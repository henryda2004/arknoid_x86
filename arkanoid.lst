     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001480 00                          ball_active db 0
   258                                  
   259 00001481 0000000000000000            ball2_x_pos:        dq 0
   260 00001489 0000000000000000            ball2_y_pos:        dq 0
   261 00001491 0000000000000000            ball2_direction_x:  dq 0
   262 00001499 0000000000000000            ball2_direction_y:  dq 0
   263 000014A1 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 000014A2 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 000014A3 0000000000000000            ball3_x_pos:        dq 0
   268 000014AB 0000000000000000            ball3_y_pos:        dq 0
   269 000014B3 0000000000000000            ball3_direction_x:  dq 0
   270 000014BB 0000000000000000            ball3_direction_y:  dq 0
   271 000014C3 00                          ball3_moving:       db 0
   272 000014C4 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 000014C5 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 000014CD [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 000014D5 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 000014DB 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 000014E1 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 000014E7 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 000014ED 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 000014F3 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 000014F9 01                          current_level db 1
   300 000014FA 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 000014FB 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   307 00001500 3D09030144                      db 61, 9, 3, 1, 'D'    ; Bloque 7
   308 00001505 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   309 0000150A 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   310 0000150F 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   311 00001514 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   312 00001519 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   313 0000151E 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   314                                  
   315                                  
   316                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   317                                  
   318                                      ; Nivel 2: Bloques de prueba
   319                                      level2_blocks:
   320 00001523 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   321                                      level2_blocks_count equ 1
   322                                  
   323                                      ; Nivel 3
   324                                      level3_blocks:
   325 00001528 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   326                                  
   327                                      level3_blocks_count equ 1
   328                                  
   329                                      ; Nivel 4
   330                                      level4_blocks:
   331 0000152D 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   332                                      level4_blocks_count equ 1
   333                                  
   334                                      ; Nivel 5
   335                                      level5_blocks:
   336 00001532 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   337                                      level5_blocks_count equ 1
   338                                  
   339                                      ; Array para mantener el estado de los bloques
   340 00001537 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   341                                  
   342                                      
   343                                      ; Variables para almacenar los valores
   344 0000159B 0000000000000000            current_score dq 0          ; Score actual
   345 000015A3 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   346                                      
   347                                      ; Buffer para convertir números a string
   348 000015A4 00<rep 14h>                 number_buffer: times 20 db 0
   349                                  
   350 000015B8 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   351                                      
   352                                      ; Estructura para los enemigos (x, y, activo)
   353 000015BD 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   354 000015DB 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   355                                      
   356 000015DC 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   357 000015E4 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   358 000015E5 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   359 000015E6 00                          enemy_move_total db 0      ; Contador total de movimientos
   360 000015E7 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 000015E8 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   362                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   363                                      ; Añade esto en la sección .dataa
   364 000015E9 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   364 000015F2 12                 
   365 000015F3 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   365 000015FC 13                 
   366 000015FD 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   366 00001606 1B                 
   367 00001607 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   367 00001610 1C                 
   368 00001611 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   368 0000161A 2D                 
   369                                          ; Arreglo de punteros a los spawn points de cada nivel
   370                                      spawn_points_table:
   371 0000161B [E915000000000000]              dq level1_spawn_points
   372 00001623 [F315000000000000]              dq level2_spawn_points
   373 0000162B [FD15000000000000]              dq level3_spawn_points
   374 00001633 [0716000000000000]              dq level4_spawn_points
   375 0000163B [1116000000000000]              dq level5_spawn_points
   376                                  
   377                                      ; Variables para el comportamiento de enemigos
   378 00001643 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   379 00001644 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   380 00001645 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   381 00001646 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   382                                  
   383 00001650 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   383 00001659 5B2020202020202020-
   383 00001662 20205D0A0D         
   384                                      score_label_len: equ $ - score_label
   385 00001667 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   385 00001670 657374727569646F73-
   385 00001679 3A205B2020205D0A0D 
   386                                      blocks_label_len: equ $ - blocks_label
   387                                      
   388                                      ; Posición donde insertar los números en los labels
   389                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   390                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   391                                      
   392                                      ; Definición de las vidas (x, y, estado)
   393                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   394                                      lives_data: 
   395 00001682 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   396 00001685 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   397 00001688 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   398 0000168B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   399 0000168E 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   400 00001691 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   401 00001694 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   402                                      lives_count equ 7    ; Total de vidas
   403 00001697 5E                          life_char db "^"    
   404 00001698 04                          current_lives db 4   ; Contador de vidas activas actual
   405                                  
   406                                  ; Estructura para almacenar las letras y sus posiciones
   407                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   408 00001699 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   409 00001829 00                          letters_count db 0   
   410 0000182A 20                          last_letter db ' '    ; Variable para almacenar la última letra
   411 0000182B 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   411 00001834 75616C3A205B205D0A-
   411 0000183D 0D                 
   412                                      last_letter_msg_len equ $ - last_letter_msg
   413 0000183E 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   414 0000183F 07                          max_lives db 7              ; Máximo número de vidas permitidas
   415 00001840 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   416 00001848 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   417 00001850 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   418                                  
   419 00001858 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   420 00001859 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   421 0000185A 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   422 00001862 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   423                                  
   424 00001863 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   425 00001864 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   426 00001865 00                          laser_count: db 0                ; Contador de láseres activos
   427 00001866 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   428 0000192E 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   429                                  
   430                                      balls_data:     ; Array para almacenar hasta 3 bolas
   431                                          ; Bola 1 (principal)
   432 00001936 0000000000000000                dq 0        ; x_pos
   433 0000193E 0000000000000000                dq 0        ; y_pos
   434 00001946 0100000000000000                dq 1        ; direction_x
   435 0000194E FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   436 00001956 01                              db 1        ; active
   437                                          ; Bola 2
   438 00001957 0000000000000000                dq 0        ; x_pos
   439 0000195F 0000000000000000                dq 0        ; y_pos
   440 00001967 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   441 0000196F FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   442 00001977 00                              db 0        ; active
   443                                          ; Bola 3
   444 00001978 0000000000000000                dq 0        ; x_pos
   445 00001980 0000000000000000                dq 0        ; y_pos
   446 00001988 0000000000000000                dq 0        ; direction_x
   447 00001990 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   448 00001998 00                              db 0        ; active
   449                                      
   450 00001999 01                          balls_count db 1     ; Contador de bolas activas
   451                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   452                                  
   453                                  
   454                                  section .text
   455                                  
   456                                  
   457                                  print_lives:
   458 000001DD 55                          push rbp
   459 000001DE 4889E5                      mov rbp, rsp
   460                                      
   461 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   462                                      
   463                                      .print_loop:
   464 000001E4 4983FC07                        cmp r12, lives_count
   465 000001E8 7D45                            jge .end
   466                                          
   467                                          ; Calcular offset de la vida actual
   468 000001EA 4C89E0                          mov rax, r12
   469 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   470 000001F1 488DB0[82160000]                lea rsi, [lives_data + rax]
   471                                          
   472                                          ; Calcular posición en el tablero
   473 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   474 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   475                                          
   476                                          ; Calcular offset en el tablero
   477 00000201 B84E000000                      mov rax, column_cells
   478 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   479 0000020A 49F7E1                          mul r9
   480 0000020D 4C01C0                          add rax, r8
   481 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   482                                          
   483                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   484 00000217 807E0201                        cmp byte [rsi + 2], 1
   485 0000021B 7405                            je .draw_active
   486                                          
   487                                          ; Si está inactiva, dibujar espacio
   488 0000021D C60720                          mov byte [rdi], ' '
   489 00000220 EB08                            jmp .next_life
   490                                          
   491                                      .draw_active:
   492                                          ; Si está activa, dibujar el símbolo de vida
   493 00000222 8A05(97160000)                  mov al, [life_char]
   494 00000228 8807                            mov [rdi], al
   495                                          
   496                                      .next_life:
   497 0000022A 49FFC4                          inc r12
   498 0000022D EBB5                            jmp .print_loop
   499                                          
   500                                      .end:
   501 0000022F 5D                              pop rbp
   502 00000230 C3                              ret
   503                                  
   504                                  ; Función para desactivar una vida
   505                                  ; Función modificada para perder una vida
   506                                  lose_life:
   507 00000231 55                          push rbp
   508 00000232 4889E5                      mov rbp, rsp
   509                                      
   510                                      ; Verificar si aún quedan vidas
   511 00000235 803D(98160000)00            cmp byte [current_lives], 0
   512 0000023C 0F8493000000                je .game_lost
   513                                      
   514                                      ; Encontrar la última vida activa
   515 00000242 B907000000                  mov rcx, lives_count
   516 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   517                                      
   518                                      .find_active_life:
   519 0000024A 4889C8                          mov rax, rcx
   520 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   521 00000251 488DB0[82160000]                lea rsi, [lives_data + rax]
   522 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   523 0000025C 7407                            je .deactivate_life
   524 0000025E 48FFC9                          dec rcx
   525 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   526 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   527                                          
   528                                      .deactivate_life:
   529                                          ; Calcular posición correcta en el tablero para borrar la vida
   530 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   531 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   532                                          
   533                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   534 0000026E B84E000000                      mov rax, column_cells
   535 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   536 00000277 49F7E1                          mul r9
   537 0000027A 4C01C0                          add rax, r8
   538 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   539                                          
   540                                          ; Borrar visualmente la vida
   541 00000284 C60720                          mov byte [rdi], ' '             
   542                                          
   543                                          ; Desactivar la vida en los datos
   544 00000287 C6460200                        mov byte [rsi + 2], 0          
   545 0000028B FE0D(98160000)                  dec byte [current_lives]
   546                                          
   547                                          ; Borrar visualmente la paleta anterior
   548 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   549 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   550                                          .erase_pallet_loop:
   551 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   552 000002A3 49FFC0                              inc r8
   553 000002A6 48FFC9                              dec rcx
   554 000002A9 75F4                                jnz .erase_pallet_loop
   555                                          
   556                                  
   557                                          ; Reiniciar posición de la bola y la paleta
   558 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   558 000002B3 000000             
   559 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   559 000002BE 000000             
   560 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   561 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   561 000002CF [36130000]         
   562                                          
   563 000002D3 EB07                            jmp .end
   564                                          
   565                                      .game_lost:
   566 000002D5 E81C000000                      call game_lost
   567 000002DA EB00                            jmp .end
   568                                          
   569                                      .end:
   570 000002DC 5D                              pop rbp
   571 000002DD C3                              ret
   572                                  ; Función modificada para verificar colisión con el borde inferior
   573                                  check_bottom_collision:
   574 000002DE 55                          push rbp
   575 000002DF 4889E5                      mov rbp, rsp
   576                                      
   577                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   578 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   579 000002E9 4883F81E                    cmp rax, row_cells - 2
   580 000002ED 7505                        jne .no_collision
   581                                      
   582                                      ; Si hay colisión, perder una vida
   583 000002EF E83DFFFFFF                  call lose_life
   584                                      
   585                                      .no_collision:
   586 000002F4 5D                              pop rbp
   587 000002F5 C3                              ret
   588                                  
   589                                  ; Nueva función para game over
   590                                  game_lost:
   591                                      ; Limpiar la pantalla
   592                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   593                                      
   594                                      ; Mostrar mensaje de derrota
   595                                      section .data
   596 0000199A C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   596 000019A3 6469646F210A0D     
   597                                          lost_msg_len: equ $ - lost_msg
   598                                      section .text
   599                                      
   600                                      ; Imprimir mensaje de derrota
   601                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [9A19000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   602                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [C819000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   603                                      
   604                                      ; Mostrar puntaje final
   605 00000347 488B05(9B150000)            mov rax, [current_score]
   606 0000034E 48BF-                       mov rdi, number_buffer
   606 00000350 [A415000000000000] 
   607 00000358 E8BA120000                  call number_to_string
   608                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [A415000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   609                                      
   610                                      ; Esperar un momento antes de salir
   611 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   611 00000381 0000               
   612 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   612 0000038C 0000               
   613                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   614                                      
   615 000003A1 E9A21A0000                  jmp exit
   616                                  
   617                                  
   618                                  ; Función para registrar una nueva letra en el mapa
   619                                  ; Entrada:
   620                                  ;   al - letra a registrar
   621                                  ;   r8b - posición x
   622                                  ;   r9b - posición y
   623                                  register_letter:
   624 000003A6 55                          push rbp
   625 000003A7 4889E5                      mov rbp, rsp
   626 000003AA 53                          push rbx
   627 000003AB 51                          push rcx
   628                                      
   629 000003AC 3C20                        cmp al, ' '
   630 000003AE 7438                        je .end
   631                                  
   632                                      ; Encontrar un espacio libre en el mapa
   633 000003B0 4831C9                      xor rcx, rcx
   634 000003B3 480FB615(29180000)          movzx rdx, byte [letters_count]
   635                                      
   636                                      .find_slot:
   637 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   638 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   639                                          
   640 000003C1 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   641 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   642 000003CD 7405                            je .found_slot
   643                                          
   644 000003CF 48FFC1                          inc rcx
   645 000003D2 EBE7                            jmp .find_slot
   646                                          
   647                                      .found_slot:
   648                                          ; Guardar la información de la letra
   649 000003D4 448803                          mov [rbx], r8b           ; x
   650 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   651 000003DB 884302                          mov [rbx + 2], al        ; letra
   652 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   653                                          
   654 000003E2 FE05(29180000)                  inc byte [letters_count]
   655                                          
   656                                      .end:
   657 000003E8 59                              pop rcx
   658 000003E9 5B                              pop rbx
   659 000003EA 5D                              pop rbp
   660 000003EB C3                              ret
   661                                  
   662                                  ; Función para imprimir todas las letras registradas
   663                                  print_letters:
   664 000003EC 55                          push rbp
   665 000003ED 4889E5                      mov rbp, rsp
   666 000003F0 53                          push rbx
   667 000003F1 51                          push rcx
   668                                      
   669 000003F2 4831C9                      xor rcx, rcx
   670                                      
   671                                      .print_loop:
   672 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   673 000003F9 7D37                            jge .end
   674                                          
   675                                          ; Obtener puntero a la letra actual
   676 000003FB 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   677                                          
   678                                          ; Verificar si está activa
   679 00000403 807B0300                        cmp byte [rbx + 3], 0
   680 00000407 7424                            je .next_letter
   681                                          
   682                                          ; Calcular posición en el tablero
   683 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   684 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   685                                          
   686                                          ; Calcular offset en el tablero
   687 00000412 B84E000000                      mov rax, column_cells
   688 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   689 0000041B 49F7E1                          mul r9
   690 0000041E 4C01C0                          add rax, r8
   691 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   692                                          
   693                                          ; Imprimir la letra
   694 00000428 8A4302                          mov al, [rbx + 2]
   695 0000042B 8807                            mov [rdi], al
   696                                          
   697                                      .next_letter:
   698 0000042D 48FFC1                          inc rcx
   699 00000430 EBC3                            jmp .print_loop
   700                                          
   701                                      .end:
   702 00000432 59                              pop rcx
   703 00000433 5B                              pop rbx
   704 00000434 5D                              pop rbp
   705 00000435 C3                              ret
   706                                  
   707                                  ; Función para borrar una letra específica
   708                                  ; Entrada:
   709                                  ;   r8b - posición x
   710                                  ;   r9b - posición y
   711                                  remove_letter:
   712 00000436 55                          push rbp
   713 00000437 4889E5                      mov rbp, rsp
   714 0000043A 53                          push rbx
   715 0000043B 51                          push rcx
   716                                      
   717 0000043C 4831C9                      xor rcx, rcx
   718                                      
   719                                      .find_loop:
   720 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   721 00000443 7D2E                            jge .end
   722                                          
   723 00000445 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   724                                          
   725                                          ; Verificar si está activa y coincide la posición
   726 0000044D 807B0300                        cmp byte [rbx + 3], 0
   727 00000451 741B                            je .next_letter
   728                                          
   729 00000453 8A03                            mov al, [rbx]
   730 00000455 4438C0                          cmp al, r8b
   731 00000458 7514                            jne .next_letter
   732                                          
   733 0000045A 8A4301                          mov al, [rbx + 1]
   734 0000045D 4438C8                          cmp al, r9b
   735 00000460 750C                            jne .next_letter
   736                                          
   737                                          ; Encontrada la letra, desactivarla
   738 00000462 C6430300                        mov byte [rbx + 3], 0
   739 00000466 FE0D(29180000)                  dec byte [letters_count]
   740 0000046C EB05                            jmp .end
   741                                          
   742                                      .next_letter:
   743 0000046E 48FFC1                          inc rcx
   744 00000471 EBCC                            jmp .find_loop
   745                                          
   746                                      .end:
   747 00000473 59                              pop rcx
   748 00000474 5B                              pop rbx
   749 00000475 5D                              pop rbp
   750 00000476 C3                              ret
   751                                  ; Función para mover las letras hacia abajo
   752                                  move_letters:
   753 00000477 55                          push rbp
   754 00000478 4889E5                      mov rbp, rsp
   755 0000047B 53                          push rbx
   756 0000047C 57                          push rdi
   757 0000047D 56                          push rsi
   758 0000047E 4150                        push r8
   759 00000480 4151                        push r9
   760 00000482 4152                        push r10
   761 00000484 4153                        push r11
   762                                  
   763 00000486 4831C9                      xor rcx, rcx
   764                                  
   765                                      .move_loop:
   766 00000489 4883F964                        cmp rcx, 100
   767 0000048D 0F8DE3010000                    jge .print_last_letter
   768                                          
   769 00000493 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   770 0000049B 807B0300                        cmp byte [rbx + 3], 0
   771 0000049F 0F84C9010000                    je .next_letter
   772                                  
   773 000004A5 4C0FB603                        movzx r8, byte [rbx]
   774 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   775                                  
   776 000004AE B84E000000                      mov rax, column_cells
   777 000004B3 4883C002                        add rax, 2
   778 000004B7 49F7E1                          mul r9
   779 000004BA 4C01C0                          add rax, r8
   780 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   781 000004C4 C60720                          mov byte [rdi], ' '
   782                                  
   783 000004C7 FE4301                          inc byte [rbx + 1]
   784 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   785                                  
   786 000004CF 4983F91F                        cmp r9, row_cells - 1
   787 000004D3 7C09                            jl .check_pallet_collision
   788                                  
   789 000004D5 C6430300                        mov byte [rbx + 3], 0
   790 000004D9 E990010000                      jmp .next_letter
   791                                  
   792                                          .check_pallet_collision:
   793 000004DE B84E000000                          mov rax, column_cells
   794 000004E3 4883C002                            add rax, 2
   795 000004E7 49F7E1                              mul r9
   796 000004EA 4C01C0                              add rax, r8
   797 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   798                                  
   799 000004F4 8A07                                mov al, [rdi]
   800 000004F6 3C20                                cmp al, ' '
   801 000004F8 0F8470010000                        je .next_letter
   802 000004FE 3C3D                                cmp al, char_equal
   803 00000500 740A                                je .capture_letter
   804                                  
   805 00000502 8A4302                              mov al, [rbx + 2]
   806 00000505 8807                                mov [rdi], al
   807 00000507 E962010000                          jmp .next_letter
   808                                  
   809                                          .capture_letter:
   810                                              ; Obtener la nueva letra
   811 0000050C 8A4302                              mov al, [rbx + 2]
   812                                              
   813                                              ; Comparar con la última letra
   814 0000050F 3A05(2A180000)                      cmp al, [last_letter]
   815 00000515 7407                                je .same_letter
   816                                              
   817                                              ; Es una letra diferente, resetear el procesamiento
   818 00000517 C605(3E180000)00                    mov byte [current_power_processed], 0
   819                                              
   820                                              .same_letter:
   821                                              ; Guardar la nueva letra
   822 0000051E 8805(2A180000)                      mov [last_letter], al
   823                                              
   824                                              ; Verificar si es 'E' para extender la paleta
   825 00000524 3C45                                cmp al, 'E'
   826 00000526 7450                                je .extend_pallet
   827                                              
   828                                              ; Verificar si es 'P' para añadir vida
   829 00000528 3C50                                cmp al, 'P'
   830 0000052A 7478                                je .check_add_life
   831                                  
   832 0000052C 3C53                                cmp al, 'S'
   833 0000052E 0F84B4000000                        je .slow_ball
   834                                  
   835 00000534 3C43                                cmp al, 'C'
   836 00000536 0F84D5000000                        je .activate_catch
   837                                              
   838 0000053C 3C4C                                cmp al, 'L'
   839 0000053E 0F84F6000000                        je .activate_laser
   840                                  
   841 00000544 3C44                                cmp al, 'D'
   842 00000546 0F8417010000                        je .activate_split
   843                                  
   844                                              ; Si no es ningún power-up, restaurar tamaño normal
   845 0000054C 488B05(4F140000)                    mov rax, [default_pallet_size]
   846 00000553 488905(47140000)                    mov [pallet_size], rax
   847 0000055A 48C705(40180000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   847 00000562 000000             
   848 00000565 C605(58180000)00                    mov byte [catch_power_active], 0
   849 0000056C C605(63180000)00                    mov byte [laser_power_active], 0
   850 00000573 E9F2000000                          jmp .finish_capture
   851                                  
   852                                              .extend_pallet:
   853 00000578 C605(63180000)00                        mov byte [laser_power_active], 0
   854 0000057F C605(58180000)00                        mov byte [catch_power_active], 0
   855 00000586 48C705(40180000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   855 0000058E 000000             
   856 00000591 488B05(57140000)                        mov rax, [extended_pallet_size]
   857 00000598 488905(47140000)                        mov [pallet_size], rax
   858 0000059F E9C6000000                              jmp .finish_capture
   859                                  
   860                                              .check_add_life:
   861 000005A4 C605(63180000)00                        mov byte [laser_power_active], 0
   862 000005AB C605(58180000)00                        mov byte [catch_power_active], 0
   863 000005B2 488B05(4F140000)                        mov rax, [default_pallet_size]
   864 000005B9 488905(47140000)                        mov [pallet_size], rax
   865 000005C0 48C705(40180000)01-                     mov qword [ball_speed], 1 
   865 000005C8 000000             
   866                                                  ; Verificar si ya procesamos este power-up
   867 000005CB 803D(3E180000)00                        cmp byte [current_power_processed], 0
   868 000005D2 0F8592000000                            jne .finish_capture
   869                                                  
   870                                                  ; Preservar registros importantes
   871 000005D8 51                                      push rcx
   872 000005D9 53                                      push rbx
   873                                                  
   874                                                  ; Marcar como procesado
   875 000005DA C605(3E180000)01                        mov byte [current_power_processed], 1
   876                                                  
   877                                                  ; Añadir una vida
   878 000005E1 E80E040000                              call add_life
   879                                                  
   880                                                  ; Restaurar registros
   881 000005E6 5B                                      pop rbx
   882 000005E7 59                                      pop rcx
   883                                                  
   884                                              .slow_ball:
   885 000005E8 C605(63180000)00                        mov byte [laser_power_active], 0
   886 000005EF C605(58180000)00                        mov byte [catch_power_active], 0                
   887 000005F6 488B05(4F140000)                        mov rax, [default_pallet_size]
   888 000005FD 488905(47140000)                        mov [pallet_size], rax
   889 00000604 48C705(40180000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   889 0000060C 000000             
   890 0000060F EB59                                    jmp .finish_capture
   891                                  
   892                                              .activate_catch:
   893 00000611 C605(63180000)00                        mov byte [laser_power_active], 0
   894 00000618 488B05(4F140000)                        mov rax, [default_pallet_size]
   895 0000061F 488905(47140000)                        mov [pallet_size], rax
   896 00000626 48C705(40180000)01-                     mov qword [ball_speed], 1
   896 0000062E 000000             
   897 00000631 C605(58180000)01                        mov byte [catch_power_active], 1
   898 00000638 EB30                                    jmp .finish_capture
   899                                  
   900                                              .activate_laser:
   901 0000063A C605(58180000)00                        mov byte [catch_power_active], 0
   902 00000641 488B05(4F140000)                        mov rax, [default_pallet_size]
   903 00000648 488905(47140000)                        mov [pallet_size], rax
   904 0000064F 48C705(40180000)01-                     mov qword [ball_speed], 1
   904 00000657 000000             
   905 0000065A C605(63180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   906 00000661 EB07                                    jmp .finish_capture
   907                                  
   908                                              .activate_split:
   909 00000663 E8D2000000                              call activate_split_power
   910 00000668 EB00                                    jmp .finish_capture
   911                                  
   912                                              .finish_capture:
   913 0000066A C6430300                                mov byte [rbx + 3], 0
   914                                  
   915                                          .next_letter:
   916 0000066E 48FFC1                              inc rcx
   917 00000671 E913FEFFFF                          jmp .move_loop
   918                                  
   919                                      .print_last_letter:
   920                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000676 B801000000          <1>  mov eax, sys_write
    83 0000067B BF01000000          <1>  mov edi, 1
    84 00000680 48BE-               <1>  mov rsi, %1
    84 00000682 [2B18000000000000]  <1>
    85 0000068A BA10000000          <1>  mov edx, %2
    86 0000068F 0F05                <1>  syscall
   921 00000691 8A05(2A180000)                  mov al, [last_letter]
   922 00000697 8805(3A180000)                  mov [last_letter_msg + 15], al
   923                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000069D B801000000          <1>  mov eax, sys_write
    83 000006A2 BF01000000          <1>  mov edi, 1
    84 000006A7 48BE-               <1>  mov rsi, %1
    84 000006A9 [3B18000000000000]  <1>
    85 000006B1 BA03000000          <1>  mov edx, %2
    86 000006B6 0F05                <1>  syscall
   924                                  
   925                                      .end:
   926 000006B8 415B                            pop r11
   927 000006BA 415A                            pop r10
   928 000006BC 4159                            pop r9
   929 000006BE 4158                            pop r8
   930 000006C0 5E                              pop rsi
   931 000006C1 5F                              pop rdi
   932 000006C2 5B                              pop rbx
   933 000006C3 5D                              pop rbp
   934 000006C4 C3                              ret
   935                                  
   936                                  
   937                                  clear_lasers:
   938 000006C5 55                          push rbp
   939 000006C6 4889E5                      mov  rbp, rsp
   940                                  
   941                                      ; Recorrer el array de láseres
   942 000006C9 4831C9                      xor rcx, rcx                ; Índice del láser
   943 000006CC 480FB61D(65180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   944                                  
   945                                      .clear_loop:
   946 000006D4 4839D9                          cmp rcx, rbx
   947 000006D7 7D2F                            jge .done                ; Salir si no quedan láseres
   948                                  
   949                                          ; Obtener posición del láser actual
   950 000006D9 488DB409[66180000]              lea rsi, [lasers + rcx * 2]
   951 000006E1 4C0FB606                        movzx r8, byte [rsi]     ; X
   952 000006E5 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
   953                                  
   954                                          ; Calcular posición en el tablero
   955 000006EA B84E000000                      mov rax, column_cells
   956 000006EF 4883C002                        add rax, 2
   957 000006F3 49F7E1                          mul r9
   958 000006F6 4C01C0                          add rax, r8
   959 000006F9 488DB8[000A0000]                lea rdi, [board + rax]
   960                                  
   961                                          ; Borrar el láser visualmente
   962 00000700 C60720                          mov byte [rdi], ' '
   963                                  
   964                                          ; Pasar al siguiente láser
   965 00000703 48FFC1                          inc rcx
   966 00000706 EBCC                            jmp .clear_loop
   967                                  
   968                                      .done:
   969                                          ; Resetear contador de láseres
   970 00000708 C605(65180000)00                mov byte [laser_count], 0
   971                                  
   972 0000070F 5D                              pop rbp
   973 00000710 C3                              ret
   974                                  
   975                                  
   976                                  ; Nueva función para actualizar los láseres
   977                                  update_lasers:
   978 00000711 55                          push rbp
   979 00000712 4889E5                      mov rbp, rsp
   980                                      
   981                                      ; Verificar si el poder láser está activo
   982 00000715 803D(63180000)00            cmp byte [laser_power_active], 0
   983 0000071C 741A                        je .end
   984                                      
   985                                      ; Verificar si se presionó la tecla de espacio
   986 0000071E 803D(62180000)20            cmp byte [last_key], ' '
   987 00000725 750C                        jne .skip_shooting
   988                                      
   989                                      ; Disparar nuevos láseres
   990 00000727 E89A000000                  call shoot_lasers
   991 0000072C C605(62180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   992                                      
   993                                      .skip_shooting:
   994                                      ; Mover los láseres existentes
   995 00000733 E828010000                  call move_lasers
   996                                      
   997                                      .end:
   998 00000738 5D                              pop rbp
   999 00000739 C3                              ret
  1000                                  
  1001                                  activate_split_power:
  1002 0000073A 55                          push rbp
  1003 0000073B 4889E5                      mov rbp, rsp
  1004                                      
  1005                                      ; Verificar si la bola2 y bola3 ya están activas
  1006 0000073E 803D(A2140000)01            cmp byte [ball2_active], 1
  1007 00000745 750B                        jne .enable_balls
  1008 00000747 803D(C4140000)01            cmp byte [ball3_active], 1
  1009 0000074E 7502                        jne .enable_balls
  1010                                      
  1011                                      ; Si ambas ya están activas, no hacemos nada.
  1012 00000750 EB72                        jmp .end
  1013                                  
  1014                                  .enable_balls:
  1015                                      ; Copiamos la posición de la bola principal
  1016 00000752 488B05(5F140000)            mov rax, [ball_x_pos]
  1017 00000759 488905(81140000)            mov [ball2_x_pos], rax
  1018 00000760 488905(A3140000)            mov [ball3_x_pos], rax
  1019                                  
  1020 00000767 488B05(67140000)            mov rax, [ball_y_pos]
  1021 0000076E 488905(89140000)            mov [ball2_y_pos], rax
  1022 00000775 488905(AB140000)            mov [ball3_y_pos], rax
  1023                                  
  1024                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1025                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1026 0000077C 48C705(91140000)FF-         mov qword [ball2_direction_x], -1
  1026 00000784 FFFFFF             
  1027 00000787 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  1027 0000078F FFFFFF             
  1028 00000792 C605(A1140000)01            mov byte [ball2_moving], 1
  1029 00000799 C605(A2140000)01            mov byte [ball2_active], 1
  1030                                  
  1031 000007A0 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  1031 000007A8 000000             
  1032 000007AB 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  1032 000007B3 FFFFFF             
  1033 000007B6 C605(C3140000)01            mov byte [ball3_moving], 1
  1034 000007BD C605(C4140000)01            mov byte [ball3_active], 1
  1035                                  
  1036                                  .end:
  1037 000007C4 5D                          pop rbp
  1038 000007C5 C3                          ret
  1039                                  
  1040                                  
  1041                                  shoot_lasers:
  1042 000007C6 55                          push rbp
  1043 000007C7 4889E5                      mov rbp, rsp
  1044 000007CA 53                          push rbx
  1045                                      
  1046                                      ; Verificar si hay espacio para más láseres
  1047 000007CB 480FB605(65180000)          movzx rax, byte [laser_count]
  1048 000007D3 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1049 000007D7 0F8D80000000                jge .end
  1050                                      
  1051                                      ; Obtener posición de la paleta
  1052 000007DD 4C8B05(3F140000)            mov r8, [pallet_position]
  1053 000007E4 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
  1054                                      
  1055                                      ; Calcular coordenadas x,y
  1056 000007EB 4C89C0                      mov rax, r8
  1057 000007EE 41B94E000000                mov r9, column_cells
  1058 000007F4 4983C102                    add r9, 2                     ; Ancho total de línea
  1059 000007F8 4831D2                      xor rdx, rdx
  1060 000007FB 49F7F1                      div r9                        ; rax = y, rdx = x
  1061                                      
  1062                                      ; Guardar coordenadas
  1063 000007FE 4989C2                      mov r10, rax                  ; Y en r10
  1064 00000801 4989D3                      mov r11, rdx                  ; X en r11
  1065                                      
  1066                                      ; Validar coordenadas
  1067 00000804 4983FA00                    cmp r10, 0
  1068 00000808 7C53                        jl .end
  1069 0000080A 4983FA20                    cmp r10, row_cells
  1070 0000080E 7D4D                        jge .end
  1071 00000810 4983FB00                    cmp r11, 0
  1072 00000814 7C47                        jl .end
  1073 00000816 4983FB4E                    cmp r11, column_cells
  1074 0000081A 7D41                        jge .end
  1075                                      
  1076                                      ; Calcular índice para el primer láser
  1077 0000081C 480FB61D(65180000)          movzx rbx, byte [laser_count]
  1078 00000824 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1079                                      
  1080                                      ; Primer láser (izquierda)
  1081 00000828 488DBB[66180000]            lea rdi, [lasers + rbx]
  1082 0000082F 44881F                      mov [rdi], r11b              ; X
  1083 00000832 4488D0                      mov al, r10b
  1084 00000835 FEC8                        dec al                       ; Y - 1
  1085 00000837 884701                      mov [rdi + 1], al           ; Y
  1086                                      
  1087                                      ; Segundo láser (derecha)
  1088 0000083A 4488D8                      mov al, r11b
  1089 0000083D 0205(47140000)              add al, byte [pallet_size]
  1090 00000843 FEC8                        dec al                       ; Ajustar para el último carácter
  1091 00000845 488DBB[68180000]            lea rdi, [lasers + rbx + 2]
  1092 0000084C 8807                        mov [rdi], al               ; X
  1093 0000084E 4488D0                      mov al, r10b
  1094 00000851 FEC8                        dec al                      ; Y - 1
  1095 00000853 884701                      mov [rdi + 1], al          ; Y
  1096                                      
  1097                                      ; Incrementar contador de láseres
  1098 00000856 8005(65180000)02            add byte [laser_count], 2
  1099                                      
  1100                                      
  1101                                      .end:
  1102 0000085D 5B                              pop rbx
  1103 0000085E 5D                              pop rbp
  1104 0000085F C3                              ret
  1105                                  
  1106                                  ; Función corregida para mover láseres
  1107                                  ; Función corregida para mover láseres
  1108                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1109                                  
  1110                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1111                                  ; ============================================================
  1112                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1113                                  ; ============================================================
  1114                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1115                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1116                                  ; ============================================================
  1117                                  move_lasers:
  1118 00000860 55                          push rbp
  1119 00000861 4889E5                      mov  rbp, rsp
  1120 00000864 53                          push rbx
  1121 00000865 57                          push rdi
  1122 00000866 56                          push rsi
  1123 00000867 4154                        push r12
  1124 00000869 4155                        push r13
  1125 0000086B 4156                        push r14
  1126 0000086D 4157                        push r15
  1127                                  
  1128                                      ; 1) Tomamos la cantidad de láseres
  1129 0000086F 480FB60D(65180000)          movzx rcx, byte [laser_count]
  1130 00000877 4885C9                      test rcx, rcx
  1131 0000087A 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1132                                  
  1133                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1134 00000880 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1135                                  
  1136                                  .loop_lasers:
  1137                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1138 00000883 488DB409[66180000]          lea rsi, [lasers + rcx*2]
  1139                                  
  1140                                      ; 2) Cargar x,y actuales del láser
  1141 0000088B 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1142 0000088F 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1143                                  
  1144                                      ; 3) Borrar el láser de su posición actual en pantalla
  1145                                      ;    (por si en el ciclo anterior se había dibujado)
  1146 00000894 B84E000000                  mov rax, column_cells
  1147 00000899 4883C002                    add rax, 2
  1148 0000089D 49F7E1                      mul r9
  1149 000008A0 4C01C0                      add rax, r8
  1150 000008A3 488DB8[000A0000]            lea rdi, [board + rax]
  1151 000008AA C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1152                                  
  1153                                      ; 4) Mover el láser hacia arriba (y - 1)
  1154 000008AD 49FFC9                      dec r9
  1155                                  
  1156                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1157 000008B0 4983F901                    cmp r9, 1
  1158 000008B4 7C57                        jl .delete_laser
  1159                                  
  1160                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1161 000008B6 44884E01                    mov byte [rsi + 1], r9b
  1162                                  
  1163                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1164                                      ;    - Primero colisión con bloques
  1165                                      ; ---------------------------------------------------------
  1166                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1167 000008BA B84E000000                  mov rax, column_cells
  1168 000008BF 4883C002                    add rax, 2
  1169 000008C3 49F7E1                      mul r9
  1170 000008C6 4C01C0                      add rax, r8
  1171 000008C9 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1172                                  
  1173                                      ; Revisar si hay bloque
  1174 000008D0 51                          push rcx
  1175 000008D1 56                          push rsi
  1176 000008D2 57                          push rdi
  1177 000008D3 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1178 000008D6 E8940E0000                  call check_block_collision
  1179 000008DB 5F                          pop rdi
  1180 000008DC 5E                          pop rsi
  1181 000008DD 59                          pop rcx
  1182                                  
  1183 000008DE 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1184 000008E1 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1185                                  
  1186                                      ;    - Luego colisión con enemigos
  1187                                      ; ---------------------------------------------------------
  1188 000008E3 51                          push rcx
  1189 000008E4 56                          push rsi
  1190 000008E5 57                          push rdi
  1191                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1192                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1193                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1194                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1195                                      ;
  1196                                      ; Hacemos algo como:
  1197 000008E6 4989FA                      mov r10, rdi
  1198 000008E9 E85A000000                  call check_laser_enemy_collision
  1199 000008EE 5F                          pop rdi
  1200 000008EF 5E                          pop rsi
  1201 000008F0 59                          pop rcx
  1202                                  
  1203 000008F1 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1204 000008F4 7517                        jnz .delete_laser
  1205                                  
  1206                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1207 000008F6 8A05(64180000)              mov al, [laser_symbol]
  1208 000008FC 8807                        mov [rdi], al
  1209                                  
  1210                                  .next_laser:
  1211                                      ; Pasamos al láser anterior en el array
  1212 000008FE 48FFC9                      dec rcx
  1213 00000901 4883F9FF                    cmp rcx, -1
  1214 00000905 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1215 0000090B EB2E                        jmp .fin
  1216                                  
  1217                                  ; -----------------------------------------------------------------
  1218                                  ; Subrutina interna: .delete_laser
  1219                                  ; -----------------------------------------------------------------
  1220                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1221                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1222                                  .delete_laser:
  1223 0000090D 4C0FB625(65180000)          movzx r12, byte [laser_count]
  1224 00000915 49FFCC                      dec r12                    ; r12 = índice del último láser
  1225 00000918 4939CC                      cmp r12, rcx
  1226 0000091B 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1227                                  
  1228                                      ; Copiamos el último láser a la posición actual
  1229 0000091D 488DBC09[66180000]          lea rdi, [lasers + rcx*2]
  1230 00000925 4B8DB424[66180000]          lea rsi, [lasers + r12*2]
  1231 0000092D 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1232 00000930 668907                      mov [rdi], ax             ; copiamos X,Y
  1233                                  
  1234                                  .just_decrement:
  1235 00000933 FE0D(65180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1236 00000939 EBC3                        jmp .next_laser
  1237                                  
  1238                                  .fin:
  1239 0000093B 415F                        pop r15
  1240 0000093D 415E                        pop r14
  1241 0000093F 415D                        pop r13
  1242 00000941 415C                        pop r12
  1243 00000943 5E                          pop rsi
  1244 00000944 5F                          pop rdi
  1245 00000945 5B                          pop rbx
  1246 00000946 5D                          pop rbp
  1247 00000947 C3                          ret
  1248                                  
  1249                                  
  1250                                  ; Nueva función para verificar colisión entre láser y enemigos
  1251                                  ; ==========================================================
  1252                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1253                                  ; ==========================================================
  1254                                  check_laser_enemy_collision:
  1255 00000948 55                          push rbp
  1256 00000949 4889E5                      mov  rbp, rsp
  1257                                      
  1258 0000094C 4D31ED                      xor r13, r13            ; Índice del enemigo
  1259 0000094F 4831C0                      xor rax, rax            ; 0 = no colisión
  1260                                  
  1261                                  .loop_enemies:
  1262 00000952 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1263 00000956 7D64                        jge .end
  1264                                  
  1265                                      ; r13 * 3 => offset del enemigo i
  1266 00000958 4C89E9                      mov rcx, r13
  1267 0000095B 486BC903                    imul rcx, 3
  1268 0000095F 488DB1[BD150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1269                                  
  1270                                      ; Verificar si está activo
  1271 00000966 807E0201                    cmp byte [rsi+2], 1
  1272 0000096A 754B                        jne .next_enemy
  1273                                  
  1274                                      ; Cargar posición X/Y del enemigo
  1275 0000096C 4C0FB636                    movzx r14, byte [rsi]      ; X
  1276 00000970 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1277                                  
  1278                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1279 00000975 4D39F0                      cmp r8, r14
  1280 00000978 753D                        jne .next_enemy
  1281 0000097A 4D39F9                      cmp r9, r15
  1282 0000097D 7538                        jne .next_enemy
  1283                                  
  1284                                      ; ==== Colisión detectada con láser ====
  1285                                  
  1286                                      ; 1) Desactivar enemigo
  1287 0000097F C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1288                                  
  1289                                      ; 2) Sumar puntos
  1290 00000983 488B05(DC150000)            mov rax, [enemy_points]
  1291 0000098A 480105(9B150000)            add [current_score], rax
  1292                                  
  1293                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1294                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1295 00000991 4983FF1E                    cmp r15, row_cells - 2
  1296 00000995 7419                        je .skip_erase
  1297                                  
  1298                                      ; Borrar visualmente del board
  1299 00000997 B84E000000                  mov rax, column_cells
  1300 0000099C 4883C002                    add rax, 2
  1301 000009A0 49F7E7                      mul r15
  1302 000009A3 4C01F0                      add rax, r14
  1303 000009A6 488DB8[000A0000]            lea rdi, [board + rax]
  1304 000009AD C60720                      mov byte [rdi], ' '
  1305                                  
  1306                                  .skip_erase:
  1307                                  
  1308                                      ; 4) Devolver rax=1 => colisión con enemigo
  1309 000009B0 B801000000                  mov rax, 1
  1310 000009B5 EB05                        jmp .end
  1311                                  
  1312                                  .next_enemy:
  1313 000009B7 49FFC5                      inc r13
  1314 000009BA EB96                        jmp .loop_enemies
  1315                                  
  1316                                  .end:
  1317 000009BC 5D                          pop rbp
  1318 000009BD C3                          ret
  1319                                  
  1320                                  
  1321                                  ; Función auxiliar para eliminar un láser específico
  1322                                  remove_laser:
  1323 000009BE 55                          push rbp
  1324 000009BF 4889E5                      mov rbp, rsp
  1325                                  
  1326                                      ; Borrar el láser del tablero
  1327 000009C2 41C60220                    mov byte [r10], ' '
  1328                                  
  1329                                      ; Mover el último láser a esta posición si no es el último
  1330 000009C6 480FB605(65180000)          movzx rax, byte [laser_count]
  1331 000009CE 48FFC8                      dec rax                    ; Índice del último láser
  1332 000009D1 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1333 000009D4 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1334                                  
  1335                                      ; Copiar último láser a la posición actual
  1336 000009D6 4B8DBC24[66180000]          lea rdi, [lasers + r12*2]
  1337 000009DE 488DB400[66180000]          lea rsi, [lasers + rax*2]
  1338 000009E6 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1339 000009E9 668917                      mov [rdi], dx
  1340                                  
  1341                                  .just_decrease:
  1342 000009EC FE0D(65180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1343                                  
  1344 000009F2 5D                          pop rbp
  1345 000009F3 C3                          ret
  1346                                  
  1347                                  add_life:
  1348 000009F4 55                          push rbp
  1349 000009F5 4889E5                      mov rbp, rsp
  1350 000009F8 53                          push rbx
  1351 000009F9 51                          push rcx
  1352 000009FA 57                          push rdi
  1353 000009FB 56                          push rsi
  1354 000009FC 4150                        push r8
  1355 000009FE 4151                        push r9
  1356                                      
  1357                                      ; Verificar si ya tenemos el máximo de vidas
  1358 00000A00 480FB605(98160000)          movzx rax, byte [current_lives]
  1359 00000A08 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1360 00000A0C 7D2C                        jge .end
  1361                                      
  1362                                      ; Incrementar el contador de vidas
  1363 00000A0E FE05(98160000)              inc byte [current_lives]
  1364                                      
  1365                                      ; Encontrar la siguiente vida inactiva
  1366 00000A14 4831C9                      xor rcx, rcx
  1367                                      
  1368                                      .find_inactive:
  1369 00000A17 4883F907                        cmp rcx, lives_count
  1370 00000A1B 7D1D                            jge .end
  1371                                          
  1372                                          ; Calcular offset de la vida actual
  1373 00000A1D 4889C8                          mov rax, rcx
  1374 00000A20 486BC003                        imul rax, 3
  1375 00000A24 488DB0[82160000]                lea rsi, [lives_data + rax]
  1376                                          
  1377                                          ; Verificar si está inactiva
  1378 00000A2B 807E0200                        cmp byte [rsi + 2], 0
  1379 00000A2F 7405                            je .activate_life
  1380                                          
  1381 00000A31 48FFC1                          inc rcx
  1382 00000A34 EBE1                            jmp .find_inactive
  1383                                          
  1384                                      .activate_life:
  1385                                          ; Activar la vida
  1386 00000A36 C6460201                        mov byte [rsi + 2], 1
  1387                                          
  1388                                      .end:
  1389 00000A3A 4159                            pop r9
  1390 00000A3C 4158                            pop r8
  1391 00000A3E 5E                              pop rsi
  1392 00000A3F 5F                              pop rdi
  1393 00000A40 59                              pop rcx
  1394 00000A41 5B                              pop rbx
  1395 00000A42 5D                              pop rbp
  1396 00000A43 C3                              ret
  1397                                  
  1398                                  
  1399                                  print_ball:
  1400 00000A44 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1401 00000A4B 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1402 00000A52 4981C0[000A0000]        	add r8, board
  1403                                  
  1404 00000A59 4C89C9                  	mov rcx, r9
  1405 00000A5C B850000000              	mov rax, column_cells + 2
  1406 00000A61 48F7E9                  	imul rcx
  1407                                  	
  1408 00000A64 4901C0                  	add r8, rax
  1409 00000A67 41C6004F                	mov byte [r8], char_O
  1410 00000A6B C3                      	ret
  1411                                  
  1412                                  print_ball_2:
  1413 00000A6C 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1414 00000A73 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1415 00000A7A 4981C0[000A0000]            add r8, board
  1416 00000A81 4C89C9                      mov rcx, r9
  1417 00000A84 B850000000                  mov rax, column_cells + 2
  1418 00000A89 48F7E9                      imul rcx
  1419 00000A8C 4901C0                      add r8, rax
  1420 00000A8F 41C6004F                    mov byte [r8], char_O
  1421 00000A93 C3                          ret
  1422                                  
  1423                                  print_ball_3:
  1424 00000A94 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1425 00000A9B 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1426 00000AA2 4981C0[000A0000]            add r8, board
  1427 00000AA9 4C89C9                      mov rcx, r9
  1428 00000AAC B850000000                  mov rax, column_cells + 2
  1429 00000AB1 48F7E9                      imul rcx
  1430 00000AB4 4901C0                      add r8, rax
  1431 00000AB7 41C6004F                    mov byte [r8], char_O
  1432 00000ABB C3                          ret
  1433                                  
  1434                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1435                                  	
  1436                                  print_pallet:
  1437                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1438 00000ABC 4C8B05(3F140000)            mov r8, [pallet_position]
  1439 00000AC3 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1440                                      .clear_pallet:
  1441 00000ACA 41C60020                        mov byte [r8], char_space
  1442 00000ACE 49FFC0                          inc r8
  1443 00000AD1 48FFC9                          dec rcx
  1444 00000AD4 75F4                            jnz .clear_pallet
  1445                                  
  1446                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1447 00000AD6 4C8B05(3F140000)            mov r8, [pallet_position]
  1448 00000ADD 488B0D(47140000)            mov rcx, [pallet_size]
  1449                                      .write_pallet:
  1450 00000AE4 41C6003D                        mov byte [r8], char_equal
  1451 00000AE8 49FFC0                          inc r8
  1452 00000AEB 48FFC9                          dec rcx
  1453 00000AEE 75F4                            jnz .write_pallet
  1454                                  
  1455 00000AF0 C3                          ret
  1456                                  
  1457                                  move_pallet:
  1458                                      
  1459 00000AF1 803D(7F140000)00            cmp byte [ball_moving], 0
  1460 00000AF8 7507                        jne .continue_movement
  1461 00000AFA C605(7F140000)01            mov byte [ball_moving], 1
  1462                                  
  1463                                      .continue_movement:
  1464 00000B01 4883FFFF                        cmp rdi, left_direction
  1465 00000B05 7531                            jne .move_right
  1466                                  
  1467                                          .move_left:
  1468                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1469 00000B07 4C8B05(3F140000)                    mov r8, [pallet_position]
  1470 00000B0E 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1471 00000B11 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1472 00000B14 3C58                                cmp al, 'X'        ; Comparar si es una X
  1473 00000B16 744E                                je .end            ; Si es X, no mover
  1474                                              
  1475 00000B18 4C8B05(3F140000)                    mov r8, [pallet_position]
  1476 00000B1F 4C8B0D(47140000)                    mov r9, [pallet_size]
  1477 00000B26 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1478 00000B2C 49FFC8                              dec r8
  1479 00000B2F 4C8905(3F140000)                    mov [pallet_position], r8
  1480 00000B36 EB2E                                jmp .end
  1481                                              
  1482                                          .move_right:
  1483                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1484 00000B38 4C8B05(3F140000)                    mov r8, [pallet_position]
  1485 00000B3F 4C8B0D(47140000)                    mov r9, [pallet_size]
  1486 00000B46 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1487 00000B49 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1488 00000B4D 3C58                                cmp al, 'X'        ; Comparar si es una X
  1489 00000B4F 7415                                je .end            ; Si es X, no mover
  1490                                              
  1491 00000B51 4C8B05(3F140000)                    mov r8, [pallet_position]
  1492 00000B58 41C60020                            mov byte [r8], char_space
  1493 00000B5C 49FFC0                              inc r8
  1494 00000B5F 4C8905(3F140000)                    mov [pallet_position], r8
  1495                                          .end:
  1496 00000B66 C3                                  ret
  1497                                  
  1498                                  
  1499                                  
  1500                                              
  1501                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1502                                  update_caught_ball_position:
  1503 00000B67 55                          push rbp
  1504 00000B68 4889E5                      mov rbp, rsp
  1505                                      
  1506                                      ; Calcular la nueva posición de la bola basada en la paleta
  1507 00000B6B 4C8B05(3F140000)            mov r8, [pallet_position]
  1508 00000B72 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1509 00000B79 B850000000                  mov rax, column_cells + 2
  1510 00000B7E 4831D2                      xor rdx, rdx
  1511 00000B81 48F7F0                      div rax                ; División para obtener X,Y
  1512                                      
  1513                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1514 00000B84 4989C1                      mov r9, rax            ; Y de la paleta
  1515 00000B87 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1516                                      
  1517                                      ; Añadir el offset guardado a la posición X
  1518 00000B8A 4889D0                      mov rax, rdx
  1519 00000B8D 480305(5A180000)            add rax, [ball_catch_offset]
  1520 00000B94 488905(5F140000)            mov [ball_x_pos], rax
  1521 00000B9B 4C890D(67140000)            mov [ball_y_pos], r9
  1522                                      
  1523 00000BA2 5D                          pop rbp
  1524 00000BA3 C3                          ret
  1525                                  
  1526                                  
  1527                                  move_all_balls:
  1528 00000BA4 55                          push rbp
  1529 00000BA5 4889E5                      mov rbp, rsp
  1530 00000BA8 53                          push rbx
  1531                                      
  1532                                      ; Inicializar contador de bolas
  1533 00000BA9 4831DB                      xor rbx, rbx
  1534                                      
  1535                                  .loop_balls:
  1536                                      ; Verificar si hemos procesado todas las bolas
  1537 00000BAC 3A1D(99190000)              cmp bl, byte [balls_count]
  1538 00000BB2 7D1D                        jge .end
  1539                                      
  1540                                      ; Calcular offset de la bola actual
  1541 00000BB4 B821000000                  mov rax, BALL_STRUCT_SIZE
  1542 00000BB9 48F7E3                      mul rbx
  1543                                      
  1544                                      ; Verificar si la bola está activa
  1545 00000BBC 80B8[56190000]01            cmp byte [balls_data + rax + 32], 1
  1546 00000BC3 7507                        jne .next_ball
  1547                                      
  1548                                      ; Guardar offset en la pila
  1549 00000BC5 50                          push rax
  1550                                      
  1551                                      ; Llamar a move_ball con los parámetros de esta bola
  1552 00000BC6 E809000000                  call move_ball
  1553                                      
  1554                                      ; Restaurar offset
  1555 00000BCB 58                          pop rax
  1556                                      
  1557                                  .next_ball:
  1558 00000BCC 48FFC3                      inc rbx
  1559 00000BCF EBDB                        jmp .loop_balls
  1560                                      
  1561                                  .end:
  1562 00000BD1 5B                          pop rbx
  1563 00000BD2 5D                          pop rbp
  1564 00000BD3 C3                          ret
  1565                                  
  1566                                  move_ball:
  1567                                  
  1568 00000BD4 803D(59180000)01            cmp byte [ball_caught], 1
  1569 00000BDB 0F849D000000                je .move_with_pallet
  1570                                  
  1571 00000BE1 803D(7F140000)00            cmp byte [ball_moving], 0
  1572 00000BE8 0F84B8010000                je .end
  1573                                  
  1574                                      ; Incrementar contador de velocidad
  1575 00000BEE 48FF05(50180000)            inc qword [speed_counter]
  1576                                      
  1577                                      ; Verificar si debemos mover la bola en este ciclo
  1578 00000BF5 488B05(50180000)            mov rax, [speed_counter]
  1579 00000BFC 483B05(40180000)            cmp rax, [ball_speed]
  1580 00000C03 0F8C9D010000                jl .end
  1581                                      
  1582                                      ; Resetear contador de velocidad
  1583 00000C09 48C705(50180000)00-         mov qword [speed_counter], 0
  1583 00000C11 000000             
  1584                                  
  1585                                      ; Borrar la posición actual de la bola
  1586 00000C14 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1587 00000C1B 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1588 00000C22 4981C0[000A0000]            add r8, board
  1589 00000C29 4C89C9                      mov rcx, r9
  1590 00000C2C B850000000                  mov rax, column_cells + 2
  1591 00000C31 48F7E9                      imul rcx
  1592 00000C34 4901C0                      add r8, rax
  1593 00000C37 41C60020                    mov byte [r8], char_space
  1594                                  
  1595                                      ; Calcular siguiente posición X
  1596 00000C3B 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1597 00000C42 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1598 00000C49 488B05(6F140000)            mov rax, [ball_direction_x]
  1599 00000C50 4901C0                      add r8, rax               ; Nueva posición X
  1600                                  
  1601                                      ; Calcular la dirección de memoria para la siguiente posición
  1602 00000C53 4D89C2                      mov r10, r8
  1603 00000C56 4981C2[000A0000]            add r10, board
  1604 00000C5D 4C89C9                      mov rcx, r9
  1605 00000C60 B850000000                  mov rax, column_cells + 2
  1606 00000C65 48F7E9                      imul rcx
  1607 00000C68 4901C2                      add r10, rax
  1608                                  
  1609                                      ; Verificar si hay una X en la siguiente posición X
  1610 00000C6B 418A02                      mov al, [r10]
  1611 00000C6E 3C58                        cmp al, 'X'
  1612 00000C70 7565                        jne .check_block_x
  1613 00000C72 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1614 00000C79 E928010000                  jmp .end
  1615                                  
  1616                                      .move_with_pallet:
  1617                                          ; Borrar la posición actual de la bola
  1618 00000C7E 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1619 00000C85 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1620 00000C8C 4D89C2                          mov r10, r8
  1621 00000C8F 4981C2[000A0000]                add r10, board
  1622 00000C96 4C89C9                          mov rcx, r9
  1623 00000C99 B850000000                      mov rax, column_cells + 2
  1624 00000C9E 48F7E9                          imul rcx
  1625 00000CA1 4901C2                          add r10, rax
  1626 00000CA4 41C60220                        mov byte [r10], char_space
  1627                                  
  1628                                          ; Actualizar posición X basada en la paleta
  1629 00000CA8 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1630 00000CAF 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1631 00000CB6 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1632 00000CBD 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1633                                  
  1634                                          ; Mantener la bola una posición arriba de la paleta
  1635 00000CC4 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1636 00000CCB 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1637                                  
  1638 00000CD2 E9CF000000                      jmp .end
  1639                                  
  1640                                  
  1641                                      .check_block_x:
  1642                                          ; Verificar colisión con bloques en X
  1643 00000CD7 4150                            push r8     ; Guardar registros que usa check_block_collision
  1644 00000CD9 4151                            push r9
  1645 00000CDB 4152                            push r10
  1646 00000CDD E88D0A0000                      call check_block_collision
  1647 00000CE2 415A                            pop r10
  1648 00000CE4 4159                            pop r9
  1649 00000CE6 4158                            pop r8
  1650 00000CE8 4885C0                          test rax, rax
  1651 00000CEB 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1652 00000CED 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1653 00000CF4 E9AD000000                      jmp .end
  1654                                  
  1655                                      .check_paddle_x:
  1656                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1657 00000CF9 41803A3D                        cmp byte [r10], char_equal
  1658 00000CFD 750C                            jne .check_y_movement
  1659 00000CFF 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1660 00000D06 E99B000000                      jmp .end
  1661                                  
  1662                                      .check_y_movement:
  1663                                          ; Calcular siguiente posición Y
  1664 00000D0B 488B05(77140000)                mov rax, [ball_direction_y]
  1665 00000D12 4901C1                          add r9, rax                  ; Nueva posición Y
  1666                                  
  1667                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1668 00000D15 4D89C2                          mov r10, r8
  1669 00000D18 4981C2[000A0000]                add r10, board
  1670 00000D1F 4C89C9                          mov rcx, r9
  1671 00000D22 B850000000                      mov rax, column_cells + 2
  1672 00000D27 48F7E9                          imul rcx
  1673 00000D2A 4901C2                          add r10, rax
  1674                                  
  1675                                          ; Verificar si hay una X en la siguiente posición Y
  1676 00000D2D 418A02                          mov al, [r10]
  1677 00000D30 3C58                            cmp al, 'X'
  1678 00000D32 7509                            jne .check_block_y
  1679 00000D34 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1680 00000D3B EB69                            jmp .end
  1681                                  
  1682                                      .check_block_y:
  1683                                          ; Verificar colisión con bloques en Y
  1684 00000D3D 4150                            push r8     ; Guardar registros que usa check_block_collision
  1685 00000D3F 4151                            push r9
  1686 00000D41 4152                            push r10
  1687 00000D43 E8270A0000                      call check_block_collision
  1688 00000D48 415A                            pop r10
  1689 00000D4A 4159                            pop r9
  1690 00000D4C 4158                            pop r8
  1691 00000D4E 4885C0                          test rax, rax
  1692 00000D51 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1693 00000D53 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1694 00000D5A EB4A                            jmp .end
  1695                                  
  1696                                      .check_paddle_y:
  1697                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1698 00000D5C 41803A3D                        cmp byte [r10], char_equal
  1699 00000D60 7536                            jne .update_position
  1700                                  
  1701                                          ; Verificar si el poder catch está activo
  1702 00000D62 803D(58180000)01                cmp byte [catch_power_active], 1
  1703 00000D69 7524                            jne .normal_bounce
  1704                                  
  1705                                          ; Activar el modo "atrapado"
  1706 00000D6B C605(59180000)01                mov byte [ball_caught], 1
  1707                                          
  1708                                          ; Guardar la posición X actual de la bola como offset
  1709 00000D72 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1710 00000D79 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1711 00000D80 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1712 00000D86 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1713                                          
  1714 00000D8D EB17                            jmp .end
  1715                                  
  1716                                      .normal_bounce:
  1717 00000D8F 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1718 00000D96 EB0E                            jmp .end
  1719                                  
  1720                                  
  1721                                      .update_position:
  1722 00000D98 4C8905(5F140000)                mov [ball_x_pos], r8
  1723 00000D9F 4C890D(67140000)                mov [ball_y_pos], r9
  1724                                  
  1725                                      .end:
  1726 00000DA6 C3                              ret
  1727                                  
  1728                                  
  1729                                  move_ball_2:
  1730                                  
  1731 00000DA7 803D(59180000)01            cmp byte [ball_caught], 1
  1732 00000DAE 0F849D000000                je .move_with_pallet
  1733                                  
  1734 00000DB4 803D(A1140000)00            cmp byte [ball2_moving], 0
  1735 00000DBB 0F84B8010000                je .end
  1736                                  
  1737                                      ; Incrementar contador de velocidad
  1738 00000DC1 48FF05(50180000)            inc qword [speed_counter]
  1739                                      
  1740                                      ; Verificar si debemos mover la bola en este ciclo
  1741 00000DC8 488B05(50180000)            mov rax, [speed_counter]
  1742 00000DCF 483B05(40180000)            cmp rax, [ball_speed]
  1743 00000DD6 0F8C9D010000                jl .end
  1744                                      
  1745                                      ; Resetear contador de velocidad
  1746 00000DDC 48C705(50180000)00-         mov qword [speed_counter], 0
  1746 00000DE4 000000             
  1747                                  
  1748                                      ; Borrar la posición actual de la bola
  1749 00000DE7 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1750 00000DEE 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1751 00000DF5 4981C0[000A0000]            add r8, board
  1752 00000DFC 4C89C9                      mov rcx, r9
  1753 00000DFF B850000000                  mov rax, column_cells + 2
  1754 00000E04 48F7E9                      imul rcx
  1755 00000E07 4901C0                      add r8, rax
  1756 00000E0A 41C60020                    mov byte [r8], char_space
  1757                                  
  1758                                      ; Calcular siguiente posición X
  1759 00000E0E 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1760 00000E15 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1761 00000E1C 488B05(91140000)            mov rax, [ball2_direction_x]
  1762 00000E23 4901C0                      add r8, rax               ; Nueva posición X
  1763                                  
  1764                                      ; Calcular la dirección de memoria para la siguiente posición
  1765 00000E26 4D89C2                      mov r10, r8
  1766 00000E29 4981C2[000A0000]            add r10, board
  1767 00000E30 4C89C9                      mov rcx, r9
  1768 00000E33 B850000000                  mov rax, column_cells + 2
  1769 00000E38 48F7E9                      imul rcx
  1770 00000E3B 4901C2                      add r10, rax
  1771                                  
  1772                                      ; Verificar si hay una X en la siguiente posición X
  1773 00000E3E 418A02                      mov al, [r10]
  1774 00000E41 3C58                        cmp al, 'X'
  1775 00000E43 7565                        jne .check_block_x
  1776 00000E45 48F71D(91140000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1777 00000E4C E928010000                  jmp .end
  1778                                  
  1779                                      .move_with_pallet:
  1780                                          ; Borrar la posición actual de la bola
  1781 00000E51 4C8B05(81140000)                mov r8, [ball2_x_pos]
  1782 00000E58 4C8B0D(89140000)                mov r9, [ball2_y_pos]
  1783 00000E5F 4D89C2                          mov r10, r8
  1784 00000E62 4981C2[000A0000]                add r10, board
  1785 00000E69 4C89C9                          mov rcx, r9
  1786 00000E6C B850000000                      mov rax, column_cells + 2
  1787 00000E71 48F7E9                          imul rcx
  1788 00000E74 4901C2                          add r10, rax
  1789 00000E77 41C60220                        mov byte [r10], char_space
  1790                                  
  1791                                          ; Actualizar posición X basada en la paleta
  1792 00000E7B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1793 00000E82 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1794 00000E89 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1795 00000E90 4C8905(81140000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1796                                  
  1797                                          ; Mantener la bola una posición arriba de la paleta
  1798 00000E97 4C8B0D(89140000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1799 00000E9E 4C890D(89140000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1800                                  
  1801 00000EA5 E9CF000000                      jmp .end
  1802                                  
  1803                                  
  1804                                      .check_block_x:
  1805                                          ; Verificar colisión con bloques en X
  1806 00000EAA 4150                            push r8     ; Guardar registros que usa check_block_collision
  1807 00000EAC 4151                            push r9
  1808 00000EAE 4152                            push r10
  1809 00000EB0 E8BA080000                      call check_block_collision
  1810 00000EB5 415A                            pop r10
  1811 00000EB7 4159                            pop r9
  1812 00000EB9 4158                            pop r8
  1813 00000EBB 4885C0                          test rax, rax
  1814 00000EBE 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1815 00000EC0 48F71D(91140000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1816 00000EC7 E9AD000000                      jmp .end
  1817                                  
  1818                                      .check_paddle_x:
  1819                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1820 00000ECC 41803A3D                        cmp byte [r10], char_equal
  1821 00000ED0 750C                            jne .check_y_movement
  1822 00000ED2 48F71D(91140000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1823 00000ED9 E99B000000                      jmp .end
  1824                                  
  1825                                      .check_y_movement:
  1826                                          ; Calcular siguiente posición Y
  1827 00000EDE 488B05(99140000)                mov rax, [ball2_direction_y]
  1828 00000EE5 4901C1                          add r9, rax                  ; Nueva posición Y
  1829                                  
  1830                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1831 00000EE8 4D89C2                          mov r10, r8
  1832 00000EEB 4981C2[000A0000]                add r10, board
  1833 00000EF2 4C89C9                          mov rcx, r9
  1834 00000EF5 B850000000                      mov rax, column_cells + 2
  1835 00000EFA 48F7E9                          imul rcx
  1836 00000EFD 4901C2                          add r10, rax
  1837                                  
  1838                                          ; Verificar si hay una X en la siguiente posición Y
  1839 00000F00 418A02                          mov al, [r10]
  1840 00000F03 3C58                            cmp al, 'X'
  1841 00000F05 7509                            jne .check_block_y
  1842 00000F07 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1843 00000F0E EB69                            jmp .end
  1844                                  
  1845                                      .check_block_y:
  1846                                          ; Verificar colisión con bloques en Y
  1847 00000F10 4150                            push r8     ; Guardar registros que usa check_block_collision
  1848 00000F12 4151                            push r9
  1849 00000F14 4152                            push r10
  1850 00000F16 E854080000                      call check_block_collision
  1851 00000F1B 415A                            pop r10
  1852 00000F1D 4159                            pop r9
  1853 00000F1F 4158                            pop r8
  1854 00000F21 4885C0                          test rax, rax
  1855 00000F24 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1856 00000F26 48F71D(99140000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1857 00000F2D EB4A                            jmp .end
  1858                                  
  1859                                      .check_paddle_y:
  1860                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1861 00000F2F 41803A3D                        cmp byte [r10], char_equal
  1862 00000F33 7536                            jne .update_position
  1863                                  
  1864                                          ; Verificar si el poder catch está activo
  1865 00000F35 803D(58180000)01                cmp byte [catch_power_active], 1
  1866 00000F3C 7524                            jne .normal_bounce
  1867                                  
  1868                                          ; Activar el modo "atrapado"
  1869 00000F3E C605(59180000)01                mov byte [ball_caught], 1
  1870                                          
  1871                                          ; Guardar la posición X actual de la bola como offset
  1872 00000F45 488B05(81140000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  1873 00000F4C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1874 00000F53 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1875 00000F59 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1876                                          
  1877 00000F60 EB17                            jmp .end
  1878                                  
  1879                                      .normal_bounce:
  1880 00000F62 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  1881 00000F69 EB0E                            jmp .end
  1882                                  
  1883                                  
  1884                                      .update_position:
  1885 00000F6B 4C8905(81140000)                mov [ball2_x_pos], r8
  1886 00000F72 4C890D(89140000)                mov [ball2_y_pos], r9
  1887                                  
  1888                                      .end:
  1889 00000F79 C3                              ret
  1890                                  
  1891                                  move_ball_3:
  1892                                  
  1893 00000F7A 803D(59180000)01            cmp byte [ball_caught], 1
  1894 00000F81 0F849D000000                je .move_with_pallet
  1895                                  
  1896 00000F87 803D(C3140000)00            cmp byte [ball3_moving], 0
  1897 00000F8E 0F84B8010000                je .end
  1898                                  
  1899                                      ; Incrementar contador de velocidad
  1900 00000F94 48FF05(50180000)            inc qword [speed_counter]
  1901                                      
  1902                                      ; Verificar si debemos mover la bola en este ciclo
  1903 00000F9B 488B05(50180000)            mov rax, [speed_counter]
  1904 00000FA2 483B05(40180000)            cmp rax, [ball_speed]
  1905 00000FA9 0F8C9D010000                jl .end
  1906                                      
  1907                                      ; Resetear contador de velocidad
  1908 00000FAF 48C705(50180000)00-         mov qword [speed_counter], 0
  1908 00000FB7 000000             
  1909                                  
  1910                                      ; Borrar la posición actual de la bola
  1911 00000FBA 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1912 00000FC1 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1913 00000FC8 4981C0[000A0000]            add r8, board
  1914 00000FCF 4C89C9                      mov rcx, r9
  1915 00000FD2 B850000000                  mov rax, column_cells + 2
  1916 00000FD7 48F7E9                      imul rcx
  1917 00000FDA 4901C0                      add r8, rax
  1918 00000FDD 41C60020                    mov byte [r8], char_space
  1919                                  
  1920                                      ; Calcular siguiente posición X
  1921 00000FE1 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1922 00000FE8 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1923 00000FEF 488B05(B3140000)            mov rax, [ball3_direction_x]
  1924 00000FF6 4901C0                      add r8, rax               ; Nueva posición X
  1925                                  
  1926                                      ; Calcular la dirección de memoria para la siguiente posición
  1927 00000FF9 4D89C2                      mov r10, r8
  1928 00000FFC 4981C2[000A0000]            add r10, board
  1929 00001003 4C89C9                      mov rcx, r9
  1930 00001006 B850000000                  mov rax, column_cells + 2
  1931 0000100B 48F7E9                      imul rcx
  1932 0000100E 4901C2                      add r10, rax
  1933                                  
  1934                                      ; Verificar si hay una X en la siguiente posición X
  1935 00001011 418A02                      mov al, [r10]
  1936 00001014 3C58                        cmp al, 'X'
  1937 00001016 7565                        jne .check_block_x
  1938 00001018 48F71D(B3140000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  1939 0000101F E928010000                  jmp .end
  1940                                  
  1941                                      .move_with_pallet:
  1942                                          ; Borrar la posición actual de la bola
  1943 00001024 4C8B05(A3140000)                mov r8, [ball3_x_pos]
  1944 0000102B 4C8B0D(AB140000)                mov r9, [ball3_y_pos]
  1945 00001032 4D89C2                          mov r10, r8
  1946 00001035 4981C2[000A0000]                add r10, board
  1947 0000103C 4C89C9                          mov rcx, r9
  1948 0000103F B850000000                      mov rax, column_cells + 2
  1949 00001044 48F7E9                          imul rcx
  1950 00001047 4901C2                          add r10, rax
  1951 0000104A 41C60220                        mov byte [r10], char_space
  1952                                  
  1953                                          ; Actualizar posición X basada en la paleta
  1954 0000104E 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1955 00001055 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1956 0000105C 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1957 00001063 4C8905(A3140000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  1958                                  
  1959                                          ; Mantener la bola una posición arriba de la paleta
  1960 0000106A 4C8B0D(AB140000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  1961 00001071 4C890D(AB140000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  1962                                  
  1963 00001078 E9CF000000                      jmp .end
  1964                                  
  1965                                  
  1966                                      .check_block_x:
  1967                                          ; Verificar colisión con bloques en X
  1968 0000107D 4150                            push r8     ; Guardar registros que usa check_block_collision
  1969 0000107F 4151                            push r9
  1970 00001081 4152                            push r10
  1971 00001083 E8E7060000                      call check_block_collision
  1972 00001088 415A                            pop r10
  1973 0000108A 4159                            pop r9
  1974 0000108C 4158                            pop r8
  1975 0000108E 4885C0                          test rax, rax
  1976 00001091 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1977 00001093 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  1978 0000109A E9AD000000                      jmp .end
  1979                                  
  1980                                      .check_paddle_x:
  1981                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1982 0000109F 41803A3D                        cmp byte [r10], char_equal
  1983 000010A3 750C                            jne .check_y_movement
  1984 000010A5 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  1985 000010AC E99B000000                      jmp .end
  1986                                  
  1987                                      .check_y_movement:
  1988                                          ; Calcular siguiente posición Y
  1989 000010B1 488B05(BB140000)                mov rax, [ball3_direction_y]
  1990 000010B8 4901C1                          add r9, rax                  ; Nueva posición Y
  1991                                  
  1992                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1993 000010BB 4D89C2                          mov r10, r8
  1994 000010BE 4981C2[000A0000]                add r10, board
  1995 000010C5 4C89C9                          mov rcx, r9
  1996 000010C8 B850000000                      mov rax, column_cells + 2
  1997 000010CD 48F7E9                          imul rcx
  1998 000010D0 4901C2                          add r10, rax
  1999                                  
  2000                                          ; Verificar si hay una X en la siguiente posición Y
  2001 000010D3 418A02                          mov al, [r10]
  2002 000010D6 3C58                            cmp al, 'X'
  2003 000010D8 7509                            jne .check_block_y
  2004 000010DA 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2005 000010E1 EB69                            jmp .end
  2006                                  
  2007                                      .check_block_y:
  2008                                          ; Verificar colisión con bloques en Y
  2009 000010E3 4150                            push r8     ; Guardar registros que usa check_block_collision
  2010 000010E5 4151                            push r9
  2011 000010E7 4152                            push r10
  2012 000010E9 E881060000                      call check_block_collision
  2013 000010EE 415A                            pop r10
  2014 000010F0 4159                            pop r9
  2015 000010F2 4158                            pop r8
  2016 000010F4 4885C0                          test rax, rax
  2017 000010F7 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2018 000010F9 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2019 00001100 EB4A                            jmp .end
  2020                                  
  2021                                      .check_paddle_y:
  2022                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2023 00001102 41803A3D                        cmp byte [r10], char_equal
  2024 00001106 7536                            jne .update_position
  2025                                  
  2026                                          ; Verificar si el poder catch está activo
  2027 00001108 803D(58180000)01                cmp byte [catch_power_active], 1
  2028 0000110F 7524                            jne .normal_bounce
  2029                                  
  2030                                          ; Activar el modo "atrapado"
  2031 00001111 C605(59180000)01                mov byte [ball_caught], 1
  2032                                          
  2033                                          ; Guardar la posición X actual de la bola como offset
  2034 00001118 488B05(A3140000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2035 0000111F 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2036 00001126 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2037 0000112C 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2038                                          
  2039 00001133 EB17                            jmp .end
  2040                                  
  2041                                      .normal_bounce:
  2042 00001135 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2043 0000113C EB0E                            jmp .end
  2044                                  
  2045                                  
  2046                                      .update_position:
  2047 0000113E 4C8905(A3140000)                mov [ball3_x_pos], r8
  2048 00001145 4C890D(AB140000)                mov [ball3_y_pos], r9
  2049                                  
  2050                                      .end:
  2051 0000114C C3                              ret
  2052                                  
  2053                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2054                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2055                                  process_catch_release:
  2056 0000114D 55                          push rbp
  2057 0000114E 4889E5                      mov rbp, rsp
  2058                                  
  2059                                      ; Verificar si la bola está atrapada
  2060 00001151 803D(59180000)00            cmp byte [ball_caught], 0
  2061 00001158 7436                        je .end
  2062                                  
  2063                                      ; Verificar si el poder catch está activo
  2064 0000115A 803D(58180000)01            cmp byte [catch_power_active], 1
  2065 00001161 752D                        jne .end
  2066                                  
  2067                                      ; Verificar si se presionó la tecla 'c'
  2068 00001163 803D(62180000)63            cmp byte [last_key], 'c'
  2069 0000116A 7524                        jne .end
  2070                                  
  2071                                      ; Liberar la bola y asignar dirección inicial
  2072 0000116C C605(59180000)00            mov byte [ball_caught], 0
  2073 00001173 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  2073 0000117B 000000             
  2074 0000117E 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  2074 00001186 FFFFFF             
  2075                                  
  2076                                      ; Limpiar la tecla procesada
  2077 00001189 C605(62180000)00            mov byte [last_key], 0
  2078                                  
  2079                                      .end:
  2080 00001190 5D                              pop rbp
  2081 00001191 C3                              ret
  2082                                  
  2083                                  
  2084                                  display_level_number:
  2085 00001192 55                          push rbp
  2086 00001193 4889E5                      mov rbp, rsp
  2087                                      
  2088                                      ; Limpiar la pantalla primero
  2089                                      print clear, clear_length
    82 00001196 B801000000          <1>  mov eax, sys_write
    83 0000119B BF01000000          <1>  mov edi, 1
    84 000011A0 48BE-               <1>  mov rsi, %1
    84 000011A2 [1000000000000000]  <1>
    85 000011AA BA07000000          <1>  mov edx, %2
    86 000011AF 0F05                <1>  syscall
  2090                                      
  2091                                      ; Calcular la posición central para el mensaje
  2092                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2093 000011B1 B84E000000                  mov rax, column_cells
  2094 000011B6 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2095 000011BA 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2096                                      
  2097                                      ; Calcular la fila central
  2098 000011BD BB20000000                  mov rbx, row_cells
  2099 000011C2 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2100                                      
  2101                                      ; Calcular el offset en el buffer
  2102 000011C5 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2103 000011CA 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2104 000011CD 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2105                                      
  2106                                      ; Escribir "NIVEL " en la posición calculada
  2107 000011D0 488DB8[000A0000]            lea rdi, [board + rax]
  2108 000011D7 48BE-                       mov rsi, level_msg
  2108 000011D9 [2414000000000000] 
  2109 000011E1 B906000000                  mov rcx, level_msg_len
  2110 000011E6 F3A4                        rep movsb
  2111                                      
  2112                                      ; Escribir el número del nivel
  2113 000011E8 8A05(F9140000)              mov al, [current_level]
  2114 000011EE 0430                        add al, '0'                 ; convertir a ASCII
  2115 000011F0 8807                        mov [rdi], al
  2116                                      
  2117                                      ; Mostrar el board con el mensaje
  2118                                      print board, board_size
    82 000011F2 B801000000          <1>  mov eax, sys_write
    83 000011F7 BF01000000          <1>  mov edi, 1
    84 000011FC 48BE-               <1>  mov rsi, %1
    84 000011FE [000A000000000000]  <1>
    85 00001206 BA000A0000          <1>  mov edx, %2
    86 0000120B 0F05                <1>  syscall
  2119                                      
  2120                                      ; Esperar un segundo
  2121 0000120D B823000000                  mov rax, sys_nanosleep
  2122 00001212 48BF-                       mov rdi, level_display_time
  2122 00001214 [2F14000000000000] 
  2123 0000121C 4831F6                      xor rsi, rsi
  2124 0000121F 0F05                        syscall
  2125                                      
  2126 00001221 5D                          pop rbp
  2127 00001222 C3                          ret
  2128                                  
  2129                                  ; Función para inicializar un tablero vacío
  2130                                  init_empty_board:
  2131 00001223 56                          push rsi
  2132 00001224 57                          push rdi
  2133 00001225 51                          push rcx
  2134 00001226 50                          push rax
  2135                                  
  2136 00001227 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2137 0000122E 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2138 00001235 B9000A0000                  mov rcx, board_template_size
  2139 0000123A F3A4                        rep movsb                   ; Copiar el tablero
  2140                                  
  2141 0000123C 58                          pop rax
  2142 0000123D 59                          pop rcx
  2143 0000123E 5F                          pop rdi
  2144 0000123F 5E                          pop rsi
  2145 00001240 C3                          ret
  2146                                  
  2147                                  
  2148                                  init_level:
  2149 00001241 C605(63180000)00            mov byte [laser_power_active], 0
  2150 00001248 E878F4FFFF                  call clear_lasers
  2151 0000124D 488B05(4F140000)            mov rax, [default_pallet_size]
  2152 00001254 488905(47140000)            mov [pallet_size], rax
  2153 0000125B 48C705(40180000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2153 00001263 000000             
  2154                                  
  2155                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2156                                          ; Reiniciar letras activas
  2157 00001266 488D3D(99160000)            lea rdi, [letters_map]
  2158 0000126D B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2159 00001272 4831C0                      xor rax, rax
  2160 00001275 F3AA                        rep stosb                    ; Llenar con ceros
  2161                                      
  2162                                      ; Inicializar dirección de la bola (derecha y arriba)
  2163 00001277 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2163 0000127F 000000             
  2164 00001282 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2164 0000128A FFFFFF             
  2165                                  
  2166                                  
  2167                                      ; Reiniciar contador de letras activas
  2168 0000128D 4831C0                      xor rax, rax
  2169 00001290 8805(29180000)              mov [letters_count], al
  2170                                  
  2171                                      ; Reiniciar última letra capturada
  2172 00001296 C605(2A180000)20            mov byte [last_letter], ' '
  2173 0000129D C605(A3150000)00            mov byte [destroyed_blocks], 0 
  2174 000012A4 E87AFFFFFF                  call init_empty_board
  2175 000012A9 E8E4FEFFFF                  call display_level_number
  2176 000012AE E8E5050000                  call init_enemies
  2177                                      
  2178 000012B3 56                          push rsi
  2179 000012B4 57                          push rdi
  2180 000012B5 51                          push rcx
  2181 000012B6 50                          push rax
  2182                                  
  2183 000012B7 488D35(00000000)            lea rsi, [board_template]
  2184 000012BE 488D3D(000A0000)            lea rdi, [board]
  2185 000012C5 B9000A0000                  mov rcx, board_template_size
  2186 000012CA F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2187                                  
  2188 000012CC 58                          pop rax
  2189 000012CD 59                          pop rcx
  2190 000012CE 5F                          pop rdi
  2191 000012CF 5E                          pop rsi
  2192                                  
  2193 000012D0 B90A000000                  mov rcx, 10
  2194 000012D5 4831C0                      xor rax, rax
  2195 000012D8 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2196 000012DF F3AA                        rep stosb      
  2197                                  
  2198                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2199 000012E1 803D(F9140000)01            cmp byte [current_level], 1
  2200 000012E8 7431                        je .level1
  2201 000012EA 803D(F9140000)02            cmp byte [current_level], 2
  2202 000012F1 7454                        je .level2
  2203 000012F3 803D(F9140000)03            cmp byte [current_level], 3
  2204 000012FA 7477                        je .level3
  2205 000012FC 803D(F9140000)04            cmp byte [current_level], 4
  2206 00001303 0F8492000000                je .level4
  2207 00001309 803D(F9140000)05            cmp byte [current_level], 5
  2208 00001310 0F84AD000000                je .level5
  2209 00001316 E9D0000000                  jmp .done
  2210                                  
  2211                                  
  2212                                  
  2213                                      .level1:
  2214 0000131B C605(FA140000)08                mov byte [blocks_remaining], level1_blocks_count
  2215 00001322 4831C9                          xor rcx, rcx             
  2216                                          .init_loop1:
  2217 00001325 4883F908                            cmp rcx, level1_blocks_count
  2218 00001329 0F8DBC000000                        jge .done
  2219 0000132F 4889C8                              mov rax, rcx         
  2220 00001332 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2221 00001336 8A90[FE140000]                      mov dl, byte [level1_blocks + rax + 3]  
  2222 0000133C 8891[37150000]                      mov byte [block_states + rcx], dl
  2223 00001342 48FFC1                              inc rcx
  2224 00001345 EBDE                                jmp .init_loop1
  2225                                  
  2226                                      .level2:
  2227 00001347 C605(FA140000)01                mov byte [blocks_remaining], level2_blocks_count
  2228 0000134E 4831C9                          xor rcx, rcx             
  2229                                          .init_loop2:
  2230 00001351 4883F901                            cmp rcx, level2_blocks_count
  2231 00001355 0F8D90000000                        jge .done
  2232 0000135B 4889C8                              mov rax, rcx         
  2233 0000135E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2234 00001362 8A90[26150000]                      mov dl, byte [level2_blocks + rax + 3]  
  2235 00001368 8891[37150000]                      mov byte [block_states + rcx], dl
  2236 0000136E 48FFC1                              inc rcx
  2237 00001371 EBDE                                jmp .init_loop2
  2238                                      .level3:
  2239 00001373 C605(FA140000)01                mov byte [blocks_remaining], level3_blocks_count
  2240 0000137A 4831C9                          xor rcx, rcx             
  2241                                          .init_loop3:
  2242 0000137D 4883F901                            cmp rcx, level3_blocks_count
  2243 00001381 7D68                                jge .done
  2244 00001383 4889C8                              mov rax, rcx         
  2245 00001386 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2246 0000138A 8A90[2B150000]                      mov dl, byte [level3_blocks + rax + 3]  
  2247 00001390 8891[37150000]                      mov byte [block_states + rcx], dl
  2248 00001396 48FFC1                              inc rcx
  2249 00001399 EBE2                                jmp .init_loop3
  2250                                  
  2251                                      .level4:
  2252 0000139B C605(FA140000)01                mov byte [blocks_remaining], level4_blocks_count
  2253 000013A2 4831C9                          xor rcx, rcx             
  2254                                          .init_loop4:
  2255 000013A5 4883F901                            cmp rcx, level4_blocks_count
  2256 000013A9 7D40                                jge .done
  2257 000013AB 4889C8                              mov rax, rcx         
  2258 000013AE 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2259 000013B2 8A90[30150000]                      mov dl, byte [level4_blocks + rax + 3]  
  2260 000013B8 8891[37150000]                      mov byte [block_states + rcx], dl
  2261 000013BE 48FFC1                              inc rcx
  2262 000013C1 EBE2                                jmp .init_loop4
  2263                                  
  2264                                      .level5:
  2265 000013C3 C605(FA140000)01                mov byte [blocks_remaining], level5_blocks_count
  2266 000013CA 4831C9                          xor rcx, rcx             
  2267                                          .init_loop5:
  2268 000013CD 4883F901                            cmp rcx, level5_blocks_count
  2269 000013D1 7D18                                jge .done
  2270 000013D3 4889C8                              mov rax, rcx         
  2271 000013D6 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2272 000013DA 8A90[35150000]                      mov dl, byte [level5_blocks + rax + 3]  
  2273 000013E0 8891[37150000]                      mov byte [block_states + rcx], dl
  2274 000013E6 48FFC1                              inc rcx
  2275 000013E9 EBE2                                jmp .init_loop5
  2276                                      .done:
  2277 000013EB C3                              ret
  2278                                  
  2279                                  
  2280                                  ; Función para verificar y manejar la transición de nivel
  2281                                  check_level_complete:
  2282                                      ; Verificar si quedan bloques
  2283 000013EC 803D(FA140000)00            cmp byte [blocks_remaining], 0
  2284 000013F3 753C                        jne .not_complete
  2285                                      
  2286                                      ; Incrementar el nivel
  2287 000013F5 FE05(F9140000)              inc byte [current_level]
  2288                                      
  2289                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2290 000013FB 803D(F9140000)06            cmp byte [current_level], 6
  2291 00001402 742E                        je game_win
  2292                                      
  2293                                      ; Reinicializar el juego para el siguiente nivel
  2294 00001404 E838FEFFFF                  call init_level
  2295                                      
  2296                                      ; Reinicializar la posición de la bola y la paleta
  2297 00001409 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  2297 00001411 000000             
  2298 00001414 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  2298 0000141C 000000             
  2299 0000141F C605(7F140000)00            mov byte [ball_moving], 0
  2300 00001426 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2300 0000142D [36130000]         
  2301                                      
  2302                                      .not_complete:
  2303 00001431 C3                              ret
  2304                                  
  2305                                      ; Nueva función para manejar la victoria del juego
  2306                                  game_win:
  2307                                      ; Limpiar la pantalla primero
  2308                                      print clear, clear_length
    82 00001432 B801000000          <1>  mov eax, sys_write
    83 00001437 BF01000000          <1>  mov edi, 1
    84 0000143C 48BE-               <1>  mov rsi, %1
    84 0000143E [1000000000000000]  <1>
    85 00001446 BA07000000          <1>  mov edx, %2
    86 0000144B 0F05                <1>  syscall
  2309                                      
  2310                                      ; Mensaje de victoria
  2311 0000144D 488B05(9B150000)            mov rax, [current_score]    ; Obtener el puntaje final
  2312 00001454 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2312 00001456 [A415000000000000] 
  2313 0000145E E8B4010000                  call number_to_string
  2314                                      
  2315                                      ; Definir mensaje de victoria
  2316                                      section .data
  2317 000019AA C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2317 000019B3 616465732120C2A148-
  2317 000019BC 61732067616E61646F-
  2317 000019C5 210A0D             
  2318                                          win_msg_len: equ $ - win_msg
  2319 000019C8 50756E74616A652066-             score_msg: db "Puntaje final: "
  2319 000019D1 696E616C3A20       
  2320                                          score_msg_len: equ $ - score_msg
  2321                                      section .text
  2322                                      
  2323                                      ; Imprimir mensajes
  2324                                      print win_msg, win_msg_len
    82 00001463 B801000000          <1>  mov eax, sys_write
    83 00001468 BF01000000          <1>  mov edi, 1
    84 0000146D 48BE-               <1>  mov rsi, %1
    84 0000146F [AA19000000000000]  <1>
    85 00001477 BA1E000000          <1>  mov edx, %2
    86 0000147C 0F05                <1>  syscall
  2325                                      print score_msg, score_msg_len
    82 0000147E B801000000          <1>  mov eax, sys_write
    83 00001483 BF01000000          <1>  mov edi, 1
    84 00001488 48BE-               <1>  mov rsi, %1
    84 0000148A [C819000000000000]  <1>
    85 00001492 BA0F000000          <1>  mov edx, %2
    86 00001497 0F05                <1>  syscall
  2326                                      print number_buffer, 20
    82 00001499 B801000000          <1>  mov eax, sys_write
    83 0000149E BF01000000          <1>  mov edi, 1
    84 000014A3 48BE-               <1>  mov rsi, %1
    84 000014A5 [A415000000000000]  <1>
    85 000014AD BA14000000          <1>  mov edx, %2
    86 000014B2 0F05                <1>  syscall
  2327                                      
  2328                                      ; Esperar un momento antes de salir
  2329 000014B4 48C70541EBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2329 000014BD 0000               
  2330 000014BF 48C7053EEBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2330 000014C8 0000               
  2331                                      sleeptime
    98 000014CA B823000000          <1>  mov eax, sys_nanosleep
    99 000014CF 48BF-               <1>  mov rdi, timespec
    99 000014D1 [0000000000000000]  <1>
   100 000014D9 31F6                <1>  xor esi, esi
   101 000014DB 0F05                <1>  syscall
  2332                                      
  2333 000014DD E966090000                  jmp exit
  2334                                  
  2335                                  ; Función para imprimir los bloques
  2336                                  ; Función modificada para imprimir bloques
  2337                                  
  2338                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2339                                  get_current_level_blocks:
  2340 000014E2 803D(F9140000)01            cmp byte [current_level], 1
  2341 000014E9 7428                        je .level1
  2342 000014EB 803D(F9140000)02            cmp byte [current_level], 2
  2343 000014F2 7427                        je .level2
  2344 000014F4 803D(F9140000)03            cmp byte [current_level], 3
  2345 000014FB 7426                        je .level3
  2346 000014FD 803D(F9140000)04            cmp byte [current_level], 4
  2347 00001504 7425                        je .level4
  2348 00001506 803D(F9140000)05            cmp byte [current_level], 5
  2349 0000150D 7424                        je .level5
  2350                                      ; Si llegamos aquí, hay un error en el nivel
  2351 0000150F 4831C0                      xor rax, rax
  2352 00001512 C3                          ret
  2353                                  
  2354                                      .level1:
  2355 00001513 488D05(FB140000)                lea rax, [level1_blocks]
  2356 0000151A C3                              ret
  2357                                      .level2:
  2358 0000151B 488D05(23150000)                lea rax, [level2_blocks]
  2359 00001522 C3                              ret
  2360                                      .level3:
  2361 00001523 488D05(28150000)                lea rax, [level3_blocks]
  2362 0000152A C3                              ret
  2363                                      .level4:
  2364 0000152B 488D05(2D150000)                lea rax, [level4_blocks]
  2365 00001532 C3                              ret
  2366                                      .level5:
  2367 00001533 488D05(32150000)                lea rax, [level5_blocks]
  2368 0000153A C3                              ret
  2369                                  ; Función para obtener la cantidad de bloques del nivel actual
  2370                                  get_current_level_count:
  2371 0000153B 803D(F9140000)01            cmp byte [current_level], 1
  2372 00001542 7428                        je .level1
  2373 00001544 803D(F9140000)02            cmp byte [current_level], 2
  2374 0000154B 7425                        je .level2
  2375 0000154D 803D(F9140000)03            cmp byte [current_level], 3
  2376 00001554 7422                        je .level3
  2377 00001556 803D(F9140000)04            cmp byte [current_level], 4
  2378 0000155D 741F                        je .level4
  2379 0000155F 803D(F9140000)05            cmp byte [current_level], 5
  2380 00001566 741C                        je .level5
  2381                                      ; Si llegamos aquí, hay un error en el nivel
  2382 00001568 4831C0                      xor rax, rax
  2383 0000156B C3                          ret
  2384                                  
  2385                                      .level1:
  2386 0000156C B808000000                      mov rax, level1_blocks_count
  2387 00001571 C3                              ret
  2388                                      .level2:
  2389 00001572 B801000000                      mov rax, level2_blocks_count
  2390 00001577 C3                              ret
  2391                                      .level3:
  2392 00001578 B801000000                      mov rax, level3_blocks_count
  2393 0000157D C3                              ret
  2394                                      .level4:
  2395 0000157E B801000000                      mov rax, level4_blocks_count
  2396 00001583 C3                              ret
  2397                                      .level5:
  2398 00001584 B801000000                      mov rax, level5_blocks_count
  2399 00001589 C3                              ret
  2400                                  
  2401                                  
  2402                                  print_blocks:
  2403 0000158A 55                          push rbp
  2404 0000158B 4889E5                      mov rbp, rsp
  2405                                      
  2406                                      ; Obtener puntero a los bloques del nivel actual
  2407 0000158E E84FFFFFFF                  call get_current_level_blocks
  2408 00001593 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2409                                      
  2410                                      ; Obtener cantidad de bloques del nivel actual
  2411 00001596 E8A0FFFFFF                  call get_current_level_count
  2412 0000159B 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2413                                      
  2414 0000159E 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2415                                      
  2416                                      .print_loop:
  2417 000015A1 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2418 000015A4 7D6F                            jge .end
  2419                                          
  2420                                          ; Verificar si el bloque está activo
  2421 000015A6 490FB68424-                     movzx rax, byte [block_states + r12]
  2421 000015AB [37150000]         
  2422 000015AF 4885C0                          test rax, rax
  2423 000015B2 745C                            jz .next_block
  2424                                          
  2425                                          ; Obtener posición y tipo del bloque usando r13
  2426 000015B4 4C89E0                          mov rax, r12
  2427 000015B7 486BC005                        imul rax, 5
  2428 000015BB 4C01E8                          add rax, r13
  2429 000015BE 448A00                          mov r8b, [rax]        ; X position
  2430 000015C1 448A4801                        mov r9b, [rax + 1]    ; Y position
  2431 000015C5 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2432                                  
  2433                                          ; El resto de la lógica de impresión permanece igual
  2434 000015C9 4D0FB6C0                        movzx r8, r8b
  2435 000015CD 4D0FB6C9                        movzx r9, r9b
  2436 000015D1 4981C0[000A0000]                add r8, board
  2437 000015D8 B850000000                      mov rax, column_cells + 2
  2438 000015DD 49F7E1                          mul r9
  2439 000015E0 4901C0                          add r8, rax
  2440                                          
  2441 000015E3 B906000000                      mov rcx, block_length
  2442 000015E8 48BE-                           mov rsi, block_type_1
  2442 000015EA [D514000000000000] 
  2443 000015F2 490FB6C2                        movzx rax, r10b
  2444 000015F6 48FFC8                          dec rax
  2445 000015F9 486BC006                        imul rax, block_length
  2446 000015FD 4801C6                          add rsi, rax
  2447                                          
  2448                                      .print_block_chars:
  2449 00001600 8A06                            mov al, [rsi]
  2450 00001602 418800                          mov [r8], al
  2451 00001605 48FFC6                          inc rsi
  2452 00001608 49FFC0                          inc r8
  2453 0000160B 48FFC9                          dec rcx
  2454 0000160E 75F0                            jnz .print_block_chars
  2455                                          
  2456                                      .next_block:
  2457 00001610 49FFC4                          inc r12
  2458 00001613 EB8C                            jmp .print_loop
  2459                                          
  2460                                      .end:
  2461 00001615 5D                              pop rbp
  2462 00001616 C3                              ret
  2463                                  
  2464                                  ; Función para convertir número a string
  2465                                  ; Input: RAX = número a convertir
  2466                                  ; RDI = buffer donde escribir el string
  2467                                  number_to_string:
  2468 00001617 53                          push rbx
  2469 00001618 52                          push rdx
  2470 00001619 56                          push rsi
  2471 0000161A BB0A000000                  mov rbx, 10          ; Divisor
  2472 0000161F B900000000                  mov rcx, 0          ; Contador de dígitos
  2473                                      
  2474                                      ; Si el número es 0, manejarlo especialmente
  2475 00001624 4885C0                      test rax, rax
  2476 00001627 7509                        jnz .convert_loop
  2477 00001629 C60730                      mov byte [rdi], '0'
  2478 0000162C C6470100                    mov byte [rdi + 1], 0
  2479 00001630 EB20                        jmp .end
  2480                                      
  2481                                      .convert_loop:
  2482 00001632 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2483 00001635 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2484 00001638 80C230                          add dl, '0'     ; Convertir a ASCII
  2485 0000163B 52                              push rdx        ; Guardar el dígito
  2486 0000163C 48FFC1                          inc rcx         ; Incrementar contador
  2487 0000163F 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2488 00001642 75EE                            jnz .convert_loop
  2489                                          
  2490                                      .write_loop:
  2491 00001644 5A                              pop rdx         ; Obtener dígito
  2492 00001645 8817                            mov [rdi], dl   ; Escribir al buffer
  2493 00001647 48FFC7                          inc rdi         ; Siguiente posición
  2494 0000164A 48FFC9                          dec rcx         ; Decrementar contador
  2495 0000164D 75F5                            jnz .write_loop
  2496                                          
  2497 0000164F C60700                      mov byte [rdi], 0   ; Null terminator
  2498                                      
  2499                                      .end:
  2500 00001652 5E                          pop rsi
  2501 00001653 5A                          pop rdx
  2502 00001654 5B                          pop rbx
  2503 00001655 C3                          ret
  2504                                  
  2505                                  ; Función para imprimir los labels
  2506                                  print_labels:
  2507 00001656 55                          push rbp
  2508 00001657 4889E5                      mov rbp, rsp
  2509                                  
  2510                                      ; Crear buffer temporal
  2511 0000165A 4883EC20                    sub rsp, 32
  2512                                  
  2513                                      ; Copiar labels a buffer temporal
  2514 0000165E 4889E7                      mov rdi, rsp
  2515 00001661 488D35(50160000)            lea rsi, [score_label]
  2516 00001668 B917000000                  mov rcx, score_label_len
  2517 0000166D F3A4                        rep movsb
  2518                                  
  2519                                      ; Convertir score a string
  2520 0000166F 488B05(9B150000)            mov rax, [current_score]
  2521 00001676 48BF-                       mov rdi, number_buffer
  2521 00001678 [A415000000000000] 
  2522 00001680 E892FFFFFF                  call number_to_string
  2523                                  
  2524                                      ; Calcular longitud del número
  2525 00001685 B900000000                  mov rcx, 0
  2526 0000168A 48BF-                       mov rdi, number_buffer
  2526 0000168C [A415000000000000] 
  2527                                      .count_loop:
  2528 00001694 803C0F00                        cmp byte [rdi + rcx], 0
  2529 00001698 7405                            je .count_done
  2530 0000169A 48FFC1                          inc rcx
  2531 0000169D EBF5                            jmp .count_loop
  2532                                      .count_done:
  2533                                  
  2534                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2535 0000169F 4889E7                      mov rdi, rsp
  2536 000016A2 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2537 000016A6 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2538 000016AB 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2539                                      .pad_loop:
  2540 000016AE 4885F6                          test rsi, rsi
  2541 000016B1 740B                            jz .pad_done
  2542 000016B3 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2543 000016B6 48FFC7                          inc rdi
  2544 000016B9 48FFCE                          dec rsi
  2545 000016BC EBF0                            jmp .pad_loop
  2546                                      .pad_done:
  2547                                  
  2548                                      ; Copiar el número
  2549 000016BE 48BE-                       mov rsi, number_buffer
  2549 000016C0 [A415000000000000] 
  2550 000016C8 F3A4                        rep movsb
  2551                                  
  2552                                      ; Imprimir el buffer completo
  2553                                      print rsp, score_label_len
    82 000016CA B801000000          <1>  mov eax, sys_write
    83 000016CF BF01000000          <1>  mov edi, 1
    84 000016D4 4889E6              <1>  mov rsi, %1
    85 000016D7 BA17000000          <1>  mov edx, %2
    86 000016DC 0F05                <1>  syscall
  2554                                  
  2555                                      ; Repetir proceso para bloques destruidos
  2556 000016DE 4889E7                      mov rdi, rsp
  2557 000016E1 488D35(67160000)            lea rsi, [blocks_label]
  2558 000016E8 B91B000000                  mov rcx, blocks_label_len
  2559 000016ED F3A4                        rep movsb
  2560                                  
  2561                                      ; Verificar que el `[` esté en su posición correcta
  2562 000016EF 4889E7                      mov rdi, rsp
  2563 000016F2 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2564 000016F6 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2565                                  
  2566                                      ; Convertir bloques destruidos a string
  2567 000016F9 480FB605(A3150000)          movzx rax, byte [destroyed_blocks]
  2568 00001701 48BF-                       mov rdi, number_buffer
  2568 00001703 [A415000000000000] 
  2569 0000170B E807FFFFFF                  call number_to_string
  2570                                  
  2571                                      ; Calcular longitud del número
  2572 00001710 B900000000                  mov rcx, 0
  2573 00001715 48BF-                       mov rdi, number_buffer
  2573 00001717 [A415000000000000] 
  2574                                      .count_loop2:
  2575 0000171F 803C0F00                        cmp byte [rdi + rcx], 0
  2576 00001723 7405                            je .count_done2
  2577 00001725 48FFC1                          inc rcx
  2578 00001728 EBF5                            jmp .count_loop2
  2579                                      .count_done2:
  2580                                  
  2581                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2582 0000172A 4889E7                      mov rdi, rsp
  2583 0000172D 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2584 00001731 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2585 00001736 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2586                                      .pad_loop2:
  2587 00001739 4885F6                          test rsi, rsi
  2588 0000173C 740B                            jz .pad_done2
  2589 0000173E C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2590 00001741 48FFC7                          inc rdi
  2591 00001744 48FFCE                          dec rsi
  2592 00001747 EBF0                            jmp .pad_loop2
  2593                                      .pad_done2:
  2594                                  
  2595                                      ; Copiar el número
  2596 00001749 48BE-                       mov rsi, number_buffer
  2596 0000174B [A415000000000000] 
  2597 00001753 F3A4                        rep movsb
  2598                                  
  2599                                      ; Imprimir el buffer completo
  2600                                      print rsp, blocks_label_len
    82 00001755 B801000000          <1>  mov eax, sys_write
    83 0000175A BF01000000          <1>  mov edi, 1
    84 0000175F 4889E6              <1>  mov rsi, %1
    85 00001762 BA1B000000          <1>  mov edx, %2
    86 00001767 0F05                <1>  syscall
  2601                                  
  2602                                      ; Restaurar stack
  2603 00001769 4883C420                    add rsp, 32
  2604 0000176D 5D                          pop rbp
  2605 0000176E C3                          ret
  2606                                  
  2607                                  
  2608                                  
  2609                                  check_block_collision:
  2610 0000176F 55                          push rbp
  2611 00001770 4889E5                      mov rbp, rsp
  2612                                  
  2613                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2614 00001773 418A02                      mov al, [r10]
  2615                                  
  2616                                      ; Verificar si el carácter es un bloque
  2617 00001776 3C55                        cmp al, 'U'  
  2618 00001778 7419                        je .possible
  2619 0000177A 3C4F                        cmp al, 'O'  
  2620 0000177C 7415                        je .possible
  2621 0000177E 3C44                        cmp al, 'D'  
  2622 00001780 7411                        je .possible
  2623 00001782 3C4C                        cmp al, 'L'  
  2624 00001784 740D                        je .possible
  2625 00001786 3C56                        cmp al, 'V'  
  2626 00001788 7409                        je .possible
  2627 0000178A 3C38                        cmp al, '8'  
  2628 0000178C 7405                        je .possible
  2629                                  
  2630                                      ; No es bloque, salir
  2631 0000178E 4831C0                      xor rax, rax
  2632 00001791 5D                          pop rbp
  2633 00001792 C3                          ret
  2634                                  
  2635                                  .possible:
  2636 00001793 53                          push rbx
  2637 00001794 57                          push rdi
  2638 00001795 56                          push rsi
  2639 00001796 4154                        push r12
  2640 00001798 4155                        push r13
  2641 0000179A 4156                        push r14
  2642 0000179C 4157                        push r15
  2643                                  
  2644                                      ; 1) Obtener base de los bloques del nivel actual
  2645 0000179E E83FFDFFFF                  call get_current_level_blocks
  2646 000017A3 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2647                                  
  2648                                      ; 2) Obtener la cantidad de bloques
  2649 000017A6 E890FDFFFF                  call get_current_level_count
  2650 000017AB 4989C6                      mov r14, rax
  2651                                  
  2652 000017AE 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2653                                  
  2654                                  .find_block_loop:
  2655 000017B1 4D39F4                      cmp r12, r14
  2656 000017B4 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2657                                  
  2658                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2659 000017BA 4C89E0                      mov rax, r12
  2660 000017BD 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2661 000017C1 4C01E8                      add rax, r13
  2662 000017C4 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2663                                  
  2664                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2665 000017C7 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2665 000017CC [37150000]         
  2666 000017D0 4885DB                      test rbx, rbx
  2667 000017D3 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2668                                  
  2669                                      ; Obtener coordenadas
  2670 000017D9 418A17                      mov dl, [r15]         ; x
  2671 000017DC 418A4F01                    mov cl, [r15 + 1]     ; y
  2672                                  
  2673                                      ; Calcular posición en el board
  2674 000017E0 488D3D(000A0000)            lea rdi, [board]
  2675 000017E7 4831C0                      xor rax, rax
  2676 000017EA B84E000000                  mov rax, column_cells
  2677 000017EF 4883C002                    add rax, 2
  2678 000017F3 480FB6C9                    movzx rcx, cl         ; y
  2679 000017F7 480FAFC1                    imul rax, rcx
  2680 000017FB 4801C7                      add rdi, rax
  2681 000017FE 480FB6C2                    movzx rax, dl         ; x
  2682 00001802 4801C7                      add rdi, rax
  2683                                  
  2684                                      ; Guardar la posición base del bloque
  2685 00001805 57                          push rdi
  2686                                  
  2687                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2688 00001806 4939FA                      cmp r10, rdi
  2689 00001809 7274                        jb .skip_collision
  2690 0000180B 488D5F06                    lea rbx, [rdi + block_length]
  2691 0000180F 4939DA                      cmp r10, rbx
  2692 00001812 736B                        jae .skip_collision
  2693                                  
  2694                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2695 00001814 41FE8C24[37150000]          dec byte [block_states + r12]
  2696                                      ; Volver a cargar durabilidad
  2697 0000181C 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2697 00001821 [37150000]         
  2698 00001825 4885DB                      test rbx, rbx
  2699 00001828 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2700                                  
  2701                                      ; >>> Llegó a 0 => Bloque destruido
  2702 0000182A 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2703 0000182B B906000000                  mov rcx, block_length
  2704                                  .clear_loop:
  2705 00001830 C60720                      mov byte [rdi], ' '
  2706 00001833 48FFC7                      inc rdi
  2707 00001836 E2F8                        loop .clear_loop
  2708                                  
  2709                                      ; Dibujar letra del bloque destruido
  2710 00001838 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2711 0000183C 4883EF06                    sub rdi, block_length
  2712 00001840 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2713                                      ; Después de escribir la letra en el tablero
  2714 00001842 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2715 00001846 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2716 0000184A 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2717 0000184F E852EBFFFF                  call register_letter
  2718                                      ; Actualizar contadores globales
  2719 00001854 FE0D(FA140000)              dec byte [blocks_remaining]
  2720 0000185A FE05(A3150000)              inc byte [destroyed_blocks]
  2721                                  
  2722                                      ; Sumar puntos según el tipo
  2723 00001860 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2724 00001865 486BC00A                    imul rax, 10
  2725 00001869 480105(9B150000)            add [current_score], rax
  2726                                  
  2727 00001870 B801000000                  mov rax, 1  ; colisión con destrucción
  2728 00001875 EB14                        jmp .end_pop
  2729                                  
  2730                                  .update_display:
  2731                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2732 00001877 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2733 0000187C 5F                          pop rdi     ; pop que quedó pendiente
  2734 0000187D EB0C                        jmp .end_pop
  2735                                  
  2736                                  .skip_collision:
  2737 0000187F 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2738                                  .next_block:
  2739 00001880 49FFC4                      inc r12
  2740 00001883 E929FFFFFF                  jmp .find_block_loop
  2741                                  
  2742                                  .no_block_found:
  2743 00001888 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2744                                  
  2745                                  .end_pop:
  2746 0000188B 415F                        pop r15
  2747 0000188D 415E                        pop r14
  2748 0000188F 415D                        pop r13
  2749 00001891 415C                        pop r12
  2750 00001893 5E                          pop rsi
  2751 00001894 5F                          pop rdi
  2752 00001895 5B                          pop rbx
  2753 00001896 5D                          pop rbp
  2754 00001897 C3                          ret
  2755                                  
  2756                                  
  2757                                  
  2758                                  init_enemies:
  2759 00001898 55                          push rbp
  2760 00001899 4889E5                      mov rbp, rsp
  2761                                      ; Reiniciar contadores de movimiento
  2762 0000189C C605(E6150000)00            mov byte [enemy_move_total], 0
  2763 000018A3 C605(E7150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2764                                      ; Limpiar estado previo de enemigos
  2765 000018AA B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2766 000018AF 488D3D(BD150000)            lea rdi, [enemies]
  2767 000018B6 30C0                        xor al, al
  2768 000018B8 F3AA                        rep stosb ; Limpiar datos de enemigos
  2769                                      
  2770                                      ; Marcar todos los enemigos como inactivos
  2771 000018BA 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2772 000018C1 30C0                        xor al, al
  2773 000018C3 B90A000000                  mov rcx, 10
  2774 000018C8 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2775                                  
  2776 000018CA 5D                          pop rbp
  2777 000018CB C3                          ret
  2778                                  
  2779                                  
  2780                                  ; Función para mover enemigos
  2781                                  move_enemies:
  2782 000018CC 55                          push rbp
  2783 000018CD 4889E5                      mov rbp, rsp
  2784                                      
  2785                                      ; Incrementar contador de movimiento
  2786 000018D0 FE05(E4150000)              inc byte [enemy_move_counter]
  2787 000018D6 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2788 000018DE 3A05(E5150000)              cmp al, [enemy_move_delay]
  2789 000018E4 0F85AA010000                jne .end
  2790                                      
  2791                                      ; Resetear contador
  2792 000018EA C605(E4150000)00            mov byte [enemy_move_counter], 0
  2793                                      
  2794 000018F1 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2795                                      
  2796                                      .enemy_loop:
  2797 000018F4 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2798 000018F8 0F8D96010000                    jge .end
  2799                                          
  2800                                          ; Calcular offset del enemigo actual
  2801 000018FE 4C89E0                          mov rax, r12
  2802 00001901 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2803 00001905 488DB0[BD150000]                lea rsi, [enemies + rax]
  2804                                          
  2805                                          ; Verificar si el enemigo está activo
  2806 0000190C 807E0201                        cmp byte [rsi + 2], 1
  2807 00001910 0F8576010000                    jne .next_enemy
  2808                                          
  2809                                          ; Obtener posición actual
  2810 00001916 4C0FB606                        movzx r8, byte [rsi]            ; X
  2811 0000191A 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2812                                          
  2813                                          ; Limpiar posición actual antes de mover
  2814 0000191F 4150                            push r8
  2815 00001921 4151                            push r9
  2816 00001923 B84E000000                      mov rax, column_cells
  2817 00001928 4883C002                        add rax, 2
  2818 0000192C 49F7E1                          mul r9
  2819 0000192F 4C01C0                          add rax, r8
  2820 00001932 488DB8[000A0000]                lea rdi, [board + rax]
  2821 00001939 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2822 0000193C 4159                            pop r9
  2823 0000193E 4158                            pop r8
  2824                                  
  2825                                          ; Determinar comportamiento basado en índice
  2826 00001940 4C89E0                          mov rax, r12
  2827 00001943 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2828 00001947 4885C0                          test rax, rax
  2829 0000194A 7402                            jz .chase_ball
  2830 0000194C EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2831                                          
  2832                                          ; Perseguir bola (comportamiento original)
  2833                                      .chase_ball:
  2834 0000194E 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2835 00001955 4D39D0                          cmp r8, r10
  2836 00001958 0F8F96000000                    jg .move_left
  2837 0000195E 0F8C95000000                    jl .move_right
  2838                                          
  2839 00001964 4C8B15(67140000)                mov r10, [ball_y_pos]
  2840 0000196B 4D39D1                          cmp r9, r10
  2841 0000196E 0F8F8A000000                    jg .move_up
  2842 00001974 0F8C89000000                    jl .move_down
  2843 0000197A E9A5000000                      jmp .check_collision
  2844                                          
  2845                                      .chase_paddle:
  2846                                          ; Obtener la posición X actual de la paleta
  2847 0000197F 4C8B15(3F140000)                mov r10, [pallet_position]
  2848 00001986 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2849                                          
  2850                                          ; Calcular la posición X real de la paleta
  2851 0000198D 4C89D0                          mov rax, r10
  2852 00001990 BB4E000000                      mov rbx, column_cells
  2853 00001995 4883C302                        add rbx, 2                  ; Añadir newline chars
  2854 00001999 4831D2                          xor rdx, rdx
  2855 0000199C 48F7F3                          div rbx                     ; rax = y, rdx = x
  2856                                          
  2857                                          ; rdx ahora contiene la posición X de la paleta
  2858                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2859 0000199F 488B0D(47140000)                mov rcx, [pallet_size]
  2860 000019A6 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2861 000019A9 4801CA                          add rdx, rcx
  2862                                          
  2863                                          ; Comparar con posición X del enemigo y mover gradualmente
  2864 000019AC 4939D0                          cmp r8, rdx
  2865 000019AF 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2866 000019B1 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2867 000019B3 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2868                                  
  2869                                      .check_y_paddle:
  2870                                          ; La Y de la paleta siempre es row_cells - 2
  2871 000019B5 41BA20000000                    mov r10, row_cells
  2872 000019BB 4983EA02                        sub r10, 2
  2873                                          
  2874                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2875 000019BF 4D39D1                          cmp r9, r10
  2876 000019C2 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2877 000019C4 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2878 000019C6 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2879                                          
  2880                                      .no_movement:
  2881 000019C8 EB5A                            jmp .check_collision
  2882                                  
  2883                                      ; También agregar una nueva sección para el movimiento suave
  2884                                      .smooth_transition:
  2885                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2886 000019CA 8A05(E7150000)                  mov al, [enemy_target]
  2887 000019D0 84C0                            test al, al
  2888 000019D2 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2889                                          
  2890                                          ; Verificar distancia en X
  2891 000019D4 4989D2                          mov r10, rdx              ; Posición X objetivo
  2892 000019D7 4D29C2                          sub r10, r8               ; Calcular diferencia
  2893 000019DA 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2894 000019DE 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2895 000019E0 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2896 000019E4 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2897 000019E6 EB3C                            jmp .check_collision
  2898                                          
  2899                                      .limit_right_movement:
  2900 000019E8 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2901 000019EC EB36                            jmp .check_collision
  2902                                          
  2903                                      .limit_left_movement:
  2904 000019EE 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2905 000019F2 EB30                            jmp .check_collision
  2906                                      .move_left:
  2907 000019F4 49FFC8                          dec r8
  2908 000019F7 EB0F                            jmp .check_vertical
  2909                                          
  2910                                      .move_right:
  2911 000019F9 49FFC0                          inc r8
  2912 000019FC EB0A                            jmp .check_vertical
  2913                                          
  2914                                      .move_up:
  2915 000019FE 49FFC9                          dec r9
  2916 00001A01 EB21                            jmp .check_collision
  2917                                          
  2918                                      .move_down:
  2919 00001A03 49FFC1                          inc r9
  2920 00001A06 EB1C                            jmp .check_collision
  2921                                          
  2922                                      .check_vertical:
  2923 00001A08 8A05(E7150000)                  mov al, [enemy_target]
  2924 00001A0E 84C0                            test al, al
  2925 00001A10 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2926 00001A16 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2927 00001A1D 4D39D1                          cmp r9, r10
  2928 00001A20 7FDC                            jg .move_up
  2929 00001A22 7CDF                            jl .move_down
  2930                                          
  2931                                      .check_collision:
  2932                                          ; Verificar colisión con bordes
  2933 00001A24 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2934 00001A28 7E62                            jle .next_enemy
  2935 00001A2A 4983F84E                        cmp r8, column_cells
  2936 00001A2E 7D5C                            jge .next_enemy
  2937 00001A30 4983F901                        cmp r9, 1                       ; Borde superior
  2938 00001A34 7E56                            jle .next_enemy
  2939 00001A36 4983F920                        cmp r9, row_cells
  2940 00001A3A 7D50                            jge .next_enemy
  2941                                          
  2942                                          ; Verificar colisión con bloques antes de moverse
  2943 00001A3C 4150                            push r8
  2944 00001A3E 4151                            push r9
  2945 00001A40 4152                            push r10
  2946                                          
  2947                                          ; Calcular posición en el tablero para verificar
  2948 00001A42 B84E000000                      mov rax, column_cells
  2949 00001A47 4883C002                        add rax, 2
  2950 00001A4B 49F7E1                          mul r9
  2951 00001A4E 4C01C0                          add rax, r8
  2952 00001A51 4C8D90[000A0000]                lea r10, [board + rax]
  2953                                          
  2954                                          ; Verificar si hay un bloque en la nueva posición
  2955 00001A58 418A02                          mov al, [r10]
  2956 00001A5B 3C55                            cmp al, 'U'
  2957 00001A5D 7427                            je .invalid_move
  2958 00001A5F 3C4F                            cmp al, 'O'
  2959 00001A61 7423                            je .invalid_move
  2960 00001A63 3C44                            cmp al, 'D'
  2961 00001A65 741F                            je .invalid_move
  2962 00001A67 3C4C                            cmp al, 'L'
  2963 00001A69 741B                            je .invalid_move
  2964 00001A6B 3C56                            cmp al, 'V'
  2965 00001A6D 7417                            je .invalid_move
  2966 00001A6F 3C38                            cmp al, '8'
  2967 00001A71 7413                            je .invalid_move
  2968 00001A73 3C58                            cmp al, 'X'
  2969 00001A75 740F                            je .invalid_move
  2970                                          
  2971 00001A77 415A                            pop r10
  2972 00001A79 4159                            pop r9
  2973 00001A7B 4158                            pop r8
  2974                                          
  2975                                          ; Guardar nueva posición si es válida
  2976 00001A7D 448806                          mov [rsi], r8b
  2977 00001A80 44884E01                        mov [rsi + 1], r9b
  2978 00001A84 EB06                            jmp .next_enemy
  2979                                          
  2980                                      .invalid_move:
  2981 00001A86 415A                            pop r10
  2982 00001A88 4159                            pop r9
  2983 00001A8A 4158                            pop r8
  2984                                          
  2985                                      .next_enemy:
  2986 00001A8C 49FFC4                          inc r12
  2987 00001A8F E960FEFFFF                      jmp .enemy_loop
  2988                                          
  2989                                      .end:
  2990 00001A94 5D                              pop rbp
  2991 00001A95 C3                              ret
  2992                                  
  2993                                  get_current_spawn_points:
  2994 00001A96 55                          push rbp
  2995 00001A97 4889E5                      mov rbp, rsp
  2996                                      
  2997 00001A9A 480FB605(F9140000)          movzx rax, byte [current_level]
  2998 00001AA2 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2999 00001AA5 488B04C5[1B160000]          mov rax, [spawn_points_table + rax * 8]
  3000                                      
  3001 00001AAD 5D                          pop rbp
  3002 00001AAE C3                          ret
  3003                                  
  3004                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3005                                  check_enemy_spawn:
  3006 00001AAF 55                          push rbp
  3007 00001AB0 4889E5                      mov rbp, rsp
  3008                                      
  3009                                      ; Obtener spawn points del nivel actual
  3010 00001AB3 E8DEFFFFFF                  call get_current_spawn_points
  3011 00001AB8 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3012                                      
  3013                                      ; Obtener cantidad de bloques destruidos
  3014 00001ABB 4C0FB62D(A3150000)          movzx r13, byte [destroyed_blocks]
  3015                                      
  3016                                      ; Verificar cada punto de spawn
  3017 00001AC3 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3018                                      
  3019                                      .check_loop:
  3020 00001AC6 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3021 00001ACA 7D4B                            jge .end
  3022                                          
  3023                                          ; Verificar si este spawn point ya fue usado
  3024 00001ACC 80B9[46160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3025 00001AD3 743D                            je .next_enemy
  3026                                          
  3027                                          ; Verificar si este enemigo ya está activo
  3028 00001AD5 4889C8                          mov rax, rcx
  3029 00001AD8 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3030 00001ADC 488DB0[BD150000]                lea rsi, [enemies + rax]
  3031 00001AE3 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3032 00001AE7 7429                            je .next_enemy
  3033                                          
  3034                                          ; Verificar si debemos spawnear este enemigo
  3035 00001AE9 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3036 00001AEE 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3037 00001AF1 751F                            jne .next_enemy
  3038                                          
  3039                                          ; Marcar este spawn point como usado
  3040 00001AF3 C681[46160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3041                                          
  3042                                          ; Spawner nuevo enemigo
  3043 00001AFA C60628                          mov byte [rsi], 40             ; X inicial
  3044 00001AFD C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  3045 00001B01 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  3046                                          
  3047                                          ; Inicializar comportamiento
  3048 00001B05 4889C8                          mov rax, rcx
  3049 00001B08 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3050 00001B0C 8805(45160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3051                                          
  3052                                      .next_enemy:
  3053 00001B12 48FFC1                          inc rcx
  3054 00001B15 EBAF                            jmp .check_loop
  3055                                          
  3056                                      .end:
  3057 00001B17 5D                              pop rbp
  3058 00001B18 C3                              ret
  3059                                  
  3060                                  
  3061                                  ; Función para dibujar enemigos
  3062                                  print_enemies:
  3063 00001B19 55                          push rbp
  3064 00001B1A 4889E5                      mov rbp, rsp
  3065                                      
  3066 00001B1D 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3067                                      
  3068                                      .print_loop:
  3069 00001B20 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3070 00001B24 7D4B                            jge .end
  3071                                          
  3072                                          ; Calcular offset del enemigo actual
  3073 00001B26 4C89E0                          mov rax, r12
  3074 00001B29 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3075 00001B2D 488DB0[BD150000]                lea rsi, [enemies + rax]
  3076                                          
  3077                                          ; Verificar si el enemigo está activo
  3078 00001B34 807E0201                        cmp byte [rsi + 2], 1
  3079 00001B38 7532                            jne .next_enemy
  3080                                          
  3081                                          ; Calcular posición en el tablero
  3082 00001B3A 4C0FB606                        movzx r8, byte [rsi]            ; X
  3083 00001B3E 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3084                                          
  3085                                          ; Calcular offset en el tablero
  3086 00001B43 B84E000000                      mov rax, column_cells
  3087 00001B48 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3088 00001B4C 49F7E1                          mul r9
  3089 00001B4F 4C01C0                          add rax, r8
  3090 00001B52 488DB8[000A0000]                lea rdi, [board + rax]
  3091                                          
  3092                                          ; Obtener carácter del enemigo según el nivel
  3093 00001B59 480FB605(F9140000)              movzx rax, byte [current_level]
  3094 00001B61 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3095 00001B64 8A80[B8150000]                  mov al, [enemy_chars + rax]
  3096                                          
  3097                                          ; Dibujar enemigo
  3098 00001B6A 8807                            mov [rdi], al
  3099                                          
  3100                                      .next_enemy:
  3101 00001B6C 49FFC4                          inc r12
  3102 00001B6F EBAF                            jmp .print_loop
  3103                                          
  3104                                      .end:
  3105 00001B71 5D                              pop rbp
  3106 00001B72 C3                              ret
  3107                                  
  3108                                  ; Función para verificar colisión con enemigos
  3109                                  ; Función para verificar colisión con enemigos
  3110                                  check_enemy_collision:
  3111 00001B73 55                          push rbp
  3112 00001B74 4889E5                      mov rbp, rsp
  3113                                      
  3114 00001B77 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3115 00001B7A 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3116                                      
  3117                                      .check_loop:
  3118 00001B7D 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3119 00001B81 0F8DE9000000                    jge .end
  3120                                          
  3121                                          ; Calcular offset del enemigo actual
  3122 00001B87 4C89E1                          mov rcx, r12
  3123 00001B8A 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3124 00001B8E 488DB1[BD150000]                lea rsi, [enemies + rcx]
  3125                                          
  3126                                          ; Verificar si el enemigo está activo
  3127 00001B95 807E0201                        cmp byte [rsi + 2], 1
  3128 00001B99 0F85C9000000                    jne .next_enemy
  3129                                          
  3130                                          ; Verificar colisión con la bola
  3131 00001B9F 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3132 00001BA3 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3133                                          
  3134                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3135 00001BA8 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3136 00001BAF 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3137                                          
  3138                                          ; Comprobar colisión vertical (misma columna)
  3139 00001BB6 4D39C2                          cmp r10, r8
  3140 00001BB9 7525                            jne .check_horizontal
  3141 00001BBB 4D29CB                          sub r11, r9
  3142 00001BBE 4983FB01                        cmp r11, 1
  3143 00001BC2 7F1C                            jg .check_horizontal
  3144 00001BC4 4983FBFF                        cmp r11, -1
  3145 00001BC8 7C16                            jl .check_horizontal
  3146                                          
  3147                                          ; Colisión vertical detectada
  3148 00001BCA E8A3000000                      call destroy_enemy
  3149 00001BCF 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3150 00001BD6 B801000000                      mov rax, 1
  3151 00001BDB E990000000                      jmp .end
  3152                                          
  3153                                      .check_horizontal:
  3154                                          ; Comprobar colisión horizontal (misma fila)
  3155 00001BE0 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3156 00001BE7 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3157 00001BEE 4D39CB                          cmp r11, r9
  3158 00001BF1 7522                            jne .check_paddle
  3159 00001BF3 4D29C2                          sub r10, r8
  3160 00001BF6 4983FA01                        cmp r10, 1
  3161 00001BFA 7F19                            jg .check_paddle
  3162 00001BFC 4983FAFF                        cmp r10, -1
  3163 00001C00 7C13                            jl .check_paddle
  3164                                          
  3165                                          ; Colisión horizontal detectada
  3166 00001C02 E86B000000                      call destroy_enemy
  3167 00001C07 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3168 00001C0E B801000000                      mov rax, 1
  3169 00001C13 EB5B                            jmp .end
  3170                                          
  3171                                      .check_paddle:
  3172                                          ; Verificar colisión con la paleta
  3173 00001C15 4C8B15(3F140000)                mov r10, [pallet_position]
  3174 00001C1C 4981EA[000A0000]                sub r10, board
  3175 00001C23 4C89D0                          mov rax, r10
  3176 00001C26 41BB4E000000                    mov r11, column_cells
  3177 00001C2C 4983C302                        add r11, 2
  3178 00001C30 4831D2                          xor rdx, rdx
  3179 00001C33 49F7F3                          div r11                     ; División para obtener la posición Y
  3180 00001C36 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3181                                          
  3182 00001C39 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3183                                          
  3184                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3185 00001C40 41BD20000000                    mov r13, row_cells
  3186 00001C46 4983ED02                        sub r13, 2                 ; Y de la paleta
  3187 00001C4A 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3188 00001C4D 7519                            jne .next_enemy
  3189                                          
  3190                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3191 00001C4F 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3192 00001C52 7C14                            jl .next_enemy
  3193                                          
  3194 00001C54 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3195 00001C57 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3196 00001C5A 7F0C                            jg .next_enemy
  3197                                          
  3198                                          ; Si llegamos aquí, hay colisión con la paleta
  3199 00001C5C E811000000                      call destroy_enemy        ; Destruir el enemigo
  3200 00001C61 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3201 00001C66 EB08                            jmp .end
  3202                                          
  3203                                      .next_enemy:
  3204 00001C68 49FFC4                          inc r12
  3205 00001C6B E90DFFFFFF                      jmp .check_loop
  3206                                          
  3207                                      .end:
  3208 00001C70 5D                              pop rbp
  3209 00001C71 C3                              ret
  3210                                  
  3211                                  ; Función para destruir un enemigo
  3212                                  destroy_enemy:
  3213                                      ; Desactivar enemigo
  3214 00001C72 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3215                                  
  3216                                      ; Sumar puntos por destruir enemigo
  3217 00001C76 488B05(DC150000)            mov rax, [enemy_points]
  3218 00001C7D 480105(9B150000)            add [current_score], rax
  3219                                  
  3220                                      ; No tocar bloques destruidos aquí
  3221 00001C84 C3                          ret
  3222                                  
  3223                                  
  3224                                  _start:
  3225 00001C85 E8A1E4FFFF              	call canonical_off
  3226 00001C8A E846010000              	call start_screen
  3227 00001C8F E8ADF5FFFF                  call init_level
  3228 00001C94 E8FFFBFFFF                  call init_enemies
  3229 00001C99 EB00                    	jmp .main_loop
  3230                                  	
  3231                                  
  3232                                  	.main_loop:
  3233 00001C9B E8B6F9FFFF                      call print_labels
  3234 00001CA0 E8E5F8FFFF                      call print_blocks
  3235 00001CA5 E8CDE7FFFF                      call move_letters
  3236 00001CAA E862EAFFFF                      call update_lasers
  3237 00001CAF E838E7FFFF                      call print_letters
  3238                                  
  3239 00001CB4 E803EEFFFF              		call print_pallet
  3240 00001CB9 E816EFFFFF                      call move_ball
  3241 00001CBE E81BE6FFFF                      call check_bottom_collision
  3242 00001CC3 E815E5FFFF                      call print_lives
  3243                                  
  3244                                          ; -- Mover/imprimir bola 2 si está activa --
  3245 00001CC8 803D(A2140000)01                cmp byte [ball2_active], 1
  3246 00001CCF 7505                            jne .skip_ball2
  3247 00001CD1 E8D1F0FFFF                          call move_ball_2
  3248                                          .skip_ball2:
  3249                                  
  3250                                          ; -- Mover/imprimir bola 3 si está activa --
  3251 00001CD6 803D(C4140000)01                cmp byte [ball3_active], 1
  3252 00001CDD 7505                            jne .skip_ball3
  3253 00001CDF E896F2FFFF                          call move_ball_3
  3254                                          .skip_ball3:
  3255                                  
  3256                                          ; -- Ahora imprimimos las 3 bolas (si están activas) --
  3257 00001CE4 E85BEDFFFF                      call print_ball
  3258 00001CE9 803D(A2140000)01                cmp byte [ball2_active], 1
  3259 00001CF0 7505                            jne .no_pb2
  3260 00001CF2 E875EDFFFF                          call print_ball_2
  3261                                          .no_pb2:
  3262 00001CF7 803D(C4140000)01                cmp byte [ball3_active], 1
  3263 00001CFE 7505                            jne .no_pb3
  3264 00001D00 E88FEDFFFF                          call print_ball_3
  3265                                          .no_pb3:
  3266                                  
  3267 00001D05 E8E2F6FFFF                      call check_level_complete
  3268 00001D0A E8A0FDFFFF                      call check_enemy_spawn
  3269 00001D0F E8B8FBFFFF                      call move_enemies
  3270 00001D14 E85AFEFFFF                      call check_enemy_collision
  3271 00001D19 E8FBFDFFFF                      call print_enemies
  3272 00001D1E E821EDFFFF              		call print_ball
  3273                                  		print board, board_size				
    82 00001D23 B801000000          <1>  mov eax, sys_write
    83 00001D28 BF01000000          <1>  mov edi, 1
    84 00001D2D 48BE-               <1>  mov rsi, %1
    84 00001D2F [000A000000000000]  <1>
    85 00001D37 BA000A0000          <1>  mov edx, %2
    86 00001D3C 0F05                <1>  syscall
  3274                                  		;setnonblocking	
  3275                                  	.read_more:	
  3276                                  	    getchar	
    90 00001D3E B800000000          <1>  mov rax, sys_read
    91 00001D43 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001D48 48BE-               <1>  mov rsi, input_char
    92 00001D4A [0000000000000000]  <1>
    93 00001D52 BA01000000          <1>  mov rdx, 1
    94 00001D57 0F05                <1>  syscall
  3277 00001D59 4883F801                	    cmp rax, 1
  3278 00001D5D 7543                    	    jne .done
  3279                                  	
  3280 00001D5F 8A05(00000000)          	    mov al, [input_char]
  3281 00001D65 8805(62180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3282                                  	
  3283 00001D6B 3C61                    	    cmp al, 'a'
  3284 00001D6D 750E                    	    jne .not_left
  3285 00001D6F 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3286 00001D76 E876EDFFFF              	    call move_pallet
  3287 00001D7B EB25                    	    jmp .done
  3288                                  	
  3289                                      .not_left:
  3290 00001D7D 3C64                    	    cmp al, 'd'
  3291 00001D7F 750C                    	    jne .not_right
  3292 00001D81 BF01000000              	    mov rdi, right_direction
  3293 00001D86 E866EDFFFF              	    call move_pallet
  3294 00001D8B EB15                    	    jmp .done
  3295                                  	
  3296                                      .not_right:
  3297 00001D8D 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3298 00001D8F 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3299                                  	
  3300 00001D91 3C71                    	    cmp al, 'q' 
  3301 00001D93 0F84AF000000            	    je exit
  3302 00001D99 EBA3                    	    jmp .read_more
  3303                                  	
  3304                                      .release_ball:
  3305 00001D9B E8ADF3FFFF              	    call process_catch_release
  3306 00001DA0 EB00                    	    jmp .done
  3307                                  	
  3308                                      .done:
  3309                                  	    sleeptime
    98 00001DA2 B823000000          <1>  mov eax, sys_nanosleep
    99 00001DA7 48BF-               <1>  mov rdi, timespec
    99 00001DA9 [0000000000000000]  <1>
   100 00001DB1 31F6                <1>  xor esi, esi
   101 00001DB3 0F05                <1>  syscall
  3310                                  	    print clear, clear_length
    82 00001DB5 B801000000          <1>  mov eax, sys_write
    83 00001DBA BF01000000          <1>  mov edi, 1
    84 00001DBF 48BE-               <1>  mov rsi, %1
    84 00001DC1 [1000000000000000]  <1>
    85 00001DC9 BA07000000          <1>  mov edx, %2
    86 00001DCE 0F05                <1>  syscall
  3311 00001DD0 E9C6FEFFFF              	    jmp .main_loop
  3312                                  
  3313                                  
  3314                                  
  3315                                  
  3316                                  start_screen:
  3317                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001DD5 B801000000          <1>  mov eax, sys_write
    83 00001DDA BF01000000          <1>  mov edi, 1
    84 00001DDF 48BE-               <1>  mov rsi, %1
    84 00001DE1 [1000000000000000]  <1>
    85 00001DE9 BA07000000          <1>  mov edx, %2
    86 00001DEE 0F05                <1>  syscall
  3318                                      print msg1, msg1_length
    82 00001DF0 B801000000          <1>  mov eax, sys_write
    83 00001DF5 BF01000000          <1>  mov edi, 1
    84 00001DFA 48BE-               <1>  mov rsi, %1
    84 00001DFC [1700000000000000]  <1>
    85 00001E04 BA14010000          <1>  mov edx, %2
    86 00001E09 0F05                <1>  syscall
  3319                                      
  3320                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3321                                          getchar                 ; Esperamos una tecla
    90 00001E0B B800000000          <1>  mov rax, sys_read
    91 00001E10 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001E15 48BE-               <1>  mov rsi, input_char
    92 00001E17 [0000000000000000]  <1>
    93 00001E1F BA01000000          <1>  mov rdx, 1
    94 00001E24 0F05                <1>  syscall
  3322 00001E26 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3323 00001E2A 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3324                                          
  3325                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001E2C B801000000          <1>  mov eax, sys_write
    83 00001E31 BF01000000          <1>  mov edi, 1
    84 00001E36 48BE-               <1>  mov rsi, %1
    84 00001E38 [1000000000000000]  <1>
    85 00001E40 BA07000000          <1>  mov edx, %2
    86 00001E45 0F05                <1>  syscall
  3326 00001E47 C3                          ret
  3327                                  
  3328                                  exit: 
  3329 00001E48 E820E3FFFF              	call canonical_on
  3330 00001E4D B83C000000              	mov    rax, 60
  3331 00001E52 BF00000000                  mov    rdi, 0
  3332 00001E57 0F05                        syscall
  3333                                  
