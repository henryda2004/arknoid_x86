     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 38070302                        db 56, 7, 3, 2    ; Bloque 7
   288                                      level1_blocks_count equ 1   ; Cantidad total de bloques
   289                                  
   290                                      ; Nivel 2: Bloques de prueba
   291                                      level2_blocks:
   292 000014AA 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   293                                      level2_blocks_count equ 1
   294                                  
   295                                      ; Nivel 3
   296                                      level3_blocks:
   297 000014AE 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   298                                  
   299                                      level3_blocks_count equ 1
   300                                  
   301                                      ; Nivel 4
   302                                      level4_blocks:
   303 000014B2 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   304                                      level4_blocks_count equ 1
   305                                  
   306                                      ; Nivel 5
   307                                      level5_blocks:
   308 000014B6 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   309                                      level5_blocks_count equ 1
   310                                  
   311                                      ; Array para mantener el estado de los bloques
   312 000014BA 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   313                                  
   314 0000151E 50756E74616A653A20          score_label db "Puntaje: "
   315                                      score_label_len equ $ - score_label
   316 00001527 426C6F717565732064-         blocks_label db "Bloques destruidos: "
   316 00001530 657374727569646F73-
   316 00001539 3A20               
   317                                      blocks_label_len equ $ - blocks_label
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153B 0000000000000000            current_score dq 0          ; Score actual
   321 00001543 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001544 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 00001558 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155D 00<rep Fh>                  enemies: times 5 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000156C 02                          enemies_count db 2            ; Cantidad de enemigos activos
   331                                      
   332 0000156D 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001575 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001576 03                          enemy_move_delay db 3           ; Mover enemigos cada N ciclos
   335 00001577 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001578 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 00001579 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                  
   339                                  section .text
   340                                  
   341                                  ;	Function: print_ball
   342                                  ; This function displays the position of the ball
   343                                  ; Arguments: none
   344                                  ;
   345                                  ; Return:
   346                                  ;	Void
   347                                  print_ball:
   348 000001DD 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   349 000001E4 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   350 000001EB 4981C0[000A0000]        	add r8, board
   351                                  
   352 000001F2 4C89C9                  	mov rcx, r9
   353 000001F5 B850000000              	mov rax, column_cells + 2
   354 000001FA 48F7E9                  	imul rcx
   355                                  	
   356 000001FD 4901C0                  	add r8, rax
   357 00000200 41C6004F                	mov byte [r8], char_O
   358 00000204 C3                      	ret
   359                                  
   360                                  	
   361                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   362                                  	
   363                                  
   364                                  
   365                                  
   366                                  ;	Function: print_pallet
   367                                  ; This function moves the pallet in the game
   368                                  ; Arguments: none
   369                                  ;
   370                                  ; Return;
   371                                  ;	void
   372                                  print_pallet:
   373 00000205 4C8B05(3F140000)        	mov r8, [pallet_position]
   374 0000020C 488B0D(47140000)        	mov rcx, [pallet_size]
   375                                  	.write_pallet:
   376 00000213 41C6003D                		mov byte [r8], char_equal
   377 00000217 49FFC0                  		inc r8
   378 0000021A 48FFC9                  		dec rcx
   379 0000021D 75F4                    		jnz .write_pallet
   380                                  
   381 0000021F C3                      	ret
   382                                  	
   383                                  ;	Function: move_pallet
   384                                  ; This function is in charge of moving the pallet in a given direction
   385                                  ; Arguments:
   386                                  ;	rdi: left direction or right direction
   387                                  ;
   388                                  ; Return:
   389                                  ;	void
   390                                  move_pallet:
   391                                      
   392 00000220 803D(6F140000)00            cmp byte [ball_moving], 0
   393 00000227 7507                        jne .continue_movement
   394 00000229 C605(6F140000)01            mov byte [ball_moving], 1
   395                                  
   396                                      .continue_movement:
   397 00000230 4883FFFF                        cmp rdi, left_direction
   398 00000234 7531                            jne .move_right
   399                                  
   400                                          .move_left:
   401                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   402 00000236 4C8B05(3F140000)                    mov r8, [pallet_position]
   403 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   404 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   405 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   406 00000245 744D                                je .end            ; Si es X, no mover
   407                                              
   408 00000247 4C8B05(3F140000)                    mov r8, [pallet_position]
   409 0000024E 4C8B0D(47140000)                    mov r9, [pallet_size]
   410 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   411 0000025B 49FFC8                              dec r8
   412 0000025E 4C8905(3F140000)                    mov [pallet_position], r8
   413 00000265 EB2D                                jmp .end
   414                                              
   415                                          .move_right:
   416                                              ; Verificar si la siguiente posición después de la paleta sería una X
   417 00000267 4C8B05(3F140000)                    mov r8, [pallet_position]
   418 0000026E 4C8B0D(47140000)                    mov r9, [pallet_size]
   419 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   420 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   421 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   422 0000027D 7415                                je .end            ; Si es X, no mover
   423                                              
   424 0000027F 4C8B05(3F140000)                    mov r8, [pallet_position]
   425 00000286 41C60020                            mov byte [r8], char_space
   426 0000028A 49FFC0                              inc r8
   427 0000028D 4C8905(3F140000)                    mov [pallet_position], r8
   428                                          .end:
   429 00000294 C3                                  ret
   430                                  
   431                                  move_ball:
   432                                      ; Si la bola no está en movimiento, no hacer nada
   433 00000295 803D(6F140000)00            cmp byte [ball_moving], 0
   434 0000029C 0F8406010000                je .end
   435                                  
   436                                      ; Borrar la posición actual de la bola
   437 000002A2 4C8B05(4F140000)            mov r8, [ball_x_pos]
   438 000002A9 4C8B0D(57140000)            mov r9, [ball_y_pos]
   439 000002B0 4981C0[000A0000]            add r8, board
   440 000002B7 4C89C9                      mov rcx, r9
   441 000002BA B850000000                  mov rax, column_cells + 2
   442 000002BF 48F7E9                      imul rcx
   443 000002C2 4901C0                      add r8, rax
   444 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   445                                  
   446                                      ; Calcular siguiente posición X
   447 000002C9 4C8B05(4F140000)            mov r8, [ball_x_pos]
   448 000002D0 4C8B0D(57140000)            mov r9, [ball_y_pos]
   449 000002D7 488B05(5F140000)            mov rax, [ball_direction_x]
   450 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   451                                  
   452                                      ; Calcular la dirección de memoria para la siguiente posición
   453 000002E1 4D89C2                      mov r10, r8
   454 000002E4 4981C2[000A0000]            add r10, board
   455 000002EB 4C89C9                      mov rcx, r9
   456 000002EE B850000000                  mov rax, column_cells + 2
   457 000002F3 48F7E9                      imul rcx
   458 000002F6 4901C2                      add r10, rax
   459                                  
   460                                      ; Verificar si hay una X en la siguiente posición X
   461 000002F9 418A02                      mov al, [r10]
   462 000002FC 3C58                        cmp al, 'X'
   463 000002FE 750C                        jne .check_block_x
   464 00000300 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   465 00000307 E99C000000                  jmp .end
   466                                  
   467                                      .check_block_x:
   468                                          ; Verificar colisión con bloques en X
   469 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   470 0000030E 4151                            push r9
   471 00000310 4152                            push r10
   472 00000312 E8D4050000                      call check_block_collision
   473 00000317 415A                            pop r10
   474 00000319 4159                            pop r9
   475 0000031B 4158                            pop r8
   476 0000031D 4885C0                          test rax, rax
   477 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   478 00000322 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   479 00000329 EB7D                            jmp .end
   480                                  
   481                                      .check_paddle_x:
   482                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   483 0000032B 41803A3D                        cmp byte [r10], char_equal
   484 0000032F 7509                            jne .check_y_movement
   485 00000331 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   486 00000338 EB6E                            jmp .end
   487                                  
   488                                      .check_y_movement:
   489                                          ; Calcular siguiente posición Y
   490 0000033A 488B05(67140000)                mov rax, [ball_direction_y]
   491 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   492                                  
   493                                          ; Calcular la dirección de memoria para la siguiente posición Y
   494 00000344 4D89C2                          mov r10, r8
   495 00000347 4981C2[000A0000]                add r10, board
   496 0000034E 4C89C9                          mov rcx, r9
   497 00000351 B850000000                      mov rax, column_cells + 2
   498 00000356 48F7E9                          imul rcx
   499 00000359 4901C2                          add r10, rax
   500                                  
   501                                          ; Verificar si hay una X en la siguiente posición Y
   502 0000035C 418A02                          mov al, [r10]
   503 0000035F 3C58                            cmp al, 'X'
   504 00000361 7509                            jne .check_block_y
   505 00000363 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   506 0000036A EB3C                            jmp .end
   507                                  
   508                                      .check_block_y:
   509                                          ; Verificar colisión con bloques en Y
   510 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   511 0000036E 4151                            push r9
   512 00000370 4152                            push r10
   513 00000372 E874050000                      call check_block_collision
   514 00000377 415A                            pop r10
   515 00000379 4159                            pop r9
   516 0000037B 4158                            pop r8
   517 0000037D 4885C0                          test rax, rax
   518 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   519 00000382 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   520 00000389 EB1D                            jmp .end
   521                                  
   522                                      .check_paddle_y:
   523                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   524 0000038B 41803A3D                    cmp byte [r10], char_equal
   525 0000038F 7509                        jne .update_position
   526 00000391 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   527 00000398 EB0E                        jmp .end
   528                                  
   529                                  
   530                                      .update_position:
   531 0000039A 4C8905(4F140000)                mov [ball_x_pos], r8
   532 000003A1 4C890D(57140000)                mov [ball_y_pos], r9
   533                                  
   534                                      .end:
   535 000003A8 C3                              ret
   536                                  
   537                                  ; Función para inicializar el nivel
   538                                  ; Función para inicializar el nivel
   539                                  ; Función para mostrar el número de nivel
   540                                  display_level_number:
   541 000003A9 55                          push rbp
   542 000003AA 4889E5                      mov rbp, rsp
   543                                      
   544                                      ; Limpiar la pantalla primero
   545                                      print clear, clear_length
    82 000003AD B801000000          <1>  mov eax, sys_write
    83 000003B2 BF01000000          <1>  mov edi, 1
    84 000003B7 48BE-               <1>  mov rsi, %1
    84 000003B9 [1000000000000000]  <1>
    85 000003C1 BA07000000          <1>  mov edx, %2
    86 000003C6 0F05                <1>  syscall
   546                                      
   547                                      ; Calcular la posición central para el mensaje
   548                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   549 000003C8 B84E000000                  mov rax, column_cells
   550 000003CD 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   551 000003D1 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   552                                      
   553                                      ; Calcular la fila central
   554 000003D4 BB20000000                  mov rbx, row_cells
   555 000003D9 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   556                                      
   557                                      ; Calcular el offset en el buffer
   558 000003DC B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   559 000003E1 48F7E3                      mul rbx                     ; multiplicar por la fila central
   560 000003E4 4801D8                      add rax, rbx                ; añadir el offset horizontal
   561                                      
   562                                      ; Escribir "NIVEL " en la posición calculada
   563 000003E7 488DB8[000A0000]            lea rdi, [board + rax]
   564 000003EE 48BE-                       mov rsi, level_msg
   564 000003F0 [2414000000000000] 
   565 000003F8 B906000000                  mov rcx, level_msg_len
   566 000003FD F3A4                        rep movsb
   567                                      
   568                                      ; Escribir el número del nivel
   569 000003FF 8A05(A4140000)              mov al, [current_level]
   570 00000405 0430                        add al, '0'                 ; convertir a ASCII
   571 00000407 8807                        mov [rdi], al
   572                                      
   573                                      ; Mostrar el board con el mensaje
   574                                      print board, board_size
    82 00000409 B801000000          <1>  mov eax, sys_write
    83 0000040E BF01000000          <1>  mov edi, 1
    84 00000413 48BE-               <1>  mov rsi, %1
    84 00000415 [000A000000000000]  <1>
    85 0000041D BA000A0000          <1>  mov edx, %2
    86 00000422 0F05                <1>  syscall
   575                                      
   576                                      ; Esperar un segundo
   577 00000424 B823000000                  mov rax, sys_nanosleep
   578 00000429 48BF-                       mov rdi, level_display_time
   578 0000042B [2F14000000000000] 
   579 00000433 4831F6                      xor rsi, rsi
   580 00000436 0F05                        syscall
   581                                      
   582 00000438 5D                          pop rbp
   583 00000439 C3                          ret
   584                                  
   585                                  ; Función para inicializar un tablero vacío
   586                                  init_empty_board:
   587 0000043A 56                          push rsi
   588 0000043B 57                          push rdi
   589 0000043C 51                          push rcx
   590 0000043D 50                          push rax
   591                                  
   592 0000043E 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   593 00000445 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   594 0000044C B9000A0000                  mov rcx, board_template_size
   595 00000451 F3A4                        rep movsb                   ; Copiar el tablero
   596                                  
   597 00000453 58                          pop rax
   598 00000454 59                          pop rcx
   599 00000455 5F                          pop rdi
   600 00000456 5E                          pop rsi
   601 00000457 C3                          ret
   602                                  
   603                                  
   604                                  init_level:
   605                                      ; 1) Copiamos board_template en board para que quede "virgen"
   606 00000458 C605(43150000)00            mov byte [destroyed_blocks], 0 
   607 0000045F E8D6FFFFFF                  call init_empty_board
   608 00000464 E840FFFFFF                  call display_level_number
   609 00000469 E87C050000                  call init_enemies
   610                                      
   611 0000046E 56                          push rsi
   612 0000046F 57                          push rdi
   613 00000470 51                          push rcx
   614 00000471 50                          push rax
   615                                  
   616 00000472 488D35(00000000)            lea rsi, [board_template]
   617 00000479 488D3D(000A0000)            lea rdi, [board]
   618 00000480 B9000A0000                  mov rcx, board_template_size
   619 00000485 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   620                                  
   621 00000487 58                          pop rax
   622 00000488 59                          pop rcx
   623 00000489 5F                          pop rdi
   624 0000048A 5E                          pop rsi
   625                                  
   626                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   627 0000048B 803D(A4140000)01            cmp byte [current_level], 1
   628 00000492 7431                        je .level1
   629 00000494 803D(A4140000)02            cmp byte [current_level], 2
   630 0000049B 7454                        je .level2
   631 0000049D 803D(A4140000)03            cmp byte [current_level], 3
   632 000004A4 7477                        je .level3
   633 000004A6 803D(A4140000)04            cmp byte [current_level], 4
   634 000004AD 0F8492000000                je .level4
   635 000004B3 803D(A4140000)05            cmp byte [current_level], 5
   636 000004BA 0F84AD000000                je .level5
   637 000004C0 E9D0000000                  jmp .done
   638                                  
   639                                      .level1:
   640 000004C5 C605(A5140000)01                mov byte [blocks_remaining], level1_blocks_count
   641 000004CC 4831C9                          xor rcx, rcx             
   642                                          .init_loop1:
   643 000004CF 4883F901                            cmp rcx, level1_blocks_count
   644 000004D3 0F8DBC000000                        jge .done
   645 000004D9 4889C8                              mov rax, rcx         
   646 000004DC 48C1E002                            shl rax, 2          
   647 000004E0 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   648 000004E6 8891[BA140000]                      mov byte [block_states + rcx], dl
   649 000004EC 48FFC1                              inc rcx
   650 000004EF EBDE                                jmp .init_loop1
   651                                  
   652                                      .level2:
   653 000004F1 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   654 000004F8 4831C9                          xor rcx, rcx             
   655                                          .init_loop2:
   656 000004FB 4883F901                            cmp rcx, level2_blocks_count
   657 000004FF 0F8D90000000                        jge .done
   658 00000505 4889C8                              mov rax, rcx         
   659 00000508 48C1E002                            shl rax, 2          
   660 0000050C 8A90[AD140000]                      mov dl, byte [level2_blocks + rax + 3]  
   661 00000512 8891[BA140000]                      mov byte [block_states + rcx], dl
   662 00000518 48FFC1                              inc rcx
   663 0000051B EBDE                                jmp .init_loop2
   664                                      .level3:
   665 0000051D C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   666 00000524 4831C9                          xor rcx, rcx             
   667                                          .init_loop3:
   668 00000527 4883F901                            cmp rcx, level3_blocks_count
   669 0000052B 7D68                                jge .done
   670 0000052D 4889C8                              mov rax, rcx         
   671 00000530 48C1E002                            shl rax, 2          
   672 00000534 8A90[B1140000]                      mov dl, byte [level3_blocks + rax + 3]  
   673 0000053A 8891[BA140000]                      mov byte [block_states + rcx], dl
   674 00000540 48FFC1                              inc rcx
   675 00000543 EBE2                                jmp .init_loop3
   676                                  
   677                                      .level4:
   678 00000545 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   679 0000054C 4831C9                          xor rcx, rcx             
   680                                          .init_loop4:
   681 0000054F 4883F901                            cmp rcx, level4_blocks_count
   682 00000553 7D40                                jge .done
   683 00000555 4889C8                              mov rax, rcx         
   684 00000558 48C1E002                            shl rax, 2          
   685 0000055C 8A90[B5140000]                      mov dl, byte [level4_blocks + rax + 3]  
   686 00000562 8891[BA140000]                      mov byte [block_states + rcx], dl
   687 00000568 48FFC1                              inc rcx
   688 0000056B EBE2                                jmp .init_loop4
   689                                  
   690                                      .level5:
   691 0000056D C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   692 00000574 4831C9                          xor rcx, rcx             
   693                                          .init_loop5:
   694 00000577 4883F901                            cmp rcx, level5_blocks_count
   695 0000057B 7D18                                jge .done
   696 0000057D 4889C8                              mov rax, rcx         
   697 00000580 48C1E002                            shl rax, 2          
   698 00000584 8A90[B9140000]                      mov dl, byte [level5_blocks + rax + 3]  
   699 0000058A 8891[BA140000]                      mov byte [block_states + rcx], dl
   700 00000590 48FFC1                              inc rcx
   701 00000593 EBE2                                jmp .init_loop5
   702                                      .done:
   703 00000595 C3                              ret
   704                                  
   705                                  
   706                                  ; Función para verificar y manejar la transición de nivel
   707                                  check_level_complete:
   708                                      ; Verificar si quedan bloques
   709 00000596 803D(A5140000)00            cmp byte [blocks_remaining], 0
   710 0000059D 753C                        jne .not_complete
   711                                      
   712                                      ; Incrementar el nivel
   713 0000059F FE05(A4140000)              inc byte [current_level]
   714                                      
   715                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   716 000005A5 803D(A4140000)06            cmp byte [current_level], 6
   717 000005AC 742E                        je game_win
   718                                      
   719                                      ; Reinicializar el juego para el siguiente nivel
   720 000005AE E8A5FEFFFF                  call init_level
   721                                      
   722                                      ; Reinicializar la posición de la bola y la paleta
   723 000005B3 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   723 000005BB 000000             
   724 000005BE 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   724 000005C6 000000             
   725 000005C9 C605(6F140000)00            mov byte [ball_moving], 0
   726 000005D0 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   726 000005D7 [38130000]         
   727                                      
   728                                      .not_complete:
   729 000005DB C3                              ret
   730                                  
   731                                      ; Nueva función para manejar la victoria del juego
   732                                  game_win:
   733                                      ; Limpiar la pantalla primero
   734                                      print clear, clear_length
    82 000005DC B801000000          <1>  mov eax, sys_write
    83 000005E1 BF01000000          <1>  mov edi, 1
    84 000005E6 48BE-               <1>  mov rsi, %1
    84 000005E8 [1000000000000000]  <1>
    85 000005F0 BA07000000          <1>  mov edx, %2
    86 000005F5 0F05                <1>  syscall
   735                                      
   736                                      ; Mensaje de victoria
   737 000005F7 488B05(3B150000)            mov rax, [current_score]    ; Obtener el puntaje final
   738 000005FE 48BF-                       mov rdi, number_buffer      ; Convertir a string
   738 00000600 [4415000000000000] 
   739 00000608 E8AE010000                  call number_to_string
   740                                      
   741                                      ; Definir mensaje de victoria
   742                                      section .data
   743 0000157A C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   743 00001583 616465732120C2A148-
   743 0000158C 61732067616E61646F-
   743 00001595 210A0D             
   744                                          win_msg_len: equ $ - win_msg
   745 00001598 50756E74616A652066-             score_msg: db "Puntaje final: "
   745 000015A1 696E616C3A20       
   746                                          score_msg_len: equ $ - score_msg
   747                                      section .text
   748                                      
   749                                      ; Imprimir mensajes
   750                                      print win_msg, win_msg_len
    82 0000060D B801000000          <1>  mov eax, sys_write
    83 00000612 BF01000000          <1>  mov edi, 1
    84 00000617 48BE-               <1>  mov rsi, %1
    84 00000619 [7A15000000000000]  <1>
    85 00000621 BA1E000000          <1>  mov edx, %2
    86 00000626 0F05                <1>  syscall
   751                                      print score_msg, score_msg_len
    82 00000628 B801000000          <1>  mov eax, sys_write
    83 0000062D BF01000000          <1>  mov edi, 1
    84 00000632 48BE-               <1>  mov rsi, %1
    84 00000634 [9815000000000000]  <1>
    85 0000063C BA0F000000          <1>  mov edx, %2
    86 00000641 0F05                <1>  syscall
   752                                      print number_buffer, 20
    82 00000643 B801000000          <1>  mov eax, sys_write
    83 00000648 BF01000000          <1>  mov edi, 1
    84 0000064D 48BE-               <1>  mov rsi, %1
    84 0000064F [4415000000000000]  <1>
    85 00000657 BA14000000          <1>  mov edx, %2
    86 0000065C 0F05                <1>  syscall
   753                                      
   754                                      ; Esperar un momento antes de salir
   755 0000065E 48C70597F9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   755 00000667 0000               
   756 00000669 48C70594F9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   756 00000672 0000               
   757                                      sleeptime
    98 00000674 B823000000          <1>  mov eax, sys_nanosleep
    99 00000679 48BF-               <1>  mov rdi, timespec
    99 0000067B [0000000000000000]  <1>
   100 00000683 31F6                <1>  xor esi, esi
   101 00000685 0F05                <1>  syscall
   758                                      
   759 00000687 E948080000                  jmp exit
   760                                  
   761                                  ; Función para imprimir los bloques
   762                                  ; Función modificada para imprimir bloques
   763                                  
   764                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   765                                  get_current_level_blocks:
   766 0000068C 803D(A4140000)01            cmp byte [current_level], 1
   767 00000693 7428                        je .level1
   768 00000695 803D(A4140000)02            cmp byte [current_level], 2
   769 0000069C 7427                        je .level2
   770 0000069E 803D(A4140000)03            cmp byte [current_level], 3
   771 000006A5 7426                        je .level3
   772 000006A7 803D(A4140000)04            cmp byte [current_level], 4
   773 000006AE 7425                        je .level4
   774 000006B0 803D(A4140000)05            cmp byte [current_level], 5
   775 000006B7 7424                        je .level5
   776                                      ; Si llegamos aquí, hay un error en el nivel
   777 000006B9 4831C0                      xor rax, rax
   778 000006BC C3                          ret
   779                                  
   780                                      .level1:
   781 000006BD 488D05(A6140000)                lea rax, [level1_blocks]
   782 000006C4 C3                              ret
   783                                      .level2:
   784 000006C5 488D05(AA140000)                lea rax, [level2_blocks]
   785 000006CC C3                              ret
   786                                      .level3:
   787 000006CD 488D05(AE140000)                lea rax, [level3_blocks]
   788 000006D4 C3                              ret
   789                                      .level4:
   790 000006D5 488D05(B2140000)                lea rax, [level4_blocks]
   791 000006DC C3                              ret
   792                                      .level5:
   793 000006DD 488D05(B6140000)                lea rax, [level5_blocks]
   794 000006E4 C3                              ret
   795                                  ; Función para obtener la cantidad de bloques del nivel actual
   796                                  get_current_level_count:
   797 000006E5 803D(A4140000)01            cmp byte [current_level], 1
   798 000006EC 7428                        je .level1
   799 000006EE 803D(A4140000)02            cmp byte [current_level], 2
   800 000006F5 7425                        je .level2
   801 000006F7 803D(A4140000)03            cmp byte [current_level], 3
   802 000006FE 7422                        je .level3
   803 00000700 803D(A4140000)04            cmp byte [current_level], 4
   804 00000707 741F                        je .level4
   805 00000709 803D(A4140000)05            cmp byte [current_level], 5
   806 00000710 741C                        je .level5
   807                                      ; Si llegamos aquí, hay un error en el nivel
   808 00000712 4831C0                      xor rax, rax
   809 00000715 C3                          ret
   810                                  
   811                                      .level1:
   812 00000716 B801000000                      mov rax, level1_blocks_count
   813 0000071B C3                              ret
   814                                      .level2:
   815 0000071C B801000000                      mov rax, level2_blocks_count
   816 00000721 C3                              ret
   817                                      .level3:
   818 00000722 B801000000                      mov rax, level3_blocks_count
   819 00000727 C3                              ret
   820                                      .level4:
   821 00000728 B801000000                      mov rax, level4_blocks_count
   822 0000072D C3                              ret
   823                                      .level5:
   824 0000072E B801000000                      mov rax, level5_blocks_count
   825 00000733 C3                              ret
   826                                  
   827                                  
   828                                  print_blocks:
   829 00000734 55                          push rbp
   830 00000735 4889E5                      mov rbp, rsp
   831                                      
   832                                      ; Obtener puntero a los bloques del nivel actual
   833 00000738 E84FFFFFFF                  call get_current_level_blocks
   834 0000073D 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   835                                      
   836                                      ; Obtener cantidad de bloques del nivel actual
   837 00000740 E8A0FFFFFF                  call get_current_level_count
   838 00000745 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   839                                      
   840 00000748 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   841                                      
   842                                      .print_loop:
   843 0000074B 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   844 0000074E 7D69                            jge .end
   845                                          
   846                                          ; Verificar si el bloque está activo
   847 00000750 490FB68424-                     movzx rax, byte [block_states + r12]
   847 00000755 [BA140000]         
   848 00000759 4885C0                          test rax, rax
   849 0000075C 7456                            jz .next_block
   850                                          
   851                                          ; Obtener posición y tipo del bloque usando r13
   852 0000075E 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   853 00000763 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   854 00000768 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   855                                          
   856                                          ; El resto de la lógica de impresión permanece igual
   857 0000076D 4D0FB6C0                        movzx r8, r8b
   858 00000771 4D0FB6C9                        movzx r9, r9b
   859 00000775 4981C0[000A0000]                add r8, board
   860 0000077C B850000000                      mov rax, column_cells + 2
   861 00000781 49F7E1                          mul r9
   862 00000784 4901C0                          add r8, rax
   863                                          
   864 00000787 B906000000                      mov rcx, block_length
   865 0000078C 48BE-                           mov rsi, block_type_1
   865 0000078E [8014000000000000] 
   866 00000796 490FB6C2                        movzx rax, r10b
   867 0000079A 48FFC8                          dec rax
   868 0000079D 486BC006                        imul rax, block_length
   869 000007A1 4801C6                          add rsi, rax
   870                                          
   871                                      .print_block_chars:
   872 000007A4 8A06                            mov al, [rsi]
   873 000007A6 418800                          mov [r8], al
   874 000007A9 48FFC6                          inc rsi
   875 000007AC 49FFC0                          inc r8
   876 000007AF 48FFC9                          dec rcx
   877 000007B2 75F0                            jnz .print_block_chars
   878                                          
   879                                      .next_block:
   880 000007B4 49FFC4                          inc r12
   881 000007B7 EB92                            jmp .print_loop
   882                                          
   883                                      .end:
   884 000007B9 5D                              pop rbp
   885 000007BA C3                              ret
   886                                  
   887                                  ; Función para convertir número a string
   888                                  ; Input: RAX = número a convertir
   889                                  ; RDI = buffer donde escribir el string
   890                                  number_to_string:
   891 000007BB 53                          push rbx
   892 000007BC 52                          push rdx
   893 000007BD 56                          push rsi
   894 000007BE BB0A000000                  mov rbx, 10          ; Divisor
   895 000007C3 B900000000                  mov rcx, 0          ; Contador de dígitos
   896                                      
   897                                      ; Si el número es 0, manejarlo especialmente
   898 000007C8 4885C0                      test rax, rax
   899 000007CB 7509                        jnz .convert_loop
   900 000007CD C60730                      mov byte [rdi], '0'
   901 000007D0 C6470100                    mov byte [rdi + 1], 0
   902 000007D4 EB20                        jmp .end
   903                                      
   904                                      .convert_loop:
   905 000007D6 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   906 000007D9 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   907 000007DC 80C230                          add dl, '0'     ; Convertir a ASCII
   908 000007DF 52                              push rdx        ; Guardar el dígito
   909 000007E0 48FFC1                          inc rcx         ; Incrementar contador
   910 000007E3 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
   911 000007E6 75EE                            jnz .convert_loop
   912                                          
   913                                      .write_loop:
   914 000007E8 5A                              pop rdx         ; Obtener dígito
   915 000007E9 8817                            mov [rdi], dl   ; Escribir al buffer
   916 000007EB 48FFC7                          inc rdi         ; Siguiente posición
   917 000007EE 48FFC9                          dec rcx         ; Decrementar contador
   918 000007F1 75F5                            jnz .write_loop
   919                                          
   920 000007F3 C60700                      mov byte [rdi], 0   ; Null terminator
   921                                      
   922                                      .end:
   923 000007F6 5E                          pop rsi
   924 000007F7 5A                          pop rdx
   925 000007F8 5B                          pop rbx
   926 000007F9 C3                          ret
   927                                  
   928                                  ; Función para imprimir los labels
   929                                  print_labels:
   930 000007FA 55                          push rbp
   931 000007FB 4889E5                      mov rbp, rsp
   932                                      
   933                                      ; Guardar el score en string
   934 000007FE 488B05(3B150000)            mov rax, [current_score]
   935 00000805 48BF-                       mov rdi, number_buffer
   935 00000807 [4415000000000000] 
   936 0000080F E8A7FFFFFF                  call number_to_string
   937                                      
   938                                      ; Imprimir score label
   939                                      print score_label, score_label_len
    82 00000814 B801000000          <1>  mov eax, sys_write
    83 00000819 BF01000000          <1>  mov edi, 1
    84 0000081E 48BE-               <1>  mov rsi, %1
    84 00000820 [1E15000000000000]  <1>
    85 00000828 BA09000000          <1>  mov edx, %2
    86 0000082D 0F05                <1>  syscall
   940                                      print number_buffer, 20
    82 0000082F B801000000          <1>  mov eax, sys_write
    83 00000834 BF01000000          <1>  mov edi, 1
    84 00000839 48BE-               <1>  mov rsi, %1
    84 0000083B [4415000000000000]  <1>
    85 00000843 BA14000000          <1>  mov edx, %2
    86 00000848 0F05                <1>  syscall
   941                                      
   942                                      ; Nueva línea
   943 0000084A C605(44150000)0A            mov byte [number_buffer], 0xA
   944 00000851 C605(45150000)0D            mov byte [number_buffer + 1], 0xD
   945                                      print number_buffer, 2
    82 00000858 B801000000          <1>  mov eax, sys_write
    83 0000085D BF01000000          <1>  mov edi, 1
    84 00000862 48BE-               <1>  mov rsi, %1
    84 00000864 [4415000000000000]  <1>
    85 0000086C BA02000000          <1>  mov edx, %2
    86 00000871 0F05                <1>  syscall
   946                                      
   947                                      ; Convertir bloques destruidos a string
   948 00000873 480FB605(43150000)          movzx rax, byte [destroyed_blocks]
   949 0000087B 48BF-                       mov rdi, number_buffer
   949 0000087D [4415000000000000] 
   950 00000885 E831FFFFFF                  call number_to_string
   951                                      
   952                                      ; Imprimir label de bloques destruidos
   953                                      print blocks_label, blocks_label_len
    82 0000088A B801000000          <1>  mov eax, sys_write
    83 0000088F BF01000000          <1>  mov edi, 1
    84 00000894 48BE-               <1>  mov rsi, %1
    84 00000896 [2715000000000000]  <1>
    85 0000089E BA14000000          <1>  mov edx, %2
    86 000008A3 0F05                <1>  syscall
   954                                      print number_buffer, 20
    82 000008A5 B801000000          <1>  mov eax, sys_write
    83 000008AA BF01000000          <1>  mov edi, 1
    84 000008AF 48BE-               <1>  mov rsi, %1
    84 000008B1 [4415000000000000]  <1>
    85 000008B9 BA14000000          <1>  mov edx, %2
    86 000008BE 0F05                <1>  syscall
   955                                      
   956                                      ; Nueva línea
   957 000008C0 C605(44150000)0A            mov byte [number_buffer], 0xA
   958 000008C7 C605(45150000)0D            mov byte [number_buffer + 1], 0xD
   959                                      print number_buffer, 2
    82 000008CE B801000000          <1>  mov eax, sys_write
    83 000008D3 BF01000000          <1>  mov edi, 1
    84 000008D8 48BE-               <1>  mov rsi, %1
    84 000008DA [4415000000000000]  <1>
    85 000008E2 BA02000000          <1>  mov edx, %2
    86 000008E7 0F05                <1>  syscall
   960                                      
   961 000008E9 5D                          pop rbp
   962 000008EA C3                          ret
   963                                  
   964                                  ; Función modificada para detectar colisión
   965                                  ; Función mejorada para detectar colisión y manejar la física
   966                                  ; Función corregida para manejar colisiones con bloques completos
   967                                  ;---------------------------------------------------------
   968                                  ; check_block_collision:
   969                                  ;   Detecta si en la posición r10 (que apunta a board[])
   970                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
   971                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
   972                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
   973                                  ;   retorna 0.
   974                                  ;---------------------------------------------------------
   975                                  ;--------------------------------------
   976                                  ; check_block_collision
   977                                  ;--------------------------------------
   978                                  ; Actualizar check_block_collision para usar el nivel actual
   979                                  check_block_collision:
   980 000008EB 55                          push rbp
   981 000008EC 4889E5                      mov rbp, rsp
   982                                  
   983 000008EF 418A02                      mov al, [r10]
   984                                  
   985                                      ; Verificación de caracteres igual que antes...
   986 000008F2 3C55                        cmp al, 'U'  
   987 000008F4 7419                        je .possible
   988 000008F6 3C4F                        cmp al, 'O'  
   989 000008F8 7415                        je .possible
   990 000008FA 3C44                        cmp al, 'D'  
   991 000008FC 7411                        je .possible
   992 000008FE 3C4C                        cmp al, 'L'  
   993 00000900 740D                        je .possible
   994 00000902 3C56                        cmp al, 'V'  
   995 00000904 7409                        je .possible
   996 00000906 3C38                        cmp al, '8'  
   997 00000908 7405                        je .possible
   998                                  
   999 0000090A 4831C0                      xor rax, rax
  1000 0000090D 5D                          pop rbp
  1001 0000090E C3                          ret
  1002                                  
  1003                                      .possible:
  1004 0000090F 53                              push rbx
  1005 00000910 57                              push rdi
  1006 00000911 56                              push rsi
  1007 00000912 4154                            push r12
  1008                                  
  1009                                          ; Obtener puntero a los bloques del nivel actual
  1010 00000914 E873FDFFFF                      call get_current_level_blocks
  1011 00000919 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
  1012                                          
  1013                                          ; Obtener cantidad de bloques del nivel actual
  1014 0000091C E8C4FDFFFF                      call get_current_level_count
  1015 00000921 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
  1016                                  
  1017 00000924 4D31E4                          xor r12, r12
  1018                                      .find_block_loop:
  1019 00000927 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1020 0000092A 0F8DB0000000                    jge .no_block_found
  1021                                  
  1022                                          ; El resto de la lógica de verificación de colisiones...
  1023 00000930 418A9C24[BA140000]              mov bl, [block_states + r12]
  1024 00000938 84DB                            test bl, bl
  1025 0000093A 0F8498000000                    jz .next_block
  1026                                  
  1027                                          ; Usar r13 para acceder a los bloques del nivel actual
  1028 00000940 4C89E8                          mov rax, r13
  1029 00000943 4D6BE404                        imul r12, 4
  1030 00000947 4C01E0                          add rax, r12
  1031 0000094A 8A10                            mov dl, [rax]       ; x
  1032 0000094C 8A4801                          mov cl, [rax+1]     ; y
  1033                                  
  1034                                          ; Revertir r12
  1035 0000094F 4D89E4                          mov r12, r12
  1036 00000952 49C1EC02                        shr r12, 2
  1037                                  
  1038                                          ; La misma lógica de detección de colisiones...
  1039 00000956 488D3D(000A0000)                lea rdi, [board]
  1040 0000095D 4831C0                          xor rax, rax
  1041 00000960 B850000000                      mov rax, column_cells + 2
  1042 00000965 480FB6C9                        movzx rcx, cl
  1043 00000969 480FAFC1                        imul rax, rcx
  1044 0000096D 4801C7                          add rdi, rax
  1045 00000970 480FB6C2                        movzx rax, dl
  1046 00000974 4801C7                          add rdi, rax
  1047                                  
  1048 00000977 4939FA                          cmp r10, rdi
  1049 0000097A 725C                            jb .next_block
  1050 0000097C 488D5F06                        lea rbx, [rdi + 6]
  1051 00000980 4939DA                          cmp r10, rbx
  1052 00000983 7353                            jae .next_block
  1053                                  
  1054                                          ; Manejo de colisión igual que antes...
  1055 00000985 41FE8C24[BA140000]              dec byte [block_states + r12]
  1056 0000098D 418A9C24[BA140000]              mov bl, [block_states + r12]
  1057 00000995 84DB                            test bl, bl
  1058 00000997 7533                            jnz .still_alive
  1059                                  
  1060 00000999 B906000000                      mov rcx, block_length
  1061                                      .erase_block_chars:
  1062 0000099E C60720                          mov byte [rdi], char_space
  1063 000009A1 48FFC7                          inc rdi
  1064 000009A4 E2F8                            loop .erase_block_chars
  1065                                  
  1066 000009A6 FE0D(A5140000)                  dec byte [blocks_remaining]
  1067 000009AC FE05(43150000)                  inc byte [destroyed_blocks]     ; Incrementar contador de bloques destruidos
  1068                                      
  1069                                          ; Calcular puntos basado en la durabilidad original del bloque
  1070 000009B2 4C89E0                          mov rax, r12                    ; Índice del bloque
  1071 000009B5 486BC004                        imul rax, 4                     ; Multiplicar por 4 (tamaño de cada entrada)
  1072 000009B9 4C01E8                          add rax, r13                    ; Agregar base de los bloques
  1073 000009BC 480FB64002                      movzx rax, byte [rax + 2]       ; Obtener tipo de bloque (durabilidad original)
  1074 000009C1 486BC00A                        imul rax, 10                    ; Multiplicar por 10
  1075 000009C5 480105(3B150000)                add [current_score], rax        ; Agregar al score total
  1076                                  
  1077                                      .still_alive:
  1078 000009CC B801000000                      mov rax, 1
  1079 000009D1 415C                            pop r12
  1080 000009D3 5E                              pop rsi
  1081 000009D4 5F                              pop rdi
  1082 000009D5 5B                              pop rbx
  1083 000009D6 5D                              pop rbp
  1084 000009D7 C3                              ret
  1085                                  
  1086                                      .next_block:
  1087 000009D8 49FFC4                          inc r12
  1088 000009DB E947FFFFFF                      jmp .find_block_loop
  1089                                  
  1090                                      .no_block_found:
  1091 000009E0 4831C0                          xor rax, rax
  1092 000009E3 415C                            pop r12
  1093 000009E5 5E                              pop rsi
  1094 000009E6 5F                              pop rdi
  1095 000009E7 5B                              pop rbx
  1096 000009E8 5D                              pop rbp
  1097 000009E9 C3                              ret
  1098                                  
  1099                                  init_enemies:
  1100 000009EA 55                          push rbp
  1101 000009EB 4889E5                      mov rbp, rsp
  1102                                      ; Reiniciar contadores de movimiento
  1103 000009EE C605(77150000)00            mov byte [enemy_move_total], 0
  1104 000009F5 C605(78150000)00            mov byte [enemy_target], 0      ; Inicialmente persigue la bola
  1105                                      ; Limpiar estado previo de enemigos
  1106 000009FC B90F000000                  mov rcx, 15                     ; 5 enemigos * 3 bytes
  1107 00000A01 488D3D(5D150000)            lea rdi, [enemies]
  1108 00000A08 30C0                        xor al, al
  1109 00000A0A F3AA                        rep stosb
  1110                                      
  1111                                      ; Configurar enemigo según el nivel actual
  1112 00000A0C 480FB60D(A4140000)          movzx rcx, byte [current_level]
  1113 00000A14 48FFC9                      dec rcx                         ; Ajustar para índice base 0
  1114                                      
  1115                                      ; Activar un enemigo
  1116 00000A17 488D3D(5D150000)            lea rdi, [enemies]
  1117                                      
  1118                                      ; Posición X inicial (centro de la pantalla)
  1119 00000A1E C60704                      mov byte [rdi], 4
  1120                                      
  1121                                      ; Posición Y inicial (cerca de la parte superior)
  1122 00000A21 C6470101                    mov byte [rdi + 1], 1
  1123                                      
  1124                                      ; Marcar como activo
  1125 00000A25 C6470201                    mov byte [rdi + 2], 1
  1126                                      
  1127                                      ; Establecer cantidad de enemigos activos
  1128 00000A29 C605(6C150000)01            mov byte [enemies_count], 1
  1129                                      
  1130 00000A30 5D                          pop rbp
  1131 00000A31 C3                          ret
  1132                                  
  1133                                  ; Función para mover enemigos
  1134                                  move_enemies:
  1135 00000A32 55                          push rbp
  1136 00000A33 4889E5                      mov rbp, rsp
  1137                                      
  1138                                      ; Control de velocidad de movimiento
  1139 00000A36 FE05(75150000)              inc byte [enemy_move_counter]
  1140 00000A3C 8A05(75150000)              mov al, [enemy_move_counter]
  1141 00000A42 3A05(76150000)              cmp al, [enemy_move_delay]
  1142 00000A48 0F8CC1010000                jl .end
  1143                                      
  1144                                      ; Resetear contador
  1145 00000A4E C605(75150000)00            mov byte [enemy_move_counter], 0
  1146                                      
  1147                                      ; Incrementar contador total de movimientos y verificar umbral
  1148 00000A55 FE05(77150000)              inc byte [enemy_move_total]
  1149 00000A5B 8A05(77150000)              mov al, [enemy_move_total]
  1150 00000A61 3A05(79150000)              cmp al, [MOVEMENT_THRESHOLD]
  1151 00000A67 7C07                        jl .continue_normal
  1152 00000A69 C605(78150000)01            mov byte [enemy_target], 1    ; Cambiar a perseguir paleta
  1153                                      
  1154                                      .continue_normal:
  1155                                          ; Iterar sobre enemigos
  1156 00000A70 4D31E4                          xor r12, r12                    ; Índice del enemigo
  1157                                          
  1158                                      .enemy_loop:
  1159 00000A73 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1160 00000A77 0F8D92010000                    jge .end
  1161                                          
  1162                                          ; Calcular offset del enemigo actual
  1163 00000A7D 4C89E0                          mov rax, r12
  1164 00000A80 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1165 00000A84 488DB0[5D150000]                lea rsi, [enemies + rax]
  1166                                          
  1167                                          ; Verificar si el enemigo está activo
  1168 00000A8B 807E0201                        cmp byte [rsi + 2], 1
  1169 00000A8F 0F8572010000                    jne .next_enemy
  1170                                          
  1171                                          ; Obtener posición actual del enemigo
  1172 00000A95 4C0FB606                        movzx r8, byte [rsi]            ; X
  1173 00000A99 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1174                                          
  1175                                          ; Borrar posición actual del enemigo en el tablero
  1176 00000A9E 4150                            push r8                         ; Guardar coordenadas actuales
  1177 00000AA0 4151                            push r9
  1178                                          
  1179                                          ; Calcular offset en el tablero para borrar
  1180 00000AA2 B84E000000                      mov rax, column_cells
  1181 00000AA7 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1182 00000AAB 49F7E1                          mul r9
  1183 00000AAE 4C01C0                          add rax, r8
  1184 00000AB1 488DB8[000A0000]                lea rdi, [board + rax]
  1185 00000AB8 C60720                          mov byte [rdi], ' '             ; Borrar posición actual
  1186                                          
  1187 00000ABB 4159                            pop r9                          ; Restaurar coordenadas
  1188 00000ABD 4158                            pop r8
  1189                                          
  1190                                          ; Decidir objetivo basado en enemy_target
  1191 00000ABF 8A05(78150000)                  mov al, [enemy_target]
  1192 00000AC5 84C0                            test al, al
  1193 00000AC7 7531                            jnz .chase_paddle              ; Si es 1, perseguir paleta
  1194                                          
  1195                                          ; Perseguir bola (comportamiento original)
  1196                                      .chase_ball:
  1197 00000AC9 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1198 00000AD0 4D39D0                          cmp r8, r10
  1199 00000AD3 0F8F96000000                    jg .move_left
  1200 00000AD9 0F8C95000000                    jl .move_right
  1201                                          
  1202 00000ADF 4C8B15(57140000)                mov r10, [ball_y_pos]
  1203 00000AE6 4D39D1                          cmp r9, r10
  1204 00000AE9 0F8F8A000000                    jg .move_up
  1205 00000AEF 0F8C89000000                    jl .move_down
  1206 00000AF5 E9A5000000                      jmp .check_collision
  1207                                          
  1208                                      .chase_paddle:
  1209                                          ; Obtener la posición X actual de la paleta
  1210 00000AFA 4C8B15(3F140000)                mov r10, [pallet_position]
  1211 00000B01 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1212                                          
  1213                                          ; Calcular la posición X real de la paleta
  1214 00000B08 4C89D0                          mov rax, r10
  1215 00000B0B BB4E000000                      mov rbx, column_cells
  1216 00000B10 4883C302                        add rbx, 2                  ; Añadir newline chars
  1217 00000B14 4831D2                          xor rdx, rdx
  1218 00000B17 48F7F3                          div rbx                     ; rax = y, rdx = x
  1219                                          
  1220                                          ; rdx ahora contiene la posición X de la paleta
  1221                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1222 00000B1A 488B0D(47140000)                mov rcx, [pallet_size]
  1223 00000B21 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1224 00000B24 4801CA                          add rdx, rcx
  1225                                          
  1226                                          ; Comparar con posición X del enemigo y mover gradualmente
  1227 00000B27 4939D0                          cmp r8, rdx
  1228 00000B2A 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1229 00000B2C 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1230 00000B2E 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1231                                  
  1232                                      .check_y_paddle:
  1233                                          ; La Y de la paleta siempre es row_cells - 2
  1234 00000B30 41BA20000000                    mov r10, row_cells
  1235 00000B36 4983EA02                        sub r10, 2
  1236                                          
  1237                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1238 00000B3A 4D39D1                          cmp r9, r10
  1239 00000B3D 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1240 00000B3F 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1241 00000B41 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1242                                          
  1243                                      .no_movement:
  1244 00000B43 EB5A                            jmp .check_collision
  1245                                  
  1246                                      ; También agregar una nueva sección para el movimiento suave
  1247                                      .smooth_transition:
  1248                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1249 00000B45 8A05(78150000)                  mov al, [enemy_target]
  1250 00000B4B 84C0                            test al, al
  1251 00000B4D 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1252                                          
  1253                                          ; Verificar distancia en X
  1254 00000B4F 4989D2                          mov r10, rdx              ; Posición X objetivo
  1255 00000B52 4D29C2                          sub r10, r8               ; Calcular diferencia
  1256 00000B55 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1257 00000B59 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1258 00000B5B 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1259 00000B5F 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1260 00000B61 EB3C                            jmp .check_collision
  1261                                          
  1262                                      .limit_right_movement:
  1263 00000B63 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1264 00000B67 EB36                            jmp .check_collision
  1265                                          
  1266                                      .limit_left_movement:
  1267 00000B69 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1268 00000B6D EB30                            jmp .check_collision
  1269                                      .move_left:
  1270 00000B6F 49FFC8                          dec r8
  1271 00000B72 EB0F                            jmp .check_vertical
  1272                                          
  1273                                      .move_right:
  1274 00000B74 49FFC0                          inc r8
  1275 00000B77 EB0A                            jmp .check_vertical
  1276                                          
  1277                                      .move_up:
  1278 00000B79 49FFC9                          dec r9
  1279 00000B7C EB21                            jmp .check_collision
  1280                                          
  1281                                      .move_down:
  1282 00000B7E 49FFC1                          inc r9
  1283 00000B81 EB1C                            jmp .check_collision
  1284                                          
  1285                                      .check_vertical:
  1286 00000B83 8A05(78150000)                  mov al, [enemy_target]
  1287 00000B89 84C0                            test al, al
  1288 00000B8B 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1289 00000B91 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1290 00000B98 4D39D1                          cmp r9, r10
  1291 00000B9B 7FDC                            jg .move_up
  1292 00000B9D 7CDF                            jl .move_down
  1293                                          
  1294                                      .check_collision:
  1295                                          ; Verificar colisión con bordes
  1296 00000B9F 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1297 00000BA3 7E62                            jle .next_enemy
  1298 00000BA5 4983F84E                        cmp r8, column_cells
  1299 00000BA9 7D5C                            jge .next_enemy
  1300 00000BAB 4983F901                        cmp r9, 1                       ; Borde superior
  1301 00000BAF 7E56                            jle .next_enemy
  1302 00000BB1 4983F920                        cmp r9, row_cells
  1303 00000BB5 7D50                            jge .next_enemy
  1304                                          
  1305                                          ; Verificar colisión con bloques antes de moverse
  1306 00000BB7 4150                            push r8
  1307 00000BB9 4151                            push r9
  1308 00000BBB 4152                            push r10
  1309                                          
  1310                                          ; Calcular posición en el tablero para verificar
  1311 00000BBD B84E000000                      mov rax, column_cells
  1312 00000BC2 4883C002                        add rax, 2
  1313 00000BC6 49F7E1                          mul r9
  1314 00000BC9 4C01C0                          add rax, r8
  1315 00000BCC 4C8D90[000A0000]                lea r10, [board + rax]
  1316                                          
  1317                                          ; Verificar si hay un bloque en la nueva posición
  1318 00000BD3 418A02                          mov al, [r10]
  1319 00000BD6 3C55                            cmp al, 'U'
  1320 00000BD8 7427                            je .invalid_move
  1321 00000BDA 3C4F                            cmp al, 'O'
  1322 00000BDC 7423                            je .invalid_move
  1323 00000BDE 3C44                            cmp al, 'D'
  1324 00000BE0 741F                            je .invalid_move
  1325 00000BE2 3C4C                            cmp al, 'L'
  1326 00000BE4 741B                            je .invalid_move
  1327 00000BE6 3C56                            cmp al, 'V'
  1328 00000BE8 7417                            je .invalid_move
  1329 00000BEA 3C38                            cmp al, '8'
  1330 00000BEC 7413                            je .invalid_move
  1331 00000BEE 3C58                            cmp al, 'X'
  1332 00000BF0 740F                            je .invalid_move
  1333                                          
  1334 00000BF2 415A                            pop r10
  1335 00000BF4 4159                            pop r9
  1336 00000BF6 4158                            pop r8
  1337                                          
  1338                                          ; Guardar nueva posición si es válida
  1339 00000BF8 448806                          mov [rsi], r8b
  1340 00000BFB 44884E01                        mov [rsi + 1], r9b
  1341 00000BFF EB06                            jmp .next_enemy
  1342                                          
  1343                                      .invalid_move:
  1344 00000C01 415A                            pop r10
  1345 00000C03 4159                            pop r9
  1346 00000C05 4158                            pop r8
  1347                                          
  1348                                      .next_enemy:
  1349 00000C07 49FFC4                          inc r12
  1350 00000C0A E964FEFFFF                      jmp .enemy_loop
  1351                                          
  1352                                      .end:
  1353 00000C0F 5D                              pop rbp
  1354 00000C10 C3                              ret
  1355                                  
  1356                                  ; Función para dibujar enemigos
  1357                                  print_enemies:
  1358 00000C11 55                          push rbp
  1359 00000C12 4889E5                      mov rbp, rsp
  1360                                      
  1361 00000C15 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1362                                      
  1363                                      .print_loop:
  1364 00000C18 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1365 00000C1C 7D4B                            jge .end
  1366                                          
  1367                                          ; Calcular offset del enemigo actual
  1368 00000C1E 4C89E0                          mov rax, r12
  1369 00000C21 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1370 00000C25 488DB0[5D150000]                lea rsi, [enemies + rax]
  1371                                          
  1372                                          ; Verificar si el enemigo está activo
  1373 00000C2C 807E0201                        cmp byte [rsi + 2], 1
  1374 00000C30 7532                            jne .next_enemy
  1375                                          
  1376                                          ; Calcular posición en el tablero
  1377 00000C32 4C0FB606                        movzx r8, byte [rsi]            ; X
  1378 00000C36 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1379                                          
  1380                                          ; Calcular offset en el tablero
  1381 00000C3B B84E000000                      mov rax, column_cells
  1382 00000C40 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1383 00000C44 49F7E1                          mul r9
  1384 00000C47 4C01C0                          add rax, r8
  1385 00000C4A 488DB8[000A0000]                lea rdi, [board + rax]
  1386                                          
  1387                                          ; Obtener carácter del enemigo según el nivel
  1388 00000C51 480FB605(A4140000)              movzx rax, byte [current_level]
  1389 00000C59 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1390 00000C5C 8A80[58150000]                  mov al, [enemy_chars + rax]
  1391                                          
  1392                                          ; Dibujar enemigo
  1393 00000C62 8807                            mov [rdi], al
  1394                                          
  1395                                      .next_enemy:
  1396 00000C64 49FFC4                          inc r12
  1397 00000C67 EBAF                            jmp .print_loop
  1398                                          
  1399                                      .end:
  1400 00000C69 5D                              pop rbp
  1401 00000C6A C3                              ret
  1402                                  
  1403                                  ; Función para verificar colisión con enemigos
  1404                                  ; Función para verificar colisión con enemigos
  1405                                  check_enemy_collision:
  1406 00000C6B 55                          push rbp
  1407 00000C6C 4889E5                      mov rbp, rsp
  1408                                      
  1409 00000C6F 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1410 00000C72 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1411                                      
  1412                                      .check_loop:
  1413 00000C75 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1414 00000C79 0F8DE9000000                    jge .end
  1415                                          
  1416                                          ; Calcular offset del enemigo actual
  1417 00000C7F 4C89E1                          mov rcx, r12
  1418 00000C82 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1419 00000C86 488DB1[5D150000]                lea rsi, [enemies + rcx]
  1420                                          
  1421                                          ; Verificar si el enemigo está activo
  1422 00000C8D 807E0201                        cmp byte [rsi + 2], 1
  1423 00000C91 0F85C9000000                    jne .next_enemy
  1424                                          
  1425                                          ; Verificar colisión con la bola
  1426 00000C97 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1427 00000C9B 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1428                                          
  1429                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1430 00000CA0 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1431 00000CA7 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1432                                          
  1433                                          ; Comprobar colisión vertical (misma columna)
  1434 00000CAE 4D39C2                          cmp r10, r8
  1435 00000CB1 7525                            jne .check_horizontal
  1436 00000CB3 4D29CB                          sub r11, r9
  1437 00000CB6 4983FB01                        cmp r11, 1
  1438 00000CBA 7F1C                            jg .check_horizontal
  1439 00000CBC 4983FBFF                        cmp r11, -1
  1440 00000CC0 7C16                            jl .check_horizontal
  1441                                          
  1442                                          ; Colisión vertical detectada
  1443 00000CC2 E8A3000000                      call destroy_enemy
  1444 00000CC7 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1445 00000CCE B801000000                      mov rax, 1
  1446 00000CD3 E990000000                      jmp .end
  1447                                          
  1448                                      .check_horizontal:
  1449                                          ; Comprobar colisión horizontal (misma fila)
  1450 00000CD8 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1451 00000CDF 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1452 00000CE6 4D39CB                          cmp r11, r9
  1453 00000CE9 7522                            jne .check_paddle
  1454 00000CEB 4D29C2                          sub r10, r8
  1455 00000CEE 4983FA01                        cmp r10, 1
  1456 00000CF2 7F19                            jg .check_paddle
  1457 00000CF4 4983FAFF                        cmp r10, -1
  1458 00000CF8 7C13                            jl .check_paddle
  1459                                          
  1460                                          ; Colisión horizontal detectada
  1461 00000CFA E86B000000                      call destroy_enemy
  1462 00000CFF 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1463 00000D06 B801000000                      mov rax, 1
  1464 00000D0B EB5B                            jmp .end
  1465                                          
  1466                                      .check_paddle:
  1467                                          ; Verificar colisión con la paleta
  1468 00000D0D 4C8B15(3F140000)                mov r10, [pallet_position]
  1469 00000D14 4981EA[000A0000]                sub r10, board
  1470 00000D1B 4C89D0                          mov rax, r10
  1471 00000D1E 41BB4E000000                    mov r11, column_cells
  1472 00000D24 4983C302                        add r11, 2
  1473 00000D28 4831D2                          xor rdx, rdx
  1474 00000D2B 49F7F3                          div r11                     ; División para obtener la posición Y
  1475 00000D2E 4989D3                          mov r11, rdx               ; X de la paleta en r11
  1476                                          
  1477 00000D31 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  1478                                          
  1479                                          ; Verificar si el enemigo está en la misma fila que la paleta
  1480 00000D38 41BD20000000                    mov r13, row_cells
  1481 00000D3E 4983ED02                        sub r13, 2                 ; Y de la paleta
  1482 00000D42 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  1483 00000D45 7519                            jne .next_enemy
  1484                                          
  1485                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  1486 00000D47 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  1487 00000D4A 7C14                            jl .next_enemy
  1488                                          
  1489 00000D4C 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  1490 00000D4F 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  1491 00000D52 7F0C                            jg .next_enemy
  1492                                          
  1493                                          ; Si llegamos aquí, hay colisión con la paleta
  1494 00000D54 E811000000                      call destroy_enemy        ; Destruir el enemigo
  1495 00000D59 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  1496 00000D5E EB08                            jmp .end
  1497                                          
  1498                                      .next_enemy:
  1499 00000D60 49FFC4                          inc r12
  1500 00000D63 E90DFFFFFF                      jmp .check_loop
  1501                                          
  1502                                      .end:
  1503 00000D68 5D                              pop rbp
  1504 00000D69 C3                              ret
  1505                                  
  1506                                  ; Función para destruir un enemigo
  1507                                  destroy_enemy:
  1508                                      ; Desactivar enemigo
  1509 00000D6A C6460200                    mov byte [rsi + 2], 0
  1510                                      
  1511                                      ; Sumar puntos
  1512 00000D6E 488B05(6D150000)            mov rax, [enemy_points]
  1513 00000D75 480105(3B150000)            add [current_score], rax
  1514                                      
  1515 00000D7C C3                          ret
  1516                                  
  1517                                  _start:
  1518 00000D7D E8A9F3FFFF              	call canonical_off
  1519 00000D82 E8DA000000              	call start_screen
  1520 00000D87 E8CCF6FFFF                  call init_level
  1521 00000D8C E859FCFFFF                  call init_enemies
  1522 00000D91 EB00                    	jmp .main_loop
  1523                                  	
  1524                                  
  1525                                  	.main_loop:
  1526 00000D93 E862FAFFFF                      call print_labels
  1527 00000D98 E868F4FFFF              		call print_pallet
  1528 00000D9D E8F3F4FFFF                      call move_ball
  1529 00000DA2 E88DF9FFFF                      call print_blocks
  1530 00000DA7 E8EAF7FFFF                      call check_level_complete
  1531 00000DAC E881FCFFFF                      call move_enemies
  1532 00000DB1 E8B5FEFFFF                      call check_enemy_collision
  1533 00000DB6 E856FEFFFF                      call print_enemies
  1534 00000DBB E81DF4FFFF              		call print_ball
  1535                                  		print board, board_size				
    82 00000DC0 B801000000          <1>  mov eax, sys_write
    83 00000DC5 BF01000000          <1>  mov edi, 1
    84 00000DCA 48BE-               <1>  mov rsi, %1
    84 00000DCC [000A000000000000]  <1>
    85 00000DD4 BA000A0000          <1>  mov edx, %2
    86 00000DD9 0F05                <1>  syscall
  1536                                  		;setnonblocking	
  1537                                  	.read_more:	
  1538                                  		getchar	
    90 00000DDB B800000000          <1>  mov rax, sys_read
    91 00000DE0 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000DE5 48BE-               <1>  mov rsi, input_char
    92 00000DE7 [0000000000000000]  <1>
    93 00000DEF BA01000000          <1>  mov rdx, 1
    94 00000DF4 0F05                <1>  syscall
  1539                                  		
  1540 00000DF6 4883F801                		cmp rax, 1
  1541 00000DFA 7532                        	jne .done
  1542                                  		
  1543 00000DFC 8A05(00000000)          		mov al,[input_char]
  1544                                  
  1545 00000E02 3C61                    		cmp al, 'a'
  1546 00000E04 750E                    	    jne .not_left
  1547 00000E06 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1548 00000E0D E80EF4FFFF              		call move_pallet
  1549 00000E12 EB1A                    	    jmp .done
  1550                                  		
  1551                                  		.not_left:
  1552 00000E14 3C64                    		 	cmp al, 'd'
  1553 00000E16 750C                    	    	jne .not_right
  1554 00000E18 BF01000000              			mov rdi, right_direction
  1555 00000E1D E8FEF3FFFF              	    	call move_pallet
  1556 00000E22 EB0A                        		jmp .done		
  1557                                  
  1558                                  		.not_right:
  1559                                  
  1560 00000E24 3C71                        		cmp al, 'q'
  1561 00000E26 0F84A8000000                		je exit
  1562                                  
  1563 00000E2C EBAD                    			jmp .read_more
  1564                                  		
  1565                                  		.done:	
  1566                                  			;unsetnonblocking		
  1567                                  			sleeptime	
    98 00000E2E B823000000          <1>  mov eax, sys_nanosleep
    99 00000E33 48BF-               <1>  mov rdi, timespec
    99 00000E35 [0000000000000000]  <1>
   100 00000E3D 31F6                <1>  xor esi, esi
   101 00000E3F 0F05                <1>  syscall
  1568                                  			print clear, clear_length
    82 00000E41 B801000000          <1>  mov eax, sys_write
    83 00000E46 BF01000000          <1>  mov edi, 1
    84 00000E4B 48BE-               <1>  mov rsi, %1
    84 00000E4D [1000000000000000]  <1>
    85 00000E55 BA07000000          <1>  mov edx, %2
    86 00000E5A 0F05                <1>  syscall
  1569 00000E5C E932FFFFFF                  		jmp .main_loop
  1570                                  
  1571                                  
  1572                                  
  1573                                  start_screen:
  1574                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000E61 B801000000          <1>  mov eax, sys_write
    83 00000E66 BF01000000          <1>  mov edi, 1
    84 00000E6B 48BE-               <1>  mov rsi, %1
    84 00000E6D [1000000000000000]  <1>
    85 00000E75 BA07000000          <1>  mov edx, %2
    86 00000E7A 0F05                <1>  syscall
  1575                                      print msg1, msg1_length
    82 00000E7C B801000000          <1>  mov eax, sys_write
    83 00000E81 BF01000000          <1>  mov edi, 1
    84 00000E86 48BE-               <1>  mov rsi, %1
    84 00000E88 [1700000000000000]  <1>
    85 00000E90 BA14010000          <1>  mov edx, %2
    86 00000E95 0F05                <1>  syscall
  1576                                      
  1577                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1578                                          getchar                 ; Esperamos una tecla
    90 00000E97 B800000000          <1>  mov rax, sys_read
    91 00000E9C BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000EA1 48BE-               <1>  mov rsi, input_char
    92 00000EA3 [0000000000000000]  <1>
    93 00000EAB BA01000000          <1>  mov rdx, 1
    94 00000EB0 0F05                <1>  syscall
  1579 00000EB2 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1580 00000EB6 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1581                                          
  1582                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000EB8 B801000000          <1>  mov eax, sys_write
    83 00000EBD BF01000000          <1>  mov edi, 1
    84 00000EC2 48BE-               <1>  mov rsi, %1
    84 00000EC4 [1000000000000000]  <1>
    85 00000ECC BA07000000          <1>  mov edx, %2
    86 00000ED1 0F05                <1>  syscall
  1583 00000ED3 C3                          ret
  1584                                  
  1585                                  exit: 
  1586 00000ED4 E894F2FFFF              	call canonical_on
  1587 00000ED9 B83C000000              	mov    rax, 60
  1588 00000EDE BF00000000                  mov    rdi, 0
  1589 00000EE3 0F05                        syscall
  1590                                  
