     1                                  bits 64;codigo destinado a arcquitectura de 64 bits
     2                                  default rel;configura el uso de direcciones relativas, que son mas flecibles
     3                                  
     4                                  
     5                                  ;RAX: Registro acumulador. Se utiliza generalmente para operaciones aritméticas y como valor de retorno de funciones.
     6                                  ;RBX: Registro base. Generalmente preservado entre llamadas a funciones.
     7                                  ;RCX: Contador. Usado en operaciones de repetición y bucles.
     8                                  ;RDX: Registro de datos. Se usa en operaciones aritméticas complejas y como argumento adicional en llamadas a funciones.
     9                                  ;RDI y RSI: Usados para pasar parámetros en las llamadas a funciones. RDI es el primer argumento, RSI el segundo.
    10                                  ;RBP: Registro base del marco de pila. Usado para rastrear la base del stack frame en funciones.
    11                                  ;RSP: Puntero de pila. Rastrea el tope de la pila.
    12                                  ;R8-R15: Registros adicionales introducidos en x86-64 para proporcionar más flexibilidad.
    13                                  
    14                                  
    15                                  
    16                                  ; definiciones de llamadas al sistema operativo
    17                                  sys_read: equ 0	;equ es como define y estos numeros se basan en la tabla se syscalls de x86
    18                                  sys_write:	equ 1
    19                                  sys_nanosleep:	equ 35
    20                                  sys_time:	equ 201
    21                                  sys_fcntl:	equ 72
    22                                  
    23                                  ;configurcaion de archivo descriptor
    24                                  STDIN_FILENO: equ 0
    25                                  
    26                                  F_SETFL:	equ 0x0004
    27                                  O_NONBLOCK: equ 0x0004
    28                                  
    29                                  ;screen clean definition
    30                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    31                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    32                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    33                                  
    34                                  ;intervalos de tiempo utilizados
    35                                  timespec:
    36 00000000 0000000000000000            tv_sec  dq 0
    37 00000008 002D310100000000            tv_nsec dq 20000000
    38                                  
    39                                  
    40                                  ;This is for cleaning up the screen
    41 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H";27 es el codigo de escape, [2J limpia la pantalla y [H mueve el cursor al inicio
    42                                  clear_length:	equ $-clear
    43                                  	
    44                                  	
    45                                  
    46                                  ; Start Message
    47 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD;salto de linea y retorno de carro
    47 00000020 45434E4F4C4F474943-
    47 00000029 4F20444520434F5354-
    47 00000032 412052494341202020-
    47 0000003B 20202020200A0D     
    48 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    48 0000004B 525155495445435455-
    48 00000054 524120444520434F4D-
    48 0000005D 50555441444F524153-
    48 00000066 204920202020202020-
    48 0000006F 200A0D             
    49 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    49 0000007B 5354554449414E5445-
    49 00000084 3A2048454E5259204E-
    49 0000008D 554E455A2050455245-
    49 00000096 5A2020202020202020-
    49 0000009F 0A0D               
    50 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    50 000000AA 524F4645534F523A20-
    50 000000B3 45524E4553544F2052-
    50 000000BC 495645524120414C56-
    50 000000C5 415241444F20202020-
    50 000000CE 202020200A0D       
    51 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    51 000000DD 524B414E4F49442052-
    51 000000E6 4554524F2020202020-
    51 000000EF 2020200A0D         
    52 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    52 000000FD 524553494F4E452043-
    52 00000106 55414C515549455220-
    52 0000010F 5445434C4120504152-
    52 00000118 4120494E4943494152-
    52 00000121 20202020202020200A-
    52 0000012A 0D                 
    53                                  msg1_length: equ $-msg1;calcula la longitud del mensaje
    54                                  msg2_length: equ $-msg2
    55                                  msg3_length: equ $-msg3
    56                                  msg4_length: equ $-msg4
    57                                  msg5_length: equ $-msg5
    58                                  msg6_length: equ $-msg6
    59                                  
    60                                  ; Usefull macros
    61                                  
    62                                  
    63                                  
    64                                  %macro setnonblocking 0;este macro se encarga de configurar el archivo descriptor para que no bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    65                                  	mov rax, sys_fcntl
    66                                      mov rdi, STDIN_FILENO
    67                                      mov rsi, F_SETFL
    68                                      mov rdx, O_NONBLOCK
    69                                      syscall
    70                                  %endmacro
    71                                  
    72                                  %macro unsetnonblocking 0;este macro se encarga de configurar el archivo descriptor para que bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    73                                  	mov rax, sys_fcntl
    74                                      mov rdi, STDIN_FILENO
    75                                      mov rsi, F_SETFL
    76                                      mov rdx, 0
    77                                      syscall
    78                                  %endmacro
    79                                  
    80                                  %macro full_line 0;este macro se encarga de dibujar una linea completa en la pantalla, se usa para dibujar el tablero
    81                                      times column_cells db "X"
    82                                      db 0x0a, 0xD
    83                                  %endmacro
    84                                  
    85                                  %macro hollow_line 0;este macro se encarga de dibujar una linea hueca en la pantalla, se usa para dibujar el tablero
    86                                      db "X"
    87                                      times column_cells-2 db " "
    88                                      db "X", 0x0a, 0xD
    89                                  %endmacro
    90                                  
    91                                  
    92                                  %macro print 2;este se usa para imprimir en pantalla, se encarga de escribir en pantalla
    93                                  	mov eax, sys_write
    94                                  	mov edi, 1 	; stdout
    95                                  	mov rsi, %1
    96                                  	mov edx, %2
    97                                  	syscall
    98                                  %endmacro
    99                                  
   100                                  %macro getchar 0;este se usa para leer una tecla presionada, se encarga de leer una tecla presionada
   101                                  	mov     rax, sys_read
   102                                      mov     rdi, STDIN_FILENO
   103                                      mov     rsi, input_char
   104                                      mov     rdx, 1 ; number of bytes
   105                                      syscall         ;read text input from keyboard
   106                                  %endmacro
   107                                  
   108                                  %macro sleeptime 0;este se usa para dormir el programa por un tiempo determinado, se encarga de dormir el programa por un tiempo determinado
   109                                  	mov eax, sys_nanosleep
   110                                  	mov rdi, timespec
   111                                  	xor esi, esi		; ignore remaining time in case of call interruption
   112                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   113                                  %endmacro
   114                                  
   115                                  
   116                                  
   117                                  global _start;se declara la etiqueta global _start, que es el punto de entrada del programa
   118                                  
   119                                  section .bss;seccion bss, se usa para declarar variables no inicializadas
   120                                  
   121 00000000 ??                      input_char: resb 1;reserva un byte para almacenar la tecla presionada
   122                                  
   123                                  section .data;seccion data, se usa para declarar variables inicializadas
   124                                  
   125                                  	; Guardamos la plantilla del tablero (32 filas)
   126                                      board_template:;se declara la plantilla del tablero, se hace asi porque se necesita dibujar el tablero en pantalla
   127                                          full_line
    81 00000000 58<rep 50h>         <1>  times column_cells db "X"
    82 00000050 0A0D                <1>  db 0x0a, 0xD
   128                                          %rep 30
   129                                          hollow_line
   130                                          %endrep
   129                              <1>  hollow_line
    86 00000052 58                  <2>  db "X"
    87 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000A4 58                  <2>  db "X"
    87 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000F6 58                  <2>  db "X"
    87 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000148 58                  <2>  db "X"
    87 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000019A 58                  <2>  db "X"
    87 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000001EC 58                  <2>  db "X"
    87 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000023E 58                  <2>  db "X"
    87 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000290 58                  <2>  db "X"
    87 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000002E2 58                  <2>  db "X"
    87 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000334 58                  <2>  db "X"
    87 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000386 58                  <2>  db "X"
    87 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000003D8 58                  <2>  db "X"
    87 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000042A 58                  <2>  db "X"
    87 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000047C 58                  <2>  db "X"
    87 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000004CE 58                  <2>  db "X"
    87 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000520 58                  <2>  db "X"
    87 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000572 58                  <2>  db "X"
    87 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000005C4 58                  <2>  db "X"
    87 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000616 58                  <2>  db "X"
    87 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000668 58                  <2>  db "X"
    87 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000006BA 58                  <2>  db "X"
    87 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000070C 58                  <2>  db "X"
    87 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000075E 58                  <2>  db "X"
    87 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000007B0 58                  <2>  db "X"
    87 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000802 58                  <2>  db "X"
    87 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000854 58                  <2>  db "X"
    87 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008A6 58                  <2>  db "X"
    87 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008F8 58                  <2>  db "X"
    87 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000094A 58                  <2>  db "X"
    87 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000099C 58                  <2>  db "X"
    87 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   131                                          full_line
    81 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    82 00000A3E 0A0D                <1>  db 0x0a, 0xD
   132                                      board_template_size: equ $ - board_template;esto calcula el tamaño de la plantilla del tablero
   133                                  
   134                                      ; Espacio real que se usará en la ejecución
   135 00000A40 00<rep A40h>                board: times board_template_size db 0;times sirve para repetir un valor, en este caso se repite el tamaño de la plantilla del tablero
   136                                      board_size: equ board_template_size
   137                                  
   138                                  	; Added for the terminal issue
   139 00001480 00<rep 24h>             	termios:        times 36 db 0;termios es una estructura que se usa para configurar el terminal, se inicializa en 0
   140                                  	stdin:          equ 0;stdin es el archivo descriptor del terminal, se inicializa en 0
   141                                  	ICANON:         equ 1<<1;ICANON es una bandera que se usa para configurar el terminal, se inicializa en 1<<1
   142                                  	ECHO:           equ 1<<3;ECHO es una bandera que se usa para configurar el terminal, se inicializa en 1<<3
   143                                  	VTIME: 			equ 5;VTIME es una bandera que se usa para configurar el terminal, se inicializa en 5
   144                                  	VMIN:			equ 6;VMIN es una bandera que se usa para configurar el terminal, se inicializa en 6
   145                                  	CC_C:			equ 18;CC_C es una bandera que se usa para configurar el terminal, se inicializa en 18
   146                                  
   147                                  section .text
   148                                  canonical_off:;esta funcion se encarga de apagar el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser borrado porque no se necesita
   149 0000012B E86F000000                      call read_stdin_termios
   150                                  
   151                                          ; aqui abajo que pasa es que se apaga el bit de canonical en los flags de modo local, eso significa que se apaga el modo canonico
   152 00000130 50                              push rax
   153 00000131 B802000000                      mov eax, ICANON
   154 00000136 F7D0                            not eax
   155 00000138 2105(8C140000)                  and [termios+12], eax
   156 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   157 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   158 0000014C 58                              pop rax
   159                                  
   160 0000014D E86C000000                      call write_stdin_termios
   161 00000152 C3                              ret
   162                                  
   163                                  echo_off:;esta funcion se encarga de apagar el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se apga porque no se necesita
   164 00000153 E847000000                      call read_stdin_termios
   165                                  
   166                                          ; abajo lo que pasa esque se apaga el bit de echo en los flags de modo local, eso significa que se apaga el eco
   167 00000158 50                              push rax
   168 00000159 B808000000                      mov eax, ECHO
   169 0000015E F7D0                            not eax
   170 00000160 2105(8C140000)                  and [termios+12], eax
   171 00000166 58                              pop rax
   172                                  
   173 00000167 E852000000                      call write_stdin_termios
   174 0000016C C3                              ret
   175                                  
   176                                  canonical_on:;esta funcion se encarga de encender el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser encendido porque se necesita
   177 0000016D E82D000000                      call read_stdin_termios
   178                                  
   179                                          ; esto lo que hace es que prende el bit de canonical en los flags de modo local, eso significa que se prende el modo canonico
   180 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   181 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   182 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   183 00000187 E832000000                      call write_stdin_termios
   184 0000018C C3                              ret
   185                                  
   186                                  echo_on:;esta funcion se encarga de encender el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se enciende porque se necesita
   187 0000018D E80D000000                      call read_stdin_termios
   188                                  
   189                                          ; set echo bit in local mode flags
   190 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   191                                  
   192 00000199 E820000000                      call write_stdin_termios
   193 0000019E C3                              ret
   194                                  
   195                                  read_stdin_termios:;esta funcion se encarga de leer la configuracion del terminal, lo hace mediante una llamada al sistema
   196 0000019F 50                              push rax
   197 000001A0 53                              push rbx
   198 000001A1 51                              push rcx
   199 000001A2 52                              push rdx
   200                                  
   201 000001A3 B836000000                      mov eax, 36h
   202 000001A8 BB00000000                      mov ebx, stdin
   203 000001AD B901540000                      mov ecx, 5401h
   204 000001B2 BA[80140000]                    mov edx, termios
   205 000001B7 CD80                            int 80h
   206                                  
   207 000001B9 5A                              pop rdx
   208 000001BA 59                              pop rcx
   209 000001BB 5B                              pop rbx
   210 000001BC 58                              pop rax
   211 000001BD C3                              ret
   212                                  
   213                                  write_stdin_termios:;esta funcion se encarga de escribir la configuracion del terminal, lo hace mediante una llamada al sistema
   214 000001BE 50                              push rax
   215 000001BF 53                              push rbx
   216 000001C0 51                              push rcx
   217 000001C1 52                              push rdx
   218                                  
   219 000001C2 B836000000                      mov eax, 36h
   220 000001C7 BB00000000                      mov ebx, stdin
   221 000001CC B902540000                      mov ecx, 5402h
   222 000001D1 BA[80140000]                    mov edx, termios
   223 000001D6 CD80                            int 80h
   224                                  
   225 000001D8 5A                              pop rdx
   226 000001D9 59                              pop rcx
   227 000001DA 5B                              pop rbx
   228 000001DB 58                              pop rax
   229 000001DC C3                              ret
   230                                  
   231                                  
   232                                  char_equal: equ 61;se inicializa el caracter "="
   233                                  char_space: equ 32;se inicializa el caracter " "
   234                                  char_O: equ 79;se inicializa el caracter "O"
   235                                  left_direction: equ -1;se inicializa la direccion izquierda
   236                                  right_direction: equ 1;se inicializa la direccion derecha
   237                                  
   238                                  
   239                                  section .data
   240                                  
   241                                  ; Mensajes para los niveles
   242 000014A4 4E4956454C20                level_msg: db "NIVEL "
   243                                      level_msg_len: equ $ - level_msg
   244 000014AA 31                          level_1_char: db "1"
   245 000014AB 32                          level_2_char: db "2"
   246 000014AC 33                          level_3_char: db "3"
   247 000014AD 34                          level_4_char: db "4"
   248 000014AE 35                          level_5_char: db "5"
   249                                      level_char_len: equ 1
   250                                  
   251                                      ; Timespec para la pausa del mensaje de nivel
   252                                      level_display_time:
   253 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   254 000014B7 0000000000000000                lvl_tv_nsec dq 0
   255                                          
   256 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   257 000014C7 0500000000000000            pallet_size dq 5
   258 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   259 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   260                                  
   261 000014DF 2800000000000000        	ball_x_pos: dq 40
   262 000014E7 1C00000000000000        	ball_y_pos: dq 28
   263 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   264 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   265 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   266 00001500 00                          ball_active db 0
   267                                  
   268 00001501 0000000000000000            ball2_x_pos:        dq 0
   269 00001509 0000000000000000            ball2_y_pos:        dq 0
   270 00001511 0000000000000000            ball2_direction_x:  dq 0
   271 00001519 0000000000000000            ball2_direction_y:  dq 0
   272 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   273 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   274                                  
   275                                      ; -- Pelota 3 --
   276 00001523 0000000000000000            ball3_x_pos:        dq 0
   277 0000152B 0000000000000000            ball3_y_pos:        dq 0
   278 00001533 0000000000000000            ball3_direction_x:  dq 0
   279 0000153B 0000000000000000            ball3_direction_y:  dq 0
   280 00001543 00                          ball3_moving:       db 0
   281 00001544 00                          ball3_active:       db 0
   282                                  
   283                                  
   284                                  ; Definir los límites de la pantalla o área de juego
   285                                      board_top_left_x equ 1
   286                                      board_top_left_y equ 1
   287                                      board_bottom_right_x equ column_cells - 1
   288                                      board_bottom_right_y equ row_cells
   289                                  
   290                                      ; Limites laterales
   291                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   292                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   293                                  
   294                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   295 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   296 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   297                                  
   298                                      ; Definición de tipos de bloques
   299 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   300 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   301 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   302 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   303 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   304 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   305                                      block_length: equ 6        ; Longitud de cada bloque
   306                                  
   307                                      ; Estructura para el nivel actual
   308 00001579 05                          current_level db 5
   309 0000157A 00                          blocks_remaining db 0
   310                                  
   311                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   312                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   313                                      level1_blocks:
   314                                          ; Tercera fila (tipo 3)
   315 0000157B 0105050220                      db 1, 5, 5, 2, ' '   
   316 00001580 0705050220                      db 7, 5, 5, 2, ' '    
   317 00001585 0D05050220                      db 13, 5, 5, 2, ' '   
   318 0000158A 1305050220                      db 19, 5, 5, 2, ' '   
   319 0000158F 1905050220                      db 25, 5, 5, 2, ' '   
   320 00001594 1F05050220                      db 31, 5, 5, 2, ' '   
   321 00001599 2505050220                      db 37, 5, 5, 2, ' '   
   322 0000159E 2B05050220                      db 43, 5, 5, 2, ' '   
   323 000015A3 3105050220                      db 49, 5, 5, 2, ' '   
   324 000015A8 3705050220                      db 55, 5, 5, 2, ' '   
   325 000015AD 3D05050220                      db 61, 5, 5, 2, ' '  
   326 000015B2 4305050220                      db 67, 5, 5, 2, ' '   
   327 000015B7 4905050220                      db 73, 5, 5, 2, ' '   
   328                                  
   329 000015BC 0106040145                      db 1, 6, 4, 1, 'E'   
   330 000015C1 0706020153                      db 7, 6, 2, 1, 'S'    
   331 000015C6 0D06040153                      db 13, 6, 4, 1, 'S'   
   332 000015CB 1306020153                      db 19, 6, 2, 1, 'S'   
   333 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   334 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   335 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   336 000015DF 2B06020143                      db 43, 6, 2, 1, 'C'   
   337 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   338 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   339 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   340 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   341 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   342                                  
   343 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   344 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   345 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   346 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   347 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   348 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   349 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   350 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   351 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   352 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   353 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   354 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   355 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   356                                  
   357 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   358 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   359 00001648 0D08040150                      db 13, 8, 4, 1, 'P'   
   360 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   361 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   362 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   363 0000165C 2508040145                      db 37, 8, 4, 1, 'E'   
   364 00001661 2B08020143                      db 43, 8, 2, 1, 'C'   
   365 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   366 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   367 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   368 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   369 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   370                                  
   371 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   372 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   373 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   374 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   375 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   376 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   377 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   378 000016A2 2B09030120                      db 43, 9, 3, 1, ' '     
   379 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   380 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   381 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   382 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   383 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   384                                  
   385 000016C0 010A040145                      db 1, 10, 4, 1, 'E'   
   386 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   387 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   388 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   389 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   390 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   391 000016DE 250A040143                      db 37, 10, 4, 1, 'C'   
   392 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   393 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   394 000016ED 370A02014C                      db 55, 10, 2, 1, 'L'   
   395 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   396 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   397 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   398                                  
   399                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   400                                  
   401                                      ; Nivel 2: Bloques de prueba
   402                                      level2_blocks:
   403 00001701 0103040120                      db 1, 3, 4, 1, ' '
   404                                  
   405 00001706 0104030120                      db 1, 4, 3, 1, ' '   
   406 0000170B 0704040120                      db 7, 4, 4, 1, ' '   
   407                                                  
   408 00001710 0105020120                      db 1, 5, 2, 1, ' '   
   409 00001715 0705030120                      db 7, 5, 3, 1, ' '
   410 0000171A 0D05040144                      db 13, 5, 4, 1, 'D'
   411                                  
   412 0000171F 0106010120                      db 1, 6, 1, 1, ' '   
   413 00001724 0706020120                      db 7, 6, 2, 1, ' '
   414 00001729 0D06030120                      db 13, 6, 3, 1, ' '
   415 0000172E 1306040120                      db 19, 6, 4, 1, ' '   
   416                                  
   417 00001733 0107040120                      db 1, 7, 4, 1, ' '   
   418 00001738 0707010120                      db 7, 7, 1, 1, ' '
   419 0000173D 0D07020120                      db 13, 7, 2, 1, ' '
   420 00001742 1307030120                      db 19, 7, 3, 1, ' '  
   421 00001747 1907040120                      db 25, 7, 4, 1, ' '   
   422                                  
   423 0000174C 0108030120                      db 1, 8, 3, 1, ' '   
   424 00001751 0708040120                      db 7, 8, 4, 1, ' '
   425 00001756 0D08010120                      db 13, 8, 1, 1, ' '
   426 0000175B 1308020120                      db 19, 8, 2, 1, ' '  
   427 00001760 1908030120                      db 25, 8, 3, 1, ' ' 
   428 00001765 1F08040120                      db 31, 8, 4, 1, ' '   
   429                                  
   430 0000176A 0109020120                      db 1, 9, 2, 1, ' '   
   431 0000176F 0709030120                      db 7, 9, 3, 1, ' '
   432 00001774 0D09040120                      db 13, 9, 4, 1, ' '
   433 00001779 1309010120                      db 19, 9, 1, 1, ' '  
   434 0000177E 1909020120                      db 25, 9, 2, 1, ' ' 
   435 00001783 1F09030143                      db 31, 9, 3, 1, 'C' 
   436 00001788 2509040120                      db 37, 9, 4, 1, ' '   
   437                                  
   438 0000178D 010A010120                      db 1, 10, 1, 1, ' '   
   439 00001792 070A020120                      db 7, 10, 2, 1, ' '
   440 00001797 0D0A030120                      db 13, 10, 3, 1, ' '
   441 0000179C 130A040120                      db 19, 10, 4, 1, ' '  
   442 000017A1 190A010120                      db 25, 10, 1, 1, ' ' 
   443 000017A6 1F0A020120                      db 31, 10, 2, 1, ' ' 
   444 000017AB 250A03014C                      db 37, 10, 3, 1, 'L'  
   445 000017B0 2B0A040120                      db 43, 10, 4, 1, ' '   
   446                                  
   447 000017B5 010B040120                      db 1, 11, 4, 1, ' '   
   448 000017BA 070B010120                      db 7, 11, 1, 1, ' '
   449 000017BF 0D0B020120                      db 13, 11, 2, 1, ' '
   450 000017C4 130B030144                      db 19, 11, 3, 1, 'D'  
   451 000017C9 190B040120                      db 25, 11, 4, 1, ' ' 
   452 000017CE 1F0B010120                      db 31, 11, 1, 1, ' ' 
   453 000017D3 250B020120                      db 37, 11, 2, 1, ' '  
   454 000017D8 2B0B030120                      db 43, 11, 3, 1, ' ' 
   455 000017DD 310B040120                      db 49, 11, 4, 1, ' '   
   456                                  
   457 000017E2 010C030120                      db 1, 12, 3, 1, ' '   
   458 000017E7 070C040120                      db 7, 12, 4, 1, ' '
   459 000017EC 0D0C010120                      db 13, 12, 1, 1, ' '
   460 000017F1 130C020120                      db 19, 12, 2, 1, ' '  
   461 000017F6 190C030120                      db 25, 12, 3, 1, ' ' 
   462 000017FB 1F0C040120                      db 31, 12, 4, 1, ' ' 
   463 00001800 250C010120                      db 37, 12, 1, 1, ' '  
   464 00001805 2B0C020120                      db 43, 12, 2, 1, ' ' 
   465 0000180A 310C030120                      db 49, 12, 3, 1, ' '
   466 0000180F 370C040120                      db 55, 12, 4, 1, ' '   
   467                                  
   468 00001814 010D020120                      db 1, 13, 2, 1, ' '   
   469 00001819 070D030120                      db 7, 13, 3, 1, ' '
   470 0000181E 0D0D040120                      db 13, 13, 4, 1, ' '
   471 00001823 130D010144                      db 19, 13, 1, 1, 'D'  
   472 00001828 190D020120                      db 25, 13, 2, 1, ' ' 
   473 0000182D 1F0D030120                      db 31, 13, 3, 1, ' ' 
   474 00001832 250D040120                      db 37, 13, 4, 1, ' '  
   475 00001837 2B0D010120                      db 43, 13, 1, 1, ' ' 
   476 0000183C 310D020120                      db 49, 13, 2, 1, ' '
   477 00001841 370D030120                      db 55, 13, 3, 1, ' ' 
   478 00001846 3D0D040120                      db 61, 13, 4, 1, ' '   
   479                                  
   480 0000184B 010E010120                      db 1, 14, 1, 1, ' '   
   481 00001850 070E020120                      db 7, 14, 2, 1, ' '
   482 00001855 0D0E030120                      db 13, 14, 3, 1, ' '
   483 0000185A 130E040120                      db 19, 14, 4, 1, ' '  
   484 0000185F 190E010120                      db 25, 14, 1, 1, ' ' 
   485 00001864 1F0E020120                      db 31, 14, 2, 1, ' ' 
   486 00001869 250E030120                      db 37, 14, 3, 1, ' '  
   487 0000186E 2B0E040120                      db 43, 14, 4, 1, ' ' 
   488 00001873 310E010120                      db 49, 14, 1, 1, ' '
   489 00001878 370E020120                      db 55, 14, 2, 1, ' ' 
   490 0000187D 3D0E030120                      db 61, 14, 3, 1, ' '  
   491 00001882 430E040120                      db 67, 14, 4, 1, ' '   
   492                                  
   493 00001887 010F050220                      db 1, 15, 5, 2, ' '   
   494 0000188C 070F050220                      db 7, 15, 5, 2, ' '
   495 00001891 0D0F050220                      db 13, 15, 5, 2, ' '
   496 00001896 130F050220                      db 19, 15, 5, 2, ' '  
   497 0000189B 190F050220                      db 25, 15, 5, 2, ' ' 
   498 000018A0 1F0F050220                      db 31, 15, 5, 2, ' ' 
   499 000018A5 250F050220                      db 37, 15, 5, 2, ' '  
   500 000018AA 2B0F050220                      db 43, 15, 5, 2, ' ' 
   501 000018AF 310F050220                      db 49, 15, 5, 2, ' '
   502 000018B4 370F050220                      db 55, 15, 5, 2, ' ' 
   503 000018B9 3D0F050220                      db 61, 15, 5, 2, ' '  
   504 000018BE 430F050220                      db 67, 15, 5, 2, ' '
   505 000018C3 490F040120                      db 73, 15, 4, 1, ' '   
   506                                         
   507                                  
   508                                      level2_blocks_count equ 91
   509                                  
   510                                      ; Nivel 3
   511                                      level3_blocks:
   512                                  
   513 000018C8 0102010120                      db 1, 2, 1, 1, ' '   
   514 000018CD 0702020120                      db 7, 2, 2, 1, ' '    
   515 000018D2 0D02010120                      db 13, 2, 1, 1, ' '   
   516 000018D7 1302020120                      db 19, 2, 2, 1, ' '   
   517 000018DC 1902010120                      db 25, 2, 1, 1, ' '   
   518 000018E1 1F02020120                      db 31, 2, 2, 1, ' '   
   519 000018E6 2502010120                      db 37, 2, 1, 1, ' '   
   520 000018EB 2B02020120                      db 43, 2, 2, 1, ' '   
   521 000018F0 3102010120                      db 49, 2, 1, 1, ' '   
   522 000018F5 3702020120                      db 55, 2, 2, 1, ' '   
   523 000018FA 3D02010120                      db 61, 2, 1, 1, ' '  
   524 000018FF 4302020120                      db 67, 2, 2, 1, ' '   
   525 00001904 4902010120                      db 73, 2, 1, 1, ' ' 
   526                                  
   527 00001909 0106040120                      db 1, 6, 4, 1, ' '   
   528 0000190E 0706040120                      db 7, 6, 4, 1, ' '    
   529 00001913 0D06040120                      db 13, 6, 4, 1, ' '   
   530 00001918 1306066320                      db 19, 6, 6, 99, ' '   
   531 0000191D 1906066320                      db 25, 6, 6, 99, ' '   
   532 00001922 1F06066320                      db 31, 6, 6, 99, ' '   
   533 00001927 2506066320                      db 37, 6, 6, 99, ' '   
   534 0000192C 2B06066320                      db 43, 6, 6, 99, ' '   
   535 00001931 3106066320                      db 49, 6, 6, 99, ' '   
   536 00001936 3706066320                      db 55, 6, 6, 99, ' '   
   537 0000193B 3D06066320                      db 61, 6, 6, 99, ' '  
   538 00001940 4306066320                      db 67, 6, 6, 99, ' '   
   539 00001945 4906066320                      db 73, 6, 6, 99, ' ' 
   540                                  
   541 0000194A 0108040120                      db 1, 8, 4, 1, ' '   
   542 0000194F 0708030120                      db 7, 8, 3, 1, ' '    
   543 00001954 0D08040120                      db 13, 8, 4, 1, ' '   
   544 00001959 1308030120                      db 19, 8, 3, 1, ' '   
   545 0000195E 1908040120                      db 25, 8, 4, 1, ' '   
   546 00001963 1F08030120                      db 31, 8, 3, 1, ' '   
   547 00001968 2508040120                      db 37, 8, 4, 1, ' '   
   548 0000196D 2B08030120                      db 43, 8, 3, 1, ' '   
   549 00001972 3108040120                      db 49, 8, 4, 1, ' '   
   550 00001977 3708030120                      db 55, 8, 3, 1, ' '   
   551 0000197C 3D08040120                      db 61, 8, 4, 1, ' '  
   552 00001981 4308030120                      db 67, 8, 3, 1, ' '   
   553 00001986 4908040120                      db 73, 8, 4, 1, ' ' 
   554                                  
   555 0000198B 010B066320                      db 1, 11, 6, 99, ' '   
   556 00001990 070B066320                      db 7, 11, 6, 99, ' '    
   557 00001995 0D0B066320                      db 13, 11, 6, 99, ' '   
   558 0000199A 130B066320                      db 19, 11, 6, 99, ' '   
   559 0000199F 190B066320                      db 25, 11, 6, 99, ' '   
   560 000019A4 1F0B066320                      db 31, 11, 6, 99, ' '   
   561 000019A9 250B066320                      db 37, 11, 6, 99, ' '   
   562 000019AE 2B0B066320                      db 43, 11, 6, 99, ' '   
   563 000019B3 310B066320                      db 49, 11, 6, 99, ' '   
   564 000019B8 370B066320                      db 55, 11, 6, 99, ' '   
   565 000019BD 3D0B030144                      db 61, 11, 3, 1, 'D'  
   566 000019C2 430B030120                      db 67, 11, 3, 1, ' '   
   567 000019C7 490B030120                      db 73, 11, 3, 1, ' ' 
   568                                  
   569 000019CC 010D010144                      db 1, 13, 1, 1, 'D'   
   570 000019D1 070D020150                      db 7, 13, 2, 1, 'P'    
   571 000019D6 0D0D010143                      db 13, 13, 1, 1, 'C'   
   572 000019DB 130D020120                      db 19, 13, 2, 1, ' '   
   573 000019E0 190D010120                      db 25, 13, 1, 1, ' '   
   574 000019E5 1F0D020120                      db 31, 13, 2, 1, ' '   
   575 000019EA 250D010120                      db 37, 13, 1, 1, ' '   
   576 000019EF 2B0D020120                      db 43, 13, 2, 1, ' '   
   577 000019F4 310D010120                      db 49, 13, 1, 1, ' '   
   578 000019F9 370D020120                      db 55, 13, 2, 1, ' '   
   579 000019FE 3D0D010120                      db 61, 13, 1, 1, ' '  
   580 00001A03 430D020120                      db 67, 13, 2, 1, ' '   
   581 00001A08 490D010120                      db 73, 13, 1, 1, ' ' 
   582                                  
   583 00001A0D 010F020120                      db 1, 15, 2, 1, ' '   
   584 00001A12 070F020120                      db 7, 15, 2, 1, ' '    
   585 00001A17 0D0F020120                      db 13, 15, 2, 1, ' '   
   586 00001A1C 130F066320                      db 19, 15, 6, 99, ' '   
   587 00001A21 190F066320                      db 25, 15, 6, 99, ' '   
   588 00001A26 1F0F066320                      db 31, 15, 6, 99, ' '   
   589 00001A2B 250F066320                      db 37, 15, 6, 99, ' '   
   590 00001A30 2B0F066320                      db 43, 15, 6, 99, ' '   
   591 00001A35 310F066320                      db 49, 15, 6, 99, ' '   
   592 00001A3A 370F066320                      db 55, 15, 6, 99, ' '   
   593 00001A3F 3D0F066320                      db 61, 15, 6, 99, ' '  
   594 00001A44 430F066320                      db 67, 15, 6, 99, ' '   
   595 00001A49 490F066320                      db 73, 15, 6, 99, ' ' 
   596                                  
   597 00001A4E 0112020120                      db 1, 18, 2, 1, ' '   
   598 00001A53 0712030120                      db 7, 18, 3, 1, ' '    
   599 00001A58 0D12020144                      db 13, 18, 2, 1, 'D'   
   600 00001A5D 1312030120                      db 19, 18, 3, 1, ' '   
   601 00001A62 1912020120                      db 25, 18, 2, 1, ' '   
   602 00001A67 1F12030120                      db 31, 18, 3, 1, ' '   
   603 00001A6C 2512020120                      db 37, 18, 2, 1, ' '   
   604 00001A71 2B12030120                      db 43, 18, 3, 1, ' '   
   605 00001A76 3112020120                      db 49, 18, 2, 1, ' '   
   606 00001A7B 3712030144                      db 55, 18, 3, 1, 'D'   
   607 00001A80 3D12020120                      db 61, 18, 2, 1, ' '  
   608 00001A85 4312030143                      db 67, 18, 3, 1, 'C'   
   609 00001A8A 4912020120                      db 73, 18, 2, 1, ' ' 
   610                                  
   611                                  
   612 00001A8F 0114066320                      db 1, 20, 6, 99, ' '   
   613 00001A94 0714066320                      db 7, 20, 6, 99, ' '    
   614 00001A99 0D14066320                      db 13, 20, 6, 99, ' '   
   615 00001A9E 1314066320                      db 19, 20, 6, 99, ' '   
   616 00001AA3 1914066320                      db 25, 20, 6, 99, ' '   
   617 00001AA8 1F14066320                      db 31, 20, 6, 99, ' '   
   618 00001AAD 2514066320                      db 37, 20, 6, 99, ' '   
   619 00001AB2 2B14066320                      db 43, 20, 6, 99, ' '   
   620 00001AB7 3114066320                      db 49, 20, 6, 99, ' '   
   621 00001ABC 3714066320                      db 55, 20, 6, 99, ' '   
   622 00001AC1 3D14010120                      db 61, 20, 1, 1, ' '  
   623 00001AC6 4314010153                      db 67, 20, 1, 1, 'S'   
   624 00001ACB 4914010143                      db 73, 20, 1, 1, 'C' 
   625                                  
   626                                      level3_blocks_count equ 104
   627                                  
   628                                      ; Nivel 4
   629                                      level4_blocks:
   630                                  
   631 00001AD0 0704010120                      db 7, 4, 1, 1, ' '    
   632 00001AD5 0D04020120                      db 13, 4, 2, 1, ' '   
   633 00001ADA 1304030120                      db 19, 4, 3, 1, ' '   
   634 00001ADF 1904050220                      db 25, 4, 5, 2, ' '   
   635 00001AE4 1F04020120                      db 31, 4, 2, 1, ' '
   636                                  
   637 00001AE9 2B04010120                      db 43, 4, 1, 1, ' '   
   638 00001AEE 3104020120                      db 49, 4, 2, 1, ' '   
   639 00001AF3 3704030144                      db 55, 4, 3, 1, 'D'   
   640 00001AF8 3D04040120                      db 61, 4, 4, 1, ' '  
   641 00001AFD 4304020120                      db 67, 4, 2, 1, ' ' 
   642                                  
   643 00001B02 0705020120                      db 7, 5, 2, 1, ' '    
   644 00001B07 0D05030120                      db 13, 5, 3, 1, ' '   
   645 00001B0C 1305050220                      db 19, 5, 5, 2, ' '   
   646 00001B11 1905020120                      db 25, 5, 2, 1, ' '   
   647 00001B16 1F05010120                      db 31, 5, 1, 1, ' '
   648                                  
   649 00001B1B 2B05020120                      db 43, 5, 2, 1, ' '   
   650 00001B20 3105030120                      db 49, 5, 3, 1, ' '   
   651 00001B25 3705040120                      db 55, 5, 4, 1, ' '   
   652 00001B2A 3D05020120                      db 61, 5, 2, 1, ' '  
   653 00001B2F 4305050220                      db 67, 5, 5, 2, ' '  
   654                                  
   655 00001B34 0706030120                      db 7, 6, 3, 1, ' '    
   656 00001B39 0D06050220                      db 13, 6, 5, 2, ' '   
   657 00001B3E 1306020120                      db 19, 6, 2, 1, ' '   
   658 00001B43 1906010120                      db 25, 6, 1, 1, ' '   
   659 00001B48 1F06020120                      db 31, 6, 2, 1, ' '
   660                                  
   661 00001B4D 2B06030120                      db 43, 6, 3, 1, ' '   
   662 00001B52 3106040120                      db 49, 6, 4, 1, ' '   
   663 00001B57 3706020120                      db 55, 6, 2, 1, ' '   
   664 00001B5C 3D06050220                      db 61, 6, 5, 2, ' '  
   665 00001B61 4306020120                      db 67, 6, 2, 1, ' '
   666                                  
   667 00001B66 0707050220                      db 7, 7, 5, 2, ' '    
   668 00001B6B 0D07020120                      db 13, 7, 2, 1, ' '   
   669 00001B70 1307010120                      db 19, 7, 1, 1, ' '   
   670 00001B75 1907020120                      db 25, 7, 2, 1, ' '   
   671 00001B7A 1F07030120                      db 31, 7, 3, 1, ' '
   672                                  
   673 00001B7F 2B07040120                      db 43, 7, 4, 1, ' '   
   674 00001B84 3107020120                      db 49, 7, 2, 1, ' '   
   675 00001B89 3707050220                      db 55, 7, 5, 2, ' '   
   676 00001B8E 3D07020120                      db 61, 7, 2, 1, ' '  
   677 00001B93 4307030120                      db 67, 7, 3, 1, ' '
   678                                  
   679 00001B98 0708020120                      db 7, 8, 2, 1, ' '    
   680 00001B9D 0D08010120                      db 13, 8, 1, 1, ' '   
   681 00001BA2 1308020120                      db 19, 8, 2, 1, ' '   
   682 00001BA7 1908030120                      db 25, 8, 3, 1, ' '   
   683 00001BAC 1F08040120                      db 31, 8, 4, 1, ' '
   684                                  
   685 00001BB1 2B08020120                      db 43, 8, 2, 1, ' '   
   686 00001BB6 3108050220                      db 49, 8, 5, 2, ' '   
   687 00001BBB 3708020120                      db 55, 8, 2, 1, ' '   
   688 00001BC0 3D08030120                      db 61, 8, 3, 1, ' '  
   689 00001BC5 4308040120                      db 67, 8, 4, 1, ' '
   690                                  
   691 00001BCA 0709010120                      db 7, 9, 1, 1, ' '    
   692 00001BCF 0D09020120                      db 13, 9, 2, 1, ' '   
   693 00001BD4 1309030120                      db 19, 9, 3, 1, ' '   
   694 00001BD9 1909040120                      db 25, 9, 4, 1, ' '   
   695 00001BDE 1F09020120                      db 31, 9, 2, 1, ' '
   696                                  
   697 00001BE3 2B09050220                      db 43, 9, 5, 2, ' '   
   698 00001BE8 3109020120                      db 49, 9, 2, 1, ' '   
   699 00001BED 3709030120                      db 55, 9, 3, 1, ' '   
   700 00001BF2 3D09040120                      db 61, 9, 4, 1, ' '  
   701 00001BF7 4309020120                      db 67, 9, 2, 1, ' '
   702                                  
   703 00001BFC 070A020120                      db 7, 10, 2, 1, ' '    
   704 00001C01 0D0A030120                      db 13, 10, 3, 1, ' '   
   705 00001C06 130A040120                      db 19, 10, 4, 1, ' '   
   706 00001C0B 190A020120                      db 25, 10, 2, 1, ' '   
   707 00001C10 1F0A010120                      db 31, 10, 1, 1, ' '
   708                                  
   709 00001C15 2B0A020120                      db 43, 10, 2, 1, ' '   
   710 00001C1A 310A030120                      db 49, 10, 3, 1, ' '   
   711 00001C1F 370A040120                      db 55, 10, 4, 1, ' '   
   712 00001C24 3D0A020120                      db 61, 10, 2, 1, ' '  
   713 00001C29 430A010120                      db 67, 10, 1, 1, ' '
   714                                  
   715 00001C2E 070B030120                      db 7, 11, 3, 1, ' '   
   716 00001C33 0D0B040120                      db 13, 11, 4, 1, ' '   
   717 00001C38 130B020120                      db 19, 11, 2, 1, ' '   
   718 00001C3D 190B010120                      db 25, 11, 1, 1, ' '  
   719 00001C42 1F0B050220                      db 31, 11, 5, 2, ' '
   720                                  
   721 00001C47 2B0B030120                      db 43, 11, 3, 1, ' '   
   722 00001C4C 310B040120                      db 49, 11, 4, 1, ' '   
   723 00001C51 370B020120                      db 55, 11, 2, 1, ' '   
   724 00001C56 3D0B010120                      db 61, 11, 1, 1, ' '  
   725 00001C5B 430B020120                      db 67, 11, 2, 1, ' '
   726                                  
   727 00001C60 070C040120                      db 7, 12, 4, 1, ' '   
   728 00001C65 0D0C020120                      db 13, 12, 2, 1, ' '   
   729 00001C6A 130C010120                      db 19, 12, 1, 1, ' '   
   730 00001C6F 190C050220                      db 25, 12, 5, 2, ' '  
   731 00001C74 1F0C030120                      db 31, 12, 3, 1, ' '
   732                                  
   733 00001C79 2B0C040120                      db 43, 12, 4, 1, ' '    
   734 00001C7E 310C020120                      db 49, 12, 2, 1, ' '   
   735 00001C83 370C010120                      db 55, 12, 1, 1, ' '   
   736 00001C88 3D0C020120                      db 61, 12, 2, 1, ' '   
   737 00001C8D 430C030120                      db 67, 12, 3, 1, ' '
   738                                  
   739 00001C92 070D020120                      db 7, 13, 2, 1, ' '   
   740 00001C97 0D0D010120                      db 13, 13, 1, 1, ' '   
   741 00001C9C 130D050220                      db 19, 13, 5, 2, ' '   
   742 00001CA1 190D030143                      db 25, 13, 3, 1, 'C'  
   743 00001CA6 1F0D040120                      db 31, 13, 4, 1, ' '
   744                                  
   745 00001CAB 2B0D020120                      db 43, 13, 2, 1, ' '    
   746 00001CB0 310D010120                      db 49, 13, 1, 1, ' '   
   747 00001CB5 370D020120                      db 55, 13, 2, 1, ' '   
   748 00001CBA 3D0D030120                      db 61, 13, 3, 1, ' '   
   749 00001CBF 430D050220                      db 67, 13, 5, 2, ' '
   750                                  
   751 00001CC4 070E010120                      db 7, 14, 1, 1, ' '   
   752 00001CC9 0D0E050220                      db 13, 14, 5, 2, ' '   
   753 00001CCE 130E030120                      db 19, 14, 3, 1, ' '   
   754 00001CD3 190E040120                      db 25, 14, 4, 1, ' '  
   755 00001CD8 1F0E020120                      db 31, 14, 2, 1, ' '
   756                                  
   757 00001CDD 2B0E010120                      db 43, 14, 1, 1, ' '    
   758 00001CE2 310E020120                      db 49, 14, 2, 1, ' '   
   759 00001CE7 370E030120                      db 55, 14, 3, 1, ' '   
   760 00001CEC 3D0E050220                      db 61, 14, 5, 2, ' '   
   761 00001CF1 430E020120                      db 67, 14, 2, 1, ' '
   762                                  
   763 00001CF6 070F050220                      db 7, 15, 5, 2, ' '   
   764 00001CFB 0D0F030120                      db 13, 15, 3, 1, ' '   
   765 00001D00 130F040120                      db 19, 15, 4, 1, ' '   
   766 00001D05 190F020120                      db 25, 15, 2, 1, ' '  
   767 00001D0A 1F0F010120                      db 31, 15, 1, 1, ' '
   768                                  
   769 00001D0F 2B0F020145                      db 43, 15, 2, 1, 'E'    
   770 00001D14 310F03014C                      db 49, 15, 3, 1, 'L'   
   771 00001D19 370F050220                      db 55, 15, 5, 2, ' '   
   772 00001D1E 3D0F020120                      db 61, 15, 2, 1, ' '   
   773 00001D23 430F010120                      db 67, 15, 1, 1, ' '
   774                                  
   775 00001D28 0710030120                      db 7, 16, 3, 1, ' '   
   776 00001D2D 0D10040120                      db 13, 16, 4, 1, ' '   
   777 00001D32 1310020120                      db 19, 16, 2, 1, ' '   
   778 00001D37 1910010120                      db 25, 16, 1, 1, ' '  
   779 00001D3C 1F10020120                      db 31, 16, 2, 1, ' '
   780                                  
   781 00001D41 2B10030120                      db 43, 16, 3, 1, ' '    
   782 00001D46 3110050220                      db 49, 16, 5, 2, ' '   
   783 00001D4B 3710020120                      db 55, 16, 2, 1, ' '   
   784 00001D50 3D10010120                      db 61, 16, 1, 1, ' '   
   785 00001D55 4310020120                      db 67, 16, 2, 1, ' '
   786                                  
   787 00001D5A 0711040120                      db 7, 17, 4, 1, ' '   
   788 00001D5F 0D11020120                      db 13, 17, 2, 1, ' '   
   789 00001D64 1311010120                      db 19, 17, 1, 1, ' '   
   790 00001D69 1911020120                      db 25, 17, 2, 1, ' '  
   791 00001D6E 1F11030120                      db 31, 17, 3, 1, ' '
   792                                  
   793 00001D73 2B11050220                      db 43, 17, 5, 2, ' '    
   794 00001D78 3111020120                      db 49, 17, 2, 1, ' '    
   795 00001D7D 3711010120                      db 55, 17, 1, 1, ' '   
   796 00001D82 3D11020120                      db 61, 17, 2, 1, ' '   
   797 00001D87 4311030120                      db 67, 17, 3, 1, ' '
   798                                  
   799                                      level4_blocks_count equ 140
   800                                  
   801                                      ; Nivel 5
   802                                      level5_blocks:
   803                                  
   804 00001D8C 1303020145                      db 19, 3, 2, 1, 'E'   
   805 00001D91 3703020120                      db 55, 3, 2, 1, ' '   
   806                                  
   807 00001D96 1304020120                      db 19, 4, 2, 1, ' '   
   808 00001D9B 370402014C                      db 55, 4, 2, 1, 'L' 
   809                                  
   810 00001DA0 1905020120                      db 25, 5, 2, 1, ' '   
   811 00001DA5 3105020153                      db 49, 5, 2, 1, 'S'   
   812                                  
   813 00001DAA 1906020120                      db 25, 6, 2, 1, ' '   
   814 00001DAF 3106020120                      db 49, 6, 2, 1, ' '   
   815                                  
   816 00001DB4 1307050220                      db 19, 7, 5, 2, ' '   
   817 00001DB9 1907050220                      db 25, 7, 5, 2, ' '  
   818 00001DBE 1F07050220                      db 31, 7, 5, 2, ' '
   819 00001DC3 2507050220                      db 37, 7, 5, 2, ' '
   820 00001DC8 2B07050220                      db 43, 7, 5, 2, ' '    
   821 00001DCD 3107050220                      db 49, 7, 5, 2, ' '    
   822 00001DD2 3707050220                      db 55, 7, 5, 2, ' '   
   823                                  
   824 00001DD7 1308050220                      db 19, 8, 5, 2, ' '   
   825 00001DDC 1908050220                      db 25, 8, 5, 2, ' '  
   826 00001DE1 1F08050220                      db 31, 8, 5, 2, ' '
   827 00001DE6 2508050220                      db 37, 8, 5, 2, ' '
   828 00001DEB 2B08050220                      db 43, 8, 5, 2, ' '    
   829 00001DF0 3108050220                      db 49, 8, 5, 2, ' '    
   830 00001DF5 3708050220                      db 55, 8, 5, 2, ' '   
   831                                  
   832 00001DFA 0D09050220                      db 13, 9, 5, 2, ' '   
   833 00001DFF 1309050220                      db 19, 9, 5, 2, ' '   
   834 00001E04 1909040143                      db 25, 9, 4, 1, 'C'  
   835 00001E09 1F09050220                      db 31, 9, 5, 2, ' '
   836 00001E0E 2509050220                      db 37, 9, 5, 2, ' '
   837 00001E13 2B09050220                      db 43, 9, 5, 2, ' '    
   838 00001E18 3109040144                      db 49, 9, 4, 1, 'D'    
   839 00001E1D 3709050220                      db 55, 9, 5, 2, ' '   
   840 00001E22 3D09050220                      db 61, 9, 5, 2, ' '  
   841                                  
   842 00001E27 0D0A050220                      db 13, 10, 5, 2, ' '   
   843 00001E2C 130A050220                      db 19, 10, 5, 2, ' '   
   844 00001E31 190A040120                      db 25, 10, 4, 1, ' '  
   845 00001E36 1F0A050220                      db 31, 10, 5, 2, ' '
   846 00001E3B 250A050220                      db 37, 10, 5, 2, ' '
   847 00001E40 2B0A050220                      db 43, 10, 5, 2, ' '    
   848 00001E45 310A040120                      db 49, 10, 4, 1, ' '    
   849 00001E4A 370A050220                      db 55, 10, 5, 2, ' '   
   850 00001E4F 3D0A050220                      db 61, 10, 5, 2, ' '   
   851                                          
   852 00001E54 070B050220                      db 7, 11, 5, 2, ' '   
   853 00001E59 0D0B050220                      db 13, 11, 5, 2, ' '   
   854 00001E5E 130B050220                      db 19, 11, 5, 2, ' '   
   855 00001E63 190B050220                      db 25, 11, 5, 2, ' '  
   856 00001E68 1F0B050220                      db 31, 11, 5, 2, ' '
   857 00001E6D 250B050220                      db 37, 11, 5, 2, ' '
   858 00001E72 2B0B050220                      db 43, 11, 5, 2, ' '    
   859 00001E77 310B050220                      db 49, 11, 5, 2, ' '    
   860 00001E7C 370B050220                      db 55, 11, 5, 2, ' '   
   861 00001E81 3D0B050220                      db 61, 11, 5, 2, ' '   
   862 00001E86 430B050220                      db 67, 11, 5, 2, ' '
   863                                  
   864 00001E8B 070C050220                      db 7, 12, 5, 2, ' '   
   865 00001E90 0D0C050220                      db 13, 12, 5, 2, ' '   
   866 00001E95 130C050220                      db 19, 12, 5, 2, ' '   
   867 00001E9A 190C050220                      db 25, 12, 5, 2, ' '  
   868 00001E9F 1F0C050220                      db 31, 12, 5, 2, ' '
   869 00001EA4 250C050220                      db 37, 12, 5, 2, ' '
   870 00001EA9 2B0C050220                      db 43, 12, 5, 2, ' '    
   871 00001EAE 310C050220                      db 49, 12, 5, 2, ' '    
   872 00001EB3 370C050220                      db 55, 12, 5, 2, ' '   
   873 00001EB8 3D0C050220                      db 61, 12, 5, 2, ' '   
   874 00001EBD 430C050220                      db 67, 12, 5, 2, ' '
   875                                  
   876 00001EC2 070D050220                      db 7, 13, 5, 2, ' '   
   877 00001EC7 0D0D050220                      db 13, 13, 5, 2, ' '   
   878 00001ECC 130D050220                      db 19, 13, 5, 2, ' '   
   879 00001ED1 190D050220                      db 25, 13, 5, 2, ' '  
   880 00001ED6 1F0D050220                      db 31, 13, 5, 2, ' '
   881 00001EDB 250D050220                      db 37, 13, 5, 2, ' '
   882 00001EE0 2B0D050220                      db 43, 13, 5, 2, ' '    
   883 00001EE5 310D050220                      db 49, 13, 5, 2, ' '    
   884 00001EEA 370D050220                      db 55, 13, 5, 2, ' '   
   885 00001EEF 3D0D050220                      db 61, 13, 5, 2, ' '   
   886 00001EF4 430D050220                      db 67, 13, 5, 2, ' '
   887                                  
   888                                          
   889 00001EF9 070E050220                      db 7, 14, 5, 2, ' '   
   890 00001EFE 130E050220                      db 19, 14, 5, 2, ' '   
   891 00001F03 190E050220                      db 25, 14, 5, 2, ' '  
   892 00001F08 1F0E050220                      db 31, 14, 5, 2, ' '
   893 00001F0D 250E050220                      db 37, 14, 5, 2, ' '
   894 00001F12 2B0E050220                      db 43, 14, 5, 2, ' '    
   895 00001F17 310E050220                      db 49, 14, 5, 2, ' '    
   896 00001F1C 370E050220                      db 55, 14, 5, 2, ' '   
   897 00001F21 430E050220                      db 67, 14, 5, 2, ' '
   898                                  
   899 00001F26 070F050220                      db 7, 15, 5, 2, ' '   
   900 00001F2B 130F050220                      db 19, 15, 5, 2, ' '      
   901 00001F30 370F050220                      db 55, 15, 5, 2, ' '   
   902 00001F35 430F050220                      db 67, 15, 5, 2, ' '
   903                                   
   904 00001F3A 0710050220                      db 7, 16, 5, 2, ' '   
   905 00001F3F 1310050220                      db 19, 16, 5, 2, ' '      
   906 00001F44 3710050220                      db 55, 16, 5, 2, ' '   
   907 00001F49 4310050220                      db 67, 16, 5, 2, ' '
   908                                  
   909                                  
   910 00001F4E 1911050220                      db 25, 17, 5, 2, ' '  
   911 00001F53 1F11050220                      db 31, 17, 5, 2, ' '
   912 00001F58 2B11050220                      db 43, 17, 5, 2, ' '    
   913 00001F5D 3111050220                      db 49, 17, 5, 2, ' ' 
   914                                  
   915 00001F62 1912050220                      db 25, 18, 5, 2, ' '  
   916 00001F67 1F12050220                      db 31, 18, 5, 2, ' '
   917 00001F6C 2B12050220                      db 43, 18, 5, 2, ' '    
   918 00001F71 3112050220                      db 49, 18, 5, 2, ' ' 
   919                                  
   920                                      level5_blocks_count equ 98
   921                                  
   922                                      ; Array para mantener el estado de los bloques
   923 00001F76 00<rep C8h>                 block_states: times 200 db 0  ; Durabilidad actual de cada bloque
   924                                  
   925                                      
   926                                      ; Variables para almacenar los valores
   927 0000203E 0000000000000000            current_score dq 0          ; Score actual
   928 00002046 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   929                                      
   930                                      ; Buffer para convertir números a string
   931 00002047 00<rep 14h>                 number_buffer: times 20 db 0
   932                                  
   933 0000205B 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   934                                      
   935                                      ; Estructura para los enemigos (x, y, activo)
   936 00002060 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   937 0000207E 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   938                                      
   939 0000207F 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   940 00002087 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   941 00002088 0A                          enemy_move_delay db 10           ; Mover enemigos cada N ciclos
   942 00002089 00                          enemy_move_total db 0      ; Contador total de movimientos
   943 0000208A 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   944 0000208B 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   945                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   946 0000208C 323C464BE4F8788CA0-         level1_spawn_points: db 50, 60, 70, 75, 740, 760, 120, 140, 160, 180    ; 10 enemigos
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946 00002095 B4                 
   947 00002096 001E3246556E8296AA-         level2_spawn_points: db 0, 30, 50, 70, 85, 110, 130, 150, 170, 190    ; 10 enemigos
   947 0000209F BE                 
   948 000020A0 00000032373C646464-         level3_spawn_points: db 0, 0, 0, 50, 55, 60, 100, 100, 100, 100   ; 10 enemigos
   948 000020A9 64                 
   949 000020AA 00040F1E2832465A64-         level4_spawn_points: db 0, 4, 15, 30, 40, 50, 70, 90, 100, 120  ; 10 enemigos
   949 000020B3 78                 
   950 000020B4 00000A141E2328323C-         level5_spawn_points: db 0, 0, 10, 20, 30, 35, 40, 50, 60, 80 ; 10 enemigos
   950 000020BD 50                 
   951                                          ; Arreglo de punteros a los spawn points de cada nivel
   952                                      spawn_points_table:
   953 000020BE [8C20000000000000]              dq level1_spawn_points
   954 000020C6 [9620000000000000]              dq level2_spawn_points
   955 000020CE [A020000000000000]              dq level3_spawn_points
   956 000020D6 [AA20000000000000]              dq level4_spawn_points
   957 000020DE [B420000000000000]              dq level5_spawn_points
   958                                  
   959                                      ; Variables para el comportamiento de enemigos
   960 000020E6 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   961 000020E7 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   962 000020E8 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   963 000020E9 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   964                                  
   965 000020F3 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   965 000020FC 5B2020202020202020-
   965 00002105 20205D0A0D         
   966                                      score_label_len: equ $ - score_label
   967 0000210A 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   967 00002113 657374727569646F73-
   967 0000211C 3A205B2020205D0A0D 
   968                                      blocks_label_len: equ $ - blocks_label
   969                                      
   970                                      ; Posición donde insertar los números en los labels
   971                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   972                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   973                                      
   974                                      ; Definición de las vidas (x, y, estado)
   975                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   976                                      lives_data: 
   977 00002125 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   978 00002128 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   979 0000212B 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   980 0000212E 081E00                          db 8, 30, 0     ; Vida 4 (inactiva)
   981 00002131 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   982 00002134 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   983 00002137 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   984                                      lives_count equ 7    ; Total de vidas
   985 0000213A 5E                          life_char db "^"    
   986 0000213B 03                          current_lives db 3   ; Contador de vidas activas actual
   987                                  
   988                                  ; Estructura para almacenar las letras y sus posiciones
   989                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   990 0000213C 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   991 000022CC 00                          letters_count db 0   
   992 000022CD 20                          last_letter db ' '    ; Variable para almacenar la última letra
   993 000022CE 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   993 000022D7 75616C3A205B205D0A-
   993 000022E0 0D                 
   994                                      last_letter_msg_len equ $ - last_letter_msg
   995 000022E1 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   996 000022E2 07                          max_lives db 7              ; Máximo número de vidas permitidas
   997 000022E3 0700000000000000            ball_speed dq 7             ; Velocidad normal de la bola
   998 000022EB 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   999 000022F3 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
  1000                                     
  1001 000022FB 00                          initial_catch_active db 0   ; 0 = inactivo, 1 = activo
  1002                                  
  1003 000022FC 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
  1004 000022FD 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
  1005 000022FE 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
  1006 000022FF 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
  1007                                  
  1008 00002300 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
  1009 00002308 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
  1010                                  
  1011 00002309 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
  1012 0000230A 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
  1013 0000230B 00                          laser_count: db 0                ; Contador de láseres activos
  1014 0000230C 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
  1015 000023D4 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
  1016                                  
  1017                                      balls_data:     ; Array para almacenar hasta 3 bolas
  1018                                          ; Bola 1 (principal)
  1019 000023DC 0000000000000000                dq 0        ; x_pos
  1020 000023E4 0000000000000000                dq 0        ; y_pos
  1021 000023EC 0100000000000000                dq 1        ; direction_x
  1022 000023F4 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1023 000023FC 01                              db 1        ; active
  1024                                          ; Bola 2
  1025 000023FD 0000000000000000                dq 0        ; x_pos
  1026 00002405 0000000000000000                dq 0        ; y_pos
  1027 0000240D FFFFFFFFFFFFFFFF                dq -1       ; direction_x
  1028 00002415 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1029 0000241D 00                              db 0        ; active
  1030                                          ; Bola 3
  1031 0000241E 0000000000000000                dq 0        ; x_pos
  1032 00002426 0000000000000000                dq 0        ; y_pos
  1033 0000242E 0000000000000000                dq 0        ; direction_x
  1034 00002436 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1035 0000243E 00                              db 0        ; active
  1036                                      
  1037 0000243F 01                          balls_count db 1     ; Contador de bolas activas
  1038                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
  1039 00002440 00<rep Ah>                  enemy_last_x:       times 10 db 0
  1040 0000244A 00<rep Ah>                  enemy_last_y:       times 10 db 0
  1041 00002454 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
  1042 0000245E 00                          letter_move_counter db 0
  1043                                      initial_ball_offset_x equ 2    ; Offset desde el centro de la paleta
  1044                                      initial_ball_offset_y equ -1   ; Offset vertical desde la paleta
  1045                                  
  1046 0000245F C2A148617320706572-         game_over_msg db '¡Has perdido!', 10, 'Puntaje final: '
  1046 00002468 6469646F210A50756E-
  1046 00002471 74616A652066696E61-
  1046 0000247A 6C3A20             
  1047                                      game_over_len equ $ - game_over_msg
  1048 0000247D 0A                          newline db 10
  1049                                      newline_len equ 1
  1050                                  
  1051 0000247E C2A146656C69636964-         game_win_msg db '¡Felicidades, ganaste!', 10, 'Puntaje final: '
  1051 00002487 616465732C2067616E-
  1051 00002490 61737465210A50756E-
  1051 00002499 74616A652066696E61-
  1051 000024A2 6C3A20             
  1052                                      game_win_len equ $ - game_win_msg
  1053                                  
  1054                                  
  1055                                  section .text
  1056                                  
  1057                                  
  1058                                  print_lives:; Función para imprimir las vidas en la parte inferior
  1059 000001DD 55                          push rbp; Guardar el puntero de la base
  1060 000001DE 4889E5                      mov rbp, rsp; Establecer el puntero de la base
  1061                                      
  1062 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
  1063                                      
  1064                                      .print_loop:; Bucle para imprimir todas las vidas
  1065 000001E4 4983FC07                        cmp r12, lives_count; Verificar si se han impreso todas las vidas
  1066 000001E8 7D45                            jge .end; Si se han impreso todas las vidas, terminar
  1067                                          
  1068                                          ; Calcular offset de la vida actual
  1069 000001EA 4C89E0                          mov rax, r12    ; Calcular offset en el arreglo de vidas
  1070 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
  1071 000001F1 488DB0[25210000]                lea rsi, [lives_data + rax]    ; Cargar dirección de la vida actual
  1072                                          
  1073                                          ; Calcular posición en el tablero
  1074 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
  1075 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1076                                          
  1077                                          ; Calcular offset en el tablero
  1078 00000201 B850000000                      mov rax, column_cells        ; Ancho del tablero
  1079 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1080 0000020A 49F7E1                          mul r9                        ; Multiplicar por Y
  1081 0000020D 4C01C0                          add rax, r8                    ; Sumar X
  1082 00000210 488DB8[400A0000]                lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1083                                          
  1084                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
  1085 00000217 807E0201                        cmp byte [rsi + 2], 1     ; Verificar si la vida está activa
  1086 0000021B 7405                            je .draw_active           ; Si está activa, dibujar el carácter de vida 
  1087                                          
  1088                                          ; Si está inactiva, dibujar espacio
  1089 0000021D C60720                          mov byte [rdi], ' '
  1090 00000220 EB08                            jmp .next_life
  1091                                          
  1092                                      .draw_active:
  1093                                          ; Si está activa, dibujar el símbolo de vida
  1094 00000222 8A05(3A210000)                  mov al, [life_char]
  1095 00000228 8807                            mov [rdi], al
  1096                                          
  1097                                      .next_life:
  1098 0000022A 49FFC4                          inc r12
  1099 0000022D EBB5                            jmp .print_loop
  1100                                          
  1101                                      .end:
  1102 0000022F 5D                              pop rbp
  1103 00000230 C3                              ret
  1104                                  
  1105                                  ; Función para desactivar una vida
  1106                                  
  1107                                  lose_life:
  1108 00000231 55                          push rbp    ; Guardar el puntero de la base
  1109 00000232 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1110                                      
  1111                                      ; Verificar si aún quedan vidas
  1112 00000235 803D(3B210000)00            cmp byte [current_lives], 0   ; Verificar si quedan vidas
  1113 0000023C 0F84AB000000                je .game_lost             ; Si no quedan vidas, perder el juego
  1114                                      
  1115                                      ; Encontrar la última vida activa
  1116 00000242 B907000000                  mov rcx, lives_count    ; Cantidad total de vidas
  1117 00000247 48FFC9                      dec rcx               ; Índice de la última vida
  1118                                      
  1119                                      .find_active_life:  ; Bucle para encontrar la última vida activa
  1120 0000024A 4889C8                          mov rax, rcx    ; Calcular offset en el arreglo de vidas
  1121 0000024D 486BC003                        imul rax, 3    ; Cada vida ocupa 3 bytes (x, y, estado)
  1122 00000251 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Cargar dirección de la vida actual
  1123 00000258 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si la vida está activa
  1124 0000025C 740A                            je .deactivate_life   ; Si está activa, desactivarla
  1125 0000025E 48FFC9                          dec rcx   ; Si no está activa, probar con la siguiente vida
  1126 00000261 79E7                            jns .find_active_life   ; Si aún quedan vidas, continuar buscando
  1127 00000263 E985000000                      jmp .game_lost  ; Si no quedan vidas, perder el juego
  1128                                          
  1129                                      .deactivate_life:   ; Desactivar la vida encontrada
  1130                                          ; Borrar vida visualmente y en datos
  1131 00000268 4C0FB606                        movzx r8, byte [rsi]    ; X
  1132 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]    ; Y
  1133 00000271 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1134 00000276 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1135 0000027A 49F7E1                          mul r9  ; Multiplicar por Y
  1136 0000027D 4C01C0                          add rax, r8 ; Sumar X
  1137 00000280 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1138 00000287 C60720                          mov byte [rdi], ' ' ; Borrar visual
  1139 0000028A C6460200                        mov byte [rsi + 2], 0   ; Desactivar vida
  1140 0000028E FE0D(3B210000)                  dec byte [current_lives]    ; Decrementar contador de vidas
  1141                                          
  1142                                          ; Borrar paleta anterior
  1143 00000294 4C8B05(BF140000)                mov r8, [pallet_position]   ; Posición de la paleta
  1144 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]  ; Tamaño de la paleta
  1145                                          .erase_pallet_loop: ; Bucle para borrar la paleta
  1146 000002A2 41C60020                            mov byte [r8], ' '  ; Borrar visualmente
  1147 000002A6 49FFC0                              inc r8  ; Siguiente byte
  1148 000002A9 48FFC9                              dec rcx ; Decrementar contador
  1149 000002AC 75F4                                jnz .erase_pallet_loop  ; Si no se ha borrado toda la paleta, continuar
  1150                                          
  1151                                          ; Reiniciar solo la bola principal
  1152 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40      ; Posición inicial de la bola
  1152 000002B6 000000             
  1153 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28    ; Posición inicial de la bola
  1153 000002C1 000000             
  1154 000002C4 C605(FF140000)00                mov byte [ball_moving], 0   ; Detener la bola
  1155 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
  1156 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1156 000002D9 [B0130000]         
  1157                                          
  1158                                          ; Asegurarse que las otras bolas están desactivadas
  1159 000002DD C605(22150000)00                mov byte [ball2_active], 0  ; Desactivar bola 2
  1160 000002E4 C605(44150000)00                mov byte [ball3_active], 0      ; Desactivar bola 3
  1161                                          
  1162 000002EB EB07                            jmp .end    ; Salir
  1163                                          
  1164                                      .game_lost:
  1165 000002ED E8D5000000                      call game_lost  ; Perder el juego
  1166 000002F2 EB00                            jmp .end    ; Salir
  1167                                          
  1168                                      .end:
  1169 000002F4 5D                              pop rbp   ; Restaurar el puntero de la base
  1170 000002F5 C3                              ret  ; Retornar
  1171                                  ; Función modificada para verificar colisión con el borde inferior
  1172                                  check_bottom_collision:   ; Función para verificar colisión con el borde inferior
  1173 000002F6 55                          push rbp    ; Guardar el puntero de la base
  1174 000002F7 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1175                                      
  1176                                  
  1177                                      ; Verificar bola principal
  1178 000002FA 803D(00150000)01            cmp byte [ball_active], 1   ; Verificar si la bola principal está activa
  1179 00000301 7542                        jne .check_ball2        ; Si no está activa, verificar bola 2
  1180 00000303 488B05(E7140000)            mov rax, [ball_y_pos]   ; Obtener posición Y de la bola principal
  1181 0000030A 4883F81E                    cmp rax, row_cells - 2      ; Verificar si ha llegado al borde inferior
  1182 0000030E 7535                        jne .check_ball2    ; Si no ha llegado al borde, verificar bola 2
  1183                                      
  1184                                      ; Borrar visualmente la bola principal
  1185 00000310 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Obtener posición X de la bola principal
  1186 00000317 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Obtener posición Y de la bola principal
  1187 0000031E 4981C0[400A0000]            add r8, board        ; Calcular dirección en el tablero
  1188 00000325 4C89C9                      mov rcx, r9        ; Calcular offset en el tablero
  1189 00000328 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  1190 0000032D 48F7E9                      imul rcx    ; Multiplicar por Y
  1191 00000330 4901C0                      add r8, rax   ; Sumar X
  1192 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1193                                      
  1194 00000337 C605(00150000)00            mov byte [ball_active], 0   ; Desactivar bola principal
  1195 0000033E C605(FF140000)00            mov byte [ball_moving], 0   ; Detener la bola principal
  1196                                  
  1197                                  .check_ball2:   ; Verificar bola 2
  1198 00000345 803D(22150000)01            cmp byte [ball2_active], 1  ; Verificar si la bola 2 está activa
  1199 0000034C 751B                        jne .check_ball3    ; Si no está activa, verificar bola 3
  1200 0000034E 488B05(09150000)            mov rax, [ball2_y_pos]  ; Obtener
  1201 00000355 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1202 00000359 750E                        jne .check_ball3    ; Si no ha llegado al borde, verificar bola 3
  1203 0000035B C605(22150000)00            mov byte [ball2_active], 0      ; Desactivar bola 2
  1204 00000362 C605(21150000)00            mov byte [ball2_moving], 0    ; Detener bola 2
  1205                                  
  1206                                  .check_ball3:   ; Verificar bola 3
  1207 00000369 803D(44150000)01            cmp byte [ball3_active], 1  ; Verificar si la bola 3 está activa
  1208 00000370 751B                        jne .check_active_balls   ; Si no está activa, verificar bolas activas
  1209 00000372 488B05(2B150000)            mov rax, [ball3_y_pos]  ; Obtener posición Y de la bola 3
  1210 00000379 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1211 0000037D 750E                        jne .check_active_balls  ; Si no ha llegado al borde, verificar bolas activas
  1212 0000037F C605(44150000)00            mov byte [ball3_active], 0  ; Desactivar bola 3
  1213 00000386 C605(43150000)00            mov byte [ball3_moving], 0  ; Detener bola 3
  1214                                  
  1215                                  .check_active_balls:        
  1216                                      ; Verificar si quedan bolas activas
  1217 0000038D 4831C9                      xor rcx, rcx    ; Contar bolas activas
  1218                                      
  1219                                      ; Contar bolas activas
  1220 00000390 8A05(00150000)              mov al, byte [ball_active]  ; Verificar si la bola principal está activa
  1221 00000396 4801C1                      add rcx, rax    ; Sumar al contador
  1222 00000399 8A05(22150000)              mov al, byte [ball2_active] ; Verificar si la bola 2 está activa
  1223 0000039F 4801C1                      add rcx, rax    ; Sumar al contador
  1224 000003A2 8A05(44150000)              mov al, byte [ball3_active] ; Verificar si la bola 3 está activa
  1225 000003A8 4801C1                      add rcx, rax    ; Sumar al contador
  1226                                      
  1227                                      ; Si no hay bolas activas y quedan bloques, perder vida
  1228 000003AB 4885C9                      test rcx, rcx   ; Verificar si hay bolas activas
  1229 000003AE 7515                        jnz .balls_remain   ; Si hay bolas activas, salir
  1230                                      
  1231 000003B0 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Verificar si quedan bloques
  1232 000003B7 740C                        je .balls_remain               ; Si no quedan bloques, no perder vida
  1233                                      
  1234 000003B9 E873FEFFFF                  call lose_life
  1235 000003BE C605(00150000)01            mov byte [ball_active], 1      ; Reactivar bola principal
  1236                                      
  1237                                  .balls_remain:  ; Si quedan bolas, continuar
  1238 000003C5 5D                          pop rbp     ; Restaurar el puntero de la base
  1239 000003C6 C3                          ret    ; Retornar
  1240                                  
  1241                                  ; Nueva función para game over
  1242                                  game_lost:
  1243 000003C7 55                          push rbp
  1244 000003C8 4889E5                      mov rbp, rsp
  1245                                      
  1246                                      ; Limpiar pantalla
  1247 000003CB 48BE-                       mov rsi, clear
  1247 000003CD [1000000000000000] 
  1248 000003D5 BA07000000                  mov rdx, clear_length
  1249 000003DA B801000000                  mov eax, sys_write
  1250 000003DF BF01000000                  mov edi, 1
  1251 000003E4 0F05                        syscall
  1252                                      
  1253                                      ; Imprimir mensaje de Game Over
  1254 000003E6 48BE-                       mov rsi, game_over_msg
  1254 000003E8 [5F24000000000000] 
  1255 000003F0 BA1E000000                  mov rdx, game_over_len
  1256 000003F5 B801000000                  mov eax, sys_write
  1257 000003FA BF01000000                  mov edi, 1
  1258 000003FF 0F05                        syscall
  1259                                      
  1260                                      ; Convertir score a string
  1261 00000401 488B05(3E200000)            mov rax, [current_score]
  1262 00000408 48BF-                       mov rdi, number_buffer
  1262 0000040A [4720000000000000] 
  1263 00000412 E881150000                  call number_to_string
  1264                                      
  1265                                      ; Calcular longitud del número convertido
  1266 00000417 B900000000                  mov rcx, 0
  1267 0000041C 48BF-                       mov rdi, number_buffer
  1267 0000041E [4720000000000000] 
  1268                                  .count_loop:
  1269 00000426 803C0F00                    cmp byte [rdi + rcx], 0
  1270 0000042A 7405                        je .print_score
  1271 0000042C 48FFC1                      inc rcx
  1272 0000042F EBF5                        jmp .count_loop
  1273                                  
  1274                                  .print_score:
  1275                                      ; Imprimir el score
  1276 00000431 48BE-                       mov rsi, number_buffer
  1276 00000433 [4720000000000000] 
  1277 0000043B 4889CA                      mov rdx, rcx
  1278 0000043E B801000000                  mov eax, sys_write
  1279 00000443 BF01000000                  mov edi, 1
  1280 00000448 0F05                        syscall
  1281                                      
  1282                                      ; Imprimir nueva línea
  1283 0000044A 48BE-                       mov rsi, newline
  1283 0000044C [7D24000000000000] 
  1284 00000454 BA01000000                  mov rdx, newline_len
  1285 00000459 B801000000                  mov eax, sys_write
  1286 0000045E BF01000000                  mov edi, 1
  1287 00000463 0F05                        syscall
  1288                                      
  1289                                  .wait_q:
  1290                                      ; Esperar por la tecla 'q'
  1291 00000465 B800000000                  mov rax, sys_read
  1292 0000046A BF00000000                  mov rdi, STDIN_FILENO
  1293 0000046F 48BE-                       mov rsi, input_char
  1293 00000471 [0000000000000000] 
  1294 00000479 BA01000000                  mov rdx, 1
  1295 0000047E 0F05                        syscall
  1296                                      
  1297 00000480 803D(00000000)71            cmp byte [input_char], 'q'
  1298 00000487 75DC                        jne .wait_q
  1299                                  
  1300 00000489 E9881F0000                  jmp exit
  1301                                      
  1302 0000048E 5D                          pop rbp
  1303 0000048F C3                          ret
  1304                                  ; Función para registrar una nueva letra en el mapa
  1305                                  ; Entrada:
  1306                                  ;   al - letra a registrar
  1307                                  ;   r8b - posición x
  1308                                  ;   r9b - posición y
  1309                                  register_letter:        
  1310 00000490 55                          push rbp    ; Guardar el puntero de la base
  1311 00000491 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1312 00000494 53                          push rbx    ; Guardar registros
  1313 00000495 51                          push rcx    ; Guardar registros
  1314                                      
  1315 00000496 3C20                        cmp al, ' '   ; Verificar si es un espacio
  1316 00000498 7438                        je .end      ; Si es un espacio, salir
  1317                                  
  1318                                      ; Encontrar un espacio libre en el mapa
  1319 0000049A 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1320 0000049D 480FB615(CC220000)          movzx rdx, byte [letters_count] ; Cantidad de letras registradas
  1321                                      
  1322                                      .find_slot:
  1323 000004A5 4883F964                        cmp rcx, 100              ; Máximo de letras
  1324 000004A9 7D27                            jge .end                  ; Si no hay espacio, salir
  1325                                          
  1326 000004AB 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1327 000004B3 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
  1328 000004B7 7405                            je .found_slot
  1329                                          
  1330 000004B9 48FFC1                          inc rcx   ; Probar con la siguiente letra
  1331 000004BC EBE7                            jmp .find_slot  ; Continuar buscando
  1332                                          
  1333                                      .found_slot:
  1334                                          ; Guardar la información de la letra
  1335 000004BE 448803                          mov [rbx], r8b           ; x
  1336 000004C1 44884B01                        mov [rbx + 1], r9b       ; y
  1337 000004C5 884302                          mov [rbx + 2], al        ; letra
  1338 000004C8 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
  1339                                          
  1340 000004CC FE05(CC220000)                  inc byte [letters_count]
  1341                                          
  1342                                      .end:
  1343 000004D2 59                              pop rcx
  1344 000004D3 5B                              pop rbx
  1345 000004D4 5D                              pop rbp
  1346 000004D5 C3                              ret
  1347                                  
  1348                                  ; Función para imprimir todas las letras registradas
  1349                                  print_letters:
  1350 000004D6 55                          push rbp        ; Guardar el puntero de la base
  1351 000004D7 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1352 000004DA 53                          push rbx    ; Guardar registros
  1353 000004DB 51                          push rcx    ; Guardar registros
  1354                                      
  1355 000004DC 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1356                                      
  1357                                      .print_loop:
  1358 000004DF 4883F964                        cmp rcx, 100              ; Máximo de letras
  1359 000004E3 7D37                            jge .end              ; Si no hay más letras, salir
  1360                                          
  1361                                          ; Obtener puntero a la letra actual
  1362 000004E5 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]
  1363                                          
  1364                                          ; Verificar si está activa
  1365 000004ED 807B0300                        cmp byte [rbx + 3], 0
  1366 000004F1 7424                            je .next_letter
  1367                                          
  1368                                          ; Calcular posición en el tablero
  1369 000004F3 4C0FB603                        movzx r8, byte [rbx]      ; x
  1370 000004F7 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
  1371                                          
  1372                                          ; Calcular offset en el tablero
  1373 000004FC B850000000                      mov rax, column_cells
  1374 00000501 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
  1375 00000505 49F7E1                          mul r9
  1376 00000508 4C01C0                          add rax, r8
  1377 0000050B 488DB8[400A0000]                lea rdi, [board + rax]  ; Dirección en el tablero
  1378                                          
  1379                                          ; Imprimir la letra
  1380 00000512 8A4302                          mov al, [rbx + 2]   ; Obtener la letra
  1381 00000515 8807                            mov [rdi], al    ; Imprimir la letra
  1382                                          
  1383                                      .next_letter:
  1384 00000517 48FFC1                          inc rcx   ; Siguiente letra
  1385 0000051A EBC3                            jmp .print_loop ; Continuar imprimiendo
  1386                                          
  1387                                      .end:
  1388 0000051C 59                              pop rcx   ; Restaurar registros
  1389 0000051D 5B                              pop rbx  ; Restaurar registros
  1390 0000051E 5D                              pop rbp ; Restaurar el puntero de la base
  1391 0000051F C3                              ret   ; Retornar
  1392                                  
  1393                                  ; Función para borrar una letra específica
  1394                                  ; Entrada:
  1395                                  ;   r8b - posición x
  1396                                  ;   r9b - posición y
  1397                                  remove_letter:
  1398 00000520 55                          push rbp
  1399 00000521 4889E5                      mov rbp, rsp
  1400 00000524 53                          push rbx    ; Guardar registros
  1401 00000525 51                          push rcx    ; Guardar registros
  1402                                      
  1403 00000526 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1404                                      
  1405                                      .find_loop:     
  1406 00000529 4883F964                        cmp rcx, 100              ; Máximo de letras
  1407 0000052D 7D2E                            jge .end
  1408                                          
  1409 0000052F 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1410                                          
  1411                                          ; Verificar si está activa y coincide la posición
  1412 00000537 807B0300                        cmp byte [rbx + 3], 0
  1413 0000053B 741B                            je .next_letter   ; Si no está activa, probar con la siguiente letra
  1414                                          
  1415 0000053D 8A03                            mov al, [rbx]   ; x
  1416 0000053F 4438C0                          cmp al, r8b    ; Verificar si coincide la posición x
  1417 00000542 7514                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1418                                          
  1419 00000544 8A4301                          mov al, [rbx + 1]   ; y
  1420 00000547 4438C8                          cmp al, r9b   ; Verificar si coincide la posición y
  1421 0000054A 750C                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1422                                          
  1423                                          ; Encontrada la letra, desactivarla 
  1424 0000054C C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1425 00000550 FE0D(CC220000)                  dec byte [letters_count]        ; Decrementar contador de letras
  1426 00000556 EB05                            jmp .end
  1427                                          
  1428                                      .next_letter:
  1429 00000558 48FFC1                          inc rcx  ; Siguiente letra
  1430 0000055B EBCC                            jmp .find_loop  ; Continuar buscando
  1431                                          
  1432                                      .end:
  1433 0000055D 59                              pop rcx
  1434 0000055E 5B                              pop rbx
  1435 0000055F 5D                              pop rbp
  1436 00000560 C3                              ret
  1437                                  ; Función para mover las letras hacia abajo
  1438                                  move_letters:
  1439 00000561 55                          push rbp    ; Guardar el puntero de la base
  1440 00000562 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1441 00000565 53                          push rbx    ; Guardar registros
  1442 00000566 57                          push rdi    ; Guardar registros
  1443 00000567 56                          push rsi    ; Guardar registros
  1444 00000568 4150                        push r8    ; Guardar registros
  1445 0000056A 4151                        push r9   ; Guardar registros
  1446 0000056C 4152                        push r10    ; Guardar registros
  1447 0000056E 4153                        push r11    ; Guardar registros
  1448                                  
  1449 00000570 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1450                                  
  1451                                      ; Verificar si debemos mover la letra en este frame
  1452 00000573 FE05(5E240000)              inc byte [letter_move_counter]    ; Incrementar contador
  1453 00000579 803D(5E240000)0B            cmp byte [letter_move_counter], 11 ; Ajusta este número para cambiar velocidad
  1454 00000580 0F8C20020000                jl .skip_all                         ; Si no es momento de mover, terminar
  1455 00000586 C605(5E240000)00            mov byte [letter_move_counter], 0 ; Resetear contador
  1456                                  
  1457                                      .move_loop:
  1458 0000058D 4883F964                        cmp rcx, 100          ; Máximo de letras, se hace esta verificacion porque se pueden borrar letras
  1459 00000591 0F8D0D020000                    jge .print_last_letter  ; Si no hay más letras, imprimir la última letra
  1460                                          
  1461 00000597 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1462 0000059F 807B0300                        cmp byte [rbx + 3], 0   ; Verificar si está activa
  1463 000005A3 0F84F3010000                    je .next_letter       ; Si no está activa, probar con la siguiente letra
  1464                                  
  1465 000005A9 4C0FB603                        movzx r8, byte [rbx]    ; x
  1466 000005AD 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1467                                  
  1468 000005B2 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1469 000005B7 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1470 000005BB 49F7E1                          mul r9  ; Multiplicar por Y
  1471 000005BE 4C01C0                          add rax, r8 ; Sumar X
  1472 000005C1 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1473 000005C8 C60720                          mov byte [rdi], ' ' ; Borrar visualmente la letra
  1474                                  
  1475 000005CB FE4301                          inc byte [rbx + 1]  ; Mover la letra hacia abajo
  1476 000005CE 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1477                                  
  1478 000005D3 4983F91F                        cmp r9, row_cells - 1   ; Verificar si ha llegado al borde inferior
  1479 000005D7 7C09                            jl .check_pallet_collision  ; Si no ha llegado al borde, verificar colisión con la paleta
  1480                                  
  1481 000005D9 C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1482 000005DD E9BA010000                      jmp .next_letter    ; Probar con la siguiente letra
  1483                                  
  1484                                          .check_pallet_collision:    ; Verificar colisión con la paleta
  1485 000005E2 B850000000                          mov rax, column_cells   ; Ancho del tablero
  1486 000005E7 4883C002                            add rax, 2  ; Incluir caracteres de nueva línea
  1487 000005EB 49F7E1                              mul r9  ; Multiplicar por Y
  1488 000005EE 4C01C0                              add rax, r8 ; Sumar X
  1489 000005F1 488DB8[400A0000]                    lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1490                                  
  1491 000005F8 8A07                                mov al, [rdi]   ; Obtener el carácter actual
  1492 000005FA 3C20                                cmp al, ' '  ; Verificar si es un espacio
  1493 000005FC 0F849A010000                        je .next_letter ; Si es un espacio, probar con la siguiente letra
  1494 00000602 3C3D                                cmp al, char_equal  ; Verificar si es la paleta
  1495 00000604 740A                                je .capture_letter  ; Si es la paleta, capturar la letra
  1496                                  
  1497 00000606 8A4302                              mov al, [rbx + 2]   ; Obtener la letra
  1498 00000609 8807                                mov [rdi], al   ; Imprimir la letra
  1499 0000060B E98C010000                          jmp .next_letter    ; Probar con la siguiente letra
  1500                                  
  1501                                          .capture_letter:    ; Capturar la letra
  1502                                              ; Obtener la nueva letra
  1503 00000610 8A4302                              mov al, [rbx + 2]
  1504                                              
  1505                                              ; Comparar con la última letra
  1506 00000613 3A05(CD220000)                      cmp al, [last_letter]
  1507 00000619 7407                                je .same_letter
  1508                                              
  1509                                              ; Es una letra diferente, resetear el procesamiento
  1510 0000061B C605(E1220000)00                    mov byte [current_power_processed], 0
  1511                                              
  1512                                              .same_letter:
  1513                                              ; Guardar la nueva letra
  1514 00000622 8805(CD220000)                      mov [last_letter], al
  1515                                              
  1516                                              ; Verificar si es 'E' para extender la paleta
  1517 00000628 3C45                                cmp al, 'E'
  1518 0000062A 7450                                je .extend_pallet
  1519                                              
  1520                                              ; Verificar si es 'P' para añadir vida
  1521 0000062C 3C50                                cmp al, 'P'
  1522 0000062E 7478                                je .check_add_life
  1523                                  
  1524 00000630 3C53                                cmp al, 'S'
  1525 00000632 0F84B4000000                        je .slow_ball
  1526                                  
  1527 00000638 3C43                                cmp al, 'C'
  1528 0000063A 0F84D8000000                        je .activate_catch
  1529                                              
  1530 00000640 3C4C                                cmp al, 'L'
  1531 00000642 0F84F9000000                        je .activate_laser
  1532                                  
  1533 00000648 3C44                                cmp al, 'D'
  1534 0000064A 0F841A010000                        je .activate_split
  1535                                  
  1536                                              ; Si no es ningún power-up, restaurar tamaño normal
  1537 00000650 488B05(CF140000)                    mov rax, [default_pallet_size]
  1538 00000657 488905(C7140000)                    mov [pallet_size], rax
  1539 0000065E 48C705(E3220000)07-                 mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1539 00000666 000000             
  1540 00000669 C605(FC220000)00                    mov byte [catch_power_active], 0
  1541 00000670 C605(09230000)00                    mov byte [laser_power_active], 0
  1542 00000677 E91C010000                          jmp .finish_capture
  1543                                  
  1544                                              .extend_pallet:
  1545 0000067C C605(09230000)00                        mov byte [laser_power_active], 0
  1546 00000683 C605(FC220000)00                        mov byte [catch_power_active], 0
  1547 0000068A 48C705(E3220000)07-                     mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1547 00000692 000000             
  1548 00000695 488B05(D7140000)                        mov rax, [extended_pallet_size]
  1549 0000069C 488905(C7140000)                        mov [pallet_size], rax
  1550 000006A3 E9F0000000                              jmp .finish_capture
  1551                                  
  1552                                              .check_add_life:
  1553 000006A8 C605(09230000)00                        mov byte [laser_power_active], 0
  1554 000006AF C605(FC220000)00                        mov byte [catch_power_active], 0
  1555 000006B6 488B05(CF140000)                        mov rax, [default_pallet_size]
  1556 000006BD 488905(C7140000)                        mov [pallet_size], rax
  1557 000006C4 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1557 000006CC 000000             
  1558                                                  ; Verificar si ya procesamos este power-up
  1559 000006CF 803D(E1220000)00                        cmp byte [current_power_processed], 0
  1560 000006D6 0F85BC000000                            jne .finish_capture
  1561                                                  
  1562                                                  ; Preservar registros importantes
  1563 000006DC 51                                      push rcx
  1564 000006DD 53                                      push rbx
  1565                                                  
  1566                                                  ; Marcar como procesado
  1567 000006DE C605(E1220000)01                        mov byte [current_power_processed], 1
  1568                                                  
  1569                                                  ; Añadir una vida
  1570 000006E5 E8A8040000                              call add_life
  1571                                                  
  1572                                                  ; Restaurar registros
  1573 000006EA 5B                                      pop rbx
  1574 000006EB 59                                      pop rcx
  1575                                                  
  1576                                              .slow_ball:
  1577 000006EC C605(09230000)00                        mov byte [laser_power_active], 0
  1578 000006F3 C605(FC220000)00                        mov byte [catch_power_active], 0                
  1579 000006FA 488B05(CF140000)                        mov rax, [default_pallet_size]
  1580 00000701 488905(C7140000)                        mov [pallet_size], rax
  1581 00000708 48C705(E3220000)0A-                     mov qword [ball_speed], 10    ; Activar velocidad lenta
  1581 00000710 000000             
  1582 00000713 E980000000                              jmp .finish_capture
  1583                                  
  1584                                              .activate_catch:
  1585 00000718 C605(09230000)00                        mov byte [laser_power_active], 0
  1586 0000071F 488B05(CF140000)                        mov rax, [default_pallet_size]
  1587 00000726 488905(C7140000)                        mov [pallet_size], rax
  1588 0000072D 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1588 00000735 000000             
  1589 00000738 C605(FC220000)01                        mov byte [catch_power_active], 1
  1590 0000073F EB57                                    jmp .finish_capture
  1591                                  
  1592                                              .activate_laser:
  1593 00000741 C605(FC220000)00                        mov byte [catch_power_active], 0
  1594 00000748 488B05(CF140000)                        mov rax, [default_pallet_size]
  1595 0000074F 488905(C7140000)                        mov [pallet_size], rax
  1596 00000756 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1596 0000075E 000000             
  1597 00000761 C605(09230000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1598 00000768 EB2E                                    jmp .finish_capture
  1599                                  
  1600                                              .activate_split:
  1601 0000076A C605(09230000)00                        mov byte [laser_power_active], 0
  1602 00000771 C605(FC220000)00                        mov byte [catch_power_active], 0
  1603 00000778 488B05(CF140000)                        mov rax, [default_pallet_size]
  1604 0000077F 488905(C7140000)                        mov [pallet_size], rax
  1605 00000786 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1605 0000078E 000000             
  1606 00000791 E8DF000000                              call activate_split_power
  1607 00000796 EB00                                    jmp .finish_capture
  1608                                  
  1609                                              .finish_capture:
  1610 00000798 C6430300                                mov byte [rbx + 3], 0
  1611                                  
  1612                                          .next_letter:
  1613 0000079C 48FFC1                              inc rcx
  1614 0000079F E9E9FDFFFF                          jmp .move_loop
  1615                                  
  1616                                      .print_last_letter:
  1617                                          ; ;; en vez de imprimir, saltamos
  1618 000007A4 EB0D                            jmp .end
  1619                                  
  1620                                  
  1621                                      .skip_all:                        ; Nueva etiqueta para saltar todo cuando no movemos
  1622 000007A6 415B                            pop r11                       ; Restaurar registros
  1623 000007A8 415A                            pop r10                      ; Restaurar registros
  1624 000007AA 4159                            pop r9
  1625 000007AC 4158                            pop r8
  1626 000007AE 5E                              pop rsi
  1627 000007AF 5F                              pop rdi
  1628 000007B0 5B                              pop rbx
  1629 000007B1 5D                              pop rbp
  1630 000007B2 C3                              ret
  1631                                  
  1632                                      .end:
  1633 000007B3 415B                            pop r11
  1634 000007B5 415A                            pop r10
  1635 000007B7 4159                            pop r9
  1636 000007B9 4158                            pop r8
  1637 000007BB 5E                              pop rsi
  1638 000007BC 5F                              pop rdi
  1639 000007BD 5B                              pop rbx
  1640 000007BE 5D                              pop rbp
  1641 000007BF C3                              ret
  1642                                  
  1643                                  print_power_label:  ; Función para imprimir el mensaje de poder actual
  1644 000007C0 55                          push rbp
  1645 000007C1 4889E5                      mov  rbp, rsp
  1646                                      
  1647                                      ; Crear buffer temporal
  1648 000007C4 4883EC20                    sub rsp, 32
  1649                                      
  1650                                      ; Copiar el mensaje base al buffer
  1651 000007C8 4889E7                      mov rdi, rsp
  1652 000007CB 48BE-                       mov rsi, last_letter_msg
  1652 000007CD [CE22000000000000] 
  1653 000007D5 B913000000                  mov rcx, last_letter_msg_len
  1654 000007DA F3A4                        rep movsb
  1655                                      
  1656                                      ; Insertar la última letra capturada
  1657 000007DC 8A05(CD220000)              mov al, [last_letter]
  1658 000007E2 8844240F                    mov byte [rsp + 15], al    ; Asumiendo que 15 es la posición correcta
  1659                                      
  1660                                      ; Imprimir el buffer completo
  1661                                      print rsp, last_letter_msg_len
    93 000007E6 B801000000          <1>  mov eax, sys_write
    94 000007EB BF01000000          <1>  mov edi, 1
    95 000007F0 4889E6              <1>  mov rsi, %1
    96 000007F3 BA13000000          <1>  mov edx, %2
    97 000007F8 0F05                <1>  syscall
  1662                                      
  1663                                      ; Restaurar stack
  1664 000007FA 4883C420                    add rsp, 32
  1665 000007FE 5D                          pop rbp
  1666 000007FF C3                          ret
  1667                                  
  1668                                  clear_lasers:
  1669 00000800 55                          push rbp
  1670 00000801 4889E5                      mov  rbp, rsp
  1671                                  
  1672                                      ; Recorrer el array de láseres
  1673 00000804 4831C9                      xor rcx, rcx                ; Índice del láser
  1674 00000807 480FB61D(0B230000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1675                                  
  1676                                      .clear_loop:
  1677 0000080F 4839D9                          cmp rcx, rbx
  1678 00000812 7D2F                            jge .done                ; Salir si no quedan láseres
  1679                                  
  1680                                          ; Obtener posición del láser actual
  1681 00000814 488DB409[0C230000]              lea rsi, [lasers + rcx * 2]
  1682 0000081C 4C0FB606                        movzx r8, byte [rsi]     ; X
  1683 00000820 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1684                                  
  1685                                          ; Calcular posición en el tablero
  1686 00000825 B850000000                      mov rax, column_cells
  1687 0000082A 4883C002                        add rax, 2
  1688 0000082E 49F7E1                          mul r9
  1689 00000831 4C01C0                          add rax, r8
  1690 00000834 488DB8[400A0000]                lea rdi, [board + rax]
  1691                                  
  1692                                          ; Borrar el láser visualmente
  1693 0000083B C60720                          mov byte [rdi], ' '
  1694                                  
  1695                                          ; Pasar al siguiente láser
  1696 0000083E 48FFC1                          inc rcx
  1697 00000841 EBCC                            jmp .clear_loop
  1698                                  
  1699                                      .done:
  1700                                          ; Resetear contador de láseres
  1701 00000843 C605(0B230000)00                mov byte [laser_count], 0
  1702                                  
  1703 0000084A 5D                              pop rbp
  1704 0000084B C3                              ret
  1705                                  
  1706                                  
  1707                                  ; Nueva función para actualizar los láseres
  1708                                  update_lasers:
  1709 0000084C 55                          push rbp
  1710 0000084D 4889E5                      mov rbp, rsp
  1711                                      
  1712                                      ; Verificar si el poder láser está activo
  1713 00000850 803D(09230000)00            cmp byte [laser_power_active], 0
  1714 00000857 741A                        je .end
  1715                                      
  1716                                      ; Verificar si se presionó la tecla de espacio
  1717 00000859 803D(08230000)20            cmp byte [last_key], ' '
  1718 00000860 750C                        jne .skip_shooting
  1719                                      
  1720                                      ; Disparar nuevos láseres
  1721 00000862 E8FD000000                  call shoot_lasers
  1722 00000867 C605(08230000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1723                                      
  1724                                      .skip_shooting:
  1725                                      ; Mover los láseres existentes
  1726 0000086E E88B010000                  call move_lasers
  1727                                      
  1728                                      .end:
  1729 00000873 5D                              pop rbp
  1730 00000874 C3                              ret
  1731                                  
  1732                                  activate_split_power:; Función para activar el poder de división de bolas
  1733 00000875 55                          push rbp    ; Guardar el puntero de la base
  1734 00000876 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1735 00000879 50                          push rax    ; Guardar registros
  1736 0000087A 53                          push rbx    
  1737 0000087B 51                          push rcx
  1738 0000087C 52                          push rdx
  1739                                      
  1740                                      ; Si ambas bolas extra ya están activas, salimos
  1741 0000087D 8A0D(22150000)              mov cl, byte [ball2_active]
  1742 00000883 220D(44150000)              and cl, byte [ball3_active]
  1743 00000889 80F901                      cmp cl, 1   ; Verificar si ambas bolas están activas
  1744 0000088C 0F84CC000000                je .end   ; Si ambas bolas están activas, salir
  1745                                      
  1746                                  .find_active_ball:
  1747                                      ; Guardar posición de la bola activa
  1748 00000892 4831C0                      xor rax, rax    ; Limpiar rax
  1749 00000895 4831DB                      xor rbx, rbx    ; Limpiar rbx
  1750                                      
  1751                                      ; Revisar ball1
  1752 00000898 803D(00150000)01            cmp byte [ball_active], 1
  1753 0000089F 7417                        je .use_ball1
  1754                                      
  1755                                      ; Revisar ball2
  1756 000008A1 803D(22150000)01            cmp byte [ball2_active], 1
  1757 000008A8 741E                        je .use_ball2
  1758                                      
  1759                                      ; Revisar ball3
  1760 000008AA 803D(44150000)01            cmp byte [ball3_active], 1
  1761 000008B1 7425                        je .use_ball3
  1762                                      
  1763 000008B3 E9A6000000                  jmp .end        ; Si no hay bolas activas, salimos
  1764                                  
  1765                                  .use_ball1:
  1766 000008B8 488B05(DF140000)            mov rax, qword [ball_x_pos]; Cargar posición de la bola principal
  1767 000008BF 488B1D(E7140000)            mov rbx, qword [ball_y_pos]     ; Cargar posición de la bola principal
  1768 000008C6 EB20                        jmp .create_missing_balls
  1769                                  
  1770                                  .use_ball2:
  1771 000008C8 488B05(01150000)            mov rax, qword [ball2_x_pos]    ; Cargar posición de la bola 2
  1772 000008CF 488B1D(09150000)            mov rbx, qword [ball2_y_pos]    ; Cargar posición de la bola 2
  1773 000008D6 EB10                        jmp .create_missing_balls
  1774                                  
  1775                                  .use_ball3:
  1776 000008D8 488B05(23150000)            mov rax, qword [ball3_x_pos]    ; Cargar posición de la bola 3
  1777 000008DF 488B1D(2B150000)            mov rbx, qword [ball3_y_pos]    ; Cargar posición de la bola 3
  1778 000008E6 EB00                        jmp .create_missing_balls
  1779                                  
  1780                                  .create_missing_balls:
  1781                                      ; Intentar crear ball2 si no está activa    
  1782 000008E8 803D(22150000)01            cmp byte [ball2_active], 1
  1783 000008EF 7432                        je .create_ball3    ; Si ball2 ya está activa, intentar crear ball3
  1784                                      
  1785                                      ; Crear ball2
  1786 000008F1 488905(01150000)            mov qword [ball2_x_pos], rax    ; Copiar posición de la bola activa
  1787 000008F8 48891D(09150000)            mov qword [ball2_y_pos], rbx    ; Copiar posición de la bola activa
  1788 000008FF 48C705(11150000)FF-         mov qword [ball2_direction_x], -1   ; Dirección opuesta
  1788 00000907 FFFFFF             
  1789 0000090A 48C705(19150000)FF-         mov qword [ball2_direction_y], -1   ; Dirección opuesta
  1789 00000912 FFFFFF             
  1790 00000915 C605(21150000)01            mov byte [ball2_moving], 1  ; Activar movimiento
  1791 0000091C C605(22150000)01            mov byte [ball2_active], 1  ; Activar bola2
  1792                                      
  1793                                  .create_ball3:
  1794                                      ; Intentar crear ball3 si no está activa
  1795 00000923 803D(44150000)01            cmp byte [ball3_active], 1
  1796 0000092A 7432                        je .end
  1797                                      
  1798                                      ; Crear ball3
  1799 0000092C 488905(23150000)            mov qword [ball3_x_pos], rax    ; Copiar posición de la bola activa
  1800 00000933 48891D(2B150000)            mov qword [ball3_y_pos], rbx    ; Copiar posición de la bola activa
  1801 0000093A 48C705(33150000)01-         mov qword [ball3_direction_x], 1    ; Dirección opuesta
  1801 00000942 000000             
  1802 00000945 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1       ; Dirección opuesta
  1802 0000094D FFFFFF             
  1803 00000950 C605(43150000)01            mov byte [ball3_moving], 1
  1804 00000957 C605(44150000)01            mov byte [ball3_active], 1  
  1805                                  
  1806                                  .end:
  1807 0000095E 5A                          pop rdx   ; Restaurar registros
  1808 0000095F 59                          pop rcx
  1809 00000960 5B                          pop rbx
  1810 00000961 58                          pop rax
  1811 00000962 5D                          pop rbp
  1812 00000963 C3                          ret
  1813                                  
  1814                                  
  1815                                  shoot_lasers:   ; Función para disparar láseres
  1816 00000964 55                          push rbp    ; Guardar el puntero de la base
  1817 00000965 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1818 00000968 53                          push rbx
  1819                                      
  1820                                      ; Verificar si hay espacio para más láseres
  1821 00000969 480FB605(0B230000)          movzx rax, byte [laser_count]
  1822 00000971 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1823 00000975 0F8D80000000                jge .end
  1824                                      
  1825                                      ; Obtener posición de la paleta
  1826 0000097B 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición de la paleta
  1827 00000982 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1828                                      
  1829                                      ; Calcular coordenadas x,y
  1830 00000989 4C89C0                      mov rax, r8                 ; Posición de la paleta
  1831 0000098C 41B950000000                mov r9, column_cells    ; Ancho del tablero
  1832 00000992 4983C102                    add r9, 2                     ; Ancho total de línea
  1833 00000996 4831D2                      xor rdx, rdx             ; Limpiar rdx
  1834 00000999 49F7F1                      div r9                        ; rax = y, rdx = x
  1835                                      
  1836                                      ; Guardar coordenadas
  1837 0000099C 4989C2                      mov r10, rax                  ; Y en r10
  1838 0000099F 4989D3                      mov r11, rdx                  ; X en r11
  1839                                      
  1840                                      ; Validar coordenadas
  1841 000009A2 4983FA00                    cmp r10, 0  ; Verificar si está en la primera fila
  1842 000009A6 7C53                        jl .end   ; Si está en la primera fila, salir
  1843 000009A8 4983FA20                    cmp r10, row_cells  ; Verificar si está en la última fila
  1844 000009AC 7D4D                        jge .end    ; Si está en la última fila, salir
  1845 000009AE 4983FB00                    cmp r11, 0  ; Verificar si está en la primera columna
  1846 000009B2 7C47                        jl .end  ; Si está en la primera columna, salir
  1847 000009B4 4983FB50                    cmp r11, column_cells   ; Verificar si está en la última columna
  1848 000009B8 7D41                        jge .end    ; Si está en la última columna, salir
  1849                                      
  1850                                      ; Calcular índice para el primer láser
  1851 000009BA 480FB61D(0B230000)          movzx rbx, byte [laser_count]
  1852 000009C2 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1853                                      
  1854                                      ; Primer láser (izquierda)
  1855 000009C6 488DBB[0C230000]            lea rdi, [lasers + rbx]   ; Dirección del láser
  1856 000009CD 44881F                      mov [rdi], r11b              ; X
  1857 000009D0 4488D0                      mov al, r10b              ; Y - 1
  1858 000009D3 FEC8                        dec al                       ; Y - 1
  1859 000009D5 884701                      mov [rdi + 1], al           ; Y
  1860                                      
  1861                                      ; Segundo láser (derecha)
  1862 000009D8 4488D8                      mov al, r11b
  1863 000009DB 0205(C7140000)              add al, byte [pallet_size]  ; X + tamaño de la paleta
  1864 000009E1 FEC8                        dec al                       ; Ajustar para el último carácter
  1865 000009E3 488DBB[0E230000]            lea rdi, [lasers + rbx + 2]
  1866 000009EA 8807                        mov [rdi], al               ; X
  1867 000009EC 4488D0                      mov al, r10b
  1868 000009EF FEC8                        dec al                      ; Y - 1
  1869 000009F1 884701                      mov [rdi + 1], al          ; Y
  1870                                      
  1871                                      ; Incrementar contador de láseres
  1872 000009F4 8005(0B230000)02            add byte [laser_count], 2
  1873                                      
  1874                                      
  1875                                      .end:
  1876 000009FB 5B                              pop rbx
  1877 000009FC 5D                              pop rbp
  1878 000009FD C3                              ret
  1879                                  
  1880                                  ; ============================================================
  1881                                  ; NUEVA FUNCIÓN move_lasers 
  1882                                  ; ============================================================
  1883                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1884                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1885                                  ; ============================================================
  1886                                  move_lasers:
  1887 000009FE 55                          push rbp
  1888 000009FF 4889E5                      mov  rbp, rsp
  1889 00000A02 53                          push rbx
  1890 00000A03 57                          push rdi
  1891 00000A04 56                          push rsi
  1892 00000A05 4154                        push r12
  1893 00000A07 4155                        push r13
  1894 00000A09 4156                        push r14
  1895 00000A0B 4157                        push r15
  1896                                  
  1897                                      ; 1) Tomamos la cantidad de láseres
  1898 00000A0D 480FB60D(0B230000)          movzx rcx, byte [laser_count]
  1899 00000A15 4885C9                      test rcx, rcx
  1900 00000A18 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1901                                  
  1902                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1903 00000A1E 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1904                                  
  1905                                  .loop_lasers:
  1906                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1907 00000A21 488DB409[0C230000]          lea rsi, [lasers + rcx*2]
  1908                                  
  1909                                      ; 2) Cargar x,y actuales del láser
  1910 00000A29 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1911 00000A2D 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1912                                  
  1913                                      ; 3) Borrar el láser de su posición actual en pantalla
  1914                                      ;    (por si en el ciclo anterior se había dibujado)
  1915 00000A32 B850000000                  mov rax, column_cells
  1916 00000A37 4883C002                    add rax, 2
  1917 00000A3B 49F7E1                      mul r9
  1918 00000A3E 4C01C0                      add rax, r8
  1919 00000A41 488DB8[400A0000]            lea rdi, [board + rax]
  1920 00000A48 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1921                                  
  1922                                      ; 4) Mover el láser hacia arriba (y - 1)
  1923 00000A4B 49FFC9                      dec r9
  1924                                  
  1925                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1926 00000A4E 4983F901                    cmp r9, 1
  1927 00000A52 7C57                        jl .delete_laser
  1928                                  
  1929                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1930 00000A54 44884E01                    mov byte [rsi + 1], r9b
  1931                                  
  1932                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1933                                      ;    - Primero colisión con bloques
  1934                                      ; ---------------------------------------------------------
  1935                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1936 00000A58 B850000000                  mov rax, column_cells
  1937 00000A5D 4883C002                    add rax, 2
  1938 00000A61 49F7E1                      mul r9
  1939 00000A64 4C01C0                      add rax, r8
  1940 00000A67 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1941                                  
  1942                                      ; Revisar si hay bloque
  1943 00000A6E 51                          push rcx
  1944 00000A6F 56                          push rsi
  1945 00000A70 57                          push rdi
  1946 00000A71 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1947 00000A74 E877100000                  call check_block_collision
  1948 00000A79 5F                          pop rdi
  1949 00000A7A 5E                          pop rsi
  1950 00000A7B 59                          pop rcx
  1951                                  
  1952 00000A7C 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1953 00000A7F 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1954                                  
  1955                                      ;    - Luego colisión con enemigos
  1956                                      ; ---------------------------------------------------------
  1957 00000A81 51                          push rcx
  1958 00000A82 56                          push rsi
  1959 00000A83 57                          push rdi
  1960                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1961                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1962                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1963                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1964                                      ;
  1965                                      ; Hacemos algo como:
  1966 00000A84 4989FA                      mov r10, rdi
  1967 00000A87 E85A000000                  call check_laser_enemy_collision
  1968 00000A8C 5F                          pop rdi
  1969 00000A8D 5E                          pop rsi
  1970 00000A8E 59                          pop rcx
  1971                                  
  1972 00000A8F 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1973 00000A92 7517                        jnz .delete_laser
  1974                                  
  1975                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1976 00000A94 8A05(0A230000)              mov al, [laser_symbol]
  1977 00000A9A 8807                        mov [rdi], al
  1978                                  
  1979                                  .next_laser:
  1980                                      ; Pasamos al láser anterior en el array
  1981 00000A9C 48FFC9                      dec rcx
  1982 00000A9F 4883F9FF                    cmp rcx, -1
  1983 00000AA3 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1984 00000AA9 EB2E                        jmp .fin
  1985                                  
  1986                                  ; -----------------------------------------------------------------
  1987                                  ; Subrutina interna: .delete_laser
  1988                                  ; -----------------------------------------------------------------
  1989                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1990                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1991                                  .delete_laser:
  1992 00000AAB 4C0FB625(0B230000)          movzx r12, byte [laser_count]
  1993 00000AB3 49FFCC                      dec r12                    ; r12 = índice del último láser
  1994 00000AB6 4939CC                      cmp r12, rcx
  1995 00000AB9 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1996                                  
  1997                                      ; Copiamos el último láser a la posición actual
  1998 00000ABB 488DBC09[0C230000]          lea rdi, [lasers + rcx*2]
  1999 00000AC3 4B8DB424[0C230000]          lea rsi, [lasers + r12*2]
  2000 00000ACB 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  2001 00000ACE 668907                      mov [rdi], ax             ; copiamos X,Y
  2002                                  
  2003                                  .just_decrement:
  2004 00000AD1 FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2005 00000AD7 EBC3                        jmp .next_laser
  2006                                  
  2007                                  .fin:
  2008 00000AD9 415F                        pop r15
  2009 00000ADB 415E                        pop r14
  2010 00000ADD 415D                        pop r13
  2011 00000ADF 415C                        pop r12
  2012 00000AE1 5E                          pop rsi
  2013 00000AE2 5F                          pop rdi
  2014 00000AE3 5B                          pop rbx
  2015 00000AE4 5D                          pop rbp
  2016 00000AE5 C3                          ret
  2017                                  
  2018                                  
  2019                                  ; Nueva función para verificar colisión entre láser y enemigos
  2020                                  ; ==========================================================
  2021                                  ; NUEVA check_laser_enemy_collision
  2022                                  ; ==========================================================
  2023                                  check_laser_enemy_collision:    ; Función para verificar colisión entre láser y enemigos
  2024 00000AE6 55                          push rbp        
  2025 00000AE7 4889E5                      mov  rbp, rsp
  2026                                      
  2027 00000AEA 4D31ED                      xor r13, r13            ; Índice del enemigo
  2028 00000AED 4831C0                      xor rax, rax            ; 0 = no colisión
  2029                                  
  2030                                  .loop_enemies:      ; Iterar sobre los enemigos
  2031 00000AF0 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  2032 00000AF4 7D64                        jge .end            ; Si no hay más enemigos, salir
  2033                                  
  2034                                      ; r13 * 3 => offset del enemigo i
  2035 00000AF6 4C89E9                      mov rcx, r13        ; r13 = i
  2036 00000AF9 486BC903                    imul rcx, 3        ; rcx = i * 3
  2037 00000AFD 488DB1[60200000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  2038                                  
  2039                                      ; Verificar si está activo
  2040 00000B04 807E0201                    cmp byte [rsi+2], 1 
  2041 00000B08 754B                        jne .next_enemy       ; Si no está activo, probar con el siguiente enemigo
  2042                                  
  2043                                      ; Cargar posición X/Y del enemigo
  2044 00000B0A 4C0FB636                    movzx r14, byte [rsi]      ; X
  2045 00000B0E 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  2046                                  
  2047                                      ; Comparar con posición del láser (r8=X, r9=Y)
  2048 00000B13 4D39F0                      cmp r8, r14
  2049 00000B16 753D                        jne .next_enemy        ; Si no coincide X, probar con el siguiente enemigo
  2050 00000B18 4D39F9                      cmp r9, r15
  2051 00000B1B 7538                        jne .next_enemy     ; Si no coincide Y, probar con el siguiente enemigo
  2052                                  
  2053                                      ; ==== Colisión detectada con láser ====
  2054                                  
  2055                                      ; 1) Desactivar enemigo
  2056 00000B1D C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  2057                                  
  2058                                      ; 2) Sumar puntos
  2059 00000B21 488B05(7F200000)            mov rax, [enemy_points]  ; Puntos por enemigo
  2060 00000B28 480105(3E200000)            add [current_score], rax
  2061                                  
  2062                                      ; 3) Borrar del board, SOLO si no coincide con la paleta
  2063                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  2064 00000B2F 4983FF1E                    cmp r15, row_cells - 2
  2065 00000B33 7419                        je .skip_erase
  2066                                  
  2067                                      ; Borrar visualmente del board
  2068 00000B35 B850000000                  mov rax, column_cells   ; Ancho del tablero
  2069 00000B3A 4883C002                    add rax, 2            ; Incluir caracteres de nueva línea
  2070 00000B3E 49F7E7                      mul r15              ; Multiplicar por Y
  2071 00000B41 4C01F0                      add rax, r14     ; Sumar X
  2072 00000B44 488DB8[400A0000]            lea rdi, [board + rax]      ; Dirección en el tablero
  2073 00000B4B C60720                      mov byte [rdi], ' '       ; Borrar enemigo visualmente
  2074                                  
  2075                                  .skip_erase:
  2076                                  
  2077                                      ; 4) Devolver rax=1 => colisión con enemigo
  2078 00000B4E B801000000                  mov rax, 1  
  2079 00000B53 EB05                        jmp .end
  2080                                  
  2081                                  .next_enemy:    ; Pasar al siguiente enemigo
  2082 00000B55 49FFC5                      inc r13       ; Siguiente enemigo
  2083 00000B58 EB96                        jmp .loop_enemies   ; Iterar
  2084                                  
  2085                                  .end:
  2086 00000B5A 5D                          pop rbp
  2087 00000B5B C3                          ret
  2088                                  
  2089                                  
  2090                                  ; Función auxiliar para eliminar un láser específico
  2091                                  remove_laser:
  2092 00000B5C 55                          push rbp    
  2093 00000B5D 4889E5                      mov rbp, rsp
  2094                                  
  2095                                      ; Borrar el láser del tablero
  2096 00000B60 41C60220                    mov byte [r10], ' '
  2097                                  
  2098                                      ; Mover el último láser a esta posición si no es el último
  2099 00000B64 480FB605(0B230000)          movzx rax, byte [laser_count]
  2100 00000B6C 48FFC8                      dec rax                    ; Índice del último láser
  2101 00000B6F 4939C4                      cmp r12, rax              ; Comparar con láser actual
  2102 00000B72 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  2103                                  
  2104                                      ; Copiar último láser a la posición actual
  2105 00000B74 4B8DBC24[0C230000]          lea rdi, [lasers + r12*2]   ; Dirección del último láser
  2106 00000B7C 488DB400[0C230000]          lea rsi, [lasers + rax*2]   ; Dirección del láser actual
  2107 00000B84 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  2108 00000B87 668917                      mov [rdi], dx
  2109                                  
  2110                                  .just_decrease:
  2111 00000B8A FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2112                                  
  2113 00000B90 5D                          pop rbp
  2114 00000B91 C3                          ret
  2115                                  
  2116                                  add_life:   ; Función para añadir una vida
  2117 00000B92 55                          push rbp
  2118 00000B93 4889E5                      mov rbp, rsp    
  2119 00000B96 53                          push rbx
  2120 00000B97 51                          push rcx
  2121 00000B98 57                          push rdi
  2122 00000B99 56                          push rsi
  2123 00000B9A 4150                        push r8
  2124 00000B9C 4151                        push r9
  2125                                      
  2126                                      ; Verificar si ya tenemos el máximo de vidas
  2127 00000B9E 480FB605(3B210000)          movzx rax, byte [current_lives]
  2128 00000BA6 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  2129 00000BAA 7D2C                        jge .end
  2130                                      
  2131                                      ; Incrementar el contador de vidas
  2132 00000BAC FE05(3B210000)              inc byte [current_lives]
  2133                                      
  2134                                      ; Encontrar la siguiente vida inactiva
  2135 00000BB2 4831C9                      xor rcx, rcx
  2136                                      
  2137                                      .find_inactive:     
  2138 00000BB5 4883F907                        cmp rcx, lives_count    ; Verificar si llegamos al final
  2139 00000BB9 7D1D                            jge .end    
  2140                                          
  2141                                          ; Calcular offset de la vida actual
  2142 00000BBB 4889C8                          mov rax, rcx    ; Índice de la vida
  2143 00000BBE 486BC003                        imul rax, 3    ; Cada vida usa 3 bytes
  2144 00000BC2 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Dirección de la vida actual
  2145                                          
  2146                                          ; Verificar si está inactiva
  2147 00000BC9 807E0200                        cmp byte [rsi + 2], 0
  2148 00000BCD 7405                            je .activate_life   ; Si está inactiva, activarla
  2149                                          
  2150 00000BCF 48FFC1                          inc rcx   ; Probar con la siguiente vida
  2151 00000BD2 EBE1                            jmp .find_inactive  ; Continuar buscando
  2152                                          
  2153                                      .activate_life:
  2154                                          ; Activar la vida
  2155 00000BD4 C6460201                        mov byte [rsi + 2], 1
  2156                                          
  2157                                      .end:
  2158 00000BD8 4159                            pop r9
  2159 00000BDA 4158                            pop r8
  2160 00000BDC 5E                              pop rsi
  2161 00000BDD 5F                              pop rdi
  2162 00000BDE 59                              pop rcx
  2163 00000BDF 5B                              pop rbx
  2164 00000BE0 5D                              pop rbp
  2165 00000BE1 C3                              ret
  2166                                  
  2167                                  
  2168                                  print_ball:
  2169 00000BE2 4C8B05(DF140000)        	mov r8, [ball_x_pos]    ; Cargar posición X de la bola
  2170 00000BE9 4C8B0D(E7140000)        	mov r9, [ball_y_pos]    ; Cargar posición Y de la bola
  2171 00000BF0 4981C0[400A0000]        	add r8, board       ; Añadir offset del tablero
  2172                                  
  2173 00000BF7 4C89C9                  	mov rcx, r9        ; Y
  2174 00000BFA B852000000              	mov rax, column_cells + 2   ; Ancho del tablero
  2175 00000BFF 48F7E9                  	imul rcx     ; Multiplicar por Y
  2176                                  	
  2177 00000C02 4901C0                  	add r8, rax   ; Sumar X
  2178 00000C05 41C6004F                	mov byte [r8], char_O       ; Dibujar la bola en el tablero
  2179 00000C09 C3                      	ret
  2180                                  
  2181                                  print_ball_2:   ; Función para imprimir la segunda bola
  2182 00000C0A 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X de la segunda bola
  2183 00000C11 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y de la segunda bola
  2184 00000C18 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2185 00000C1F 4C89C9                      mov rcx, r9     ; Y
  2186 00000C22 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2187 00000C27 48F7E9                      imul rcx    ; Multiplicar por Y
  2188 00000C2A 4901C0                      add r8, rax  ; Sumar X
  2189 00000C2D 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2190 00000C31 C3                          ret     ; Retornar
  2191                                  
  2192                                  print_ball_3:   ; Función para imprimir la tercera bola
  2193 00000C32 4C8B05(23150000)            mov r8, [ball3_x_pos]   ; Cargar posición X de la tercera bola
  2194 00000C39 4C8B0D(2B150000)            mov r9, [ball3_y_pos]   ; Cargar posición Y de la tercera bola
  2195 00000C40 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2196 00000C47 4C89C9                      mov rcx, r9   ; Y
  2197 00000C4A B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2198 00000C4F 48F7E9                      imul rcx    ; Multiplicar por Y
  2199 00000C52 4901C0                      add r8, rax  ; Sumar X
  2200 00000C55 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2201 00000C59 C3                          ret    ; Retornar
  2202                                  
  2203                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  2204                                  	
  2205                                  print_pallet:
  2206                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  2207 00000C5A 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición actual de la paleta
  2208 00000C61 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño actual de la paleta
  2209                                      .clear_pallet:  ; Bucle para borrar la paleta
  2210 00000C68 41C60020                        mov byte [r8], char_space   ; Borrar carácter actual
  2211 00000C6C 49FFC0                          inc r8  ; Mover al siguiente carácter
  2212 00000C6F 48FFC9                          dec rcx ; Decrementar contador
  2213 00000C72 75F4                            jnz .clear_pallet   ; Repetir si no hemos terminado
  2214                                  
  2215                                      ; Luego dibujar la nueva paleta con el tamaño actual
  2216 00000C74 4C8B05(BF140000)            mov r8, [pallet_position]
  2217 00000C7B 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño de la paleta
  2218                                      .write_pallet:  ; Bucle para escribir la paleta
  2219 00000C82 41C6003D                        mov byte [r8], char_equal   ; Dibujar carácter actual
  2220 00000C86 49FFC0                          inc r8  ; Mover al siguiente carácter
  2221 00000C89 48FFC9                          dec rcx ; Decrementar contador
  2222 00000C8C 75F4                            jnz .write_pallet   ; Repetir si no hemos terminado
  2223                                  
  2224 00000C8E C3                          ret
  2225                                  
  2226                                  move_pallet:    ; Función para mover la paleta
  2227                                      
  2228 00000C8F 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2229 00000C96 7507                        jne .continue_movement  ; Si la bola se está moviendo, continuar
  2230 00000C98 C605(FF140000)01            mov byte [ball_moving], 1   ; Marcar la bola como en movimiento
  2231                                  
  2232                                      .continue_movement:
  2233 00000C9F 4883FFFF                        cmp rdi, left_direction  ; Verificar si la dirección es a la izquierda
  2234 00000CA3 7531                            jne .move_right  ; Si no es a la izquierda, mover a la derecha
  2235                                  
  2236                                          .move_left:         
  2237                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  2238 00000CA5 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2239 00000CAC 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  2240 00000CAF 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2241 00000CB2 3C58                                cmp al, 'X'        ; Comparar si es una X
  2242 00000CB4 744D                                je .end            ; Si es X, no mover
  2243                                              
  2244 00000CB6 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2245 00000CBD 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2246 00000CC4 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  2247 00000CCA 49FFC8                              dec r8            ; Mover a la izquierda
  2248 00000CCD 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2249 00000CD4 EB2D                                jmp .end    ; Salir
  2250                                              
  2251                                          .move_right:
  2252                                              ; Verificar si la siguiente posición después de la paleta sería una X
  2253 00000CD6 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2254 00000CDD 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2255 00000CE4 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  2256 00000CE7 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2257 00000CEA 3C58                                cmp al, 'X'        ; Comparar si es una X
  2258 00000CEC 7415                                je .end            ; Si es X, no mover
  2259                                              
  2260 00000CEE 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2261 00000CF5 41C60020                            mov byte [r8], char_space   ; Borrar primer carácter de la paleta
  2262 00000CF9 49FFC0                              inc r8          ; Mover a la derecha
  2263 00000CFC 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2264                                          .end:
  2265 00000D03 C3                                  ret
  2266                                  
  2267                                  
  2268                                  
  2269                                              
  2270                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  2271                                  update_caught_ball_position:    ; Función para actualizar la posición de la bola atrapada
  2272 00000D04 55                          push rbp    ; Guardar el puntero de la base
  2273 00000D05 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  2274                                      
  2275                                      ; Calcular la nueva posición de la bola basada en la paleta
  2276 00000D08 4C8B05(BF140000)            mov r8, [pallet_position]   ; Obtener posición actual de la paleta
  2277 00000D0F 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  2278 00000D16 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2279 00000D1B 4831D2                      xor rdx, rdx      ; Limpiar rdx
  2280 00000D1E 48F7F0                      div rax                ; División para obtener X,Y
  2281                                      
  2282                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  2283 00000D21 4989C1                      mov r9, rax            ; Y de la paleta
  2284 00000D24 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  2285                                      
  2286                                      ; Añadir el offset guardado a la posición X
  2287 00000D27 4889D0                      mov rax, rdx
  2288 00000D2A 480305(00230000)            add rax, [ball_catch_offset]    ; Añadir el offset guardado
  2289 00000D31 488905(DF140000)            mov [ball_x_pos], rax   ; Guardar nueva posición X
  2290 00000D38 4C890D(E7140000)            mov [ball_y_pos], r9    ; Guardar nueva posición Y
  2291                                      
  2292 00000D3F 5D                          pop rbp
  2293 00000D40 C3                          ret
  2294                                  
  2295                                  
  2296                                  move_all_balls:
  2297 00000D41 55                          push rbp
  2298 00000D42 4889E5                      mov rbp, rsp
  2299 00000D45 53                          push rbx
  2300                                      
  2301                                      ; Inicializar contador de bolas
  2302 00000D46 4831DB                      xor rbx, rbx
  2303                                      
  2304                                  .loop_balls:
  2305                                      ; Verificar si hemos procesado todas las bolas
  2306 00000D49 3A1D(3F240000)              cmp bl, byte [balls_count]  ; Comparar con la cantidad de bolas
  2307 00000D4F 7D1D                        jge .end    ; Si hemos procesado todas las bolas, salir
  2308                                      
  2309                                      ; Calcular offset de la bola actual
  2310 00000D51 B821000000                  mov rax, BALL_STRUCT_SIZE
  2311 00000D56 48F7E3                      mul rbx   ; Multiplicar por el índice de la bola
  2312                                      
  2313                                      ; Verificar si la bola está activa
  2314 00000D59 80B8[FC230000]01            cmp byte [balls_data + rax + 32], 1
  2315 00000D60 7507                        jne .next_ball  ; Si la bola no está activa, pasar a la siguiente
  2316                                      
  2317                                      ; Guardar offset en la pila
  2318 00000D62 50                          push rax
  2319                                      
  2320                                      ; Llamar a move_ball con los parámetros de esta bola
  2321 00000D63 E809000000                  call move_ball
  2322                                      
  2323                                      ; Restaurar offset
  2324 00000D68 58                          pop rax
  2325                                      
  2326                                  .next_ball:     ; Pasar a la siguiente bola
  2327 00000D69 48FFC3                      inc rbx  ; Incrementar contador de bolas
  2328 00000D6C EBDB                        jmp .loop_balls ; Repetir el ciclo
  2329                                      
  2330                                  .end:
  2331 00000D6E 5B                          pop rbx
  2332 00000D6F 5D                          pop rbp
  2333 00000D70 C3                          ret
  2334                                  
  2335                                  move_ball:  ; Función para mover una bola
  2336                                  
  2337 00000D71 803D(FD220000)01            cmp byte [ball_caught], 1   ; Verificar si la bola está atrapada
  2338 00000D78 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2339                                  
  2340 00000D7E 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2341 00000D85 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2342                                  
  2343                                      ; Incrementar contador de velocidad
  2344 00000D8B 48FF05(F3220000)            inc qword [speed_counter]
  2345                                      
  2346                                      ; Verificar si debemos mover la bola en este ciclo
  2347 00000D92 488B05(F3220000)            mov rax, [speed_counter]
  2348 00000D99 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2349 00000DA0 0F8C9D010000                jl .end  ; Si no es tiempo de mover la bola, salir
  2350                                      
  2351                                      ; Resetear contador de velocidad
  2352 00000DA6 48C705(F3220000)00-         mov qword [speed_counter], 0    ; Resetear contador
  2352 00000DAE 000000             
  2353                                  
  2354                                      ; Borrar la posición actual de la bola
  2355 00000DB1 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2356 00000DB8 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2357 00000DBF 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2358 00000DC6 4C89C9                      mov rcx, r9   ; Y
  2359 00000DC9 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2360 00000DCE 48F7E9                      imul rcx    ; Multiplicar por Y
  2361 00000DD1 4901C0                      add r8, rax  ; Sumar X
  2362 00000DD4 41C60020                    mov byte [r8], char_space   ; Borrar la bola de la posición actual
  2363                                  
  2364                                      ; Calcular siguiente posición X
  2365 00000DD8 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2366 00000DDF 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2367 00000DE6 488B05(EF140000)            mov rax, [ball_direction_x]  ; Cargar dirección X de la bola
  2368 00000DED 4901C0                      add r8, rax               ; Nueva posición X
  2369                                  
  2370                                      ; Calcular la dirección de memoria para la siguiente posición
  2371 00000DF0 4D89C2                      mov r10, r8
  2372 00000DF3 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2373 00000DFA 4C89C9                      mov rcx, r9   ; Y
  2374 00000DFD B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2375 00000E02 48F7E9                      imul rcx    ; Multiplicar por Y
  2376 00000E05 4901C2                      add r10, rax    ; Sumar X
  2377                                  
  2378                                      ; Verificar si hay una X en la siguiente posición X
  2379 00000E08 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2380 00000E0B 3C58                        cmp al, 'X'     ; Comparar con X
  2381 00000E0D 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2382 00000E0F 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  2383 00000E16 E928010000                  jmp .end    ; Salir
  2384                                  
  2385                                      .move_with_pallet:  ; Mover la bola con la paleta
  2386                                          ; Borrar la posición actual de la bola
  2387 00000E1B 4C8B05(DF140000)                mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2388 00000E22 4C8B0D(E7140000)                mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2389 00000E29 4D89C2                          mov r10, r8   ; Guardar posición X actual
  2390 00000E2C 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2391 00000E33 4C89C9                          mov rcx, r9  ; Y
  2392 00000E36 B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2393 00000E3B 48F7E9                          imul rcx    ; Multiplicar por Y
  2394 00000E3E 4901C2                          add r10, rax    ; Sumar X
  2395 00000E41 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2396                                  
  2397                                          ; Actualizar posición X basada en la paleta
  2398 00000E45 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2399 00000E4C 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2400 00000E53 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2401 00000E5A 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  2402                                  
  2403                                          ; Mantener la bola una posición arriba de la paleta
  2404 00000E61 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  2405 00000E68 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  2406                                  
  2407 00000E6F E9CF000000                      jmp .end
  2408                                  
  2409                                  
  2410                                      .check_block_x: 
  2411                                          ; Verificar colisión con bloques en X
  2412 00000E74 4150                            push r8     ; Guardar registros que usa check_block_collision
  2413 00000E76 4151                            push r9     ; Guardar registros que usa check_block_collision
  2414 00000E78 4152                            push r10    ; Guardar registros que usa check_block_collision
  2415 00000E7A E8710C0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2416 00000E7F 415A                            pop r10    ; Restaurar registros
  2417 00000E81 4159                            pop r9   ; Restaurar registros
  2418 00000E83 4158                            pop r8  ; Restaurar registros
  2419 00000E85 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2420 00000E88 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2421 00000E8A 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  2422 00000E91 E9AD000000                      jmp .end    ; Salir
  2423                                  
  2424                                      .check_paddle_x:
  2425                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2426 00000E96 41803A3D                        cmp byte [r10], char_equal  ; Comparar con el carácter de la paleta
  2427 00000E9A 750C                            jne .check_y_movement   ; Si no es la paleta, verificar movimiento en Y
  2428 00000E9C 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  2429 00000EA3 E99B000000                      jmp .end
  2430                                  
  2431                                      .check_y_movement:  ; Verificar movimiento en Y
  2432                                          ; Calcular siguiente posición Y
  2433 00000EA8 488B05(F7140000)                mov rax, [ball_direction_y] ; Cargar dirección Y de la bola
  2434 00000EAF 4901C1                          add r9, rax                  ; Nueva posición Y
  2435                                  
  2436                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2437 00000EB2 4D89C2                          mov r10, r8
  2438 00000EB5 4981C2[400A0000]                    add r10, board  ; Añadir offset del tablero
  2439 00000EBC 4C89C9                              mov rcx, r9  ; Y
  2440 00000EBF B852000000                          mov rax, column_cells + 2   ; Ancho del tablero 
  2441 00000EC4 48F7E9                          imul rcx    ; Multiplicar por Y
  2442 00000EC7 4901C2                          add r10, rax    ; Sumar X
  2443                                  
  2444                                          ; Verificar si hay una X en la siguiente posición Y
  2445 00000ECA 418A02                          mov al, [r10]       ; Cargar el carácter en la siguiente posición
  2446 00000ECD 3C58                            cmp al, 'X'    ; Comparar con X
  2447 00000ECF 7509                            jne .check_block_y  ; Si no hay X, verificar colisión con bloques
  2448 00000ED1 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  2449 00000ED8 EB69                            jmp .end    ; Salir
  2450                                  
  2451                                      .check_block_y:
  2452                                          ; Verificar colisión con bloques en Y
  2453 00000EDA 4150                            push r8     ; Guardar registros que usa check_block_collision
  2454 00000EDC 4151                            push r9    ; Guardar registros que usa check_block_collision
  2455 00000EDE 4152                            push r10    ; Guardar registros que usa check_block_collision
  2456 00000EE0 E80B0C0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2457 00000EE5 415A                            pop r10   ; Restaurar registros
  2458 00000EE7 4159                            pop r9  ; Restaurar registros
  2459 00000EE9 4158                            pop r8  ; Restaurar registros
  2460 00000EEB 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2461 00000EEE 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2462 00000EF0 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  2463 00000EF7 EB4A                            jmp .end
  2464                                  
  2465                                      .check_paddle_y:
  2466                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2467 00000EF9 41803A3D                        cmp byte [r10], char_equal
  2468 00000EFD 7536                            jne .update_position    ; Si no es la paleta, actualizar posición
  2469                                  
  2470                                          ; Verificar si el poder catch está activo
  2471 00000EFF 803D(FC220000)01                cmp byte [catch_power_active], 1
  2472 00000F06 7524                            jne .normal_bounce  ; Si no está activo, rebotar normalmente
  2473                                  
  2474                                          ; Activar el modo "atrapado"
  2475 00000F08 C605(FD220000)01                mov byte [ball_caught], 1   ; Marcar la bola como atrapada
  2476                                          
  2477                                          ; Guardar la posición X actual de la bola como offset
  2478 00000F0F 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  2479 00000F16 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2480 00000F1D 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2481 00000F23 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2482                                          
  2483 00000F2A EB17                            jmp .end
  2484                                  
  2485                                      .normal_bounce:
  2486 00000F2C 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  2487 00000F33 EB0E                            jmp .end
  2488                                  
  2489                                  
  2490                                      .update_position:   ; Actualizar la posición de la bola
  2491 00000F35 4C8905(DF140000)                mov [ball_x_pos], r8    ; Guardar nueva posición X
  2492 00000F3C 4C890D(E7140000)                mov [ball_y_pos], r9        ; Guardar nueva posición Y
  2493                                  
  2494                                      .end:
  2495 00000F43 C3                              ret
  2496                                  
  2497                                  
  2498                                  move_ball_2:
  2499                                  
  2500 00000F44 803D(FE220000)01            cmp byte [ball_caught_2], 1  ; Verificar si la bola está atrapada
  2501 00000F4B 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2502                                  
  2503 00000F51 803D(21150000)00            cmp byte [ball2_moving], 0  ; Verificar si la bola está en movimiento
  2504 00000F58 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2505                                  
  2506                                      ; Incrementar contador de velocidad
  2507 00000F5E 48FF05(F3220000)            inc qword [speed_counter]   ; Incrementar contador de velocidad
  2508                                      
  2509                                      ; Verificar si debemos mover la bola en este ciclo
  2510 00000F65 488B05(F3220000)            mov rax, [speed_counter]
  2511 00000F6C 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2512 00000F73 0F8C9D010000                jl .end
  2513                                      
  2514                                      ; Resetear contador de velocidad
  2515 00000F79 48C705(F3220000)00-         mov qword [speed_counter], 0
  2515 00000F81 000000             
  2516                                  
  2517                                      ; Borrar la posición actual de la bola
  2518 00000F84 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2519 00000F8B 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2520 00000F92 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2521 00000F99 4C89C9                      mov rcx, r9  ; Y
  2522 00000F9C B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2523 00000FA1 48F7E9                      imul rcx    ; Multiplicar por Y
  2524 00000FA4 4901C0                      add r8, rax     ; Sumar X
  2525 00000FA7 41C60020                    mov byte [r8], char_space       ; Borrar la bola de la posición actual
  2526                                  
  2527                                      ; Calcular siguiente posición X
  2528 00000FAB 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2529 00000FB2 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2530 00000FB9 488B05(11150000)            mov rax, [ball2_direction_x]    ; Cargar dirección X de la bola
  2531 00000FC0 4901C0                      add r8, rax               ; Nueva posición X
  2532                                  
  2533                                      ; Calcular la dirección de memoria para la siguiente posición
  2534 00000FC3 4D89C2                      mov r10, r8  ; Guardar posición X actual
  2535 00000FC6 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2536 00000FCD 4C89C9                      mov rcx, r9 ; Y
  2537 00000FD0 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2538 00000FD5 48F7E9                      imul rcx    ; Multiplicar por Y
  2539 00000FD8 4901C2                      add r10, rax    ; Sumar X
  2540                                  
  2541                                      ; Verificar si hay una X en la siguiente posición X
  2542 00000FDB 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2543 00000FDE 3C58                        cmp al, 'X'    ; Comparar con X
  2544 00000FE0 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2545 00000FE2 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  2546 00000FE9 E928010000                  jmp .end    ; Salir
  2547                                  
  2548                                      .move_with_pallet:
  2549                                          ; Borrar la posición actual de la bola
  2550 00000FEE 4C8B05(01150000)                mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2551 00000FF5 4C8B0D(09150000)                mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2552 00000FFC 4D89C2                          mov r10, r8  ; Guardar posición X actual
  2553 00000FFF 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2554 00001006 4C89C9                          mov rcx, r9 ; Y
  2555 00001009 B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2556 0000100E 48F7E9                          imul rcx    ; Multiplicar por Y
  2557 00001011 4901C2                          add r10, rax    ; Sumar X
  2558 00001014 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2559                                  
  2560                                          ; Actualizar posición X basada en la paleta
  2561 00001018 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2562 0000101F 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2563 00001026 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2564 0000102D 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  2565                                  
  2566                                          ; Mantener la bola una posición arriba de la paleta
  2567 00001034 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  2568 0000103B 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  2569                                  
  2570 00001042 E9CF000000                      jmp .end
  2571                                  
  2572                                  
  2573                                      .check_block_x:
  2574                                          ; Verificar colisión con bloques en X
  2575 00001047 4150                            push r8     ; Guardar registros que usa check_block_collision
  2576 00001049 4151                            push r9
  2577 0000104B 4152                            push r10    ; Guardar registros que usa check_block_collision
  2578 0000104D E89E0A0000                      call check_block_collision      
  2579 00001052 415A                            pop r10   ; Restaurar registros
  2580 00001054 4159                            pop r9
  2581 00001056 4158                            pop r8
  2582 00001058 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2583 0000105B 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2584 0000105D 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  2585 00001064 E9AD000000                      jmp .end
  2586                                  
  2587                                      .check_paddle_x:
  2588                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2589 00001069 41803A3D                        cmp byte [r10], char_equal  
  2590 0000106D 750C                            jne .check_y_movement
  2591 0000106F 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  2592 00001076 E99B000000                      jmp .end
  2593                                  
  2594                                      .check_y_movement:
  2595                                          ; Calcular siguiente posición Y
  2596 0000107B 488B05(19150000)                mov rax, [ball2_direction_y]
  2597 00001082 4901C1                          add r9, rax                  ; Nueva posición Y
  2598                                  
  2599                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2600 00001085 4D89C2                          mov r10, r8
  2601 00001088 4981C2[400A0000]                add r10, board
  2602 0000108F 4C89C9                          mov rcx, r9
  2603 00001092 B852000000                      mov rax, column_cells + 2
  2604 00001097 48F7E9                          imul rcx
  2605 0000109A 4901C2                          add r10, rax
  2606                                  
  2607                                          ; Verificar si hay una X en la siguiente posición Y
  2608 0000109D 418A02                          mov al, [r10]
  2609 000010A0 3C58                            cmp al, 'X'     ; Comparar con X
  2610 000010A2 7509                            jne .check_block_y
  2611 000010A4 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  2612 000010AB EB69                            jmp .end
  2613                                  
  2614                                      .check_block_y:
  2615                                          ; Verificar colisión con bloques en Y
  2616 000010AD 4150                            push r8     ; Guardar registros que usa check_block_collision
  2617 000010AF 4151                            push r9
  2618 000010B1 4152                            push r10
  2619 000010B3 E8380A0000                      call check_block_collision
  2620 000010B8 415A                            pop r10
  2621 000010BA 4159                            pop r9
  2622 000010BC 4158                            pop r8
  2623 000010BE 4885C0                          test rax, rax
  2624 000010C1 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2625 000010C3 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  2626 000010CA EB4A                            jmp .end
  2627                                  
  2628                                      .check_paddle_y:
  2629                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2630 000010CC 41803A3D                        cmp byte [r10], char_equal
  2631 000010D0 7536                            jne .update_position
  2632                                  
  2633                                          ; Verificar si el poder catch está activo
  2634 000010D2 803D(FC220000)01                cmp byte [catch_power_active], 1
  2635 000010D9 7524                            jne .normal_bounce
  2636                                  
  2637                                          ; Activar el modo "atrapado"
  2638 000010DB C605(FE220000)01                mov byte [ball_caught_2], 1
  2639                                          
  2640                                          ; Guardar la posición X actual de la bola como offset
  2641 000010E2 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2642 000010E9 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2643 000010F0 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2644 000010F6 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2645                                          
  2646 000010FD EB17                            jmp .end
  2647                                  
  2648                                      .normal_bounce:
  2649 000010FF 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2650 00001106 EB0E                            jmp .end
  2651                                  
  2652                                  
  2653                                      .update_position:
  2654 00001108 4C8905(01150000)                mov [ball2_x_pos], r8
  2655 0000110F 4C890D(09150000)                mov [ball2_y_pos], r9
  2656                                  
  2657                                      .end:
  2658 00001116 C3                              ret
  2659                                  
  2660                                  move_ball_3:    ; Función para mover la tercera bola
  2661                                  
  2662 00001117 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2663 0000111E 0F849D000000                je .move_with_pallet
  2664                                  
  2665 00001124 803D(43150000)00            cmp byte [ball3_moving], 0
  2666 0000112B 0F84B8010000                je .end
  2667                                  
  2668                                      ; Incrementar contador de velocidad
  2669 00001131 48FF05(F3220000)            inc qword [speed_counter]
  2670                                      
  2671                                      ; Verificar si debemos mover la bola en este ciclo
  2672 00001138 488B05(F3220000)            mov rax, [speed_counter]
  2673 0000113F 483B05(E3220000)            cmp rax, [ball_speed]
  2674 00001146 0F8C9D010000                jl .end
  2675                                      
  2676                                      ; Resetear contador de velocidad
  2677 0000114C 48C705(F3220000)00-         mov qword [speed_counter], 0
  2677 00001154 000000             
  2678                                  
  2679                                      ; Borrar la posición actual de la bola
  2680 00001157 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2681 0000115E 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2682 00001165 4981C0[400A0000]            add r8, board
  2683 0000116C 4C89C9                      mov rcx, r9
  2684 0000116F B852000000                  mov rax, column_cells + 2
  2685 00001174 48F7E9                      imul rcx
  2686 00001177 4901C0                      add r8, rax
  2687 0000117A 41C60020                    mov byte [r8], char_space
  2688                                  
  2689                                      ; Calcular siguiente posición X
  2690 0000117E 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2691 00001185 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2692 0000118C 488B05(33150000)            mov rax, [ball3_direction_x]
  2693 00001193 4901C0                      add r8, rax               ; Nueva posición X
  2694                                  
  2695                                      ; Calcular la dirección de memoria para la siguiente posición
  2696 00001196 4D89C2                      mov r10, r8
  2697 00001199 4981C2[400A0000]            add r10, board
  2698 000011A0 4C89C9                      mov rcx, r9
  2699 000011A3 B852000000                  mov rax, column_cells + 2
  2700 000011A8 48F7E9                      imul rcx
  2701 000011AB 4901C2                      add r10, rax
  2702                                  
  2703                                      ; Verificar si hay una X en la siguiente posición X
  2704 000011AE 418A02                      mov al, [r10]
  2705 000011B1 3C58                        cmp al, 'X'
  2706 000011B3 7565                        jne .check_block_x
  2707 000011B5 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2708 000011BC E928010000                  jmp .end
  2709                                  
  2710                                      .move_with_pallet:
  2711                                          ; Borrar la posición actual de la bola
  2712 000011C1 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2713 000011C8 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2714 000011CF 4D89C2                          mov r10, r8
  2715 000011D2 4981C2[400A0000]                add r10, board
  2716 000011D9 4C89C9                          mov rcx, r9
  2717 000011DC B852000000                      mov rax, column_cells + 2
  2718 000011E1 48F7E9                          imul rcx
  2719 000011E4 4901C2                          add r10, rax
  2720 000011E7 41C60220                        mov byte [r10], char_space
  2721                                  
  2722                                          ; Actualizar posición X basada en la paleta
  2723 000011EB 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2724 000011F2 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2725 000011F9 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2726 00001200 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2727                                  
  2728                                          ; Mantener la bola una posición arriba de la paleta
  2729 00001207 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2730 0000120E 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2731                                  
  2732 00001215 E9CF000000                      jmp .end
  2733                                  
  2734                                  
  2735                                      .check_block_x:
  2736                                          ; Verificar colisión con bloques en X
  2737 0000121A 4150                            push r8     ; Guardar registros que usa check_block_collision
  2738 0000121C 4151                            push r9
  2739 0000121E 4152                            push r10
  2740 00001220 E8CB080000                      call check_block_collision
  2741 00001225 415A                            pop r10
  2742 00001227 4159                            pop r9
  2743 00001229 4158                            pop r8
  2744 0000122B 4885C0                          test rax, rax
  2745 0000122E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2746 00001230 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2747 00001237 E9AD000000                      jmp .end
  2748                                  
  2749                                      .check_paddle_x:
  2750                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2751 0000123C 41803A3D                        cmp byte [r10], char_equal
  2752 00001240 750C                            jne .check_y_movement
  2753 00001242 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2754 00001249 E99B000000                      jmp .end
  2755                                  
  2756                                      .check_y_movement:
  2757                                          ; Calcular siguiente posición Y
  2758 0000124E 488B05(3B150000)                mov rax, [ball3_direction_y]
  2759 00001255 4901C1                          add r9, rax                  ; Nueva posición Y
  2760                                  
  2761                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2762 00001258 4D89C2                          mov r10, r8
  2763 0000125B 4981C2[400A0000]                add r10, board
  2764 00001262 4C89C9                          mov rcx, r9
  2765 00001265 B852000000                      mov rax, column_cells + 2
  2766 0000126A 48F7E9                          imul rcx
  2767 0000126D 4901C2                          add r10, rax
  2768                                  
  2769                                          ; Verificar si hay una X en la siguiente posición Y
  2770 00001270 418A02                          mov al, [r10]
  2771 00001273 3C58                            cmp al, 'X'
  2772 00001275 7509                            jne .check_block_y
  2773 00001277 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2774 0000127E EB69                            jmp .end
  2775                                  
  2776                                      .check_block_y:
  2777                                          ; Verificar colisión con bloques en Y
  2778 00001280 4150                            push r8     ; Guardar registros que usa check_block_collision
  2779 00001282 4151                            push r9
  2780 00001284 4152                            push r10
  2781 00001286 E865080000                      call check_block_collision
  2782 0000128B 415A                            pop r10
  2783 0000128D 4159                            pop r9
  2784 0000128F 4158                            pop r8
  2785 00001291 4885C0                          test rax, rax
  2786 00001294 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2787 00001296 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2788 0000129D EB4A                            jmp .end
  2789                                  
  2790                                      .check_paddle_y:
  2791                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2792 0000129F 41803A3D                        cmp byte [r10], char_equal
  2793 000012A3 7536                            jne .update_position
  2794                                  
  2795                                          ; Verificar si el poder catch está activo
  2796 000012A5 803D(FC220000)01                cmp byte [catch_power_active], 1
  2797 000012AC 7524                            jne .normal_bounce
  2798                                  
  2799                                          ; Activar el modo "atrapado"
  2800 000012AE C605(FF220000)01                mov byte [ball_caught_3], 1
  2801                                          
  2802                                          ; Guardar la posición X actual de la bola como offset
  2803 000012B5 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2804 000012BC 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2805 000012C3 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2806 000012C9 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2807                                          
  2808 000012D0 EB17                            jmp .end
  2809                                  
  2810                                      .normal_bounce:
  2811 000012D2 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2812 000012D9 EB0E                            jmp .end
  2813                                  
  2814                                  
  2815                                      .update_position:
  2816 000012DB 4C8905(23150000)                mov [ball3_x_pos], r8
  2817 000012E2 4C890D(2B150000)                mov [ball3_y_pos], r9
  2818                                  
  2819                                      .end:
  2820 000012E9 C3                              ret
  2821                                  
  2822                                  ; función para procesar la tecla C cuando la bola está atrapada
  2823                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2824                                  process_catch_release:
  2825 000012EA 55                          push rbp
  2826 000012EB 4889E5                      mov  rbp, rsp
  2827                                  
  2828                                      ; Verificar si el poder de catch está activo
  2829 000012EE 803D(FC220000)01            cmp byte [catch_power_active], 1
  2830 000012F5 0F8531010000                jne .no_catch_power
  2831                                  
  2832                                      ; Verificar si se presionó 'c' (derecha y arriba)
  2833 000012FB 803D(08230000)63            cmp byte [last_key], 'c'
  2834 00001302 7412                        je .release_right
  2835                                      
  2836                                      ; Verificar si se presionó 'x' (izquierda y arriba)
  2837 00001304 803D(08230000)78            cmp byte [last_key], 'x'
  2838 0000130B 0F8487000000                je .release_left
  2839                                      
  2840 00001311 E916010000                  jmp .no_catch_power
  2841                                  
  2842                                  .release_right:
  2843                                      ; Liberar la bola hacia la derecha
  2844 00001316 803D(FD220000)01            cmp byte [ball_caught], 1
  2845 0000131D 7522                        jne .check_ball2_right
  2846 0000131F C605(FD220000)00            mov byte [ball_caught], 0
  2847 00001326 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Derecha
  2847 0000132E 000000             
  2848 00001331 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2848 00001339 FFFFFF             
  2849 0000133C E9CD000000                  jmp .release_complete
  2850                                  
  2851                                  .check_ball2_right:
  2852 00001341 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2853 00001348 7522                        jne .check_ball3_right
  2854 0000134A C605(FE220000)00            mov byte [ball_caught_2], 0
  2855 00001351 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2855 00001359 000000             
  2856 0000135C 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2856 00001364 FFFFFF             
  2857 00001367 E9A2000000                  jmp .release_complete
  2858                                  
  2859                                  .check_ball3_right:
  2860 0000136C 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2861 00001373 0F8595000000                jne .release_complete
  2862 00001379 C605(FF220000)00            mov byte [ball_caught_3], 0
  2863 00001380 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2863 00001388 000000             
  2864 0000138B 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2864 00001393 FFFFFF             
  2865 00001396 EB76                        jmp .release_complete
  2866                                  
  2867                                  .release_left:
  2868                                      ; Liberar la bola hacia la izquierda
  2869 00001398 803D(FD220000)01            cmp byte [ball_caught], 1
  2870 0000139F 751F                        jne .check_ball2_left
  2871 000013A1 C605(FD220000)00            mov byte [ball_caught], 0
  2872 000013A8 48C705(EF140000)FF-         mov qword [ball_direction_x], -1   ; Izquierda
  2872 000013B0 FFFFFF             
  2873 000013B3 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2873 000013BB FFFFFF             
  2874 000013BE EB4E                        jmp .release_complete
  2875                                  
  2876                                  .check_ball2_left:
  2877 000013C0 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2878 000013C7 751F                        jne .check_ball3_left
  2879 000013C9 C605(FE220000)00            mov byte [ball_caught_2], 0
  2880 000013D0 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  2880 000013D8 FFFFFF             
  2881 000013DB 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2881 000013E3 FFFFFF             
  2882 000013E6 EB26                        jmp .release_complete
  2883                                  
  2884                                  .check_ball3_left:
  2885 000013E8 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2886 000013EF 751D                        jne .release_complete
  2887 000013F1 C605(FF220000)00            mov byte [ball_caught_3], 0
  2888 000013F8 48C705(33150000)FF-         mov qword [ball3_direction_x], -1
  2888 00001400 FFFFFF             
  2889 00001403 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2889 0000140B FFFFFF             
  2890                                  
  2891                                  .release_complete:
  2892                                      ; Si era el catch inicial, desactivarlo
  2893 0000140E 803D(FB220000)01            cmp byte [initial_catch_active], 1
  2894 00001415 750E                        jne .finish
  2895 00001417 C605(FB220000)00            mov byte [initial_catch_active], 0
  2896 0000141E C605(FC220000)00            mov byte [catch_power_active], 0  ; Desactivar poder de catch después de la 1ra vez
  2897                                  
  2898                                  .finish:
  2899 00001425 C605(08230000)00            mov byte [last_key], 0  ; Limpiar la tecla
  2900                                  .no_catch_power:
  2901 0000142C 5D                          pop rbp
  2902 0000142D C3                          ret
  2903                                  
  2904                                  
  2905                                  
  2906                                  display_level_number:   ; Función para mostrar el número del nivel
  2907 0000142E 55                          push rbp
  2908 0000142F 4889E5                      mov rbp, rsp
  2909                                      
  2910                                      ; Limpiar la pantalla primero
  2911                                      print clear, clear_length
    93 00001432 B801000000          <1>  mov eax, sys_write
    94 00001437 BF01000000          <1>  mov edi, 1
    95 0000143C 48BE-               <1>  mov rsi, %1
    95 0000143E [1000000000000000]  <1>
    96 00001446 BA07000000          <1>  mov edx, %2
    97 0000144B 0F05                <1>  syscall
  2912                                      
  2913                                      ; Calcular la posición central para el mensaje
  2914                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2915 0000144D B850000000                  mov rax, column_cells
  2916 00001452 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2917 00001456 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2918                                      
  2919                                      ; Calcular la fila central
  2920 00001459 BB20000000                  mov rbx, row_cells
  2921 0000145E 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2922                                      
  2923                                      ; Calcular el offset en el buffer
  2924 00001461 B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2925 00001466 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2926 00001469 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2927                                      
  2928                                      ; Escribir "NIVEL " en la posición calculada
  2929 0000146C 488DB8[400A0000]            lea rdi, [board + rax]
  2930 00001473 48BE-                       mov rsi, level_msg       ; mensaje "NIVEL "
  2930 00001475 [A414000000000000] 
  2931 0000147D B906000000                  mov rcx, level_msg_len  ; longitud del mensaje
  2932 00001482 F3A4                        rep movsb
  2933                                      
  2934                                      ; Escribir el número del nivel
  2935 00001484 8A05(79150000)              mov al, [current_level]
  2936 0000148A 0430                        add al, '0'                 ; convertir a ASCII
  2937 0000148C 8807                        mov [rdi], al
  2938                                      
  2939                                      ; Mostrar el board con el mensaje
  2940                                      print board, board_size
    93 0000148E B801000000          <1>  mov eax, sys_write
    94 00001493 BF01000000          <1>  mov edi, 1
    95 00001498 48BE-               <1>  mov rsi, %1
    95 0000149A [400A000000000000]  <1>
    96 000014A2 BA400A0000          <1>  mov edx, %2
    97 000014A7 0F05                <1>  syscall
  2941                                      
  2942                                      ; Esperar un segundo
  2943 000014A9 B823000000                  mov rax, sys_nanosleep
  2944 000014AE 48BF-                       mov rdi, level_display_time
  2944 000014B0 [AF14000000000000] 
  2945 000014B8 4831F6                      xor rsi, rsi
  2946 000014BB 0F05                        syscall
  2947                                      
  2948 000014BD 5D                          pop rbp
  2949 000014BE C3                          ret
  2950                                  
  2951                                  ; Función para inicializar un tablero vacío
  2952                                  init_empty_board:   ; Inicializar un tablero vacío
  2953 000014BF 56                          push rsi
  2954 000014C0 57                          push rdi
  2955 000014C1 51                          push rcx
  2956 000014C2 50                          push rax
  2957                                  
  2958 000014C3 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2959 000014CA 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2960 000014D1 B9400A0000                  mov rcx, board_template_size
  2961 000014D6 F3A4                        rep movsb                   ; Copiar el tablero
  2962                                  
  2963 000014D8 58                          pop rax
  2964 000014D9 59                          pop rcx
  2965 000014DA 5F                          pop rdi
  2966 000014DB 5E                          pop rsi
  2967 000014DC C3                          ret
  2968                                  
  2969                                  clear_enemies_from_board:   ; Función para limpiar los enemigos del tablero
  2970 000014DD 55                          push rbp
  2971 000014DE 4889E5                      mov rbp, rsp
  2972 000014E1 56                          push rsi
  2973 000014E2 57                          push rdi
  2974                                  
  2975                                      ; Primero limpiar board
  2976 000014E3 B9400A0000                  mov rcx, board_size      
  2977 000014E8 488D35(400A0000)            lea rsi, [board]         
  2978                                  
  2979                                  .clear_loop:
  2980 000014EF 4883F900                    cmp rcx, 0              
  2981 000014F3 741F                        je .clear_template      ; En vez de terminar, vamos a limpiar template
  2982                                      
  2983 000014F5 8A06                        mov al, [rsi]           
  2984 000014F7 3C40                        cmp al, '@'             
  2985 000014F9 740E                        je .make_space
  2986 000014FB 3C23                        cmp al, '#'             
  2987 000014FD 740A                        je .make_space
  2988 000014FF 3C24                        cmp al, '$'             
  2989 00001501 7406                        je .make_space
  2990 00001503 3C26                        cmp al, '&'             
  2991 00001505 7402                        je .make_space
  2992                                      
  2993 00001507 EB03                        jmp .next               
  2994                                  
  2995                                  .make_space:
  2996 00001509 C60620                      mov byte [rsi], ' '         ; Reemplazar enemigo con espacio
  2997                                  
  2998                                  .next:
  2999 0000150C 48FFC6                      inc rsi                 
  3000 0000150F 48FFC9                      dec rcx                
  3001 00001512 EBDB                        jmp .clear_loop        
  3002                                  
  3003                                  .clear_template:
  3004                                      ; Ahora limpiar board_template
  3005 00001514 B9400A0000                  mov rcx, board_template_size
  3006 00001519 488D35(00000000)            lea rsi, [board_template]   
  3007                                  
  3008                                  .template_loop: ; Bucle para limpiar la plantilla
  3009 00001520 4883F900                    cmp rcx, 0
  3010 00001524 741F                        je .end
  3011                                      
  3012 00001526 8A06                        mov al, [rsi]
  3013 00001528 3C40                        cmp al, '@'
  3014 0000152A 740E                        je .make_space_template
  3015 0000152C 3C23                        cmp al, '#'
  3016 0000152E 740A                        je .make_space_template
  3017 00001530 3C24                        cmp al, '$'
  3018 00001532 7406                        je .make_space_template
  3019 00001534 3C26                        cmp al, '&'
  3020 00001536 7402                        je .make_space_template
  3021                                      
  3022 00001538 EB03                        jmp .next_template
  3023                                  
  3024                                  .make_space_template:
  3025 0000153A C60620                      mov byte [rsi], ' '
  3026                                  
  3027                                  .next_template:
  3028 0000153D 48FFC6                      inc rsi
  3029 00001540 48FFC9                      dec rcx
  3030 00001543 EBDB                        jmp .template_loop
  3031                                  
  3032                                  .end:
  3033 00001545 5F                          pop rdi
  3034 00001546 5E                          pop rsi
  3035 00001547 5D                          pop rbp
  3036 00001548 C3                          ret
  3037                                  
  3038                                  
  3039                                  init_level:  ; Función para inicializar un nivel
  3040 00001549 E88FFFFFFF                  call clear_enemies_from_board
  3041 0000154E C605(22150000)00            mov byte [ball2_active], 0
  3042 00001555 C605(44150000)00            mov byte [ball3_active], 0
  3043 0000155C C605(09230000)00            mov byte [laser_power_active], 0
  3044 00001563 E898F2FFFF                  call clear_lasers
  3045 00001568 488B05(CF140000)            mov rax, [default_pallet_size]
  3046 0000156F 488905(C7140000)            mov [pallet_size], rax
  3047 00001576 48C705(E3220000)07-         mov qword [ball_speed], 7    ; Restaurar velocidad normal
  3047 0000157E 000000             
  3048                                  
  3049                                      ; 1) Copiamos board_template en board para que quede limpio
  3050                                          ; Reiniciar letras activas
  3051 00001581 488D3D(3C210000)            lea rdi, [letters_map]
  3052 00001588 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  3053 0000158D 4831C0                      xor rax, rax
  3054 00001590 F3AA                        rep stosb                    ; Llenar con ceros
  3055                                      
  3056                                      ; Inicializar dirección de la bola (derecha y arriba)
  3057 00001592 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  3057 0000159A 000000             
  3058 0000159D 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  3058 000015A5 FFFFFF             
  3059                                  
  3060                                      ; En init_level, después de inicializar las direcciones
  3061 000015A8 C605(FC220000)01            mov byte [catch_power_active], 1    ; Activar el poder catch
  3062 000015AF C605(FD220000)01            mov byte [ball_caught], 1           ; Marcar la bola como atrapada
  3063 000015B6 C605(FB220000)01            mov byte [initial_catch_active], 1  ; Marcar que es el catch inicial
  3064                                  
  3065                                      ; Calcular y guardar el offset inicial de la bola respecto a la paleta
  3066 000015BD 488B05(DF140000)            mov rax, [ball_x_pos]              ; Posición X actual de la bola
  3067 000015C4 482B05(BF140000)            sub rax, [pallet_position]         ; Restar la posición de la paleta
  3068 000015CB 4805[400A0000]              add rax, board                     ; Ajustar por el offset del tablero
  3069 000015D1 488905(00230000)            mov [ball_catch_offset], rax       ; Guardar el offset
  3070                                  
  3071                                  
  3072                                  
  3073                                      ; Reiniciar contador de letras activas
  3074 000015D8 4831C0                      xor rax, rax
  3075 000015DB 8805(CC220000)              mov [letters_count], al
  3076                                  
  3077                                      ; Reiniciar última letra capturada
  3078 000015E1 C605(CD220000)20            mov byte [last_letter], ' '
  3079 000015E8 C605(46200000)00            mov byte [destroyed_blocks], 0 
  3080 000015EF E8CBFEFFFF                  call init_empty_board
  3081 000015F4 E835FEFFFF                  call display_level_number
  3082                                  
  3083 000015F9 56                          push rsi
  3084 000015FA 57                          push rdi
  3085 000015FB 51                          push rcx
  3086 000015FC 50                          push rax
  3087                                  
  3088 000015FD 488D35(00000000)            lea rsi, [board_template]
  3089 00001604 488D3D(400A0000)            lea rdi, [board]
  3090 0000160B B9400A0000                  mov rcx, board_template_size
  3091 00001610 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  3092                                  
  3093 00001612 58                          pop rax
  3094 00001613 59                          pop rcx
  3095 00001614 5F                          pop rdi
  3096 00001615 5E                          pop rsi
  3097                                  
  3098 00001616 B90A000000                  mov rcx, 10
  3099 0000161B 4831C0                      xor rax, rax
  3100 0000161E 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3101 00001625 F3AA                        rep stosb   
  3102 00001627 E8ED050000                  call init_enemies   
  3103                                  
  3104                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  3105 0000162C 803D(79150000)01            cmp byte [current_level], 1
  3106 00001633 7431                        je .level1
  3107 00001635 803D(79150000)02            cmp byte [current_level], 2
  3108 0000163C 7454                        je .level2
  3109 0000163E 803D(79150000)03            cmp byte [current_level], 3
  3110 00001645 7477                        je .level3
  3111 00001647 803D(79150000)04            cmp byte [current_level], 4
  3112 0000164E 0F8492000000                je .level4
  3113 00001654 803D(79150000)05            cmp byte [current_level], 5
  3114 0000165B 0F84B0000000                je .level5
  3115 00001661 E9D3000000                  jmp .done
  3116                                  
  3117                                  
  3118                                  
  3119                                      .level1:
  3120 00001666 C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  3121 0000166D 4831C9                          xor rcx, rcx             
  3122                                          .init_loop1:    ; Bucle para inicializar los bloques del nivel 1
  3123 00001670 4883F94E                            cmp rcx, level1_blocks_count
  3124 00001674 0F8DBF000000                        jge .done   ; Si ya inicializamos todos los bloques, terminar
  3125 0000167A 4889C8                              mov rax, rcx              
  3126 0000167D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3127 00001681 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]       
  3128 00001687 8891[761F0000]                      mov byte [block_states + rcx], dl
  3129 0000168D 48FFC1                              inc rcx        ; Incrementar contador
  3130 00001690 EBDE                                jmp .init_loop1
  3131                                  
  3132                                      .level2:
  3133 00001692 C605(7A150000)5B                mov byte [blocks_remaining], level2_blocks_count    ; Inicializar el contador de bloques restantes
  3134 00001699 4831C9                          xor rcx, rcx             
  3135                                          .init_loop2:
  3136 0000169C 4883F95B                            cmp rcx, level2_blocks_count
  3137 000016A0 0F8D93000000                        jge .done
  3138 000016A6 4889C8                              mov rax, rcx         
  3139 000016A9 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3140 000016AD 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  3141 000016B3 8891[761F0000]                      mov byte [block_states + rcx], dl
  3142 000016B9 48FFC1                              inc rcx
  3143 000016BC EBDE                                jmp .init_loop2
  3144                                      .level3:
  3145 000016BE C605(7A150000)40                mov byte [blocks_remaining], 64
  3146 000016C5 4831C9                          xor rcx, rcx             
  3147                                          .init_loop3:
  3148 000016C8 4883F968                            cmp rcx, level3_blocks_count
  3149 000016CC 7D6B                                jge .done
  3150 000016CE 4889C8                              mov rax, rcx         
  3151 000016D1 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3152 000016D5 8A90[CB180000]                      mov dl, byte [level3_blocks + rax + 3]  
  3153 000016DB 8891[761F0000]                      mov byte [block_states + rcx], dl
  3154 000016E1 48FFC1                              inc rcx
  3155 000016E4 EBE2                                jmp .init_loop3
  3156                                  
  3157                                      .level4:
  3158 000016E6 C605(7A150000)8C                mov byte [blocks_remaining], level4_blocks_count
  3159 000016ED 4831C9                          xor rcx, rcx             
  3160                                          .init_loop4:
  3161 000016F0 4881F98C000000                      cmp rcx, level4_blocks_count
  3162 000016F7 7D40                                jge .done
  3163 000016F9 4889C8                              mov rax, rcx         
  3164 000016FC 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3165 00001700 8A90[D31A0000]                      mov dl, byte [level4_blocks + rax + 3]  
  3166 00001706 8891[761F0000]                      mov byte [block_states + rcx], dl
  3167 0000170C 48FFC1                              inc rcx
  3168 0000170F EBDF                                jmp .init_loop4
  3169                                  
  3170                                      .level5:
  3171 00001711 C605(7A150000)62                mov byte [blocks_remaining], level5_blocks_count
  3172 00001718 4831C9                          xor rcx, rcx             
  3173                                          .init_loop5:
  3174 0000171B 4883F962                            cmp rcx, level5_blocks_count
  3175 0000171F 7D18                                jge .done
  3176 00001721 4889C8                              mov rax, rcx         
  3177 00001724 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3178 00001728 8A90[8F1D0000]                      mov dl, byte [level5_blocks + rax + 3]  
  3179 0000172E 8891[761F0000]                      mov byte [block_states + rcx], dl
  3180 00001734 48FFC1                              inc rcx
  3181 00001737 EBE2                                jmp .init_loop5
  3182                                      .done:
  3183 00001739 C3                              ret
  3184                                  
  3185                                  
  3186                                  ; Función para verificar y manejar la transición de nivel
  3187                                  check_level_complete:   ; Verificar si el nivel está completo
  3188                                      ; Verificar si quedan bloques
  3189 0000173A 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Si no quedan bloques
  3190 00001741 7556                        jne .not_complete            ; No completado, continuar con el nivel actual
  3191                                      
  3192                                      ; Incrementar el nivel
  3193 00001743 FE05(79150000)              inc byte [current_level]    ; Incrementar el nivel
  3194                                      
  3195                                      ; Verificar si hemos completado todos los niveles
  3196 00001749 803D(79150000)06            cmp byte [current_level], 6 ; Si hemos completado todos los niveles
  3197 00001750 7448                        je game_win               ; Ganar el juego
  3198                                      
  3199                                  
  3200 00001752 E886FDFFFF                  call clear_enemies_from_board
  3201                                      ; Primero establecer las posiciones seguras
  3202 00001757 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  3202 0000175E [B0130000]         
  3203 00001762 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  3203 0000176A 000000             
  3204 0000176D 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  3204 00001775 000000             
  3205 00001778 C605(FF140000)00            mov byte [ball_moving], 0
  3206                                      
  3207                                      ; Asegurar que la bola esté en un estado seguro
  3208 0000177F C605(FC220000)01            mov byte [catch_power_active], 1
  3209 00001786 C605(FD220000)01            mov byte [ball_caught], 1
  3210 0000178D C605(FB220000)01            mov byte [initial_catch_active], 1
  3211                                      
  3212                                      ; Reinicializar el juego para el siguiente nivel
  3213 00001794 E8B0FDFFFF                  call init_level
  3214                                      
  3215                                  .not_complete:
  3216 00001799 C3                          ret
  3217                                  
  3218                                      ; Nueva función para manejar la victoria del juego
  3219                                  game_win:
  3220 0000179A 55                          push rbp
  3221 0000179B 4889E5                      mov rbp, rsp
  3222                                      
  3223                                      ; Limpiar pantalla
  3224 0000179E 48BE-                       mov rsi, clear
  3224 000017A0 [1000000000000000] 
  3225 000017A8 BA07000000                  mov rdx, clear_length
  3226 000017AD B801000000                  mov eax, sys_write
  3227 000017B2 BF01000000                  mov edi, 1
  3228 000017B7 0F05                        syscall
  3229                                      
  3230                                      ; Imprimir mensaje de Game Over
  3231 000017B9 48BE-                       mov rsi, game_win_msg
  3231 000017BB [7E24000000000000] 
  3232 000017C3 BA27000000                  mov rdx, game_win_len
  3233 000017C8 B801000000                  mov eax, sys_write
  3234 000017CD BF01000000                  mov edi, 1
  3235 000017D2 0F05                        syscall
  3236                                      
  3237                                      ; Convertir score a string
  3238 000017D4 488B05(3E200000)            mov rax, [current_score]
  3239 000017DB 48BF-                       mov rdi, number_buffer
  3239 000017DD [4720000000000000] 
  3240 000017E5 E8AE010000                  call number_to_string
  3241                                      
  3242                                      ; Calcular longitud del número convertido
  3243 000017EA B900000000                  mov rcx, 0
  3244 000017EF 48BF-                       mov rdi, number_buffer
  3244 000017F1 [4720000000000000] 
  3245                                  .count_loop:
  3246 000017F9 803C0F00                    cmp byte [rdi + rcx], 0
  3247 000017FD 7405                        je .print_score
  3248 000017FF 48FFC1                      inc rcx
  3249 00001802 EBF5                        jmp .count_loop
  3250                                  
  3251                                  .print_score:
  3252                                      ; Imprimir el score
  3253 00001804 48BE-                       mov rsi, number_buffer
  3253 00001806 [4720000000000000] 
  3254 0000180E 4889CA                      mov rdx, rcx
  3255 00001811 B801000000                  mov eax, sys_write
  3256 00001816 BF01000000                  mov edi, 1
  3257 0000181B 0F05                        syscall
  3258                                      
  3259                                      ; Imprimir nueva línea
  3260 0000181D 48BE-                       mov rsi, newline
  3260 0000181F [7D24000000000000] 
  3261 00001827 BA01000000                  mov rdx, newline_len
  3262 0000182C B801000000                  mov eax, sys_write
  3263 00001831 BF01000000                  mov edi, 1
  3264 00001836 0F05                        syscall
  3265                                      
  3266                                  .wait_q:
  3267                                      ; Esperar por la tecla 'q'
  3268 00001838 B800000000                  mov rax, sys_read
  3269 0000183D BF00000000                  mov rdi, STDIN_FILENO
  3270 00001842 48BE-                       mov rsi, input_char
  3270 00001844 [0000000000000000] 
  3271 0000184C BA01000000                  mov rdx, 1
  3272 00001851 0F05                        syscall
  3273                                      
  3274 00001853 803D(00000000)71            cmp byte [input_char], 'q'
  3275 0000185A 75DC                        jne .wait_q
  3276                                  
  3277 0000185C E9B50B0000                  jmp exit
  3278                                      
  3279 00001861 5D                          pop rbp
  3280 00001862 C3                          ret
  3281                                  
  3282                                  ; unción para obtener el puntero a los bloques del nivel actual
  3283                                  get_current_level_blocks:
  3284 00001863 803D(79150000)01            cmp byte [current_level], 1
  3285 0000186A 7428                        je .level1
  3286 0000186C 803D(79150000)02            cmp byte [current_level], 2
  3287 00001873 7427                        je .level2
  3288 00001875 803D(79150000)03            cmp byte [current_level], 3
  3289 0000187C 7426                        je .level3
  3290 0000187E 803D(79150000)04            cmp byte [current_level], 4
  3291 00001885 7425                        je .level4
  3292 00001887 803D(79150000)05            cmp byte [current_level], 5
  3293 0000188E 7424                        je .level5
  3294                                      ; Si llegamos aquí, hay un error en el nivel
  3295 00001890 4831C0                      xor rax, rax
  3296 00001893 C3                          ret
  3297                                  
  3298                                      .level1:
  3299 00001894 488D05(7B150000)                lea rax, [level1_blocks]
  3300 0000189B C3                              ret
  3301                                      .level2:
  3302 0000189C 488D05(01170000)                lea rax, [level2_blocks]
  3303 000018A3 C3                              ret
  3304                                      .level3:
  3305 000018A4 488D05(C8180000)                lea rax, [level3_blocks]
  3306 000018AB C3                              ret
  3307                                      .level4:
  3308 000018AC 488D05(D01A0000)                lea rax, [level4_blocks]
  3309 000018B3 C3                              ret
  3310                                      .level5:
  3311 000018B4 488D05(8C1D0000)                lea rax, [level5_blocks]
  3312 000018BB C3                              ret
  3313                                  ; Función para obtener la cantidad de bloques del nivel actual
  3314                                  get_current_level_count:
  3315 000018BC 803D(79150000)01            cmp byte [current_level], 1
  3316 000018C3 7428                        je .level1
  3317 000018C5 803D(79150000)02            cmp byte [current_level], 2
  3318 000018CC 7425                        je .level2
  3319 000018CE 803D(79150000)03            cmp byte [current_level], 3
  3320 000018D5 7422                        je .level3
  3321 000018D7 803D(79150000)04            cmp byte [current_level], 4
  3322 000018DE 741F                        je .level4
  3323 000018E0 803D(79150000)05            cmp byte [current_level], 5
  3324 000018E7 741C                        je .level5
  3325                                      ; Si llegamos aquí, hay un error en el nivel
  3326 000018E9 4831C0                      xor rax, rax
  3327 000018EC C3                          ret
  3328                                  
  3329                                      .level1:
  3330 000018ED B84E000000                      mov rax, level1_blocks_count
  3331 000018F2 C3                              ret
  3332                                      .level2:
  3333 000018F3 B85B000000                      mov rax, level2_blocks_count
  3334 000018F8 C3                              ret
  3335                                      .level3:
  3336 000018F9 B868000000                      mov rax, level3_blocks_count
  3337 000018FE C3                              ret
  3338                                      .level4:
  3339 000018FF B88C000000                      mov rax, level4_blocks_count
  3340 00001904 C3                              ret
  3341                                      .level5:
  3342 00001905 B862000000                      mov rax, level5_blocks_count
  3343 0000190A C3                              ret
  3344                                  
  3345                                  ; Función para imprimir los bloques del nivel actual
  3346                                  print_blocks:   ; Imprimir los bloques del nivel actual
  3347 0000190B 55                          push rbp                  ; Guardar el puntero de la pila
  3348 0000190C 4889E5                      mov rbp, rsp          ; Establecer el puntero de la pila
  3349                                      
  3350                                      ; Obtener puntero a los bloques del nivel actual
  3351 0000190F E84FFFFFFF                  call get_current_level_blocks
  3352 00001914 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  3353                                      
  3354                                      ; Obtener cantidad de bloques del nivel actual
  3355 00001917 E8A0FFFFFF                  call get_current_level_count
  3356 0000191C 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  3357                                      
  3358 0000191F 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  3359                                      
  3360                                      .print_loop:              ; Bucle para imprimir los bloques
  3361 00001922 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  3362 00001925 7D6F                            jge .end              ; Si ya imprimimos todos los bloques, terminar
  3363                                          
  3364                                          ; Verificar si el bloque está activo
  3365 00001927 490FB68424-                     movzx rax, byte [block_states + r12]
  3365 0000192C [761F0000]         
  3366 00001930 4885C0                          test rax, rax
  3367 00001933 745C                            jz .next_block
  3368                                          
  3369                                          ; Obtener posición y tipo del bloque usando r13
  3370 00001935 4C89E0                          mov rax, r12
  3371 00001938 486BC005                        imul rax, 5
  3372 0000193C 4C01E8                          add rax, r13
  3373 0000193F 448A00                          mov r8b, [rax]        ; X position
  3374 00001942 448A4801                        mov r9b, [rax + 1]    ; Y position
  3375 00001946 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  3376                                  
  3377                                          ; El resto de la lógica de impresión permanece igual
  3378 0000194A 4D0FB6C0                        movzx r8, r8b
  3379 0000194E 4D0FB6C9                        movzx r9, r9b
  3380 00001952 4981C0[400A0000]                add r8, board
  3381 00001959 B852000000                      mov rax, column_cells + 2
  3382 0000195E 49F7E1                          mul r9
  3383 00001961 4901C0                          add r8, rax
  3384                                          
  3385 00001964 B906000000                      mov rcx, block_length
  3386 00001969 48BE-                           mov rsi, block_type_1
  3386 0000196B [5515000000000000] 
  3387 00001973 490FB6C2                        movzx rax, r10b
  3388 00001977 48FFC8                          dec rax
  3389 0000197A 486BC006                        imul rax, block_length
  3390 0000197E 4801C6                          add rsi, rax
  3391                                          
  3392                                      .print_block_chars:   ; Bucle para imprimir los caracteres del bloque
  3393 00001981 8A06                            mov al, [rsi]   ; Obtener el carácter
  3394 00001983 418800                          mov [r8], al    ; Escribir en el tablero
  3395 00001986 48FFC6                          inc rsi        ; Siguiente carácter
  3396 00001989 49FFC0                          inc r8          ; Siguiente posición
  3397 0000198C 48FFC9                          dec rcx        ; Decrementar contador
  3398 0000198F 75F0                            jnz .print_block_chars  ; Repetir si no hemos terminado
  3399                                          
  3400                                      .next_block:      ; Continuar con el siguiente bloque
  3401 00001991 49FFC4                          inc r12         ; Incrementar el índice del bloque
  3402 00001994 EB8C                            jmp .print_loop ; Repetir el bucle
  3403                                          
  3404                                      .end:
  3405 00001996 5D                              pop rbp
  3406 00001997 C3                              ret
  3407                                  
  3408                                  ; Función para convertir número a string
  3409                                  ; Input: RAX = número a convertir
  3410                                  ; RDI = buffer donde escribir el string
  3411                                  number_to_string:
  3412 00001998 53                          push rbx
  3413 00001999 52                          push rdx
  3414 0000199A 56                          push rsi
  3415 0000199B BB0A000000                  mov rbx, 10          ; Divisor
  3416 000019A0 B900000000                  mov rcx, 0          ; Contador de dígitos
  3417                                      
  3418                                      ; Si el número es 0, manejarlo especialmente
  3419 000019A5 4885C0                      test rax, rax
  3420 000019A8 7509                        jnz .convert_loop   ; Saltar si no es 0
  3421 000019AA C60730                      mov byte [rdi], '0'
  3422 000019AD C6470100                    mov byte [rdi + 1], 0   ; Null terminator
  3423 000019B1 EB20                        jmp .end
  3424                                      
  3425                                      .convert_loop:
  3426 000019B3 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  3427 000019B6 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  3428 000019B9 80C230                          add dl, '0'     ; Convertir a ASCII
  3429 000019BC 52                              push rdx        ; Guardar el dígito
  3430 000019BD 48FFC1                          inc rcx         ; Incrementar contador
  3431 000019C0 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  3432 000019C3 75EE                            jnz .convert_loop
  3433                                          
  3434                                      .write_loop:
  3435 000019C5 5A                              pop rdx         ; Obtener dígito
  3436 000019C6 8817                            mov [rdi], dl   ; Escribir al buffer
  3437 000019C8 48FFC7                          inc rdi         ; Siguiente posición
  3438 000019CB 48FFC9                          dec rcx         ; Decrementar contador
  3439 000019CE 75F5                            jnz .write_loop
  3440                                          
  3441 000019D0 C60700                      mov byte [rdi], 0   ; Null terminator
  3442                                      
  3443                                      .end:
  3444 000019D3 5E                          pop rsi
  3445 000019D4 5A                          pop rdx
  3446 000019D5 5B                          pop rbx
  3447 000019D6 C3                          ret
  3448                                  
  3449                                  ; Función para imprimir los labels
  3450                                  print_labels:
  3451 000019D7 55                          push rbp
  3452 000019D8 4889E5                      mov rbp, rsp
  3453                                  
  3454                                      ; Crear buffer temporal
  3455 000019DB 4883EC20                    sub rsp, 32
  3456                                  
  3457                                      ; Copiar labels a buffer temporal
  3458 000019DF 4889E7                      mov rdi, rsp
  3459 000019E2 488D35(F3200000)            lea rsi, [score_label]
  3460 000019E9 B917000000                  mov rcx, score_label_len
  3461 000019EE F3A4                        rep movsb
  3462                                  
  3463                                      ; Convertir score a string
  3464 000019F0 488B05(3E200000)            mov rax, [current_score]
  3465 000019F7 48BF-                       mov rdi, number_buffer
  3465 000019F9 [4720000000000000] 
  3466 00001A01 E892FFFFFF                  call number_to_string
  3467                                  
  3468                                      ; Calcular longitud del número
  3469 00001A06 B900000000                  mov rcx, 0
  3470 00001A0B 48BF-                       mov rdi, number_buffer
  3470 00001A0D [4720000000000000] 
  3471                                      .count_loop:        ; Bucle para contar la longitud del número
  3472 00001A15 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3473 00001A19 7405                            je .count_done       ; Si es así, terminar
  3474 00001A1B 48FFC1                          inc rcx             ; Incrementar contador
  3475 00001A1E EBF5                            jmp .count_loop    ; Repetir el bucle
  3476                                      .count_done:      ; Conteo terminado
  3477                                  
  3478                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3479 00001A20 4889E7                      mov rdi, rsp      ; Inicializar RDI al buffer temporal
  3480 00001A23 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  3481 00001A27 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  3482 00001A2C 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  3483                                      .pad_loop:                 ; Bucle para añadir padding
  3484 00001A2F 4885F6                          test rsi, rsi       ; Verificar si terminamos
  3485 00001A32 740B                            jz .pad_done    ; Si es así, terminar
  3486 00001A34 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3487 00001A37 48FFC7                          inc rdi            ; Siguiente posición
  3488 00001A3A 48FFCE                          dec rsi           ; Decrementar contador
  3489 00001A3D EBF0                            jmp .pad_loop   ; Repetir el bucle
  3490                                      .pad_done:    ; Padding añadido
  3491                                  
  3492                                      ; Copiar el número
  3493 00001A3F 48BE-                       mov rsi, number_buffer  ; Inicializar RSI al número
  3493 00001A41 [4720000000000000] 
  3494 00001A49 F3A4                        rep movsb            ; Copiar el número al buffer temporal
  3495                                  
  3496                                      ; Imprimir el buffer completo   
  3497                                      print rsp, score_label_len  ; Imprimir el buffer
    93 00001A4B B801000000          <1>  mov eax, sys_write
    94 00001A50 BF01000000          <1>  mov edi, 1
    95 00001A55 4889E6              <1>  mov rsi, %1
    96 00001A58 BA17000000          <1>  mov edx, %2
    97 00001A5D 0F05                <1>  syscall
  3498                                  
  3499                                      ; Repetir proceso para bloques destruidos   
  3500 00001A5F 4889E7                      mov rdi, rsp    ; Inicializar RDI al buffer temporal
  3501 00001A62 488D35(0A210000)            lea rsi, [blocks_label] ; Inicializar RSI al label de bloques
  3502 00001A69 B91B000000                  mov rcx, blocks_label_len   ; Longitud del label
  3503 00001A6E F3A4                        rep movsb   ; Copiar el label al buffer temporal
  3504                                  
  3505                                      ; Verificar que el `[` esté en su posición correcta
  3506 00001A70 4889E7                      mov rdi, rsp
  3507 00001A73 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  3508 00001A77 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  3509                                  
  3510                                      ; Convertir bloques destruidos a string
  3511 00001A7A 480FB605(46200000)          movzx rax, byte [destroyed_blocks]  ; Obtener el número de bloques destruidos
  3512 00001A82 48BF-                       mov rdi, number_buffer      ; Convertir a string
  3512 00001A84 [4720000000000000] 
  3513 00001A8C E807FFFFFF                  call number_to_string   ; Convertir a string
  3514                                  
  3515                                      ; Calcular longitud del número
  3516 00001A91 B900000000                  mov rcx, 0
  3517 00001A96 48BF-                       mov rdi, number_buffer  ; Inicializar RDI al número
  3517 00001A98 [4720000000000000] 
  3518                                      .count_loop2:     ; Bucle para contar la longitud del número
  3519 00001AA0 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3520 00001AA4 7405                            je .count_done2   ; Si es así, terminar
  3521 00001AA6 48FFC1                          inc rcx          ; Incrementar contador
  3522 00001AA9 EBF5                            jmp .count_loop2    ; Repetir el bucle
  3523                                      .count_done2:   ; Conteo terminado
  3524                                  
  3525                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3526 00001AAB 4889E7                      mov rdi, rsp
  3527 00001AAE 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  3528 00001AB2 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  3529 00001AB7 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  3530                                      .pad_loop2:
  3531 00001ABA 4885F6                          test rsi, rsi    ; Verificar si terminamos
  3532 00001ABD 740B                            jz .pad_done2   ; Si es así, terminar
  3533 00001ABF C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3534 00001AC2 48FFC7                          inc rdi
  3535 00001AC5 48FFCE                          dec rsi
  3536 00001AC8 EBF0                            jmp .pad_loop2  ; Repetir el bucle
  3537                                      .pad_done2:
  3538                                  
  3539                                      ; Copiar el número
  3540 00001ACA 48BE-                       mov rsi, number_buffer
  3540 00001ACC [4720000000000000] 
  3541 00001AD4 F3A4                        rep movsb
  3542                                  
  3543                                      ; Imprimir el buffer completo
  3544                                      print rsp, blocks_label_len
    93 00001AD6 B801000000          <1>  mov eax, sys_write
    94 00001ADB BF01000000          <1>  mov edi, 1
    95 00001AE0 4889E6              <1>  mov rsi, %1
    96 00001AE3 BA1B000000          <1>  mov edx, %2
    97 00001AE8 0F05                <1>  syscall
  3545                                  
  3546                                      ; Restaurar stack
  3547 00001AEA 4883C420                    add rsp, 32     
  3548 00001AEE 5D                          pop rbp
  3549 00001AEF C3                          ret
  3550                                  
  3551                                  
  3552                                  
  3553                                  check_block_collision:  ; Función para verificar colisión con bloques
  3554 00001AF0 55                          push rbp              ; Guardar el puntero de la pila
  3555 00001AF1 4889E5                      mov rbp, rsp      ; Establecer el puntero de la pila
  3556                                  
  3557                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  3558 00001AF4 418A02                      mov al, [r10]
  3559                                  
  3560                                      ; Verificar si el carácter es un bloque
  3561 00001AF7 3C55                        cmp al, 'U'  
  3562 00001AF9 7419                        je .possible
  3563 00001AFB 3C4F                        cmp al, 'O'  
  3564 00001AFD 7415                        je .possible
  3565 00001AFF 3C44                        cmp al, 'D'  
  3566 00001B01 7411                        je .possible
  3567 00001B03 3C4C                        cmp al, 'L'  
  3568 00001B05 740D                        je .possible
  3569 00001B07 3C56                        cmp al, 'V'  
  3570 00001B09 7409                        je .possible
  3571 00001B0B 3C38                        cmp al, '8'  
  3572 00001B0D 7405                        je .possible
  3573                                  
  3574                                      ; No es bloque, salir
  3575 00001B0F 4831C0                      xor rax, rax
  3576 00001B12 5D                          pop rbp
  3577 00001B13 C3                          ret
  3578                                  
  3579                                  .possible:
  3580 00001B14 53                          push rbx
  3581 00001B15 57                          push rdi
  3582 00001B16 56                          push rsi
  3583 00001B17 4154                        push r12
  3584 00001B19 4155                        push r13
  3585 00001B1B 4156                        push r14
  3586 00001B1D 4157                        push r15
  3587                                  
  3588                                      ; 1) Obtener base de los bloques del nivel actual
  3589 00001B1F E83FFDFFFF                  call get_current_level_blocks
  3590 00001B24 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  3591                                  
  3592                                      ; 2) Obtener la cantidad de bloques
  3593 00001B27 E890FDFFFF                  call get_current_level_count
  3594 00001B2C 4989C6                      mov r14, rax
  3595                                  
  3596 00001B2F 4D31E4                      xor r12, r12  ; Índice del bloque actual
  3597                                  
  3598                                  .find_block_loop:
  3599 00001B32 4D39F4                      cmp r12, r14
  3600 00001B35 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  3601                                  
  3602                                      ; Calcular puntero base del bloque actual en levelX_blocks
  3603 00001B3B 4C89E0                      mov rax, r12
  3604 00001B3E 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  3605 00001B42 4C01E8                      add rax, r13
  3606 00001B45 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  3607                                  
  3608                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  3609 00001B48 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  3609 00001B4D [761F0000]         
  3610 00001B51 4885DB                      test rbx, rbx
  3611 00001B54 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  3612                                  
  3613                                      ; Obtener coordenadas
  3614 00001B5A 418A17                      mov dl, [r15]         ; x
  3615 00001B5D 418A4F01                    mov cl, [r15 + 1]     ; y
  3616                                  
  3617                                      ; Calcular posición en el board
  3618 00001B61 488D3D(400A0000)            lea rdi, [board]
  3619 00001B68 4831C0                      xor rax, rax
  3620 00001B6B B850000000                  mov rax, column_cells
  3621 00001B70 4883C002                    add rax, 2
  3622 00001B74 480FB6C9                    movzx rcx, cl         ; y
  3623 00001B78 480FAFC1                    imul rax, rcx
  3624 00001B7C 4801C7                      add rdi, rax
  3625 00001B7F 480FB6C2                    movzx rax, dl         ; x
  3626 00001B83 4801C7                      add rdi, rax
  3627                                  
  3628                                      ; Guardar la posición base del bloque
  3629 00001B86 57                          push rdi
  3630                                  
  3631                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  3632 00001B87 4939FA                      cmp r10, rdi
  3633 00001B8A 7274                        jb .skip_collision
  3634 00001B8C 488D5F06                    lea rbx, [rdi + block_length]
  3635 00001B90 4939DA                      cmp r10, rbx
  3636 00001B93 736B                        jae .skip_collision
  3637                                  
  3638                                      ; ------- Hay colisión, reducir durabilidad en block_states
  3639 00001B95 41FE8C24[761F0000]          dec byte [block_states + r12]
  3640                                      ; Volver a cargar durabilidad
  3641 00001B9D 490FB69C24-                 movzx rbx, byte [block_states + r12]
  3641 00001BA2 [761F0000]         
  3642 00001BA6 4885DB                      test rbx, rbx
  3643 00001BA9 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  3644                                  
  3645                                      ; >>> Llegó a 0 => Bloque destruido
  3646 00001BAB 5F                          pop rdi  ; recuperar puntero base del bloque en board
  3647 00001BAC B906000000                  mov rcx, block_length
  3648                                  .clear_loop:
  3649 00001BB1 C60720                      mov byte [rdi], ' '
  3650 00001BB4 48FFC7                      inc rdi
  3651 00001BB7 E2F8                        loop .clear_loop
  3652                                  
  3653                                      ; Dibujar letra del bloque destruido
  3654 00001BB9 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  3655 00001BBD 4883EF06                    sub rdi, block_length
  3656 00001BC1 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  3657                                      ; Después de escribir la letra en el tablero
  3658 00001BC3 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  3659 00001BC7 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  3660 00001BCB 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  3661 00001BD0 E8BBE8FFFF                  call register_letter
  3662                                      ; Actualizar contadores globales
  3663 00001BD5 FE0D(7A150000)              dec byte [blocks_remaining]
  3664 00001BDB FE05(46200000)              inc byte [destroyed_blocks]
  3665                                  
  3666                                      ; Sumar puntos según el tipo
  3667 00001BE1 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  3668 00001BE6 486BC00A                    imul rax, 10
  3669 00001BEA 480105(3E200000)            add [current_score], rax
  3670                                  
  3671 00001BF1 B801000000                  mov rax, 1  ; colisión con destrucción
  3672 00001BF6 EB14                        jmp .end_pop
  3673                                  
  3674                                  .update_display:
  3675                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  3676 00001BF8 B801000000                  mov rax, 1  ; colisión con "rebote"  
  3677 00001BFD 5F                          pop rdi     ; pop que quedó pendiente
  3678 00001BFE EB0C                        jmp .end_pop
  3679                                  
  3680                                  .skip_collision:
  3681 00001C00 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  3682                                  .next_block:
  3683 00001C01 49FFC4                      inc r12
  3684 00001C04 E929FFFFFF                  jmp .find_block_loop
  3685                                  
  3686                                  .no_block_found:
  3687 00001C09 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  3688                                  
  3689                                  .end_pop:
  3690 00001C0C 415F                        pop r15
  3691 00001C0E 415E                        pop r14
  3692 00001C10 415D                        pop r13
  3693 00001C12 415C                        pop r12
  3694 00001C14 5E                          pop rsi
  3695 00001C15 5F                          pop rdi
  3696 00001C16 5B                          pop rbx
  3697 00001C17 5D                          pop rbp
  3698 00001C18 C3                          ret
  3699                                  
  3700                                  
  3701                                  
  3702                                  init_enemies:   ; Función para inicializar los enemigos
  3703 00001C19 55                          push rbp    
  3704 00001C1A 4889E5                      mov rbp, rsp
  3705                                      
  3706                                      ; Reiniciar contadores de movimiento
  3707 00001C1D C605(89200000)00            mov byte [enemy_move_total], 0
  3708 00001C24 C605(8A200000)00            mov byte [enemy_target], 0
  3709                                      
  3710                                      ; Limpiar completamente el array de enemigos
  3711 00001C2B B91E000000                  mov rcx, 30  ; 10 enemigos * 3 bytes cada uno
  3712 00001C30 488D3D(60200000)            lea rdi, [enemies]
  3713 00001C37 30C0                        xor al, al
  3714 00001C39 F3AA                        rep stosb    ; Llenar todo con ceros
  3715                                      
  3716                                      ; Marcar todos los spawns como no activados
  3717 00001C3B 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3718 00001C42 B90A000000                  mov rcx, 10 ; 10 spawns
  3719 00001C47 F3AA                        rep stosb   ; Llenar con ceros
  3720                                      
  3721 00001C49 5D                          pop rbp
  3722 00001C4A C3                          ret
  3723                                  
  3724                                  
  3725                                  random_move_enemy:  ; Función para mover un enemigo aleatoriamente
  3726 00001C4B 55                          push rbp        ; Guardar el puntero de la pila
  3727 00001C4C 4889E5                      mov  rbp, rsp
  3728 00001C4F 53                          push rbx
  3729 00001C50 52                          push rdx
  3730 00001C51 57                          push rdi
  3731                                  
  3732                                      ; r12 = índice del enemigo
  3733                                      ; 1) obtener puntero al enemigo i
  3734 00001C52 4C89E0                      mov rax, r12
  3735 00001C55 486BC003                    imul rax, 3                ; Cada enemigo ocupa 3 bytes
  3736 00001C59 488D98[60200000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  3737                                  
  3738                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  3739 00001C60 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  3740 00001C64 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  3741                                  
  3742                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  3743 00001C69 480FB605(87200000)          movzx rax, byte [enemy_move_counter]
  3744 00001C71 4883E003                    and rax, 3  ; rax = [enemy_move_counter] & 3
  3745                                  
  3746 00001C75 4883F800                    cmp rax, 0  ; si es 0 => mover abajo
  3747 00001C79 741B                        je .try_left    ; si es 1 => mover izquierda
  3748 00001C7B 4883F801                    cmp rax, 1  ; si es 1 => mover izquierda
  3749 00001C7F 7410                        je .try_right   ; si es 2 => mover derecha
  3750 00001C81 4883F802                    cmp rax, 2  ; si es 2 => mover derecha
  3751 00001C85 7405                        je .try_up
  3752                                      ; si es 3 => mover abajo
  3753                                  .try_down:
  3754 00001C87 49FFC1                      inc r9  ; mover abajo
  3755 00001C8A EB0D                        jmp .check_valid    ; saltar a la verificación de validez
  3756                                  
  3757                                  .try_up:    ; mover arriba
  3758 00001C8C 49FFC9                      dec r9  ; mover arriba
  3759 00001C8F EB08                        jmp .check_valid    ; saltar a la verificación de validez
  3760                                  
  3761                                  .try_right:   ; mover derecha
  3762 00001C91 49FFC0                      inc r8  ; mover derecha
  3763 00001C94 EB03                        jmp .check_valid
  3764                                  
  3765                                  .try_left:
  3766 00001C96 49FFC8                      dec r8
  3767                                  
  3768                                  .check_valid:
  3769                                      ; 4) Verificar límites
  3770 00001C99 4983F801                    cmp r8, 1                    
  3771 00001C9D 0F8EA4000000                jle .invalid_move
  3772 00001CA3 4983F850                    cmp r8, column_cells        
  3773 00001CA7 0F8D9A000000                jge .invalid_move
  3774 00001CAD 4983F901                    cmp r9, 1                    
  3775 00001CB1 0F8E90000000                jle .invalid_move
  3776 00001CB7 4983F920                    cmp r9, row_cells          
  3777 00001CBB 0F8D86000000                jge .invalid_move
  3778                                  
  3779                                      ; 5) Verificar colisión con bloques/enemigos
  3780 00001CC1 4150                        push r8
  3781 00001CC3 4151                        push r9
  3782 00001CC5 B850000000                  mov rax, column_cells       ; rax = column_cells
  3783 00001CCA 4883C002                    add rax, 2                ; rax = column_cells + 2
  3784 00001CCE 49F7E1                      mul r9                  ; rax = (column_cells + 2) * r9
  3785 00001CD1 4C01C0                      add rax, r8             ; rax = (column_cells + 2) * r9 + r8
  3786 00001CD4 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * r9 + r8]
  3787 00001CDB 8A07                        mov al, [rdi]        ; al = board[(column_cells + 2) * r9 + r8]
  3788                                  
  3789                                      ; Revisa si es bloque o borde
  3790 00001CDD 3C55                        cmp al, 'U'
  3791 00001CDF 7462                        je .pop_and_invalid
  3792 00001CE1 3C4F                        cmp al, 'O'
  3793 00001CE3 745E                        je .pop_and_invalid
  3794 00001CE5 3C44                        cmp al, 'D'
  3795 00001CE7 745A                        je .pop_and_invalid
  3796 00001CE9 3C4C                        cmp al, 'L'
  3797 00001CEB 7456                        je .pop_and_invalid
  3798 00001CED 3C56                        cmp al, 'V'
  3799 00001CEF 7452                        je .pop_and_invalid
  3800 00001CF1 3C38                        cmp al, '8'
  3801 00001CF3 744E                        je .pop_and_invalid
  3802 00001CF5 3C58                        cmp al, 'X'
  3803 00001CF7 744A                        je .pop_and_invalid
  3804                                  
  3805                                      ; Revisa si hay enemigo
  3806 00001CF9 3C40                        cmp al, '@'
  3807 00001CFB 7446                        je .pop_and_invalid
  3808 00001CFD 3C23                        cmp al, '#'
  3809 00001CFF 7442                        je .pop_and_invalid
  3810 00001D01 3C24                        cmp al, '$'
  3811 00001D03 743E                        je .pop_and_invalid
  3812 00001D05 3C26                        cmp al, '&'
  3813 00001D07 743A                        je .pop_and_invalid
  3814                                  
  3815 00001D09 E808030000                  call check_enemy_at_position
  3816 00001D0E 4883F801                    cmp rax, 1
  3817 00001D12 742F                        je .pop_and_invalid
  3818                                  
  3819                                      ; ------------------------------
  3820                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3821                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3822                                      ; ------------------------------
  3823 00001D14 4159                        pop r9
  3824 00001D16 4158                        pop r8
  3825                                  
  3826                                      ; (A) Borrar la posición antigua en el board
  3827                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3828 00001D18 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3829 00001D1C 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3830 00001D21 B850000000                  mov rax, column_cells
  3831 00001D26 4883C002                    add rax, 2              ; rax = column_cells + 2
  3832 00001D2A 49F7E3                      mul r11                ; rax = (column_cells + 2) * oldY
  3833 00001D2D 4C01D0                      add rax, r10
  3834 00001D30 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * oldY + oldX]
  3835 00001D37 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3836                                  
  3837                                      ; (B) Guardar la nueva X,Y en la estructura
  3838 00001D3A 448803                      mov byte [rbx], r8b
  3839 00001D3D 44884B01                    mov byte [rbx + 1], r9b
  3840                                  
  3841 00001D41 EB0D                        jmp .done
  3842                                  
  3843                                  .pop_and_invalid:
  3844 00001D43 4159                        pop r9
  3845 00001D45 4158                        pop r8
  3846                                  
  3847                                  .invalid_move:
  3848                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3849 00001D47 4C0FB603                    movzx r8, byte [rbx]
  3850 00001D4B 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3851                                      ; Se queda donde estaba
  3852                                  .done:
  3853 00001D50 5F                          pop rdi
  3854 00001D51 5A                          pop rdx
  3855 00001D52 5B                          pop rbx
  3856 00001D53 5D                          pop rbp
  3857 00001D54 C3                          ret
  3858                                  
  3859                                  
  3860                                  ; Función para mover enemigos
  3861                                  move_enemies:   ; Mover enemigos
  3862 00001D55 55                          push rbp    ; Guardar el puntero de la pila
  3863 00001D56 4889E5                      mov rbp, rsp    ; Establecer el puntero de la pila
  3864                                      
  3865                                      ; Incrementar contador de movimiento
  3866 00001D59 FE05(87200000)              inc byte [enemy_move_counter]   ; Incrementar el contador de movimiento
  3867 00001D5F 480FB605(87200000)          movzx rax, byte [enemy_move_counter]    ; rax = enemy_move_counter
  3868 00001D67 3A05(88200000)              cmp al, [enemy_move_delay]  ; Verificar si es hora de mover
  3869 00001D6D 0F85A1020000                jne .end
  3870                                      
  3871                                      ; Resetear contador
  3872 00001D73 C605(87200000)00            mov byte [enemy_move_counter], 0
  3873                                      
  3874 00001D7A 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3875                                      
  3876                                      .enemy_loop:
  3877 00001D7D 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3878 00001D81 0F8D8D020000                    jge .end                    ; Si ya movimos todos los enemigos, terminar
  3879                                          
  3880                                          ; Calcular offset del enemigo actual
  3881 00001D87 4C89E0                          mov rax, r12                ; rax = r12
  3882 00001D8A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3883 00001D8E 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[r12]
  3884                                          
  3885                                          ; Verificar si el enemigo está activo
  3886 00001D95 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si el enemigo está activo
  3887 00001D99 0F856D020000                    jne .next_enemy        ; Si no está activo, pasar al siguiente enemigo
  3888                                          
  3889                                          ; Obtener posición actual
  3890 00001D9F 4C0FB606                        movzx r8, byte [rsi]            ; X
  3891 00001DA3 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3892                                          
  3893 00001DA8 488D3D(40240000)                lea rdi, [enemy_last_x]        ; rdi = &enemy_last_x
  3894 00001DAF 4C01E7                          add rdi, r12            ; rdi = &enemy_last_x[r12]
  3895 00001DB2 8A07                            mov al, [rdi]             ; al = last_x
  3896                                  
  3897 00001DB4 488D15(4A240000)                lea rdx, [enemy_last_y]       ; rdx = &enemy_last_y
  3898 00001DBB 4C01E2                          add rdx, r12        ; rdx = &enemy_last_y[r12]
  3899 00001DBE 8A22                            mov ah, [rdx]             ; ah = last_y
  3900                                  
  3901                                          ; r8 = X actual del enemigo
  3902                                          ; r9 = Y actual del enemigo
  3903                                  
  3904                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3905 00001DC0 88E2                            mov dl, ah      ; dl = old_Y
  3906 00001DC2 4488CB                          mov bl, r9b     ; bl = new_Y
  3907 00001DC5 38DA                            cmp dl, bl    ; Comparar Y
  3908 00001DC7 752C                            jne .not_stuck      ; Si son diferentes, no está pegado
  3909                                  
  3910                                          ; => SI son iguales => pasa al siguiente check
  3911 00001DC9 88C2                            mov dl, al      ; dl = old_X
  3912 00001DCB 4488C3                          mov bl, r8b     ; bl = new_X
  3913 00001DCE 38DA                            cmp dl, bl  ; Comparar X
  3914 00001DD0 7523                            jne .not_stuck    ; Si son diferentes, no está pegado
  3915                                  
  3916                                          ; => MISMA POSICIÓN (STUCK)
  3917 00001DD2 488D1D(54240000)                lea rbx, [enemy_stuck_count]    ; rbx = &enemy_stuck_count
  3918 00001DD9 4C01E3                          add rbx, r12        ; rbx = &enemy_stuck_count[r12]
  3919 00001DDC FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3920                                  
  3921                                          ; Verificar si supera umbral, digamos 3
  3922 00001DDE 480FB60B                        movzx rcx, byte [rbx]    ; rcx = stuck_count
  3923 00001DE2 4883F902                        cmp rcx, 2      ; Si llega a 3, forzar movimiento aleatorio
  3924 00001DE6 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3925                                  
  3926                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3927                                          ;  1) resetear el stuck_count
  3928 00001DE8 C60300                          mov byte [rbx], 0
  3929                                  
  3930                                          ;  2) cambiar random
  3931 00001DEB E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3932 00001DF0 E917020000                      jmp .next_enemy 
  3933                                  
  3934                                      .not_stuck:
  3935                                          ; => Se movió
  3936 00001DF5 488D1D(54240000)                lea rbx, [enemy_stuck_count]
  3937 00001DFC 4C01E3                          add rbx, r12    ; rbx = &enemy_stuck_count[r12]
  3938 00001DFF C60300                          mov byte [rbx], 0            ; Resetear
  3939                                  
  3940                                          ; Guardar su nueva posición en “last_x, last_y”
  3941 00001E02 488D3D(40240000)                lea rdi, [enemy_last_x]
  3942 00001E09 4C01E7                          add rdi, r12    ; rdi = &enemy_last_x[r12]
  3943 00001E0C 448807                          mov [rdi], r8b      ; Guardar X
  3944                                          
  3945 00001E0F 488D3D(4A240000)                lea rdi, [enemy_last_y]
  3946 00001E16 4C01E7                          add rdi, r12
  3947 00001E19 44880F                          mov [rdi], r9b
  3948                                  
  3949                                          ; Limpiar posición actual antes de mover
  3950                                      .check_normal_move:
  3951 00001E1C 4150                            push r8
  3952 00001E1E 4151                            push r9
  3953 00001E20 B850000000                      mov rax, column_cells    ; rax = column_cells
  3954 00001E25 4883C002                        add rax, 2            ; rax = column_cells + 2
  3955 00001E29 49F7E1                          mul r9            ; rax = (column_cells + 2) * Y
  3956 00001E2C 4C01C0                          add rax, r8       ; rax = (column_cells + 2) * Y + X
  3957 00001E2F 488DB8[400A0000]                lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  3958 00001E36 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3959 00001E39 4159                            pop r9          ; Recuperar Y
  3960 00001E3B 4158                            pop r8      ; Restaurar X, Y
  3961                                  
  3962                                          ; Determinar comportamiento basado en índice
  3963 00001E3D 4C89E0                          mov rax, r12
  3964 00001E40 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3965 00001E44 4885C0                          test rax, rax
  3966 00001E47 7405                            jz .chase_ball
  3967 00001E49 E996000000                      jmp .chase_paddle             ; Si es 1, perseguir paleta
  3968                                          
  3969                                          ; Perseguir bola (comportamiento original)
  3970                                      .chase_ball:
  3971                                          ; Primero intentar con la bola principal
  3972 00001E4E 803D(00150000)01                cmp byte [ball_active], 1
  3973 00001E55 7414                            je .use_ball1
  3974                                          
  3975                                          ; Si no está activa, probar con ball2
  3976 00001E57 803D(22150000)01                cmp byte [ball2_active], 1
  3977 00001E5E 7414                            je .use_ball2
  3978                                          
  3979                                          ; Si no está activa, probar con ball3
  3980 00001E60 803D(44150000)01                cmp byte [ball3_active], 1
  3981 00001E67 7414                            je .use_ball3
  3982                                          
  3983                                          ; Si no hay bolas activas, perseguir la paleta
  3984 00001E69 EB79                            jmp .chase_paddle
  3985                                  
  3986                                      .use_ball1:
  3987 00001E6B 4C8B15(DF140000)                mov r10, [ball_x_pos]   ; r10 = ball_x_pos
  3988 00001E72 EB12                            jmp .compare_positions
  3989                                  
  3990                                      .use_ball2:         
  3991 00001E74 4C8B15(01150000)                mov r10, [ball2_x_pos]
  3992 00001E7B EB09                            jmp .compare_positions
  3993                                  
  3994                                      .use_ball3:
  3995 00001E7D 4C8B15(23150000)                mov r10, [ball3_x_pos]
  3996 00001E84 EB00                            jmp .compare_positions
  3997                                  
  3998                                      .compare_positions:
  3999                                          ; Comparar X
  4000 00001E86 4D39D0                          cmp r8, r10
  4001 00001E89 0F8FCA000000                    jg .move_left
  4002 00001E8F 0F8CC9000000                    jl .move_right
  4003                                          
  4004                                          ; Si llegamos aquí, las X son iguales
  4005                                          ; Ahora comparar Y según qué bola estemos siguiendo
  4006 00001E95 803D(00150000)01                cmp byte [ball_active], 1
  4007 00001E9C 7417                            je .check_ball1_y
  4008 00001E9E 803D(22150000)01                cmp byte [ball2_active], 1
  4009 00001EA5 7417                            je .check_ball2_y
  4010 00001EA7 803D(44150000)01                cmp byte [ball3_active], 1
  4011 00001EAE 7417                            je .check_ball3_y
  4012 00001EB0 E9D4000000                      jmp .check_collision
  4013                                  
  4014                                      .check_ball1_y:
  4015 00001EB5 4C8B15(E7140000)                mov r10, [ball_y_pos]
  4016 00001EBC EB12                            jmp .compare_y
  4017                                  
  4018                                      .check_ball2_y:
  4019 00001EBE 4C8B15(09150000)                mov r10, [ball2_y_pos]
  4020 00001EC5 EB09                            jmp .compare_y
  4021                                  
  4022                                      .check_ball3_y:
  4023 00001EC7 4C8B15(2B150000)                mov r10, [ball3_y_pos]
  4024 00001ECE EB00                            jmp .compare_y
  4025                                  
  4026                                      .compare_y:
  4027 00001ED0 4D39D1                          cmp r9, r10
  4028 00001ED3 0F8F8A000000                    jg .move_up
  4029 00001ED9 0F8C89000000                    jl .move_down
  4030 00001EDF E9A5000000                      jmp .check_collision
  4031                                          
  4032                                      .chase_paddle:
  4033                                          ; Obtener la posición X actual de la paleta
  4034 00001EE4 4C8B15(BF140000)                mov r10, [pallet_position]
  4035 00001EEB 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  4036                                          
  4037                                          ; Calcular la posición X real de la paleta
  4038 00001EF2 4C89D0                          mov rax, r10
  4039 00001EF5 BB50000000                      mov rbx, column_cells
  4040 00001EFA 4883C302                        add rbx, 2                  ; Añadir newline chars
  4041 00001EFE 4831D2                          xor rdx, rdx
  4042 00001F01 48F7F3                          div rbx                     ; rax = y, rdx = x
  4043                                          
  4044                                          ; rdx ahora contiene la posición X de la paleta
  4045                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  4046 00001F04 488B0D(C7140000)                mov rcx, [pallet_size]
  4047 00001F0B 48D1E9                          shr rcx, 1                  ; Dividir por 2
  4048 00001F0E 4801CA                          add rdx, rcx
  4049                                          
  4050                                          ; Comparar con posición X del enemigo y mover gradualmente
  4051 00001F11 4939D0                          cmp r8, rdx
  4052 00001F14 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  4053 00001F16 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  4054 00001F18 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  4055                                  
  4056                                      .check_y_paddle:
  4057                                          ; La Y de la paleta siempre es row_cells - 2
  4058 00001F1A 41BA20000000                    mov r10, row_cells
  4059 00001F20 4983EA02                        sub r10, 2
  4060                                          
  4061                                          ; Comparar con posición Y del enemigo y mover gradualmente
  4062 00001F24 4D39D1                          cmp r9, r10
  4063 00001F27 7404                            je .no_movement            ; Si está en la misma Y, no mover
  4064 00001F29 7F38                            jg .move_up               ; Si está abajo, mover arriba
  4065 00001F2B 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  4066                                          
  4067                                      .no_movement:
  4068 00001F2D EB5A                            jmp .check_collision
  4069                                  
  4070                                      ; También agregar una nueva sección para el movimiento suave
  4071                                      .smooth_transition:
  4072                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  4073 00001F2F 8A05(8A200000)                  mov al, [enemy_target]
  4074 00001F35 84C0                            test al, al
  4075 00001F37 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  4076                                          
  4077                                          ; Verificar distancia en X
  4078 00001F39 4989D2                          mov r10, rdx              ; Posición X objetivo
  4079 00001F3C 4D29C2                          sub r10, r8               ; Calcular diferencia
  4080 00001F3F 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  4081 00001F43 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  4082 00001F45 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  4083 00001F49 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  4084 00001F4B EB3C                            jmp .check_collision
  4085                                          
  4086                                      .limit_right_movement:
  4087 00001F4D 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  4088 00001F51 EB36                            jmp .check_collision
  4089                                          
  4090                                      .limit_left_movement:
  4091 00001F53 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  4092 00001F57 EB30                            jmp .check_collision
  4093                                      .move_left:
  4094 00001F59 49FFC8                          dec r8
  4095 00001F5C EB0F                            jmp .check_vertical
  4096                                          
  4097                                      .move_right:
  4098 00001F5E 49FFC0                          inc r8
  4099 00001F61 EB0A                            jmp .check_vertical
  4100                                          
  4101                                      .move_up:
  4102 00001F63 49FFC9                          dec r9
  4103 00001F66 EB21                            jmp .check_collision
  4104                                          
  4105                                      .move_down:
  4106 00001F68 49FFC1                          inc r9
  4107 00001F6B EB1C                            jmp .check_collision
  4108                                          
  4109                                      .check_vertical:
  4110 00001F6D 8A05(8A200000)                  mov al, [enemy_target]
  4111 00001F73 84C0                            test al, al
  4112 00001F75 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  4113 00001F7B 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  4114 00001F82 4D39D1                          cmp r9, r10
  4115 00001F85 7FDC                            jg .move_up
  4116 00001F87 7CDF                            jl .move_down
  4117                                          
  4118                                      .check_collision:
  4119                                          ; Verificar colisión con bordes
  4120 00001F89 4983F801                        cmp r8, 1                       ; Borde izquierdo
  4121 00001F8D 7E7D                            jle .next_enemy
  4122 00001F8F 4983F850                        cmp r8, column_cells
  4123 00001F93 7D77                            jge .next_enemy
  4124 00001F95 4983F901                        cmp r9, 1                       ; Borde superior
  4125 00001F99 7E71                            jle .next_enemy
  4126 00001F9B 4983F920                        cmp r9, row_cells
  4127 00001F9F 7D6B                            jge .next_enemy
  4128                                          
  4129                                          ; Verificar colisión con bloques antes de moverse
  4130 00001FA1 4150                            push r8
  4131 00001FA3 4151                            push r9
  4132 00001FA5 4152                            push r10
  4133                                          
  4134                                          ; Calcular posición en el tablero para verificar
  4135 00001FA7 B850000000                      mov rax, column_cells
  4136 00001FAC 4883C002                        add rax, 2
  4137 00001FB0 49F7E1                          mul r9
  4138 00001FB3 4C01C0                          add rax, r8
  4139 00001FB6 4C8D90[400A0000]                lea r10, [board + rax]
  4140                                          
  4141                                          ; Verificar si hay un bloque en la nueva posición
  4142 00001FBD 418A02                          mov al, [r10]
  4143 00001FC0 3C55                            cmp al, 'U'
  4144 00001FC2 7442                            je .invalid_move
  4145 00001FC4 3C4F                            cmp al, 'O'
  4146 00001FC6 743E                            je .invalid_move
  4147 00001FC8 3C44                            cmp al, 'D'
  4148 00001FCA 743A                            je .invalid_move
  4149 00001FCC 3C4C                            cmp al, 'L'
  4150 00001FCE 7436                            je .invalid_move
  4151 00001FD0 3C56                            cmp al, 'V'
  4152 00001FD2 7432                            je .invalid_move
  4153 00001FD4 3C38                            cmp al, '8'
  4154 00001FD6 742E                            je .invalid_move
  4155 00001FD8 3C58                            cmp al, 'X'
  4156 00001FDA 742A                            je .invalid_move
  4157 00001FDC 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  4158 00001FDE 7426                            je .invalid_move
  4159 00001FE0 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  4160 00001FE2 7422                            je .invalid_move
  4161 00001FE4 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  4162 00001FE6 741E                            je .invalid_move
  4163 00001FE8 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  4164 00001FEA 741A                            je .invalid_move
  4165                                          
  4166 00001FEC E825000000                      call check_enemy_at_position
  4167 00001FF1 4883F801                        cmp rax, 1
  4168 00001FF5 740F                            je .invalid_move
  4169 00001FF7 415A                            pop r10
  4170 00001FF9 4159                            pop r9
  4171 00001FFB 4158                            pop r8
  4172                                          
  4173                                          ; Guardar nueva posición si es válida
  4174 00001FFD 448806                          mov [rsi], r8b
  4175 00002000 44884E01                        mov [rsi + 1], r9b
  4176 00002004 EB06                            jmp .next_enemy
  4177                                          
  4178                                      .invalid_move:
  4179 00002006 415A                            pop r10
  4180 00002008 4159                            pop r9
  4181 0000200A 4158                            pop r8
  4182                                          
  4183                                      .next_enemy:
  4184 0000200C 49FFC4                          inc r12
  4185 0000200F E969FDFFFF                      jmp .enemy_loop
  4186                                          
  4187                                      .end:
  4188 00002014 5D                              pop rbp
  4189 00002015 C3                              ret
  4190                                  
  4191                                  check_enemy_at_position:    ; Función para verificar si hay un enemigo en una posición
  4192 00002016 55                          push rbp
  4193 00002017 4889E5                      mov rbp, rsp
  4194                                      
  4195                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  4196 0000201A B850000000                  mov rax, column_cells
  4197 0000201F 4883C002                    add rax, 2
  4198 00002023 49F7E1                      mul r9                ; rax = (column_cells + 2) * Y
  4199 00002026 4C01C0                      add rax, r8   ; rax = (column_cells + 2) * Y + X
  4200 00002029 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  4201 00002030 480FB607                    movzx rax, byte [rdi]   ; rax = board[(column_cells + 2) * Y + X]
  4202                                      
  4203                                      ; Verificar todos los caracteres de enemigos
  4204 00002034 3C40                        cmp al, '@'
  4205 00002036 7411                        je .enemy_found
  4206 00002038 3C23                        cmp al, '#'
  4207 0000203A 740D                        je .enemy_found
  4208 0000203C 3C24                        cmp al, '$'
  4209 0000203E 7409                        je .enemy_found
  4210 00002040 3C26                        cmp al, '&'
  4211 00002042 7405                        je .enemy_found
  4212                                      
  4213 00002044 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  4214 00002047 EB05                        jmp .end
  4215                                      
  4216                                  .enemy_found:
  4217 00002049 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  4218                                      
  4219                                  .end:
  4220 0000204E 5D                          pop rbp
  4221 0000204F C3                          ret
  4222                                  
  4223                                  get_current_spawn_points:   ; Función para obtener los puntos de spawn del nivel actual
  4224 00002050 55                          push rbp
  4225 00002051 4889E5                      mov rbp, rsp
  4226                                      
  4227 00002054 480FB605(79150000)          movzx rax, byte [current_level] ; Obtener nivel actual
  4228 0000205C 48FFC8                      dec rax                         ; Ajustar para índice base 0
  4229 0000205F 488B04C5[BE200000]          mov rax, [spawn_points_table + rax * 8] ; Obtener puntero a puntos de spawn
  4230                                      
  4231 00002067 5D                          pop rbp
  4232 00002068 C3                          ret
  4233                                  
  4234                                  ; Función para verificar si debe aparecer un nuevo enemigo
  4235                                  check_enemy_spawn:  ; Verificar si debe aparecer un nuevo enemigo
  4236 00002069 55                          push rbp                ; Guardar el puntero de la pila
  4237 0000206A 4889E5                      mov rbp, rsp        ; Establecer el puntero de la pila
  4238                                      
  4239                                      ; Obtener spawn points del nivel actual
  4240 0000206D E8DEFFFFFF                  call get_current_spawn_points
  4241 00002072 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  4242                                      
  4243                                      ; Obtener cantidad de bloques destruidos
  4244 00002075 4C0FB62D(46200000)          movzx r13, byte [destroyed_blocks]
  4245                                      
  4246                                      ; Verificar cada punto de spawn
  4247 0000207D 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  4248                                      
  4249                                      .check_loop:
  4250 00002080 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  4251 00002084 7D4E                            jge .end
  4252                                          
  4253                                          ; Verificar si este spawn point ya fue usado
  4254 00002086 80B9[E9200000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  4255 0000208D 7440                            je .next_enemy
  4256                                          
  4257                                          ; Verificar si este enemigo ya está activo
  4258 0000208F 4889C8                          mov rax, rcx
  4259 00002092 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4260 00002096 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[rcx]
  4261 0000209D 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  4262 000020A1 742C                            je .next_enemy
  4263                                          
  4264                                          ; Verificar si debemos spawnear este enemigo
  4265 000020A3 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  4266 000020A8 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  4267 000020AB 7522                            jne .next_enemy               ; Si no coincide, pasar al siguiente
  4268                                          
  4269                                          ; Marcar este spawn point como usado
  4270 000020AD C681[E9200000]01                mov byte [enemy_spawns_triggered + rcx], 1  ; Marcar como usado
  4271                                  
  4272                                          ; Spawner nuevo enemigo
  4273 000020B4 B004                            mov al, 4                   ; Nivel de X
  4274 000020B6 00C8                            add al, cl       ; con 'rcx' como índice
  4275 000020B8 8806                            mov [rsi], al            ; X
  4276 000020BA C6460101                        mov byte [rsi+1], 1    ; Y
  4277 000020BE C6460201                        mov byte [rsi+2], 1   ; Activar enemigo
  4278                                  
  4279                                          ; Inicializar comportamiento
  4280 000020C2 4889C8                          mov rax, rcx            ; rax = rcx
  4281 000020C5 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  4282 000020C9 8805(E8200000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  4283                                          
  4284                                      .next_enemy:
  4285 000020CF 48FFC1                          inc rcx
  4286 000020D2 EBAC                            jmp .check_loop
  4287                                          
  4288                                      .end:
  4289 000020D4 5D                              pop rbp
  4290 000020D5 C3                              ret
  4291                                  
  4292                                  
  4293                                  ; Función para dibujar enemigos
  4294                                  print_enemies:
  4295 000020D6 55                          push rbp
  4296 000020D7 4889E5                      mov rbp, rsp
  4297                                      
  4298 000020DA 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4299                                      
  4300                                      .print_loop:
  4301 000020DD 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  4302 000020E1 7D4B                            jge .end
  4303                                          
  4304                                          ; Calcular offset del enemigo actual
  4305 000020E3 4C89E0                          mov rax, r12
  4306 000020E6 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4307 000020EA 488DB0[60200000]                lea rsi, [enemies + rax]
  4308                                          
  4309                                          ; Verificar si el enemigo está activo
  4310 000020F1 807E0201                        cmp byte [rsi + 2], 1
  4311 000020F5 7532                            jne .next_enemy
  4312                                          
  4313                                          ; Calcular posición en el tablero
  4314 000020F7 4C0FB606                        movzx r8, byte [rsi]            ; X
  4315 000020FB 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  4316                                          
  4317                                          ; Calcular offset en el tablero
  4318 00002100 B850000000                      mov rax, column_cells
  4319 00002105 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  4320 00002109 49F7E1                          mul r9                        ; rax = (column_cells + 2) * Y
  4321 0000210C 4C01C0                          add rax, r8                    ; rax = (column_cells + 2) * Y + X
  4322 0000210F 488DB8[400A0000]                lea rdi, [board + rax]
  4323                                          
  4324                                          ; Obtener carácter del enemigo según el nivel
  4325 00002116 480FB605(79150000)              movzx rax, byte [current_level]
  4326 0000211E 48FFC8                          dec rax                         ; Ajustar para índice base 0
  4327 00002121 8A80[5B200000]                  mov al, [enemy_chars + rax]
  4328                                          
  4329                                          ; Dibujar enemigo
  4330 00002127 8807                            mov [rdi], al
  4331                                          
  4332                                      .next_enemy:
  4333 00002129 49FFC4                          inc r12
  4334 0000212C EBAF                            jmp .print_loop
  4335                                          
  4336                                      .end:
  4337 0000212E 5D                              pop rbp
  4338 0000212F C3                              ret
  4339                                  
  4340                                  ; Función para verificar colisión con enemigos
  4341                                  check_enemy_collision:  ; Verificar colisión con enemigos
  4342 00002130 55                          push rbp
  4343 00002131 4889E5                      mov rbp, rsp
  4344                                      
  4345 00002134 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4346 00002137 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  4347                                      
  4348                                      .check_loop:
  4349 0000213A 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  4350 0000213E 0F8DE9000000                    jge .end
  4351                                          
  4352                                          ; Calcular offset del enemigo actual
  4353 00002144 4C89E1                          mov rcx, r12
  4354 00002147 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  4355 0000214B 488DB1[60200000]                lea rsi, [enemies + rcx]
  4356                                          
  4357                                          ; Verificar si el enemigo está activo
  4358 00002152 807E0201                        cmp byte [rsi + 2], 1
  4359 00002156 0F85C9000000                    jne .next_enemy
  4360                                          
  4361                                          ; Verificar colisión con la bola
  4362 0000215C 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  4363 00002160 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  4364                                          
  4365                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  4366 00002165 4C8B15(DF140000)                mov r10, [ball_x_pos]
  4367 0000216C 4C8B1D(E7140000)                mov r11, [ball_y_pos]        ; Posición de la bola
  4368                                          
  4369                                          ; Comprobar colisión vertical (misma columna)
  4370 00002173 4D39C2                          cmp r10, r8
  4371 00002176 7525                            jne .check_horizontal     ; Si no está en la misma columna, verificar horizontal
  4372 00002178 4D29CB                          sub r11, r9         ; Calcular diferencia de Y
  4373 0000217B 4983FB01                        cmp r11, 1              ; Si la bola está justo arriba del enemigo
  4374 0000217F 7F1C                            jg .check_horizontal    ; Si está más arriba, verificar horizontal
  4375 00002181 4983FBFF                        cmp r11, -1
  4376 00002185 7C16                            jl .check_horizontal    ; Si está más abajo, verificar horizontal
  4377                                          
  4378                                          ; Colisión vertical detectada   
  4379 00002187 E8A3000000                      call destroy_enemy      ; Destruir el enemigo
  4380 0000218C 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  4381 00002193 B801000000                      mov rax, 1
  4382 00002198 E990000000                      jmp .end
  4383                                          
  4384                                      .check_horizontal:      
  4385                                          ; Comprobar colisión horizontal (misma fila)
  4386 0000219D 4C8B15(DF140000)                mov r10, [ball_x_pos]     ; Posición de la bola
  4387 000021A4 4C8B1D(E7140000)                mov r11, [ball_y_pos]   ; Posición de la bola
  4388 000021AB 4D39CB                          cmp r11, r9            ; Comparar Y de la bola con Y del enemigo
  4389 000021AE 7522                            jne .check_paddle   ; Si no están en la misma fila, verificar con la paleta
  4390 000021B0 4D29C2                          sub r10, r8        ; Calcular diferencia de X
  4391 000021B3 4983FA01                        cmp r10, 1        ; Si la bola está justo a la izquierda del enemigo
  4392 000021B7 7F19                            jg .check_paddle    ; Si está más a la izquierda, verificar con la paleta
  4393 000021B9 4983FAFF                        cmp r10, -1      ; Si la bola está justo a la derecha del enemigo
  4394 000021BD 7C13                            jl .check_paddle    ; Si está más a la derecha, verificar con la paleta
  4395                                          
  4396                                          ; Colisión horizontal detectada
  4397 000021BF E86B000000                      call destroy_enemy    ; Destruir el enemigo
  4398 000021C4 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  4399 000021CB B801000000                      mov rax, 1          ; Indicar que hubo colisión
  4400 000021D0 EB5B                            jmp .end        ; Terminar
  4401                                  
  4402                                      .check_paddle:
  4403                                          ; Verificar colisión con la paleta
  4404 000021D2 4C8B15(BF140000)                mov r10, [pallet_position]  ; Posición de la paleta
  4405 000021D9 4981EA[400A0000]                sub r10, board            ; Convertir a offset relativo
  4406 000021E0 4C89D0                          mov rax, r10          ; rax = r10
  4407 000021E3 41BB50000000                    mov r11, column_cells   ; r11 = column_cells
  4408 000021E9 4983C302                        add r11, 2          ; r11 = column_cells + 2
  4409 000021ED 4831D2                          xor rdx, rdx    ; rdx = 0
  4410 000021F0 49F7F3                          div r11                     ; División para obtener la posición Y
  4411 000021F3 4989D3                          mov r11, rdx               ; X de la paleta en r11
  4412                                          
  4413 000021F6 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  4414                                          
  4415                                          ; Verificar si el enemigo está en la misma fila que la paleta
  4416 000021FD 41BD20000000                    mov r13, row_cells
  4417 00002203 4983ED02                        sub r13, 2                 ; Y de la paleta
  4418 00002207 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  4419 0000220A 7519                            jne .next_enemy
  4420                                          
  4421                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  4422 0000220C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  4423 0000220F 7C14                            jl .next_enemy
  4424                                          
  4425 00002211 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  4426 00002214 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  4427 00002217 7F0C                            jg .next_enemy
  4428                                          
  4429                                          ; Si llegamos aquí, hay colisión con la paleta
  4430 00002219 E811000000                      call destroy_enemy        ; Destruir el enemigo
  4431 0000221E B801000000                      mov rax, 1                ; Indicar que hubo colisión
  4432 00002223 EB08                            jmp .end
  4433                                          
  4434                                      .next_enemy:
  4435 00002225 49FFC4                          inc r12
  4436 00002228 E90DFFFFFF                      jmp .check_loop   ; Verificar el siguiente enemigo
  4437                                          
  4438                                      .end:
  4439 0000222D 5D                              pop rbp
  4440 0000222E C3                              ret
  4441                                  
  4442                                  ; Función para destruir un enemigo
  4443                                  destroy_enemy:
  4444                                      ; Desactivar enemigo
  4445 0000222F C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  4446                                  
  4447                                      ; Sumar puntos por destruir enemigo
  4448 00002233 488B05(7F200000)            mov rax, [enemy_points]
  4449 0000223A 480105(3E200000)            add [current_score], rax
  4450                                  
  4451                                      ; No tocar bloques destruidos aquí
  4452 00002241 C3                          ret
  4453                                  
  4454                                  
  4455                                  _start:   
  4456 00002242 E8E4DEFFFF              	call canonical_off  ; Desactivar modo canónico
  4457 00002247 E857010000              	call start_screen   ; Mostrar pantalla de inicio
  4458 0000224C E8F8F2FFFF                  call init_level    ; Inicializar el nivel
  4459 00002251 EB00                    	jmp .main_loop    ; Saltar al bucle principal
  4460                                  	
  4461                                  
  4462                                      .main_loop:     ; Bucle principal
  4463 00002253 E87FF7FFFF                      call print_labels   ; Imprimir etiquetas
  4464 00002258 E8AEF6FFFF                      call print_blocks   ; Imprimir bloques
  4465 0000225D E8FFE2FFFF                      call move_letters   ; Mover letras
  4466 00002262 E8E5E5FFFF                      call update_lasers          ; Actualizar láseres
  4467 00002267 E86AE2FFFF                      call print_letters  ; Imprimir letras
  4468 0000226C E8E9E9FFFF                      call print_pallet   ; Imprimir paleta
  4469                                          
  4470                                          ; Mover bola principal solo si está activa
  4471 00002271 803D(00150000)01                cmp byte [ball_active], 1
  4472 00002278 7505                            jne .skip_ball1
  4473 0000227A E8F2EAFFFF                          call move_ball
  4474                                          .skip_ball1:
  4475                                  
  4476                                          ; Mover bola 2 si está activa
  4477 0000227F 803D(22150000)01                cmp byte [ball2_active], 1
  4478 00002286 7505                            jne .skip_ball2
  4479 00002288 E8B7ECFFFF                          call move_ball_2
  4480                                          .skip_ball2:
  4481                                  
  4482                                          ; Mover bola 3 si está activa
  4483 0000228D 803D(44150000)01                cmp byte [ball3_active], 1
  4484 00002294 7505                            jne .skip_ball3
  4485 00002296 E87CEEFFFF                          call move_ball_3
  4486                                          .skip_ball3:
  4487                                  
  4488 0000229B E856E0FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  4489 000022A0 E838DFFFFF                      call print_lives
  4490                                  
  4491                                          ; Imprimir solo las bolas activas
  4492 000022A5 803D(00150000)01                cmp byte [ball_active], 1
  4493 000022AC 7505                            jne .no_pb1
  4494 000022AE E82FE9FFFF                          call print_ball
  4495                                          .no_pb1:
  4496                                  
  4497 000022B3 803D(22150000)01                cmp byte [ball2_active], 1
  4498 000022BA 7505                            jne .no_pb2
  4499 000022BC E849E9FFFF                          call print_ball_2
  4500                                          .no_pb2:
  4501                                  
  4502 000022C1 803D(44150000)01                cmp byte [ball3_active], 1
  4503 000022C8 7505                            jne .no_pb3
  4504 000022CA E863E9FFFF                          call print_ball_3
  4505                                          .no_pb3:
  4506                                  
  4507 000022CF E866F4FFFF                      call check_level_complete
  4508 000022D4 E890FDFFFF                      call check_enemy_spawn
  4509 000022D9 E877FAFFFF                      call move_enemies
  4510 000022DE E84DFEFFFF                      call check_enemy_collision
  4511 000022E3 E8EEFDFFFF                      call print_enemies
  4512 000022E8 E8D3E4FFFF                      call print_power_label
  4513                                  		print board, board_size				
    93 000022ED B801000000          <1>  mov eax, sys_write
    94 000022F2 BF01000000          <1>  mov edi, 1
    95 000022F7 48BE-               <1>  mov rsi, %1
    95 000022F9 [400A000000000000]  <1>
    96 00002301 BA400A0000          <1>  mov edx, %2
    97 00002306 0F05                <1>  syscall
  4514                                  		;setnonblocking	
  4515                                  	.read_more:	    
  4516                                  	    getchar	    ; Leer una tecla
   101 00002308 B800000000          <1>  mov rax, sys_read
   102 0000230D BF00000000          <1>  mov rdi, STDIN_FILENO
   103 00002312 48BE-               <1>  mov rsi, input_char
   103 00002314 [0000000000000000]  <1>
   104 0000231C BA01000000          <1>  mov rdx, 1
   105 00002321 0F05                <1>  syscall
  4517 00002323 4883F801                	    cmp rax, 1  ; Verificar si se presionó una tecla
  4518 00002327 7547                    	    jne .done   ; Si no se presionó ninguna tecla, terminar
  4519                                  	
  4520 00002329 8A05(00000000)          	    mov al, [input_char]
  4521 0000232F 8805(08230000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  4522                                  	
  4523 00002335 3C61                    	    cmp al, 'a'            ; Verificar si se presionó la tecla 'a'
  4524 00002337 750E                    	    jne .not_left       ; Si no se presionó, verificar si se presionó 'd'
  4525 00002339 48C7C7FFFFFFFF          	    mov rdi, left_direction    ; Si sí, mover la paleta a la izquierda
  4526 00002340 E84AE9FFFF              	    call move_pallet    ; Mover la paleta
  4527 00002345 EB29                    	    jmp .done        ; Terminar
  4528                                  	
  4529                                      .not_left:  
  4530 00002347 3C64                    	    cmp al, 'd'           ; Verificar si se presionó la tecla 'd'
  4531 00002349 750C                    	    jne .not_right    ; Si no se presionó, verificar si se presionó 'c'
  4532 0000234B BF01000000              	    mov rdi, right_direction    ; Si sí, mover la paleta a la derecha
  4533 00002350 E83AE9FFFF              	    call move_pallet    ; Mover la paleta
  4534 00002355 EB19                    	    jmp .done     ; Terminar
  4535                                  	
  4536                                      .not_right:
  4537 00002357 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  4538 00002359 740E                    	    je .release_ball        ; Si sí, liberar la bola
  4539                                  	
  4540 0000235B 3C78                            cmp al, 'x'             ; Verificar si se presionó la tecla 'c'
  4541 0000235D 740A                    	    je .release_ball        ; Si sí, liberar la bola
  4542                                  	
  4543                                  
  4544 0000235F 3C71                    	    cmp al, 'q' 
  4545 00002361 0F84AF000000            	    je exit
  4546 00002367 EB9F                    	    jmp .read_more
  4547                                  	
  4548                                      .release_ball:
  4549 00002369 E87CEFFFFF              	    call process_catch_release
  4550 0000236E EB00                    	    jmp .done
  4551                                  	
  4552                                      .done:
  4553                                  	    sleeptime
   109 00002370 B823000000          <1>  mov eax, sys_nanosleep
   110 00002375 48BF-               <1>  mov rdi, timespec
   110 00002377 [0000000000000000]  <1>
   111 0000237F 31F6                <1>  xor esi, esi
   112 00002381 0F05                <1>  syscall
  4554                                  	    print clear, clear_length
    93 00002383 B801000000          <1>  mov eax, sys_write
    94 00002388 BF01000000          <1>  mov edi, 1
    95 0000238D 48BE-               <1>  mov rsi, %1
    95 0000238F [1000000000000000]  <1>
    96 00002397 BA07000000          <1>  mov edx, %2
    97 0000239C 0F05                <1>  syscall
  4555 0000239E E9B0FEFFFF              	    jmp .main_loop
  4556                                  
  4557                                  
  4558                                  
  4559                                  
  4560                                  start_screen:
  4561                                      print clear, clear_length    ; Limpiamos la pantalla primero
    93 000023A3 B801000000          <1>  mov eax, sys_write
    94 000023A8 BF01000000          <1>  mov edi, 1
    95 000023AD 48BE-               <1>  mov rsi, %1
    95 000023AF [1000000000000000]  <1>
    96 000023B7 BA07000000          <1>  mov edx, %2
    97 000023BC 0F05                <1>  syscall
  4562                                      print msg1, msg1_length
    93 000023BE B801000000          <1>  mov eax, sys_write
    94 000023C3 BF01000000          <1>  mov edi, 1
    95 000023C8 48BE-               <1>  mov rsi, %1
    95 000023CA [1700000000000000]  <1>
    96 000023D2 BA14010000          <1>  mov edx, %2
    97 000023D7 0F05                <1>  syscall
  4563                                      
  4564                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  4565                                          getchar                 ; Esperamos una tecla
   101 000023D9 B800000000          <1>  mov rax, sys_read
   102 000023DE BF00000000          <1>  mov rdi, STDIN_FILENO
   103 000023E3 48BE-               <1>  mov rsi, input_char
   103 000023E5 [0000000000000000]  <1>
   104 000023ED BA01000000          <1>  mov rdx, 1
   105 000023F2 0F05                <1>  syscall
  4566 000023F4 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  4567 000023F8 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  4568                                          
  4569                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    93 000023FA B801000000          <1>  mov eax, sys_write
    94 000023FF BF01000000          <1>  mov edi, 1
    95 00002404 48BE-               <1>  mov rsi, %1
    95 00002406 [1000000000000000]  <1>
    96 0000240E BA07000000          <1>  mov edx, %2
    97 00002413 0F05                <1>  syscall
  4570 00002415 C3                          ret
  4571                                  
  4572                                  exit: 
  4573 00002416 E852DDFFFF              	call canonical_on
  4574 0000241B B83C000000              	mov    rax, 60
  4575 00002420 BF00000000                  mov    rdi, 0
  4576 00002425 0F05                        syscall
  4577                                  
