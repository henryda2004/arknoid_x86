     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 3A07030244                      db 58, 7, 3, 2, 'D'    ; Bloque 7
   288 000014AB 3D09030145                      db 61, 9, 3, 1, 'E'    ; Bloque 7
   289 000014B0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014BA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014C4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 0000152D 0000000000000000            current_score dq 0          ; Score actual
   319 00001535 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 00001536 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 0000154A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 0000154F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 0000156D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 0000156E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 00001576 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001577 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   333 00001578 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001579 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 0000157A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 0000157B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 00001584 12                 
   339 00001585 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 0000158E 13                 
   340 0000158F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001598 1B                 
   341 00001599 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 000015A2 1C                 
   342 000015A3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015AC 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015AD [7B15000000000000]              dq level1_spawn_points
   346 000015B5 [8515000000000000]              dq level2_spawn_points
   347 000015BD [8F15000000000000]              dq level3_spawn_points
   348 000015C5 [9915000000000000]              dq level4_spawn_points
   349 000015CD [A315000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015D5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015D6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015E2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015EB 5B2020202020202020-
   357 000015F4 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F9 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 00001602 657374727569646F73-
   359 0000160B 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365                                      
   366                                      ; Definición de las vidas (x, y, estado)
   367                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   368                                      lives_data: 
   369 00001614 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   370 00001617 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   371 0000161A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   372 0000161D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   373 00001620 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   374 00001623 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   375 00001626 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   376                                      lives_count equ 7    ; Total de vidas
   377 00001629 5E                          life_char db "^"    
   378 0000162A 07                          current_lives db 7   ; Contador de vidas activas actual
   379                                  
   380                                  ; Estructura para almacenar las letras y sus posiciones
   381                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   382 0000162B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   383 000017BB 00                          letters_count db 0   
   384 000017BC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   385 000017BD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   385 000017C6 75616C3A205B205D0A-
   385 000017CF 0D                 
   386                                      last_letter_msg_len equ $ - last_letter_msg
   387                                  section .text
   388                                  
   389                                  ;	Function: print_ball
   390                                  ; This function displays the position of the ball
   391                                  ; Arguments: none
   392                                  ;
   393                                  ; Return:
   394                                  ;	Void
   395                                  
   396                                  ; Función para imprimir las vidas
   397                                  ; Función modificada para imprimir las vidas
   398                                  print_lives:
   399 000001DD 55                          push rbp
   400 000001DE 4889E5                      mov rbp, rsp
   401                                      
   402 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   403                                      
   404                                      .print_loop:
   405 000001E4 4983FC07                        cmp r12, lives_count
   406 000001E8 7D45                            jge .end
   407                                          
   408                                          ; Calcular offset de la vida actual
   409 000001EA 4C89E0                          mov rax, r12
   410 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   411 000001F1 488DB0[14160000]                lea rsi, [lives_data + rax]
   412                                          
   413                                          ; Calcular posición en el tablero
   414 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   415 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   416                                          
   417                                          ; Calcular offset en el tablero
   418 00000201 B84E000000                      mov rax, column_cells
   419 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   420 0000020A 49F7E1                          mul r9
   421 0000020D 4C01C0                          add rax, r8
   422 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   423                                          
   424                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   425 00000217 807E0201                        cmp byte [rsi + 2], 1
   426 0000021B 7405                            je .draw_active
   427                                          
   428                                          ; Si está inactiva, dibujar espacio
   429 0000021D C60720                          mov byte [rdi], ' '
   430 00000220 EB08                            jmp .next_life
   431                                          
   432                                      .draw_active:
   433                                          ; Si está activa, dibujar el símbolo de vida
   434 00000222 8A05(29160000)                  mov al, [life_char]
   435 00000228 8807                            mov [rdi], al
   436                                          
   437                                      .next_life:
   438 0000022A 49FFC4                          inc r12
   439 0000022D EBB5                            jmp .print_loop
   440                                          
   441                                      .end:
   442 0000022F 5D                              pop rbp
   443 00000230 C3                              ret
   444                                  
   445                                  ; Función para desactivar una vida
   446                                  ; Función modificada para perder una vida
   447                                  lose_life:
   448 00000231 55                          push rbp
   449 00000232 4889E5                      mov rbp, rsp
   450                                      
   451                                      ; Verificar si aún quedan vidas
   452 00000235 803D(2A160000)00            cmp byte [current_lives], 0
   453 0000023C 0F8493000000                je .game_lost
   454                                      
   455                                      ; Encontrar la última vida activa
   456 00000242 B907000000                  mov rcx, lives_count
   457 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   458                                      
   459                                      .find_active_life:
   460 0000024A 4889C8                          mov rax, rcx
   461 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   462 00000251 488DB0[14160000]                lea rsi, [lives_data + rax]
   463 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   464 0000025C 7407                            je .deactivate_life
   465 0000025E 48FFC9                          dec rcx
   466 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   467 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   468                                          
   469                                      .deactivate_life:
   470                                          ; Calcular posición correcta en el tablero para borrar la vida
   471 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   472 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   473                                          
   474                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   475 0000026E B84E000000                      mov rax, column_cells
   476 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   477 00000277 49F7E1                          mul r9
   478 0000027A 4C01C0                          add rax, r8
   479 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   480                                          
   481                                          ; Borrar visualmente la vida
   482 00000284 C60720                          mov byte [rdi], ' '             
   483                                          
   484                                          ; Desactivar la vida en los datos
   485 00000287 C6460200                        mov byte [rsi + 2], 0          
   486 0000028B FE0D(2A160000)                  dec byte [current_lives]
   487                                          
   488                                          ; Borrar visualmente la paleta anterior
   489 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   490 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   491                                          .erase_pallet_loop:
   492 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   493 000002A3 49FFC0                              inc r8
   494 000002A6 48FFC9                              dec rcx
   495 000002A9 75F4                                jnz .erase_pallet_loop
   496                                          
   497                                  
   498                                          ; Reiniciar posición de la bola y la paleta
   499 000002AB 48C705(4F140000)28-             mov qword [ball_x_pos], 40
   499 000002B3 000000             
   500 000002B6 48C705(57140000)1C-             mov qword [ball_y_pos], 28
   500 000002BE 000000             
   501 000002C1 C605(6F140000)00                mov byte [ball_moving], 0
   502 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   502 000002CF [36130000]         
   503                                          
   504 000002D3 EB07                            jmp .end
   505                                          
   506                                      .game_lost:
   507 000002D5 E81C000000                      call game_lost
   508 000002DA EB00                            jmp .end
   509                                          
   510                                      .end:
   511 000002DC 5D                              pop rbp
   512 000002DD C3                              ret
   513                                  ; Función modificada para verificar colisión con el borde inferior
   514                                  check_bottom_collision:
   515 000002DE 55                          push rbp
   516 000002DF 4889E5                      mov rbp, rsp
   517                                      
   518                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   519 000002E2 488B05(57140000)            mov rax, [ball_y_pos]
   520 000002E9 4883F81E                    cmp rax, row_cells - 2
   521 000002ED 7505                        jne .no_collision
   522                                      
   523                                      ; Si hay colisión, perder una vida
   524 000002EF E83DFFFFFF                  call lose_life
   525                                      
   526                                      .no_collision:
   527 000002F4 5D                              pop rbp
   528 000002F5 C3                              ret
   529                                  
   530                                  ; Nueva función para game over
   531                                  game_lost:
   532                                      ; Limpiar la pantalla
   533                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   534                                      
   535                                      ; Mostrar mensaje de derrota
   536                                      section .data
   537 000017D0 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   537 000017D9 6469646F210A0D     
   538                                          lost_msg_len: equ $ - lost_msg
   539                                      section .text
   540                                      
   541                                      ; Imprimir mensaje de derrota
   542                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [D017000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   543                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [FE17000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   544                                      
   545                                      ; Mostrar puntaje final
   546 00000347 488B05(2D150000)            mov rax, [current_score]
   547 0000034E 48BF-                       mov rdi, number_buffer
   547 00000350 [3615000000000000] 
   548 00000358 E821080000                  call number_to_string
   549                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [3615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   550                                      
   551                                      ; Esperar un momento antes de salir
   552 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   552 00000381 0000               
   553 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   553 0000038C 0000               
   554                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   555                                      
   556 000003A1 E9B60F0000                  jmp exit
   557                                  
   558                                  
   559                                  ; Función para registrar una nueva letra en el mapa
   560                                  ; Entrada:
   561                                  ;   al - letra a registrar
   562                                  ;   r8b - posición x
   563                                  ;   r9b - posición y
   564                                  register_letter:
   565 000003A6 55                          push rbp
   566 000003A7 4889E5                      mov rbp, rsp
   567 000003AA 53                          push rbx
   568 000003AB 51                          push rcx
   569                                      
   570 000003AC 3C20                        cmp al, ' '
   571 000003AE 7438                        je .end
   572                                  
   573                                      ; Encontrar un espacio libre en el mapa
   574 000003B0 4831C9                      xor rcx, rcx
   575 000003B3 480FB615(BB170000)          movzx rdx, byte [letters_count]
   576                                      
   577                                      .find_slot:
   578 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   579 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   580                                          
   581 000003C1 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   582 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   583 000003CD 7405                            je .found_slot
   584                                          
   585 000003CF 48FFC1                          inc rcx
   586 000003D2 EBE7                            jmp .find_slot
   587                                          
   588                                      .found_slot:
   589                                          ; Guardar la información de la letra
   590 000003D4 448803                          mov [rbx], r8b           ; x
   591 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   592 000003DB 884302                          mov [rbx + 2], al        ; letra
   593 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   594                                          
   595 000003E2 FE05(BB170000)                  inc byte [letters_count]
   596                                          
   597                                      .end:
   598 000003E8 59                              pop rcx
   599 000003E9 5B                              pop rbx
   600 000003EA 5D                              pop rbp
   601 000003EB C3                              ret
   602                                  
   603                                  ; Función para imprimir todas las letras registradas
   604                                  print_letters:
   605 000003EC 55                          push rbp
   606 000003ED 4889E5                      mov rbp, rsp
   607 000003F0 53                          push rbx
   608 000003F1 51                          push rcx
   609                                      
   610 000003F2 4831C9                      xor rcx, rcx
   611                                      
   612                                      .print_loop:
   613 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   614 000003F9 7D37                            jge .end
   615                                          
   616                                          ; Obtener puntero a la letra actual
   617 000003FB 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   618                                          
   619                                          ; Verificar si está activa
   620 00000403 807B0300                        cmp byte [rbx + 3], 0
   621 00000407 7424                            je .next_letter
   622                                          
   623                                          ; Calcular posición en el tablero
   624 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   625 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   626                                          
   627                                          ; Calcular offset en el tablero
   628 00000412 B84E000000                      mov rax, column_cells
   629 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   630 0000041B 49F7E1                          mul r9
   631 0000041E 4C01C0                          add rax, r8
   632 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   633                                          
   634                                          ; Imprimir la letra
   635 00000428 8A4302                          mov al, [rbx + 2]
   636 0000042B 8807                            mov [rdi], al
   637                                          
   638                                      .next_letter:
   639 0000042D 48FFC1                          inc rcx
   640 00000430 EBC3                            jmp .print_loop
   641                                          
   642                                      .end:
   643 00000432 59                              pop rcx
   644 00000433 5B                              pop rbx
   645 00000434 5D                              pop rbp
   646 00000435 C3                              ret
   647                                  
   648                                  ; Función para borrar una letra específica
   649                                  ; Entrada:
   650                                  ;   r8b - posición x
   651                                  ;   r9b - posición y
   652                                  remove_letter:
   653 00000436 55                          push rbp
   654 00000437 4889E5                      mov rbp, rsp
   655 0000043A 53                          push rbx
   656 0000043B 51                          push rcx
   657                                      
   658 0000043C 4831C9                      xor rcx, rcx
   659                                      
   660                                      .find_loop:
   661 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   662 00000443 7D2E                            jge .end
   663                                          
   664 00000445 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   665                                          
   666                                          ; Verificar si está activa y coincide la posición
   667 0000044D 807B0300                        cmp byte [rbx + 3], 0
   668 00000451 741B                            je .next_letter
   669                                          
   670 00000453 8A03                            mov al, [rbx]
   671 00000455 4438C0                          cmp al, r8b
   672 00000458 7514                            jne .next_letter
   673                                          
   674 0000045A 8A4301                          mov al, [rbx + 1]
   675 0000045D 4438C8                          cmp al, r9b
   676 00000460 750C                            jne .next_letter
   677                                          
   678                                          ; Encontrada la letra, desactivarla
   679 00000462 C6430300                        mov byte [rbx + 3], 0
   680 00000466 FE0D(BB170000)                  dec byte [letters_count]
   681 0000046C EB05                            jmp .end
   682                                          
   683                                      .next_letter:
   684 0000046E 48FFC1                          inc rcx
   685 00000471 EBCC                            jmp .find_loop
   686                                          
   687                                      .end:
   688 00000473 59                              pop rcx
   689 00000474 5B                              pop rbx
   690 00000475 5D                              pop rbp
   691 00000476 C3                              ret
   692                                  ; Función para mover las letras hacia abajo
   693                                  move_letters:
   694 00000477 55                          push rbp
   695 00000478 4889E5                      mov rbp, rsp
   696 0000047B 53                          push rbx
   697 0000047C 57                          push rdi
   698 0000047D 56                          push rsi
   699                                  
   700 0000047E 4831C9                      xor rcx, rcx                    ; Índice de la letra actual
   701                                  
   702                                      .move_loop:
   703 00000481 4883F964                        cmp rcx, 100                ; Máximo 100 letras
   704 00000485 0F8D80000000                    jge .print_last_letter      ; Al terminar, mostrar la última letra
   705                                          
   706                                          ; Obtener puntero a la letra actual
   707 0000048B 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   708                                  
   709                                          ; Verificar si la letra está activa
   710 00000493 807B0300                        cmp byte [rbx + 3], 0
   711 00000497 746A                            je .next_letter
   712                                  
   713                                          ; Obtener la posición actual de la letra
   714 00000499 4C0FB603                        movzx r8, byte [rbx]        ; X
   715 0000049D 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; Y
   716                                  
   717                                          ; Calcular la posición en el tablero para borrar la letra anterior
   718 000004A2 B84E000000                      mov rax, column_cells
   719 000004A7 4883C002                        add rax, 2                  ; Incluye caracteres de nueva línea
   720 000004AB 49F7E1                          mul r9
   721 000004AE 4C01C0                          add rax, r8
   722 000004B1 488DB8[000A0000]                lea rdi, [board + rax]
   723 000004B8 C60720                          mov byte [rdi], ' '         ; Borra la letra en la posición anterior
   724                                  
   725                                          ; Incrementar la posición Y de la letra
   726 000004BB FE4301                          inc byte [rbx + 1]
   727 000004BE 4C0FB64B01                      movzx r9, byte [rbx + 1]
   728                                  
   729                                          ; Verificar si la letra alcanzó el final del tablero
   730 000004C3 4983F91F                        cmp r9, row_cells - 1
   731 000004C7 7C06                            jl .check_pallet_collision
   732                                  
   733                                          ; Desactivar la letra si llega al final
   734 000004C9 C6430300                        mov byte [rbx + 3], 0
   735 000004CD EB34                            jmp .next_letter
   736                                  
   737                                          .check_pallet_collision:
   738                                              ; Calcular la nueva posición en el tablero
   739 000004CF B84E000000                          mov rax, column_cells
   740 000004D4 4883C002                            add rax, 2
   741 000004D8 49F7E1                              mul r9
   742 000004DB 4C01C0                              add rax, r8
   743 000004DE 488DB8[000A0000]                    lea rdi, [board + rax]
   744                                  
   745                                              ; Verificar si hay colisión con la paleta (símbolo =)
   746 000004E5 8A07                                mov al, [rdi]
   747 000004E7 3C20                                cmp al, ' '
   748 000004E9 7418                                je .next_letter
   749 000004EB 3C3D                                cmp al, char_equal
   750 000004ED 7407                                je .capture_letter
   751                                  
   752                                              ; Si no hay colisión, dibujar la letra
   753 000004EF 8A4302                              mov al, [rbx + 2]
   754 000004F2 8807                                mov [rdi], al
   755 000004F4 EB0D                                jmp .next_letter
   756                                  
   757                                          .capture_letter:
   758                                              ; Guardar la letra capturada
   759 000004F6 8A4302                              mov al, [rbx + 2]       ; Obtener la letra
   760 000004F9 8805(BC170000)                      mov [last_letter], al   ; Guardarla como última letra capturada
   761                                              
   762                                              ; Desactivar la letra
   763 000004FF C6430300                            mov byte [rbx + 3], 0
   764                                  
   765                                          .next_letter:
   766 00000503 48FFC1                              inc rcx
   767 00000506 E976FFFFFF                          jmp .move_loop
   768                                  
   769                                      .print_last_letter:
   770                                          ; Imprimir el mensaje con la última letra
   771                                          print last_letter_msg, last_letter_msg_len - 3  ; Imprimir hasta antes del salto de línea
    82 0000050B B801000000          <1>  mov eax, sys_write
    83 00000510 BF01000000          <1>  mov edi, 1
    84 00000515 48BE-               <1>  mov rsi, %1
    84 00000517 [BD17000000000000]  <1>
    85 0000051F BA10000000          <1>  mov edx, %2
    86 00000524 0F05                <1>  syscall
   772                                          
   773                                          ; Imprimir la última letra
   774 00000526 8A05(BC170000)                  mov al, [last_letter]
   775 0000052C 8805(CC170000)                  mov [last_letter_msg + 15], al  ; Colocar la letra en el espacio entre corchetes
   776                                          
   777                                          ; Imprimir el salto de línea
   778                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000532 B801000000          <1>  mov eax, sys_write
    83 00000537 BF01000000          <1>  mov edi, 1
    84 0000053C 48BE-               <1>  mov rsi, %1
    84 0000053E [CD17000000000000]  <1>
    85 00000546 BA03000000          <1>  mov edx, %2
    86 0000054B 0F05                <1>  syscall
   779                                  
   780                                      .end:
   781 0000054D 5E                              pop rsi
   782 0000054E 5F                              pop rdi
   783 0000054F 5B                              pop rbx
   784 00000550 5D                              pop rbp
   785 00000551 C3                              ret
   786                                  
   787                                  print_ball:
   788 00000552 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   789 00000559 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   790 00000560 4981C0[000A0000]        	add r8, board
   791                                  
   792 00000567 4C89C9                  	mov rcx, r9
   793 0000056A B850000000              	mov rax, column_cells + 2
   794 0000056F 48F7E9                  	imul rcx
   795                                  	
   796 00000572 4901C0                  	add r8, rax
   797 00000575 41C6004F                	mov byte [r8], char_O
   798 00000579 C3                      	ret
   799                                  
   800                                  	
   801                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   802                                  	
   803                                  
   804                                  
   805                                  
   806                                  ;	Function: print_pallet
   807                                  ; This function moves the pallet in the game
   808                                  ; Arguments: none
   809                                  ;
   810                                  ; Return;
   811                                  ;	void
   812                                  print_pallet:
   813 0000057A 4C8B05(3F140000)        	mov r8, [pallet_position]
   814 00000581 488B0D(47140000)        	mov rcx, [pallet_size]
   815                                  	.write_pallet:
   816 00000588 41C6003D                		mov byte [r8], char_equal
   817 0000058C 49FFC0                  		inc r8
   818 0000058F 48FFC9                  		dec rcx
   819 00000592 75F4                    		jnz .write_pallet
   820                                  
   821 00000594 C3                      	ret
   822                                  	
   823                                  ;	Function: move_pallet
   824                                  ; This function is in charge of moving the pallet in a given direction
   825                                  ; Arguments:
   826                                  ;	rdi: left direction or right direction
   827                                  ;
   828                                  ; Return:
   829                                  ;	void
   830                                  move_pallet:
   831                                      
   832 00000595 803D(6F140000)00            cmp byte [ball_moving], 0
   833 0000059C 7507                        jne .continue_movement
   834 0000059E C605(6F140000)01            mov byte [ball_moving], 1
   835                                  
   836                                      .continue_movement:
   837 000005A5 4883FFFF                        cmp rdi, left_direction
   838 000005A9 7531                            jne .move_right
   839                                  
   840                                          .move_left:
   841                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   842 000005AB 4C8B05(3F140000)                    mov r8, [pallet_position]
   843 000005B2 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   844 000005B5 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   845 000005B8 3C58                                cmp al, 'X'        ; Comparar si es una X
   846 000005BA 744D                                je .end            ; Si es X, no mover
   847                                              
   848 000005BC 4C8B05(3F140000)                    mov r8, [pallet_position]
   849 000005C3 4C8B0D(47140000)                    mov r9, [pallet_size]
   850 000005CA 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   851 000005D0 49FFC8                              dec r8
   852 000005D3 4C8905(3F140000)                    mov [pallet_position], r8
   853 000005DA EB2D                                jmp .end
   854                                              
   855                                          .move_right:
   856                                              ; Verificar si la siguiente posición después de la paleta sería una X
   857 000005DC 4C8B05(3F140000)                    mov r8, [pallet_position]
   858 000005E3 4C8B0D(47140000)                    mov r9, [pallet_size]
   859 000005EA 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   860 000005ED 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   861 000005F0 3C58                                cmp al, 'X'        ; Comparar si es una X
   862 000005F2 7415                                je .end            ; Si es X, no mover
   863                                              
   864 000005F4 4C8B05(3F140000)                    mov r8, [pallet_position]
   865 000005FB 41C60020                            mov byte [r8], char_space
   866 000005FF 49FFC0                              inc r8
   867 00000602 4C8905(3F140000)                    mov [pallet_position], r8
   868                                          .end:
   869 00000609 C3                                  ret
   870                                  
   871                                  move_ball:
   872                                      ; Si la bola no está en movimiento, no hacer nada
   873 0000060A 803D(6F140000)00            cmp byte [ball_moving], 0
   874 00000611 0F8406010000                je .end
   875                                  
   876                                      ; Borrar la posición actual de la bola
   877 00000617 4C8B05(4F140000)            mov r8, [ball_x_pos]
   878 0000061E 4C8B0D(57140000)            mov r9, [ball_y_pos]
   879 00000625 4981C0[000A0000]            add r8, board
   880 0000062C 4C89C9                      mov rcx, r9
   881 0000062F B850000000                  mov rax, column_cells + 2
   882 00000634 48F7E9                      imul rcx
   883 00000637 4901C0                      add r8, rax
   884 0000063A 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   885                                  
   886                                      ; Calcular siguiente posición X
   887 0000063E 4C8B05(4F140000)            mov r8, [ball_x_pos]
   888 00000645 4C8B0D(57140000)            mov r9, [ball_y_pos]
   889 0000064C 488B05(5F140000)            mov rax, [ball_direction_x]
   890 00000653 4901C0                      add r8, rax                  ; Nueva posición X
   891                                  
   892                                      ; Calcular la dirección de memoria para la siguiente posición
   893 00000656 4D89C2                      mov r10, r8
   894 00000659 4981C2[000A0000]            add r10, board
   895 00000660 4C89C9                      mov rcx, r9
   896 00000663 B850000000                  mov rax, column_cells + 2
   897 00000668 48F7E9                      imul rcx
   898 0000066B 4901C2                      add r10, rax
   899                                  
   900                                      ; Verificar si hay una X en la siguiente posición X
   901 0000066E 418A02                      mov al, [r10]
   902 00000671 3C58                        cmp al, 'X'
   903 00000673 750C                        jne .check_block_x
   904 00000675 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   905 0000067C E99C000000                  jmp .end
   906                                  
   907                                      .check_block_x:
   908                                          ; Verificar colisión con bloques en X
   909 00000681 4150                            push r8     ; Guardar registros que usa check_block_collision
   910 00000683 4151                            push r9
   911 00000685 4152                            push r10
   912 00000687 E84A060000                      call check_block_collision
   913 0000068C 415A                            pop r10
   914 0000068E 4159                            pop r9
   915 00000690 4158                            pop r8
   916 00000692 4885C0                          test rax, rax
   917 00000695 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   918 00000697 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   919 0000069E EB7D                            jmp .end
   920                                  
   921                                      .check_paddle_x:
   922                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   923 000006A0 41803A3D                        cmp byte [r10], char_equal
   924 000006A4 7509                            jne .check_y_movement
   925 000006A6 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   926 000006AD EB6E                            jmp .end
   927                                  
   928                                      .check_y_movement:
   929                                          ; Calcular siguiente posición Y
   930 000006AF 488B05(67140000)                mov rax, [ball_direction_y]
   931 000006B6 4901C1                          add r9, rax                  ; Nueva posición Y
   932                                  
   933                                          ; Calcular la dirección de memoria para la siguiente posición Y
   934 000006B9 4D89C2                          mov r10, r8
   935 000006BC 4981C2[000A0000]                add r10, board
   936 000006C3 4C89C9                          mov rcx, r9
   937 000006C6 B850000000                      mov rax, column_cells + 2
   938 000006CB 48F7E9                          imul rcx
   939 000006CE 4901C2                          add r10, rax
   940                                  
   941                                          ; Verificar si hay una X en la siguiente posición Y
   942 000006D1 418A02                          mov al, [r10]
   943 000006D4 3C58                            cmp al, 'X'
   944 000006D6 7509                            jne .check_block_y
   945 000006D8 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   946 000006DF EB3C                            jmp .end
   947                                  
   948                                      .check_block_y:
   949                                          ; Verificar colisión con bloques en Y
   950 000006E1 4150                            push r8     ; Guardar registros que usa check_block_collision
   951 000006E3 4151                            push r9
   952 000006E5 4152                            push r10
   953 000006E7 E8EA050000                      call check_block_collision
   954 000006EC 415A                            pop r10
   955 000006EE 4159                            pop r9
   956 000006F0 4158                            pop r8
   957 000006F2 4885C0                          test rax, rax
   958 000006F5 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   959 000006F7 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   960 000006FE EB1D                            jmp .end
   961                                  
   962                                      .check_paddle_y:
   963                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   964 00000700 41803A3D                    cmp byte [r10], char_equal
   965 00000704 7509                        jne .update_position
   966 00000706 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   967 0000070D EB0E                        jmp .end
   968                                  
   969                                  
   970                                      .update_position:
   971 0000070F 4C8905(4F140000)                mov [ball_x_pos], r8
   972 00000716 4C890D(57140000)                mov [ball_y_pos], r9
   973                                  
   974                                      .end:
   975 0000071D C3                              ret
   976                                  
   977                                  ; Función para inicializar el nivel
   978                                  ; Función para inicializar el nivel
   979                                  ; Función para mostrar el número de nivel
   980                                  display_level_number:
   981 0000071E 55                          push rbp
   982 0000071F 4889E5                      mov rbp, rsp
   983                                      
   984                                      ; Limpiar la pantalla primero
   985                                      print clear, clear_length
    82 00000722 B801000000          <1>  mov eax, sys_write
    83 00000727 BF01000000          <1>  mov edi, 1
    84 0000072C 48BE-               <1>  mov rsi, %1
    84 0000072E [1000000000000000]  <1>
    85 00000736 BA07000000          <1>  mov edx, %2
    86 0000073B 0F05                <1>  syscall
   986                                      
   987                                      ; Calcular la posición central para el mensaje
   988                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   989 0000073D B84E000000                  mov rax, column_cells
   990 00000742 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   991 00000746 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   992                                      
   993                                      ; Calcular la fila central
   994 00000749 BB20000000                  mov rbx, row_cells
   995 0000074E 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   996                                      
   997                                      ; Calcular el offset en el buffer
   998 00000751 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   999 00000756 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1000 00000759 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1001                                      
  1002                                      ; Escribir "NIVEL " en la posición calculada
  1003 0000075C 488DB8[000A0000]            lea rdi, [board + rax]
  1004 00000763 48BE-                       mov rsi, level_msg
  1004 00000765 [2414000000000000] 
  1005 0000076D B906000000                  mov rcx, level_msg_len
  1006 00000772 F3A4                        rep movsb
  1007                                      
  1008                                      ; Escribir el número del nivel
  1009 00000774 8A05(A4140000)              mov al, [current_level]
  1010 0000077A 0430                        add al, '0'                 ; convertir a ASCII
  1011 0000077C 8807                        mov [rdi], al
  1012                                      
  1013                                      ; Mostrar el board con el mensaje
  1014                                      print board, board_size
    82 0000077E B801000000          <1>  mov eax, sys_write
    83 00000783 BF01000000          <1>  mov edi, 1
    84 00000788 48BE-               <1>  mov rsi, %1
    84 0000078A [000A000000000000]  <1>
    85 00000792 BA000A0000          <1>  mov edx, %2
    86 00000797 0F05                <1>  syscall
  1015                                      
  1016                                      ; Esperar un segundo
  1017 00000799 B823000000                  mov rax, sys_nanosleep
  1018 0000079E 48BF-                       mov rdi, level_display_time
  1018 000007A0 [2F14000000000000] 
  1019 000007A8 4831F6                      xor rsi, rsi
  1020 000007AB 0F05                        syscall
  1021                                      
  1022 000007AD 5D                          pop rbp
  1023 000007AE C3                          ret
  1024                                  
  1025                                  ; Función para inicializar un tablero vacío
  1026                                  init_empty_board:
  1027 000007AF 56                          push rsi
  1028 000007B0 57                          push rdi
  1029 000007B1 51                          push rcx
  1030 000007B2 50                          push rax
  1031                                  
  1032 000007B3 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1033 000007BA 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1034 000007C1 B9000A0000                  mov rcx, board_template_size
  1035 000007C6 F3A4                        rep movsb                   ; Copiar el tablero
  1036                                  
  1037 000007C8 58                          pop rax
  1038 000007C9 59                          pop rcx
  1039 000007CA 5F                          pop rdi
  1040 000007CB 5E                          pop rsi
  1041 000007CC C3                          ret
  1042                                  
  1043                                  
  1044                                  init_level:
  1045                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1046                                          ; Reiniciar letras activas
  1047 000007CD 488D3D(2B160000)            lea rdi, [letters_map]
  1048 000007D4 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1049 000007D9 4831C0                      xor rax, rax
  1050 000007DC F3AA                        rep stosb                    ; Llenar con ceros
  1051                                      
  1052                                      ; Inicializar dirección de la bola (derecha y arriba)
  1053 000007DE 48C705(5F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1053 000007E6 000000             
  1054 000007E9 48C705(67140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1054 000007F1 FFFFFF             
  1055                                  
  1056                                  
  1057                                      ; Reiniciar contador de letras activas
  1058 000007F4 4831C0                      xor rax, rax
  1059 000007F7 8805(BB170000)              mov [letters_count], al
  1060                                  
  1061                                      ; Reiniciar última letra capturada
  1062 000007FD C605(BC170000)20            mov byte [last_letter], ' '
  1063 00000804 C605(35150000)00            mov byte [destroyed_blocks], 0 
  1064 0000080B E89FFFFFFF                  call init_empty_board
  1065 00000810 E809FFFFFF                  call display_level_number
  1066 00000815 E8E5050000                  call init_enemies
  1067                                      
  1068 0000081A 56                          push rsi
  1069 0000081B 57                          push rdi
  1070 0000081C 51                          push rcx
  1071 0000081D 50                          push rax
  1072                                  
  1073 0000081E 488D35(00000000)            lea rsi, [board_template]
  1074 00000825 488D3D(000A0000)            lea rdi, [board]
  1075 0000082C B9000A0000                  mov rcx, board_template_size
  1076 00000831 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1077                                  
  1078 00000833 58                          pop rax
  1079 00000834 59                          pop rcx
  1080 00000835 5F                          pop rdi
  1081 00000836 5E                          pop rsi
  1082                                  
  1083 00000837 B90A000000                  mov rcx, 10
  1084 0000083C 4831C0                      xor rax, rax
  1085 0000083F 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1086 00000846 F3AA                        rep stosb      
  1087                                  
  1088                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1089 00000848 803D(A4140000)01            cmp byte [current_level], 1
  1090 0000084F 7431                        je .level1
  1091 00000851 803D(A4140000)02            cmp byte [current_level], 2
  1092 00000858 7454                        je .level2
  1093 0000085A 803D(A4140000)03            cmp byte [current_level], 3
  1094 00000861 7477                        je .level3
  1095 00000863 803D(A4140000)04            cmp byte [current_level], 4
  1096 0000086A 0F8492000000                je .level4
  1097 00000870 803D(A4140000)05            cmp byte [current_level], 5
  1098 00000877 0F84AD000000                je .level5
  1099 0000087D E9D0000000                  jmp .done
  1100                                  
  1101                                  
  1102                                  
  1103                                      .level1:
  1104 00000882 C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1105 00000889 4831C9                          xor rcx, rcx             
  1106                                          .init_loop1:
  1107 0000088C 4883F903                            cmp rcx, level1_blocks_count
  1108 00000890 0F8DBC000000                        jge .done
  1109 00000896 4889C8                              mov rax, rcx         
  1110 00000899 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1111 0000089D 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1112 000008A3 8891[C9140000]                      mov byte [block_states + rcx], dl
  1113 000008A9 48FFC1                              inc rcx
  1114 000008AC EBDE                                jmp .init_loop1
  1115                                  
  1116                                      .level2:
  1117 000008AE C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1118 000008B5 4831C9                          xor rcx, rcx             
  1119                                          .init_loop2:
  1120 000008B8 4883F901                            cmp rcx, level2_blocks_count
  1121 000008BC 0F8D90000000                        jge .done
  1122 000008C2 4889C8                              mov rax, rcx         
  1123 000008C5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1124 000008C9 8A90[B8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1125 000008CF 8891[C9140000]                      mov byte [block_states + rcx], dl
  1126 000008D5 48FFC1                              inc rcx
  1127 000008D8 EBDE                                jmp .init_loop2
  1128                                      .level3:
  1129 000008DA C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1130 000008E1 4831C9                          xor rcx, rcx             
  1131                                          .init_loop3:
  1132 000008E4 4883F901                            cmp rcx, level3_blocks_count
  1133 000008E8 7D68                                jge .done
  1134 000008EA 4889C8                              mov rax, rcx         
  1135 000008ED 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1136 000008F1 8A90[BD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1137 000008F7 8891[C9140000]                      mov byte [block_states + rcx], dl
  1138 000008FD 48FFC1                              inc rcx
  1139 00000900 EBE2                                jmp .init_loop3
  1140                                  
  1141                                      .level4:
  1142 00000902 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1143 00000909 4831C9                          xor rcx, rcx             
  1144                                          .init_loop4:
  1145 0000090C 4883F901                            cmp rcx, level4_blocks_count
  1146 00000910 7D40                                jge .done
  1147 00000912 4889C8                              mov rax, rcx         
  1148 00000915 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1149 00000919 8A90[C2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1150 0000091F 8891[C9140000]                      mov byte [block_states + rcx], dl
  1151 00000925 48FFC1                              inc rcx
  1152 00000928 EBE2                                jmp .init_loop4
  1153                                  
  1154                                      .level5:
  1155 0000092A C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1156 00000931 4831C9                          xor rcx, rcx             
  1157                                          .init_loop5:
  1158 00000934 4883F901                            cmp rcx, level5_blocks_count
  1159 00000938 7D18                                jge .done
  1160 0000093A 4889C8                              mov rax, rcx         
  1161 0000093D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1162 00000941 8A90[C7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1163 00000947 8891[C9140000]                      mov byte [block_states + rcx], dl
  1164 0000094D 48FFC1                              inc rcx
  1165 00000950 EBE2                                jmp .init_loop5
  1166                                      .done:
  1167 00000952 C3                              ret
  1168                                  
  1169                                  
  1170                                  ; Función para verificar y manejar la transición de nivel
  1171                                  check_level_complete:
  1172                                      ; Verificar si quedan bloques
  1173 00000953 803D(A5140000)00            cmp byte [blocks_remaining], 0
  1174 0000095A 753C                        jne .not_complete
  1175                                      
  1176                                      ; Incrementar el nivel
  1177 0000095C FE05(A4140000)              inc byte [current_level]
  1178                                      
  1179                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1180 00000962 803D(A4140000)06            cmp byte [current_level], 6
  1181 00000969 742E                        je game_win
  1182                                      
  1183                                      ; Reinicializar el juego para el siguiente nivel
  1184 0000096B E85DFEFFFF                  call init_level
  1185                                      
  1186                                      ; Reinicializar la posición de la bola y la paleta
  1187 00000970 48C705(4F140000)28-         mov qword [ball_x_pos], 40
  1187 00000978 000000             
  1188 0000097B 48C705(57140000)1C-         mov qword [ball_y_pos], 28
  1188 00000983 000000             
  1189 00000986 C605(6F140000)00            mov byte [ball_moving], 0
  1190 0000098D 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1190 00000994 [36130000]         
  1191                                      
  1192                                      .not_complete:
  1193 00000998 C3                              ret
  1194                                  
  1195                                      ; Nueva función para manejar la victoria del juego
  1196                                  game_win:
  1197                                      ; Limpiar la pantalla primero
  1198                                      print clear, clear_length
    82 00000999 B801000000          <1>  mov eax, sys_write
    83 0000099E BF01000000          <1>  mov edi, 1
    84 000009A3 48BE-               <1>  mov rsi, %1
    84 000009A5 [1000000000000000]  <1>
    85 000009AD BA07000000          <1>  mov edx, %2
    86 000009B2 0F05                <1>  syscall
  1199                                      
  1200                                      ; Mensaje de victoria
  1201 000009B4 488B05(2D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1202 000009BB 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1202 000009BD [3615000000000000] 
  1203 000009C5 E8B4010000                  call number_to_string
  1204                                      
  1205                                      ; Definir mensaje de victoria
  1206                                      section .data
  1207 000017E0 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1207 000017E9 616465732120C2A148-
  1207 000017F2 61732067616E61646F-
  1207 000017FB 210A0D             
  1208                                          win_msg_len: equ $ - win_msg
  1209 000017FE 50756E74616A652066-             score_msg: db "Puntaje final: "
  1209 00001807 696E616C3A20       
  1210                                          score_msg_len: equ $ - score_msg
  1211                                      section .text
  1212                                      
  1213                                      ; Imprimir mensajes
  1214                                      print win_msg, win_msg_len
    82 000009CA B801000000          <1>  mov eax, sys_write
    83 000009CF BF01000000          <1>  mov edi, 1
    84 000009D4 48BE-               <1>  mov rsi, %1
    84 000009D6 [E017000000000000]  <1>
    85 000009DE BA1E000000          <1>  mov edx, %2
    86 000009E3 0F05                <1>  syscall
  1215                                      print score_msg, score_msg_len
    82 000009E5 B801000000          <1>  mov eax, sys_write
    83 000009EA BF01000000          <1>  mov edi, 1
    84 000009EF 48BE-               <1>  mov rsi, %1
    84 000009F1 [FE17000000000000]  <1>
    85 000009F9 BA0F000000          <1>  mov edx, %2
    86 000009FE 0F05                <1>  syscall
  1216                                      print number_buffer, 20
    82 00000A00 B801000000          <1>  mov eax, sys_write
    83 00000A05 BF01000000          <1>  mov edi, 1
    84 00000A0A 48BE-               <1>  mov rsi, %1
    84 00000A0C [3615000000000000]  <1>
    85 00000A14 BA14000000          <1>  mov edx, %2
    86 00000A19 0F05                <1>  syscall
  1217                                      
  1218                                      ; Esperar un momento antes de salir
  1219 00000A1B 48C705DAF5FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1219 00000A24 0000               
  1220 00000A26 48C705D7F5FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1220 00000A2F 0000               
  1221                                      sleeptime
    98 00000A31 B823000000          <1>  mov eax, sys_nanosleep
    99 00000A36 48BF-               <1>  mov rdi, timespec
    99 00000A38 [0000000000000000]  <1>
   100 00000A40 31F6                <1>  xor esi, esi
   101 00000A42 0F05                <1>  syscall
  1222                                      
  1223 00000A44 E913090000                  jmp exit
  1224                                  
  1225                                  ; Función para imprimir los bloques
  1226                                  ; Función modificada para imprimir bloques
  1227                                  
  1228                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1229                                  get_current_level_blocks:
  1230 00000A49 803D(A4140000)01            cmp byte [current_level], 1
  1231 00000A50 7428                        je .level1
  1232 00000A52 803D(A4140000)02            cmp byte [current_level], 2
  1233 00000A59 7427                        je .level2
  1234 00000A5B 803D(A4140000)03            cmp byte [current_level], 3
  1235 00000A62 7426                        je .level3
  1236 00000A64 803D(A4140000)04            cmp byte [current_level], 4
  1237 00000A6B 7425                        je .level4
  1238 00000A6D 803D(A4140000)05            cmp byte [current_level], 5
  1239 00000A74 7424                        je .level5
  1240                                      ; Si llegamos aquí, hay un error en el nivel
  1241 00000A76 4831C0                      xor rax, rax
  1242 00000A79 C3                          ret
  1243                                  
  1244                                      .level1:
  1245 00000A7A 488D05(A6140000)                lea rax, [level1_blocks]
  1246 00000A81 C3                              ret
  1247                                      .level2:
  1248 00000A82 488D05(B5140000)                lea rax, [level2_blocks]
  1249 00000A89 C3                              ret
  1250                                      .level3:
  1251 00000A8A 488D05(BA140000)                lea rax, [level3_blocks]
  1252 00000A91 C3                              ret
  1253                                      .level4:
  1254 00000A92 488D05(BF140000)                lea rax, [level4_blocks]
  1255 00000A99 C3                              ret
  1256                                      .level5:
  1257 00000A9A 488D05(C4140000)                lea rax, [level5_blocks]
  1258 00000AA1 C3                              ret
  1259                                  ; Función para obtener la cantidad de bloques del nivel actual
  1260                                  get_current_level_count:
  1261 00000AA2 803D(A4140000)01            cmp byte [current_level], 1
  1262 00000AA9 7428                        je .level1
  1263 00000AAB 803D(A4140000)02            cmp byte [current_level], 2
  1264 00000AB2 7425                        je .level2
  1265 00000AB4 803D(A4140000)03            cmp byte [current_level], 3
  1266 00000ABB 7422                        je .level3
  1267 00000ABD 803D(A4140000)04            cmp byte [current_level], 4
  1268 00000AC4 741F                        je .level4
  1269 00000AC6 803D(A4140000)05            cmp byte [current_level], 5
  1270 00000ACD 741C                        je .level5
  1271                                      ; Si llegamos aquí, hay un error en el nivel
  1272 00000ACF 4831C0                      xor rax, rax
  1273 00000AD2 C3                          ret
  1274                                  
  1275                                      .level1:
  1276 00000AD3 B803000000                      mov rax, level1_blocks_count
  1277 00000AD8 C3                              ret
  1278                                      .level2:
  1279 00000AD9 B801000000                      mov rax, level2_blocks_count
  1280 00000ADE C3                              ret
  1281                                      .level3:
  1282 00000ADF B801000000                      mov rax, level3_blocks_count
  1283 00000AE4 C3                              ret
  1284                                      .level4:
  1285 00000AE5 B801000000                      mov rax, level4_blocks_count
  1286 00000AEA C3                              ret
  1287                                      .level5:
  1288 00000AEB B801000000                      mov rax, level5_blocks_count
  1289 00000AF0 C3                              ret
  1290                                  
  1291                                  
  1292                                  print_blocks:
  1293 00000AF1 55                          push rbp
  1294 00000AF2 4889E5                      mov rbp, rsp
  1295                                      
  1296                                      ; Obtener puntero a los bloques del nivel actual
  1297 00000AF5 E84FFFFFFF                  call get_current_level_blocks
  1298 00000AFA 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1299                                      
  1300                                      ; Obtener cantidad de bloques del nivel actual
  1301 00000AFD E8A0FFFFFF                  call get_current_level_count
  1302 00000B02 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1303                                      
  1304 00000B05 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1305                                      
  1306                                      .print_loop:
  1307 00000B08 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1308 00000B0B 7D6F                            jge .end
  1309                                          
  1310                                          ; Verificar si el bloque está activo
  1311 00000B0D 490FB68424-                     movzx rax, byte [block_states + r12]
  1311 00000B12 [C9140000]         
  1312 00000B16 4885C0                          test rax, rax
  1313 00000B19 745C                            jz .next_block
  1314                                          
  1315                                          ; Obtener posición y tipo del bloque usando r13
  1316 00000B1B 4C89E0                          mov rax, r12
  1317 00000B1E 486BC005                        imul rax, 5
  1318 00000B22 4C01E8                          add rax, r13
  1319 00000B25 448A00                          mov r8b, [rax]        ; X position
  1320 00000B28 448A4801                        mov r9b, [rax + 1]    ; Y position
  1321 00000B2C 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1322                                  
  1323                                          ; El resto de la lógica de impresión permanece igual
  1324 00000B30 4D0FB6C0                        movzx r8, r8b
  1325 00000B34 4D0FB6C9                        movzx r9, r9b
  1326 00000B38 4981C0[000A0000]                add r8, board
  1327 00000B3F B850000000                      mov rax, column_cells + 2
  1328 00000B44 49F7E1                          mul r9
  1329 00000B47 4901C0                          add r8, rax
  1330                                          
  1331 00000B4A B906000000                      mov rcx, block_length
  1332 00000B4F 48BE-                           mov rsi, block_type_1
  1332 00000B51 [8014000000000000] 
  1333 00000B59 490FB6C2                        movzx rax, r10b
  1334 00000B5D 48FFC8                          dec rax
  1335 00000B60 486BC006                        imul rax, block_length
  1336 00000B64 4801C6                          add rsi, rax
  1337                                          
  1338                                      .print_block_chars:
  1339 00000B67 8A06                            mov al, [rsi]
  1340 00000B69 418800                          mov [r8], al
  1341 00000B6C 48FFC6                          inc rsi
  1342 00000B6F 49FFC0                          inc r8
  1343 00000B72 48FFC9                          dec rcx
  1344 00000B75 75F0                            jnz .print_block_chars
  1345                                          
  1346                                      .next_block:
  1347 00000B77 49FFC4                          inc r12
  1348 00000B7A EB8C                            jmp .print_loop
  1349                                          
  1350                                      .end:
  1351 00000B7C 5D                              pop rbp
  1352 00000B7D C3                              ret
  1353                                  
  1354                                  ; Función para convertir número a string
  1355                                  ; Input: RAX = número a convertir
  1356                                  ; RDI = buffer donde escribir el string
  1357                                  number_to_string:
  1358 00000B7E 53                          push rbx
  1359 00000B7F 52                          push rdx
  1360 00000B80 56                          push rsi
  1361 00000B81 BB0A000000                  mov rbx, 10          ; Divisor
  1362 00000B86 B900000000                  mov rcx, 0          ; Contador de dígitos
  1363                                      
  1364                                      ; Si el número es 0, manejarlo especialmente
  1365 00000B8B 4885C0                      test rax, rax
  1366 00000B8E 7509                        jnz .convert_loop
  1367 00000B90 C60730                      mov byte [rdi], '0'
  1368 00000B93 C6470100                    mov byte [rdi + 1], 0
  1369 00000B97 EB20                        jmp .end
  1370                                      
  1371                                      .convert_loop:
  1372 00000B99 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1373 00000B9C 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1374 00000B9F 80C230                          add dl, '0'     ; Convertir a ASCII
  1375 00000BA2 52                              push rdx        ; Guardar el dígito
  1376 00000BA3 48FFC1                          inc rcx         ; Incrementar contador
  1377 00000BA6 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1378 00000BA9 75EE                            jnz .convert_loop
  1379                                          
  1380                                      .write_loop:
  1381 00000BAB 5A                              pop rdx         ; Obtener dígito
  1382 00000BAC 8817                            mov [rdi], dl   ; Escribir al buffer
  1383 00000BAE 48FFC7                          inc rdi         ; Siguiente posición
  1384 00000BB1 48FFC9                          dec rcx         ; Decrementar contador
  1385 00000BB4 75F5                            jnz .write_loop
  1386                                          
  1387 00000BB6 C60700                      mov byte [rdi], 0   ; Null terminator
  1388                                      
  1389                                      .end:
  1390 00000BB9 5E                          pop rsi
  1391 00000BBA 5A                          pop rdx
  1392 00000BBB 5B                          pop rbx
  1393 00000BBC C3                          ret
  1394                                  
  1395                                  ; Función para imprimir los labels
  1396                                  print_labels:
  1397 00000BBD 55                          push rbp
  1398 00000BBE 4889E5                      mov rbp, rsp
  1399                                  
  1400                                      ; Crear buffer temporal
  1401 00000BC1 4883EC20                    sub rsp, 32
  1402                                  
  1403                                      ; Copiar labels a buffer temporal
  1404 00000BC5 4889E7                      mov rdi, rsp
  1405 00000BC8 488D35(E2150000)            lea rsi, [score_label]
  1406 00000BCF B917000000                  mov rcx, score_label_len
  1407 00000BD4 F3A4                        rep movsb
  1408                                  
  1409                                      ; Convertir score a string
  1410 00000BD6 488B05(2D150000)            mov rax, [current_score]
  1411 00000BDD 48BF-                       mov rdi, number_buffer
  1411 00000BDF [3615000000000000] 
  1412 00000BE7 E892FFFFFF                  call number_to_string
  1413                                  
  1414                                      ; Calcular longitud del número
  1415 00000BEC B900000000                  mov rcx, 0
  1416 00000BF1 48BF-                       mov rdi, number_buffer
  1416 00000BF3 [3615000000000000] 
  1417                                      .count_loop:
  1418 00000BFB 803C0F00                        cmp byte [rdi + rcx], 0
  1419 00000BFF 7405                            je .count_done
  1420 00000C01 48FFC1                          inc rcx
  1421 00000C04 EBF5                            jmp .count_loop
  1422                                      .count_done:
  1423                                  
  1424                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1425 00000C06 4889E7                      mov rdi, rsp
  1426 00000C09 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1427 00000C0D BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1428 00000C12 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1429                                      .pad_loop:
  1430 00000C15 4885F6                          test rsi, rsi
  1431 00000C18 740B                            jz .pad_done
  1432 00000C1A C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1433 00000C1D 48FFC7                          inc rdi
  1434 00000C20 48FFCE                          dec rsi
  1435 00000C23 EBF0                            jmp .pad_loop
  1436                                      .pad_done:
  1437                                  
  1438                                      ; Copiar el número
  1439 00000C25 48BE-                       mov rsi, number_buffer
  1439 00000C27 [3615000000000000] 
  1440 00000C2F F3A4                        rep movsb
  1441                                  
  1442                                      ; Imprimir el buffer completo
  1443                                      print rsp, score_label_len
    82 00000C31 B801000000          <1>  mov eax, sys_write
    83 00000C36 BF01000000          <1>  mov edi, 1
    84 00000C3B 4889E6              <1>  mov rsi, %1
    85 00000C3E BA17000000          <1>  mov edx, %2
    86 00000C43 0F05                <1>  syscall
  1444                                  
  1445                                      ; Repetir proceso para bloques destruidos
  1446 00000C45 4889E7                      mov rdi, rsp
  1447 00000C48 488D35(F9150000)            lea rsi, [blocks_label]
  1448 00000C4F B91B000000                  mov rcx, blocks_label_len
  1449 00000C54 F3A4                        rep movsb
  1450                                  
  1451                                      ; Verificar que el `[` esté en su posición correcta
  1452 00000C56 4889E7                      mov rdi, rsp
  1453 00000C59 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1454 00000C5D C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1455                                  
  1456                                      ; Convertir bloques destruidos a string
  1457 00000C60 480FB605(35150000)          movzx rax, byte [destroyed_blocks]
  1458 00000C68 48BF-                       mov rdi, number_buffer
  1458 00000C6A [3615000000000000] 
  1459 00000C72 E807FFFFFF                  call number_to_string
  1460                                  
  1461                                      ; Calcular longitud del número
  1462 00000C77 B900000000                  mov rcx, 0
  1463 00000C7C 48BF-                       mov rdi, number_buffer
  1463 00000C7E [3615000000000000] 
  1464                                      .count_loop2:
  1465 00000C86 803C0F00                        cmp byte [rdi + rcx], 0
  1466 00000C8A 7405                            je .count_done2
  1467 00000C8C 48FFC1                          inc rcx
  1468 00000C8F EBF5                            jmp .count_loop2
  1469                                      .count_done2:
  1470                                  
  1471                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1472 00000C91 4889E7                      mov rdi, rsp
  1473 00000C94 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1474 00000C98 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1475 00000C9D 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1476                                      .pad_loop2:
  1477 00000CA0 4885F6                          test rsi, rsi
  1478 00000CA3 740B                            jz .pad_done2
  1479 00000CA5 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1480 00000CA8 48FFC7                          inc rdi
  1481 00000CAB 48FFCE                          dec rsi
  1482 00000CAE EBF0                            jmp .pad_loop2
  1483                                      .pad_done2:
  1484                                  
  1485                                      ; Copiar el número
  1486 00000CB0 48BE-                       mov rsi, number_buffer
  1486 00000CB2 [3615000000000000] 
  1487 00000CBA F3A4                        rep movsb
  1488                                  
  1489                                      ; Imprimir el buffer completo
  1490                                      print rsp, blocks_label_len
    82 00000CBC B801000000          <1>  mov eax, sys_write
    83 00000CC1 BF01000000          <1>  mov edi, 1
    84 00000CC6 4889E6              <1>  mov rsi, %1
    85 00000CC9 BA1B000000          <1>  mov edx, %2
    86 00000CCE 0F05                <1>  syscall
  1491                                  
  1492                                      ; Restaurar stack
  1493 00000CD0 4883C420                    add rsp, 32
  1494 00000CD4 5D                          pop rbp
  1495 00000CD5 C3                          ret
  1496                                  
  1497                                  
  1498                                  ; Función modificada para detectar colisión
  1499                                  ; Función mejorada para detectar colisión y manejar la física
  1500                                  ; Función corregida para manejar colisiones con bloques completos
  1501                                  ;---------------------------------------------------------
  1502                                  ; check_block_collision:
  1503                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1504                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1505                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1506                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1507                                  ;   retorna 0.
  1508                                  ;---------------------------------------------------------
  1509                                  ;--------------------------------------
  1510                                  ; check_block_collision
  1511                                  ;--------------------------------------
  1512                                  ; Actualizar check_block_collision para usar el nivel actual
  1513                                  check_block_collision:
  1514 00000CD6 55                          push rbp
  1515 00000CD7 4889E5                      mov rbp, rsp
  1516                                  
  1517                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1518 00000CDA 418A02                      mov al, [r10]
  1519                                  
  1520                                      ; Verificar si el carácter es un bloque
  1521 00000CDD 3C55                        cmp al, 'U'  
  1522 00000CDF 7419                        je .possible
  1523 00000CE1 3C4F                        cmp al, 'O'  
  1524 00000CE3 7415                        je .possible
  1525 00000CE5 3C44                        cmp al, 'D'  
  1526 00000CE7 7411                        je .possible
  1527 00000CE9 3C4C                        cmp al, 'L'  
  1528 00000CEB 740D                        je .possible
  1529 00000CED 3C56                        cmp al, 'V'  
  1530 00000CEF 7409                        je .possible
  1531 00000CF1 3C38                        cmp al, '8'  
  1532 00000CF3 7405                        je .possible
  1533                                  
  1534                                      ; No es bloque, salir
  1535 00000CF5 4831C0                      xor rax, rax
  1536 00000CF8 5D                          pop rbp
  1537 00000CF9 C3                          ret
  1538                                  
  1539                                  .possible:
  1540 00000CFA 53                          push rbx
  1541 00000CFB 57                          push rdi
  1542 00000CFC 56                          push rsi
  1543 00000CFD 4154                        push r12
  1544 00000CFF 4155                        push r13
  1545 00000D01 4156                        push r14
  1546 00000D03 4157                        push r15
  1547                                  
  1548                                      ; 1) Obtener base de los bloques del nivel actual
  1549 00000D05 E83FFDFFFF                  call get_current_level_blocks
  1550 00000D0A 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1551                                  
  1552                                      ; 2) Obtener la cantidad de bloques
  1553 00000D0D E890FDFFFF                  call get_current_level_count
  1554 00000D12 4989C6                      mov r14, rax
  1555                                  
  1556 00000D15 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1557                                  
  1558                                  .find_block_loop:
  1559 00000D18 4D39F4                      cmp r12, r14
  1560 00000D1B 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1561                                  
  1562                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1563 00000D21 4C89E0                      mov rax, r12
  1564 00000D24 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1565 00000D28 4C01E8                      add rax, r13
  1566 00000D2B 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1567                                  
  1568                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1569 00000D2E 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1569 00000D33 [C9140000]         
  1570 00000D37 4885DB                      test rbx, rbx
  1571 00000D3A 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1572                                  
  1573                                      ; Obtener coordenadas
  1574 00000D40 418A17                      mov dl, [r15]         ; x
  1575 00000D43 418A4F01                    mov cl, [r15 + 1]     ; y
  1576                                  
  1577                                      ; Calcular posición en el board
  1578 00000D47 488D3D(000A0000)            lea rdi, [board]
  1579 00000D4E 4831C0                      xor rax, rax
  1580 00000D51 B84E000000                  mov rax, column_cells
  1581 00000D56 4883C002                    add rax, 2
  1582 00000D5A 480FB6C9                    movzx rcx, cl         ; y
  1583 00000D5E 480FAFC1                    imul rax, rcx
  1584 00000D62 4801C7                      add rdi, rax
  1585 00000D65 480FB6C2                    movzx rax, dl         ; x
  1586 00000D69 4801C7                      add rdi, rax
  1587                                  
  1588                                      ; Guardar la posición base del bloque
  1589 00000D6C 57                          push rdi
  1590                                  
  1591                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1592 00000D6D 4939FA                      cmp r10, rdi
  1593 00000D70 7274                        jb .skip_collision
  1594 00000D72 488D5F06                    lea rbx, [rdi + block_length]
  1595 00000D76 4939DA                      cmp r10, rbx
  1596 00000D79 736B                        jae .skip_collision
  1597                                  
  1598                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1599 00000D7B 41FE8C24[C9140000]          dec byte [block_states + r12]
  1600                                      ; Volver a cargar durabilidad
  1601 00000D83 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1601 00000D88 [C9140000]         
  1602 00000D8C 4885DB                      test rbx, rbx
  1603 00000D8F 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1604                                  
  1605                                      ; >>> Llegó a 0 => Bloque destruido
  1606 00000D91 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1607 00000D92 B906000000                  mov rcx, block_length
  1608                                  .clear_loop:
  1609 00000D97 C60720                      mov byte [rdi], ' '
  1610 00000D9A 48FFC7                      inc rdi
  1611 00000D9D E2F8                        loop .clear_loop
  1612                                  
  1613                                      ; Dibujar letra del bloque destruido
  1614 00000D9F 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1615 00000DA3 4883EF06                    sub rdi, block_length
  1616 00000DA7 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1617                                      ; Después de escribir la letra en el tablero
  1618 00000DA9 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1619 00000DAD 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1620 00000DB1 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1621 00000DB6 E8EBF5FFFF                  call register_letter
  1622                                      ; Actualizar contadores globales
  1623 00000DBB FE0D(A5140000)              dec byte [blocks_remaining]
  1624 00000DC1 FE05(35150000)              inc byte [destroyed_blocks]
  1625                                  
  1626                                      ; Sumar puntos según el tipo
  1627 00000DC7 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1628 00000DCC 486BC00A                    imul rax, 10
  1629 00000DD0 480105(2D150000)            add [current_score], rax
  1630                                  
  1631 00000DD7 B801000000                  mov rax, 1  ; colisión con destrucción
  1632 00000DDC EB14                        jmp .end_pop
  1633                                  
  1634                                  .update_display:
  1635                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1636 00000DDE B801000000                  mov rax, 1  ; colisión con "rebote"  
  1637 00000DE3 5F                          pop rdi     ; pop que quedó pendiente
  1638 00000DE4 EB0C                        jmp .end_pop
  1639                                  
  1640                                  .skip_collision:
  1641 00000DE6 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1642                                  .next_block:
  1643 00000DE7 49FFC4                      inc r12
  1644 00000DEA E929FFFFFF                  jmp .find_block_loop
  1645                                  
  1646                                  .no_block_found:
  1647 00000DEF 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1648                                  
  1649                                  .end_pop:
  1650 00000DF2 415F                        pop r15
  1651 00000DF4 415E                        pop r14
  1652 00000DF6 415D                        pop r13
  1653 00000DF8 415C                        pop r12
  1654 00000DFA 5E                          pop rsi
  1655 00000DFB 5F                          pop rdi
  1656 00000DFC 5B                          pop rbx
  1657 00000DFD 5D                          pop rbp
  1658 00000DFE C3                          ret
  1659                                  
  1660                                  
  1661                                  
  1662                                  init_enemies:
  1663 00000DFF 55                          push rbp
  1664 00000E00 4889E5                      mov rbp, rsp
  1665                                      ; Reiniciar contadores de movimiento
  1666 00000E03 C605(78150000)00            mov byte [enemy_move_total], 0
  1667 00000E0A C605(79150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1668                                      ; Limpiar estado previo de enemigos
  1669 00000E11 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1670 00000E16 488D3D(4F150000)            lea rdi, [enemies]
  1671 00000E1D 30C0                        xor al, al
  1672 00000E1F F3AA                        rep stosb ; Limpiar datos de enemigos
  1673                                      
  1674                                      ; Marcar todos los enemigos como inactivos
  1675 00000E21 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1676 00000E28 30C0                        xor al, al
  1677 00000E2A B90A000000                  mov rcx, 10
  1678 00000E2F F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1679                                  
  1680 00000E31 5D                          pop rbp
  1681 00000E32 C3                          ret
  1682                                  
  1683                                  
  1684                                  ; Función para mover enemigos
  1685                                  move_enemies:
  1686 00000E33 55                          push rbp
  1687 00000E34 4889E5                      mov rbp, rsp
  1688                                      
  1689                                      ; Incrementar contador de movimiento
  1690 00000E37 FE05(76150000)              inc byte [enemy_move_counter]
  1691 00000E3D 480FB605(76150000)          movzx rax, byte [enemy_move_counter]
  1692 00000E45 3A05(77150000)              cmp al, [enemy_move_delay]
  1693 00000E4B 0F85AA010000                jne .end
  1694                                      
  1695                                      ; Resetear contador
  1696 00000E51 C605(76150000)00            mov byte [enemy_move_counter], 0
  1697                                      
  1698 00000E58 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1699                                      
  1700                                      .enemy_loop:
  1701 00000E5B 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1702 00000E5F 0F8D96010000                    jge .end
  1703                                          
  1704                                          ; Calcular offset del enemigo actual
  1705 00000E65 4C89E0                          mov rax, r12
  1706 00000E68 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1707 00000E6C 488DB0[4F150000]                lea rsi, [enemies + rax]
  1708                                          
  1709                                          ; Verificar si el enemigo está activo
  1710 00000E73 807E0201                        cmp byte [rsi + 2], 1
  1711 00000E77 0F8576010000                    jne .next_enemy
  1712                                          
  1713                                          ; Obtener posición actual
  1714 00000E7D 4C0FB606                        movzx r8, byte [rsi]            ; X
  1715 00000E81 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1716                                          
  1717                                          ; Limpiar posición actual antes de mover
  1718 00000E86 4150                            push r8
  1719 00000E88 4151                            push r9
  1720 00000E8A B84E000000                      mov rax, column_cells
  1721 00000E8F 4883C002                        add rax, 2
  1722 00000E93 49F7E1                          mul r9
  1723 00000E96 4C01C0                          add rax, r8
  1724 00000E99 488DB8[000A0000]                lea rdi, [board + rax]
  1725 00000EA0 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1726 00000EA3 4159                            pop r9
  1727 00000EA5 4158                            pop r8
  1728                                  
  1729                                          ; Determinar comportamiento basado en índice
  1730 00000EA7 4C89E0                          mov rax, r12
  1731 00000EAA 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1732 00000EAE 4885C0                          test rax, rax
  1733 00000EB1 7402                            jz .chase_ball
  1734 00000EB3 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1735                                          
  1736                                          ; Perseguir bola (comportamiento original)
  1737                                      .chase_ball:
  1738 00000EB5 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1739 00000EBC 4D39D0                          cmp r8, r10
  1740 00000EBF 0F8F96000000                    jg .move_left
  1741 00000EC5 0F8C95000000                    jl .move_right
  1742                                          
  1743 00000ECB 4C8B15(57140000)                mov r10, [ball_y_pos]
  1744 00000ED2 4D39D1                          cmp r9, r10
  1745 00000ED5 0F8F8A000000                    jg .move_up
  1746 00000EDB 0F8C89000000                    jl .move_down
  1747 00000EE1 E9A5000000                      jmp .check_collision
  1748                                          
  1749                                      .chase_paddle:
  1750                                          ; Obtener la posición X actual de la paleta
  1751 00000EE6 4C8B15(3F140000)                mov r10, [pallet_position]
  1752 00000EED 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1753                                          
  1754                                          ; Calcular la posición X real de la paleta
  1755 00000EF4 4C89D0                          mov rax, r10
  1756 00000EF7 BB4E000000                      mov rbx, column_cells
  1757 00000EFC 4883C302                        add rbx, 2                  ; Añadir newline chars
  1758 00000F00 4831D2                          xor rdx, rdx
  1759 00000F03 48F7F3                          div rbx                     ; rax = y, rdx = x
  1760                                          
  1761                                          ; rdx ahora contiene la posición X de la paleta
  1762                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1763 00000F06 488B0D(47140000)                mov rcx, [pallet_size]
  1764 00000F0D 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1765 00000F10 4801CA                          add rdx, rcx
  1766                                          
  1767                                          ; Comparar con posición X del enemigo y mover gradualmente
  1768 00000F13 4939D0                          cmp r8, rdx
  1769 00000F16 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1770 00000F18 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1771 00000F1A 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1772                                  
  1773                                      .check_y_paddle:
  1774                                          ; La Y de la paleta siempre es row_cells - 2
  1775 00000F1C 41BA20000000                    mov r10, row_cells
  1776 00000F22 4983EA02                        sub r10, 2
  1777                                          
  1778                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1779 00000F26 4D39D1                          cmp r9, r10
  1780 00000F29 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1781 00000F2B 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1782 00000F2D 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1783                                          
  1784                                      .no_movement:
  1785 00000F2F EB5A                            jmp .check_collision
  1786                                  
  1787                                      ; También agregar una nueva sección para el movimiento suave
  1788                                      .smooth_transition:
  1789                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1790 00000F31 8A05(79150000)                  mov al, [enemy_target]
  1791 00000F37 84C0                            test al, al
  1792 00000F39 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1793                                          
  1794                                          ; Verificar distancia en X
  1795 00000F3B 4989D2                          mov r10, rdx              ; Posición X objetivo
  1796 00000F3E 4D29C2                          sub r10, r8               ; Calcular diferencia
  1797 00000F41 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1798 00000F45 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1799 00000F47 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1800 00000F4B 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1801 00000F4D EB3C                            jmp .check_collision
  1802                                          
  1803                                      .limit_right_movement:
  1804 00000F4F 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1805 00000F53 EB36                            jmp .check_collision
  1806                                          
  1807                                      .limit_left_movement:
  1808 00000F55 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1809 00000F59 EB30                            jmp .check_collision
  1810                                      .move_left:
  1811 00000F5B 49FFC8                          dec r8
  1812 00000F5E EB0F                            jmp .check_vertical
  1813                                          
  1814                                      .move_right:
  1815 00000F60 49FFC0                          inc r8
  1816 00000F63 EB0A                            jmp .check_vertical
  1817                                          
  1818                                      .move_up:
  1819 00000F65 49FFC9                          dec r9
  1820 00000F68 EB21                            jmp .check_collision
  1821                                          
  1822                                      .move_down:
  1823 00000F6A 49FFC1                          inc r9
  1824 00000F6D EB1C                            jmp .check_collision
  1825                                          
  1826                                      .check_vertical:
  1827 00000F6F 8A05(79150000)                  mov al, [enemy_target]
  1828 00000F75 84C0                            test al, al
  1829 00000F77 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1830 00000F7D 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1831 00000F84 4D39D1                          cmp r9, r10
  1832 00000F87 7FDC                            jg .move_up
  1833 00000F89 7CDF                            jl .move_down
  1834                                          
  1835                                      .check_collision:
  1836                                          ; Verificar colisión con bordes
  1837 00000F8B 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1838 00000F8F 7E62                            jle .next_enemy
  1839 00000F91 4983F84E                        cmp r8, column_cells
  1840 00000F95 7D5C                            jge .next_enemy
  1841 00000F97 4983F901                        cmp r9, 1                       ; Borde superior
  1842 00000F9B 7E56                            jle .next_enemy
  1843 00000F9D 4983F920                        cmp r9, row_cells
  1844 00000FA1 7D50                            jge .next_enemy
  1845                                          
  1846                                          ; Verificar colisión con bloques antes de moverse
  1847 00000FA3 4150                            push r8
  1848 00000FA5 4151                            push r9
  1849 00000FA7 4152                            push r10
  1850                                          
  1851                                          ; Calcular posición en el tablero para verificar
  1852 00000FA9 B84E000000                      mov rax, column_cells
  1853 00000FAE 4883C002                        add rax, 2
  1854 00000FB2 49F7E1                          mul r9
  1855 00000FB5 4C01C0                          add rax, r8
  1856 00000FB8 4C8D90[000A0000]                lea r10, [board + rax]
  1857                                          
  1858                                          ; Verificar si hay un bloque en la nueva posición
  1859 00000FBF 418A02                          mov al, [r10]
  1860 00000FC2 3C55                            cmp al, 'U'
  1861 00000FC4 7427                            je .invalid_move
  1862 00000FC6 3C4F                            cmp al, 'O'
  1863 00000FC8 7423                            je .invalid_move
  1864 00000FCA 3C44                            cmp al, 'D'
  1865 00000FCC 741F                            je .invalid_move
  1866 00000FCE 3C4C                            cmp al, 'L'
  1867 00000FD0 741B                            je .invalid_move
  1868 00000FD2 3C56                            cmp al, 'V'
  1869 00000FD4 7417                            je .invalid_move
  1870 00000FD6 3C38                            cmp al, '8'
  1871 00000FD8 7413                            je .invalid_move
  1872 00000FDA 3C58                            cmp al, 'X'
  1873 00000FDC 740F                            je .invalid_move
  1874                                          
  1875 00000FDE 415A                            pop r10
  1876 00000FE0 4159                            pop r9
  1877 00000FE2 4158                            pop r8
  1878                                          
  1879                                          ; Guardar nueva posición si es válida
  1880 00000FE4 448806                          mov [rsi], r8b
  1881 00000FE7 44884E01                        mov [rsi + 1], r9b
  1882 00000FEB EB06                            jmp .next_enemy
  1883                                          
  1884                                      .invalid_move:
  1885 00000FED 415A                            pop r10
  1886 00000FEF 4159                            pop r9
  1887 00000FF1 4158                            pop r8
  1888                                          
  1889                                      .next_enemy:
  1890 00000FF3 49FFC4                          inc r12
  1891 00000FF6 E960FEFFFF                      jmp .enemy_loop
  1892                                          
  1893                                      .end:
  1894 00000FFB 5D                              pop rbp
  1895 00000FFC C3                              ret
  1896                                  
  1897                                  get_current_spawn_points:
  1898 00000FFD 55                          push rbp
  1899 00000FFE 4889E5                      mov rbp, rsp
  1900                                      
  1901 00001001 480FB605(A4140000)          movzx rax, byte [current_level]
  1902 00001009 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1903 0000100C 488B04C5[AD150000]          mov rax, [spawn_points_table + rax * 8]
  1904                                      
  1905 00001014 5D                          pop rbp
  1906 00001015 C3                          ret
  1907                                  
  1908                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1909                                  check_enemy_spawn:
  1910 00001016 55                          push rbp
  1911 00001017 4889E5                      mov rbp, rsp
  1912                                      
  1913                                      ; Obtener spawn points del nivel actual
  1914 0000101A E8DEFFFFFF                  call get_current_spawn_points
  1915 0000101F 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1916                                      
  1917                                      ; Obtener cantidad de bloques destruidos
  1918 00001022 4C0FB62D(35150000)          movzx r13, byte [destroyed_blocks]
  1919                                      
  1920                                      ; Verificar cada punto de spawn
  1921 0000102A 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1922                                      
  1923                                      .check_loop:
  1924 0000102D 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1925 00001031 7D4B                            jge .end
  1926                                          
  1927                                          ; Verificar si este spawn point ya fue usado
  1928 00001033 80B9[D8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1929 0000103A 743D                            je .next_enemy
  1930                                          
  1931                                          ; Verificar si este enemigo ya está activo
  1932 0000103C 4889C8                          mov rax, rcx
  1933 0000103F 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1934 00001043 488DB0[4F150000]                lea rsi, [enemies + rax]
  1935 0000104A 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1936 0000104E 7429                            je .next_enemy
  1937                                          
  1938                                          ; Verificar si debemos spawnear este enemigo
  1939 00001050 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1940 00001055 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1941 00001058 751F                            jne .next_enemy
  1942                                          
  1943                                          ; Marcar este spawn point como usado
  1944 0000105A C681[D8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1945                                          
  1946                                          ; Spawner nuevo enemigo
  1947 00001061 C60628                          mov byte [rsi], 40             ; X inicial
  1948 00001064 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1949 00001068 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1950                                          
  1951                                          ; Inicializar comportamiento
  1952 0000106C 4889C8                          mov rax, rcx
  1953 0000106F 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1954 00001073 8805(D7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1955                                          
  1956                                      .next_enemy:
  1957 00001079 48FFC1                          inc rcx
  1958 0000107C EBAF                            jmp .check_loop
  1959                                          
  1960                                      .end:
  1961 0000107E 5D                              pop rbp
  1962 0000107F C3                              ret
  1963                                  
  1964                                  
  1965                                  ; Función para dibujar enemigos
  1966                                  print_enemies:
  1967 00001080 55                          push rbp
  1968 00001081 4889E5                      mov rbp, rsp
  1969                                      
  1970 00001084 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1971                                      
  1972                                      .print_loop:
  1973 00001087 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1974 0000108B 7D4B                            jge .end
  1975                                          
  1976                                          ; Calcular offset del enemigo actual
  1977 0000108D 4C89E0                          mov rax, r12
  1978 00001090 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1979 00001094 488DB0[4F150000]                lea rsi, [enemies + rax]
  1980                                          
  1981                                          ; Verificar si el enemigo está activo
  1982 0000109B 807E0201                        cmp byte [rsi + 2], 1
  1983 0000109F 7532                            jne .next_enemy
  1984                                          
  1985                                          ; Calcular posición en el tablero
  1986 000010A1 4C0FB606                        movzx r8, byte [rsi]            ; X
  1987 000010A5 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1988                                          
  1989                                          ; Calcular offset en el tablero
  1990 000010AA B84E000000                      mov rax, column_cells
  1991 000010AF 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1992 000010B3 49F7E1                          mul r9
  1993 000010B6 4C01C0                          add rax, r8
  1994 000010B9 488DB8[000A0000]                lea rdi, [board + rax]
  1995                                          
  1996                                          ; Obtener carácter del enemigo según el nivel
  1997 000010C0 480FB605(A4140000)              movzx rax, byte [current_level]
  1998 000010C8 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1999 000010CB 8A80[4A150000]                  mov al, [enemy_chars + rax]
  2000                                          
  2001                                          ; Dibujar enemigo
  2002 000010D1 8807                            mov [rdi], al
  2003                                          
  2004                                      .next_enemy:
  2005 000010D3 49FFC4                          inc r12
  2006 000010D6 EBAF                            jmp .print_loop
  2007                                          
  2008                                      .end:
  2009 000010D8 5D                              pop rbp
  2010 000010D9 C3                              ret
  2011                                  
  2012                                  ; Función para verificar colisión con enemigos
  2013                                  ; Función para verificar colisión con enemigos
  2014                                  check_enemy_collision:
  2015 000010DA 55                          push rbp
  2016 000010DB 4889E5                      mov rbp, rsp
  2017                                      
  2018 000010DE 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2019 000010E1 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2020                                      
  2021                                      .check_loop:
  2022 000010E4 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2023 000010E8 0F8DE9000000                    jge .end
  2024                                          
  2025                                          ; Calcular offset del enemigo actual
  2026 000010EE 4C89E1                          mov rcx, r12
  2027 000010F1 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2028 000010F5 488DB1[4F150000]                lea rsi, [enemies + rcx]
  2029                                          
  2030                                          ; Verificar si el enemigo está activo
  2031 000010FC 807E0201                        cmp byte [rsi + 2], 1
  2032 00001100 0F85C9000000                    jne .next_enemy
  2033                                          
  2034                                          ; Verificar colisión con la bola
  2035 00001106 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2036 0000110A 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2037                                          
  2038                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2039 0000110F 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2040 00001116 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2041                                          
  2042                                          ; Comprobar colisión vertical (misma columna)
  2043 0000111D 4D39C2                          cmp r10, r8
  2044 00001120 7525                            jne .check_horizontal
  2045 00001122 4D29CB                          sub r11, r9
  2046 00001125 4983FB01                        cmp r11, 1
  2047 00001129 7F1C                            jg .check_horizontal
  2048 0000112B 4983FBFF                        cmp r11, -1
  2049 0000112F 7C16                            jl .check_horizontal
  2050                                          
  2051                                          ; Colisión vertical detectada
  2052 00001131 E8A3000000                      call destroy_enemy
  2053 00001136 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2054 0000113D B801000000                      mov rax, 1
  2055 00001142 E990000000                      jmp .end
  2056                                          
  2057                                      .check_horizontal:
  2058                                          ; Comprobar colisión horizontal (misma fila)
  2059 00001147 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2060 0000114E 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2061 00001155 4D39CB                          cmp r11, r9
  2062 00001158 7522                            jne .check_paddle
  2063 0000115A 4D29C2                          sub r10, r8
  2064 0000115D 4983FA01                        cmp r10, 1
  2065 00001161 7F19                            jg .check_paddle
  2066 00001163 4983FAFF                        cmp r10, -1
  2067 00001167 7C13                            jl .check_paddle
  2068                                          
  2069                                          ; Colisión horizontal detectada
  2070 00001169 E86B000000                      call destroy_enemy
  2071 0000116E 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2072 00001175 B801000000                      mov rax, 1
  2073 0000117A EB5B                            jmp .end
  2074                                          
  2075                                      .check_paddle:
  2076                                          ; Verificar colisión con la paleta
  2077 0000117C 4C8B15(3F140000)                mov r10, [pallet_position]
  2078 00001183 4981EA[000A0000]                sub r10, board
  2079 0000118A 4C89D0                          mov rax, r10
  2080 0000118D 41BB4E000000                    mov r11, column_cells
  2081 00001193 4983C302                        add r11, 2
  2082 00001197 4831D2                          xor rdx, rdx
  2083 0000119A 49F7F3                          div r11                     ; División para obtener la posición Y
  2084 0000119D 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2085                                          
  2086 000011A0 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2087                                          
  2088                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2089 000011A7 41BD20000000                    mov r13, row_cells
  2090 000011AD 4983ED02                        sub r13, 2                 ; Y de la paleta
  2091 000011B1 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2092 000011B4 7519                            jne .next_enemy
  2093                                          
  2094                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2095 000011B6 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2096 000011B9 7C14                            jl .next_enemy
  2097                                          
  2098 000011BB 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2099 000011BE 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2100 000011C1 7F0C                            jg .next_enemy
  2101                                          
  2102                                          ; Si llegamos aquí, hay colisión con la paleta
  2103 000011C3 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2104 000011C8 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2105 000011CD EB08                            jmp .end
  2106                                          
  2107                                      .next_enemy:
  2108 000011CF 49FFC4                          inc r12
  2109 000011D2 E90DFFFFFF                      jmp .check_loop
  2110                                          
  2111                                      .end:
  2112 000011D7 5D                              pop rbp
  2113 000011D8 C3                              ret
  2114                                  
  2115                                  ; Función para destruir un enemigo
  2116                                  destroy_enemy:
  2117                                      ; Desactivar enemigo
  2118 000011D9 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2119                                  
  2120                                      ; Sumar puntos por destruir enemigo
  2121 000011DD 488B05(6E150000)            mov rax, [enemy_points]
  2122 000011E4 480105(2D150000)            add [current_score], rax
  2123                                  
  2124                                      ; No tocar bloques destruidos aquí
  2125 000011EB C3                          ret
  2126                                  
  2127                                  
  2128                                  _start:
  2129 000011EC E83AEFFFFF              	call canonical_off
  2130 000011F1 E8F3000000              	call start_screen
  2131 000011F6 E8D2F5FFFF                  call init_level
  2132 000011FB E8FFFBFFFF                  call init_enemies
  2133 00001200 EB00                    	jmp .main_loop
  2134                                  	
  2135                                  
  2136                                  	.main_loop:
  2137 00001202 E8B6F9FFFF                      call print_labels
  2138 00001207 E8E5F8FFFF                      call print_blocks
  2139 0000120C E866F2FFFF                      call move_letters
  2140 00001211 E8D6F1FFFF                      call print_letters
  2141 00001216 E85FF3FFFF              		call print_pallet
  2142 0000121B E8EAF3FFFF                      call move_ball
  2143 00001220 E8B9F0FFFF                      call check_bottom_collision
  2144 00001225 E8B3EFFFFF                      call print_lives
  2145 0000122A E824F7FFFF                      call check_level_complete
  2146 0000122F E8E2FDFFFF                      call check_enemy_spawn
  2147 00001234 E8FAFBFFFF                      call move_enemies
  2148 00001239 E89CFEFFFF                      call check_enemy_collision
  2149 0000123E E83DFEFFFF                      call print_enemies
  2150 00001243 E80AF3FFFF              		call print_ball
  2151                                  		print board, board_size				
    82 00001248 B801000000          <1>  mov eax, sys_write
    83 0000124D BF01000000          <1>  mov edi, 1
    84 00001252 48BE-               <1>  mov rsi, %1
    84 00001254 [000A000000000000]  <1>
    85 0000125C BA000A0000          <1>  mov edx, %2
    86 00001261 0F05                <1>  syscall
  2152                                  		;setnonblocking	
  2153                                  	.read_more:	
  2154                                  		getchar	
    90 00001263 B800000000          <1>  mov rax, sys_read
    91 00001268 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000126D 48BE-               <1>  mov rsi, input_char
    92 0000126F [0000000000000000]  <1>
    93 00001277 BA01000000          <1>  mov rdx, 1
    94 0000127C 0F05                <1>  syscall
  2155                                  		
  2156 0000127E 4883F801                		cmp rax, 1
  2157 00001282 7532                        	jne .done
  2158                                  		
  2159 00001284 8A05(00000000)          		mov al,[input_char]
  2160                                  
  2161 0000128A 3C61                    		cmp al, 'a'
  2162 0000128C 750E                    	    jne .not_left
  2163 0000128E 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2164 00001295 E8FBF2FFFF              		call move_pallet
  2165 0000129A EB1A                    	    jmp .done
  2166                                  		
  2167                                  		.not_left:
  2168 0000129C 3C64                    		 	cmp al, 'd'
  2169 0000129E 750C                    	    	jne .not_right
  2170 000012A0 BF01000000              			mov rdi, right_direction
  2171 000012A5 E8EBF2FFFF              	    	call move_pallet
  2172 000012AA EB0A                        		jmp .done		
  2173                                  
  2174                                  		.not_right:
  2175                                  
  2176 000012AC 3C71                        		cmp al, 'q'
  2177 000012AE 0F84A8000000                		je exit
  2178                                  
  2179 000012B4 EBAD                    			jmp .read_more
  2180                                  		
  2181                                  		.done:	
  2182                                  			;unsetnonblocking		
  2183                                  			sleeptime	
    98 000012B6 B823000000          <1>  mov eax, sys_nanosleep
    99 000012BB 48BF-               <1>  mov rdi, timespec
    99 000012BD [0000000000000000]  <1>
   100 000012C5 31F6                <1>  xor esi, esi
   101 000012C7 0F05                <1>  syscall
  2184                                  			print clear, clear_length
    82 000012C9 B801000000          <1>  mov eax, sys_write
    83 000012CE BF01000000          <1>  mov edi, 1
    84 000012D3 48BE-               <1>  mov rsi, %1
    84 000012D5 [1000000000000000]  <1>
    85 000012DD BA07000000          <1>  mov edx, %2
    86 000012E2 0F05                <1>  syscall
  2185 000012E4 E919FFFFFF                  		jmp .main_loop
  2186                                  
  2187                                  
  2188                                  
  2189                                  start_screen:
  2190                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000012E9 B801000000          <1>  mov eax, sys_write
    83 000012EE BF01000000          <1>  mov edi, 1
    84 000012F3 48BE-               <1>  mov rsi, %1
    84 000012F5 [1000000000000000]  <1>
    85 000012FD BA07000000          <1>  mov edx, %2
    86 00001302 0F05                <1>  syscall
  2191                                      print msg1, msg1_length
    82 00001304 B801000000          <1>  mov eax, sys_write
    83 00001309 BF01000000          <1>  mov edi, 1
    84 0000130E 48BE-               <1>  mov rsi, %1
    84 00001310 [1700000000000000]  <1>
    85 00001318 BA14010000          <1>  mov edx, %2
    86 0000131D 0F05                <1>  syscall
  2192                                      
  2193                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2194                                          getchar                 ; Esperamos una tecla
    90 0000131F B800000000          <1>  mov rax, sys_read
    91 00001324 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001329 48BE-               <1>  mov rsi, input_char
    92 0000132B [0000000000000000]  <1>
    93 00001333 BA01000000          <1>  mov rdx, 1
    94 00001338 0F05                <1>  syscall
  2195 0000133A 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2196 0000133E 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2197                                          
  2198                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001340 B801000000          <1>  mov eax, sys_write
    83 00001345 BF01000000          <1>  mov edi, 1
    84 0000134A 48BE-               <1>  mov rsi, %1
    84 0000134C [1000000000000000]  <1>
    85 00001354 BA07000000          <1>  mov edx, %2
    86 00001359 0F05                <1>  syscall
  2199 0000135B C3                          ret
  2200                                  
  2201                                  exit: 
  2202 0000135C E80CEEFFFF              	call canonical_on
  2203 00001361 B83C000000              	mov    rax, 60
  2204 00001366 BF00000000                  mov    rdi, 0
  2205 0000136B 0F05                        syscall
  2206                                  
