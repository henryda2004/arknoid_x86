     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                          level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 3C060301                        db 60, 6, 3, 1    ; Bloque 7
   288 000014AA 38070301                        db 56, 7, 3, 1    ; Bloque 7
   289                                      level1_blocks_count equ 2   ; Cantidad total de bloques
   290                                  
   291                                      ; Nivel 2: Bloques de prueba
   292                                      level2_blocks:
   293 000014AE 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   294                                      level2_blocks_count equ 1
   295                                  
   296                                      ; Nivel 3
   297                                      level3_blocks:
   298 000014B2 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   299                                  
   300                                      level3_blocks_count equ 1
   301                                  
   302                                      ; Nivel 4
   303                                      level4_blocks:
   304 000014B6 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   305                                      level4_blocks_count equ 1
   306                                  
   307                                      ; Nivel 5
   308                                      level5_blocks:
   309 000014BA 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   310                                      level5_blocks_count equ 1
   311                                  
   312                                      ; Array para mantener el estado de los bloques
   313 000014BE 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   314                                  
   315                                  section .text
   316                                  
   317                                  ;	Function: print_ball
   318                                  ; This function displays the position of the ball
   319                                  ; Arguments: none
   320                                  ;
   321                                  ; Return:
   322                                  ;	Void
   323                                  print_ball:
   324 000001DD 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   325 000001E4 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   326 000001EB 4981C0[000A0000]        	add r8, board
   327                                  
   328 000001F2 4C89C9                  	mov rcx, r9
   329 000001F5 B850000000              	mov rax, column_cells + 2
   330 000001FA 48F7E9                  	imul rcx
   331                                  	
   332 000001FD 4901C0                  	add r8, rax
   333 00000200 41C6004F                	mov byte [r8], char_O
   334 00000204 C3                      	ret
   335                                  
   336                                  	
   337                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   338                                  	
   339                                  
   340                                  
   341                                  
   342                                  ;	Function: print_pallet
   343                                  ; This function moves the pallet in the game
   344                                  ; Arguments: none
   345                                  ;
   346                                  ; Return;
   347                                  ;	void
   348                                  print_pallet:
   349 00000205 4C8B05(3F140000)        	mov r8, [pallet_position]
   350 0000020C 488B0D(47140000)        	mov rcx, [pallet_size]
   351                                  	.write_pallet:
   352 00000213 41C6003D                		mov byte [r8], char_equal
   353 00000217 49FFC0                  		inc r8
   354 0000021A 48FFC9                  		dec rcx
   355 0000021D 75F4                    		jnz .write_pallet
   356                                  
   357 0000021F C3                      	ret
   358                                  	
   359                                  ;	Function: move_pallet
   360                                  ; This function is in charge of moving the pallet in a given direction
   361                                  ; Arguments:
   362                                  ;	rdi: left direction or right direction
   363                                  ;
   364                                  ; Return:
   365                                  ;	void
   366                                  move_pallet:
   367                                      
   368 00000220 803D(6F140000)00            cmp byte [ball_moving], 0
   369 00000227 7507                        jne .continue_movement
   370 00000229 C605(6F140000)01            mov byte [ball_moving], 1
   371                                  
   372                                      .continue_movement:
   373 00000230 4883FFFF                        cmp rdi, left_direction
   374 00000234 7531                            jne .move_right
   375                                  
   376                                          .move_left:
   377                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   378 00000236 4C8B05(3F140000)                    mov r8, [pallet_position]
   379 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   380 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   381 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   382 00000245 744D                                je .end            ; Si es X, no mover
   383                                              
   384 00000247 4C8B05(3F140000)                    mov r8, [pallet_position]
   385 0000024E 4C8B0D(47140000)                    mov r9, [pallet_size]
   386 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   387 0000025B 49FFC8                              dec r8
   388 0000025E 4C8905(3F140000)                    mov [pallet_position], r8
   389 00000265 EB2D                                jmp .end
   390                                              
   391                                          .move_right:
   392                                              ; Verificar si la siguiente posición después de la paleta sería una X
   393 00000267 4C8B05(3F140000)                    mov r8, [pallet_position]
   394 0000026E 4C8B0D(47140000)                    mov r9, [pallet_size]
   395 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   396 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   397 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   398 0000027D 7415                                je .end            ; Si es X, no mover
   399                                              
   400 0000027F 4C8B05(3F140000)                    mov r8, [pallet_position]
   401 00000286 41C60020                            mov byte [r8], char_space
   402 0000028A 49FFC0                              inc r8
   403 0000028D 4C8905(3F140000)                    mov [pallet_position], r8
   404                                          .end:
   405 00000294 C3                                  ret
   406                                  
   407                                  move_ball:
   408                                      ; Si la bola no está en movimiento, no hacer nada
   409 00000295 803D(6F140000)00            cmp byte [ball_moving], 0
   410 0000029C 0F8406010000                je .end
   411                                  
   412                                      ; Borrar la posición actual de la bola
   413 000002A2 4C8B05(4F140000)            mov r8, [ball_x_pos]
   414 000002A9 4C8B0D(57140000)            mov r9, [ball_y_pos]
   415 000002B0 4981C0[000A0000]            add r8, board
   416 000002B7 4C89C9                      mov rcx, r9
   417 000002BA B850000000                  mov rax, column_cells + 2
   418 000002BF 48F7E9                      imul rcx
   419 000002C2 4901C0                      add r8, rax
   420 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   421                                  
   422                                      ; Calcular siguiente posición X
   423 000002C9 4C8B05(4F140000)            mov r8, [ball_x_pos]
   424 000002D0 4C8B0D(57140000)            mov r9, [ball_y_pos]
   425 000002D7 488B05(5F140000)            mov rax, [ball_direction_x]
   426 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   427                                  
   428                                      ; Calcular la dirección de memoria para la siguiente posición
   429 000002E1 4D89C2                      mov r10, r8
   430 000002E4 4981C2[000A0000]            add r10, board
   431 000002EB 4C89C9                      mov rcx, r9
   432 000002EE B850000000                  mov rax, column_cells + 2
   433 000002F3 48F7E9                      imul rcx
   434 000002F6 4901C2                      add r10, rax
   435                                  
   436                                      ; Verificar si hay una X en la siguiente posición X
   437 000002F9 418A02                      mov al, [r10]
   438 000002FC 3C58                        cmp al, 'X'
   439 000002FE 750C                        jne .check_block_x
   440 00000300 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   441 00000307 E99C000000                  jmp .end
   442                                  
   443                                      .check_block_x:
   444                                          ; Verificar colisión con bloques en X
   445 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   446 0000030E 4151                            push r9
   447 00000310 4152                            push r10
   448 00000312 E8ED030000                      call check_block_collision
   449 00000317 415A                            pop r10
   450 00000319 4159                            pop r9
   451 0000031B 4158                            pop r8
   452 0000031D 4885C0                          test rax, rax
   453 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   454 00000322 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   455 00000329 EB7D                            jmp .end
   456                                  
   457                                      .check_paddle_x:
   458                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   459 0000032B 41803A3D                        cmp byte [r10], char_equal
   460 0000032F 7509                            jne .check_y_movement
   461 00000331 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   462 00000338 EB6E                            jmp .end
   463                                  
   464                                      .check_y_movement:
   465                                          ; Calcular siguiente posición Y
   466 0000033A 488B05(67140000)                mov rax, [ball_direction_y]
   467 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   468                                  
   469                                          ; Calcular la dirección de memoria para la siguiente posición Y
   470 00000344 4D89C2                          mov r10, r8
   471 00000347 4981C2[000A0000]                add r10, board
   472 0000034E 4C89C9                          mov rcx, r9
   473 00000351 B850000000                      mov rax, column_cells + 2
   474 00000356 48F7E9                          imul rcx
   475 00000359 4901C2                          add r10, rax
   476                                  
   477                                          ; Verificar si hay una X en la siguiente posición Y
   478 0000035C 418A02                          mov al, [r10]
   479 0000035F 3C58                            cmp al, 'X'
   480 00000361 7509                            jne .check_block_y
   481 00000363 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   482 0000036A EB3C                            jmp .end
   483                                  
   484                                      .check_block_y:
   485                                          ; Verificar colisión con bloques en Y
   486 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   487 0000036E 4151                            push r9
   488 00000370 4152                            push r10
   489 00000372 E88D030000                      call check_block_collision
   490 00000377 415A                            pop r10
   491 00000379 4159                            pop r9
   492 0000037B 4158                            pop r8
   493 0000037D 4885C0                          test rax, rax
   494 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   495 00000382 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   496 00000389 EB1D                            jmp .end
   497                                  
   498                                      .check_paddle_y:
   499                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   500 0000038B 41803A3D                    cmp byte [r10], char_equal
   501 0000038F 7509                        jne .update_position
   502 00000391 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   503 00000398 EB0E                        jmp .end
   504                                  
   505                                  
   506                                      .update_position:
   507 0000039A 4C8905(4F140000)                mov [ball_x_pos], r8
   508 000003A1 4C890D(57140000)                mov [ball_y_pos], r9
   509                                  
   510                                      .end:
   511 000003A8 C3                              ret
   512                                  
   513                                  ; Función para inicializar el nivel
   514                                  ; Función para inicializar el nivel
   515                                  ; Función para mostrar el número de nivel
   516                                  display_level_number:
   517 000003A9 55                          push rbp
   518 000003AA 4889E5                      mov rbp, rsp
   519                                      
   520                                      ; Limpiar la pantalla primero
   521                                      print clear, clear_length
    82 000003AD B801000000          <1>  mov eax, sys_write
    83 000003B2 BF01000000          <1>  mov edi, 1
    84 000003B7 48BE-               <1>  mov rsi, %1
    84 000003B9 [1000000000000000]  <1>
    85 000003C1 BA07000000          <1>  mov edx, %2
    86 000003C6 0F05                <1>  syscall
   522                                      
   523                                      ; Calcular la posición central para el mensaje
   524                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   525 000003C8 B84E000000                  mov rax, column_cells
   526 000003CD 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   527 000003D1 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   528                                      
   529                                      ; Calcular la fila central
   530 000003D4 BB20000000                  mov rbx, row_cells
   531 000003D9 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   532                                      
   533                                      ; Calcular el offset en el buffer
   534 000003DC B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   535 000003E1 48F7E3                      mul rbx                     ; multiplicar por la fila central
   536 000003E4 4801D8                      add rax, rbx                ; añadir el offset horizontal
   537                                      
   538                                      ; Escribir "NIVEL " en la posición calculada
   539 000003E7 488DB8[000A0000]            lea rdi, [board + rax]
   540 000003EE 48BE-                       mov rsi, level_msg
   540 000003F0 [2414000000000000] 
   541 000003F8 B906000000                  mov rcx, level_msg_len
   542 000003FD F3A4                        rep movsb
   543                                      
   544                                      ; Escribir el número del nivel
   545 000003FF 8A05(A4140000)              mov al, [current_level]
   546 00000405 0430                        add al, '0'                 ; convertir a ASCII
   547 00000407 8807                        mov [rdi], al
   548                                      
   549                                      ; Mostrar el board con el mensaje
   550                                      print board, board_size
    82 00000409 B801000000          <1>  mov eax, sys_write
    83 0000040E BF01000000          <1>  mov edi, 1
    84 00000413 48BE-               <1>  mov rsi, %1
    84 00000415 [000A000000000000]  <1>
    85 0000041D BA000A0000          <1>  mov edx, %2
    86 00000422 0F05                <1>  syscall
   551                                      
   552                                      ; Esperar un segundo
   553 00000424 B823000000                  mov rax, sys_nanosleep
   554 00000429 48BF-                       mov rdi, level_display_time
   554 0000042B [2F14000000000000] 
   555 00000433 4831F6                      xor rsi, rsi
   556 00000436 0F05                        syscall
   557                                      
   558 00000438 5D                          pop rbp
   559 00000439 C3                          ret
   560                                  
   561                                  ; Función para inicializar un tablero vacío
   562                                  init_empty_board:
   563 0000043A 56                          push rsi
   564 0000043B 57                          push rdi
   565 0000043C 51                          push rcx
   566 0000043D 50                          push rax
   567                                  
   568 0000043E 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   569 00000445 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   570 0000044C B9000A0000                  mov rcx, board_template_size
   571 00000451 F3A4                        rep movsb                   ; Copiar el tablero
   572                                  
   573 00000453 58                          pop rax
   574 00000454 59                          pop rcx
   575 00000455 5F                          pop rdi
   576 00000456 5E                          pop rsi
   577 00000457 C3                          ret
   578                                  
   579                                  
   580                                  init_level:
   581                                      ; 1) Copiamos board_template en board para que quede "virgen"
   582 00000458 E8DDFFFFFF                  call init_empty_board
   583 0000045D E847FFFFFF                  call display_level_number
   584                                      
   585 00000462 56                          push rsi
   586 00000463 57                          push rdi
   587 00000464 51                          push rcx
   588 00000465 50                          push rax
   589                                  
   590 00000466 488D35(00000000)            lea rsi, [board_template]
   591 0000046D 488D3D(000A0000)            lea rdi, [board]
   592 00000474 B9000A0000                  mov rcx, board_template_size
   593 00000479 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   594                                  
   595 0000047B 58                          pop rax
   596 0000047C 59                          pop rcx
   597 0000047D 5F                          pop rdi
   598 0000047E 5E                          pop rsi
   599                                  
   600                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   601 0000047F 803D(A4140000)01            cmp byte [current_level], 1
   602 00000486 7431                        je .level1
   603 00000488 803D(A4140000)02            cmp byte [current_level], 2
   604 0000048F 7454                        je .level2
   605 00000491 803D(A4140000)03            cmp byte [current_level], 3
   606 00000498 7477                        je .level3
   607 0000049A 803D(A4140000)04            cmp byte [current_level], 4
   608 000004A1 0F8492000000                je .level4
   609 000004A7 803D(A4140000)05            cmp byte [current_level], 5
   610 000004AE 0F84AD000000                je .level5
   611 000004B4 E9D0000000                  jmp .done
   612                                  
   613                                      .level1:
   614 000004B9 C605(A5140000)02                mov byte [blocks_remaining], level1_blocks_count
   615 000004C0 4831C9                          xor rcx, rcx             
   616                                          .init_loop1:
   617 000004C3 4883F902                            cmp rcx, level1_blocks_count
   618 000004C7 0F8DBC000000                        jge .done
   619 000004CD 4889C8                              mov rax, rcx         
   620 000004D0 48C1E002                            shl rax, 2          
   621 000004D4 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   622 000004DA 8891[BE140000]                      mov byte [block_states + rcx], dl
   623 000004E0 48FFC1                              inc rcx
   624 000004E3 EBDE                                jmp .init_loop1
   625                                  
   626                                      .level2:
   627 000004E5 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   628 000004EC 4831C9                          xor rcx, rcx             
   629                                          .init_loop2:
   630 000004EF 4883F901                            cmp rcx, level2_blocks_count
   631 000004F3 0F8D90000000                        jge .done
   632 000004F9 4889C8                              mov rax, rcx         
   633 000004FC 48C1E002                            shl rax, 2          
   634 00000500 8A90[B1140000]                      mov dl, byte [level2_blocks + rax + 3]  
   635 00000506 8891[BE140000]                      mov byte [block_states + rcx], dl
   636 0000050C 48FFC1                              inc rcx
   637 0000050F EBDE                                jmp .init_loop2
   638                                      .level3:
   639 00000511 C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   640 00000518 4831C9                          xor rcx, rcx             
   641                                          .init_loop3:
   642 0000051B 4883F901                            cmp rcx, level3_blocks_count
   643 0000051F 7D68                                jge .done
   644 00000521 4889C8                              mov rax, rcx         
   645 00000524 48C1E002                            shl rax, 2          
   646 00000528 8A90[B5140000]                      mov dl, byte [level3_blocks + rax + 3]  
   647 0000052E 8891[BE140000]                      mov byte [block_states + rcx], dl
   648 00000534 48FFC1                              inc rcx
   649 00000537 EBE2                                jmp .init_loop3
   650                                  
   651                                      .level4:
   652 00000539 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   653 00000540 4831C9                          xor rcx, rcx             
   654                                          .init_loop4:
   655 00000543 4883F901                            cmp rcx, level4_blocks_count
   656 00000547 7D40                                jge .done
   657 00000549 4889C8                              mov rax, rcx         
   658 0000054C 48C1E002                            shl rax, 2          
   659 00000550 8A90[B9140000]                      mov dl, byte [level4_blocks + rax + 3]  
   660 00000556 8891[BE140000]                      mov byte [block_states + rcx], dl
   661 0000055C 48FFC1                              inc rcx
   662 0000055F EBE2                                jmp .init_loop4
   663                                  
   664                                      .level5:
   665 00000561 C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   666 00000568 4831C9                          xor rcx, rcx             
   667                                          .init_loop5:
   668 0000056B 4883F901                            cmp rcx, level5_blocks_count
   669 0000056F 7D18                                jge .done
   670 00000571 4889C8                              mov rax, rcx         
   671 00000574 48C1E002                            shl rax, 2          
   672 00000578 8A90[BD140000]                      mov dl, byte [level5_blocks + rax + 3]  
   673 0000057E 8891[BE140000]                      mov byte [block_states + rcx], dl
   674 00000584 48FFC1                              inc rcx
   675 00000587 EBE2                                jmp .init_loop5
   676                                      .done:
   677 00000589 C3                              ret
   678                                  
   679                                  
   680                                  ; Función para verificar y manejar la transición de nivel
   681                                  check_level_complete:
   682                                      ; Verificar si quedan bloques
   683 0000058A 803D(A5140000)00            cmp byte [blocks_remaining], 0
   684 00000591 753C                        jne .not_complete
   685                                      
   686                                      ; Incrementar el nivel
   687 00000593 FE05(A4140000)              inc byte [current_level]
   688                                      
   689                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   690 00000599 803D(A4140000)06            cmp byte [current_level], 6
   691 000005A0 742E                        je game_win
   692                                      
   693                                      ; Reinicializar el juego para el siguiente nivel
   694 000005A2 E8B1FEFFFF                  call init_level
   695                                      
   696                                      ; Reinicializar la posición de la bola y la paleta
   697 000005A7 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   697 000005AF 000000             
   698 000005B2 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   698 000005BA 000000             
   699 000005BD C605(6F140000)00            mov byte [ball_moving], 0
   700 000005C4 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   700 000005CB [38130000]         
   701                                      
   702                                      .not_complete:
   703 000005CF C3                              ret
   704                                  
   705                                      ; Nueva función para manejar la victoria del juego
   706                                      game_win:
   707                                          ; Aquí puedes agregar lógica para mostrar un mensaje de victoria
   708                                          ; y terminar el juego o reiniciarlo
   709 000005D0 E948030000                      jmp exit
   710                                  
   711                                  ; Función para imprimir los bloques
   712                                  ; Función modificada para imprimir bloques
   713                                  
   714                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   715                                  get_current_level_blocks:
   716 000005D5 803D(A4140000)01            cmp byte [current_level], 1
   717 000005DC 7428                        je .level1
   718 000005DE 803D(A4140000)02            cmp byte [current_level], 2
   719 000005E5 7427                        je .level2
   720 000005E7 803D(A4140000)03            cmp byte [current_level], 3
   721 000005EE 7426                        je .level3
   722 000005F0 803D(A4140000)04            cmp byte [current_level], 4
   723 000005F7 7425                        je .level4
   724 000005F9 803D(A4140000)05            cmp byte [current_level], 5
   725 00000600 7424                        je .level5
   726                                      ; Si llegamos aquí, hay un error en el nivel
   727 00000602 4831C0                      xor rax, rax
   728 00000605 C3                          ret
   729                                  
   730                                      .level1:
   731 00000606 488D05(A6140000)                lea rax, [level1_blocks]
   732 0000060D C3                              ret
   733                                      .level2:
   734 0000060E 488D05(AE140000)                lea rax, [level2_blocks]
   735 00000615 C3                              ret
   736                                      .level3:
   737 00000616 488D05(B2140000)                lea rax, [level3_blocks]
   738 0000061D C3                              ret
   739                                      .level4:
   740 0000061E 488D05(B6140000)                lea rax, [level4_blocks]
   741 00000625 C3                              ret
   742                                      .level5:
   743 00000626 488D05(BA140000)                lea rax, [level5_blocks]
   744 0000062D C3                              ret
   745                                  ; Función para obtener la cantidad de bloques del nivel actual
   746                                  get_current_level_count:
   747 0000062E 803D(A4140000)01            cmp byte [current_level], 1
   748 00000635 7428                        je .level1
   749 00000637 803D(A4140000)02            cmp byte [current_level], 2
   750 0000063E 7425                        je .level2
   751 00000640 803D(A4140000)03            cmp byte [current_level], 3
   752 00000647 7422                        je .level3
   753 00000649 803D(A4140000)04            cmp byte [current_level], 4
   754 00000650 741F                        je .level4
   755 00000652 803D(A4140000)05            cmp byte [current_level], 5
   756 00000659 741C                        je .level5
   757                                      ; Si llegamos aquí, hay un error en el nivel
   758 0000065B 4831C0                      xor rax, rax
   759 0000065E C3                          ret
   760                                  
   761                                      .level1:
   762 0000065F B802000000                      mov rax, level1_blocks_count
   763 00000664 C3                              ret
   764                                      .level2:
   765 00000665 B801000000                      mov rax, level2_blocks_count
   766 0000066A C3                              ret
   767                                      .level3:
   768 0000066B B801000000                      mov rax, level3_blocks_count
   769 00000670 C3                              ret
   770                                      .level4:
   771 00000671 B801000000                      mov rax, level4_blocks_count
   772 00000676 C3                              ret
   773                                      .level5:
   774 00000677 B801000000                      mov rax, level5_blocks_count
   775 0000067C C3                              ret
   776                                  
   777                                  
   778                                  print_blocks:
   779 0000067D 55                          push rbp
   780 0000067E 4889E5                      mov rbp, rsp
   781                                      
   782                                      ; Obtener puntero a los bloques del nivel actual
   783 00000681 E84FFFFFFF                  call get_current_level_blocks
   784 00000686 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   785                                      
   786                                      ; Obtener cantidad de bloques del nivel actual
   787 00000689 E8A0FFFFFF                  call get_current_level_count
   788 0000068E 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   789                                      
   790 00000691 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   791                                      
   792                                      .print_loop:
   793 00000694 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   794 00000697 7D69                            jge .end
   795                                          
   796                                          ; Verificar si el bloque está activo
   797 00000699 490FB68424-                     movzx rax, byte [block_states + r12]
   797 0000069E [BE140000]         
   798 000006A2 4885C0                          test rax, rax
   799 000006A5 7456                            jz .next_block
   800                                          
   801                                          ; Obtener posición y tipo del bloque usando r13
   802 000006A7 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   803 000006AC 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   804 000006B1 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   805                                          
   806                                          ; El resto de la lógica de impresión permanece igual
   807 000006B6 4D0FB6C0                        movzx r8, r8b
   808 000006BA 4D0FB6C9                        movzx r9, r9b
   809 000006BE 4981C0[000A0000]                add r8, board
   810 000006C5 B850000000                      mov rax, column_cells + 2
   811 000006CA 49F7E1                          mul r9
   812 000006CD 4901C0                          add r8, rax
   813                                          
   814 000006D0 B906000000                      mov rcx, block_length
   815 000006D5 48BE-                           mov rsi, block_type_1
   815 000006D7 [8014000000000000] 
   816 000006DF 490FB6C2                        movzx rax, r10b
   817 000006E3 48FFC8                          dec rax
   818 000006E6 486BC006                        imul rax, block_length
   819 000006EA 4801C6                          add rsi, rax
   820                                          
   821                                      .print_block_chars:
   822 000006ED 8A06                            mov al, [rsi]
   823 000006EF 418800                          mov [r8], al
   824 000006F2 48FFC6                          inc rsi
   825 000006F5 49FFC0                          inc r8
   826 000006F8 48FFC9                          dec rcx
   827 000006FB 75F0                            jnz .print_block_chars
   828                                          
   829                                      .next_block:
   830 000006FD 49FFC4                          inc r12
   831 00000700 EB92                            jmp .print_loop
   832                                          
   833                                      .end:
   834 00000702 5D                              pop rbp
   835 00000703 C3                              ret
   836                                  
   837                                  
   838                                  ; Función modificada para detectar colisión
   839                                  ; Función mejorada para detectar colisión y manejar la física
   840                                  ; Función corregida para manejar colisiones con bloques completos
   841                                  ;---------------------------------------------------------
   842                                  ; check_block_collision:
   843                                  ;   Detecta si en la posición r10 (que apunta a board[])
   844                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
   845                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
   846                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
   847                                  ;   retorna 0.
   848                                  ;---------------------------------------------------------
   849                                  ;--------------------------------------
   850                                  ; check_block_collision
   851                                  ;--------------------------------------
   852                                  ; Actualizar check_block_collision para usar el nivel actual
   853                                  check_block_collision:
   854 00000704 55                          push rbp
   855 00000705 4889E5                      mov rbp, rsp
   856                                  
   857 00000708 418A02                      mov al, [r10]
   858                                  
   859                                      ; Verificación de caracteres igual que antes...
   860 0000070B 3C55                        cmp al, 'U'  
   861 0000070D 7419                        je .possible
   862 0000070F 3C4F                        cmp al, 'O'  
   863 00000711 7415                        je .possible
   864 00000713 3C44                        cmp al, 'D'  
   865 00000715 7411                        je .possible
   866 00000717 3C4C                        cmp al, 'L'  
   867 00000719 740D                        je .possible
   868 0000071B 3C56                        cmp al, 'V'  
   869 0000071D 7409                        je .possible
   870 0000071F 3C38                        cmp al, '8'  
   871 00000721 7405                        je .possible
   872                                  
   873 00000723 4831C0                      xor rax, rax
   874 00000726 5D                          pop rbp
   875 00000727 C3                          ret
   876                                  
   877                                      .possible:
   878 00000728 53                              push rbx
   879 00000729 57                              push rdi
   880 0000072A 56                              push rsi
   881 0000072B 4154                            push r12
   882                                  
   883                                          ; Obtener puntero a los bloques del nivel actual
   884 0000072D E8A3FEFFFF                      call get_current_level_blocks
   885 00000732 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
   886                                          
   887                                          ; Obtener cantidad de bloques del nivel actual
   888 00000735 E8F4FEFFFF                      call get_current_level_count
   889 0000073A 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
   890                                  
   891 0000073D 4D31E4                          xor r12, r12
   892                                      .find_block_loop:
   893 00000740 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   894 00000743 0F8D8C000000                    jge .no_block_found
   895                                  
   896                                          ; El resto de la lógica de verificación de colisiones...
   897 00000749 418A9C24[BE140000]              mov bl, [block_states + r12]
   898 00000751 84DB                            test bl, bl
   899 00000753 7478                            jz .next_block
   900                                  
   901                                          ; Usar r13 para acceder a los bloques del nivel actual
   902 00000755 4C89E8                          mov rax, r13
   903 00000758 4D6BE404                        imul r12, 4
   904 0000075C 4C01E0                          add rax, r12
   905 0000075F 8A10                            mov dl, [rax]       ; x
   906 00000761 8A4801                          mov cl, [rax+1]     ; y
   907                                  
   908                                          ; Revertir r12
   909 00000764 4D89E4                          mov r12, r12
   910 00000767 49C1EC02                        shr r12, 2
   911                                  
   912                                          ; La misma lógica de detección de colisiones...
   913 0000076B 488D3D(000A0000)                lea rdi, [board]
   914 00000772 4831C0                          xor rax, rax
   915 00000775 B850000000                      mov rax, column_cells + 2
   916 0000077A 480FB6C9                        movzx rcx, cl
   917 0000077E 480FAFC1                        imul rax, rcx
   918 00000782 4801C7                          add rdi, rax
   919 00000785 480FB6C2                        movzx rax, dl
   920 00000789 4801C7                          add rdi, rax
   921                                  
   922 0000078C 4939FA                          cmp r10, rdi
   923 0000078F 723C                            jb .next_block
   924 00000791 488D5F06                        lea rbx, [rdi + 6]
   925 00000795 4939DA                          cmp r10, rbx
   926 00000798 7333                            jae .next_block
   927                                  
   928                                          ; Manejo de colisión igual que antes...
   929 0000079A 41FE8C24[BE140000]              dec byte [block_states + r12]
   930 000007A2 418A9C24[BE140000]              mov bl, [block_states + r12]
   931 000007AA 84DB                            test bl, bl
   932 000007AC 7513                            jnz .still_alive
   933                                  
   934 000007AE B906000000                      mov rcx, block_length
   935                                      .erase_block_chars:
   936 000007B3 C60720                          mov byte [rdi], char_space
   937 000007B6 48FFC7                          inc rdi
   938 000007B9 E2F8                            loop .erase_block_chars
   939                                  
   940 000007BB FE0D(A5140000)                  dec byte [blocks_remaining]
   941                                  
   942                                      .still_alive:
   943 000007C1 B801000000                      mov rax, 1
   944 000007C6 415C                            pop r12
   945 000007C8 5E                              pop rsi
   946 000007C9 5F                              pop rdi
   947 000007CA 5B                              pop rbx
   948 000007CB 5D                              pop rbp
   949 000007CC C3                              ret
   950                                  
   951                                      .next_block:
   952 000007CD 49FFC4                          inc r12
   953 000007D0 E96BFFFFFF                      jmp .find_block_loop
   954                                  
   955                                      .no_block_found:
   956 000007D5 4831C0                          xor rax, rax
   957 000007D8 415C                            pop r12
   958 000007DA 5E                              pop rsi
   959 000007DB 5F                              pop rdi
   960 000007DC 5B                              pop rbx
   961 000007DD 5D                              pop rbp
   962 000007DE C3                              ret
   963                                  
   964                                  
   965                                  
   966                                  _start:
   967 000007DF E847F9FFFF              	call canonical_off
   968 000007E4 E8C1000000              	call start_screen
   969 000007E9 E86AFCFFFF                  call init_level
   970 000007EE EB00                    	jmp .main_loop
   971                                  	
   972                                  
   973                                  	.main_loop:
   974 000007F0 E810FAFFFF              		call print_pallet
   975 000007F5 E89BFAFFFF                      call move_ball
   976 000007FA E87EFEFFFF                      call print_blocks
   977 000007FF E886FDFFFF                      call check_level_complete
   978 00000804 E8D4F9FFFF              		call print_ball
   979                                  		print board, board_size				
    82 00000809 B801000000          <1>  mov eax, sys_write
    83 0000080E BF01000000          <1>  mov edi, 1
    84 00000813 48BE-               <1>  mov rsi, %1
    84 00000815 [000A000000000000]  <1>
    85 0000081D BA000A0000          <1>  mov edx, %2
    86 00000822 0F05                <1>  syscall
   980                                  		;setnonblocking	
   981                                  	.read_more:	
   982                                  		getchar	
    90 00000824 B800000000          <1>  mov rax, sys_read
    91 00000829 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000082E 48BE-               <1>  mov rsi, input_char
    92 00000830 [0000000000000000]  <1>
    93 00000838 BA01000000          <1>  mov rdx, 1
    94 0000083D 0F05                <1>  syscall
   983                                  		
   984 0000083F 4883F801                		cmp rax, 1
   985 00000843 7532                        	jne .done
   986                                  		
   987 00000845 8A05(00000000)          		mov al,[input_char]
   988                                  
   989 0000084B 3C61                    		cmp al, 'a'
   990 0000084D 750E                    	    jne .not_left
   991 0000084F 48C7C7FFFFFFFF          	    mov rdi, left_direction
   992 00000856 E8C5F9FFFF              		call move_pallet
   993 0000085B EB1A                    	    jmp .done
   994                                  		
   995                                  		.not_left:
   996 0000085D 3C64                    		 	cmp al, 'd'
   997 0000085F 750C                    	    	jne .not_right
   998 00000861 BF01000000              			mov rdi, right_direction
   999 00000866 E8B5F9FFFF              	    	call move_pallet
  1000 0000086B EB0A                        		jmp .done		
  1001                                  
  1002                                  		.not_right:
  1003                                  
  1004 0000086D 3C71                        		cmp al, 'q'
  1005 0000086F 0F84A8000000                		je exit
  1006                                  
  1007 00000875 EBAD                    			jmp .read_more
  1008                                  		
  1009                                  		.done:	
  1010                                  			;unsetnonblocking		
  1011                                  			sleeptime	
    98 00000877 B823000000          <1>  mov eax, sys_nanosleep
    99 0000087C 48BF-               <1>  mov rdi, timespec
    99 0000087E [0000000000000000]  <1>
   100 00000886 31F6                <1>  xor esi, esi
   101 00000888 0F05                <1>  syscall
  1012                                  			print clear, clear_length
    82 0000088A B801000000          <1>  mov eax, sys_write
    83 0000088F BF01000000          <1>  mov edi, 1
    84 00000894 48BE-               <1>  mov rsi, %1
    84 00000896 [1000000000000000]  <1>
    85 0000089E BA07000000          <1>  mov edx, %2
    86 000008A3 0F05                <1>  syscall
  1013 000008A5 E946FFFFFF                  		jmp .main_loop
  1014                                  
  1015                                  
  1016                                  
  1017                                  start_screen:
  1018                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000008AA B801000000          <1>  mov eax, sys_write
    83 000008AF BF01000000          <1>  mov edi, 1
    84 000008B4 48BE-               <1>  mov rsi, %1
    84 000008B6 [1000000000000000]  <1>
    85 000008BE BA07000000          <1>  mov edx, %2
    86 000008C3 0F05                <1>  syscall
  1019                                      print msg1, msg1_length
    82 000008C5 B801000000          <1>  mov eax, sys_write
    83 000008CA BF01000000          <1>  mov edi, 1
    84 000008CF 48BE-               <1>  mov rsi, %1
    84 000008D1 [1700000000000000]  <1>
    85 000008D9 BA14010000          <1>  mov edx, %2
    86 000008DE 0F05                <1>  syscall
  1020                                      
  1021                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1022                                          getchar                 ; Esperamos una tecla
    90 000008E0 B800000000          <1>  mov rax, sys_read
    91 000008E5 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000008EA 48BE-               <1>  mov rsi, input_char
    92 000008EC [0000000000000000]  <1>
    93 000008F4 BA01000000          <1>  mov rdx, 1
    94 000008F9 0F05                <1>  syscall
  1023 000008FB 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1024 000008FF 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1025                                          
  1026                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000901 B801000000          <1>  mov eax, sys_write
    83 00000906 BF01000000          <1>  mov edi, 1
    84 0000090B 48BE-               <1>  mov rsi, %1
    84 0000090D [1000000000000000]  <1>
    85 00000915 BA07000000          <1>  mov edx, %2
    86 0000091A 0F05                <1>  syscall
  1027 0000091C C3                          ret
  1028                                  
  1029                                  exit: 
  1030 0000091D E84BF8FFFF              	call canonical_on
  1031 00000922 B83C000000              	mov    rax, 60
  1032 00000927 BF00000000                  mov    rdi, 0
  1033 0000092C 0F05                        syscall
  1034                                  
