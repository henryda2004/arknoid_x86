     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030150                      db 58, 7, 3, 1, 'P'    ; Bloque 7
   290 000014BB 3D09030145                      db 61, 9, 3, 1, 'E'    ; Bloque 7
   291 000014C0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   292                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   293                                  
   294                                      ; Nivel 2: Bloques de prueba
   295                                      level2_blocks:
   296 000014C5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   297                                      level2_blocks_count equ 1
   298                                  
   299                                      ; Nivel 3
   300                                      level3_blocks:
   301 000014CA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   302                                  
   303                                      level3_blocks_count equ 1
   304                                  
   305                                      ; Nivel 4
   306                                      level4_blocks:
   307 000014CF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   308                                      level4_blocks_count equ 1
   309                                  
   310                                      ; Nivel 5
   311                                      level5_blocks:
   312 000014D4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   313                                      level5_blocks_count equ 1
   314                                  
   315                                      ; Array para mantener el estado de los bloques
   316 000014D9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   317                                  
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153D 0000000000000000            current_score dq 0          ; Score actual
   321 00001545 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001546 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 0000155A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000157D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   331                                      
   332 0000157E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001586 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001587 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   335 00001588 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001589 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 0000158A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   339                                      ; Añade esto en la sección .dataa
   340 0000158B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   340 00001594 12                 
   341 00001595 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   341 0000159E 13                 
   342 0000159F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   342 000015A8 1B                 
   343 000015A9 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   343 000015B2 1C                 
   344 000015B3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   344 000015BC 2D                 
   345                                          ; Arreglo de punteros a los spawn points de cada nivel
   346                                      spawn_points_table:
   347 000015BD [8B15000000000000]              dq level1_spawn_points
   348 000015C5 [9515000000000000]              dq level2_spawn_points
   349 000015CD [9F15000000000000]              dq level3_spawn_points
   350 000015D5 [A915000000000000]              dq level4_spawn_points
   351 000015DD [B315000000000000]              dq level5_spawn_points
   352                                  
   353                                      ; Variables para el comportamiento de enemigos
   354 000015E5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   355 000015E6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   356 000015E7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   357 000015E8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   358                                  
   359 000015F2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   359 000015FB 5B2020202020202020-
   359 00001604 20205D0A0D         
   360                                      score_label_len: equ $ - score_label
   361 00001609 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   361 00001612 657374727569646F73-
   361 0000161B 3A205B2020205D0A0D 
   362                                      blocks_label_len: equ $ - blocks_label
   363                                      
   364                                      ; Posición donde insertar los números en los labels
   365                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   366                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   367                                      
   368                                      ; Definición de las vidas (x, y, estado)
   369                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   370                                      lives_data: 
   371 00001624 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   372 00001627 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   373 0000162A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   374 0000162D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   375 00001630 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   376 00001633 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   377 00001636 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   378                                      lives_count equ 7    ; Total de vidas
   379 00001639 5E                          life_char db "^"    
   380 0000163A 04                          current_lives db 4   ; Contador de vidas activas actual
   381                                  
   382                                  ; Estructura para almacenar las letras y sus posiciones
   383                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   384 0000163B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   385 000017CB 00                          letters_count db 0   
   386 000017CC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   387 000017CD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   387 000017D6 75616C3A205B205D0A-
   387 000017DF 0D                 
   388                                      last_letter_msg_len equ $ - last_letter_msg
   389 000017E0 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   390 000017E1 07                          max_lives db 7              ; Máximo número de vidas permitidas
   391                                  
   392                                  section .text
   393                                  
   394                                  
   395                                  print_lives:
   396 000001DD 55                          push rbp
   397 000001DE 4889E5                      mov rbp, rsp
   398                                      
   399 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   400                                      
   401                                      .print_loop:
   402 000001E4 4983FC07                        cmp r12, lives_count
   403 000001E8 7D45                            jge .end
   404                                          
   405                                          ; Calcular offset de la vida actual
   406 000001EA 4C89E0                          mov rax, r12
   407 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   408 000001F1 488DB0[24160000]                lea rsi, [lives_data + rax]
   409                                          
   410                                          ; Calcular posición en el tablero
   411 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   412 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   413                                          
   414                                          ; Calcular offset en el tablero
   415 00000201 B84E000000                      mov rax, column_cells
   416 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   417 0000020A 49F7E1                          mul r9
   418 0000020D 4C01C0                          add rax, r8
   419 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   420                                          
   421                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   422 00000217 807E0201                        cmp byte [rsi + 2], 1
   423 0000021B 7405                            je .draw_active
   424                                          
   425                                          ; Si está inactiva, dibujar espacio
   426 0000021D C60720                          mov byte [rdi], ' '
   427 00000220 EB08                            jmp .next_life
   428                                          
   429                                      .draw_active:
   430                                          ; Si está activa, dibujar el símbolo de vida
   431 00000222 8A05(39160000)                  mov al, [life_char]
   432 00000228 8807                            mov [rdi], al
   433                                          
   434                                      .next_life:
   435 0000022A 49FFC4                          inc r12
   436 0000022D EBB5                            jmp .print_loop
   437                                          
   438                                      .end:
   439 0000022F 5D                              pop rbp
   440 00000230 C3                              ret
   441                                  
   442                                  ; Función para desactivar una vida
   443                                  ; Función modificada para perder una vida
   444                                  lose_life:
   445 00000231 55                          push rbp
   446 00000232 4889E5                      mov rbp, rsp
   447                                      
   448                                      ; Verificar si aún quedan vidas
   449 00000235 803D(3A160000)00            cmp byte [current_lives], 0
   450 0000023C 0F8493000000                je .game_lost
   451                                      
   452                                      ; Encontrar la última vida activa
   453 00000242 B907000000                  mov rcx, lives_count
   454 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   455                                      
   456                                      .find_active_life:
   457 0000024A 4889C8                          mov rax, rcx
   458 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   459 00000251 488DB0[24160000]                lea rsi, [lives_data + rax]
   460 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   461 0000025C 7407                            je .deactivate_life
   462 0000025E 48FFC9                          dec rcx
   463 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   464 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   465                                          
   466                                      .deactivate_life:
   467                                          ; Calcular posición correcta en el tablero para borrar la vida
   468 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   469 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   470                                          
   471                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   472 0000026E B84E000000                      mov rax, column_cells
   473 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   474 00000277 49F7E1                          mul r9
   475 0000027A 4C01C0                          add rax, r8
   476 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   477                                          
   478                                          ; Borrar visualmente la vida
   479 00000284 C60720                          mov byte [rdi], ' '             
   480                                          
   481                                          ; Desactivar la vida en los datos
   482 00000287 C6460200                        mov byte [rsi + 2], 0          
   483 0000028B FE0D(3A160000)                  dec byte [current_lives]
   484                                          
   485                                          ; Borrar visualmente la paleta anterior
   486 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   487 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   488                                          .erase_pallet_loop:
   489 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   490 000002A3 49FFC0                              inc r8
   491 000002A6 48FFC9                              dec rcx
   492 000002A9 75F4                                jnz .erase_pallet_loop
   493                                          
   494                                  
   495                                          ; Reiniciar posición de la bola y la paleta
   496 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   496 000002B3 000000             
   497 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   497 000002BE 000000             
   498 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   499 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   499 000002CF [36130000]         
   500                                          
   501 000002D3 EB07                            jmp .end
   502                                          
   503                                      .game_lost:
   504 000002D5 E81C000000                      call game_lost
   505 000002DA EB00                            jmp .end
   506                                          
   507                                      .end:
   508 000002DC 5D                              pop rbp
   509 000002DD C3                              ret
   510                                  ; Función modificada para verificar colisión con el borde inferior
   511                                  check_bottom_collision:
   512 000002DE 55                          push rbp
   513 000002DF 4889E5                      mov rbp, rsp
   514                                      
   515                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   516 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   517 000002E9 4883F81E                    cmp rax, row_cells - 2
   518 000002ED 7505                        jne .no_collision
   519                                      
   520                                      ; Si hay colisión, perder una vida
   521 000002EF E83DFFFFFF                  call lose_life
   522                                      
   523                                      .no_collision:
   524 000002F4 5D                              pop rbp
   525 000002F5 C3                              ret
   526                                  
   527                                  ; Nueva función para game over
   528                                  game_lost:
   529                                      ; Limpiar la pantalla
   530                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   531                                      
   532                                      ; Mostrar mensaje de derrota
   533                                      section .data
   534 000017E2 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   534 000017EB 6469646F210A0D     
   535                                          lost_msg_len: equ $ - lost_msg
   536                                      section .text
   537                                      
   538                                      ; Imprimir mensaje de derrota
   539                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [E217000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   540                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [1018000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   541                                      
   542                                      ; Mostrar puntaje final
   543 00000347 488B05(3D150000)            mov rax, [current_score]
   544 0000034E 48BF-                       mov rdi, number_buffer
   544 00000350 [4615000000000000] 
   545 00000358 E800090000                  call number_to_string
   546                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   547                                      
   548                                      ; Esperar un momento antes de salir
   549 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   549 00000381 0000               
   550 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   550 0000038C 0000               
   551                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   552                                      
   553 000003A1 E995100000                  jmp exit
   554                                  
   555                                  
   556                                  ; Función para registrar una nueva letra en el mapa
   557                                  ; Entrada:
   558                                  ;   al - letra a registrar
   559                                  ;   r8b - posición x
   560                                  ;   r9b - posición y
   561                                  register_letter:
   562 000003A6 55                          push rbp
   563 000003A7 4889E5                      mov rbp, rsp
   564 000003AA 53                          push rbx
   565 000003AB 51                          push rcx
   566                                      
   567 000003AC 3C20                        cmp al, ' '
   568 000003AE 7438                        je .end
   569                                  
   570                                      ; Encontrar un espacio libre en el mapa
   571 000003B0 4831C9                      xor rcx, rcx
   572 000003B3 480FB615(CB170000)          movzx rdx, byte [letters_count]
   573                                      
   574                                      .find_slot:
   575 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   576 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   577                                          
   578 000003C1 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   579 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   580 000003CD 7405                            je .found_slot
   581                                          
   582 000003CF 48FFC1                          inc rcx
   583 000003D2 EBE7                            jmp .find_slot
   584                                          
   585                                      .found_slot:
   586                                          ; Guardar la información de la letra
   587 000003D4 448803                          mov [rbx], r8b           ; x
   588 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   589 000003DB 884302                          mov [rbx + 2], al        ; letra
   590 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   591                                          
   592 000003E2 FE05(CB170000)                  inc byte [letters_count]
   593                                          
   594                                      .end:
   595 000003E8 59                              pop rcx
   596 000003E9 5B                              pop rbx
   597 000003EA 5D                              pop rbp
   598 000003EB C3                              ret
   599                                  
   600                                  ; Función para imprimir todas las letras registradas
   601                                  print_letters:
   602 000003EC 55                          push rbp
   603 000003ED 4889E5                      mov rbp, rsp
   604 000003F0 53                          push rbx
   605 000003F1 51                          push rcx
   606                                      
   607 000003F2 4831C9                      xor rcx, rcx
   608                                      
   609                                      .print_loop:
   610 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   611 000003F9 7D37                            jge .end
   612                                          
   613                                          ; Obtener puntero a la letra actual
   614 000003FB 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   615                                          
   616                                          ; Verificar si está activa
   617 00000403 807B0300                        cmp byte [rbx + 3], 0
   618 00000407 7424                            je .next_letter
   619                                          
   620                                          ; Calcular posición en el tablero
   621 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   622 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   623                                          
   624                                          ; Calcular offset en el tablero
   625 00000412 B84E000000                      mov rax, column_cells
   626 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   627 0000041B 49F7E1                          mul r9
   628 0000041E 4C01C0                          add rax, r8
   629 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   630                                          
   631                                          ; Imprimir la letra
   632 00000428 8A4302                          mov al, [rbx + 2]
   633 0000042B 8807                            mov [rdi], al
   634                                          
   635                                      .next_letter:
   636 0000042D 48FFC1                          inc rcx
   637 00000430 EBC3                            jmp .print_loop
   638                                          
   639                                      .end:
   640 00000432 59                              pop rcx
   641 00000433 5B                              pop rbx
   642 00000434 5D                              pop rbp
   643 00000435 C3                              ret
   644                                  
   645                                  ; Función para borrar una letra específica
   646                                  ; Entrada:
   647                                  ;   r8b - posición x
   648                                  ;   r9b - posición y
   649                                  remove_letter:
   650 00000436 55                          push rbp
   651 00000437 4889E5                      mov rbp, rsp
   652 0000043A 53                          push rbx
   653 0000043B 51                          push rcx
   654                                      
   655 0000043C 4831C9                      xor rcx, rcx
   656                                      
   657                                      .find_loop:
   658 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   659 00000443 7D2E                            jge .end
   660                                          
   661 00000445 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   662                                          
   663                                          ; Verificar si está activa y coincide la posición
   664 0000044D 807B0300                        cmp byte [rbx + 3], 0
   665 00000451 741B                            je .next_letter
   666                                          
   667 00000453 8A03                            mov al, [rbx]
   668 00000455 4438C0                          cmp al, r8b
   669 00000458 7514                            jne .next_letter
   670                                          
   671 0000045A 8A4301                          mov al, [rbx + 1]
   672 0000045D 4438C8                          cmp al, r9b
   673 00000460 750C                            jne .next_letter
   674                                          
   675                                          ; Encontrada la letra, desactivarla
   676 00000462 C6430300                        mov byte [rbx + 3], 0
   677 00000466 FE0D(CB170000)                  dec byte [letters_count]
   678 0000046C EB05                            jmp .end
   679                                          
   680                                      .next_letter:
   681 0000046E 48FFC1                          inc rcx
   682 00000471 EBCC                            jmp .find_loop
   683                                          
   684                                      .end:
   685 00000473 59                              pop rcx
   686 00000474 5B                              pop rbx
   687 00000475 5D                              pop rbp
   688 00000476 C3                              ret
   689                                  ; Función para mover las letras hacia abajo
   690                                  move_letters:
   691 00000477 55                          push rbp
   692 00000478 4889E5                      mov rbp, rsp
   693 0000047B 53                          push rbx
   694 0000047C 57                          push rdi
   695 0000047D 56                          push rsi
   696 0000047E 4150                        push r8
   697 00000480 4151                        push r9
   698 00000482 4152                        push r10
   699 00000484 4153                        push r11
   700                                  
   701 00000486 4831C9                      xor rcx, rcx
   702                                  
   703                                      .move_loop:
   704 00000489 4883F964                        cmp rcx, 100
   705 0000048D 0F8DD7000000                    jge .print_last_letter
   706                                          
   707 00000493 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   708 0000049B 807B0300                        cmp byte [rbx + 3], 0
   709 0000049F 0F84BD000000                    je .next_letter
   710                                  
   711 000004A5 4C0FB603                        movzx r8, byte [rbx]
   712 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   713                                  
   714 000004AE B84E000000                      mov rax, column_cells
   715 000004B3 4883C002                        add rax, 2
   716 000004B7 49F7E1                          mul r9
   717 000004BA 4C01C0                          add rax, r8
   718 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   719 000004C4 C60720                          mov byte [rdi], ' '
   720                                  
   721 000004C7 FE4301                          inc byte [rbx + 1]
   722 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   723                                  
   724 000004CF 4983F91F                        cmp r9, row_cells - 1
   725 000004D3 7C09                            jl .check_pallet_collision
   726                                  
   727 000004D5 C6430300                        mov byte [rbx + 3], 0
   728 000004D9 E984000000                      jmp .next_letter
   729                                  
   730                                          .check_pallet_collision:
   731 000004DE B84E000000                          mov rax, column_cells
   732 000004E3 4883C002                            add rax, 2
   733 000004E7 49F7E1                              mul r9
   734 000004EA 4C01C0                              add rax, r8
   735 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   736                                  
   737 000004F4 8A07                                mov al, [rdi]
   738 000004F6 3C20                                cmp al, ' '
   739 000004F8 7468                                je .next_letter
   740 000004FA 3C3D                                cmp al, char_equal
   741 000004FC 7407                                je .capture_letter
   742                                  
   743 000004FE 8A4302                              mov al, [rbx + 2]
   744 00000501 8807                                mov [rdi], al
   745 00000503 EB5D                                jmp .next_letter
   746                                  
   747                                          .capture_letter:
   748                                              ; Obtener la nueva letra
   749 00000505 8A4302                              mov al, [rbx + 2]
   750                                              
   751                                              ; Comparar con la última letra
   752 00000508 3A05(CC170000)                      cmp al, [last_letter]
   753 0000050E 7407                                je .same_letter
   754                                              
   755                                              ; Es una letra diferente, resetear el procesamiento
   756 00000510 C605(E0170000)00                    mov byte [current_power_processed], 0
   757                                              
   758                                              .same_letter:
   759                                              ; Guardar la nueva letra
   760 00000517 8805(CC170000)                      mov [last_letter], al
   761                                              
   762                                              ; Verificar si es 'E' para extender la paleta
   763 0000051D 3C45                                cmp al, 'E'
   764 0000051F 7414                                je .extend_pallet
   765                                              
   766                                              ; Verificar si es 'P' para añadir vida
   767 00000521 3C50                                cmp al, 'P'
   768 00000523 7420                                je .check_add_life
   769                                              
   770                                              ; Si no es ningún power-up, restaurar tamaño normal
   771 00000525 488B05(4F140000)                    mov rax, [default_pallet_size]
   772 0000052C 488905(47140000)                    mov [pallet_size], rax
   773 00000533 EB29                                jmp .finish_capture
   774                                  
   775                                              .extend_pallet:
   776 00000535 488B05(57140000)                        mov rax, [extended_pallet_size]
   777 0000053C 488905(47140000)                        mov [pallet_size], rax
   778 00000543 EB19                                    jmp .finish_capture
   779                                  
   780                                              .check_add_life:
   781                                                  ; Verificar si ya procesamos este power-up
   782 00000545 803D(E0170000)00                        cmp byte [current_power_processed], 0
   783 0000054C 7510                                    jne .finish_capture
   784                                                  
   785                                                  ; Preservar registros importantes
   786 0000054E 51                                      push rcx
   787 0000054F 53                                      push rbx
   788                                                  
   789                                                  ; Marcar como procesado
   790 00000550 C605(E0170000)01                        mov byte [current_power_processed], 1
   791                                                  
   792                                                  ; Añadir una vida
   793 00000557 E85D000000                              call add_life
   794                                                  
   795                                                  ; Restaurar registros
   796 0000055C 5B                                      pop rbx
   797 0000055D 59                                      pop rcx
   798                                                  
   799                                              .finish_capture:
   800 0000055E C6430300                                mov byte [rbx + 3], 0
   801                                  
   802                                          .next_letter:
   803 00000562 48FFC1                              inc rcx
   804 00000565 E91FFFFFFF                          jmp .move_loop
   805                                  
   806                                      .print_last_letter:
   807                                          print last_letter_msg, last_letter_msg_len - 3
    82 0000056A B801000000          <1>  mov eax, sys_write
    83 0000056F BF01000000          <1>  mov edi, 1
    84 00000574 48BE-               <1>  mov rsi, %1
    84 00000576 [CD17000000000000]  <1>
    85 0000057E BA10000000          <1>  mov edx, %2
    86 00000583 0F05                <1>  syscall
   808 00000585 8A05(CC170000)                  mov al, [last_letter]
   809 0000058B 8805(DC170000)                  mov [last_letter_msg + 15], al
   810                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000591 B801000000          <1>  mov eax, sys_write
    83 00000596 BF01000000          <1>  mov edi, 1
    84 0000059B 48BE-               <1>  mov rsi, %1
    84 0000059D [DD17000000000000]  <1>
    85 000005A5 BA03000000          <1>  mov edx, %2
    86 000005AA 0F05                <1>  syscall
   811                                  
   812                                      .end:
   813 000005AC 415B                            pop r11
   814 000005AE 415A                            pop r10
   815 000005B0 4159                            pop r9
   816 000005B2 4158                            pop r8
   817 000005B4 5E                              pop rsi
   818 000005B5 5F                              pop rdi
   819 000005B6 5B                              pop rbx
   820 000005B7 5D                              pop rbp
   821 000005B8 C3                              ret
   822                                  
   823                                  add_life:
   824 000005B9 55                          push rbp
   825 000005BA 4889E5                      mov rbp, rsp
   826 000005BD 53                          push rbx
   827 000005BE 51                          push rcx
   828 000005BF 57                          push rdi
   829 000005C0 56                          push rsi
   830 000005C1 4150                        push r8
   831 000005C3 4151                        push r9
   832                                      
   833                                      ; Verificar si ya tenemos el máximo de vidas
   834 000005C5 480FB605(3A160000)          movzx rax, byte [current_lives]
   835 000005CD 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
   836 000005D1 7D2C                        jge .end
   837                                      
   838                                      ; Incrementar el contador de vidas
   839 000005D3 FE05(3A160000)              inc byte [current_lives]
   840                                      
   841                                      ; Encontrar la siguiente vida inactiva
   842 000005D9 4831C9                      xor rcx, rcx
   843                                      
   844                                      .find_inactive:
   845 000005DC 4883F907                        cmp rcx, lives_count
   846 000005E0 7D1D                            jge .end
   847                                          
   848                                          ; Calcular offset de la vida actual
   849 000005E2 4889C8                          mov rax, rcx
   850 000005E5 486BC003                        imul rax, 3
   851 000005E9 488DB0[24160000]                lea rsi, [lives_data + rax]
   852                                          
   853                                          ; Verificar si está inactiva
   854 000005F0 807E0200                        cmp byte [rsi + 2], 0
   855 000005F4 7405                            je .activate_life
   856                                          
   857 000005F6 48FFC1                          inc rcx
   858 000005F9 EBE1                            jmp .find_inactive
   859                                          
   860                                      .activate_life:
   861                                          ; Activar la vida
   862 000005FB C6460201                        mov byte [rsi + 2], 1
   863                                          
   864                                      .end:
   865 000005FF 4159                            pop r9
   866 00000601 4158                            pop r8
   867 00000603 5E                              pop rsi
   868 00000604 5F                              pop rdi
   869 00000605 59                              pop rcx
   870 00000606 5B                              pop rbx
   871 00000607 5D                              pop rbp
   872 00000608 C3                              ret
   873                                  
   874                                  
   875                                  print_ball:
   876 00000609 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   877 00000610 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   878 00000617 4981C0[000A0000]        	add r8, board
   879                                  
   880 0000061E 4C89C9                  	mov rcx, r9
   881 00000621 B850000000              	mov rax, column_cells + 2
   882 00000626 48F7E9                  	imul rcx
   883                                  	
   884 00000629 4901C0                  	add r8, rax
   885 0000062C 41C6004F                	mov byte [r8], char_O
   886 00000630 C3                      	ret
   887                                  
   888                                  	
   889                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   890                                  	
   891                                  print_pallet:
   892                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   893 00000631 4C8B05(3F140000)            mov r8, [pallet_position]
   894 00000638 488B0D(57140000)            mov rcx, [extended_pallet_size]
   895                                      .clear_pallet:
   896 0000063F 41C60020                        mov byte [r8], char_space
   897 00000643 49FFC0                          inc r8
   898 00000646 48FFC9                          dec rcx
   899 00000649 75F4                            jnz .clear_pallet
   900                                  
   901                                      ; Luego dibujar la nueva paleta con el tamaño actual
   902 0000064B 4C8B05(3F140000)            mov r8, [pallet_position]
   903 00000652 488B0D(47140000)            mov rcx, [pallet_size]
   904                                      .write_pallet:
   905 00000659 41C6003D                        mov byte [r8], char_equal
   906 0000065D 49FFC0                          inc r8
   907 00000660 48FFC9                          dec rcx
   908 00000663 75F4                            jnz .write_pallet
   909                                  
   910 00000665 C3                          ret
   911                                  
   912                                  move_pallet:
   913                                      
   914 00000666 803D(7F140000)00            cmp byte [ball_moving], 0
   915 0000066D 7507                        jne .continue_movement
   916 0000066F C605(7F140000)01            mov byte [ball_moving], 1
   917                                  
   918                                      .continue_movement:
   919 00000676 4883FFFF                        cmp rdi, left_direction
   920 0000067A 7531                            jne .move_right
   921                                  
   922                                          .move_left:
   923                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   924 0000067C 4C8B05(3F140000)                    mov r8, [pallet_position]
   925 00000683 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   926 00000686 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   927 00000689 3C58                                cmp al, 'X'        ; Comparar si es una X
   928 0000068B 744D                                je .end            ; Si es X, no mover
   929                                              
   930 0000068D 4C8B05(3F140000)                    mov r8, [pallet_position]
   931 00000694 4C8B0D(47140000)                    mov r9, [pallet_size]
   932 0000069B 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   933 000006A1 49FFC8                              dec r8
   934 000006A4 4C8905(3F140000)                    mov [pallet_position], r8
   935 000006AB EB2D                                jmp .end
   936                                              
   937                                          .move_right:
   938                                              ; Verificar si la siguiente posición después de la paleta sería una X
   939 000006AD 4C8B05(3F140000)                    mov r8, [pallet_position]
   940 000006B4 4C8B0D(47140000)                    mov r9, [pallet_size]
   941 000006BB 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   942 000006BE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   943 000006C1 3C58                                cmp al, 'X'        ; Comparar si es una X
   944 000006C3 7415                                je .end            ; Si es X, no mover
   945                                              
   946 000006C5 4C8B05(3F140000)                    mov r8, [pallet_position]
   947 000006CC 41C60020                            mov byte [r8], char_space
   948 000006D0 49FFC0                              inc r8
   949 000006D3 4C8905(3F140000)                    mov [pallet_position], r8
   950                                          .end:
   951 000006DA C3                                  ret
   952                                  
   953                                  move_ball:
   954                                      ; Si la bola no está en movimiento, no hacer nada
   955 000006DB 803D(7F140000)00            cmp byte [ball_moving], 0
   956 000006E2 0F8406010000                je .end
   957                                  
   958                                      ; Borrar la posición actual de la bola
   959 000006E8 4C8B05(5F140000)            mov r8, [ball_x_pos]
   960 000006EF 4C8B0D(67140000)            mov r9, [ball_y_pos]
   961 000006F6 4981C0[000A0000]            add r8, board
   962 000006FD 4C89C9                      mov rcx, r9
   963 00000700 B850000000                  mov rax, column_cells + 2
   964 00000705 48F7E9                      imul rcx
   965 00000708 4901C0                      add r8, rax
   966 0000070B 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   967                                  
   968                                      ; Calcular siguiente posición X
   969 0000070F 4C8B05(5F140000)            mov r8, [ball_x_pos]
   970 00000716 4C8B0D(67140000)            mov r9, [ball_y_pos]
   971 0000071D 488B05(6F140000)            mov rax, [ball_direction_x]
   972 00000724 4901C0                      add r8, rax                  ; Nueva posición X
   973                                  
   974                                      ; Calcular la dirección de memoria para la siguiente posición
   975 00000727 4D89C2                      mov r10, r8
   976 0000072A 4981C2[000A0000]            add r10, board
   977 00000731 4C89C9                      mov rcx, r9
   978 00000734 B850000000                  mov rax, column_cells + 2
   979 00000739 48F7E9                      imul rcx
   980 0000073C 4901C2                      add r10, rax
   981                                  
   982                                      ; Verificar si hay una X en la siguiente posición X
   983 0000073F 418A02                      mov al, [r10]
   984 00000742 3C58                        cmp al, 'X'
   985 00000744 750C                        jne .check_block_x
   986 00000746 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   987 0000074D E99C000000                  jmp .end
   988                                  
   989                                      .check_block_x:
   990                                          ; Verificar colisión con bloques en X
   991 00000752 4150                            push r8     ; Guardar registros que usa check_block_collision
   992 00000754 4151                            push r9
   993 00000756 4152                            push r10
   994 00000758 E858060000                      call check_block_collision
   995 0000075D 415A                            pop r10
   996 0000075F 4159                            pop r9
   997 00000761 4158                            pop r8
   998 00000763 4885C0                          test rax, rax
   999 00000766 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1000 00000768 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1001 0000076F EB7D                            jmp .end
  1002                                  
  1003                                      .check_paddle_x:
  1004                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1005 00000771 41803A3D                        cmp byte [r10], char_equal
  1006 00000775 7509                            jne .check_y_movement
  1007 00000777 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1008 0000077E EB6E                            jmp .end
  1009                                  
  1010                                      .check_y_movement:
  1011                                          ; Calcular siguiente posición Y
  1012 00000780 488B05(77140000)                mov rax, [ball_direction_y]
  1013 00000787 4901C1                          add r9, rax                  ; Nueva posición Y
  1014                                  
  1015                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1016 0000078A 4D89C2                          mov r10, r8
  1017 0000078D 4981C2[000A0000]                add r10, board
  1018 00000794 4C89C9                          mov rcx, r9
  1019 00000797 B850000000                      mov rax, column_cells + 2
  1020 0000079C 48F7E9                          imul rcx
  1021 0000079F 4901C2                          add r10, rax
  1022                                  
  1023                                          ; Verificar si hay una X en la siguiente posición Y
  1024 000007A2 418A02                          mov al, [r10]
  1025 000007A5 3C58                            cmp al, 'X'
  1026 000007A7 7509                            jne .check_block_y
  1027 000007A9 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1028 000007B0 EB3C                            jmp .end
  1029                                  
  1030                                      .check_block_y:
  1031                                          ; Verificar colisión con bloques en Y
  1032 000007B2 4150                            push r8     ; Guardar registros que usa check_block_collision
  1033 000007B4 4151                            push r9
  1034 000007B6 4152                            push r10
  1035 000007B8 E8F8050000                      call check_block_collision
  1036 000007BD 415A                            pop r10
  1037 000007BF 4159                            pop r9
  1038 000007C1 4158                            pop r8
  1039 000007C3 4885C0                          test rax, rax
  1040 000007C6 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1041 000007C8 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1042 000007CF EB1D                            jmp .end
  1043                                  
  1044                                      .check_paddle_y:
  1045                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
  1046 000007D1 41803A3D                    cmp byte [r10], char_equal
  1047 000007D5 7509                        jne .update_position
  1048 000007D7 48F71D(77140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1049 000007DE EB0E                        jmp .end
  1050                                  
  1051                                  
  1052                                      .update_position:
  1053 000007E0 4C8905(5F140000)                mov [ball_x_pos], r8
  1054 000007E7 4C890D(67140000)                mov [ball_y_pos], r9
  1055                                  
  1056                                      .end:
  1057 000007EE C3                              ret
  1058                                  
  1059                                  ; Función para inicializar el nivel
  1060                                  ; Función para inicializar el nivel
  1061                                  ; Función para mostrar el número de nivel
  1062                                  display_level_number:
  1063 000007EF 55                          push rbp
  1064 000007F0 4889E5                      mov rbp, rsp
  1065                                      
  1066                                      ; Limpiar la pantalla primero
  1067                                      print clear, clear_length
    82 000007F3 B801000000          <1>  mov eax, sys_write
    83 000007F8 BF01000000          <1>  mov edi, 1
    84 000007FD 48BE-               <1>  mov rsi, %1
    84 000007FF [1000000000000000]  <1>
    85 00000807 BA07000000          <1>  mov edx, %2
    86 0000080C 0F05                <1>  syscall
  1068                                      
  1069                                      ; Calcular la posición central para el mensaje
  1070                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1071 0000080E B84E000000                  mov rax, column_cells
  1072 00000813 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1073 00000817 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1074                                      
  1075                                      ; Calcular la fila central
  1076 0000081A BB20000000                  mov rbx, row_cells
  1077 0000081F 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1078                                      
  1079                                      ; Calcular el offset en el buffer
  1080 00000822 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1081 00000827 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1082 0000082A 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1083                                      
  1084                                      ; Escribir "NIVEL " en la posición calculada
  1085 0000082D 488DB8[000A0000]            lea rdi, [board + rax]
  1086 00000834 48BE-                       mov rsi, level_msg
  1086 00000836 [2414000000000000] 
  1087 0000083E B906000000                  mov rcx, level_msg_len
  1088 00000843 F3A4                        rep movsb
  1089                                      
  1090                                      ; Escribir el número del nivel
  1091 00000845 8A05(B4140000)              mov al, [current_level]
  1092 0000084B 0430                        add al, '0'                 ; convertir a ASCII
  1093 0000084D 8807                        mov [rdi], al
  1094                                      
  1095                                      ; Mostrar el board con el mensaje
  1096                                      print board, board_size
    82 0000084F B801000000          <1>  mov eax, sys_write
    83 00000854 BF01000000          <1>  mov edi, 1
    84 00000859 48BE-               <1>  mov rsi, %1
    84 0000085B [000A000000000000]  <1>
    85 00000863 BA000A0000          <1>  mov edx, %2
    86 00000868 0F05                <1>  syscall
  1097                                      
  1098                                      ; Esperar un segundo
  1099 0000086A B823000000                  mov rax, sys_nanosleep
  1100 0000086F 48BF-                       mov rdi, level_display_time
  1100 00000871 [2F14000000000000] 
  1101 00000879 4831F6                      xor rsi, rsi
  1102 0000087C 0F05                        syscall
  1103                                      
  1104 0000087E 5D                          pop rbp
  1105 0000087F C3                          ret
  1106                                  
  1107                                  ; Función para inicializar un tablero vacío
  1108                                  init_empty_board:
  1109 00000880 56                          push rsi
  1110 00000881 57                          push rdi
  1111 00000882 51                          push rcx
  1112 00000883 50                          push rax
  1113                                  
  1114 00000884 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1115 0000088B 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1116 00000892 B9000A0000                  mov rcx, board_template_size
  1117 00000897 F3A4                        rep movsb                   ; Copiar el tablero
  1118                                  
  1119 00000899 58                          pop rax
  1120 0000089A 59                          pop rcx
  1121 0000089B 5F                          pop rdi
  1122 0000089C 5E                          pop rsi
  1123 0000089D C3                          ret
  1124                                  
  1125                                  
  1126                                  init_level:
  1127                                  
  1128 0000089E 488B05(4F140000)            mov rax, [default_pallet_size]
  1129 000008A5 488905(47140000)            mov [pallet_size], rax
  1130                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1131                                          ; Reiniciar letras activas
  1132 000008AC 488D3D(3B160000)            lea rdi, [letters_map]
  1133 000008B3 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1134 000008B8 4831C0                      xor rax, rax
  1135 000008BB F3AA                        rep stosb                    ; Llenar con ceros
  1136                                      
  1137                                      ; Inicializar dirección de la bola (derecha y arriba)
  1138 000008BD 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1138 000008C5 000000             
  1139 000008C8 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1139 000008D0 FFFFFF             
  1140                                  
  1141                                  
  1142                                      ; Reiniciar contador de letras activas
  1143 000008D3 4831C0                      xor rax, rax
  1144 000008D6 8805(CB170000)              mov [letters_count], al
  1145                                  
  1146                                      ; Reiniciar última letra capturada
  1147 000008DC C605(CC170000)20            mov byte [last_letter], ' '
  1148 000008E3 C605(45150000)00            mov byte [destroyed_blocks], 0 
  1149 000008EA E891FFFFFF                  call init_empty_board
  1150 000008EF E8FBFEFFFF                  call display_level_number
  1151 000008F4 E8E5050000                  call init_enemies
  1152                                      
  1153 000008F9 56                          push rsi
  1154 000008FA 57                          push rdi
  1155 000008FB 51                          push rcx
  1156 000008FC 50                          push rax
  1157                                  
  1158 000008FD 488D35(00000000)            lea rsi, [board_template]
  1159 00000904 488D3D(000A0000)            lea rdi, [board]
  1160 0000090B B9000A0000                  mov rcx, board_template_size
  1161 00000910 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1162                                  
  1163 00000912 58                          pop rax
  1164 00000913 59                          pop rcx
  1165 00000914 5F                          pop rdi
  1166 00000915 5E                          pop rsi
  1167                                  
  1168 00000916 B90A000000                  mov rcx, 10
  1169 0000091B 4831C0                      xor rax, rax
  1170 0000091E 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1171 00000925 F3AA                        rep stosb      
  1172                                  
  1173                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1174 00000927 803D(B4140000)01            cmp byte [current_level], 1
  1175 0000092E 7431                        je .level1
  1176 00000930 803D(B4140000)02            cmp byte [current_level], 2
  1177 00000937 7454                        je .level2
  1178 00000939 803D(B4140000)03            cmp byte [current_level], 3
  1179 00000940 7477                        je .level3
  1180 00000942 803D(B4140000)04            cmp byte [current_level], 4
  1181 00000949 0F8492000000                je .level4
  1182 0000094F 803D(B4140000)05            cmp byte [current_level], 5
  1183 00000956 0F84AD000000                je .level5
  1184 0000095C E9D0000000                  jmp .done
  1185                                  
  1186                                  
  1187                                  
  1188                                      .level1:
  1189 00000961 C605(B5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1190 00000968 4831C9                          xor rcx, rcx             
  1191                                          .init_loop1:
  1192 0000096B 4883F903                            cmp rcx, level1_blocks_count
  1193 0000096F 0F8DBC000000                        jge .done
  1194 00000975 4889C8                              mov rax, rcx         
  1195 00000978 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1196 0000097C 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1197 00000982 8891[D9140000]                      mov byte [block_states + rcx], dl
  1198 00000988 48FFC1                              inc rcx
  1199 0000098B EBDE                                jmp .init_loop1
  1200                                  
  1201                                      .level2:
  1202 0000098D C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1203 00000994 4831C9                          xor rcx, rcx             
  1204                                          .init_loop2:
  1205 00000997 4883F901                            cmp rcx, level2_blocks_count
  1206 0000099B 0F8D90000000                        jge .done
  1207 000009A1 4889C8                              mov rax, rcx         
  1208 000009A4 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1209 000009A8 8A90[C8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1210 000009AE 8891[D9140000]                      mov byte [block_states + rcx], dl
  1211 000009B4 48FFC1                              inc rcx
  1212 000009B7 EBDE                                jmp .init_loop2
  1213                                      .level3:
  1214 000009B9 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1215 000009C0 4831C9                          xor rcx, rcx             
  1216                                          .init_loop3:
  1217 000009C3 4883F901                            cmp rcx, level3_blocks_count
  1218 000009C7 7D68                                jge .done
  1219 000009C9 4889C8                              mov rax, rcx         
  1220 000009CC 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1221 000009D0 8A90[CD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1222 000009D6 8891[D9140000]                      mov byte [block_states + rcx], dl
  1223 000009DC 48FFC1                              inc rcx
  1224 000009DF EBE2                                jmp .init_loop3
  1225                                  
  1226                                      .level4:
  1227 000009E1 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1228 000009E8 4831C9                          xor rcx, rcx             
  1229                                          .init_loop4:
  1230 000009EB 4883F901                            cmp rcx, level4_blocks_count
  1231 000009EF 7D40                                jge .done
  1232 000009F1 4889C8                              mov rax, rcx         
  1233 000009F4 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1234 000009F8 8A90[D2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1235 000009FE 8891[D9140000]                      mov byte [block_states + rcx], dl
  1236 00000A04 48FFC1                              inc rcx
  1237 00000A07 EBE2                                jmp .init_loop4
  1238                                  
  1239                                      .level5:
  1240 00000A09 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1241 00000A10 4831C9                          xor rcx, rcx             
  1242                                          .init_loop5:
  1243 00000A13 4883F901                            cmp rcx, level5_blocks_count
  1244 00000A17 7D18                                jge .done
  1245 00000A19 4889C8                              mov rax, rcx         
  1246 00000A1C 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1247 00000A20 8A90[D7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1248 00000A26 8891[D9140000]                      mov byte [block_states + rcx], dl
  1249 00000A2C 48FFC1                              inc rcx
  1250 00000A2F EBE2                                jmp .init_loop5
  1251                                      .done:
  1252 00000A31 C3                              ret
  1253                                  
  1254                                  
  1255                                  ; Función para verificar y manejar la transición de nivel
  1256                                  check_level_complete:
  1257                                      ; Verificar si quedan bloques
  1258 00000A32 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1259 00000A39 753C                        jne .not_complete
  1260                                      
  1261                                      ; Incrementar el nivel
  1262 00000A3B FE05(B4140000)              inc byte [current_level]
  1263                                      
  1264                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1265 00000A41 803D(B4140000)06            cmp byte [current_level], 6
  1266 00000A48 742E                        je game_win
  1267                                      
  1268                                      ; Reinicializar el juego para el siguiente nivel
  1269 00000A4A E84FFEFFFF                  call init_level
  1270                                      
  1271                                      ; Reinicializar la posición de la bola y la paleta
  1272 00000A4F 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1272 00000A57 000000             
  1273 00000A5A 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1273 00000A62 000000             
  1274 00000A65 C605(7F140000)00            mov byte [ball_moving], 0
  1275 00000A6C 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1275 00000A73 [36130000]         
  1276                                      
  1277                                      .not_complete:
  1278 00000A77 C3                              ret
  1279                                  
  1280                                      ; Nueva función para manejar la victoria del juego
  1281                                  game_win:
  1282                                      ; Limpiar la pantalla primero
  1283                                      print clear, clear_length
    82 00000A78 B801000000          <1>  mov eax, sys_write
    83 00000A7D BF01000000          <1>  mov edi, 1
    84 00000A82 48BE-               <1>  mov rsi, %1
    84 00000A84 [1000000000000000]  <1>
    85 00000A8C BA07000000          <1>  mov edx, %2
    86 00000A91 0F05                <1>  syscall
  1284                                      
  1285                                      ; Mensaje de victoria
  1286 00000A93 488B05(3D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1287 00000A9A 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1287 00000A9C [4615000000000000] 
  1288 00000AA4 E8B4010000                  call number_to_string
  1289                                      
  1290                                      ; Definir mensaje de victoria
  1291                                      section .data
  1292 000017F2 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1292 000017FB 616465732120C2A148-
  1292 00001804 61732067616E61646F-
  1292 0000180D 210A0D             
  1293                                          win_msg_len: equ $ - win_msg
  1294 00001810 50756E74616A652066-             score_msg: db "Puntaje final: "
  1294 00001819 696E616C3A20       
  1295                                          score_msg_len: equ $ - score_msg
  1296                                      section .text
  1297                                      
  1298                                      ; Imprimir mensajes
  1299                                      print win_msg, win_msg_len
    82 00000AA9 B801000000          <1>  mov eax, sys_write
    83 00000AAE BF01000000          <1>  mov edi, 1
    84 00000AB3 48BE-               <1>  mov rsi, %1
    84 00000AB5 [F217000000000000]  <1>
    85 00000ABD BA1E000000          <1>  mov edx, %2
    86 00000AC2 0F05                <1>  syscall
  1300                                      print score_msg, score_msg_len
    82 00000AC4 B801000000          <1>  mov eax, sys_write
    83 00000AC9 BF01000000          <1>  mov edi, 1
    84 00000ACE 48BE-               <1>  mov rsi, %1
    84 00000AD0 [1018000000000000]  <1>
    85 00000AD8 BA0F000000          <1>  mov edx, %2
    86 00000ADD 0F05                <1>  syscall
  1301                                      print number_buffer, 20
    82 00000ADF B801000000          <1>  mov eax, sys_write
    83 00000AE4 BF01000000          <1>  mov edi, 1
    84 00000AE9 48BE-               <1>  mov rsi, %1
    84 00000AEB [4615000000000000]  <1>
    85 00000AF3 BA14000000          <1>  mov edx, %2
    86 00000AF8 0F05                <1>  syscall
  1302                                      
  1303                                      ; Esperar un momento antes de salir
  1304 00000AFA 48C705FBF4FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1304 00000B03 0000               
  1305 00000B05 48C705F8F4FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1305 00000B0E 0000               
  1306                                      sleeptime
    98 00000B10 B823000000          <1>  mov eax, sys_nanosleep
    99 00000B15 48BF-               <1>  mov rdi, timespec
    99 00000B17 [0000000000000000]  <1>
   100 00000B1F 31F6                <1>  xor esi, esi
   101 00000B21 0F05                <1>  syscall
  1307                                      
  1308 00000B23 E913090000                  jmp exit
  1309                                  
  1310                                  ; Función para imprimir los bloques
  1311                                  ; Función modificada para imprimir bloques
  1312                                  
  1313                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1314                                  get_current_level_blocks:
  1315 00000B28 803D(B4140000)01            cmp byte [current_level], 1
  1316 00000B2F 7428                        je .level1
  1317 00000B31 803D(B4140000)02            cmp byte [current_level], 2
  1318 00000B38 7427                        je .level2
  1319 00000B3A 803D(B4140000)03            cmp byte [current_level], 3
  1320 00000B41 7426                        je .level3
  1321 00000B43 803D(B4140000)04            cmp byte [current_level], 4
  1322 00000B4A 7425                        je .level4
  1323 00000B4C 803D(B4140000)05            cmp byte [current_level], 5
  1324 00000B53 7424                        je .level5
  1325                                      ; Si llegamos aquí, hay un error en el nivel
  1326 00000B55 4831C0                      xor rax, rax
  1327 00000B58 C3                          ret
  1328                                  
  1329                                      .level1:
  1330 00000B59 488D05(B6140000)                lea rax, [level1_blocks]
  1331 00000B60 C3                              ret
  1332                                      .level2:
  1333 00000B61 488D05(C5140000)                lea rax, [level2_blocks]
  1334 00000B68 C3                              ret
  1335                                      .level3:
  1336 00000B69 488D05(CA140000)                lea rax, [level3_blocks]
  1337 00000B70 C3                              ret
  1338                                      .level4:
  1339 00000B71 488D05(CF140000)                lea rax, [level4_blocks]
  1340 00000B78 C3                              ret
  1341                                      .level5:
  1342 00000B79 488D05(D4140000)                lea rax, [level5_blocks]
  1343 00000B80 C3                              ret
  1344                                  ; Función para obtener la cantidad de bloques del nivel actual
  1345                                  get_current_level_count:
  1346 00000B81 803D(B4140000)01            cmp byte [current_level], 1
  1347 00000B88 7428                        je .level1
  1348 00000B8A 803D(B4140000)02            cmp byte [current_level], 2
  1349 00000B91 7425                        je .level2
  1350 00000B93 803D(B4140000)03            cmp byte [current_level], 3
  1351 00000B9A 7422                        je .level3
  1352 00000B9C 803D(B4140000)04            cmp byte [current_level], 4
  1353 00000BA3 741F                        je .level4
  1354 00000BA5 803D(B4140000)05            cmp byte [current_level], 5
  1355 00000BAC 741C                        je .level5
  1356                                      ; Si llegamos aquí, hay un error en el nivel
  1357 00000BAE 4831C0                      xor rax, rax
  1358 00000BB1 C3                          ret
  1359                                  
  1360                                      .level1:
  1361 00000BB2 B803000000                      mov rax, level1_blocks_count
  1362 00000BB7 C3                              ret
  1363                                      .level2:
  1364 00000BB8 B801000000                      mov rax, level2_blocks_count
  1365 00000BBD C3                              ret
  1366                                      .level3:
  1367 00000BBE B801000000                      mov rax, level3_blocks_count
  1368 00000BC3 C3                              ret
  1369                                      .level4:
  1370 00000BC4 B801000000                      mov rax, level4_blocks_count
  1371 00000BC9 C3                              ret
  1372                                      .level5:
  1373 00000BCA B801000000                      mov rax, level5_blocks_count
  1374 00000BCF C3                              ret
  1375                                  
  1376                                  
  1377                                  print_blocks:
  1378 00000BD0 55                          push rbp
  1379 00000BD1 4889E5                      mov rbp, rsp
  1380                                      
  1381                                      ; Obtener puntero a los bloques del nivel actual
  1382 00000BD4 E84FFFFFFF                  call get_current_level_blocks
  1383 00000BD9 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1384                                      
  1385                                      ; Obtener cantidad de bloques del nivel actual
  1386 00000BDC E8A0FFFFFF                  call get_current_level_count
  1387 00000BE1 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1388                                      
  1389 00000BE4 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1390                                      
  1391                                      .print_loop:
  1392 00000BE7 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1393 00000BEA 7D6F                            jge .end
  1394                                          
  1395                                          ; Verificar si el bloque está activo
  1396 00000BEC 490FB68424-                     movzx rax, byte [block_states + r12]
  1396 00000BF1 [D9140000]         
  1397 00000BF5 4885C0                          test rax, rax
  1398 00000BF8 745C                            jz .next_block
  1399                                          
  1400                                          ; Obtener posición y tipo del bloque usando r13
  1401 00000BFA 4C89E0                          mov rax, r12
  1402 00000BFD 486BC005                        imul rax, 5
  1403 00000C01 4C01E8                          add rax, r13
  1404 00000C04 448A00                          mov r8b, [rax]        ; X position
  1405 00000C07 448A4801                        mov r9b, [rax + 1]    ; Y position
  1406 00000C0B 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1407                                  
  1408                                          ; El resto de la lógica de impresión permanece igual
  1409 00000C0F 4D0FB6C0                        movzx r8, r8b
  1410 00000C13 4D0FB6C9                        movzx r9, r9b
  1411 00000C17 4981C0[000A0000]                add r8, board
  1412 00000C1E B850000000                      mov rax, column_cells + 2
  1413 00000C23 49F7E1                          mul r9
  1414 00000C26 4901C0                          add r8, rax
  1415                                          
  1416 00000C29 B906000000                      mov rcx, block_length
  1417 00000C2E 48BE-                           mov rsi, block_type_1
  1417 00000C30 [9014000000000000] 
  1418 00000C38 490FB6C2                        movzx rax, r10b
  1419 00000C3C 48FFC8                          dec rax
  1420 00000C3F 486BC006                        imul rax, block_length
  1421 00000C43 4801C6                          add rsi, rax
  1422                                          
  1423                                      .print_block_chars:
  1424 00000C46 8A06                            mov al, [rsi]
  1425 00000C48 418800                          mov [r8], al
  1426 00000C4B 48FFC6                          inc rsi
  1427 00000C4E 49FFC0                          inc r8
  1428 00000C51 48FFC9                          dec rcx
  1429 00000C54 75F0                            jnz .print_block_chars
  1430                                          
  1431                                      .next_block:
  1432 00000C56 49FFC4                          inc r12
  1433 00000C59 EB8C                            jmp .print_loop
  1434                                          
  1435                                      .end:
  1436 00000C5B 5D                              pop rbp
  1437 00000C5C C3                              ret
  1438                                  
  1439                                  ; Función para convertir número a string
  1440                                  ; Input: RAX = número a convertir
  1441                                  ; RDI = buffer donde escribir el string
  1442                                  number_to_string:
  1443 00000C5D 53                          push rbx
  1444 00000C5E 52                          push rdx
  1445 00000C5F 56                          push rsi
  1446 00000C60 BB0A000000                  mov rbx, 10          ; Divisor
  1447 00000C65 B900000000                  mov rcx, 0          ; Contador de dígitos
  1448                                      
  1449                                      ; Si el número es 0, manejarlo especialmente
  1450 00000C6A 4885C0                      test rax, rax
  1451 00000C6D 7509                        jnz .convert_loop
  1452 00000C6F C60730                      mov byte [rdi], '0'
  1453 00000C72 C6470100                    mov byte [rdi + 1], 0
  1454 00000C76 EB20                        jmp .end
  1455                                      
  1456                                      .convert_loop:
  1457 00000C78 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1458 00000C7B 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1459 00000C7E 80C230                          add dl, '0'     ; Convertir a ASCII
  1460 00000C81 52                              push rdx        ; Guardar el dígito
  1461 00000C82 48FFC1                          inc rcx         ; Incrementar contador
  1462 00000C85 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1463 00000C88 75EE                            jnz .convert_loop
  1464                                          
  1465                                      .write_loop:
  1466 00000C8A 5A                              pop rdx         ; Obtener dígito
  1467 00000C8B 8817                            mov [rdi], dl   ; Escribir al buffer
  1468 00000C8D 48FFC7                          inc rdi         ; Siguiente posición
  1469 00000C90 48FFC9                          dec rcx         ; Decrementar contador
  1470 00000C93 75F5                            jnz .write_loop
  1471                                          
  1472 00000C95 C60700                      mov byte [rdi], 0   ; Null terminator
  1473                                      
  1474                                      .end:
  1475 00000C98 5E                          pop rsi
  1476 00000C99 5A                          pop rdx
  1477 00000C9A 5B                          pop rbx
  1478 00000C9B C3                          ret
  1479                                  
  1480                                  ; Función para imprimir los labels
  1481                                  print_labels:
  1482 00000C9C 55                          push rbp
  1483 00000C9D 4889E5                      mov rbp, rsp
  1484                                  
  1485                                      ; Crear buffer temporal
  1486 00000CA0 4883EC20                    sub rsp, 32
  1487                                  
  1488                                      ; Copiar labels a buffer temporal
  1489 00000CA4 4889E7                      mov rdi, rsp
  1490 00000CA7 488D35(F2150000)            lea rsi, [score_label]
  1491 00000CAE B917000000                  mov rcx, score_label_len
  1492 00000CB3 F3A4                        rep movsb
  1493                                  
  1494                                      ; Convertir score a string
  1495 00000CB5 488B05(3D150000)            mov rax, [current_score]
  1496 00000CBC 48BF-                       mov rdi, number_buffer
  1496 00000CBE [4615000000000000] 
  1497 00000CC6 E892FFFFFF                  call number_to_string
  1498                                  
  1499                                      ; Calcular longitud del número
  1500 00000CCB B900000000                  mov rcx, 0
  1501 00000CD0 48BF-                       mov rdi, number_buffer
  1501 00000CD2 [4615000000000000] 
  1502                                      .count_loop:
  1503 00000CDA 803C0F00                        cmp byte [rdi + rcx], 0
  1504 00000CDE 7405                            je .count_done
  1505 00000CE0 48FFC1                          inc rcx
  1506 00000CE3 EBF5                            jmp .count_loop
  1507                                      .count_done:
  1508                                  
  1509                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1510 00000CE5 4889E7                      mov rdi, rsp
  1511 00000CE8 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1512 00000CEC BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1513 00000CF1 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1514                                      .pad_loop:
  1515 00000CF4 4885F6                          test rsi, rsi
  1516 00000CF7 740B                            jz .pad_done
  1517 00000CF9 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1518 00000CFC 48FFC7                          inc rdi
  1519 00000CFF 48FFCE                          dec rsi
  1520 00000D02 EBF0                            jmp .pad_loop
  1521                                      .pad_done:
  1522                                  
  1523                                      ; Copiar el número
  1524 00000D04 48BE-                       mov rsi, number_buffer
  1524 00000D06 [4615000000000000] 
  1525 00000D0E F3A4                        rep movsb
  1526                                  
  1527                                      ; Imprimir el buffer completo
  1528                                      print rsp, score_label_len
    82 00000D10 B801000000          <1>  mov eax, sys_write
    83 00000D15 BF01000000          <1>  mov edi, 1
    84 00000D1A 4889E6              <1>  mov rsi, %1
    85 00000D1D BA17000000          <1>  mov edx, %2
    86 00000D22 0F05                <1>  syscall
  1529                                  
  1530                                      ; Repetir proceso para bloques destruidos
  1531 00000D24 4889E7                      mov rdi, rsp
  1532 00000D27 488D35(09160000)            lea rsi, [blocks_label]
  1533 00000D2E B91B000000                  mov rcx, blocks_label_len
  1534 00000D33 F3A4                        rep movsb
  1535                                  
  1536                                      ; Verificar que el `[` esté en su posición correcta
  1537 00000D35 4889E7                      mov rdi, rsp
  1538 00000D38 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1539 00000D3C C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1540                                  
  1541                                      ; Convertir bloques destruidos a string
  1542 00000D3F 480FB605(45150000)          movzx rax, byte [destroyed_blocks]
  1543 00000D47 48BF-                       mov rdi, number_buffer
  1543 00000D49 [4615000000000000] 
  1544 00000D51 E807FFFFFF                  call number_to_string
  1545                                  
  1546                                      ; Calcular longitud del número
  1547 00000D56 B900000000                  mov rcx, 0
  1548 00000D5B 48BF-                       mov rdi, number_buffer
  1548 00000D5D [4615000000000000] 
  1549                                      .count_loop2:
  1550 00000D65 803C0F00                        cmp byte [rdi + rcx], 0
  1551 00000D69 7405                            je .count_done2
  1552 00000D6B 48FFC1                          inc rcx
  1553 00000D6E EBF5                            jmp .count_loop2
  1554                                      .count_done2:
  1555                                  
  1556                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1557 00000D70 4889E7                      mov rdi, rsp
  1558 00000D73 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1559 00000D77 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1560 00000D7C 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1561                                      .pad_loop2:
  1562 00000D7F 4885F6                          test rsi, rsi
  1563 00000D82 740B                            jz .pad_done2
  1564 00000D84 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1565 00000D87 48FFC7                          inc rdi
  1566 00000D8A 48FFCE                          dec rsi
  1567 00000D8D EBF0                            jmp .pad_loop2
  1568                                      .pad_done2:
  1569                                  
  1570                                      ; Copiar el número
  1571 00000D8F 48BE-                       mov rsi, number_buffer
  1571 00000D91 [4615000000000000] 
  1572 00000D99 F3A4                        rep movsb
  1573                                  
  1574                                      ; Imprimir el buffer completo
  1575                                      print rsp, blocks_label_len
    82 00000D9B B801000000          <1>  mov eax, sys_write
    83 00000DA0 BF01000000          <1>  mov edi, 1
    84 00000DA5 4889E6              <1>  mov rsi, %1
    85 00000DA8 BA1B000000          <1>  mov edx, %2
    86 00000DAD 0F05                <1>  syscall
  1576                                  
  1577                                      ; Restaurar stack
  1578 00000DAF 4883C420                    add rsp, 32
  1579 00000DB3 5D                          pop rbp
  1580 00000DB4 C3                          ret
  1581                                  
  1582                                  
  1583                                  
  1584                                  check_block_collision:
  1585 00000DB5 55                          push rbp
  1586 00000DB6 4889E5                      mov rbp, rsp
  1587                                  
  1588                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1589 00000DB9 418A02                      mov al, [r10]
  1590                                  
  1591                                      ; Verificar si el carácter es un bloque
  1592 00000DBC 3C55                        cmp al, 'U'  
  1593 00000DBE 7419                        je .possible
  1594 00000DC0 3C4F                        cmp al, 'O'  
  1595 00000DC2 7415                        je .possible
  1596 00000DC4 3C44                        cmp al, 'D'  
  1597 00000DC6 7411                        je .possible
  1598 00000DC8 3C4C                        cmp al, 'L'  
  1599 00000DCA 740D                        je .possible
  1600 00000DCC 3C56                        cmp al, 'V'  
  1601 00000DCE 7409                        je .possible
  1602 00000DD0 3C38                        cmp al, '8'  
  1603 00000DD2 7405                        je .possible
  1604                                  
  1605                                      ; No es bloque, salir
  1606 00000DD4 4831C0                      xor rax, rax
  1607 00000DD7 5D                          pop rbp
  1608 00000DD8 C3                          ret
  1609                                  
  1610                                  .possible:
  1611 00000DD9 53                          push rbx
  1612 00000DDA 57                          push rdi
  1613 00000DDB 56                          push rsi
  1614 00000DDC 4154                        push r12
  1615 00000DDE 4155                        push r13
  1616 00000DE0 4156                        push r14
  1617 00000DE2 4157                        push r15
  1618                                  
  1619                                      ; 1) Obtener base de los bloques del nivel actual
  1620 00000DE4 E83FFDFFFF                  call get_current_level_blocks
  1621 00000DE9 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1622                                  
  1623                                      ; 2) Obtener la cantidad de bloques
  1624 00000DEC E890FDFFFF                  call get_current_level_count
  1625 00000DF1 4989C6                      mov r14, rax
  1626                                  
  1627 00000DF4 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1628                                  
  1629                                  .find_block_loop:
  1630 00000DF7 4D39F4                      cmp r12, r14
  1631 00000DFA 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1632                                  
  1633                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1634 00000E00 4C89E0                      mov rax, r12
  1635 00000E03 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1636 00000E07 4C01E8                      add rax, r13
  1637 00000E0A 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1638                                  
  1639                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1640 00000E0D 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1640 00000E12 [D9140000]         
  1641 00000E16 4885DB                      test rbx, rbx
  1642 00000E19 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1643                                  
  1644                                      ; Obtener coordenadas
  1645 00000E1F 418A17                      mov dl, [r15]         ; x
  1646 00000E22 418A4F01                    mov cl, [r15 + 1]     ; y
  1647                                  
  1648                                      ; Calcular posición en el board
  1649 00000E26 488D3D(000A0000)            lea rdi, [board]
  1650 00000E2D 4831C0                      xor rax, rax
  1651 00000E30 B84E000000                  mov rax, column_cells
  1652 00000E35 4883C002                    add rax, 2
  1653 00000E39 480FB6C9                    movzx rcx, cl         ; y
  1654 00000E3D 480FAFC1                    imul rax, rcx
  1655 00000E41 4801C7                      add rdi, rax
  1656 00000E44 480FB6C2                    movzx rax, dl         ; x
  1657 00000E48 4801C7                      add rdi, rax
  1658                                  
  1659                                      ; Guardar la posición base del bloque
  1660 00000E4B 57                          push rdi
  1661                                  
  1662                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1663 00000E4C 4939FA                      cmp r10, rdi
  1664 00000E4F 7274                        jb .skip_collision
  1665 00000E51 488D5F06                    lea rbx, [rdi + block_length]
  1666 00000E55 4939DA                      cmp r10, rbx
  1667 00000E58 736B                        jae .skip_collision
  1668                                  
  1669                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1670 00000E5A 41FE8C24[D9140000]          dec byte [block_states + r12]
  1671                                      ; Volver a cargar durabilidad
  1672 00000E62 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1672 00000E67 [D9140000]         
  1673 00000E6B 4885DB                      test rbx, rbx
  1674 00000E6E 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1675                                  
  1676                                      ; >>> Llegó a 0 => Bloque destruido
  1677 00000E70 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1678 00000E71 B906000000                  mov rcx, block_length
  1679                                  .clear_loop:
  1680 00000E76 C60720                      mov byte [rdi], ' '
  1681 00000E79 48FFC7                      inc rdi
  1682 00000E7C E2F8                        loop .clear_loop
  1683                                  
  1684                                      ; Dibujar letra del bloque destruido
  1685 00000E7E 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1686 00000E82 4883EF06                    sub rdi, block_length
  1687 00000E86 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1688                                      ; Después de escribir la letra en el tablero
  1689 00000E88 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1690 00000E8C 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1691 00000E90 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1692 00000E95 E80CF5FFFF                  call register_letter
  1693                                      ; Actualizar contadores globales
  1694 00000E9A FE0D(B5140000)              dec byte [blocks_remaining]
  1695 00000EA0 FE05(45150000)              inc byte [destroyed_blocks]
  1696                                  
  1697                                      ; Sumar puntos según el tipo
  1698 00000EA6 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1699 00000EAB 486BC00A                    imul rax, 10
  1700 00000EAF 480105(3D150000)            add [current_score], rax
  1701                                  
  1702 00000EB6 B801000000                  mov rax, 1  ; colisión con destrucción
  1703 00000EBB EB14                        jmp .end_pop
  1704                                  
  1705                                  .update_display:
  1706                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1707 00000EBD B801000000                  mov rax, 1  ; colisión con "rebote"  
  1708 00000EC2 5F                          pop rdi     ; pop que quedó pendiente
  1709 00000EC3 EB0C                        jmp .end_pop
  1710                                  
  1711                                  .skip_collision:
  1712 00000EC5 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1713                                  .next_block:
  1714 00000EC6 49FFC4                      inc r12
  1715 00000EC9 E929FFFFFF                  jmp .find_block_loop
  1716                                  
  1717                                  .no_block_found:
  1718 00000ECE 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1719                                  
  1720                                  .end_pop:
  1721 00000ED1 415F                        pop r15
  1722 00000ED3 415E                        pop r14
  1723 00000ED5 415D                        pop r13
  1724 00000ED7 415C                        pop r12
  1725 00000ED9 5E                          pop rsi
  1726 00000EDA 5F                          pop rdi
  1727 00000EDB 5B                          pop rbx
  1728 00000EDC 5D                          pop rbp
  1729 00000EDD C3                          ret
  1730                                  
  1731                                  
  1732                                  
  1733                                  init_enemies:
  1734 00000EDE 55                          push rbp
  1735 00000EDF 4889E5                      mov rbp, rsp
  1736                                      ; Reiniciar contadores de movimiento
  1737 00000EE2 C605(88150000)00            mov byte [enemy_move_total], 0
  1738 00000EE9 C605(89150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1739                                      ; Limpiar estado previo de enemigos
  1740 00000EF0 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1741 00000EF5 488D3D(5F150000)            lea rdi, [enemies]
  1742 00000EFC 30C0                        xor al, al
  1743 00000EFE F3AA                        rep stosb ; Limpiar datos de enemigos
  1744                                      
  1745                                      ; Marcar todos los enemigos como inactivos
  1746 00000F00 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1747 00000F07 30C0                        xor al, al
  1748 00000F09 B90A000000                  mov rcx, 10
  1749 00000F0E F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1750                                  
  1751 00000F10 5D                          pop rbp
  1752 00000F11 C3                          ret
  1753                                  
  1754                                  
  1755                                  ; Función para mover enemigos
  1756                                  move_enemies:
  1757 00000F12 55                          push rbp
  1758 00000F13 4889E5                      mov rbp, rsp
  1759                                      
  1760                                      ; Incrementar contador de movimiento
  1761 00000F16 FE05(86150000)              inc byte [enemy_move_counter]
  1762 00000F1C 480FB605(86150000)          movzx rax, byte [enemy_move_counter]
  1763 00000F24 3A05(87150000)              cmp al, [enemy_move_delay]
  1764 00000F2A 0F85AA010000                jne .end
  1765                                      
  1766                                      ; Resetear contador
  1767 00000F30 C605(86150000)00            mov byte [enemy_move_counter], 0
  1768                                      
  1769 00000F37 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1770                                      
  1771                                      .enemy_loop:
  1772 00000F3A 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1773 00000F3E 0F8D96010000                    jge .end
  1774                                          
  1775                                          ; Calcular offset del enemigo actual
  1776 00000F44 4C89E0                          mov rax, r12
  1777 00000F47 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1778 00000F4B 488DB0[5F150000]                lea rsi, [enemies + rax]
  1779                                          
  1780                                          ; Verificar si el enemigo está activo
  1781 00000F52 807E0201                        cmp byte [rsi + 2], 1
  1782 00000F56 0F8576010000                    jne .next_enemy
  1783                                          
  1784                                          ; Obtener posición actual
  1785 00000F5C 4C0FB606                        movzx r8, byte [rsi]            ; X
  1786 00000F60 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1787                                          
  1788                                          ; Limpiar posición actual antes de mover
  1789 00000F65 4150                            push r8
  1790 00000F67 4151                            push r9
  1791 00000F69 B84E000000                      mov rax, column_cells
  1792 00000F6E 4883C002                        add rax, 2
  1793 00000F72 49F7E1                          mul r9
  1794 00000F75 4C01C0                          add rax, r8
  1795 00000F78 488DB8[000A0000]                lea rdi, [board + rax]
  1796 00000F7F C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1797 00000F82 4159                            pop r9
  1798 00000F84 4158                            pop r8
  1799                                  
  1800                                          ; Determinar comportamiento basado en índice
  1801 00000F86 4C89E0                          mov rax, r12
  1802 00000F89 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1803 00000F8D 4885C0                          test rax, rax
  1804 00000F90 7402                            jz .chase_ball
  1805 00000F92 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1806                                          
  1807                                          ; Perseguir bola (comportamiento original)
  1808                                      .chase_ball:
  1809 00000F94 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1810 00000F9B 4D39D0                          cmp r8, r10
  1811 00000F9E 0F8F96000000                    jg .move_left
  1812 00000FA4 0F8C95000000                    jl .move_right
  1813                                          
  1814 00000FAA 4C8B15(67140000)                mov r10, [ball_y_pos]
  1815 00000FB1 4D39D1                          cmp r9, r10
  1816 00000FB4 0F8F8A000000                    jg .move_up
  1817 00000FBA 0F8C89000000                    jl .move_down
  1818 00000FC0 E9A5000000                      jmp .check_collision
  1819                                          
  1820                                      .chase_paddle:
  1821                                          ; Obtener la posición X actual de la paleta
  1822 00000FC5 4C8B15(3F140000)                mov r10, [pallet_position]
  1823 00000FCC 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1824                                          
  1825                                          ; Calcular la posición X real de la paleta
  1826 00000FD3 4C89D0                          mov rax, r10
  1827 00000FD6 BB4E000000                      mov rbx, column_cells
  1828 00000FDB 4883C302                        add rbx, 2                  ; Añadir newline chars
  1829 00000FDF 4831D2                          xor rdx, rdx
  1830 00000FE2 48F7F3                          div rbx                     ; rax = y, rdx = x
  1831                                          
  1832                                          ; rdx ahora contiene la posición X de la paleta
  1833                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1834 00000FE5 488B0D(47140000)                mov rcx, [pallet_size]
  1835 00000FEC 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1836 00000FEF 4801CA                          add rdx, rcx
  1837                                          
  1838                                          ; Comparar con posición X del enemigo y mover gradualmente
  1839 00000FF2 4939D0                          cmp r8, rdx
  1840 00000FF5 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1841 00000FF7 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1842 00000FF9 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1843                                  
  1844                                      .check_y_paddle:
  1845                                          ; La Y de la paleta siempre es row_cells - 2
  1846 00000FFB 41BA20000000                    mov r10, row_cells
  1847 00001001 4983EA02                        sub r10, 2
  1848                                          
  1849                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1850 00001005 4D39D1                          cmp r9, r10
  1851 00001008 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1852 0000100A 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1853 0000100C 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1854                                          
  1855                                      .no_movement:
  1856 0000100E EB5A                            jmp .check_collision
  1857                                  
  1858                                      ; También agregar una nueva sección para el movimiento suave
  1859                                      .smooth_transition:
  1860                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1861 00001010 8A05(89150000)                  mov al, [enemy_target]
  1862 00001016 84C0                            test al, al
  1863 00001018 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1864                                          
  1865                                          ; Verificar distancia en X
  1866 0000101A 4989D2                          mov r10, rdx              ; Posición X objetivo
  1867 0000101D 4D29C2                          sub r10, r8               ; Calcular diferencia
  1868 00001020 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1869 00001024 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1870 00001026 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1871 0000102A 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1872 0000102C EB3C                            jmp .check_collision
  1873                                          
  1874                                      .limit_right_movement:
  1875 0000102E 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1876 00001032 EB36                            jmp .check_collision
  1877                                          
  1878                                      .limit_left_movement:
  1879 00001034 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1880 00001038 EB30                            jmp .check_collision
  1881                                      .move_left:
  1882 0000103A 49FFC8                          dec r8
  1883 0000103D EB0F                            jmp .check_vertical
  1884                                          
  1885                                      .move_right:
  1886 0000103F 49FFC0                          inc r8
  1887 00001042 EB0A                            jmp .check_vertical
  1888                                          
  1889                                      .move_up:
  1890 00001044 49FFC9                          dec r9
  1891 00001047 EB21                            jmp .check_collision
  1892                                          
  1893                                      .move_down:
  1894 00001049 49FFC1                          inc r9
  1895 0000104C EB1C                            jmp .check_collision
  1896                                          
  1897                                      .check_vertical:
  1898 0000104E 8A05(89150000)                  mov al, [enemy_target]
  1899 00001054 84C0                            test al, al
  1900 00001056 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1901 0000105C 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1902 00001063 4D39D1                          cmp r9, r10
  1903 00001066 7FDC                            jg .move_up
  1904 00001068 7CDF                            jl .move_down
  1905                                          
  1906                                      .check_collision:
  1907                                          ; Verificar colisión con bordes
  1908 0000106A 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1909 0000106E 7E62                            jle .next_enemy
  1910 00001070 4983F84E                        cmp r8, column_cells
  1911 00001074 7D5C                            jge .next_enemy
  1912 00001076 4983F901                        cmp r9, 1                       ; Borde superior
  1913 0000107A 7E56                            jle .next_enemy
  1914 0000107C 4983F920                        cmp r9, row_cells
  1915 00001080 7D50                            jge .next_enemy
  1916                                          
  1917                                          ; Verificar colisión con bloques antes de moverse
  1918 00001082 4150                            push r8
  1919 00001084 4151                            push r9
  1920 00001086 4152                            push r10
  1921                                          
  1922                                          ; Calcular posición en el tablero para verificar
  1923 00001088 B84E000000                      mov rax, column_cells
  1924 0000108D 4883C002                        add rax, 2
  1925 00001091 49F7E1                          mul r9
  1926 00001094 4C01C0                          add rax, r8
  1927 00001097 4C8D90[000A0000]                lea r10, [board + rax]
  1928                                          
  1929                                          ; Verificar si hay un bloque en la nueva posición
  1930 0000109E 418A02                          mov al, [r10]
  1931 000010A1 3C55                            cmp al, 'U'
  1932 000010A3 7427                            je .invalid_move
  1933 000010A5 3C4F                            cmp al, 'O'
  1934 000010A7 7423                            je .invalid_move
  1935 000010A9 3C44                            cmp al, 'D'
  1936 000010AB 741F                            je .invalid_move
  1937 000010AD 3C4C                            cmp al, 'L'
  1938 000010AF 741B                            je .invalid_move
  1939 000010B1 3C56                            cmp al, 'V'
  1940 000010B3 7417                            je .invalid_move
  1941 000010B5 3C38                            cmp al, '8'
  1942 000010B7 7413                            je .invalid_move
  1943 000010B9 3C58                            cmp al, 'X'
  1944 000010BB 740F                            je .invalid_move
  1945                                          
  1946 000010BD 415A                            pop r10
  1947 000010BF 4159                            pop r9
  1948 000010C1 4158                            pop r8
  1949                                          
  1950                                          ; Guardar nueva posición si es válida
  1951 000010C3 448806                          mov [rsi], r8b
  1952 000010C6 44884E01                        mov [rsi + 1], r9b
  1953 000010CA EB06                            jmp .next_enemy
  1954                                          
  1955                                      .invalid_move:
  1956 000010CC 415A                            pop r10
  1957 000010CE 4159                            pop r9
  1958 000010D0 4158                            pop r8
  1959                                          
  1960                                      .next_enemy:
  1961 000010D2 49FFC4                          inc r12
  1962 000010D5 E960FEFFFF                      jmp .enemy_loop
  1963                                          
  1964                                      .end:
  1965 000010DA 5D                              pop rbp
  1966 000010DB C3                              ret
  1967                                  
  1968                                  get_current_spawn_points:
  1969 000010DC 55                          push rbp
  1970 000010DD 4889E5                      mov rbp, rsp
  1971                                      
  1972 000010E0 480FB605(B4140000)          movzx rax, byte [current_level]
  1973 000010E8 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1974 000010EB 488B04C5[BD150000]          mov rax, [spawn_points_table + rax * 8]
  1975                                      
  1976 000010F3 5D                          pop rbp
  1977 000010F4 C3                          ret
  1978                                  
  1979                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1980                                  check_enemy_spawn:
  1981 000010F5 55                          push rbp
  1982 000010F6 4889E5                      mov rbp, rsp
  1983                                      
  1984                                      ; Obtener spawn points del nivel actual
  1985 000010F9 E8DEFFFFFF                  call get_current_spawn_points
  1986 000010FE 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1987                                      
  1988                                      ; Obtener cantidad de bloques destruidos
  1989 00001101 4C0FB62D(45150000)          movzx r13, byte [destroyed_blocks]
  1990                                      
  1991                                      ; Verificar cada punto de spawn
  1992 00001109 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1993                                      
  1994                                      .check_loop:
  1995 0000110C 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1996 00001110 7D4B                            jge .end
  1997                                          
  1998                                          ; Verificar si este spawn point ya fue usado
  1999 00001112 80B9[E8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2000 00001119 743D                            je .next_enemy
  2001                                          
  2002                                          ; Verificar si este enemigo ya está activo
  2003 0000111B 4889C8                          mov rax, rcx
  2004 0000111E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2005 00001122 488DB0[5F150000]                lea rsi, [enemies + rax]
  2006 00001129 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2007 0000112D 7429                            je .next_enemy
  2008                                          
  2009                                          ; Verificar si debemos spawnear este enemigo
  2010 0000112F 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2011 00001134 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2012 00001137 751F                            jne .next_enemy
  2013                                          
  2014                                          ; Marcar este spawn point como usado
  2015 00001139 C681[E8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2016                                          
  2017                                          ; Spawner nuevo enemigo
  2018 00001140 C60628                          mov byte [rsi], 40             ; X inicial
  2019 00001143 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2020 00001147 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2021                                          
  2022                                          ; Inicializar comportamiento
  2023 0000114B 4889C8                          mov rax, rcx
  2024 0000114E 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2025 00001152 8805(E7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2026                                          
  2027                                      .next_enemy:
  2028 00001158 48FFC1                          inc rcx
  2029 0000115B EBAF                            jmp .check_loop
  2030                                          
  2031                                      .end:
  2032 0000115D 5D                              pop rbp
  2033 0000115E C3                              ret
  2034                                  
  2035                                  
  2036                                  ; Función para dibujar enemigos
  2037                                  print_enemies:
  2038 0000115F 55                          push rbp
  2039 00001160 4889E5                      mov rbp, rsp
  2040                                      
  2041 00001163 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2042                                      
  2043                                      .print_loop:
  2044 00001166 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2045 0000116A 7D4B                            jge .end
  2046                                          
  2047                                          ; Calcular offset del enemigo actual
  2048 0000116C 4C89E0                          mov rax, r12
  2049 0000116F 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2050 00001173 488DB0[5F150000]                lea rsi, [enemies + rax]
  2051                                          
  2052                                          ; Verificar si el enemigo está activo
  2053 0000117A 807E0201                        cmp byte [rsi + 2], 1
  2054 0000117E 7532                            jne .next_enemy
  2055                                          
  2056                                          ; Calcular posición en el tablero
  2057 00001180 4C0FB606                        movzx r8, byte [rsi]            ; X
  2058 00001184 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2059                                          
  2060                                          ; Calcular offset en el tablero
  2061 00001189 B84E000000                      mov rax, column_cells
  2062 0000118E 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2063 00001192 49F7E1                          mul r9
  2064 00001195 4C01C0                          add rax, r8
  2065 00001198 488DB8[000A0000]                lea rdi, [board + rax]
  2066                                          
  2067                                          ; Obtener carácter del enemigo según el nivel
  2068 0000119F 480FB605(B4140000)              movzx rax, byte [current_level]
  2069 000011A7 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2070 000011AA 8A80[5A150000]                  mov al, [enemy_chars + rax]
  2071                                          
  2072                                          ; Dibujar enemigo
  2073 000011B0 8807                            mov [rdi], al
  2074                                          
  2075                                      .next_enemy:
  2076 000011B2 49FFC4                          inc r12
  2077 000011B5 EBAF                            jmp .print_loop
  2078                                          
  2079                                      .end:
  2080 000011B7 5D                              pop rbp
  2081 000011B8 C3                              ret
  2082                                  
  2083                                  ; Función para verificar colisión con enemigos
  2084                                  ; Función para verificar colisión con enemigos
  2085                                  check_enemy_collision:
  2086 000011B9 55                          push rbp
  2087 000011BA 4889E5                      mov rbp, rsp
  2088                                      
  2089 000011BD 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2090 000011C0 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2091                                      
  2092                                      .check_loop:
  2093 000011C3 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2094 000011C7 0F8DE9000000                    jge .end
  2095                                          
  2096                                          ; Calcular offset del enemigo actual
  2097 000011CD 4C89E1                          mov rcx, r12
  2098 000011D0 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2099 000011D4 488DB1[5F150000]                lea rsi, [enemies + rcx]
  2100                                          
  2101                                          ; Verificar si el enemigo está activo
  2102 000011DB 807E0201                        cmp byte [rsi + 2], 1
  2103 000011DF 0F85C9000000                    jne .next_enemy
  2104                                          
  2105                                          ; Verificar colisión con la bola
  2106 000011E5 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2107 000011E9 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2108                                          
  2109                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2110 000011EE 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2111 000011F5 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2112                                          
  2113                                          ; Comprobar colisión vertical (misma columna)
  2114 000011FC 4D39C2                          cmp r10, r8
  2115 000011FF 7525                            jne .check_horizontal
  2116 00001201 4D29CB                          sub r11, r9
  2117 00001204 4983FB01                        cmp r11, 1
  2118 00001208 7F1C                            jg .check_horizontal
  2119 0000120A 4983FBFF                        cmp r11, -1
  2120 0000120E 7C16                            jl .check_horizontal
  2121                                          
  2122                                          ; Colisión vertical detectada
  2123 00001210 E8A3000000                      call destroy_enemy
  2124 00001215 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2125 0000121C B801000000                      mov rax, 1
  2126 00001221 E990000000                      jmp .end
  2127                                          
  2128                                      .check_horizontal:
  2129                                          ; Comprobar colisión horizontal (misma fila)
  2130 00001226 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2131 0000122D 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2132 00001234 4D39CB                          cmp r11, r9
  2133 00001237 7522                            jne .check_paddle
  2134 00001239 4D29C2                          sub r10, r8
  2135 0000123C 4983FA01                        cmp r10, 1
  2136 00001240 7F19                            jg .check_paddle
  2137 00001242 4983FAFF                        cmp r10, -1
  2138 00001246 7C13                            jl .check_paddle
  2139                                          
  2140                                          ; Colisión horizontal detectada
  2141 00001248 E86B000000                      call destroy_enemy
  2142 0000124D 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2143 00001254 B801000000                      mov rax, 1
  2144 00001259 EB5B                            jmp .end
  2145                                          
  2146                                      .check_paddle:
  2147                                          ; Verificar colisión con la paleta
  2148 0000125B 4C8B15(3F140000)                mov r10, [pallet_position]
  2149 00001262 4981EA[000A0000]                sub r10, board
  2150 00001269 4C89D0                          mov rax, r10
  2151 0000126C 41BB4E000000                    mov r11, column_cells
  2152 00001272 4983C302                        add r11, 2
  2153 00001276 4831D2                          xor rdx, rdx
  2154 00001279 49F7F3                          div r11                     ; División para obtener la posición Y
  2155 0000127C 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2156                                          
  2157 0000127F 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2158                                          
  2159                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2160 00001286 41BD20000000                    mov r13, row_cells
  2161 0000128C 4983ED02                        sub r13, 2                 ; Y de la paleta
  2162 00001290 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2163 00001293 7519                            jne .next_enemy
  2164                                          
  2165                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2166 00001295 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2167 00001298 7C14                            jl .next_enemy
  2168                                          
  2169 0000129A 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2170 0000129D 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2171 000012A0 7F0C                            jg .next_enemy
  2172                                          
  2173                                          ; Si llegamos aquí, hay colisión con la paleta
  2174 000012A2 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2175 000012A7 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2176 000012AC EB08                            jmp .end
  2177                                          
  2178                                      .next_enemy:
  2179 000012AE 49FFC4                          inc r12
  2180 000012B1 E90DFFFFFF                      jmp .check_loop
  2181                                          
  2182                                      .end:
  2183 000012B6 5D                              pop rbp
  2184 000012B7 C3                              ret
  2185                                  
  2186                                  ; Función para destruir un enemigo
  2187                                  destroy_enemy:
  2188                                      ; Desactivar enemigo
  2189 000012B8 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2190                                  
  2191                                      ; Sumar puntos por destruir enemigo
  2192 000012BC 488B05(7E150000)            mov rax, [enemy_points]
  2193 000012C3 480105(3D150000)            add [current_score], rax
  2194                                  
  2195                                      ; No tocar bloques destruidos aquí
  2196 000012CA C3                          ret
  2197                                  
  2198                                  
  2199                                  _start:
  2200 000012CB E85BEEFFFF              	call canonical_off
  2201 000012D0 E8F3000000              	call start_screen
  2202 000012D5 E8C4F5FFFF                  call init_level
  2203 000012DA E8FFFBFFFF                  call init_enemies
  2204 000012DF EB00                    	jmp .main_loop
  2205                                  	
  2206                                  
  2207                                  	.main_loop:
  2208 000012E1 E8B6F9FFFF                      call print_labels
  2209 000012E6 E8E5F8FFFF                      call print_blocks
  2210 000012EB E887F1FFFF                      call move_letters
  2211 000012F0 E8F7F0FFFF                      call print_letters
  2212 000012F5 E837F3FFFF              		call print_pallet
  2213 000012FA E8DCF3FFFF                      call move_ball
  2214 000012FF E8DAEFFFFF                      call check_bottom_collision
  2215 00001304 E8D4EEFFFF                      call print_lives
  2216 00001309 E824F7FFFF                      call check_level_complete
  2217 0000130E E8E2FDFFFF                      call check_enemy_spawn
  2218 00001313 E8FAFBFFFF                      call move_enemies
  2219 00001318 E89CFEFFFF                      call check_enemy_collision
  2220 0000131D E83DFEFFFF                      call print_enemies
  2221 00001322 E8E2F2FFFF              		call print_ball
  2222                                  		print board, board_size				
    82 00001327 B801000000          <1>  mov eax, sys_write
    83 0000132C BF01000000          <1>  mov edi, 1
    84 00001331 48BE-               <1>  mov rsi, %1
    84 00001333 [000A000000000000]  <1>
    85 0000133B BA000A0000          <1>  mov edx, %2
    86 00001340 0F05                <1>  syscall
  2223                                  		;setnonblocking	
  2224                                  	.read_more:	
  2225                                  		getchar	
    90 00001342 B800000000          <1>  mov rax, sys_read
    91 00001347 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000134C 48BE-               <1>  mov rsi, input_char
    92 0000134E [0000000000000000]  <1>
    93 00001356 BA01000000          <1>  mov rdx, 1
    94 0000135B 0F05                <1>  syscall
  2226                                  		
  2227 0000135D 4883F801                		cmp rax, 1
  2228 00001361 7532                        	jne .done
  2229                                  		
  2230 00001363 8A05(00000000)          		mov al,[input_char]
  2231                                  
  2232 00001369 3C61                    		cmp al, 'a'
  2233 0000136B 750E                    	    jne .not_left
  2234 0000136D 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2235 00001374 E8EDF2FFFF              		call move_pallet
  2236 00001379 EB1A                    	    jmp .done
  2237                                  		
  2238                                  		.not_left:
  2239 0000137B 3C64                    		 	cmp al, 'd'
  2240 0000137D 750C                    	    	jne .not_right
  2241 0000137F BF01000000              			mov rdi, right_direction
  2242 00001384 E8DDF2FFFF              	    	call move_pallet
  2243 00001389 EB0A                        		jmp .done		
  2244                                  
  2245                                  		.not_right:
  2246                                  
  2247 0000138B 3C71                        		cmp al, 'q'
  2248 0000138D 0F84A8000000                		je exit
  2249                                  
  2250 00001393 EBAD                    			jmp .read_more
  2251                                  		
  2252                                  		.done:	
  2253                                  			;unsetnonblocking		
  2254                                  			sleeptime	
    98 00001395 B823000000          <1>  mov eax, sys_nanosleep
    99 0000139A 48BF-               <1>  mov rdi, timespec
    99 0000139C [0000000000000000]  <1>
   100 000013A4 31F6                <1>  xor esi, esi
   101 000013A6 0F05                <1>  syscall
  2255                                  			print clear, clear_length
    82 000013A8 B801000000          <1>  mov eax, sys_write
    83 000013AD BF01000000          <1>  mov edi, 1
    84 000013B2 48BE-               <1>  mov rsi, %1
    84 000013B4 [1000000000000000]  <1>
    85 000013BC BA07000000          <1>  mov edx, %2
    86 000013C1 0F05                <1>  syscall
  2256 000013C3 E919FFFFFF                  		jmp .main_loop
  2257                                  
  2258                                  
  2259                                  
  2260                                  start_screen:
  2261                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000013C8 B801000000          <1>  mov eax, sys_write
    83 000013CD BF01000000          <1>  mov edi, 1
    84 000013D2 48BE-               <1>  mov rsi, %1
    84 000013D4 [1000000000000000]  <1>
    85 000013DC BA07000000          <1>  mov edx, %2
    86 000013E1 0F05                <1>  syscall
  2262                                      print msg1, msg1_length
    82 000013E3 B801000000          <1>  mov eax, sys_write
    83 000013E8 BF01000000          <1>  mov edi, 1
    84 000013ED 48BE-               <1>  mov rsi, %1
    84 000013EF [1700000000000000]  <1>
    85 000013F7 BA14010000          <1>  mov edx, %2
    86 000013FC 0F05                <1>  syscall
  2263                                      
  2264                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2265                                          getchar                 ; Esperamos una tecla
    90 000013FE B800000000          <1>  mov rax, sys_read
    91 00001403 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001408 48BE-               <1>  mov rsi, input_char
    92 0000140A [0000000000000000]  <1>
    93 00001412 BA01000000          <1>  mov rdx, 1
    94 00001417 0F05                <1>  syscall
  2266 00001419 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2267 0000141D 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2268                                          
  2269                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000141F B801000000          <1>  mov eax, sys_write
    83 00001424 BF01000000          <1>  mov edi, 1
    84 00001429 48BE-               <1>  mov rsi, %1
    84 0000142B [1000000000000000]  <1>
    85 00001433 BA07000000          <1>  mov edx, %2
    86 00001438 0F05                <1>  syscall
  2270 0000143A C3                          ret
  2271                                  
  2272                                  exit: 
  2273 0000143B E82DEDFFFF              	call canonical_on
  2274 00001440 B83C000000              	mov    rax, 60
  2275 00001445 BF00000000                  mov    rdi, 0
  2276 0000144A 0F05                        syscall
  2277                                  
