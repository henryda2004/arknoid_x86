     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001480 00                          ball_active db 0
   258                                  
   259 00001481 0000000000000000            ball2_x_pos:        dq 0
   260 00001489 0000000000000000            ball2_y_pos:        dq 0
   261 00001491 0000000000000000            ball2_direction_x:  dq 0
   262 00001499 0000000000000000            ball2_direction_y:  dq 0
   263 000014A1 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 000014A2 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 000014A3 0000000000000000            ball3_x_pos:        dq 0
   268 000014AB 0000000000000000            ball3_y_pos:        dq 0
   269 000014B3 0000000000000000            ball3_direction_x:  dq 0
   270 000014BB 0000000000000000            ball3_direction_y:  dq 0
   271 000014C3 00                          ball3_moving:       db 0
   272 000014C4 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 000014C5 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 000014CD [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 000014D5 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 000014DB 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 000014E1 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 000014E7 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 000014ED 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 000014F3 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 000014F9 01                          current_level db 1
   300 000014FA 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 000014FB 3A07030153                      db 58, 7, 3, 1, 'S'    ; Bloque 7
   307 00001500 3D09030144                      db 61, 9, 3, 1, 'D'    ; Bloque 7
   308 00001505 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   309 0000150A 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   310 0000150F 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   311 00001514 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   312 00001519 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   313 0000151E 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   314                                  
   315                                  
   316                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   317                                  
   318                                      ; Nivel 2: Bloques de prueba
   319                                      level2_blocks:
   320 00001523 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   321                                      level2_blocks_count equ 1
   322                                  
   323                                      ; Nivel 3
   324                                      level3_blocks:
   325 00001528 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   326                                  
   327                                      level3_blocks_count equ 1
   328                                  
   329                                      ; Nivel 4
   330                                      level4_blocks:
   331 0000152D 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   332                                      level4_blocks_count equ 1
   333                                  
   334                                      ; Nivel 5
   335                                      level5_blocks:
   336 00001532 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   337                                      level5_blocks_count equ 1
   338                                  
   339                                      ; Array para mantener el estado de los bloques
   340 00001537 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   341                                  
   342                                      
   343                                      ; Variables para almacenar los valores
   344 0000159B 0000000000000000            current_score dq 0          ; Score actual
   345 000015A3 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   346                                      
   347                                      ; Buffer para convertir números a string
   348 000015A4 00<rep 14h>                 number_buffer: times 20 db 0
   349                                  
   350 000015B8 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   351                                      
   352                                      ; Estructura para los enemigos (x, y, activo)
   353 000015BD 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   354 000015DB 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   355                                      
   356 000015DC 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   357 000015E4 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   358 000015E5 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   359 000015E6 00                          enemy_move_total db 0      ; Contador total de movimientos
   360 000015E7 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 000015E8 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   362                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   363                                      ; Añade esto en la sección .dataa
   364 000015E9 00000006080A0C0E10-         level1_spawn_points: db 0, 0, 0, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   364 000015F2 12                 
   365 000015F3 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   365 000015FC 13                 
   366 000015FD 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   366 00001606 1B                 
   367 00001607 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   367 00001610 1C                 
   368 00001611 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   368 0000161A 2D                 
   369                                          ; Arreglo de punteros a los spawn points de cada nivel
   370                                      spawn_points_table:
   371 0000161B [E915000000000000]              dq level1_spawn_points
   372 00001623 [F315000000000000]              dq level2_spawn_points
   373 0000162B [FD15000000000000]              dq level3_spawn_points
   374 00001633 [0716000000000000]              dq level4_spawn_points
   375 0000163B [1116000000000000]              dq level5_spawn_points
   376                                  
   377                                      ; Variables para el comportamiento de enemigos
   378 00001643 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   379 00001644 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   380 00001645 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   381 00001646 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   382                                  
   383 00001650 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   383 00001659 5B2020202020202020-
   383 00001662 20205D0A0D         
   384                                      score_label_len: equ $ - score_label
   385 00001667 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   385 00001670 657374727569646F73-
   385 00001679 3A205B2020205D0A0D 
   386                                      blocks_label_len: equ $ - blocks_label
   387                                      
   388                                      ; Posición donde insertar los números en los labels
   389                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   390                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   391                                      
   392                                      ; Definición de las vidas (x, y, estado)
   393                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   394                                      lives_data: 
   395 00001682 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   396 00001685 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   397 00001688 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   398 0000168B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   399 0000168E 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   400 00001691 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   401 00001694 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   402                                      lives_count equ 7    ; Total de vidas
   403 00001697 5E                          life_char db "^"    
   404 00001698 04                          current_lives db 4   ; Contador de vidas activas actual
   405                                  
   406                                  ; Estructura para almacenar las letras y sus posiciones
   407                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   408 00001699 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   409 00001829 00                          letters_count db 0   
   410 0000182A 20                          last_letter db ' '    ; Variable para almacenar la última letra
   411 0000182B 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   411 00001834 75616C3A205B205D0A-
   411 0000183D 0D                 
   412                                      last_letter_msg_len equ $ - last_letter_msg
   413 0000183E 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   414 0000183F 07                          max_lives db 7              ; Máximo número de vidas permitidas
   415 00001840 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   416 00001848 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   417 00001850 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   418                                  
   419 00001858 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   420 00001859 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   421 0000185A 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
   422 0000185B 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
   423                                  
   424 0000185C 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   425 00001864 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   426                                  
   427 00001865 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   428 00001866 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   429 00001867 00                          laser_count: db 0                ; Contador de láseres activos
   430 00001868 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   431 00001930 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   432                                  
   433                                      balls_data:     ; Array para almacenar hasta 3 bolas
   434                                          ; Bola 1 (principal)
   435 00001938 0000000000000000                dq 0        ; x_pos
   436 00001940 0000000000000000                dq 0        ; y_pos
   437 00001948 0100000000000000                dq 1        ; direction_x
   438 00001950 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   439 00001958 01                              db 1        ; active
   440                                          ; Bola 2
   441 00001959 0000000000000000                dq 0        ; x_pos
   442 00001961 0000000000000000                dq 0        ; y_pos
   443 00001969 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   444 00001971 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   445 00001979 00                              db 0        ; active
   446                                          ; Bola 3
   447 0000197A 0000000000000000                dq 0        ; x_pos
   448 00001982 0000000000000000                dq 0        ; y_pos
   449 0000198A 0000000000000000                dq 0        ; direction_x
   450 00001992 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   451 0000199A 00                              db 0        ; active
   452                                      
   453 0000199B 01                          balls_count db 1     ; Contador de bolas activas
   454                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   455                                  
   456                                  
   457                                  section .text
   458                                  
   459                                  
   460                                  print_lives:
   461 000001DD 55                          push rbp
   462 000001DE 4889E5                      mov rbp, rsp
   463                                      
   464 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   465                                      
   466                                      .print_loop:
   467 000001E4 4983FC07                        cmp r12, lives_count
   468 000001E8 7D45                            jge .end
   469                                          
   470                                          ; Calcular offset de la vida actual
   471 000001EA 4C89E0                          mov rax, r12
   472 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   473 000001F1 488DB0[82160000]                lea rsi, [lives_data + rax]
   474                                          
   475                                          ; Calcular posición en el tablero
   476 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   477 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   478                                          
   479                                          ; Calcular offset en el tablero
   480 00000201 B84E000000                      mov rax, column_cells
   481 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   482 0000020A 49F7E1                          mul r9
   483 0000020D 4C01C0                          add rax, r8
   484 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   485                                          
   486                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   487 00000217 807E0201                        cmp byte [rsi + 2], 1
   488 0000021B 7405                            je .draw_active
   489                                          
   490                                          ; Si está inactiva, dibujar espacio
   491 0000021D C60720                          mov byte [rdi], ' '
   492 00000220 EB08                            jmp .next_life
   493                                          
   494                                      .draw_active:
   495                                          ; Si está activa, dibujar el símbolo de vida
   496 00000222 8A05(97160000)                  mov al, [life_char]
   497 00000228 8807                            mov [rdi], al
   498                                          
   499                                      .next_life:
   500 0000022A 49FFC4                          inc r12
   501 0000022D EBB5                            jmp .print_loop
   502                                          
   503                                      .end:
   504 0000022F 5D                              pop rbp
   505 00000230 C3                              ret
   506                                  
   507                                  ; Función para desactivar una vida
   508                                  ; Función modificada para perder una vida
   509                                  ; Modificar lose_life para reiniciar solo la bola principal
   510                                  lose_life:
   511 00000231 55                          push rbp
   512 00000232 4889E5                      mov rbp, rsp
   513                                      
   514                                      ; Verificar si aún quedan vidas
   515 00000235 803D(98160000)00            cmp byte [current_lives], 0
   516 0000023C 0F84AB000000                je .game_lost
   517                                      
   518                                      ; Encontrar la última vida activa
   519 00000242 B907000000                  mov rcx, lives_count
   520 00000247 48FFC9                      dec rcx
   521                                      
   522                                      .find_active_life:
   523 0000024A 4889C8                          mov rax, rcx
   524 0000024D 486BC003                        imul rax, 3
   525 00000251 488DB0[82160000]                lea rsi, [lives_data + rax]
   526 00000258 807E0201                        cmp byte [rsi + 2], 1
   527 0000025C 740A                            je .deactivate_life
   528 0000025E 48FFC9                          dec rcx
   529 00000261 79E7                            jns .find_active_life
   530 00000263 E985000000                      jmp .game_lost
   531                                          
   532                                      .deactivate_life:
   533                                          ; Borrar vida visualmente y en datos
   534 00000268 4C0FB606                        movzx r8, byte [rsi]
   535 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   536 00000271 B84E000000                      mov rax, column_cells
   537 00000276 4883C002                        add rax, 2
   538 0000027A 49F7E1                          mul r9
   539 0000027D 4C01C0                          add rax, r8
   540 00000280 488DB8[000A0000]                lea rdi, [board + rax]
   541 00000287 C60720                          mov byte [rdi], ' '
   542 0000028A C6460200                        mov byte [rsi + 2], 0
   543 0000028E FE0D(98160000)                  dec byte [current_lives]
   544                                          
   545                                          ; Borrar paleta anterior
   546 00000294 4C8B05(3F140000)                mov r8, [pallet_position]
   547 0000029B 488B0D(47140000)                mov rcx, [pallet_size]
   548                                          .erase_pallet_loop:
   549 000002A2 41C60020                            mov byte [r8], ' '
   550 000002A6 49FFC0                              inc r8
   551 000002A9 48FFC9                              dec rcx
   552 000002AC 75F4                                jnz .erase_pallet_loop
   553                                          
   554                                          ; Reiniciar solo la bola principal
   555 000002AE 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   555 000002B6 000000             
   556 000002B9 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   556 000002C1 000000             
   557 000002C4 C605(7F140000)00                mov byte [ball_moving], 0
   558 000002CB C605(80140000)01                mov byte [ball_active], 1       ; Activar bola principal
   559 000002D2 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   559 000002D9 [36130000]         
   560                                          
   561                                          ; Asegurarse que las otras bolas están desactivadas
   562 000002DD C605(A2140000)00                mov byte [ball2_active], 0
   563 000002E4 C605(C4140000)00                mov byte [ball3_active], 0
   564                                          
   565 000002EB EB07                            jmp .end
   566                                          
   567                                      .game_lost:
   568 000002ED E8C7000000                      call game_lost
   569 000002F2 EB00                            jmp .end
   570                                          
   571                                      .end:
   572 000002F4 5D                              pop rbp
   573 000002F5 C3                              ret
   574                                  ; Función modificada para verificar colisión con el borde inferior
   575                                  check_bottom_collision:
   576 000002F6 55                          push rbp
   577 000002F7 4889E5                      mov rbp, rsp
   578                                      
   579                                      ; Verificar bola principal
   580 000002FA 803D(80140000)01            cmp byte [ball_active], 1
   581 00000301 7542                        jne .check_ball2
   582 00000303 488B05(67140000)            mov rax, [ball_y_pos]
   583 0000030A 4883F81E                    cmp rax, row_cells - 2
   584 0000030E 7535                        jne .check_ball2
   585                                      
   586                                      ; Borrar visualmente la bola principal
   587 00000310 4C8B05(5F140000)            mov r8, [ball_x_pos]
   588 00000317 4C8B0D(67140000)            mov r9, [ball_y_pos]
   589 0000031E 4981C0[000A0000]            add r8, board
   590 00000325 4C89C9                      mov rcx, r9
   591 00000328 B850000000                  mov rax, column_cells + 2
   592 0000032D 48F7E9                      imul rcx
   593 00000330 4901C0                      add r8, rax
   594 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   595                                      
   596 00000337 C605(80140000)00            mov byte [ball_active], 0
   597 0000033E C605(7F140000)00            mov byte [ball_moving], 0
   598                                  
   599                                  .check_ball2:
   600 00000345 803D(A2140000)01            cmp byte [ball2_active], 1
   601 0000034C 751B                        jne .check_ball3
   602 0000034E 488B05(89140000)            mov rax, [ball2_y_pos]
   603 00000355 4883F81E                    cmp rax, row_cells - 2
   604 00000359 750E                        jne .check_ball3
   605 0000035B C605(A2140000)00            mov byte [ball2_active], 0
   606 00000362 C605(A1140000)00            mov byte [ball2_moving], 0
   607                                  
   608                                  .check_ball3:
   609 00000369 803D(C4140000)01            cmp byte [ball3_active], 1
   610 00000370 751B                        jne .check_active_balls
   611 00000372 488B05(AB140000)            mov rax, [ball3_y_pos]
   612 00000379 4883F81E                    cmp rax, row_cells - 2
   613 0000037D 750E                        jne .check_active_balls
   614 0000037F C605(C4140000)00            mov byte [ball3_active], 0
   615 00000386 C605(C3140000)00            mov byte [ball3_moving], 0
   616                                  
   617                                  .check_active_balls:
   618                                      ; Verificar si quedan bolas activas
   619 0000038D 4831C9                      xor rcx, rcx
   620 00000390 803D(80140000)01            cmp byte [ball_active], 1
   621 00000397 741E                        je .balls_remain
   622 00000399 803D(A2140000)01            cmp byte [ball2_active], 1
   623 000003A0 7415                        je .balls_remain
   624 000003A2 803D(C4140000)01            cmp byte [ball3_active], 1
   625 000003A9 740C                        je .balls_remain
   626                                      
   627                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   628 000003AB E881FEFFFF                  call lose_life
   629 000003B0 C605(80140000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   630                                      
   631                                  .balls_remain:
   632 000003B7 5D                          pop rbp
   633 000003B8 C3                          ret
   634                                  
   635                                  
   636                                  
   637                                  ; Nueva función para game over
   638                                  game_lost:
   639                                      ; Limpiar la pantalla
   640                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   641                                      
   642                                      ; Mostrar mensaje de derrota
   643                                      section .data
   644 0000199C C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   644 000019A5 6469646F210A0D     
   645                                          lost_msg_len: equ $ - lost_msg
   646                                      section .text
   647                                      
   648                                      ; Imprimir mensaje de derrota
   649                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [9C19000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   650                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [CA19000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   651                                      
   652                                      ; Mostrar puntaje final
   653 0000040A 488B05(9B150000)            mov rax, [current_score]
   654 00000411 48BF-                       mov rdi, number_buffer
   654 00000413 [A415000000000000] 
   655 0000041B E846130000                  call number_to_string
   656                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [A415000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   657                                      
   658                                      ; Esperar un momento antes de salir
   659 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   659 00000444 0000               
   660 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   660 0000044F 0000               
   661                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   662                                      
   663 00000464 E93E1B0000                  jmp exit
   664                                  
   665                                  
   666                                  ; Función para registrar una nueva letra en el mapa
   667                                  ; Entrada:
   668                                  ;   al - letra a registrar
   669                                  ;   r8b - posición x
   670                                  ;   r9b - posición y
   671                                  register_letter:
   672 00000469 55                          push rbp
   673 0000046A 4889E5                      mov rbp, rsp
   674 0000046D 53                          push rbx
   675 0000046E 51                          push rcx
   676                                      
   677 0000046F 3C20                        cmp al, ' '
   678 00000471 7438                        je .end
   679                                  
   680                                      ; Encontrar un espacio libre en el mapa
   681 00000473 4831C9                      xor rcx, rcx
   682 00000476 480FB615(29180000)          movzx rdx, byte [letters_count]
   683                                      
   684                                      .find_slot:
   685 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   686 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   687                                          
   688 00000484 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   689 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   690 00000490 7405                            je .found_slot
   691                                          
   692 00000492 48FFC1                          inc rcx
   693 00000495 EBE7                            jmp .find_slot
   694                                          
   695                                      .found_slot:
   696                                          ; Guardar la información de la letra
   697 00000497 448803                          mov [rbx], r8b           ; x
   698 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   699 0000049E 884302                          mov [rbx + 2], al        ; letra
   700 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   701                                          
   702 000004A5 FE05(29180000)                  inc byte [letters_count]
   703                                          
   704                                      .end:
   705 000004AB 59                              pop rcx
   706 000004AC 5B                              pop rbx
   707 000004AD 5D                              pop rbp
   708 000004AE C3                              ret
   709                                  
   710                                  ; Función para imprimir todas las letras registradas
   711                                  print_letters:
   712 000004AF 55                          push rbp
   713 000004B0 4889E5                      mov rbp, rsp
   714 000004B3 53                          push rbx
   715 000004B4 51                          push rcx
   716                                      
   717 000004B5 4831C9                      xor rcx, rcx
   718                                      
   719                                      .print_loop:
   720 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   721 000004BC 7D37                            jge .end
   722                                          
   723                                          ; Obtener puntero a la letra actual
   724 000004BE 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   725                                          
   726                                          ; Verificar si está activa
   727 000004C6 807B0300                        cmp byte [rbx + 3], 0
   728 000004CA 7424                            je .next_letter
   729                                          
   730                                          ; Calcular posición en el tablero
   731 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   732 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   733                                          
   734                                          ; Calcular offset en el tablero
   735 000004D5 B84E000000                      mov rax, column_cells
   736 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   737 000004DE 49F7E1                          mul r9
   738 000004E1 4C01C0                          add rax, r8
   739 000004E4 488DB8[000A0000]                lea rdi, [board + rax]
   740                                          
   741                                          ; Imprimir la letra
   742 000004EB 8A4302                          mov al, [rbx + 2]
   743 000004EE 8807                            mov [rdi], al
   744                                          
   745                                      .next_letter:
   746 000004F0 48FFC1                          inc rcx
   747 000004F3 EBC3                            jmp .print_loop
   748                                          
   749                                      .end:
   750 000004F5 59                              pop rcx
   751 000004F6 5B                              pop rbx
   752 000004F7 5D                              pop rbp
   753 000004F8 C3                              ret
   754                                  
   755                                  ; Función para borrar una letra específica
   756                                  ; Entrada:
   757                                  ;   r8b - posición x
   758                                  ;   r9b - posición y
   759                                  remove_letter:
   760 000004F9 55                          push rbp
   761 000004FA 4889E5                      mov rbp, rsp
   762 000004FD 53                          push rbx
   763 000004FE 51                          push rcx
   764                                      
   765 000004FF 4831C9                      xor rcx, rcx
   766                                      
   767                                      .find_loop:
   768 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   769 00000506 7D2E                            jge .end
   770                                          
   771 00000508 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   772                                          
   773                                          ; Verificar si está activa y coincide la posición
   774 00000510 807B0300                        cmp byte [rbx + 3], 0
   775 00000514 741B                            je .next_letter
   776                                          
   777 00000516 8A03                            mov al, [rbx]
   778 00000518 4438C0                          cmp al, r8b
   779 0000051B 7514                            jne .next_letter
   780                                          
   781 0000051D 8A4301                          mov al, [rbx + 1]
   782 00000520 4438C8                          cmp al, r9b
   783 00000523 750C                            jne .next_letter
   784                                          
   785                                          ; Encontrada la letra, desactivarla
   786 00000525 C6430300                        mov byte [rbx + 3], 0
   787 00000529 FE0D(29180000)                  dec byte [letters_count]
   788 0000052F EB05                            jmp .end
   789                                          
   790                                      .next_letter:
   791 00000531 48FFC1                          inc rcx
   792 00000534 EBCC                            jmp .find_loop
   793                                          
   794                                      .end:
   795 00000536 59                              pop rcx
   796 00000537 5B                              pop rbx
   797 00000538 5D                              pop rbp
   798 00000539 C3                              ret
   799                                  ; Función para mover las letras hacia abajo
   800                                  move_letters:
   801 0000053A 55                          push rbp
   802 0000053B 4889E5                      mov rbp, rsp
   803 0000053E 53                          push rbx
   804 0000053F 57                          push rdi
   805 00000540 56                          push rsi
   806 00000541 4150                        push r8
   807 00000543 4151                        push r9
   808 00000545 4152                        push r10
   809 00000547 4153                        push r11
   810                                  
   811 00000549 4831C9                      xor rcx, rcx
   812                                  
   813                                      .move_loop:
   814 0000054C 4883F964                        cmp rcx, 100
   815 00000550 0F8D0D020000                    jge .print_last_letter
   816                                          
   817 00000556 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   818 0000055E 807B0300                        cmp byte [rbx + 3], 0
   819 00000562 0F84F3010000                    je .next_letter
   820                                  
   821 00000568 4C0FB603                        movzx r8, byte [rbx]
   822 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
   823                                  
   824 00000571 B84E000000                      mov rax, column_cells
   825 00000576 4883C002                        add rax, 2
   826 0000057A 49F7E1                          mul r9
   827 0000057D 4C01C0                          add rax, r8
   828 00000580 488DB8[000A0000]                lea rdi, [board + rax]
   829 00000587 C60720                          mov byte [rdi], ' '
   830                                  
   831 0000058A FE4301                          inc byte [rbx + 1]
   832 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
   833                                  
   834 00000592 4983F91F                        cmp r9, row_cells - 1
   835 00000596 7C09                            jl .check_pallet_collision
   836                                  
   837 00000598 C6430300                        mov byte [rbx + 3], 0
   838 0000059C E9BA010000                      jmp .next_letter
   839                                  
   840                                          .check_pallet_collision:
   841 000005A1 B84E000000                          mov rax, column_cells
   842 000005A6 4883C002                            add rax, 2
   843 000005AA 49F7E1                              mul r9
   844 000005AD 4C01C0                              add rax, r8
   845 000005B0 488DB8[000A0000]                    lea rdi, [board + rax]
   846                                  
   847 000005B7 8A07                                mov al, [rdi]
   848 000005B9 3C20                                cmp al, ' '
   849 000005BB 0F849A010000                        je .next_letter
   850 000005C1 3C3D                                cmp al, char_equal
   851 000005C3 740A                                je .capture_letter
   852                                  
   853 000005C5 8A4302                              mov al, [rbx + 2]
   854 000005C8 8807                                mov [rdi], al
   855 000005CA E98C010000                          jmp .next_letter
   856                                  
   857                                          .capture_letter:
   858                                              ; Obtener la nueva letra
   859 000005CF 8A4302                              mov al, [rbx + 2]
   860                                              
   861                                              ; Comparar con la última letra
   862 000005D2 3A05(2A180000)                      cmp al, [last_letter]
   863 000005D8 7407                                je .same_letter
   864                                              
   865                                              ; Es una letra diferente, resetear el procesamiento
   866 000005DA C605(3E180000)00                    mov byte [current_power_processed], 0
   867                                              
   868                                              .same_letter:
   869                                              ; Guardar la nueva letra
   870 000005E1 8805(2A180000)                      mov [last_letter], al
   871                                              
   872                                              ; Verificar si es 'E' para extender la paleta
   873 000005E7 3C45                                cmp al, 'E'
   874 000005E9 7450                                je .extend_pallet
   875                                              
   876                                              ; Verificar si es 'P' para añadir vida
   877 000005EB 3C50                                cmp al, 'P'
   878 000005ED 7478                                je .check_add_life
   879                                  
   880 000005EF 3C53                                cmp al, 'S'
   881 000005F1 0F84B4000000                        je .slow_ball
   882                                  
   883 000005F7 3C43                                cmp al, 'C'
   884 000005F9 0F84D8000000                        je .activate_catch
   885                                              
   886 000005FF 3C4C                                cmp al, 'L'
   887 00000601 0F84F9000000                        je .activate_laser
   888                                  
   889 00000607 3C44                                cmp al, 'D'
   890 00000609 0F841A010000                        je .activate_split
   891                                  
   892                                              ; Si no es ningún power-up, restaurar tamaño normal
   893 0000060F 488B05(4F140000)                    mov rax, [default_pallet_size]
   894 00000616 488905(47140000)                    mov [pallet_size], rax
   895 0000061D 48C705(40180000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   895 00000625 000000             
   896 00000628 C605(58180000)00                    mov byte [catch_power_active], 0
   897 0000062F C605(65180000)00                    mov byte [laser_power_active], 0
   898 00000636 E91C010000                          jmp .finish_capture
   899                                  
   900                                              .extend_pallet:
   901 0000063B C605(65180000)00                        mov byte [laser_power_active], 0
   902 00000642 C605(58180000)00                        mov byte [catch_power_active], 0
   903 00000649 48C705(40180000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   903 00000651 000000             
   904 00000654 488B05(57140000)                        mov rax, [extended_pallet_size]
   905 0000065B 488905(47140000)                        mov [pallet_size], rax
   906 00000662 E9F0000000                              jmp .finish_capture
   907                                  
   908                                              .check_add_life:
   909 00000667 C605(65180000)00                        mov byte [laser_power_active], 0
   910 0000066E C605(58180000)00                        mov byte [catch_power_active], 0
   911 00000675 488B05(4F140000)                        mov rax, [default_pallet_size]
   912 0000067C 488905(47140000)                        mov [pallet_size], rax
   913 00000683 48C705(40180000)01-                     mov qword [ball_speed], 1 
   913 0000068B 000000             
   914                                                  ; Verificar si ya procesamos este power-up
   915 0000068E 803D(3E180000)00                        cmp byte [current_power_processed], 0
   916 00000695 0F85BC000000                            jne .finish_capture
   917                                                  
   918                                                  ; Preservar registros importantes
   919 0000069B 51                                      push rcx
   920 0000069C 53                                      push rbx
   921                                                  
   922                                                  ; Marcar como procesado
   923 0000069D C605(3E180000)01                        mov byte [current_power_processed], 1
   924                                                  
   925                                                  ; Añadir una vida
   926 000006A4 E838040000                              call add_life
   927                                                  
   928                                                  ; Restaurar registros
   929 000006A9 5B                                      pop rbx
   930 000006AA 59                                      pop rcx
   931                                                  
   932                                              .slow_ball:
   933 000006AB C605(65180000)00                        mov byte [laser_power_active], 0
   934 000006B2 C605(58180000)00                        mov byte [catch_power_active], 0                
   935 000006B9 488B05(4F140000)                        mov rax, [default_pallet_size]
   936 000006C0 488905(47140000)                        mov [pallet_size], rax
   937 000006C7 48C705(40180000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   937 000006CF 000000             
   938 000006D2 E980000000                              jmp .finish_capture
   939                                  
   940                                              .activate_catch:
   941 000006D7 C605(65180000)00                        mov byte [laser_power_active], 0
   942 000006DE 488B05(4F140000)                        mov rax, [default_pallet_size]
   943 000006E5 488905(47140000)                        mov [pallet_size], rax
   944 000006EC 48C705(40180000)01-                     mov qword [ball_speed], 1
   944 000006F4 000000             
   945 000006F7 C605(58180000)01                        mov byte [catch_power_active], 1
   946 000006FE EB57                                    jmp .finish_capture
   947                                  
   948                                              .activate_laser:
   949 00000700 C605(58180000)00                        mov byte [catch_power_active], 0
   950 00000707 488B05(4F140000)                        mov rax, [default_pallet_size]
   951 0000070E 488905(47140000)                        mov [pallet_size], rax
   952 00000715 48C705(40180000)01-                     mov qword [ball_speed], 1
   952 0000071D 000000             
   953 00000720 C605(65180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   954 00000727 EB2E                                    jmp .finish_capture
   955                                  
   956                                              .activate_split:
   957 00000729 C605(65180000)00                        mov byte [laser_power_active], 0
   958 00000730 C605(58180000)00                        mov byte [catch_power_active], 0
   959 00000737 488B05(4F140000)                        mov rax, [default_pallet_size]
   960 0000073E 488905(47140000)                        mov [pallet_size], rax
   961 00000745 48C705(40180000)01-                     mov qword [ball_speed], 1 
   961 0000074D 000000             
   962 00000750 E8D2000000                              call activate_split_power
   963 00000755 EB00                                    jmp .finish_capture
   964                                  
   965                                              .finish_capture:
   966 00000757 C6430300                                mov byte [rbx + 3], 0
   967                                  
   968                                          .next_letter:
   969 0000075B 48FFC1                              inc rcx
   970 0000075E E9E9FDFFFF                          jmp .move_loop
   971                                  
   972                                      .print_last_letter:
   973                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000763 B801000000          <1>  mov eax, sys_write
    83 00000768 BF01000000          <1>  mov edi, 1
    84 0000076D 48BE-               <1>  mov rsi, %1
    84 0000076F [2B18000000000000]  <1>
    85 00000777 BA10000000          <1>  mov edx, %2
    86 0000077C 0F05                <1>  syscall
   974 0000077E 8A05(2A180000)                  mov al, [last_letter]
   975 00000784 8805(3A180000)                  mov [last_letter_msg + 15], al
   976                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000078A B801000000          <1>  mov eax, sys_write
    83 0000078F BF01000000          <1>  mov edi, 1
    84 00000794 48BE-               <1>  mov rsi, %1
    84 00000796 [3B18000000000000]  <1>
    85 0000079E BA03000000          <1>  mov edx, %2
    86 000007A3 0F05                <1>  syscall
   977                                  
   978                                      .end:
   979 000007A5 415B                            pop r11
   980 000007A7 415A                            pop r10
   981 000007A9 4159                            pop r9
   982 000007AB 4158                            pop r8
   983 000007AD 5E                              pop rsi
   984 000007AE 5F                              pop rdi
   985 000007AF 5B                              pop rbx
   986 000007B0 5D                              pop rbp
   987 000007B1 C3                              ret
   988                                  
   989                                  
   990                                  clear_lasers:
   991 000007B2 55                          push rbp
   992 000007B3 4889E5                      mov  rbp, rsp
   993                                  
   994                                      ; Recorrer el array de láseres
   995 000007B6 4831C9                      xor rcx, rcx                ; Índice del láser
   996 000007B9 480FB61D(67180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   997                                  
   998                                      .clear_loop:
   999 000007C1 4839D9                          cmp rcx, rbx
  1000 000007C4 7D2F                            jge .done                ; Salir si no quedan láseres
  1001                                  
  1002                                          ; Obtener posición del láser actual
  1003 000007C6 488DB409[68180000]              lea rsi, [lasers + rcx * 2]
  1004 000007CE 4C0FB606                        movzx r8, byte [rsi]     ; X
  1005 000007D2 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1006                                  
  1007                                          ; Calcular posición en el tablero
  1008 000007D7 B84E000000                      mov rax, column_cells
  1009 000007DC 4883C002                        add rax, 2
  1010 000007E0 49F7E1                          mul r9
  1011 000007E3 4C01C0                          add rax, r8
  1012 000007E6 488DB8[000A0000]                lea rdi, [board + rax]
  1013                                  
  1014                                          ; Borrar el láser visualmente
  1015 000007ED C60720                          mov byte [rdi], ' '
  1016                                  
  1017                                          ; Pasar al siguiente láser
  1018 000007F0 48FFC1                          inc rcx
  1019 000007F3 EBCC                            jmp .clear_loop
  1020                                  
  1021                                      .done:
  1022                                          ; Resetear contador de láseres
  1023 000007F5 C605(67180000)00                mov byte [laser_count], 0
  1024                                  
  1025 000007FC 5D                              pop rbp
  1026 000007FD C3                              ret
  1027                                  
  1028                                  
  1029                                  ; Nueva función para actualizar los láseres
  1030                                  update_lasers:
  1031 000007FE 55                          push rbp
  1032 000007FF 4889E5                      mov rbp, rsp
  1033                                      
  1034                                      ; Verificar si el poder láser está activo
  1035 00000802 803D(65180000)00            cmp byte [laser_power_active], 0
  1036 00000809 741A                        je .end
  1037                                      
  1038                                      ; Verificar si se presionó la tecla de espacio
  1039 0000080B 803D(64180000)20            cmp byte [last_key], ' '
  1040 00000812 750C                        jne .skip_shooting
  1041                                      
  1042                                      ; Disparar nuevos láseres
  1043 00000814 E89A000000                  call shoot_lasers
  1044 00000819 C605(64180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1045                                      
  1046                                      .skip_shooting:
  1047                                      ; Mover los láseres existentes
  1048 00000820 E828010000                  call move_lasers
  1049                                      
  1050                                      .end:
  1051 00000825 5D                              pop rbp
  1052 00000826 C3                              ret
  1053                                  
  1054                                  activate_split_power:
  1055 00000827 55                          push rbp
  1056 00000828 4889E5                      mov rbp, rsp
  1057                                      
  1058                                      ; Verificar si la bola2 y bola3 ya están activas
  1059 0000082B 803D(A2140000)01            cmp byte [ball2_active], 1
  1060 00000832 750B                        jne .enable_balls
  1061 00000834 803D(C4140000)01            cmp byte [ball3_active], 1
  1062 0000083B 7502                        jne .enable_balls
  1063                                      
  1064                                      ; Si ambas ya están activas, no hacemos nada.
  1065 0000083D EB72                        jmp .end
  1066                                  
  1067                                  .enable_balls:
  1068                                      ; Copiamos la posición de la bola principal
  1069 0000083F 488B05(5F140000)            mov rax, [ball_x_pos]
  1070 00000846 488905(81140000)            mov [ball2_x_pos], rax
  1071 0000084D 488905(A3140000)            mov [ball3_x_pos], rax
  1072                                  
  1073 00000854 488B05(67140000)            mov rax, [ball_y_pos]
  1074 0000085B 488905(89140000)            mov [ball2_y_pos], rax
  1075 00000862 488905(AB140000)            mov [ball3_y_pos], rax
  1076                                  
  1077                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1078                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1079 00000869 48C705(91140000)FF-         mov qword [ball2_direction_x], -1
  1079 00000871 FFFFFF             
  1080 00000874 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  1080 0000087C FFFFFF             
  1081 0000087F C605(A1140000)01            mov byte [ball2_moving], 1
  1082 00000886 C605(A2140000)01            mov byte [ball2_active], 1
  1083                                  
  1084 0000088D 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  1084 00000895 000000             
  1085 00000898 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  1085 000008A0 FFFFFF             
  1086 000008A3 C605(C3140000)01            mov byte [ball3_moving], 1
  1087 000008AA C605(C4140000)01            mov byte [ball3_active], 1
  1088                                  
  1089                                  .end:
  1090 000008B1 5D                          pop rbp
  1091 000008B2 C3                          ret
  1092                                  
  1093                                  
  1094                                  shoot_lasers:
  1095 000008B3 55                          push rbp
  1096 000008B4 4889E5                      mov rbp, rsp
  1097 000008B7 53                          push rbx
  1098                                      
  1099                                      ; Verificar si hay espacio para más láseres
  1100 000008B8 480FB605(67180000)          movzx rax, byte [laser_count]
  1101 000008C0 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1102 000008C4 0F8D80000000                jge .end
  1103                                      
  1104                                      ; Obtener posición de la paleta
  1105 000008CA 4C8B05(3F140000)            mov r8, [pallet_position]
  1106 000008D1 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
  1107                                      
  1108                                      ; Calcular coordenadas x,y
  1109 000008D8 4C89C0                      mov rax, r8
  1110 000008DB 41B94E000000                mov r9, column_cells
  1111 000008E1 4983C102                    add r9, 2                     ; Ancho total de línea
  1112 000008E5 4831D2                      xor rdx, rdx
  1113 000008E8 49F7F1                      div r9                        ; rax = y, rdx = x
  1114                                      
  1115                                      ; Guardar coordenadas
  1116 000008EB 4989C2                      mov r10, rax                  ; Y en r10
  1117 000008EE 4989D3                      mov r11, rdx                  ; X en r11
  1118                                      
  1119                                      ; Validar coordenadas
  1120 000008F1 4983FA00                    cmp r10, 0
  1121 000008F5 7C53                        jl .end
  1122 000008F7 4983FA20                    cmp r10, row_cells
  1123 000008FB 7D4D                        jge .end
  1124 000008FD 4983FB00                    cmp r11, 0
  1125 00000901 7C47                        jl .end
  1126 00000903 4983FB4E                    cmp r11, column_cells
  1127 00000907 7D41                        jge .end
  1128                                      
  1129                                      ; Calcular índice para el primer láser
  1130 00000909 480FB61D(67180000)          movzx rbx, byte [laser_count]
  1131 00000911 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1132                                      
  1133                                      ; Primer láser (izquierda)
  1134 00000915 488DBB[68180000]            lea rdi, [lasers + rbx]
  1135 0000091C 44881F                      mov [rdi], r11b              ; X
  1136 0000091F 4488D0                      mov al, r10b
  1137 00000922 FEC8                        dec al                       ; Y - 1
  1138 00000924 884701                      mov [rdi + 1], al           ; Y
  1139                                      
  1140                                      ; Segundo láser (derecha)
  1141 00000927 4488D8                      mov al, r11b
  1142 0000092A 0205(47140000)              add al, byte [pallet_size]
  1143 00000930 FEC8                        dec al                       ; Ajustar para el último carácter
  1144 00000932 488DBB[6A180000]            lea rdi, [lasers + rbx + 2]
  1145 00000939 8807                        mov [rdi], al               ; X
  1146 0000093B 4488D0                      mov al, r10b
  1147 0000093E FEC8                        dec al                      ; Y - 1
  1148 00000940 884701                      mov [rdi + 1], al          ; Y
  1149                                      
  1150                                      ; Incrementar contador de láseres
  1151 00000943 8005(67180000)02            add byte [laser_count], 2
  1152                                      
  1153                                      
  1154                                      .end:
  1155 0000094A 5B                              pop rbx
  1156 0000094B 5D                              pop rbp
  1157 0000094C C3                              ret
  1158                                  
  1159                                  ; Función corregida para mover láseres
  1160                                  ; Función corregida para mover láseres
  1161                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1162                                  
  1163                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1164                                  ; ============================================================
  1165                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1166                                  ; ============================================================
  1167                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1168                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1169                                  ; ============================================================
  1170                                  move_lasers:
  1171 0000094D 55                          push rbp
  1172 0000094E 4889E5                      mov  rbp, rsp
  1173 00000951 53                          push rbx
  1174 00000952 57                          push rdi
  1175 00000953 56                          push rsi
  1176 00000954 4154                        push r12
  1177 00000956 4155                        push r13
  1178 00000958 4156                        push r14
  1179 0000095A 4157                        push r15
  1180                                  
  1181                                      ; 1) Tomamos la cantidad de láseres
  1182 0000095C 480FB60D(67180000)          movzx rcx, byte [laser_count]
  1183 00000964 4885C9                      test rcx, rcx
  1184 00000967 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1185                                  
  1186                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1187 0000096D 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1188                                  
  1189                                  .loop_lasers:
  1190                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1191 00000970 488DB409[68180000]          lea rsi, [lasers + rcx*2]
  1192                                  
  1193                                      ; 2) Cargar x,y actuales del láser
  1194 00000978 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1195 0000097C 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1196                                  
  1197                                      ; 3) Borrar el láser de su posición actual en pantalla
  1198                                      ;    (por si en el ciclo anterior se había dibujado)
  1199 00000981 B84E000000                  mov rax, column_cells
  1200 00000986 4883C002                    add rax, 2
  1201 0000098A 49F7E1                      mul r9
  1202 0000098D 4C01C0                      add rax, r8
  1203 00000990 488DB8[000A0000]            lea rdi, [board + rax]
  1204 00000997 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1205                                  
  1206                                      ; 4) Mover el láser hacia arriba (y - 1)
  1207 0000099A 49FFC9                      dec r9
  1208                                  
  1209                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1210 0000099D 4983F901                    cmp r9, 1
  1211 000009A1 7C57                        jl .delete_laser
  1212                                  
  1213                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1214 000009A3 44884E01                    mov byte [rsi + 1], r9b
  1215                                  
  1216                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1217                                      ;    - Primero colisión con bloques
  1218                                      ; ---------------------------------------------------------
  1219                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1220 000009A7 B84E000000                  mov rax, column_cells
  1221 000009AC 4883C002                    add rax, 2
  1222 000009B0 49F7E1                      mul r9
  1223 000009B3 4C01C0                      add rax, r8
  1224 000009B6 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1225                                  
  1226                                      ; Revisar si hay bloque
  1227 000009BD 51                          push rcx
  1228 000009BE 56                          push rsi
  1229 000009BF 57                          push rdi
  1230 000009C0 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1231 000009C3 E8F60E0000                  call check_block_collision
  1232 000009C8 5F                          pop rdi
  1233 000009C9 5E                          pop rsi
  1234 000009CA 59                          pop rcx
  1235                                  
  1236 000009CB 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1237 000009CE 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1238                                  
  1239                                      ;    - Luego colisión con enemigos
  1240                                      ; ---------------------------------------------------------
  1241 000009D0 51                          push rcx
  1242 000009D1 56                          push rsi
  1243 000009D2 57                          push rdi
  1244                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1245                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1246                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1247                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1248                                      ;
  1249                                      ; Hacemos algo como:
  1250 000009D3 4989FA                      mov r10, rdi
  1251 000009D6 E85A000000                  call check_laser_enemy_collision
  1252 000009DB 5F                          pop rdi
  1253 000009DC 5E                          pop rsi
  1254 000009DD 59                          pop rcx
  1255                                  
  1256 000009DE 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1257 000009E1 7517                        jnz .delete_laser
  1258                                  
  1259                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1260 000009E3 8A05(66180000)              mov al, [laser_symbol]
  1261 000009E9 8807                        mov [rdi], al
  1262                                  
  1263                                  .next_laser:
  1264                                      ; Pasamos al láser anterior en el array
  1265 000009EB 48FFC9                      dec rcx
  1266 000009EE 4883F9FF                    cmp rcx, -1
  1267 000009F2 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1268 000009F8 EB2E                        jmp .fin
  1269                                  
  1270                                  ; -----------------------------------------------------------------
  1271                                  ; Subrutina interna: .delete_laser
  1272                                  ; -----------------------------------------------------------------
  1273                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1274                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1275                                  .delete_laser:
  1276 000009FA 4C0FB625(67180000)          movzx r12, byte [laser_count]
  1277 00000A02 49FFCC                      dec r12                    ; r12 = índice del último láser
  1278 00000A05 4939CC                      cmp r12, rcx
  1279 00000A08 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1280                                  
  1281                                      ; Copiamos el último láser a la posición actual
  1282 00000A0A 488DBC09[68180000]          lea rdi, [lasers + rcx*2]
  1283 00000A12 4B8DB424[68180000]          lea rsi, [lasers + r12*2]
  1284 00000A1A 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1285 00000A1D 668907                      mov [rdi], ax             ; copiamos X,Y
  1286                                  
  1287                                  .just_decrement:
  1288 00000A20 FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1289 00000A26 EBC3                        jmp .next_laser
  1290                                  
  1291                                  .fin:
  1292 00000A28 415F                        pop r15
  1293 00000A2A 415E                        pop r14
  1294 00000A2C 415D                        pop r13
  1295 00000A2E 415C                        pop r12
  1296 00000A30 5E                          pop rsi
  1297 00000A31 5F                          pop rdi
  1298 00000A32 5B                          pop rbx
  1299 00000A33 5D                          pop rbp
  1300 00000A34 C3                          ret
  1301                                  
  1302                                  
  1303                                  ; Nueva función para verificar colisión entre láser y enemigos
  1304                                  ; ==========================================================
  1305                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1306                                  ; ==========================================================
  1307                                  check_laser_enemy_collision:
  1308 00000A35 55                          push rbp
  1309 00000A36 4889E5                      mov  rbp, rsp
  1310                                      
  1311 00000A39 4D31ED                      xor r13, r13            ; Índice del enemigo
  1312 00000A3C 4831C0                      xor rax, rax            ; 0 = no colisión
  1313                                  
  1314                                  .loop_enemies:
  1315 00000A3F 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1316 00000A43 7D64                        jge .end
  1317                                  
  1318                                      ; r13 * 3 => offset del enemigo i
  1319 00000A45 4C89E9                      mov rcx, r13
  1320 00000A48 486BC903                    imul rcx, 3
  1321 00000A4C 488DB1[BD150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1322                                  
  1323                                      ; Verificar si está activo
  1324 00000A53 807E0201                    cmp byte [rsi+2], 1
  1325 00000A57 754B                        jne .next_enemy
  1326                                  
  1327                                      ; Cargar posición X/Y del enemigo
  1328 00000A59 4C0FB636                    movzx r14, byte [rsi]      ; X
  1329 00000A5D 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1330                                  
  1331                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1332 00000A62 4D39F0                      cmp r8, r14
  1333 00000A65 753D                        jne .next_enemy
  1334 00000A67 4D39F9                      cmp r9, r15
  1335 00000A6A 7538                        jne .next_enemy
  1336                                  
  1337                                      ; ==== Colisión detectada con láser ====
  1338                                  
  1339                                      ; 1) Desactivar enemigo
  1340 00000A6C C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1341                                  
  1342                                      ; 2) Sumar puntos
  1343 00000A70 488B05(DC150000)            mov rax, [enemy_points]
  1344 00000A77 480105(9B150000)            add [current_score], rax
  1345                                  
  1346                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1347                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1348 00000A7E 4983FF1E                    cmp r15, row_cells - 2
  1349 00000A82 7419                        je .skip_erase
  1350                                  
  1351                                      ; Borrar visualmente del board
  1352 00000A84 B84E000000                  mov rax, column_cells
  1353 00000A89 4883C002                    add rax, 2
  1354 00000A8D 49F7E7                      mul r15
  1355 00000A90 4C01F0                      add rax, r14
  1356 00000A93 488DB8[000A0000]            lea rdi, [board + rax]
  1357 00000A9A C60720                      mov byte [rdi], ' '
  1358                                  
  1359                                  .skip_erase:
  1360                                  
  1361                                      ; 4) Devolver rax=1 => colisión con enemigo
  1362 00000A9D B801000000                  mov rax, 1
  1363 00000AA2 EB05                        jmp .end
  1364                                  
  1365                                  .next_enemy:
  1366 00000AA4 49FFC5                      inc r13
  1367 00000AA7 EB96                        jmp .loop_enemies
  1368                                  
  1369                                  .end:
  1370 00000AA9 5D                          pop rbp
  1371 00000AAA C3                          ret
  1372                                  
  1373                                  
  1374                                  ; Función auxiliar para eliminar un láser específico
  1375                                  remove_laser:
  1376 00000AAB 55                          push rbp
  1377 00000AAC 4889E5                      mov rbp, rsp
  1378                                  
  1379                                      ; Borrar el láser del tablero
  1380 00000AAF 41C60220                    mov byte [r10], ' '
  1381                                  
  1382                                      ; Mover el último láser a esta posición si no es el último
  1383 00000AB3 480FB605(67180000)          movzx rax, byte [laser_count]
  1384 00000ABB 48FFC8                      dec rax                    ; Índice del último láser
  1385 00000ABE 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1386 00000AC1 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1387                                  
  1388                                      ; Copiar último láser a la posición actual
  1389 00000AC3 4B8DBC24[68180000]          lea rdi, [lasers + r12*2]
  1390 00000ACB 488DB400[68180000]          lea rsi, [lasers + rax*2]
  1391 00000AD3 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1392 00000AD6 668917                      mov [rdi], dx
  1393                                  
  1394                                  .just_decrease:
  1395 00000AD9 FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1396                                  
  1397 00000ADF 5D                          pop rbp
  1398 00000AE0 C3                          ret
  1399                                  
  1400                                  add_life:
  1401 00000AE1 55                          push rbp
  1402 00000AE2 4889E5                      mov rbp, rsp
  1403 00000AE5 53                          push rbx
  1404 00000AE6 51                          push rcx
  1405 00000AE7 57                          push rdi
  1406 00000AE8 56                          push rsi
  1407 00000AE9 4150                        push r8
  1408 00000AEB 4151                        push r9
  1409                                      
  1410                                      ; Verificar si ya tenemos el máximo de vidas
  1411 00000AED 480FB605(98160000)          movzx rax, byte [current_lives]
  1412 00000AF5 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1413 00000AF9 7D2C                        jge .end
  1414                                      
  1415                                      ; Incrementar el contador de vidas
  1416 00000AFB FE05(98160000)              inc byte [current_lives]
  1417                                      
  1418                                      ; Encontrar la siguiente vida inactiva
  1419 00000B01 4831C9                      xor rcx, rcx
  1420                                      
  1421                                      .find_inactive:
  1422 00000B04 4883F907                        cmp rcx, lives_count
  1423 00000B08 7D1D                            jge .end
  1424                                          
  1425                                          ; Calcular offset de la vida actual
  1426 00000B0A 4889C8                          mov rax, rcx
  1427 00000B0D 486BC003                        imul rax, 3
  1428 00000B11 488DB0[82160000]                lea rsi, [lives_data + rax]
  1429                                          
  1430                                          ; Verificar si está inactiva
  1431 00000B18 807E0200                        cmp byte [rsi + 2], 0
  1432 00000B1C 7405                            je .activate_life
  1433                                          
  1434 00000B1E 48FFC1                          inc rcx
  1435 00000B21 EBE1                            jmp .find_inactive
  1436                                          
  1437                                      .activate_life:
  1438                                          ; Activar la vida
  1439 00000B23 C6460201                        mov byte [rsi + 2], 1
  1440                                          
  1441                                      .end:
  1442 00000B27 4159                            pop r9
  1443 00000B29 4158                            pop r8
  1444 00000B2B 5E                              pop rsi
  1445 00000B2C 5F                              pop rdi
  1446 00000B2D 59                              pop rcx
  1447 00000B2E 5B                              pop rbx
  1448 00000B2F 5D                              pop rbp
  1449 00000B30 C3                              ret
  1450                                  
  1451                                  
  1452                                  print_ball:
  1453 00000B31 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1454 00000B38 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1455 00000B3F 4981C0[000A0000]        	add r8, board
  1456                                  
  1457 00000B46 4C89C9                  	mov rcx, r9
  1458 00000B49 B850000000              	mov rax, column_cells + 2
  1459 00000B4E 48F7E9                  	imul rcx
  1460                                  	
  1461 00000B51 4901C0                  	add r8, rax
  1462 00000B54 41C6004F                	mov byte [r8], char_O
  1463 00000B58 C3                      	ret
  1464                                  
  1465                                  print_ball_2:
  1466 00000B59 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1467 00000B60 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1468 00000B67 4981C0[000A0000]            add r8, board
  1469 00000B6E 4C89C9                      mov rcx, r9
  1470 00000B71 B850000000                  mov rax, column_cells + 2
  1471 00000B76 48F7E9                      imul rcx
  1472 00000B79 4901C0                      add r8, rax
  1473 00000B7C 41C6004F                    mov byte [r8], char_O
  1474 00000B80 C3                          ret
  1475                                  
  1476                                  print_ball_3:
  1477 00000B81 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1478 00000B88 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1479 00000B8F 4981C0[000A0000]            add r8, board
  1480 00000B96 4C89C9                      mov rcx, r9
  1481 00000B99 B850000000                  mov rax, column_cells + 2
  1482 00000B9E 48F7E9                      imul rcx
  1483 00000BA1 4901C0                      add r8, rax
  1484 00000BA4 41C6004F                    mov byte [r8], char_O
  1485 00000BA8 C3                          ret
  1486                                  
  1487                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1488                                  	
  1489                                  print_pallet:
  1490                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1491 00000BA9 4C8B05(3F140000)            mov r8, [pallet_position]
  1492 00000BB0 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1493                                      .clear_pallet:
  1494 00000BB7 41C60020                        mov byte [r8], char_space
  1495 00000BBB 49FFC0                          inc r8
  1496 00000BBE 48FFC9                          dec rcx
  1497 00000BC1 75F4                            jnz .clear_pallet
  1498                                  
  1499                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1500 00000BC3 4C8B05(3F140000)            mov r8, [pallet_position]
  1501 00000BCA 488B0D(47140000)            mov rcx, [pallet_size]
  1502                                      .write_pallet:
  1503 00000BD1 41C6003D                        mov byte [r8], char_equal
  1504 00000BD5 49FFC0                          inc r8
  1505 00000BD8 48FFC9                          dec rcx
  1506 00000BDB 75F4                            jnz .write_pallet
  1507                                  
  1508 00000BDD C3                          ret
  1509                                  
  1510                                  move_pallet:
  1511                                      
  1512 00000BDE 803D(7F140000)00            cmp byte [ball_moving], 0
  1513 00000BE5 7507                        jne .continue_movement
  1514 00000BE7 C605(7F140000)01            mov byte [ball_moving], 1
  1515                                  
  1516                                      .continue_movement:
  1517 00000BEE 4883FFFF                        cmp rdi, left_direction
  1518 00000BF2 7531                            jne .move_right
  1519                                  
  1520                                          .move_left:
  1521                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1522 00000BF4 4C8B05(3F140000)                    mov r8, [pallet_position]
  1523 00000BFB 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1524 00000BFE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1525 00000C01 3C58                                cmp al, 'X'        ; Comparar si es una X
  1526 00000C03 744E                                je .end            ; Si es X, no mover
  1527                                              
  1528 00000C05 4C8B05(3F140000)                    mov r8, [pallet_position]
  1529 00000C0C 4C8B0D(47140000)                    mov r9, [pallet_size]
  1530 00000C13 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1531 00000C19 49FFC8                              dec r8
  1532 00000C1C 4C8905(3F140000)                    mov [pallet_position], r8
  1533 00000C23 EB2E                                jmp .end
  1534                                              
  1535                                          .move_right:
  1536                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1537 00000C25 4C8B05(3F140000)                    mov r8, [pallet_position]
  1538 00000C2C 4C8B0D(47140000)                    mov r9, [pallet_size]
  1539 00000C33 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1540 00000C36 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1541 00000C3A 3C58                                cmp al, 'X'        ; Comparar si es una X
  1542 00000C3C 7415                                je .end            ; Si es X, no mover
  1543                                              
  1544 00000C3E 4C8B05(3F140000)                    mov r8, [pallet_position]
  1545 00000C45 41C60020                            mov byte [r8], char_space
  1546 00000C49 49FFC0                              inc r8
  1547 00000C4C 4C8905(3F140000)                    mov [pallet_position], r8
  1548                                          .end:
  1549 00000C53 C3                                  ret
  1550                                  
  1551                                  
  1552                                  
  1553                                              
  1554                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1555                                  update_caught_ball_position:
  1556 00000C54 55                          push rbp
  1557 00000C55 4889E5                      mov rbp, rsp
  1558                                      
  1559                                      ; Calcular la nueva posición de la bola basada en la paleta
  1560 00000C58 4C8B05(3F140000)            mov r8, [pallet_position]
  1561 00000C5F 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1562 00000C66 B850000000                  mov rax, column_cells + 2
  1563 00000C6B 4831D2                      xor rdx, rdx
  1564 00000C6E 48F7F0                      div rax                ; División para obtener X,Y
  1565                                      
  1566                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1567 00000C71 4989C1                      mov r9, rax            ; Y de la paleta
  1568 00000C74 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1569                                      
  1570                                      ; Añadir el offset guardado a la posición X
  1571 00000C77 4889D0                      mov rax, rdx
  1572 00000C7A 480305(5C180000)            add rax, [ball_catch_offset]
  1573 00000C81 488905(5F140000)            mov [ball_x_pos], rax
  1574 00000C88 4C890D(67140000)            mov [ball_y_pos], r9
  1575                                      
  1576 00000C8F 5D                          pop rbp
  1577 00000C90 C3                          ret
  1578                                  
  1579                                  
  1580                                  move_all_balls:
  1581 00000C91 55                          push rbp
  1582 00000C92 4889E5                      mov rbp, rsp
  1583 00000C95 53                          push rbx
  1584                                      
  1585                                      ; Inicializar contador de bolas
  1586 00000C96 4831DB                      xor rbx, rbx
  1587                                      
  1588                                  .loop_balls:
  1589                                      ; Verificar si hemos procesado todas las bolas
  1590 00000C99 3A1D(9B190000)              cmp bl, byte [balls_count]
  1591 00000C9F 7D1D                        jge .end
  1592                                      
  1593                                      ; Calcular offset de la bola actual
  1594 00000CA1 B821000000                  mov rax, BALL_STRUCT_SIZE
  1595 00000CA6 48F7E3                      mul rbx
  1596                                      
  1597                                      ; Verificar si la bola está activa
  1598 00000CA9 80B8[58190000]01            cmp byte [balls_data + rax + 32], 1
  1599 00000CB0 7507                        jne .next_ball
  1600                                      
  1601                                      ; Guardar offset en la pila
  1602 00000CB2 50                          push rax
  1603                                      
  1604                                      ; Llamar a move_ball con los parámetros de esta bola
  1605 00000CB3 E809000000                  call move_ball
  1606                                      
  1607                                      ; Restaurar offset
  1608 00000CB8 58                          pop rax
  1609                                      
  1610                                  .next_ball:
  1611 00000CB9 48FFC3                      inc rbx
  1612 00000CBC EBDB                        jmp .loop_balls
  1613                                      
  1614                                  .end:
  1615 00000CBE 5B                          pop rbx
  1616 00000CBF 5D                          pop rbp
  1617 00000CC0 C3                          ret
  1618                                  
  1619                                  move_ball:
  1620                                  
  1621 00000CC1 803D(59180000)01            cmp byte [ball_caught], 1
  1622 00000CC8 0F849D000000                je .move_with_pallet
  1623                                  
  1624 00000CCE 803D(7F140000)00            cmp byte [ball_moving], 0
  1625 00000CD5 0F84B8010000                je .end
  1626                                  
  1627                                      ; Incrementar contador de velocidad
  1628 00000CDB 48FF05(50180000)            inc qword [speed_counter]
  1629                                      
  1630                                      ; Verificar si debemos mover la bola en este ciclo
  1631 00000CE2 488B05(50180000)            mov rax, [speed_counter]
  1632 00000CE9 483B05(40180000)            cmp rax, [ball_speed]
  1633 00000CF0 0F8C9D010000                jl .end
  1634                                      
  1635                                      ; Resetear contador de velocidad
  1636 00000CF6 48C705(50180000)00-         mov qword [speed_counter], 0
  1636 00000CFE 000000             
  1637                                  
  1638                                      ; Borrar la posición actual de la bola
  1639 00000D01 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1640 00000D08 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1641 00000D0F 4981C0[000A0000]            add r8, board
  1642 00000D16 4C89C9                      mov rcx, r9
  1643 00000D19 B850000000                  mov rax, column_cells + 2
  1644 00000D1E 48F7E9                      imul rcx
  1645 00000D21 4901C0                      add r8, rax
  1646 00000D24 41C60020                    mov byte [r8], char_space
  1647                                  
  1648                                      ; Calcular siguiente posición X
  1649 00000D28 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1650 00000D2F 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1651 00000D36 488B05(6F140000)            mov rax, [ball_direction_x]
  1652 00000D3D 4901C0                      add r8, rax               ; Nueva posición X
  1653                                  
  1654                                      ; Calcular la dirección de memoria para la siguiente posición
  1655 00000D40 4D89C2                      mov r10, r8
  1656 00000D43 4981C2[000A0000]            add r10, board
  1657 00000D4A 4C89C9                      mov rcx, r9
  1658 00000D4D B850000000                  mov rax, column_cells + 2
  1659 00000D52 48F7E9                      imul rcx
  1660 00000D55 4901C2                      add r10, rax
  1661                                  
  1662                                      ; Verificar si hay una X en la siguiente posición X
  1663 00000D58 418A02                      mov al, [r10]
  1664 00000D5B 3C58                        cmp al, 'X'
  1665 00000D5D 7565                        jne .check_block_x
  1666 00000D5F 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1667 00000D66 E928010000                  jmp .end
  1668                                  
  1669                                      .move_with_pallet:
  1670                                          ; Borrar la posición actual de la bola
  1671 00000D6B 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1672 00000D72 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1673 00000D79 4D89C2                          mov r10, r8
  1674 00000D7C 4981C2[000A0000]                add r10, board
  1675 00000D83 4C89C9                          mov rcx, r9
  1676 00000D86 B850000000                      mov rax, column_cells + 2
  1677 00000D8B 48F7E9                          imul rcx
  1678 00000D8E 4901C2                          add r10, rax
  1679 00000D91 41C60220                        mov byte [r10], char_space
  1680                                  
  1681                                          ; Actualizar posición X basada en la paleta
  1682 00000D95 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1683 00000D9C 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1684 00000DA3 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1685 00000DAA 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1686                                  
  1687                                          ; Mantener la bola una posición arriba de la paleta
  1688 00000DB1 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1689 00000DB8 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1690                                  
  1691 00000DBF E9CF000000                      jmp .end
  1692                                  
  1693                                  
  1694                                      .check_block_x:
  1695                                          ; Verificar colisión con bloques en X
  1696 00000DC4 4150                            push r8     ; Guardar registros que usa check_block_collision
  1697 00000DC6 4151                            push r9
  1698 00000DC8 4152                            push r10
  1699 00000DCA E8EF0A0000                      call check_block_collision
  1700 00000DCF 415A                            pop r10
  1701 00000DD1 4159                            pop r9
  1702 00000DD3 4158                            pop r8
  1703 00000DD5 4885C0                          test rax, rax
  1704 00000DD8 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1705 00000DDA 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1706 00000DE1 E9AD000000                      jmp .end
  1707                                  
  1708                                      .check_paddle_x:
  1709                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1710 00000DE6 41803A3D                        cmp byte [r10], char_equal
  1711 00000DEA 750C                            jne .check_y_movement
  1712 00000DEC 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1713 00000DF3 E99B000000                      jmp .end
  1714                                  
  1715                                      .check_y_movement:
  1716                                          ; Calcular siguiente posición Y
  1717 00000DF8 488B05(77140000)                mov rax, [ball_direction_y]
  1718 00000DFF 4901C1                          add r9, rax                  ; Nueva posición Y
  1719                                  
  1720                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1721 00000E02 4D89C2                          mov r10, r8
  1722 00000E05 4981C2[000A0000]                add r10, board
  1723 00000E0C 4C89C9                          mov rcx, r9
  1724 00000E0F B850000000                      mov rax, column_cells + 2
  1725 00000E14 48F7E9                          imul rcx
  1726 00000E17 4901C2                          add r10, rax
  1727                                  
  1728                                          ; Verificar si hay una X en la siguiente posición Y
  1729 00000E1A 418A02                          mov al, [r10]
  1730 00000E1D 3C58                            cmp al, 'X'
  1731 00000E1F 7509                            jne .check_block_y
  1732 00000E21 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1733 00000E28 EB69                            jmp .end
  1734                                  
  1735                                      .check_block_y:
  1736                                          ; Verificar colisión con bloques en Y
  1737 00000E2A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1738 00000E2C 4151                            push r9
  1739 00000E2E 4152                            push r10
  1740 00000E30 E8890A0000                      call check_block_collision
  1741 00000E35 415A                            pop r10
  1742 00000E37 4159                            pop r9
  1743 00000E39 4158                            pop r8
  1744 00000E3B 4885C0                          test rax, rax
  1745 00000E3E 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1746 00000E40 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1747 00000E47 EB4A                            jmp .end
  1748                                  
  1749                                      .check_paddle_y:
  1750                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1751 00000E49 41803A3D                        cmp byte [r10], char_equal
  1752 00000E4D 7536                            jne .update_position
  1753                                  
  1754                                          ; Verificar si el poder catch está activo
  1755 00000E4F 803D(58180000)01                cmp byte [catch_power_active], 1
  1756 00000E56 7524                            jne .normal_bounce
  1757                                  
  1758                                          ; Activar el modo "atrapado"
  1759 00000E58 C605(59180000)01                mov byte [ball_caught], 1
  1760                                          
  1761                                          ; Guardar la posición X actual de la bola como offset
  1762 00000E5F 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1763 00000E66 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1764 00000E6D 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1765 00000E73 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1766                                          
  1767 00000E7A EB17                            jmp .end
  1768                                  
  1769                                      .normal_bounce:
  1770 00000E7C 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1771 00000E83 EB0E                            jmp .end
  1772                                  
  1773                                  
  1774                                      .update_position:
  1775 00000E85 4C8905(5F140000)                mov [ball_x_pos], r8
  1776 00000E8C 4C890D(67140000)                mov [ball_y_pos], r9
  1777                                  
  1778                                      .end:
  1779 00000E93 C3                              ret
  1780                                  
  1781                                  
  1782                                  move_ball_2:
  1783                                  
  1784 00000E94 803D(5A180000)01            cmp byte [ball_caught_2], 1
  1785 00000E9B 0F849D000000                je .move_with_pallet
  1786                                  
  1787 00000EA1 803D(A1140000)00            cmp byte [ball2_moving], 0
  1788 00000EA8 0F84B8010000                je .end
  1789                                  
  1790                                      ; Incrementar contador de velocidad
  1791 00000EAE 48FF05(50180000)            inc qword [speed_counter]
  1792                                      
  1793                                      ; Verificar si debemos mover la bola en este ciclo
  1794 00000EB5 488B05(50180000)            mov rax, [speed_counter]
  1795 00000EBC 483B05(40180000)            cmp rax, [ball_speed]
  1796 00000EC3 0F8C9D010000                jl .end
  1797                                      
  1798                                      ; Resetear contador de velocidad
  1799 00000EC9 48C705(50180000)00-         mov qword [speed_counter], 0
  1799 00000ED1 000000             
  1800                                  
  1801                                      ; Borrar la posición actual de la bola
  1802 00000ED4 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1803 00000EDB 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1804 00000EE2 4981C0[000A0000]            add r8, board
  1805 00000EE9 4C89C9                      mov rcx, r9
  1806 00000EEC B850000000                  mov rax, column_cells + 2
  1807 00000EF1 48F7E9                      imul rcx
  1808 00000EF4 4901C0                      add r8, rax
  1809 00000EF7 41C60020                    mov byte [r8], char_space
  1810                                  
  1811                                      ; Calcular siguiente posición X
  1812 00000EFB 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1813 00000F02 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1814 00000F09 488B05(91140000)            mov rax, [ball2_direction_x]
  1815 00000F10 4901C0                      add r8, rax               ; Nueva posición X
  1816                                  
  1817                                      ; Calcular la dirección de memoria para la siguiente posición
  1818 00000F13 4D89C2                      mov r10, r8
  1819 00000F16 4981C2[000A0000]            add r10, board
  1820 00000F1D 4C89C9                      mov rcx, r9
  1821 00000F20 B850000000                  mov rax, column_cells + 2
  1822 00000F25 48F7E9                      imul rcx
  1823 00000F28 4901C2                      add r10, rax
  1824                                  
  1825                                      ; Verificar si hay una X en la siguiente posición X
  1826 00000F2B 418A02                      mov al, [r10]
  1827 00000F2E 3C58                        cmp al, 'X'
  1828 00000F30 7565                        jne .check_block_x
  1829 00000F32 48F71D(91140000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1830 00000F39 E928010000                  jmp .end
  1831                                  
  1832                                      .move_with_pallet:
  1833                                          ; Borrar la posición actual de la bola
  1834 00000F3E 4C8B05(81140000)                mov r8, [ball2_x_pos]
  1835 00000F45 4C8B0D(89140000)                mov r9, [ball2_y_pos]
  1836 00000F4C 4D89C2                          mov r10, r8
  1837 00000F4F 4981C2[000A0000]                add r10, board
  1838 00000F56 4C89C9                          mov rcx, r9
  1839 00000F59 B850000000                      mov rax, column_cells + 2
  1840 00000F5E 48F7E9                          imul rcx
  1841 00000F61 4901C2                          add r10, rax
  1842 00000F64 41C60220                        mov byte [r10], char_space
  1843                                  
  1844                                          ; Actualizar posición X basada en la paleta
  1845 00000F68 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1846 00000F6F 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1847 00000F76 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1848 00000F7D 4C8905(81140000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1849                                  
  1850                                          ; Mantener la bola una posición arriba de la paleta
  1851 00000F84 4C8B0D(89140000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1852 00000F8B 4C890D(89140000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1853                                  
  1854 00000F92 E9CF000000                      jmp .end
  1855                                  
  1856                                  
  1857                                      .check_block_x:
  1858                                          ; Verificar colisión con bloques en X
  1859 00000F97 4150                            push r8     ; Guardar registros que usa check_block_collision
  1860 00000F99 4151                            push r9
  1861 00000F9B 4152                            push r10
  1862 00000F9D E81C090000                      call check_block_collision
  1863 00000FA2 415A                            pop r10
  1864 00000FA4 4159                            pop r9
  1865 00000FA6 4158                            pop r8
  1866 00000FA8 4885C0                          test rax, rax
  1867 00000FAB 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1868 00000FAD 48F71D(91140000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1869 00000FB4 E9AD000000                      jmp .end
  1870                                  
  1871                                      .check_paddle_x:
  1872                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1873 00000FB9 41803A3D                        cmp byte [r10], char_equal
  1874 00000FBD 750C                            jne .check_y_movement
  1875 00000FBF 48F71D(91140000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1876 00000FC6 E99B000000                      jmp .end
  1877                                  
  1878                                      .check_y_movement:
  1879                                          ; Calcular siguiente posición Y
  1880 00000FCB 488B05(99140000)                mov rax, [ball2_direction_y]
  1881 00000FD2 4901C1                          add r9, rax                  ; Nueva posición Y
  1882                                  
  1883                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1884 00000FD5 4D89C2                          mov r10, r8
  1885 00000FD8 4981C2[000A0000]                add r10, board
  1886 00000FDF 4C89C9                          mov rcx, r9
  1887 00000FE2 B850000000                      mov rax, column_cells + 2
  1888 00000FE7 48F7E9                          imul rcx
  1889 00000FEA 4901C2                          add r10, rax
  1890                                  
  1891                                          ; Verificar si hay una X en la siguiente posición Y
  1892 00000FED 418A02                          mov al, [r10]
  1893 00000FF0 3C58                            cmp al, 'X'
  1894 00000FF2 7509                            jne .check_block_y
  1895 00000FF4 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1896 00000FFB EB69                            jmp .end
  1897                                  
  1898                                      .check_block_y:
  1899                                          ; Verificar colisión con bloques en Y
  1900 00000FFD 4150                            push r8     ; Guardar registros que usa check_block_collision
  1901 00000FFF 4151                            push r9
  1902 00001001 4152                            push r10
  1903 00001003 E8B6080000                      call check_block_collision
  1904 00001008 415A                            pop r10
  1905 0000100A 4159                            pop r9
  1906 0000100C 4158                            pop r8
  1907 0000100E 4885C0                          test rax, rax
  1908 00001011 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1909 00001013 48F71D(99140000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1910 0000101A EB4A                            jmp .end
  1911                                  
  1912                                      .check_paddle_y:
  1913                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1914 0000101C 41803A3D                        cmp byte [r10], char_equal
  1915 00001020 7536                            jne .update_position
  1916                                  
  1917                                          ; Verificar si el poder catch está activo
  1918 00001022 803D(58180000)01                cmp byte [catch_power_active], 1
  1919 00001029 7524                            jne .normal_bounce
  1920                                  
  1921                                          ; Activar el modo "atrapado"
  1922 0000102B C605(5A180000)01                mov byte [ball_caught_2], 1
  1923                                          
  1924                                          ; Guardar la posición X actual de la bola como offset
  1925 00001032 488B05(81140000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  1926 00001039 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1927 00001040 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1928 00001046 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1929                                          
  1930 0000104D EB17                            jmp .end
  1931                                  
  1932                                      .normal_bounce:
  1933 0000104F 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  1934 00001056 EB0E                            jmp .end
  1935                                  
  1936                                  
  1937                                      .update_position:
  1938 00001058 4C8905(81140000)                mov [ball2_x_pos], r8
  1939 0000105F 4C890D(89140000)                mov [ball2_y_pos], r9
  1940                                  
  1941                                      .end:
  1942 00001066 C3                              ret
  1943                                  
  1944                                  move_ball_3:
  1945                                  
  1946 00001067 803D(5B180000)01            cmp byte [ball_caught_3], 1
  1947 0000106E 0F849D000000                je .move_with_pallet
  1948                                  
  1949 00001074 803D(C3140000)00            cmp byte [ball3_moving], 0
  1950 0000107B 0F84B8010000                je .end
  1951                                  
  1952                                      ; Incrementar contador de velocidad
  1953 00001081 48FF05(50180000)            inc qword [speed_counter]
  1954                                      
  1955                                      ; Verificar si debemos mover la bola en este ciclo
  1956 00001088 488B05(50180000)            mov rax, [speed_counter]
  1957 0000108F 483B05(40180000)            cmp rax, [ball_speed]
  1958 00001096 0F8C9D010000                jl .end
  1959                                      
  1960                                      ; Resetear contador de velocidad
  1961 0000109C 48C705(50180000)00-         mov qword [speed_counter], 0
  1961 000010A4 000000             
  1962                                  
  1963                                      ; Borrar la posición actual de la bola
  1964 000010A7 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1965 000010AE 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1966 000010B5 4981C0[000A0000]            add r8, board
  1967 000010BC 4C89C9                      mov rcx, r9
  1968 000010BF B850000000                  mov rax, column_cells + 2
  1969 000010C4 48F7E9                      imul rcx
  1970 000010C7 4901C0                      add r8, rax
  1971 000010CA 41C60020                    mov byte [r8], char_space
  1972                                  
  1973                                      ; Calcular siguiente posición X
  1974 000010CE 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1975 000010D5 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1976 000010DC 488B05(B3140000)            mov rax, [ball3_direction_x]
  1977 000010E3 4901C0                      add r8, rax               ; Nueva posición X
  1978                                  
  1979                                      ; Calcular la dirección de memoria para la siguiente posición
  1980 000010E6 4D89C2                      mov r10, r8
  1981 000010E9 4981C2[000A0000]            add r10, board
  1982 000010F0 4C89C9                      mov rcx, r9
  1983 000010F3 B850000000                  mov rax, column_cells + 2
  1984 000010F8 48F7E9                      imul rcx
  1985 000010FB 4901C2                      add r10, rax
  1986                                  
  1987                                      ; Verificar si hay una X en la siguiente posición X
  1988 000010FE 418A02                      mov al, [r10]
  1989 00001101 3C58                        cmp al, 'X'
  1990 00001103 7565                        jne .check_block_x
  1991 00001105 48F71D(B3140000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  1992 0000110C E928010000                  jmp .end
  1993                                  
  1994                                      .move_with_pallet:
  1995                                          ; Borrar la posición actual de la bola
  1996 00001111 4C8B05(A3140000)                mov r8, [ball3_x_pos]
  1997 00001118 4C8B0D(AB140000)                mov r9, [ball3_y_pos]
  1998 0000111F 4D89C2                          mov r10, r8
  1999 00001122 4981C2[000A0000]                add r10, board
  2000 00001129 4C89C9                          mov rcx, r9
  2001 0000112C B850000000                      mov rax, column_cells + 2
  2002 00001131 48F7E9                          imul rcx
  2003 00001134 4901C2                          add r10, rax
  2004 00001137 41C60220                        mov byte [r10], char_space
  2005                                  
  2006                                          ; Actualizar posición X basada en la paleta
  2007 0000113B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2008 00001142 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2009 00001149 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2010 00001150 4C8905(A3140000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2011                                  
  2012                                          ; Mantener la bola una posición arriba de la paleta
  2013 00001157 4C8B0D(AB140000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2014 0000115E 4C890D(AB140000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2015                                  
  2016 00001165 E9CF000000                      jmp .end
  2017                                  
  2018                                  
  2019                                      .check_block_x:
  2020                                          ; Verificar colisión con bloques en X
  2021 0000116A 4150                            push r8     ; Guardar registros que usa check_block_collision
  2022 0000116C 4151                            push r9
  2023 0000116E 4152                            push r10
  2024 00001170 E849070000                      call check_block_collision
  2025 00001175 415A                            pop r10
  2026 00001177 4159                            pop r9
  2027 00001179 4158                            pop r8
  2028 0000117B 4885C0                          test rax, rax
  2029 0000117E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2030 00001180 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2031 00001187 E9AD000000                      jmp .end
  2032                                  
  2033                                      .check_paddle_x:
  2034                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2035 0000118C 41803A3D                        cmp byte [r10], char_equal
  2036 00001190 750C                            jne .check_y_movement
  2037 00001192 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2038 00001199 E99B000000                      jmp .end
  2039                                  
  2040                                      .check_y_movement:
  2041                                          ; Calcular siguiente posición Y
  2042 0000119E 488B05(BB140000)                mov rax, [ball3_direction_y]
  2043 000011A5 4901C1                          add r9, rax                  ; Nueva posición Y
  2044                                  
  2045                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2046 000011A8 4D89C2                          mov r10, r8
  2047 000011AB 4981C2[000A0000]                add r10, board
  2048 000011B2 4C89C9                          mov rcx, r9
  2049 000011B5 B850000000                      mov rax, column_cells + 2
  2050 000011BA 48F7E9                          imul rcx
  2051 000011BD 4901C2                          add r10, rax
  2052                                  
  2053                                          ; Verificar si hay una X en la siguiente posición Y
  2054 000011C0 418A02                          mov al, [r10]
  2055 000011C3 3C58                            cmp al, 'X'
  2056 000011C5 7509                            jne .check_block_y
  2057 000011C7 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2058 000011CE EB69                            jmp .end
  2059                                  
  2060                                      .check_block_y:
  2061                                          ; Verificar colisión con bloques en Y
  2062 000011D0 4150                            push r8     ; Guardar registros que usa check_block_collision
  2063 000011D2 4151                            push r9
  2064 000011D4 4152                            push r10
  2065 000011D6 E8E3060000                      call check_block_collision
  2066 000011DB 415A                            pop r10
  2067 000011DD 4159                            pop r9
  2068 000011DF 4158                            pop r8
  2069 000011E1 4885C0                          test rax, rax
  2070 000011E4 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2071 000011E6 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2072 000011ED EB4A                            jmp .end
  2073                                  
  2074                                      .check_paddle_y:
  2075                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2076 000011EF 41803A3D                        cmp byte [r10], char_equal
  2077 000011F3 7536                            jne .update_position
  2078                                  
  2079                                          ; Verificar si el poder catch está activo
  2080 000011F5 803D(58180000)01                cmp byte [catch_power_active], 1
  2081 000011FC 7524                            jne .normal_bounce
  2082                                  
  2083                                          ; Activar el modo "atrapado"
  2084 000011FE C605(5B180000)01                mov byte [ball_caught_3], 1
  2085                                          
  2086                                          ; Guardar la posición X actual de la bola como offset
  2087 00001205 488B05(A3140000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2088 0000120C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2089 00001213 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2090 00001219 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2091                                          
  2092 00001220 EB17                            jmp .end
  2093                                  
  2094                                      .normal_bounce:
  2095 00001222 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2096 00001229 EB0E                            jmp .end
  2097                                  
  2098                                  
  2099                                      .update_position:
  2100 0000122B 4C8905(A3140000)                mov [ball3_x_pos], r8
  2101 00001232 4C890D(AB140000)                mov [ball3_y_pos], r9
  2102                                  
  2103                                      .end:
  2104 00001239 C3                              ret
  2105                                  
  2106                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2107                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2108                                  process_catch_release:
  2109 0000123A 55                          push rbp
  2110 0000123B 4889E5                      mov  rbp, rsp
  2111                                  
  2112                                      ; Verificar si el poder está activo
  2113 0000123E 803D(58180000)01            cmp byte [catch_power_active], 1
  2114 00001245 0F8586000000                jne .no_catch_power
  2115                                  
  2116                                      ; Verificar si se presionó 'c'
  2117 0000124B 803D(64180000)63            cmp byte [last_key], 'c'
  2118 00001252 757D                        jne .no_catch_power
  2119                                  
  2120                                      ; Ahora revisamos bola 1
  2121 00001254 803D(59180000)01            cmp byte [ball_caught], 1
  2122 0000125B 751F                        jne .check_ball2
  2123                                      ; Suelta la bola 1
  2124 0000125D C605(59180000)00            mov byte [ball_caught], 0
  2125 00001264 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  2125 0000126C 000000             
  2126 0000126F 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  2126 00001277 FFFFFF             
  2127 0000127A EB4E                        jmp .finish
  2128                                  
  2129                                  .check_ball2:
  2130 0000127C 803D(5A180000)01            cmp byte [ball_caught_2], 1
  2131 00001283 751F                        jne .check_ball3
  2132                                      ; Suelta la bola 2
  2133 00001285 C605(5A180000)00            mov byte [ball_caught_2], 0
  2134 0000128C 48C705(91140000)01-         mov qword [ball2_direction_x], 1
  2134 00001294 000000             
  2135 00001297 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  2135 0000129F FFFFFF             
  2136 000012A2 EB26                        jmp .finish
  2137                                  
  2138                                  .check_ball3:
  2139 000012A4 803D(5B180000)01            cmp byte [ball_caught_3], 1
  2140 000012AB 751D                        jne .finish
  2141                                      ; Suelta la bola 3
  2142 000012AD C605(5B180000)00            mov byte [ball_caught_3], 0
  2143 000012B4 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  2143 000012BC 000000             
  2144 000012BF 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  2144 000012C7 FFFFFF             
  2145                                  
  2146                                  .finish:
  2147                                      ; Limpiar la tecla
  2148 000012CA C605(64180000)00            mov byte [last_key], 0
  2149                                  
  2150                                  .no_catch_power:
  2151 000012D1 5D                          pop rbp
  2152 000012D2 C3                          ret
  2153                                  
  2154                                  
  2155                                  
  2156                                  display_level_number:
  2157 000012D3 55                          push rbp
  2158 000012D4 4889E5                      mov rbp, rsp
  2159                                      
  2160                                      ; Limpiar la pantalla primero
  2161                                      print clear, clear_length
    82 000012D7 B801000000          <1>  mov eax, sys_write
    83 000012DC BF01000000          <1>  mov edi, 1
    84 000012E1 48BE-               <1>  mov rsi, %1
    84 000012E3 [1000000000000000]  <1>
    85 000012EB BA07000000          <1>  mov edx, %2
    86 000012F0 0F05                <1>  syscall
  2162                                      
  2163                                      ; Calcular la posición central para el mensaje
  2164                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2165 000012F2 B84E000000                  mov rax, column_cells
  2166 000012F7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2167 000012FB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2168                                      
  2169                                      ; Calcular la fila central
  2170 000012FE BB20000000                  mov rbx, row_cells
  2171 00001303 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2172                                      
  2173                                      ; Calcular el offset en el buffer
  2174 00001306 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2175 0000130B 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2176 0000130E 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2177                                      
  2178                                      ; Escribir "NIVEL " en la posición calculada
  2179 00001311 488DB8[000A0000]            lea rdi, [board + rax]
  2180 00001318 48BE-                       mov rsi, level_msg
  2180 0000131A [2414000000000000] 
  2181 00001322 B906000000                  mov rcx, level_msg_len
  2182 00001327 F3A4                        rep movsb
  2183                                      
  2184                                      ; Escribir el número del nivel
  2185 00001329 8A05(F9140000)              mov al, [current_level]
  2186 0000132F 0430                        add al, '0'                 ; convertir a ASCII
  2187 00001331 8807                        mov [rdi], al
  2188                                      
  2189                                      ; Mostrar el board con el mensaje
  2190                                      print board, board_size
    82 00001333 B801000000          <1>  mov eax, sys_write
    83 00001338 BF01000000          <1>  mov edi, 1
    84 0000133D 48BE-               <1>  mov rsi, %1
    84 0000133F [000A000000000000]  <1>
    85 00001347 BA000A0000          <1>  mov edx, %2
    86 0000134C 0F05                <1>  syscall
  2191                                      
  2192                                      ; Esperar un segundo
  2193 0000134E B823000000                  mov rax, sys_nanosleep
  2194 00001353 48BF-                       mov rdi, level_display_time
  2194 00001355 [2F14000000000000] 
  2195 0000135D 4831F6                      xor rsi, rsi
  2196 00001360 0F05                        syscall
  2197                                      
  2198 00001362 5D                          pop rbp
  2199 00001363 C3                          ret
  2200                                  
  2201                                  ; Función para inicializar un tablero vacío
  2202                                  init_empty_board:
  2203 00001364 56                          push rsi
  2204 00001365 57                          push rdi
  2205 00001366 51                          push rcx
  2206 00001367 50                          push rax
  2207                                  
  2208 00001368 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2209 0000136F 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2210 00001376 B9000A0000                  mov rcx, board_template_size
  2211 0000137B F3A4                        rep movsb                   ; Copiar el tablero
  2212                                  
  2213 0000137D 58                          pop rax
  2214 0000137E 59                          pop rcx
  2215 0000137F 5F                          pop rdi
  2216 00001380 5E                          pop rsi
  2217 00001381 C3                          ret
  2218                                  
  2219                                  
  2220                                  init_level:
  2221                                            ; Asegurarse que las otras bolas están desactivadas
  2222 00001382 C605(A2140000)00            mov byte [ball2_active], 0
  2223 00001389 C605(C4140000)00            mov byte [ball3_active], 0
  2224 00001390 C605(65180000)00            mov byte [laser_power_active], 0
  2225 00001397 E816F4FFFF                  call clear_lasers
  2226 0000139C 488B05(4F140000)            mov rax, [default_pallet_size]
  2227 000013A3 488905(47140000)            mov [pallet_size], rax
  2228 000013AA 48C705(40180000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2228 000013B2 000000             
  2229                                  
  2230                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2231                                          ; Reiniciar letras activas
  2232 000013B5 488D3D(99160000)            lea rdi, [letters_map]
  2233 000013BC B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2234 000013C1 4831C0                      xor rax, rax
  2235 000013C4 F3AA                        rep stosb                    ; Llenar con ceros
  2236                                      
  2237                                      ; Inicializar dirección de la bola (derecha y arriba)
  2238 000013C6 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2238 000013CE 000000             
  2239 000013D1 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2239 000013D9 FFFFFF             
  2240                                  
  2241                                  
  2242                                      ; Reiniciar contador de letras activas
  2243 000013DC 4831C0                      xor rax, rax
  2244 000013DF 8805(29180000)              mov [letters_count], al
  2245                                  
  2246                                      ; Reiniciar última letra capturada
  2247 000013E5 C605(2A180000)20            mov byte [last_letter], ' '
  2248 000013EC C605(A3150000)00            mov byte [destroyed_blocks], 0 
  2249 000013F3 E86CFFFFFF                  call init_empty_board
  2250 000013F8 E8D6FEFFFF                  call display_level_number
  2251 000013FD E8E5050000                  call init_enemies
  2252                                      
  2253 00001402 56                          push rsi
  2254 00001403 57                          push rdi
  2255 00001404 51                          push rcx
  2256 00001405 50                          push rax
  2257                                  
  2258 00001406 488D35(00000000)            lea rsi, [board_template]
  2259 0000140D 488D3D(000A0000)            lea rdi, [board]
  2260 00001414 B9000A0000                  mov rcx, board_template_size
  2261 00001419 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2262                                  
  2263 0000141B 58                          pop rax
  2264 0000141C 59                          pop rcx
  2265 0000141D 5F                          pop rdi
  2266 0000141E 5E                          pop rsi
  2267                                  
  2268 0000141F B90A000000                  mov rcx, 10
  2269 00001424 4831C0                      xor rax, rax
  2270 00001427 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2271 0000142E F3AA                        rep stosb      
  2272                                  
  2273                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2274 00001430 803D(F9140000)01            cmp byte [current_level], 1
  2275 00001437 7431                        je .level1
  2276 00001439 803D(F9140000)02            cmp byte [current_level], 2
  2277 00001440 7454                        je .level2
  2278 00001442 803D(F9140000)03            cmp byte [current_level], 3
  2279 00001449 7477                        je .level3
  2280 0000144B 803D(F9140000)04            cmp byte [current_level], 4
  2281 00001452 0F8492000000                je .level4
  2282 00001458 803D(F9140000)05            cmp byte [current_level], 5
  2283 0000145F 0F84AD000000                je .level5
  2284 00001465 E9D0000000                  jmp .done
  2285                                  
  2286                                  
  2287                                  
  2288                                      .level1:
  2289 0000146A C605(FA140000)08                mov byte [blocks_remaining], level1_blocks_count
  2290 00001471 4831C9                          xor rcx, rcx             
  2291                                          .init_loop1:
  2292 00001474 4883F908                            cmp rcx, level1_blocks_count
  2293 00001478 0F8DBC000000                        jge .done
  2294 0000147E 4889C8                              mov rax, rcx         
  2295 00001481 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2296 00001485 8A90[FE140000]                      mov dl, byte [level1_blocks + rax + 3]  
  2297 0000148B 8891[37150000]                      mov byte [block_states + rcx], dl
  2298 00001491 48FFC1                              inc rcx
  2299 00001494 EBDE                                jmp .init_loop1
  2300                                  
  2301                                      .level2:
  2302 00001496 C605(FA140000)01                mov byte [blocks_remaining], level2_blocks_count
  2303 0000149D 4831C9                          xor rcx, rcx             
  2304                                          .init_loop2:
  2305 000014A0 4883F901                            cmp rcx, level2_blocks_count
  2306 000014A4 0F8D90000000                        jge .done
  2307 000014AA 4889C8                              mov rax, rcx         
  2308 000014AD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2309 000014B1 8A90[26150000]                      mov dl, byte [level2_blocks + rax + 3]  
  2310 000014B7 8891[37150000]                      mov byte [block_states + rcx], dl
  2311 000014BD 48FFC1                              inc rcx
  2312 000014C0 EBDE                                jmp .init_loop2
  2313                                      .level3:
  2314 000014C2 C605(FA140000)01                mov byte [blocks_remaining], level3_blocks_count
  2315 000014C9 4831C9                          xor rcx, rcx             
  2316                                          .init_loop3:
  2317 000014CC 4883F901                            cmp rcx, level3_blocks_count
  2318 000014D0 7D68                                jge .done
  2319 000014D2 4889C8                              mov rax, rcx         
  2320 000014D5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2321 000014D9 8A90[2B150000]                      mov dl, byte [level3_blocks + rax + 3]  
  2322 000014DF 8891[37150000]                      mov byte [block_states + rcx], dl
  2323 000014E5 48FFC1                              inc rcx
  2324 000014E8 EBE2                                jmp .init_loop3
  2325                                  
  2326                                      .level4:
  2327 000014EA C605(FA140000)01                mov byte [blocks_remaining], level4_blocks_count
  2328 000014F1 4831C9                          xor rcx, rcx             
  2329                                          .init_loop4:
  2330 000014F4 4883F901                            cmp rcx, level4_blocks_count
  2331 000014F8 7D40                                jge .done
  2332 000014FA 4889C8                              mov rax, rcx         
  2333 000014FD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2334 00001501 8A90[30150000]                      mov dl, byte [level4_blocks + rax + 3]  
  2335 00001507 8891[37150000]                      mov byte [block_states + rcx], dl
  2336 0000150D 48FFC1                              inc rcx
  2337 00001510 EBE2                                jmp .init_loop4
  2338                                  
  2339                                      .level5:
  2340 00001512 C605(FA140000)01                mov byte [blocks_remaining], level5_blocks_count
  2341 00001519 4831C9                          xor rcx, rcx             
  2342                                          .init_loop5:
  2343 0000151C 4883F901                            cmp rcx, level5_blocks_count
  2344 00001520 7D18                                jge .done
  2345 00001522 4889C8                              mov rax, rcx         
  2346 00001525 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2347 00001529 8A90[35150000]                      mov dl, byte [level5_blocks + rax + 3]  
  2348 0000152F 8891[37150000]                      mov byte [block_states + rcx], dl
  2349 00001535 48FFC1                              inc rcx
  2350 00001538 EBE2                                jmp .init_loop5
  2351                                      .done:
  2352 0000153A C3                              ret
  2353                                  
  2354                                  
  2355                                  ; Función para verificar y manejar la transición de nivel
  2356                                  check_level_complete:
  2357                                      ; Verificar si quedan bloques
  2358 0000153B 803D(FA140000)00            cmp byte [blocks_remaining], 0
  2359 00001542 753C                        jne .not_complete
  2360                                      
  2361                                      ; Incrementar el nivel
  2362 00001544 FE05(F9140000)              inc byte [current_level]
  2363                                      
  2364                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2365 0000154A 803D(F9140000)06            cmp byte [current_level], 6
  2366 00001551 742E                        je game_win
  2367                                      
  2368                                      ; Reinicializar el juego para el siguiente nivel
  2369 00001553 E82AFEFFFF                  call init_level
  2370                                      
  2371                                      ; Reinicializar la posición de la bola y la paleta
  2372 00001558 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  2372 00001560 000000             
  2373 00001563 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  2373 0000156B 000000             
  2374 0000156E C605(7F140000)00            mov byte [ball_moving], 0
  2375 00001575 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2375 0000157C [36130000]         
  2376                                      
  2377                                      .not_complete:
  2378 00001580 C3                              ret
  2379                                  
  2380                                      ; Nueva función para manejar la victoria del juego
  2381                                  game_win:
  2382                                      ; Limpiar la pantalla primero
  2383                                      print clear, clear_length
    82 00001581 B801000000          <1>  mov eax, sys_write
    83 00001586 BF01000000          <1>  mov edi, 1
    84 0000158B 48BE-               <1>  mov rsi, %1
    84 0000158D [1000000000000000]  <1>
    85 00001595 BA07000000          <1>  mov edx, %2
    86 0000159A 0F05                <1>  syscall
  2384                                      
  2385                                      ; Mensaje de victoria
  2386 0000159C 488B05(9B150000)            mov rax, [current_score]    ; Obtener el puntaje final
  2387 000015A3 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2387 000015A5 [A415000000000000] 
  2388 000015AD E8B4010000                  call number_to_string
  2389                                      
  2390                                      ; Definir mensaje de victoria
  2391                                      section .data
  2392 000019AC C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2392 000019B5 616465732120C2A148-
  2392 000019BE 61732067616E61646F-
  2392 000019C7 210A0D             
  2393                                          win_msg_len: equ $ - win_msg
  2394 000019CA 50756E74616A652066-             score_msg: db "Puntaje final: "
  2394 000019D3 696E616C3A20       
  2395                                          score_msg_len: equ $ - score_msg
  2396                                      section .text
  2397                                      
  2398                                      ; Imprimir mensajes
  2399                                      print win_msg, win_msg_len
    82 000015B2 B801000000          <1>  mov eax, sys_write
    83 000015B7 BF01000000          <1>  mov edi, 1
    84 000015BC 48BE-               <1>  mov rsi, %1
    84 000015BE [AC19000000000000]  <1>
    85 000015C6 BA1E000000          <1>  mov edx, %2
    86 000015CB 0F05                <1>  syscall
  2400                                      print score_msg, score_msg_len
    82 000015CD B801000000          <1>  mov eax, sys_write
    83 000015D2 BF01000000          <1>  mov edi, 1
    84 000015D7 48BE-               <1>  mov rsi, %1
    84 000015D9 [CA19000000000000]  <1>
    85 000015E1 BA0F000000          <1>  mov edx, %2
    86 000015E6 0F05                <1>  syscall
  2401                                      print number_buffer, 20
    82 000015E8 B801000000          <1>  mov eax, sys_write
    83 000015ED BF01000000          <1>  mov edi, 1
    84 000015F2 48BE-               <1>  mov rsi, %1
    84 000015F4 [A415000000000000]  <1>
    85 000015FC BA14000000          <1>  mov edx, %2
    86 00001601 0F05                <1>  syscall
  2402                                      
  2403                                      ; Esperar un momento antes de salir
  2404 00001603 48C705F2E9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2404 0000160C 0000               
  2405 0000160E 48C705EFE9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2405 00001617 0000               
  2406                                      sleeptime
    98 00001619 B823000000          <1>  mov eax, sys_nanosleep
    99 0000161E 48BF-               <1>  mov rdi, timespec
    99 00001620 [0000000000000000]  <1>
   100 00001628 31F6                <1>  xor esi, esi
   101 0000162A 0F05                <1>  syscall
  2407                                      
  2408 0000162C E976090000                  jmp exit
  2409                                  
  2410                                  ; Función para imprimir los bloques
  2411                                  ; Función modificada para imprimir bloques
  2412                                  
  2413                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2414                                  get_current_level_blocks:
  2415 00001631 803D(F9140000)01            cmp byte [current_level], 1
  2416 00001638 7428                        je .level1
  2417 0000163A 803D(F9140000)02            cmp byte [current_level], 2
  2418 00001641 7427                        je .level2
  2419 00001643 803D(F9140000)03            cmp byte [current_level], 3
  2420 0000164A 7426                        je .level3
  2421 0000164C 803D(F9140000)04            cmp byte [current_level], 4
  2422 00001653 7425                        je .level4
  2423 00001655 803D(F9140000)05            cmp byte [current_level], 5
  2424 0000165C 7424                        je .level5
  2425                                      ; Si llegamos aquí, hay un error en el nivel
  2426 0000165E 4831C0                      xor rax, rax
  2427 00001661 C3                          ret
  2428                                  
  2429                                      .level1:
  2430 00001662 488D05(FB140000)                lea rax, [level1_blocks]
  2431 00001669 C3                              ret
  2432                                      .level2:
  2433 0000166A 488D05(23150000)                lea rax, [level2_blocks]
  2434 00001671 C3                              ret
  2435                                      .level3:
  2436 00001672 488D05(28150000)                lea rax, [level3_blocks]
  2437 00001679 C3                              ret
  2438                                      .level4:
  2439 0000167A 488D05(2D150000)                lea rax, [level4_blocks]
  2440 00001681 C3                              ret
  2441                                      .level5:
  2442 00001682 488D05(32150000)                lea rax, [level5_blocks]
  2443 00001689 C3                              ret
  2444                                  ; Función para obtener la cantidad de bloques del nivel actual
  2445                                  get_current_level_count:
  2446 0000168A 803D(F9140000)01            cmp byte [current_level], 1
  2447 00001691 7428                        je .level1
  2448 00001693 803D(F9140000)02            cmp byte [current_level], 2
  2449 0000169A 7425                        je .level2
  2450 0000169C 803D(F9140000)03            cmp byte [current_level], 3
  2451 000016A3 7422                        je .level3
  2452 000016A5 803D(F9140000)04            cmp byte [current_level], 4
  2453 000016AC 741F                        je .level4
  2454 000016AE 803D(F9140000)05            cmp byte [current_level], 5
  2455 000016B5 741C                        je .level5
  2456                                      ; Si llegamos aquí, hay un error en el nivel
  2457 000016B7 4831C0                      xor rax, rax
  2458 000016BA C3                          ret
  2459                                  
  2460                                      .level1:
  2461 000016BB B808000000                      mov rax, level1_blocks_count
  2462 000016C0 C3                              ret
  2463                                      .level2:
  2464 000016C1 B801000000                      mov rax, level2_blocks_count
  2465 000016C6 C3                              ret
  2466                                      .level3:
  2467 000016C7 B801000000                      mov rax, level3_blocks_count
  2468 000016CC C3                              ret
  2469                                      .level4:
  2470 000016CD B801000000                      mov rax, level4_blocks_count
  2471 000016D2 C3                              ret
  2472                                      .level5:
  2473 000016D3 B801000000                      mov rax, level5_blocks_count
  2474 000016D8 C3                              ret
  2475                                  
  2476                                  
  2477                                  print_blocks:
  2478 000016D9 55                          push rbp
  2479 000016DA 4889E5                      mov rbp, rsp
  2480                                      
  2481                                      ; Obtener puntero a los bloques del nivel actual
  2482 000016DD E84FFFFFFF                  call get_current_level_blocks
  2483 000016E2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2484                                      
  2485                                      ; Obtener cantidad de bloques del nivel actual
  2486 000016E5 E8A0FFFFFF                  call get_current_level_count
  2487 000016EA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2488                                      
  2489 000016ED 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2490                                      
  2491                                      .print_loop:
  2492 000016F0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2493 000016F3 7D6F                            jge .end
  2494                                          
  2495                                          ; Verificar si el bloque está activo
  2496 000016F5 490FB68424-                     movzx rax, byte [block_states + r12]
  2496 000016FA [37150000]         
  2497 000016FE 4885C0                          test rax, rax
  2498 00001701 745C                            jz .next_block
  2499                                          
  2500                                          ; Obtener posición y tipo del bloque usando r13
  2501 00001703 4C89E0                          mov rax, r12
  2502 00001706 486BC005                        imul rax, 5
  2503 0000170A 4C01E8                          add rax, r13
  2504 0000170D 448A00                          mov r8b, [rax]        ; X position
  2505 00001710 448A4801                        mov r9b, [rax + 1]    ; Y position
  2506 00001714 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2507                                  
  2508                                          ; El resto de la lógica de impresión permanece igual
  2509 00001718 4D0FB6C0                        movzx r8, r8b
  2510 0000171C 4D0FB6C9                        movzx r9, r9b
  2511 00001720 4981C0[000A0000]                add r8, board
  2512 00001727 B850000000                      mov rax, column_cells + 2
  2513 0000172C 49F7E1                          mul r9
  2514 0000172F 4901C0                          add r8, rax
  2515                                          
  2516 00001732 B906000000                      mov rcx, block_length
  2517 00001737 48BE-                           mov rsi, block_type_1
  2517 00001739 [D514000000000000] 
  2518 00001741 490FB6C2                        movzx rax, r10b
  2519 00001745 48FFC8                          dec rax
  2520 00001748 486BC006                        imul rax, block_length
  2521 0000174C 4801C6                          add rsi, rax
  2522                                          
  2523                                      .print_block_chars:
  2524 0000174F 8A06                            mov al, [rsi]
  2525 00001751 418800                          mov [r8], al
  2526 00001754 48FFC6                          inc rsi
  2527 00001757 49FFC0                          inc r8
  2528 0000175A 48FFC9                          dec rcx
  2529 0000175D 75F0                            jnz .print_block_chars
  2530                                          
  2531                                      .next_block:
  2532 0000175F 49FFC4                          inc r12
  2533 00001762 EB8C                            jmp .print_loop
  2534                                          
  2535                                      .end:
  2536 00001764 5D                              pop rbp
  2537 00001765 C3                              ret
  2538                                  
  2539                                  ; Función para convertir número a string
  2540                                  ; Input: RAX = número a convertir
  2541                                  ; RDI = buffer donde escribir el string
  2542                                  number_to_string:
  2543 00001766 53                          push rbx
  2544 00001767 52                          push rdx
  2545 00001768 56                          push rsi
  2546 00001769 BB0A000000                  mov rbx, 10          ; Divisor
  2547 0000176E B900000000                  mov rcx, 0          ; Contador de dígitos
  2548                                      
  2549                                      ; Si el número es 0, manejarlo especialmente
  2550 00001773 4885C0                      test rax, rax
  2551 00001776 7509                        jnz .convert_loop
  2552 00001778 C60730                      mov byte [rdi], '0'
  2553 0000177B C6470100                    mov byte [rdi + 1], 0
  2554 0000177F EB20                        jmp .end
  2555                                      
  2556                                      .convert_loop:
  2557 00001781 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2558 00001784 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2559 00001787 80C230                          add dl, '0'     ; Convertir a ASCII
  2560 0000178A 52                              push rdx        ; Guardar el dígito
  2561 0000178B 48FFC1                          inc rcx         ; Incrementar contador
  2562 0000178E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2563 00001791 75EE                            jnz .convert_loop
  2564                                          
  2565                                      .write_loop:
  2566 00001793 5A                              pop rdx         ; Obtener dígito
  2567 00001794 8817                            mov [rdi], dl   ; Escribir al buffer
  2568 00001796 48FFC7                          inc rdi         ; Siguiente posición
  2569 00001799 48FFC9                          dec rcx         ; Decrementar contador
  2570 0000179C 75F5                            jnz .write_loop
  2571                                          
  2572 0000179E C60700                      mov byte [rdi], 0   ; Null terminator
  2573                                      
  2574                                      .end:
  2575 000017A1 5E                          pop rsi
  2576 000017A2 5A                          pop rdx
  2577 000017A3 5B                          pop rbx
  2578 000017A4 C3                          ret
  2579                                  
  2580                                  ; Función para imprimir los labels
  2581                                  print_labels:
  2582 000017A5 55                          push rbp
  2583 000017A6 4889E5                      mov rbp, rsp
  2584                                  
  2585                                      ; Crear buffer temporal
  2586 000017A9 4883EC20                    sub rsp, 32
  2587                                  
  2588                                      ; Copiar labels a buffer temporal
  2589 000017AD 4889E7                      mov rdi, rsp
  2590 000017B0 488D35(50160000)            lea rsi, [score_label]
  2591 000017B7 B917000000                  mov rcx, score_label_len
  2592 000017BC F3A4                        rep movsb
  2593                                  
  2594                                      ; Convertir score a string
  2595 000017BE 488B05(9B150000)            mov rax, [current_score]
  2596 000017C5 48BF-                       mov rdi, number_buffer
  2596 000017C7 [A415000000000000] 
  2597 000017CF E892FFFFFF                  call number_to_string
  2598                                  
  2599                                      ; Calcular longitud del número
  2600 000017D4 B900000000                  mov rcx, 0
  2601 000017D9 48BF-                       mov rdi, number_buffer
  2601 000017DB [A415000000000000] 
  2602                                      .count_loop:
  2603 000017E3 803C0F00                        cmp byte [rdi + rcx], 0
  2604 000017E7 7405                            je .count_done
  2605 000017E9 48FFC1                          inc rcx
  2606 000017EC EBF5                            jmp .count_loop
  2607                                      .count_done:
  2608                                  
  2609                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2610 000017EE 4889E7                      mov rdi, rsp
  2611 000017F1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2612 000017F5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2613 000017FA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2614                                      .pad_loop:
  2615 000017FD 4885F6                          test rsi, rsi
  2616 00001800 740B                            jz .pad_done
  2617 00001802 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2618 00001805 48FFC7                          inc rdi
  2619 00001808 48FFCE                          dec rsi
  2620 0000180B EBF0                            jmp .pad_loop
  2621                                      .pad_done:
  2622                                  
  2623                                      ; Copiar el número
  2624 0000180D 48BE-                       mov rsi, number_buffer
  2624 0000180F [A415000000000000] 
  2625 00001817 F3A4                        rep movsb
  2626                                  
  2627                                      ; Imprimir el buffer completo
  2628                                      print rsp, score_label_len
    82 00001819 B801000000          <1>  mov eax, sys_write
    83 0000181E BF01000000          <1>  mov edi, 1
    84 00001823 4889E6              <1>  mov rsi, %1
    85 00001826 BA17000000          <1>  mov edx, %2
    86 0000182B 0F05                <1>  syscall
  2629                                  
  2630                                      ; Repetir proceso para bloques destruidos
  2631 0000182D 4889E7                      mov rdi, rsp
  2632 00001830 488D35(67160000)            lea rsi, [blocks_label]
  2633 00001837 B91B000000                  mov rcx, blocks_label_len
  2634 0000183C F3A4                        rep movsb
  2635                                  
  2636                                      ; Verificar que el `[` esté en su posición correcta
  2637 0000183E 4889E7                      mov rdi, rsp
  2638 00001841 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2639 00001845 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2640                                  
  2641                                      ; Convertir bloques destruidos a string
  2642 00001848 480FB605(A3150000)          movzx rax, byte [destroyed_blocks]
  2643 00001850 48BF-                       mov rdi, number_buffer
  2643 00001852 [A415000000000000] 
  2644 0000185A E807FFFFFF                  call number_to_string
  2645                                  
  2646                                      ; Calcular longitud del número
  2647 0000185F B900000000                  mov rcx, 0
  2648 00001864 48BF-                       mov rdi, number_buffer
  2648 00001866 [A415000000000000] 
  2649                                      .count_loop2:
  2650 0000186E 803C0F00                        cmp byte [rdi + rcx], 0
  2651 00001872 7405                            je .count_done2
  2652 00001874 48FFC1                          inc rcx
  2653 00001877 EBF5                            jmp .count_loop2
  2654                                      .count_done2:
  2655                                  
  2656                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2657 00001879 4889E7                      mov rdi, rsp
  2658 0000187C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2659 00001880 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2660 00001885 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2661                                      .pad_loop2:
  2662 00001888 4885F6                          test rsi, rsi
  2663 0000188B 740B                            jz .pad_done2
  2664 0000188D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2665 00001890 48FFC7                          inc rdi
  2666 00001893 48FFCE                          dec rsi
  2667 00001896 EBF0                            jmp .pad_loop2
  2668                                      .pad_done2:
  2669                                  
  2670                                      ; Copiar el número
  2671 00001898 48BE-                       mov rsi, number_buffer
  2671 0000189A [A415000000000000] 
  2672 000018A2 F3A4                        rep movsb
  2673                                  
  2674                                      ; Imprimir el buffer completo
  2675                                      print rsp, blocks_label_len
    82 000018A4 B801000000          <1>  mov eax, sys_write
    83 000018A9 BF01000000          <1>  mov edi, 1
    84 000018AE 4889E6              <1>  mov rsi, %1
    85 000018B1 BA1B000000          <1>  mov edx, %2
    86 000018B6 0F05                <1>  syscall
  2676                                  
  2677                                      ; Restaurar stack
  2678 000018B8 4883C420                    add rsp, 32
  2679 000018BC 5D                          pop rbp
  2680 000018BD C3                          ret
  2681                                  
  2682                                  
  2683                                  
  2684                                  check_block_collision:
  2685 000018BE 55                          push rbp
  2686 000018BF 4889E5                      mov rbp, rsp
  2687                                  
  2688                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2689 000018C2 418A02                      mov al, [r10]
  2690                                  
  2691                                      ; Verificar si el carácter es un bloque
  2692 000018C5 3C55                        cmp al, 'U'  
  2693 000018C7 7419                        je .possible
  2694 000018C9 3C4F                        cmp al, 'O'  
  2695 000018CB 7415                        je .possible
  2696 000018CD 3C44                        cmp al, 'D'  
  2697 000018CF 7411                        je .possible
  2698 000018D1 3C4C                        cmp al, 'L'  
  2699 000018D3 740D                        je .possible
  2700 000018D5 3C56                        cmp al, 'V'  
  2701 000018D7 7409                        je .possible
  2702 000018D9 3C38                        cmp al, '8'  
  2703 000018DB 7405                        je .possible
  2704                                  
  2705                                      ; No es bloque, salir
  2706 000018DD 4831C0                      xor rax, rax
  2707 000018E0 5D                          pop rbp
  2708 000018E1 C3                          ret
  2709                                  
  2710                                  .possible:
  2711 000018E2 53                          push rbx
  2712 000018E3 57                          push rdi
  2713 000018E4 56                          push rsi
  2714 000018E5 4154                        push r12
  2715 000018E7 4155                        push r13
  2716 000018E9 4156                        push r14
  2717 000018EB 4157                        push r15
  2718                                  
  2719                                      ; 1) Obtener base de los bloques del nivel actual
  2720 000018ED E83FFDFFFF                  call get_current_level_blocks
  2721 000018F2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2722                                  
  2723                                      ; 2) Obtener la cantidad de bloques
  2724 000018F5 E890FDFFFF                  call get_current_level_count
  2725 000018FA 4989C6                      mov r14, rax
  2726                                  
  2727 000018FD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2728                                  
  2729                                  .find_block_loop:
  2730 00001900 4D39F4                      cmp r12, r14
  2731 00001903 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2732                                  
  2733                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2734 00001909 4C89E0                      mov rax, r12
  2735 0000190C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2736 00001910 4C01E8                      add rax, r13
  2737 00001913 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2738                                  
  2739                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2740 00001916 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2740 0000191B [37150000]         
  2741 0000191F 4885DB                      test rbx, rbx
  2742 00001922 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2743                                  
  2744                                      ; Obtener coordenadas
  2745 00001928 418A17                      mov dl, [r15]         ; x
  2746 0000192B 418A4F01                    mov cl, [r15 + 1]     ; y
  2747                                  
  2748                                      ; Calcular posición en el board
  2749 0000192F 488D3D(000A0000)            lea rdi, [board]
  2750 00001936 4831C0                      xor rax, rax
  2751 00001939 B84E000000                  mov rax, column_cells
  2752 0000193E 4883C002                    add rax, 2
  2753 00001942 480FB6C9                    movzx rcx, cl         ; y
  2754 00001946 480FAFC1                    imul rax, rcx
  2755 0000194A 4801C7                      add rdi, rax
  2756 0000194D 480FB6C2                    movzx rax, dl         ; x
  2757 00001951 4801C7                      add rdi, rax
  2758                                  
  2759                                      ; Guardar la posición base del bloque
  2760 00001954 57                          push rdi
  2761                                  
  2762                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2763 00001955 4939FA                      cmp r10, rdi
  2764 00001958 7274                        jb .skip_collision
  2765 0000195A 488D5F06                    lea rbx, [rdi + block_length]
  2766 0000195E 4939DA                      cmp r10, rbx
  2767 00001961 736B                        jae .skip_collision
  2768                                  
  2769                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2770 00001963 41FE8C24[37150000]          dec byte [block_states + r12]
  2771                                      ; Volver a cargar durabilidad
  2772 0000196B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2772 00001970 [37150000]         
  2773 00001974 4885DB                      test rbx, rbx
  2774 00001977 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2775                                  
  2776                                      ; >>> Llegó a 0 => Bloque destruido
  2777 00001979 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2778 0000197A B906000000                  mov rcx, block_length
  2779                                  .clear_loop:
  2780 0000197F C60720                      mov byte [rdi], ' '
  2781 00001982 48FFC7                      inc rdi
  2782 00001985 E2F8                        loop .clear_loop
  2783                                  
  2784                                      ; Dibujar letra del bloque destruido
  2785 00001987 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2786 0000198B 4883EF06                    sub rdi, block_length
  2787 0000198F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2788                                      ; Después de escribir la letra en el tablero
  2789 00001991 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2790 00001995 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2791 00001999 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2792 0000199E E8C6EAFFFF                  call register_letter
  2793                                      ; Actualizar contadores globales
  2794 000019A3 FE0D(FA140000)              dec byte [blocks_remaining]
  2795 000019A9 FE05(A3150000)              inc byte [destroyed_blocks]
  2796                                  
  2797                                      ; Sumar puntos según el tipo
  2798 000019AF 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2799 000019B4 486BC00A                    imul rax, 10
  2800 000019B8 480105(9B150000)            add [current_score], rax
  2801                                  
  2802 000019BF B801000000                  mov rax, 1  ; colisión con destrucción
  2803 000019C4 EB14                        jmp .end_pop
  2804                                  
  2805                                  .update_display:
  2806                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2807 000019C6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2808 000019CB 5F                          pop rdi     ; pop que quedó pendiente
  2809 000019CC EB0C                        jmp .end_pop
  2810                                  
  2811                                  .skip_collision:
  2812 000019CE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2813                                  .next_block:
  2814 000019CF 49FFC4                      inc r12
  2815 000019D2 E929FFFFFF                  jmp .find_block_loop
  2816                                  
  2817                                  .no_block_found:
  2818 000019D7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2819                                  
  2820                                  .end_pop:
  2821 000019DA 415F                        pop r15
  2822 000019DC 415E                        pop r14
  2823 000019DE 415D                        pop r13
  2824 000019E0 415C                        pop r12
  2825 000019E2 5E                          pop rsi
  2826 000019E3 5F                          pop rdi
  2827 000019E4 5B                          pop rbx
  2828 000019E5 5D                          pop rbp
  2829 000019E6 C3                          ret
  2830                                  
  2831                                  
  2832                                  
  2833                                  init_enemies:
  2834 000019E7 55                          push rbp
  2835 000019E8 4889E5                      mov rbp, rsp
  2836                                      ; Reiniciar contadores de movimiento
  2837 000019EB C605(E6150000)00            mov byte [enemy_move_total], 0
  2838 000019F2 C605(E7150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2839                                      ; Limpiar estado previo de enemigos
  2840 000019F9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2841 000019FE 488D3D(BD150000)            lea rdi, [enemies]
  2842 00001A05 30C0                        xor al, al
  2843 00001A07 F3AA                        rep stosb ; Limpiar datos de enemigos
  2844                                      
  2845                                      ; Marcar todos los enemigos como inactivos
  2846 00001A09 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2847 00001A10 30C0                        xor al, al
  2848 00001A12 B90A000000                  mov rcx, 10
  2849 00001A17 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2850                                  
  2851 00001A19 5D                          pop rbp
  2852 00001A1A C3                          ret
  2853                                  
  2854                                  
  2855                                  ; Función para mover enemigos
  2856                                  move_enemies:
  2857 00001A1B 55                          push rbp
  2858 00001A1C 4889E5                      mov rbp, rsp
  2859                                      
  2860                                      ; Incrementar contador de movimiento
  2861 00001A1F FE05(E4150000)              inc byte [enemy_move_counter]
  2862 00001A25 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2863 00001A2D 3A05(E5150000)              cmp al, [enemy_move_delay]
  2864 00001A33 0F85AA010000                jne .end
  2865                                      
  2866                                      ; Resetear contador
  2867 00001A39 C605(E4150000)00            mov byte [enemy_move_counter], 0
  2868                                      
  2869 00001A40 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2870                                      
  2871                                      .enemy_loop:
  2872 00001A43 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2873 00001A47 0F8D96010000                    jge .end
  2874                                          
  2875                                          ; Calcular offset del enemigo actual
  2876 00001A4D 4C89E0                          mov rax, r12
  2877 00001A50 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2878 00001A54 488DB0[BD150000]                lea rsi, [enemies + rax]
  2879                                          
  2880                                          ; Verificar si el enemigo está activo
  2881 00001A5B 807E0201                        cmp byte [rsi + 2], 1
  2882 00001A5F 0F8576010000                    jne .next_enemy
  2883                                          
  2884                                          ; Obtener posición actual
  2885 00001A65 4C0FB606                        movzx r8, byte [rsi]            ; X
  2886 00001A69 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2887                                          
  2888                                          ; Limpiar posición actual antes de mover
  2889 00001A6E 4150                            push r8
  2890 00001A70 4151                            push r9
  2891 00001A72 B84E000000                      mov rax, column_cells
  2892 00001A77 4883C002                        add rax, 2
  2893 00001A7B 49F7E1                          mul r9
  2894 00001A7E 4C01C0                          add rax, r8
  2895 00001A81 488DB8[000A0000]                lea rdi, [board + rax]
  2896 00001A88 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2897 00001A8B 4159                            pop r9
  2898 00001A8D 4158                            pop r8
  2899                                  
  2900                                          ; Determinar comportamiento basado en índice
  2901 00001A8F 4C89E0                          mov rax, r12
  2902 00001A92 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2903 00001A96 4885C0                          test rax, rax
  2904 00001A99 7402                            jz .chase_ball
  2905 00001A9B EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2906                                          
  2907                                          ; Perseguir bola (comportamiento original)
  2908                                      .chase_ball:
  2909 00001A9D 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2910 00001AA4 4D39D0                          cmp r8, r10
  2911 00001AA7 0F8F96000000                    jg .move_left
  2912 00001AAD 0F8C95000000                    jl .move_right
  2913                                          
  2914 00001AB3 4C8B15(67140000)                mov r10, [ball_y_pos]
  2915 00001ABA 4D39D1                          cmp r9, r10
  2916 00001ABD 0F8F8A000000                    jg .move_up
  2917 00001AC3 0F8C89000000                    jl .move_down
  2918 00001AC9 E9A5000000                      jmp .check_collision
  2919                                          
  2920                                      .chase_paddle:
  2921                                          ; Obtener la posición X actual de la paleta
  2922 00001ACE 4C8B15(3F140000)                mov r10, [pallet_position]
  2923 00001AD5 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2924                                          
  2925                                          ; Calcular la posición X real de la paleta
  2926 00001ADC 4C89D0                          mov rax, r10
  2927 00001ADF BB4E000000                      mov rbx, column_cells
  2928 00001AE4 4883C302                        add rbx, 2                  ; Añadir newline chars
  2929 00001AE8 4831D2                          xor rdx, rdx
  2930 00001AEB 48F7F3                          div rbx                     ; rax = y, rdx = x
  2931                                          
  2932                                          ; rdx ahora contiene la posición X de la paleta
  2933                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2934 00001AEE 488B0D(47140000)                mov rcx, [pallet_size]
  2935 00001AF5 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2936 00001AF8 4801CA                          add rdx, rcx
  2937                                          
  2938                                          ; Comparar con posición X del enemigo y mover gradualmente
  2939 00001AFB 4939D0                          cmp r8, rdx
  2940 00001AFE 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2941 00001B00 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2942 00001B02 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2943                                  
  2944                                      .check_y_paddle:
  2945                                          ; La Y de la paleta siempre es row_cells - 2
  2946 00001B04 41BA20000000                    mov r10, row_cells
  2947 00001B0A 4983EA02                        sub r10, 2
  2948                                          
  2949                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2950 00001B0E 4D39D1                          cmp r9, r10
  2951 00001B11 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2952 00001B13 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2953 00001B15 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2954                                          
  2955                                      .no_movement:
  2956 00001B17 EB5A                            jmp .check_collision
  2957                                  
  2958                                      ; También agregar una nueva sección para el movimiento suave
  2959                                      .smooth_transition:
  2960                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2961 00001B19 8A05(E7150000)                  mov al, [enemy_target]
  2962 00001B1F 84C0                            test al, al
  2963 00001B21 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2964                                          
  2965                                          ; Verificar distancia en X
  2966 00001B23 4989D2                          mov r10, rdx              ; Posición X objetivo
  2967 00001B26 4D29C2                          sub r10, r8               ; Calcular diferencia
  2968 00001B29 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2969 00001B2D 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2970 00001B2F 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2971 00001B33 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2972 00001B35 EB3C                            jmp .check_collision
  2973                                          
  2974                                      .limit_right_movement:
  2975 00001B37 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2976 00001B3B EB36                            jmp .check_collision
  2977                                          
  2978                                      .limit_left_movement:
  2979 00001B3D 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2980 00001B41 EB30                            jmp .check_collision
  2981                                      .move_left:
  2982 00001B43 49FFC8                          dec r8
  2983 00001B46 EB0F                            jmp .check_vertical
  2984                                          
  2985                                      .move_right:
  2986 00001B48 49FFC0                          inc r8
  2987 00001B4B EB0A                            jmp .check_vertical
  2988                                          
  2989                                      .move_up:
  2990 00001B4D 49FFC9                          dec r9
  2991 00001B50 EB21                            jmp .check_collision
  2992                                          
  2993                                      .move_down:
  2994 00001B52 49FFC1                          inc r9
  2995 00001B55 EB1C                            jmp .check_collision
  2996                                          
  2997                                      .check_vertical:
  2998 00001B57 8A05(E7150000)                  mov al, [enemy_target]
  2999 00001B5D 84C0                            test al, al
  3000 00001B5F 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  3001 00001B65 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  3002 00001B6C 4D39D1                          cmp r9, r10
  3003 00001B6F 7FDC                            jg .move_up
  3004 00001B71 7CDF                            jl .move_down
  3005                                          
  3006                                      .check_collision:
  3007                                          ; Verificar colisión con bordes
  3008 00001B73 4983F801                        cmp r8, 1                       ; Borde izquierdo
  3009 00001B77 7E62                            jle .next_enemy
  3010 00001B79 4983F84E                        cmp r8, column_cells
  3011 00001B7D 7D5C                            jge .next_enemy
  3012 00001B7F 4983F901                        cmp r9, 1                       ; Borde superior
  3013 00001B83 7E56                            jle .next_enemy
  3014 00001B85 4983F920                        cmp r9, row_cells
  3015 00001B89 7D50                            jge .next_enemy
  3016                                          
  3017                                          ; Verificar colisión con bloques antes de moverse
  3018 00001B8B 4150                            push r8
  3019 00001B8D 4151                            push r9
  3020 00001B8F 4152                            push r10
  3021                                          
  3022                                          ; Calcular posición en el tablero para verificar
  3023 00001B91 B84E000000                      mov rax, column_cells
  3024 00001B96 4883C002                        add rax, 2
  3025 00001B9A 49F7E1                          mul r9
  3026 00001B9D 4C01C0                          add rax, r8
  3027 00001BA0 4C8D90[000A0000]                lea r10, [board + rax]
  3028                                          
  3029                                          ; Verificar si hay un bloque en la nueva posición
  3030 00001BA7 418A02                          mov al, [r10]
  3031 00001BAA 3C55                            cmp al, 'U'
  3032 00001BAC 7427                            je .invalid_move
  3033 00001BAE 3C4F                            cmp al, 'O'
  3034 00001BB0 7423                            je .invalid_move
  3035 00001BB2 3C44                            cmp al, 'D'
  3036 00001BB4 741F                            je .invalid_move
  3037 00001BB6 3C4C                            cmp al, 'L'
  3038 00001BB8 741B                            je .invalid_move
  3039 00001BBA 3C56                            cmp al, 'V'
  3040 00001BBC 7417                            je .invalid_move
  3041 00001BBE 3C38                            cmp al, '8'
  3042 00001BC0 7413                            je .invalid_move
  3043 00001BC2 3C58                            cmp al, 'X'
  3044 00001BC4 740F                            je .invalid_move
  3045                                          
  3046 00001BC6 415A                            pop r10
  3047 00001BC8 4159                            pop r9
  3048 00001BCA 4158                            pop r8
  3049                                          
  3050                                          ; Guardar nueva posición si es válida
  3051 00001BCC 448806                          mov [rsi], r8b
  3052 00001BCF 44884E01                        mov [rsi + 1], r9b
  3053 00001BD3 EB06                            jmp .next_enemy
  3054                                          
  3055                                      .invalid_move:
  3056 00001BD5 415A                            pop r10
  3057 00001BD7 4159                            pop r9
  3058 00001BD9 4158                            pop r8
  3059                                          
  3060                                      .next_enemy:
  3061 00001BDB 49FFC4                          inc r12
  3062 00001BDE E960FEFFFF                      jmp .enemy_loop
  3063                                          
  3064                                      .end:
  3065 00001BE3 5D                              pop rbp
  3066 00001BE4 C3                              ret
  3067                                  
  3068                                  get_current_spawn_points:
  3069 00001BE5 55                          push rbp
  3070 00001BE6 4889E5                      mov rbp, rsp
  3071                                      
  3072 00001BE9 480FB605(F9140000)          movzx rax, byte [current_level]
  3073 00001BF1 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3074 00001BF4 488B04C5[1B160000]          mov rax, [spawn_points_table + rax * 8]
  3075                                      
  3076 00001BFC 5D                          pop rbp
  3077 00001BFD C3                          ret
  3078                                  
  3079                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3080                                  check_enemy_spawn:
  3081 00001BFE 55                          push rbp
  3082 00001BFF 4889E5                      mov rbp, rsp
  3083                                      
  3084                                      ; Obtener spawn points del nivel actual
  3085 00001C02 E8DEFFFFFF                  call get_current_spawn_points
  3086 00001C07 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3087                                      
  3088                                      ; Obtener cantidad de bloques destruidos
  3089 00001C0A 4C0FB62D(A3150000)          movzx r13, byte [destroyed_blocks]
  3090                                      
  3091                                      ; Verificar cada punto de spawn
  3092 00001C12 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3093                                      
  3094                                      .check_loop:
  3095 00001C15 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3096 00001C19 7D4E                            jge .end
  3097                                          
  3098                                          ; Verificar si este spawn point ya fue usado
  3099 00001C1B 80B9[46160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3100 00001C22 7440                            je .next_enemy
  3101                                          
  3102                                          ; Verificar si este enemigo ya está activo
  3103 00001C24 4889C8                          mov rax, rcx
  3104 00001C27 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3105 00001C2B 488DB0[BD150000]                lea rsi, [enemies + rax]
  3106 00001C32 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3107 00001C36 742C                            je .next_enemy
  3108                                          
  3109                                          ; Verificar si debemos spawnear este enemigo
  3110 00001C38 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3111 00001C3D 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3112 00001C40 7522                            jne .next_enemy
  3113                                          
  3114                                          ; Marcar este spawn point como usado
  3115 00001C42 C681[46160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3116                                          
  3117                                          ; Spawner nuevo enemigo
  3118 00001C49 B004                            mov al, 4
  3119 00001C4B 00C8                            add al, cl       ; con 'rcx' como índice
  3120 00001C4D 8806                            mov [rsi], al
  3121 00001C4F C6460102                        mov byte [rsi+1], 2
  3122 00001C53 C6460201                        mov byte [rsi+2], 1
  3123                                  
  3124                                          ; Inicializar comportamiento
  3125 00001C57 4889C8                          mov rax, rcx
  3126 00001C5A 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3127 00001C5E 8805(45160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3128                                          
  3129                                      .next_enemy:
  3130 00001C64 48FFC1                          inc rcx
  3131 00001C67 EBAC                            jmp .check_loop
  3132                                          
  3133                                      .end:
  3134 00001C69 5D                              pop rbp
  3135 00001C6A C3                              ret
  3136                                  
  3137                                  
  3138                                  ; Función para dibujar enemigos
  3139                                  print_enemies:
  3140 00001C6B 55                          push rbp
  3141 00001C6C 4889E5                      mov rbp, rsp
  3142                                      
  3143 00001C6F 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3144                                      
  3145                                      .print_loop:
  3146 00001C72 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3147 00001C76 7D4B                            jge .end
  3148                                          
  3149                                          ; Calcular offset del enemigo actual
  3150 00001C78 4C89E0                          mov rax, r12
  3151 00001C7B 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3152 00001C7F 488DB0[BD150000]                lea rsi, [enemies + rax]
  3153                                          
  3154                                          ; Verificar si el enemigo está activo
  3155 00001C86 807E0201                        cmp byte [rsi + 2], 1
  3156 00001C8A 7532                            jne .next_enemy
  3157                                          
  3158                                          ; Calcular posición en el tablero
  3159 00001C8C 4C0FB606                        movzx r8, byte [rsi]            ; X
  3160 00001C90 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3161                                          
  3162                                          ; Calcular offset en el tablero
  3163 00001C95 B84E000000                      mov rax, column_cells
  3164 00001C9A 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3165 00001C9E 49F7E1                          mul r9
  3166 00001CA1 4C01C0                          add rax, r8
  3167 00001CA4 488DB8[000A0000]                lea rdi, [board + rax]
  3168                                          
  3169                                          ; Obtener carácter del enemigo según el nivel
  3170 00001CAB 480FB605(F9140000)              movzx rax, byte [current_level]
  3171 00001CB3 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3172 00001CB6 8A80[B8150000]                  mov al, [enemy_chars + rax]
  3173                                          
  3174                                          ; Dibujar enemigo
  3175 00001CBC 8807                            mov [rdi], al
  3176                                          
  3177                                      .next_enemy:
  3178 00001CBE 49FFC4                          inc r12
  3179 00001CC1 EBAF                            jmp .print_loop
  3180                                          
  3181                                      .end:
  3182 00001CC3 5D                              pop rbp
  3183 00001CC4 C3                              ret
  3184                                  
  3185                                  ; Función para verificar colisión con enemigos
  3186                                  ; Función para verificar colisión con enemigos
  3187                                  check_enemy_collision:
  3188 00001CC5 55                          push rbp
  3189 00001CC6 4889E5                      mov rbp, rsp
  3190                                      
  3191 00001CC9 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3192 00001CCC 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3193                                      
  3194                                      .check_loop:
  3195 00001CCF 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3196 00001CD3 0F8DE9000000                    jge .end
  3197                                          
  3198                                          ; Calcular offset del enemigo actual
  3199 00001CD9 4C89E1                          mov rcx, r12
  3200 00001CDC 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3201 00001CE0 488DB1[BD150000]                lea rsi, [enemies + rcx]
  3202                                          
  3203                                          ; Verificar si el enemigo está activo
  3204 00001CE7 807E0201                        cmp byte [rsi + 2], 1
  3205 00001CEB 0F85C9000000                    jne .next_enemy
  3206                                          
  3207                                          ; Verificar colisión con la bola
  3208 00001CF1 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3209 00001CF5 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3210                                          
  3211                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3212 00001CFA 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3213 00001D01 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3214                                          
  3215                                          ; Comprobar colisión vertical (misma columna)
  3216 00001D08 4D39C2                          cmp r10, r8
  3217 00001D0B 7525                            jne .check_horizontal
  3218 00001D0D 4D29CB                          sub r11, r9
  3219 00001D10 4983FB01                        cmp r11, 1
  3220 00001D14 7F1C                            jg .check_horizontal
  3221 00001D16 4983FBFF                        cmp r11, -1
  3222 00001D1A 7C16                            jl .check_horizontal
  3223                                          
  3224                                          ; Colisión vertical detectada
  3225 00001D1C E8A3000000                      call destroy_enemy
  3226 00001D21 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3227 00001D28 B801000000                      mov rax, 1
  3228 00001D2D E990000000                      jmp .end
  3229                                          
  3230                                      .check_horizontal:
  3231                                          ; Comprobar colisión horizontal (misma fila)
  3232 00001D32 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3233 00001D39 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3234 00001D40 4D39CB                          cmp r11, r9
  3235 00001D43 7522                            jne .check_paddle
  3236 00001D45 4D29C2                          sub r10, r8
  3237 00001D48 4983FA01                        cmp r10, 1
  3238 00001D4C 7F19                            jg .check_paddle
  3239 00001D4E 4983FAFF                        cmp r10, -1
  3240 00001D52 7C13                            jl .check_paddle
  3241                                          
  3242                                          ; Colisión horizontal detectada
  3243 00001D54 E86B000000                      call destroy_enemy
  3244 00001D59 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3245 00001D60 B801000000                      mov rax, 1
  3246 00001D65 EB5B                            jmp .end
  3247                                          
  3248                                      .check_paddle:
  3249                                          ; Verificar colisión con la paleta
  3250 00001D67 4C8B15(3F140000)                mov r10, [pallet_position]
  3251 00001D6E 4981EA[000A0000]                sub r10, board
  3252 00001D75 4C89D0                          mov rax, r10
  3253 00001D78 41BB4E000000                    mov r11, column_cells
  3254 00001D7E 4983C302                        add r11, 2
  3255 00001D82 4831D2                          xor rdx, rdx
  3256 00001D85 49F7F3                          div r11                     ; División para obtener la posición Y
  3257 00001D88 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3258                                          
  3259 00001D8B 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3260                                          
  3261                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3262 00001D92 41BD20000000                    mov r13, row_cells
  3263 00001D98 4983ED02                        sub r13, 2                 ; Y de la paleta
  3264 00001D9C 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3265 00001D9F 7519                            jne .next_enemy
  3266                                          
  3267                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3268 00001DA1 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3269 00001DA4 7C14                            jl .next_enemy
  3270                                          
  3271 00001DA6 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3272 00001DA9 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3273 00001DAC 7F0C                            jg .next_enemy
  3274                                          
  3275                                          ; Si llegamos aquí, hay colisión con la paleta
  3276 00001DAE E811000000                      call destroy_enemy        ; Destruir el enemigo
  3277 00001DB3 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3278 00001DB8 EB08                            jmp .end
  3279                                          
  3280                                      .next_enemy:
  3281 00001DBA 49FFC4                          inc r12
  3282 00001DBD E90DFFFFFF                      jmp .check_loop
  3283                                          
  3284                                      .end:
  3285 00001DC2 5D                              pop rbp
  3286 00001DC3 C3                              ret
  3287                                  
  3288                                  ; Función para destruir un enemigo
  3289                                  destroy_enemy:
  3290                                      ; Desactivar enemigo
  3291 00001DC4 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3292                                  
  3293                                      ; Sumar puntos por destruir enemigo
  3294 00001DC8 488B05(DC150000)            mov rax, [enemy_points]
  3295 00001DCF 480105(9B150000)            add [current_score], rax
  3296                                  
  3297                                      ; No tocar bloques destruidos aquí
  3298 00001DD6 C3                          ret
  3299                                  
  3300                                  
  3301                                  _start:
  3302 00001DD7 E84FE3FFFF              	call canonical_off
  3303 00001DDC E853010000              	call start_screen
  3304 00001DE1 E89CF5FFFF                  call init_level
  3305 00001DE6 E8FCFBFFFF                  call init_enemies
  3306 00001DEB EB00                    	jmp .main_loop
  3307                                  	
  3308                                  
  3309                                      .main_loop:
  3310 00001DED E8B3F9FFFF                      call print_labels
  3311 00001DF2 E8E2F8FFFF                      call print_blocks
  3312 00001DF7 E83EE7FFFF                      call move_letters
  3313 00001DFC E8FDE9FFFF                      call update_lasers
  3314 00001E01 E8A9E6FFFF                      call print_letters
  3315 00001E06 E89EEDFFFF                      call print_pallet
  3316                                          
  3317                                          ; Mover bola principal solo si está activa
  3318 00001E0B 803D(80140000)01                cmp byte [ball_active], 1
  3319 00001E12 7505                            jne .skip_ball1
  3320 00001E14 E8A8EEFFFF                          call move_ball
  3321                                          .skip_ball1:
  3322                                  
  3323                                          ; Mover bola 2 si está activa
  3324 00001E19 803D(A2140000)01                cmp byte [ball2_active], 1
  3325 00001E20 7505                            jne .skip_ball2
  3326 00001E22 E86DF0FFFF                          call move_ball_2
  3327                                          .skip_ball2:
  3328                                  
  3329                                          ; Mover bola 3 si está activa
  3330 00001E27 803D(C4140000)01                cmp byte [ball3_active], 1
  3331 00001E2E 7505                            jne .skip_ball3
  3332 00001E30 E832F2FFFF                          call move_ball_3
  3333                                          .skip_ball3:
  3334                                  
  3335 00001E35 E8BCE4FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3336 00001E3A E89EE3FFFF                      call print_lives
  3337                                  
  3338                                          ; Imprimir solo las bolas activas
  3339 00001E3F 803D(80140000)01                cmp byte [ball_active], 1
  3340 00001E46 7505                            jne .no_pb1
  3341 00001E48 E8E4ECFFFF                          call print_ball
  3342                                          .no_pb1:
  3343                                  
  3344 00001E4D 803D(A2140000)01                cmp byte [ball2_active], 1
  3345 00001E54 7505                            jne .no_pb2
  3346 00001E56 E8FEECFFFF                          call print_ball_2
  3347                                          .no_pb2:
  3348                                  
  3349 00001E5B 803D(C4140000)01                cmp byte [ball3_active], 1
  3350 00001E62 7505                            jne .no_pb3
  3351 00001E64 E818EDFFFF                          call print_ball_3
  3352                                          .no_pb3:
  3353                                  
  3354 00001E69 E8CDF6FFFF                      call check_level_complete
  3355 00001E6E E88BFDFFFF                      call check_enemy_spawn
  3356 00001E73 E8A3FBFFFF                      call move_enemies
  3357 00001E78 E848FEFFFF                      call check_enemy_collision
  3358 00001E7D E8E9FDFFFF                      call print_enemies
  3359                                  		print board, board_size				
    82 00001E82 B801000000          <1>  mov eax, sys_write
    83 00001E87 BF01000000          <1>  mov edi, 1
    84 00001E8C 48BE-               <1>  mov rsi, %1
    84 00001E8E [000A000000000000]  <1>
    85 00001E96 BA000A0000          <1>  mov edx, %2
    86 00001E9B 0F05                <1>  syscall
  3360                                  		;setnonblocking	
  3361                                  	.read_more:	
  3362                                  	    getchar	
    90 00001E9D B800000000          <1>  mov rax, sys_read
    91 00001EA2 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001EA7 48BE-               <1>  mov rsi, input_char
    92 00001EA9 [0000000000000000]  <1>
    93 00001EB1 BA01000000          <1>  mov rdx, 1
    94 00001EB6 0F05                <1>  syscall
  3363 00001EB8 4883F801                	    cmp rax, 1
  3364 00001EBC 7543                    	    jne .done
  3365                                  	
  3366 00001EBE 8A05(00000000)          	    mov al, [input_char]
  3367 00001EC4 8805(64180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3368                                  	
  3369 00001ECA 3C61                    	    cmp al, 'a'
  3370 00001ECC 750E                    	    jne .not_left
  3371 00001ECE 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3372 00001ED5 E804EDFFFF              	    call move_pallet
  3373 00001EDA EB25                    	    jmp .done
  3374                                  	
  3375                                      .not_left:
  3376 00001EDC 3C64                    	    cmp al, 'd'
  3377 00001EDE 750C                    	    jne .not_right
  3378 00001EE0 BF01000000              	    mov rdi, right_direction
  3379 00001EE5 E8F4ECFFFF              	    call move_pallet
  3380 00001EEA EB15                    	    jmp .done
  3381                                  	
  3382                                      .not_right:
  3383 00001EEC 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3384 00001EEE 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3385                                  	
  3386 00001EF0 3C71                    	    cmp al, 'q' 
  3387 00001EF2 0F84AF000000            	    je exit
  3388 00001EF8 EBA3                    	    jmp .read_more
  3389                                  	
  3390                                      .release_ball:
  3391 00001EFA E83BF3FFFF              	    call process_catch_release
  3392 00001EFF EB00                    	    jmp .done
  3393                                  	
  3394                                      .done:
  3395                                  	    sleeptime
    98 00001F01 B823000000          <1>  mov eax, sys_nanosleep
    99 00001F06 48BF-               <1>  mov rdi, timespec
    99 00001F08 [0000000000000000]  <1>
   100 00001F10 31F6                <1>  xor esi, esi
   101 00001F12 0F05                <1>  syscall
  3396                                  	    print clear, clear_length
    82 00001F14 B801000000          <1>  mov eax, sys_write
    83 00001F19 BF01000000          <1>  mov edi, 1
    84 00001F1E 48BE-               <1>  mov rsi, %1
    84 00001F20 [1000000000000000]  <1>
    85 00001F28 BA07000000          <1>  mov edx, %2
    86 00001F2D 0F05                <1>  syscall
  3397 00001F2F E9B9FEFFFF              	    jmp .main_loop
  3398                                  
  3399                                  
  3400                                  
  3401                                  
  3402                                  start_screen:
  3403                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001F34 B801000000          <1>  mov eax, sys_write
    83 00001F39 BF01000000          <1>  mov edi, 1
    84 00001F3E 48BE-               <1>  mov rsi, %1
    84 00001F40 [1000000000000000]  <1>
    85 00001F48 BA07000000          <1>  mov edx, %2
    86 00001F4D 0F05                <1>  syscall
  3404                                      print msg1, msg1_length
    82 00001F4F B801000000          <1>  mov eax, sys_write
    83 00001F54 BF01000000          <1>  mov edi, 1
    84 00001F59 48BE-               <1>  mov rsi, %1
    84 00001F5B [1700000000000000]  <1>
    85 00001F63 BA14010000          <1>  mov edx, %2
    86 00001F68 0F05                <1>  syscall
  3405                                      
  3406                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3407                                          getchar                 ; Esperamos una tecla
    90 00001F6A B800000000          <1>  mov rax, sys_read
    91 00001F6F BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001F74 48BE-               <1>  mov rsi, input_char
    92 00001F76 [0000000000000000]  <1>
    93 00001F7E BA01000000          <1>  mov rdx, 1
    94 00001F83 0F05                <1>  syscall
  3408 00001F85 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3409 00001F89 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3410                                          
  3411                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001F8B B801000000          <1>  mov eax, sys_write
    83 00001F90 BF01000000          <1>  mov edi, 1
    84 00001F95 48BE-               <1>  mov rsi, %1
    84 00001F97 [1000000000000000]  <1>
    85 00001F9F BA07000000          <1>  mov edx, %2
    86 00001FA4 0F05                <1>  syscall
  3412 00001FA6 C3                          ret
  3413                                  
  3414                                  exit: 
  3415 00001FA7 E8C1E1FFFF              	call canonical_on
  3416 00001FAC B83C000000              	mov    rax, 60
  3417 00001FB1 BF00000000                  mov    rdi, 0
  3418 00001FB6 0F05                        syscall
  3419                                  
