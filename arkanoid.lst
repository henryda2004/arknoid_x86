     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001480 00                          ball_active db 0
   258                                  
   259 00001481 0000000000000000            ball2_x_pos:        dq 0
   260 00001489 0000000000000000            ball2_y_pos:        dq 0
   261 00001491 0000000000000000            ball2_direction_x:  dq 0
   262 00001499 0000000000000000            ball2_direction_y:  dq 0
   263 000014A1 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 000014A2 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 000014A3 0000000000000000            ball3_x_pos:        dq 0
   268 000014AB 0000000000000000            ball3_y_pos:        dq 0
   269 000014B3 0000000000000000            ball3_direction_x:  dq 0
   270 000014BB 0000000000000000            ball3_direction_y:  dq 0
   271 000014C3 00                          ball3_moving:       db 0
   272 000014C4 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 000014C5 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 000014CD [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 000014D5 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 000014DB 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 000014E1 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 000014E7 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 000014ED 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 000014F3 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 000014F9 01                          current_level db 1
   300 000014FA 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 000014FB 3A07030153                      db 58, 7, 3, 1, 'S'    ; Bloque 7
   307 00001500 3D09030144                      db 61, 9, 3, 1, 'D'    ; Bloque 7
   308 00001505 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   309 0000150A 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   310 0000150F 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   311 00001514 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   312 00001519 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   313 0000151E 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   314                                  
   315                                  
   316                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   317                                  
   318                                      ; Nivel 2: Bloques de prueba
   319                                      level2_blocks:
   320 00001523 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   321                                      level2_blocks_count equ 1
   322                                  
   323                                      ; Nivel 3
   324                                      level3_blocks:
   325 00001528 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   326                                  
   327                                      level3_blocks_count equ 1
   328                                  
   329                                      ; Nivel 4
   330                                      level4_blocks:
   331 0000152D 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   332                                      level4_blocks_count equ 1
   333                                  
   334                                      ; Nivel 5
   335                                      level5_blocks:
   336 00001532 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   337                                      level5_blocks_count equ 1
   338                                  
   339                                      ; Array para mantener el estado de los bloques
   340 00001537 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   341                                  
   342                                      
   343                                      ; Variables para almacenar los valores
   344 0000159B 0000000000000000            current_score dq 0          ; Score actual
   345 000015A3 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   346                                      
   347                                      ; Buffer para convertir números a string
   348 000015A4 00<rep 14h>                 number_buffer: times 20 db 0
   349                                  
   350 000015B8 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   351                                      
   352                                      ; Estructura para los enemigos (x, y, activo)
   353 000015BD 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   354 000015DB 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   355                                      
   356 000015DC 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   357 000015E4 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   358 000015E5 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   359 000015E6 00                          enemy_move_total db 0      ; Contador total de movimientos
   360 000015E7 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 000015E8 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   362                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   363                                      ; Añade esto en la sección .dataa
   364 000015E9 00000006080A0C0E10-         level1_spawn_points: db 0, 0, 0, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   364 000015F2 12                 
   365 000015F3 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   365 000015FC 13                 
   366 000015FD 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   366 00001606 1B                 
   367 00001607 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   367 00001610 1C                 
   368 00001611 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   368 0000161A 2D                 
   369                                          ; Arreglo de punteros a los spawn points de cada nivel
   370                                      spawn_points_table:
   371 0000161B [E915000000000000]              dq level1_spawn_points
   372 00001623 [F315000000000000]              dq level2_spawn_points
   373 0000162B [FD15000000000000]              dq level3_spawn_points
   374 00001633 [0716000000000000]              dq level4_spawn_points
   375 0000163B [1116000000000000]              dq level5_spawn_points
   376                                  
   377                                      ; Variables para el comportamiento de enemigos
   378 00001643 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   379 00001644 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   380 00001645 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   381 00001646 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   382                                  
   383 00001650 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   383 00001659 5B2020202020202020-
   383 00001662 20205D0A0D         
   384                                      score_label_len: equ $ - score_label
   385 00001667 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   385 00001670 657374727569646F73-
   385 00001679 3A205B2020205D0A0D 
   386                                      blocks_label_len: equ $ - blocks_label
   387                                      
   388                                      ; Posición donde insertar los números en los labels
   389                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   390                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   391                                      
   392                                      ; Definición de las vidas (x, y, estado)
   393                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   394                                      lives_data: 
   395 00001682 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   396 00001685 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   397 00001688 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   398 0000168B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   399 0000168E 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   400 00001691 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   401 00001694 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   402                                      lives_count equ 7    ; Total de vidas
   403 00001697 5E                          life_char db "^"    
   404 00001698 04                          current_lives db 4   ; Contador de vidas activas actual
   405                                  
   406                                  ; Estructura para almacenar las letras y sus posiciones
   407                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   408 00001699 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   409 00001829 00                          letters_count db 0   
   410 0000182A 20                          last_letter db ' '    ; Variable para almacenar la última letra
   411 0000182B 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   411 00001834 75616C3A205B205D0A-
   411 0000183D 0D                 
   412                                      last_letter_msg_len equ $ - last_letter_msg
   413 0000183E 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   414 0000183F 07                          max_lives db 7              ; Máximo número de vidas permitidas
   415 00001840 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   416 00001848 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   417 00001850 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   418                                  
   419 00001858 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   420 00001859 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   421 0000185A 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
   422 0000185B 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
   423                                  
   424 0000185C 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   425 00001864 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   426                                  
   427 00001865 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   428 00001866 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   429 00001867 00                          laser_count: db 0                ; Contador de láseres activos
   430 00001868 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   431 00001930 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   432                                  
   433                                      balls_data:     ; Array para almacenar hasta 3 bolas
   434                                          ; Bola 1 (principal)
   435 00001938 0000000000000000                dq 0        ; x_pos
   436 00001940 0000000000000000                dq 0        ; y_pos
   437 00001948 0100000000000000                dq 1        ; direction_x
   438 00001950 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   439 00001958 01                              db 1        ; active
   440                                          ; Bola 2
   441 00001959 0000000000000000                dq 0        ; x_pos
   442 00001961 0000000000000000                dq 0        ; y_pos
   443 00001969 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   444 00001971 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   445 00001979 00                              db 0        ; active
   446                                          ; Bola 3
   447 0000197A 0000000000000000                dq 0        ; x_pos
   448 00001982 0000000000000000                dq 0        ; y_pos
   449 0000198A 0000000000000000                dq 0        ; direction_x
   450 00001992 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   451 0000199A 00                              db 0        ; active
   452                                      
   453 0000199B 01                          balls_count db 1     ; Contador de bolas activas
   454                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   455 0000199C 00<rep Ah>                  enemy_last_x:       times 10 db 0
   456 000019A6 00<rep Ah>                  enemy_last_y:       times 10 db 0
   457 000019B0 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
   458                                  
   459                                  section .text
   460                                  
   461                                  
   462                                  print_lives:
   463 000001DD 55                          push rbp
   464 000001DE 4889E5                      mov rbp, rsp
   465                                      
   466 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   467                                      
   468                                      .print_loop:
   469 000001E4 4983FC07                        cmp r12, lives_count
   470 000001E8 7D45                            jge .end
   471                                          
   472                                          ; Calcular offset de la vida actual
   473 000001EA 4C89E0                          mov rax, r12
   474 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   475 000001F1 488DB0[82160000]                lea rsi, [lives_data + rax]
   476                                          
   477                                          ; Calcular posición en el tablero
   478 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   479 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   480                                          
   481                                          ; Calcular offset en el tablero
   482 00000201 B84E000000                      mov rax, column_cells
   483 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   484 0000020A 49F7E1                          mul r9
   485 0000020D 4C01C0                          add rax, r8
   486 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   487                                          
   488                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   489 00000217 807E0201                        cmp byte [rsi + 2], 1
   490 0000021B 7405                            je .draw_active
   491                                          
   492                                          ; Si está inactiva, dibujar espacio
   493 0000021D C60720                          mov byte [rdi], ' '
   494 00000220 EB08                            jmp .next_life
   495                                          
   496                                      .draw_active:
   497                                          ; Si está activa, dibujar el símbolo de vida
   498 00000222 8A05(97160000)                  mov al, [life_char]
   499 00000228 8807                            mov [rdi], al
   500                                          
   501                                      .next_life:
   502 0000022A 49FFC4                          inc r12
   503 0000022D EBB5                            jmp .print_loop
   504                                          
   505                                      .end:
   506 0000022F 5D                              pop rbp
   507 00000230 C3                              ret
   508                                  
   509                                  ; Función para desactivar una vida
   510                                  ; Función modificada para perder una vida
   511                                  ; Modificar lose_life para reiniciar solo la bola principal
   512                                  lose_life:
   513 00000231 55                          push rbp
   514 00000232 4889E5                      mov rbp, rsp
   515                                      
   516                                      ; Verificar si aún quedan vidas
   517 00000235 803D(98160000)00            cmp byte [current_lives], 0
   518 0000023C 0F84AB000000                je .game_lost
   519                                      
   520                                      ; Encontrar la última vida activa
   521 00000242 B907000000                  mov rcx, lives_count
   522 00000247 48FFC9                      dec rcx
   523                                      
   524                                      .find_active_life:
   525 0000024A 4889C8                          mov rax, rcx
   526 0000024D 486BC003                        imul rax, 3
   527 00000251 488DB0[82160000]                lea rsi, [lives_data + rax]
   528 00000258 807E0201                        cmp byte [rsi + 2], 1
   529 0000025C 740A                            je .deactivate_life
   530 0000025E 48FFC9                          dec rcx
   531 00000261 79E7                            jns .find_active_life
   532 00000263 E985000000                      jmp .game_lost
   533                                          
   534                                      .deactivate_life:
   535                                          ; Borrar vida visualmente y en datos
   536 00000268 4C0FB606                        movzx r8, byte [rsi]
   537 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   538 00000271 B84E000000                      mov rax, column_cells
   539 00000276 4883C002                        add rax, 2
   540 0000027A 49F7E1                          mul r9
   541 0000027D 4C01C0                          add rax, r8
   542 00000280 488DB8[000A0000]                lea rdi, [board + rax]
   543 00000287 C60720                          mov byte [rdi], ' '
   544 0000028A C6460200                        mov byte [rsi + 2], 0
   545 0000028E FE0D(98160000)                  dec byte [current_lives]
   546                                          
   547                                          ; Borrar paleta anterior
   548 00000294 4C8B05(3F140000)                mov r8, [pallet_position]
   549 0000029B 488B0D(47140000)                mov rcx, [pallet_size]
   550                                          .erase_pallet_loop:
   551 000002A2 41C60020                            mov byte [r8], ' '
   552 000002A6 49FFC0                              inc r8
   553 000002A9 48FFC9                              dec rcx
   554 000002AC 75F4                                jnz .erase_pallet_loop
   555                                          
   556                                          ; Reiniciar solo la bola principal
   557 000002AE 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   557 000002B6 000000             
   558 000002B9 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   558 000002C1 000000             
   559 000002C4 C605(7F140000)00                mov byte [ball_moving], 0
   560 000002CB C605(80140000)01                mov byte [ball_active], 1       ; Activar bola principal
   561 000002D2 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   561 000002D9 [36130000]         
   562                                          
   563                                          ; Asegurarse que las otras bolas están desactivadas
   564 000002DD C605(A2140000)00                mov byte [ball2_active], 0
   565 000002E4 C605(C4140000)00                mov byte [ball3_active], 0
   566                                          
   567 000002EB EB07                            jmp .end
   568                                          
   569                                      .game_lost:
   570 000002ED E8C7000000                      call game_lost
   571 000002F2 EB00                            jmp .end
   572                                          
   573                                      .end:
   574 000002F4 5D                              pop rbp
   575 000002F5 C3                              ret
   576                                  ; Función modificada para verificar colisión con el borde inferior
   577                                  check_bottom_collision:
   578 000002F6 55                          push rbp
   579 000002F7 4889E5                      mov rbp, rsp
   580                                      
   581                                      ; Verificar bola principal
   582 000002FA 803D(80140000)01            cmp byte [ball_active], 1
   583 00000301 7542                        jne .check_ball2
   584 00000303 488B05(67140000)            mov rax, [ball_y_pos]
   585 0000030A 4883F81E                    cmp rax, row_cells - 2
   586 0000030E 7535                        jne .check_ball2
   587                                      
   588                                      ; Borrar visualmente la bola principal
   589 00000310 4C8B05(5F140000)            mov r8, [ball_x_pos]
   590 00000317 4C8B0D(67140000)            mov r9, [ball_y_pos]
   591 0000031E 4981C0[000A0000]            add r8, board
   592 00000325 4C89C9                      mov rcx, r9
   593 00000328 B850000000                  mov rax, column_cells + 2
   594 0000032D 48F7E9                      imul rcx
   595 00000330 4901C0                      add r8, rax
   596 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   597                                      
   598 00000337 C605(80140000)00            mov byte [ball_active], 0
   599 0000033E C605(7F140000)00            mov byte [ball_moving], 0
   600                                  
   601                                  .check_ball2:
   602 00000345 803D(A2140000)01            cmp byte [ball2_active], 1
   603 0000034C 751B                        jne .check_ball3
   604 0000034E 488B05(89140000)            mov rax, [ball2_y_pos]
   605 00000355 4883F81E                    cmp rax, row_cells - 2
   606 00000359 750E                        jne .check_ball3
   607 0000035B C605(A2140000)00            mov byte [ball2_active], 0
   608 00000362 C605(A1140000)00            mov byte [ball2_moving], 0
   609                                  
   610                                  .check_ball3:
   611 00000369 803D(C4140000)01            cmp byte [ball3_active], 1
   612 00000370 751B                        jne .check_active_balls
   613 00000372 488B05(AB140000)            mov rax, [ball3_y_pos]
   614 00000379 4883F81E                    cmp rax, row_cells - 2
   615 0000037D 750E                        jne .check_active_balls
   616 0000037F C605(C4140000)00            mov byte [ball3_active], 0
   617 00000386 C605(C3140000)00            mov byte [ball3_moving], 0
   618                                  
   619                                  .check_active_balls:
   620                                      ; Verificar si quedan bolas activas
   621 0000038D 4831C9                      xor rcx, rcx
   622 00000390 803D(80140000)01            cmp byte [ball_active], 1
   623 00000397 741E                        je .balls_remain
   624 00000399 803D(A2140000)01            cmp byte [ball2_active], 1
   625 000003A0 7415                        je .balls_remain
   626 000003A2 803D(C4140000)01            cmp byte [ball3_active], 1
   627 000003A9 740C                        je .balls_remain
   628                                      
   629                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   630 000003AB E881FEFFFF                  call lose_life
   631 000003B0 C605(80140000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   632                                      
   633                                  .balls_remain:
   634 000003B7 5D                          pop rbp
   635 000003B8 C3                          ret
   636                                  
   637                                  
   638                                  
   639                                  ; Nueva función para game over
   640                                  game_lost:
   641                                      ; Limpiar la pantalla
   642                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   643                                      
   644                                      ; Mostrar mensaje de derrota
   645                                      section .data
   646 000019BA C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   646 000019C3 6469646F210A0D     
   647                                          lost_msg_len: equ $ - lost_msg
   648                                      section .text
   649                                      
   650                                      ; Imprimir mensaje de derrota
   651                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [BA19000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   652                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [E819000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   653                                      
   654                                      ; Mostrar puntaje final
   655 0000040A 488B05(9B150000)            mov rax, [current_score]
   656 00000411 48BF-                       mov rdi, number_buffer
   656 00000413 [A415000000000000] 
   657 0000041B E846130000                  call number_to_string
   658                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [A415000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   659                                      
   660                                      ; Esperar un momento antes de salir
   661 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   661 00000444 0000               
   662 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   662 0000044F 0000               
   663                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   664                                      
   665 00000464 E9901C0000                  jmp exit
   666                                  
   667                                  
   668                                  ; Función para registrar una nueva letra en el mapa
   669                                  ; Entrada:
   670                                  ;   al - letra a registrar
   671                                  ;   r8b - posición x
   672                                  ;   r9b - posición y
   673                                  register_letter:
   674 00000469 55                          push rbp
   675 0000046A 4889E5                      mov rbp, rsp
   676 0000046D 53                          push rbx
   677 0000046E 51                          push rcx
   678                                      
   679 0000046F 3C20                        cmp al, ' '
   680 00000471 7438                        je .end
   681                                  
   682                                      ; Encontrar un espacio libre en el mapa
   683 00000473 4831C9                      xor rcx, rcx
   684 00000476 480FB615(29180000)          movzx rdx, byte [letters_count]
   685                                      
   686                                      .find_slot:
   687 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   688 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   689                                          
   690 00000484 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   691 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   692 00000490 7405                            je .found_slot
   693                                          
   694 00000492 48FFC1                          inc rcx
   695 00000495 EBE7                            jmp .find_slot
   696                                          
   697                                      .found_slot:
   698                                          ; Guardar la información de la letra
   699 00000497 448803                          mov [rbx], r8b           ; x
   700 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   701 0000049E 884302                          mov [rbx + 2], al        ; letra
   702 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   703                                          
   704 000004A5 FE05(29180000)                  inc byte [letters_count]
   705                                          
   706                                      .end:
   707 000004AB 59                              pop rcx
   708 000004AC 5B                              pop rbx
   709 000004AD 5D                              pop rbp
   710 000004AE C3                              ret
   711                                  
   712                                  ; Función para imprimir todas las letras registradas
   713                                  print_letters:
   714 000004AF 55                          push rbp
   715 000004B0 4889E5                      mov rbp, rsp
   716 000004B3 53                          push rbx
   717 000004B4 51                          push rcx
   718                                      
   719 000004B5 4831C9                      xor rcx, rcx
   720                                      
   721                                      .print_loop:
   722 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   723 000004BC 7D37                            jge .end
   724                                          
   725                                          ; Obtener puntero a la letra actual
   726 000004BE 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   727                                          
   728                                          ; Verificar si está activa
   729 000004C6 807B0300                        cmp byte [rbx + 3], 0
   730 000004CA 7424                            je .next_letter
   731                                          
   732                                          ; Calcular posición en el tablero
   733 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   734 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   735                                          
   736                                          ; Calcular offset en el tablero
   737 000004D5 B84E000000                      mov rax, column_cells
   738 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   739 000004DE 49F7E1                          mul r9
   740 000004E1 4C01C0                          add rax, r8
   741 000004E4 488DB8[000A0000]                lea rdi, [board + rax]
   742                                          
   743                                          ; Imprimir la letra
   744 000004EB 8A4302                          mov al, [rbx + 2]
   745 000004EE 8807                            mov [rdi], al
   746                                          
   747                                      .next_letter:
   748 000004F0 48FFC1                          inc rcx
   749 000004F3 EBC3                            jmp .print_loop
   750                                          
   751                                      .end:
   752 000004F5 59                              pop rcx
   753 000004F6 5B                              pop rbx
   754 000004F7 5D                              pop rbp
   755 000004F8 C3                              ret
   756                                  
   757                                  ; Función para borrar una letra específica
   758                                  ; Entrada:
   759                                  ;   r8b - posición x
   760                                  ;   r9b - posición y
   761                                  remove_letter:
   762 000004F9 55                          push rbp
   763 000004FA 4889E5                      mov rbp, rsp
   764 000004FD 53                          push rbx
   765 000004FE 51                          push rcx
   766                                      
   767 000004FF 4831C9                      xor rcx, rcx
   768                                      
   769                                      .find_loop:
   770 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   771 00000506 7D2E                            jge .end
   772                                          
   773 00000508 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   774                                          
   775                                          ; Verificar si está activa y coincide la posición
   776 00000510 807B0300                        cmp byte [rbx + 3], 0
   777 00000514 741B                            je .next_letter
   778                                          
   779 00000516 8A03                            mov al, [rbx]
   780 00000518 4438C0                          cmp al, r8b
   781 0000051B 7514                            jne .next_letter
   782                                          
   783 0000051D 8A4301                          mov al, [rbx + 1]
   784 00000520 4438C8                          cmp al, r9b
   785 00000523 750C                            jne .next_letter
   786                                          
   787                                          ; Encontrada la letra, desactivarla
   788 00000525 C6430300                        mov byte [rbx + 3], 0
   789 00000529 FE0D(29180000)                  dec byte [letters_count]
   790 0000052F EB05                            jmp .end
   791                                          
   792                                      .next_letter:
   793 00000531 48FFC1                          inc rcx
   794 00000534 EBCC                            jmp .find_loop
   795                                          
   796                                      .end:
   797 00000536 59                              pop rcx
   798 00000537 5B                              pop rbx
   799 00000538 5D                              pop rbp
   800 00000539 C3                              ret
   801                                  ; Función para mover las letras hacia abajo
   802                                  move_letters:
   803 0000053A 55                          push rbp
   804 0000053B 4889E5                      mov rbp, rsp
   805 0000053E 53                          push rbx
   806 0000053F 57                          push rdi
   807 00000540 56                          push rsi
   808 00000541 4150                        push r8
   809 00000543 4151                        push r9
   810 00000545 4152                        push r10
   811 00000547 4153                        push r11
   812                                  
   813 00000549 4831C9                      xor rcx, rcx
   814                                  
   815                                      .move_loop:
   816 0000054C 4883F964                        cmp rcx, 100
   817 00000550 0F8D0D020000                    jge .print_last_letter
   818                                          
   819 00000556 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   820 0000055E 807B0300                        cmp byte [rbx + 3], 0
   821 00000562 0F84F3010000                    je .next_letter
   822                                  
   823 00000568 4C0FB603                        movzx r8, byte [rbx]
   824 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
   825                                  
   826 00000571 B84E000000                      mov rax, column_cells
   827 00000576 4883C002                        add rax, 2
   828 0000057A 49F7E1                          mul r9
   829 0000057D 4C01C0                          add rax, r8
   830 00000580 488DB8[000A0000]                lea rdi, [board + rax]
   831 00000587 C60720                          mov byte [rdi], ' '
   832                                  
   833 0000058A FE4301                          inc byte [rbx + 1]
   834 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
   835                                  
   836 00000592 4983F91F                        cmp r9, row_cells - 1
   837 00000596 7C09                            jl .check_pallet_collision
   838                                  
   839 00000598 C6430300                        mov byte [rbx + 3], 0
   840 0000059C E9BA010000                      jmp .next_letter
   841                                  
   842                                          .check_pallet_collision:
   843 000005A1 B84E000000                          mov rax, column_cells
   844 000005A6 4883C002                            add rax, 2
   845 000005AA 49F7E1                              mul r9
   846 000005AD 4C01C0                              add rax, r8
   847 000005B0 488DB8[000A0000]                    lea rdi, [board + rax]
   848                                  
   849 000005B7 8A07                                mov al, [rdi]
   850 000005B9 3C20                                cmp al, ' '
   851 000005BB 0F849A010000                        je .next_letter
   852 000005C1 3C3D                                cmp al, char_equal
   853 000005C3 740A                                je .capture_letter
   854                                  
   855 000005C5 8A4302                              mov al, [rbx + 2]
   856 000005C8 8807                                mov [rdi], al
   857 000005CA E98C010000                          jmp .next_letter
   858                                  
   859                                          .capture_letter:
   860                                              ; Obtener la nueva letra
   861 000005CF 8A4302                              mov al, [rbx + 2]
   862                                              
   863                                              ; Comparar con la última letra
   864 000005D2 3A05(2A180000)                      cmp al, [last_letter]
   865 000005D8 7407                                je .same_letter
   866                                              
   867                                              ; Es una letra diferente, resetear el procesamiento
   868 000005DA C605(3E180000)00                    mov byte [current_power_processed], 0
   869                                              
   870                                              .same_letter:
   871                                              ; Guardar la nueva letra
   872 000005E1 8805(2A180000)                      mov [last_letter], al
   873                                              
   874                                              ; Verificar si es 'E' para extender la paleta
   875 000005E7 3C45                                cmp al, 'E'
   876 000005E9 7450                                je .extend_pallet
   877                                              
   878                                              ; Verificar si es 'P' para añadir vida
   879 000005EB 3C50                                cmp al, 'P'
   880 000005ED 7478                                je .check_add_life
   881                                  
   882 000005EF 3C53                                cmp al, 'S'
   883 000005F1 0F84B4000000                        je .slow_ball
   884                                  
   885 000005F7 3C43                                cmp al, 'C'
   886 000005F9 0F84D8000000                        je .activate_catch
   887                                              
   888 000005FF 3C4C                                cmp al, 'L'
   889 00000601 0F84F9000000                        je .activate_laser
   890                                  
   891 00000607 3C44                                cmp al, 'D'
   892 00000609 0F841A010000                        je .activate_split
   893                                  
   894                                              ; Si no es ningún power-up, restaurar tamaño normal
   895 0000060F 488B05(4F140000)                    mov rax, [default_pallet_size]
   896 00000616 488905(47140000)                    mov [pallet_size], rax
   897 0000061D 48C705(40180000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   897 00000625 000000             
   898 00000628 C605(58180000)00                    mov byte [catch_power_active], 0
   899 0000062F C605(65180000)00                    mov byte [laser_power_active], 0
   900 00000636 E91C010000                          jmp .finish_capture
   901                                  
   902                                              .extend_pallet:
   903 0000063B C605(65180000)00                        mov byte [laser_power_active], 0
   904 00000642 C605(58180000)00                        mov byte [catch_power_active], 0
   905 00000649 48C705(40180000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   905 00000651 000000             
   906 00000654 488B05(57140000)                        mov rax, [extended_pallet_size]
   907 0000065B 488905(47140000)                        mov [pallet_size], rax
   908 00000662 E9F0000000                              jmp .finish_capture
   909                                  
   910                                              .check_add_life:
   911 00000667 C605(65180000)00                        mov byte [laser_power_active], 0
   912 0000066E C605(58180000)00                        mov byte [catch_power_active], 0
   913 00000675 488B05(4F140000)                        mov rax, [default_pallet_size]
   914 0000067C 488905(47140000)                        mov [pallet_size], rax
   915 00000683 48C705(40180000)01-                     mov qword [ball_speed], 1 
   915 0000068B 000000             
   916                                                  ; Verificar si ya procesamos este power-up
   917 0000068E 803D(3E180000)00                        cmp byte [current_power_processed], 0
   918 00000695 0F85BC000000                            jne .finish_capture
   919                                                  
   920                                                  ; Preservar registros importantes
   921 0000069B 51                                      push rcx
   922 0000069C 53                                      push rbx
   923                                                  
   924                                                  ; Marcar como procesado
   925 0000069D C605(3E180000)01                        mov byte [current_power_processed], 1
   926                                                  
   927                                                  ; Añadir una vida
   928 000006A4 E838040000                              call add_life
   929                                                  
   930                                                  ; Restaurar registros
   931 000006A9 5B                                      pop rbx
   932 000006AA 59                                      pop rcx
   933                                                  
   934                                              .slow_ball:
   935 000006AB C605(65180000)00                        mov byte [laser_power_active], 0
   936 000006B2 C605(58180000)00                        mov byte [catch_power_active], 0                
   937 000006B9 488B05(4F140000)                        mov rax, [default_pallet_size]
   938 000006C0 488905(47140000)                        mov [pallet_size], rax
   939 000006C7 48C705(40180000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   939 000006CF 000000             
   940 000006D2 E980000000                              jmp .finish_capture
   941                                  
   942                                              .activate_catch:
   943 000006D7 C605(65180000)00                        mov byte [laser_power_active], 0
   944 000006DE 488B05(4F140000)                        mov rax, [default_pallet_size]
   945 000006E5 488905(47140000)                        mov [pallet_size], rax
   946 000006EC 48C705(40180000)01-                     mov qword [ball_speed], 1
   946 000006F4 000000             
   947 000006F7 C605(58180000)01                        mov byte [catch_power_active], 1
   948 000006FE EB57                                    jmp .finish_capture
   949                                  
   950                                              .activate_laser:
   951 00000700 C605(58180000)00                        mov byte [catch_power_active], 0
   952 00000707 488B05(4F140000)                        mov rax, [default_pallet_size]
   953 0000070E 488905(47140000)                        mov [pallet_size], rax
   954 00000715 48C705(40180000)01-                     mov qword [ball_speed], 1
   954 0000071D 000000             
   955 00000720 C605(65180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   956 00000727 EB2E                                    jmp .finish_capture
   957                                  
   958                                              .activate_split:
   959 00000729 C605(65180000)00                        mov byte [laser_power_active], 0
   960 00000730 C605(58180000)00                        mov byte [catch_power_active], 0
   961 00000737 488B05(4F140000)                        mov rax, [default_pallet_size]
   962 0000073E 488905(47140000)                        mov [pallet_size], rax
   963 00000745 48C705(40180000)01-                     mov qword [ball_speed], 1 
   963 0000074D 000000             
   964 00000750 E8D2000000                              call activate_split_power
   965 00000755 EB00                                    jmp .finish_capture
   966                                  
   967                                              .finish_capture:
   968 00000757 C6430300                                mov byte [rbx + 3], 0
   969                                  
   970                                          .next_letter:
   971 0000075B 48FFC1                              inc rcx
   972 0000075E E9E9FDFFFF                          jmp .move_loop
   973                                  
   974                                      .print_last_letter:
   975                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000763 B801000000          <1>  mov eax, sys_write
    83 00000768 BF01000000          <1>  mov edi, 1
    84 0000076D 48BE-               <1>  mov rsi, %1
    84 0000076F [2B18000000000000]  <1>
    85 00000777 BA10000000          <1>  mov edx, %2
    86 0000077C 0F05                <1>  syscall
   976 0000077E 8A05(2A180000)                  mov al, [last_letter]
   977 00000784 8805(3A180000)                  mov [last_letter_msg + 15], al
   978                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000078A B801000000          <1>  mov eax, sys_write
    83 0000078F BF01000000          <1>  mov edi, 1
    84 00000794 48BE-               <1>  mov rsi, %1
    84 00000796 [3B18000000000000]  <1>
    85 0000079E BA03000000          <1>  mov edx, %2
    86 000007A3 0F05                <1>  syscall
   979                                  
   980                                      .end:
   981 000007A5 415B                            pop r11
   982 000007A7 415A                            pop r10
   983 000007A9 4159                            pop r9
   984 000007AB 4158                            pop r8
   985 000007AD 5E                              pop rsi
   986 000007AE 5F                              pop rdi
   987 000007AF 5B                              pop rbx
   988 000007B0 5D                              pop rbp
   989 000007B1 C3                              ret
   990                                  
   991                                  
   992                                  clear_lasers:
   993 000007B2 55                          push rbp
   994 000007B3 4889E5                      mov  rbp, rsp
   995                                  
   996                                      ; Recorrer el array de láseres
   997 000007B6 4831C9                      xor rcx, rcx                ; Índice del láser
   998 000007B9 480FB61D(67180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   999                                  
  1000                                      .clear_loop:
  1001 000007C1 4839D9                          cmp rcx, rbx
  1002 000007C4 7D2F                            jge .done                ; Salir si no quedan láseres
  1003                                  
  1004                                          ; Obtener posición del láser actual
  1005 000007C6 488DB409[68180000]              lea rsi, [lasers + rcx * 2]
  1006 000007CE 4C0FB606                        movzx r8, byte [rsi]     ; X
  1007 000007D2 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1008                                  
  1009                                          ; Calcular posición en el tablero
  1010 000007D7 B84E000000                      mov rax, column_cells
  1011 000007DC 4883C002                        add rax, 2
  1012 000007E0 49F7E1                          mul r9
  1013 000007E3 4C01C0                          add rax, r8
  1014 000007E6 488DB8[000A0000]                lea rdi, [board + rax]
  1015                                  
  1016                                          ; Borrar el láser visualmente
  1017 000007ED C60720                          mov byte [rdi], ' '
  1018                                  
  1019                                          ; Pasar al siguiente láser
  1020 000007F0 48FFC1                          inc rcx
  1021 000007F3 EBCC                            jmp .clear_loop
  1022                                  
  1023                                      .done:
  1024                                          ; Resetear contador de láseres
  1025 000007F5 C605(67180000)00                mov byte [laser_count], 0
  1026                                  
  1027 000007FC 5D                              pop rbp
  1028 000007FD C3                              ret
  1029                                  
  1030                                  
  1031                                  ; Nueva función para actualizar los láseres
  1032                                  update_lasers:
  1033 000007FE 55                          push rbp
  1034 000007FF 4889E5                      mov rbp, rsp
  1035                                      
  1036                                      ; Verificar si el poder láser está activo
  1037 00000802 803D(65180000)00            cmp byte [laser_power_active], 0
  1038 00000809 741A                        je .end
  1039                                      
  1040                                      ; Verificar si se presionó la tecla de espacio
  1041 0000080B 803D(64180000)20            cmp byte [last_key], ' '
  1042 00000812 750C                        jne .skip_shooting
  1043                                      
  1044                                      ; Disparar nuevos láseres
  1045 00000814 E89A000000                  call shoot_lasers
  1046 00000819 C605(64180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1047                                      
  1048                                      .skip_shooting:
  1049                                      ; Mover los láseres existentes
  1050 00000820 E828010000                  call move_lasers
  1051                                      
  1052                                      .end:
  1053 00000825 5D                              pop rbp
  1054 00000826 C3                              ret
  1055                                  
  1056                                  activate_split_power:
  1057 00000827 55                          push rbp
  1058 00000828 4889E5                      mov rbp, rsp
  1059                                      
  1060                                      ; Verificar si la bola2 y bola3 ya están activas
  1061 0000082B 803D(A2140000)01            cmp byte [ball2_active], 1
  1062 00000832 750B                        jne .enable_balls
  1063 00000834 803D(C4140000)01            cmp byte [ball3_active], 1
  1064 0000083B 7502                        jne .enable_balls
  1065                                      
  1066                                      ; Si ambas ya están activas, no hacemos nada.
  1067 0000083D EB72                        jmp .end
  1068                                  
  1069                                  .enable_balls:
  1070                                      ; Copiamos la posición de la bola principal
  1071 0000083F 488B05(5F140000)            mov rax, [ball_x_pos]
  1072 00000846 488905(81140000)            mov [ball2_x_pos], rax
  1073 0000084D 488905(A3140000)            mov [ball3_x_pos], rax
  1074                                  
  1075 00000854 488B05(67140000)            mov rax, [ball_y_pos]
  1076 0000085B 488905(89140000)            mov [ball2_y_pos], rax
  1077 00000862 488905(AB140000)            mov [ball3_y_pos], rax
  1078                                  
  1079                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1080                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1081 00000869 48C705(91140000)FF-         mov qword [ball2_direction_x], -1
  1081 00000871 FFFFFF             
  1082 00000874 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  1082 0000087C FFFFFF             
  1083 0000087F C605(A1140000)01            mov byte [ball2_moving], 1
  1084 00000886 C605(A2140000)01            mov byte [ball2_active], 1
  1085                                  
  1086 0000088D 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  1086 00000895 000000             
  1087 00000898 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  1087 000008A0 FFFFFF             
  1088 000008A3 C605(C3140000)01            mov byte [ball3_moving], 1
  1089 000008AA C605(C4140000)01            mov byte [ball3_active], 1
  1090                                  
  1091                                  .end:
  1092 000008B1 5D                          pop rbp
  1093 000008B2 C3                          ret
  1094                                  
  1095                                  
  1096                                  shoot_lasers:
  1097 000008B3 55                          push rbp
  1098 000008B4 4889E5                      mov rbp, rsp
  1099 000008B7 53                          push rbx
  1100                                      
  1101                                      ; Verificar si hay espacio para más láseres
  1102 000008B8 480FB605(67180000)          movzx rax, byte [laser_count]
  1103 000008C0 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1104 000008C4 0F8D80000000                jge .end
  1105                                      
  1106                                      ; Obtener posición de la paleta
  1107 000008CA 4C8B05(3F140000)            mov r8, [pallet_position]
  1108 000008D1 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
  1109                                      
  1110                                      ; Calcular coordenadas x,y
  1111 000008D8 4C89C0                      mov rax, r8
  1112 000008DB 41B94E000000                mov r9, column_cells
  1113 000008E1 4983C102                    add r9, 2                     ; Ancho total de línea
  1114 000008E5 4831D2                      xor rdx, rdx
  1115 000008E8 49F7F1                      div r9                        ; rax = y, rdx = x
  1116                                      
  1117                                      ; Guardar coordenadas
  1118 000008EB 4989C2                      mov r10, rax                  ; Y en r10
  1119 000008EE 4989D3                      mov r11, rdx                  ; X en r11
  1120                                      
  1121                                      ; Validar coordenadas
  1122 000008F1 4983FA00                    cmp r10, 0
  1123 000008F5 7C53                        jl .end
  1124 000008F7 4983FA20                    cmp r10, row_cells
  1125 000008FB 7D4D                        jge .end
  1126 000008FD 4983FB00                    cmp r11, 0
  1127 00000901 7C47                        jl .end
  1128 00000903 4983FB4E                    cmp r11, column_cells
  1129 00000907 7D41                        jge .end
  1130                                      
  1131                                      ; Calcular índice para el primer láser
  1132 00000909 480FB61D(67180000)          movzx rbx, byte [laser_count]
  1133 00000911 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1134                                      
  1135                                      ; Primer láser (izquierda)
  1136 00000915 488DBB[68180000]            lea rdi, [lasers + rbx]
  1137 0000091C 44881F                      mov [rdi], r11b              ; X
  1138 0000091F 4488D0                      mov al, r10b
  1139 00000922 FEC8                        dec al                       ; Y - 1
  1140 00000924 884701                      mov [rdi + 1], al           ; Y
  1141                                      
  1142                                      ; Segundo láser (derecha)
  1143 00000927 4488D8                      mov al, r11b
  1144 0000092A 0205(47140000)              add al, byte [pallet_size]
  1145 00000930 FEC8                        dec al                       ; Ajustar para el último carácter
  1146 00000932 488DBB[6A180000]            lea rdi, [lasers + rbx + 2]
  1147 00000939 8807                        mov [rdi], al               ; X
  1148 0000093B 4488D0                      mov al, r10b
  1149 0000093E FEC8                        dec al                      ; Y - 1
  1150 00000940 884701                      mov [rdi + 1], al          ; Y
  1151                                      
  1152                                      ; Incrementar contador de láseres
  1153 00000943 8005(67180000)02            add byte [laser_count], 2
  1154                                      
  1155                                      
  1156                                      .end:
  1157 0000094A 5B                              pop rbx
  1158 0000094B 5D                              pop rbp
  1159 0000094C C3                              ret
  1160                                  
  1161                                  ; Función corregida para mover láseres
  1162                                  ; Función corregida para mover láseres
  1163                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1164                                  
  1165                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1166                                  ; ============================================================
  1167                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1168                                  ; ============================================================
  1169                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1170                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1171                                  ; ============================================================
  1172                                  move_lasers:
  1173 0000094D 55                          push rbp
  1174 0000094E 4889E5                      mov  rbp, rsp
  1175 00000951 53                          push rbx
  1176 00000952 57                          push rdi
  1177 00000953 56                          push rsi
  1178 00000954 4154                        push r12
  1179 00000956 4155                        push r13
  1180 00000958 4156                        push r14
  1181 0000095A 4157                        push r15
  1182                                  
  1183                                      ; 1) Tomamos la cantidad de láseres
  1184 0000095C 480FB60D(67180000)          movzx rcx, byte [laser_count]
  1185 00000964 4885C9                      test rcx, rcx
  1186 00000967 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1187                                  
  1188                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1189 0000096D 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1190                                  
  1191                                  .loop_lasers:
  1192                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1193 00000970 488DB409[68180000]          lea rsi, [lasers + rcx*2]
  1194                                  
  1195                                      ; 2) Cargar x,y actuales del láser
  1196 00000978 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1197 0000097C 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1198                                  
  1199                                      ; 3) Borrar el láser de su posición actual en pantalla
  1200                                      ;    (por si en el ciclo anterior se había dibujado)
  1201 00000981 B84E000000                  mov rax, column_cells
  1202 00000986 4883C002                    add rax, 2
  1203 0000098A 49F7E1                      mul r9
  1204 0000098D 4C01C0                      add rax, r8
  1205 00000990 488DB8[000A0000]            lea rdi, [board + rax]
  1206 00000997 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1207                                  
  1208                                      ; 4) Mover el láser hacia arriba (y - 1)
  1209 0000099A 49FFC9                      dec r9
  1210                                  
  1211                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1212 0000099D 4983F901                    cmp r9, 1
  1213 000009A1 7C57                        jl .delete_laser
  1214                                  
  1215                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1216 000009A3 44884E01                    mov byte [rsi + 1], r9b
  1217                                  
  1218                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1219                                      ;    - Primero colisión con bloques
  1220                                      ; ---------------------------------------------------------
  1221                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1222 000009A7 B84E000000                  mov rax, column_cells
  1223 000009AC 4883C002                    add rax, 2
  1224 000009B0 49F7E1                      mul r9
  1225 000009B3 4C01C0                      add rax, r8
  1226 000009B6 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1227                                  
  1228                                      ; Revisar si hay bloque
  1229 000009BD 51                          push rcx
  1230 000009BE 56                          push rsi
  1231 000009BF 57                          push rdi
  1232 000009C0 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1233 000009C3 E8F60E0000                  call check_block_collision
  1234 000009C8 5F                          pop rdi
  1235 000009C9 5E                          pop rsi
  1236 000009CA 59                          pop rcx
  1237                                  
  1238 000009CB 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1239 000009CE 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1240                                  
  1241                                      ;    - Luego colisión con enemigos
  1242                                      ; ---------------------------------------------------------
  1243 000009D0 51                          push rcx
  1244 000009D1 56                          push rsi
  1245 000009D2 57                          push rdi
  1246                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1247                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1248                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1249                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1250                                      ;
  1251                                      ; Hacemos algo como:
  1252 000009D3 4989FA                      mov r10, rdi
  1253 000009D6 E85A000000                  call check_laser_enemy_collision
  1254 000009DB 5F                          pop rdi
  1255 000009DC 5E                          pop rsi
  1256 000009DD 59                          pop rcx
  1257                                  
  1258 000009DE 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1259 000009E1 7517                        jnz .delete_laser
  1260                                  
  1261                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1262 000009E3 8A05(66180000)              mov al, [laser_symbol]
  1263 000009E9 8807                        mov [rdi], al
  1264                                  
  1265                                  .next_laser:
  1266                                      ; Pasamos al láser anterior en el array
  1267 000009EB 48FFC9                      dec rcx
  1268 000009EE 4883F9FF                    cmp rcx, -1
  1269 000009F2 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1270 000009F8 EB2E                        jmp .fin
  1271                                  
  1272                                  ; -----------------------------------------------------------------
  1273                                  ; Subrutina interna: .delete_laser
  1274                                  ; -----------------------------------------------------------------
  1275                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1276                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1277                                  .delete_laser:
  1278 000009FA 4C0FB625(67180000)          movzx r12, byte [laser_count]
  1279 00000A02 49FFCC                      dec r12                    ; r12 = índice del último láser
  1280 00000A05 4939CC                      cmp r12, rcx
  1281 00000A08 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1282                                  
  1283                                      ; Copiamos el último láser a la posición actual
  1284 00000A0A 488DBC09[68180000]          lea rdi, [lasers + rcx*2]
  1285 00000A12 4B8DB424[68180000]          lea rsi, [lasers + r12*2]
  1286 00000A1A 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1287 00000A1D 668907                      mov [rdi], ax             ; copiamos X,Y
  1288                                  
  1289                                  .just_decrement:
  1290 00000A20 FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1291 00000A26 EBC3                        jmp .next_laser
  1292                                  
  1293                                  .fin:
  1294 00000A28 415F                        pop r15
  1295 00000A2A 415E                        pop r14
  1296 00000A2C 415D                        pop r13
  1297 00000A2E 415C                        pop r12
  1298 00000A30 5E                          pop rsi
  1299 00000A31 5F                          pop rdi
  1300 00000A32 5B                          pop rbx
  1301 00000A33 5D                          pop rbp
  1302 00000A34 C3                          ret
  1303                                  
  1304                                  
  1305                                  ; Nueva función para verificar colisión entre láser y enemigos
  1306                                  ; ==========================================================
  1307                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1308                                  ; ==========================================================
  1309                                  check_laser_enemy_collision:
  1310 00000A35 55                          push rbp
  1311 00000A36 4889E5                      mov  rbp, rsp
  1312                                      
  1313 00000A39 4D31ED                      xor r13, r13            ; Índice del enemigo
  1314 00000A3C 4831C0                      xor rax, rax            ; 0 = no colisión
  1315                                  
  1316                                  .loop_enemies:
  1317 00000A3F 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1318 00000A43 7D64                        jge .end
  1319                                  
  1320                                      ; r13 * 3 => offset del enemigo i
  1321 00000A45 4C89E9                      mov rcx, r13
  1322 00000A48 486BC903                    imul rcx, 3
  1323 00000A4C 488DB1[BD150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1324                                  
  1325                                      ; Verificar si está activo
  1326 00000A53 807E0201                    cmp byte [rsi+2], 1
  1327 00000A57 754B                        jne .next_enemy
  1328                                  
  1329                                      ; Cargar posición X/Y del enemigo
  1330 00000A59 4C0FB636                    movzx r14, byte [rsi]      ; X
  1331 00000A5D 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1332                                  
  1333                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1334 00000A62 4D39F0                      cmp r8, r14
  1335 00000A65 753D                        jne .next_enemy
  1336 00000A67 4D39F9                      cmp r9, r15
  1337 00000A6A 7538                        jne .next_enemy
  1338                                  
  1339                                      ; ==== Colisión detectada con láser ====
  1340                                  
  1341                                      ; 1) Desactivar enemigo
  1342 00000A6C C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1343                                  
  1344                                      ; 2) Sumar puntos
  1345 00000A70 488B05(DC150000)            mov rax, [enemy_points]
  1346 00000A77 480105(9B150000)            add [current_score], rax
  1347                                  
  1348                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1349                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1350 00000A7E 4983FF1E                    cmp r15, row_cells - 2
  1351 00000A82 7419                        je .skip_erase
  1352                                  
  1353                                      ; Borrar visualmente del board
  1354 00000A84 B84E000000                  mov rax, column_cells
  1355 00000A89 4883C002                    add rax, 2
  1356 00000A8D 49F7E7                      mul r15
  1357 00000A90 4C01F0                      add rax, r14
  1358 00000A93 488DB8[000A0000]            lea rdi, [board + rax]
  1359 00000A9A C60720                      mov byte [rdi], ' '
  1360                                  
  1361                                  .skip_erase:
  1362                                  
  1363                                      ; 4) Devolver rax=1 => colisión con enemigo
  1364 00000A9D B801000000                  mov rax, 1
  1365 00000AA2 EB05                        jmp .end
  1366                                  
  1367                                  .next_enemy:
  1368 00000AA4 49FFC5                      inc r13
  1369 00000AA7 EB96                        jmp .loop_enemies
  1370                                  
  1371                                  .end:
  1372 00000AA9 5D                          pop rbp
  1373 00000AAA C3                          ret
  1374                                  
  1375                                  
  1376                                  ; Función auxiliar para eliminar un láser específico
  1377                                  remove_laser:
  1378 00000AAB 55                          push rbp
  1379 00000AAC 4889E5                      mov rbp, rsp
  1380                                  
  1381                                      ; Borrar el láser del tablero
  1382 00000AAF 41C60220                    mov byte [r10], ' '
  1383                                  
  1384                                      ; Mover el último láser a esta posición si no es el último
  1385 00000AB3 480FB605(67180000)          movzx rax, byte [laser_count]
  1386 00000ABB 48FFC8                      dec rax                    ; Índice del último láser
  1387 00000ABE 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1388 00000AC1 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1389                                  
  1390                                      ; Copiar último láser a la posición actual
  1391 00000AC3 4B8DBC24[68180000]          lea rdi, [lasers + r12*2]
  1392 00000ACB 488DB400[68180000]          lea rsi, [lasers + rax*2]
  1393 00000AD3 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1394 00000AD6 668917                      mov [rdi], dx
  1395                                  
  1396                                  .just_decrease:
  1397 00000AD9 FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1398                                  
  1399 00000ADF 5D                          pop rbp
  1400 00000AE0 C3                          ret
  1401                                  
  1402                                  add_life:
  1403 00000AE1 55                          push rbp
  1404 00000AE2 4889E5                      mov rbp, rsp
  1405 00000AE5 53                          push rbx
  1406 00000AE6 51                          push rcx
  1407 00000AE7 57                          push rdi
  1408 00000AE8 56                          push rsi
  1409 00000AE9 4150                        push r8
  1410 00000AEB 4151                        push r9
  1411                                      
  1412                                      ; Verificar si ya tenemos el máximo de vidas
  1413 00000AED 480FB605(98160000)          movzx rax, byte [current_lives]
  1414 00000AF5 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1415 00000AF9 7D2C                        jge .end
  1416                                      
  1417                                      ; Incrementar el contador de vidas
  1418 00000AFB FE05(98160000)              inc byte [current_lives]
  1419                                      
  1420                                      ; Encontrar la siguiente vida inactiva
  1421 00000B01 4831C9                      xor rcx, rcx
  1422                                      
  1423                                      .find_inactive:
  1424 00000B04 4883F907                        cmp rcx, lives_count
  1425 00000B08 7D1D                            jge .end
  1426                                          
  1427                                          ; Calcular offset de la vida actual
  1428 00000B0A 4889C8                          mov rax, rcx
  1429 00000B0D 486BC003                        imul rax, 3
  1430 00000B11 488DB0[82160000]                lea rsi, [lives_data + rax]
  1431                                          
  1432                                          ; Verificar si está inactiva
  1433 00000B18 807E0200                        cmp byte [rsi + 2], 0
  1434 00000B1C 7405                            je .activate_life
  1435                                          
  1436 00000B1E 48FFC1                          inc rcx
  1437 00000B21 EBE1                            jmp .find_inactive
  1438                                          
  1439                                      .activate_life:
  1440                                          ; Activar la vida
  1441 00000B23 C6460201                        mov byte [rsi + 2], 1
  1442                                          
  1443                                      .end:
  1444 00000B27 4159                            pop r9
  1445 00000B29 4158                            pop r8
  1446 00000B2B 5E                              pop rsi
  1447 00000B2C 5F                              pop rdi
  1448 00000B2D 59                              pop rcx
  1449 00000B2E 5B                              pop rbx
  1450 00000B2F 5D                              pop rbp
  1451 00000B30 C3                              ret
  1452                                  
  1453                                  
  1454                                  print_ball:
  1455 00000B31 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1456 00000B38 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1457 00000B3F 4981C0[000A0000]        	add r8, board
  1458                                  
  1459 00000B46 4C89C9                  	mov rcx, r9
  1460 00000B49 B850000000              	mov rax, column_cells + 2
  1461 00000B4E 48F7E9                  	imul rcx
  1462                                  	
  1463 00000B51 4901C0                  	add r8, rax
  1464 00000B54 41C6004F                	mov byte [r8], char_O
  1465 00000B58 C3                      	ret
  1466                                  
  1467                                  print_ball_2:
  1468 00000B59 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1469 00000B60 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1470 00000B67 4981C0[000A0000]            add r8, board
  1471 00000B6E 4C89C9                      mov rcx, r9
  1472 00000B71 B850000000                  mov rax, column_cells + 2
  1473 00000B76 48F7E9                      imul rcx
  1474 00000B79 4901C0                      add r8, rax
  1475 00000B7C 41C6004F                    mov byte [r8], char_O
  1476 00000B80 C3                          ret
  1477                                  
  1478                                  print_ball_3:
  1479 00000B81 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1480 00000B88 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1481 00000B8F 4981C0[000A0000]            add r8, board
  1482 00000B96 4C89C9                      mov rcx, r9
  1483 00000B99 B850000000                  mov rax, column_cells + 2
  1484 00000B9E 48F7E9                      imul rcx
  1485 00000BA1 4901C0                      add r8, rax
  1486 00000BA4 41C6004F                    mov byte [r8], char_O
  1487 00000BA8 C3                          ret
  1488                                  
  1489                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1490                                  	
  1491                                  print_pallet:
  1492                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1493 00000BA9 4C8B05(3F140000)            mov r8, [pallet_position]
  1494 00000BB0 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1495                                      .clear_pallet:
  1496 00000BB7 41C60020                        mov byte [r8], char_space
  1497 00000BBB 49FFC0                          inc r8
  1498 00000BBE 48FFC9                          dec rcx
  1499 00000BC1 75F4                            jnz .clear_pallet
  1500                                  
  1501                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1502 00000BC3 4C8B05(3F140000)            mov r8, [pallet_position]
  1503 00000BCA 488B0D(47140000)            mov rcx, [pallet_size]
  1504                                      .write_pallet:
  1505 00000BD1 41C6003D                        mov byte [r8], char_equal
  1506 00000BD5 49FFC0                          inc r8
  1507 00000BD8 48FFC9                          dec rcx
  1508 00000BDB 75F4                            jnz .write_pallet
  1509                                  
  1510 00000BDD C3                          ret
  1511                                  
  1512                                  move_pallet:
  1513                                      
  1514 00000BDE 803D(7F140000)00            cmp byte [ball_moving], 0
  1515 00000BE5 7507                        jne .continue_movement
  1516 00000BE7 C605(7F140000)01            mov byte [ball_moving], 1
  1517                                  
  1518                                      .continue_movement:
  1519 00000BEE 4883FFFF                        cmp rdi, left_direction
  1520 00000BF2 7531                            jne .move_right
  1521                                  
  1522                                          .move_left:
  1523                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1524 00000BF4 4C8B05(3F140000)                    mov r8, [pallet_position]
  1525 00000BFB 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1526 00000BFE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1527 00000C01 3C58                                cmp al, 'X'        ; Comparar si es una X
  1528 00000C03 744E                                je .end            ; Si es X, no mover
  1529                                              
  1530 00000C05 4C8B05(3F140000)                    mov r8, [pallet_position]
  1531 00000C0C 4C8B0D(47140000)                    mov r9, [pallet_size]
  1532 00000C13 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1533 00000C19 49FFC8                              dec r8
  1534 00000C1C 4C8905(3F140000)                    mov [pallet_position], r8
  1535 00000C23 EB2E                                jmp .end
  1536                                              
  1537                                          .move_right:
  1538                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1539 00000C25 4C8B05(3F140000)                    mov r8, [pallet_position]
  1540 00000C2C 4C8B0D(47140000)                    mov r9, [pallet_size]
  1541 00000C33 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1542 00000C36 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1543 00000C3A 3C58                                cmp al, 'X'        ; Comparar si es una X
  1544 00000C3C 7415                                je .end            ; Si es X, no mover
  1545                                              
  1546 00000C3E 4C8B05(3F140000)                    mov r8, [pallet_position]
  1547 00000C45 41C60020                            mov byte [r8], char_space
  1548 00000C49 49FFC0                              inc r8
  1549 00000C4C 4C8905(3F140000)                    mov [pallet_position], r8
  1550                                          .end:
  1551 00000C53 C3                                  ret
  1552                                  
  1553                                  
  1554                                  
  1555                                              
  1556                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1557                                  update_caught_ball_position:
  1558 00000C54 55                          push rbp
  1559 00000C55 4889E5                      mov rbp, rsp
  1560                                      
  1561                                      ; Calcular la nueva posición de la bola basada en la paleta
  1562 00000C58 4C8B05(3F140000)            mov r8, [pallet_position]
  1563 00000C5F 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1564 00000C66 B850000000                  mov rax, column_cells + 2
  1565 00000C6B 4831D2                      xor rdx, rdx
  1566 00000C6E 48F7F0                      div rax                ; División para obtener X,Y
  1567                                      
  1568                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1569 00000C71 4989C1                      mov r9, rax            ; Y de la paleta
  1570 00000C74 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1571                                      
  1572                                      ; Añadir el offset guardado a la posición X
  1573 00000C77 4889D0                      mov rax, rdx
  1574 00000C7A 480305(5C180000)            add rax, [ball_catch_offset]
  1575 00000C81 488905(5F140000)            mov [ball_x_pos], rax
  1576 00000C88 4C890D(67140000)            mov [ball_y_pos], r9
  1577                                      
  1578 00000C8F 5D                          pop rbp
  1579 00000C90 C3                          ret
  1580                                  
  1581                                  
  1582                                  move_all_balls:
  1583 00000C91 55                          push rbp
  1584 00000C92 4889E5                      mov rbp, rsp
  1585 00000C95 53                          push rbx
  1586                                      
  1587                                      ; Inicializar contador de bolas
  1588 00000C96 4831DB                      xor rbx, rbx
  1589                                      
  1590                                  .loop_balls:
  1591                                      ; Verificar si hemos procesado todas las bolas
  1592 00000C99 3A1D(9B190000)              cmp bl, byte [balls_count]
  1593 00000C9F 7D1D                        jge .end
  1594                                      
  1595                                      ; Calcular offset de la bola actual
  1596 00000CA1 B821000000                  mov rax, BALL_STRUCT_SIZE
  1597 00000CA6 48F7E3                      mul rbx
  1598                                      
  1599                                      ; Verificar si la bola está activa
  1600 00000CA9 80B8[58190000]01            cmp byte [balls_data + rax + 32], 1
  1601 00000CB0 7507                        jne .next_ball
  1602                                      
  1603                                      ; Guardar offset en la pila
  1604 00000CB2 50                          push rax
  1605                                      
  1606                                      ; Llamar a move_ball con los parámetros de esta bola
  1607 00000CB3 E809000000                  call move_ball
  1608                                      
  1609                                      ; Restaurar offset
  1610 00000CB8 58                          pop rax
  1611                                      
  1612                                  .next_ball:
  1613 00000CB9 48FFC3                      inc rbx
  1614 00000CBC EBDB                        jmp .loop_balls
  1615                                      
  1616                                  .end:
  1617 00000CBE 5B                          pop rbx
  1618 00000CBF 5D                          pop rbp
  1619 00000CC0 C3                          ret
  1620                                  
  1621                                  move_ball:
  1622                                  
  1623 00000CC1 803D(59180000)01            cmp byte [ball_caught], 1
  1624 00000CC8 0F849D000000                je .move_with_pallet
  1625                                  
  1626 00000CCE 803D(7F140000)00            cmp byte [ball_moving], 0
  1627 00000CD5 0F84B8010000                je .end
  1628                                  
  1629                                      ; Incrementar contador de velocidad
  1630 00000CDB 48FF05(50180000)            inc qword [speed_counter]
  1631                                      
  1632                                      ; Verificar si debemos mover la bola en este ciclo
  1633 00000CE2 488B05(50180000)            mov rax, [speed_counter]
  1634 00000CE9 483B05(40180000)            cmp rax, [ball_speed]
  1635 00000CF0 0F8C9D010000                jl .end
  1636                                      
  1637                                      ; Resetear contador de velocidad
  1638 00000CF6 48C705(50180000)00-         mov qword [speed_counter], 0
  1638 00000CFE 000000             
  1639                                  
  1640                                      ; Borrar la posición actual de la bola
  1641 00000D01 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1642 00000D08 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1643 00000D0F 4981C0[000A0000]            add r8, board
  1644 00000D16 4C89C9                      mov rcx, r9
  1645 00000D19 B850000000                  mov rax, column_cells + 2
  1646 00000D1E 48F7E9                      imul rcx
  1647 00000D21 4901C0                      add r8, rax
  1648 00000D24 41C60020                    mov byte [r8], char_space
  1649                                  
  1650                                      ; Calcular siguiente posición X
  1651 00000D28 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1652 00000D2F 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1653 00000D36 488B05(6F140000)            mov rax, [ball_direction_x]
  1654 00000D3D 4901C0                      add r8, rax               ; Nueva posición X
  1655                                  
  1656                                      ; Calcular la dirección de memoria para la siguiente posición
  1657 00000D40 4D89C2                      mov r10, r8
  1658 00000D43 4981C2[000A0000]            add r10, board
  1659 00000D4A 4C89C9                      mov rcx, r9
  1660 00000D4D B850000000                  mov rax, column_cells + 2
  1661 00000D52 48F7E9                      imul rcx
  1662 00000D55 4901C2                      add r10, rax
  1663                                  
  1664                                      ; Verificar si hay una X en la siguiente posición X
  1665 00000D58 418A02                      mov al, [r10]
  1666 00000D5B 3C58                        cmp al, 'X'
  1667 00000D5D 7565                        jne .check_block_x
  1668 00000D5F 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1669 00000D66 E928010000                  jmp .end
  1670                                  
  1671                                      .move_with_pallet:
  1672                                          ; Borrar la posición actual de la bola
  1673 00000D6B 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1674 00000D72 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1675 00000D79 4D89C2                          mov r10, r8
  1676 00000D7C 4981C2[000A0000]                add r10, board
  1677 00000D83 4C89C9                          mov rcx, r9
  1678 00000D86 B850000000                      mov rax, column_cells + 2
  1679 00000D8B 48F7E9                          imul rcx
  1680 00000D8E 4901C2                          add r10, rax
  1681 00000D91 41C60220                        mov byte [r10], char_space
  1682                                  
  1683                                          ; Actualizar posición X basada en la paleta
  1684 00000D95 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1685 00000D9C 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1686 00000DA3 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1687 00000DAA 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1688                                  
  1689                                          ; Mantener la bola una posición arriba de la paleta
  1690 00000DB1 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1691 00000DB8 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1692                                  
  1693 00000DBF E9CF000000                      jmp .end
  1694                                  
  1695                                  
  1696                                      .check_block_x:
  1697                                          ; Verificar colisión con bloques en X
  1698 00000DC4 4150                            push r8     ; Guardar registros que usa check_block_collision
  1699 00000DC6 4151                            push r9
  1700 00000DC8 4152                            push r10
  1701 00000DCA E8EF0A0000                      call check_block_collision
  1702 00000DCF 415A                            pop r10
  1703 00000DD1 4159                            pop r9
  1704 00000DD3 4158                            pop r8
  1705 00000DD5 4885C0                          test rax, rax
  1706 00000DD8 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1707 00000DDA 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1708 00000DE1 E9AD000000                      jmp .end
  1709                                  
  1710                                      .check_paddle_x:
  1711                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1712 00000DE6 41803A3D                        cmp byte [r10], char_equal
  1713 00000DEA 750C                            jne .check_y_movement
  1714 00000DEC 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1715 00000DF3 E99B000000                      jmp .end
  1716                                  
  1717                                      .check_y_movement:
  1718                                          ; Calcular siguiente posición Y
  1719 00000DF8 488B05(77140000)                mov rax, [ball_direction_y]
  1720 00000DFF 4901C1                          add r9, rax                  ; Nueva posición Y
  1721                                  
  1722                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1723 00000E02 4D89C2                          mov r10, r8
  1724 00000E05 4981C2[000A0000]                add r10, board
  1725 00000E0C 4C89C9                          mov rcx, r9
  1726 00000E0F B850000000                      mov rax, column_cells + 2
  1727 00000E14 48F7E9                          imul rcx
  1728 00000E17 4901C2                          add r10, rax
  1729                                  
  1730                                          ; Verificar si hay una X en la siguiente posición Y
  1731 00000E1A 418A02                          mov al, [r10]
  1732 00000E1D 3C58                            cmp al, 'X'
  1733 00000E1F 7509                            jne .check_block_y
  1734 00000E21 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1735 00000E28 EB69                            jmp .end
  1736                                  
  1737                                      .check_block_y:
  1738                                          ; Verificar colisión con bloques en Y
  1739 00000E2A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1740 00000E2C 4151                            push r9
  1741 00000E2E 4152                            push r10
  1742 00000E30 E8890A0000                      call check_block_collision
  1743 00000E35 415A                            pop r10
  1744 00000E37 4159                            pop r9
  1745 00000E39 4158                            pop r8
  1746 00000E3B 4885C0                          test rax, rax
  1747 00000E3E 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1748 00000E40 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1749 00000E47 EB4A                            jmp .end
  1750                                  
  1751                                      .check_paddle_y:
  1752                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1753 00000E49 41803A3D                        cmp byte [r10], char_equal
  1754 00000E4D 7536                            jne .update_position
  1755                                  
  1756                                          ; Verificar si el poder catch está activo
  1757 00000E4F 803D(58180000)01                cmp byte [catch_power_active], 1
  1758 00000E56 7524                            jne .normal_bounce
  1759                                  
  1760                                          ; Activar el modo "atrapado"
  1761 00000E58 C605(59180000)01                mov byte [ball_caught], 1
  1762                                          
  1763                                          ; Guardar la posición X actual de la bola como offset
  1764 00000E5F 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1765 00000E66 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1766 00000E6D 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1767 00000E73 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1768                                          
  1769 00000E7A EB17                            jmp .end
  1770                                  
  1771                                      .normal_bounce:
  1772 00000E7C 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1773 00000E83 EB0E                            jmp .end
  1774                                  
  1775                                  
  1776                                      .update_position:
  1777 00000E85 4C8905(5F140000)                mov [ball_x_pos], r8
  1778 00000E8C 4C890D(67140000)                mov [ball_y_pos], r9
  1779                                  
  1780                                      .end:
  1781 00000E93 C3                              ret
  1782                                  
  1783                                  
  1784                                  move_ball_2:
  1785                                  
  1786 00000E94 803D(5A180000)01            cmp byte [ball_caught_2], 1
  1787 00000E9B 0F849D000000                je .move_with_pallet
  1788                                  
  1789 00000EA1 803D(A1140000)00            cmp byte [ball2_moving], 0
  1790 00000EA8 0F84B8010000                je .end
  1791                                  
  1792                                      ; Incrementar contador de velocidad
  1793 00000EAE 48FF05(50180000)            inc qword [speed_counter]
  1794                                      
  1795                                      ; Verificar si debemos mover la bola en este ciclo
  1796 00000EB5 488B05(50180000)            mov rax, [speed_counter]
  1797 00000EBC 483B05(40180000)            cmp rax, [ball_speed]
  1798 00000EC3 0F8C9D010000                jl .end
  1799                                      
  1800                                      ; Resetear contador de velocidad
  1801 00000EC9 48C705(50180000)00-         mov qword [speed_counter], 0
  1801 00000ED1 000000             
  1802                                  
  1803                                      ; Borrar la posición actual de la bola
  1804 00000ED4 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1805 00000EDB 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1806 00000EE2 4981C0[000A0000]            add r8, board
  1807 00000EE9 4C89C9                      mov rcx, r9
  1808 00000EEC B850000000                  mov rax, column_cells + 2
  1809 00000EF1 48F7E9                      imul rcx
  1810 00000EF4 4901C0                      add r8, rax
  1811 00000EF7 41C60020                    mov byte [r8], char_space
  1812                                  
  1813                                      ; Calcular siguiente posición X
  1814 00000EFB 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1815 00000F02 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1816 00000F09 488B05(91140000)            mov rax, [ball2_direction_x]
  1817 00000F10 4901C0                      add r8, rax               ; Nueva posición X
  1818                                  
  1819                                      ; Calcular la dirección de memoria para la siguiente posición
  1820 00000F13 4D89C2                      mov r10, r8
  1821 00000F16 4981C2[000A0000]            add r10, board
  1822 00000F1D 4C89C9                      mov rcx, r9
  1823 00000F20 B850000000                  mov rax, column_cells + 2
  1824 00000F25 48F7E9                      imul rcx
  1825 00000F28 4901C2                      add r10, rax
  1826                                  
  1827                                      ; Verificar si hay una X en la siguiente posición X
  1828 00000F2B 418A02                      mov al, [r10]
  1829 00000F2E 3C58                        cmp al, 'X'
  1830 00000F30 7565                        jne .check_block_x
  1831 00000F32 48F71D(91140000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1832 00000F39 E928010000                  jmp .end
  1833                                  
  1834                                      .move_with_pallet:
  1835                                          ; Borrar la posición actual de la bola
  1836 00000F3E 4C8B05(81140000)                mov r8, [ball2_x_pos]
  1837 00000F45 4C8B0D(89140000)                mov r9, [ball2_y_pos]
  1838 00000F4C 4D89C2                          mov r10, r8
  1839 00000F4F 4981C2[000A0000]                add r10, board
  1840 00000F56 4C89C9                          mov rcx, r9
  1841 00000F59 B850000000                      mov rax, column_cells + 2
  1842 00000F5E 48F7E9                          imul rcx
  1843 00000F61 4901C2                          add r10, rax
  1844 00000F64 41C60220                        mov byte [r10], char_space
  1845                                  
  1846                                          ; Actualizar posición X basada en la paleta
  1847 00000F68 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1848 00000F6F 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1849 00000F76 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1850 00000F7D 4C8905(81140000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1851                                  
  1852                                          ; Mantener la bola una posición arriba de la paleta
  1853 00000F84 4C8B0D(89140000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1854 00000F8B 4C890D(89140000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1855                                  
  1856 00000F92 E9CF000000                      jmp .end
  1857                                  
  1858                                  
  1859                                      .check_block_x:
  1860                                          ; Verificar colisión con bloques en X
  1861 00000F97 4150                            push r8     ; Guardar registros que usa check_block_collision
  1862 00000F99 4151                            push r9
  1863 00000F9B 4152                            push r10
  1864 00000F9D E81C090000                      call check_block_collision
  1865 00000FA2 415A                            pop r10
  1866 00000FA4 4159                            pop r9
  1867 00000FA6 4158                            pop r8
  1868 00000FA8 4885C0                          test rax, rax
  1869 00000FAB 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1870 00000FAD 48F71D(91140000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1871 00000FB4 E9AD000000                      jmp .end
  1872                                  
  1873                                      .check_paddle_x:
  1874                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1875 00000FB9 41803A3D                        cmp byte [r10], char_equal
  1876 00000FBD 750C                            jne .check_y_movement
  1877 00000FBF 48F71D(91140000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1878 00000FC6 E99B000000                      jmp .end
  1879                                  
  1880                                      .check_y_movement:
  1881                                          ; Calcular siguiente posición Y
  1882 00000FCB 488B05(99140000)                mov rax, [ball2_direction_y]
  1883 00000FD2 4901C1                          add r9, rax                  ; Nueva posición Y
  1884                                  
  1885                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1886 00000FD5 4D89C2                          mov r10, r8
  1887 00000FD8 4981C2[000A0000]                add r10, board
  1888 00000FDF 4C89C9                          mov rcx, r9
  1889 00000FE2 B850000000                      mov rax, column_cells + 2
  1890 00000FE7 48F7E9                          imul rcx
  1891 00000FEA 4901C2                          add r10, rax
  1892                                  
  1893                                          ; Verificar si hay una X en la siguiente posición Y
  1894 00000FED 418A02                          mov al, [r10]
  1895 00000FF0 3C58                            cmp al, 'X'
  1896 00000FF2 7509                            jne .check_block_y
  1897 00000FF4 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1898 00000FFB EB69                            jmp .end
  1899                                  
  1900                                      .check_block_y:
  1901                                          ; Verificar colisión con bloques en Y
  1902 00000FFD 4150                            push r8     ; Guardar registros que usa check_block_collision
  1903 00000FFF 4151                            push r9
  1904 00001001 4152                            push r10
  1905 00001003 E8B6080000                      call check_block_collision
  1906 00001008 415A                            pop r10
  1907 0000100A 4159                            pop r9
  1908 0000100C 4158                            pop r8
  1909 0000100E 4885C0                          test rax, rax
  1910 00001011 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1911 00001013 48F71D(99140000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1912 0000101A EB4A                            jmp .end
  1913                                  
  1914                                      .check_paddle_y:
  1915                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1916 0000101C 41803A3D                        cmp byte [r10], char_equal
  1917 00001020 7536                            jne .update_position
  1918                                  
  1919                                          ; Verificar si el poder catch está activo
  1920 00001022 803D(58180000)01                cmp byte [catch_power_active], 1
  1921 00001029 7524                            jne .normal_bounce
  1922                                  
  1923                                          ; Activar el modo "atrapado"
  1924 0000102B C605(5A180000)01                mov byte [ball_caught_2], 1
  1925                                          
  1926                                          ; Guardar la posición X actual de la bola como offset
  1927 00001032 488B05(81140000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  1928 00001039 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1929 00001040 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1930 00001046 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1931                                          
  1932 0000104D EB17                            jmp .end
  1933                                  
  1934                                      .normal_bounce:
  1935 0000104F 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  1936 00001056 EB0E                            jmp .end
  1937                                  
  1938                                  
  1939                                      .update_position:
  1940 00001058 4C8905(81140000)                mov [ball2_x_pos], r8
  1941 0000105F 4C890D(89140000)                mov [ball2_y_pos], r9
  1942                                  
  1943                                      .end:
  1944 00001066 C3                              ret
  1945                                  
  1946                                  move_ball_3:
  1947                                  
  1948 00001067 803D(5B180000)01            cmp byte [ball_caught_3], 1
  1949 0000106E 0F849D000000                je .move_with_pallet
  1950                                  
  1951 00001074 803D(C3140000)00            cmp byte [ball3_moving], 0
  1952 0000107B 0F84B8010000                je .end
  1953                                  
  1954                                      ; Incrementar contador de velocidad
  1955 00001081 48FF05(50180000)            inc qword [speed_counter]
  1956                                      
  1957                                      ; Verificar si debemos mover la bola en este ciclo
  1958 00001088 488B05(50180000)            mov rax, [speed_counter]
  1959 0000108F 483B05(40180000)            cmp rax, [ball_speed]
  1960 00001096 0F8C9D010000                jl .end
  1961                                      
  1962                                      ; Resetear contador de velocidad
  1963 0000109C 48C705(50180000)00-         mov qword [speed_counter], 0
  1963 000010A4 000000             
  1964                                  
  1965                                      ; Borrar la posición actual de la bola
  1966 000010A7 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1967 000010AE 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1968 000010B5 4981C0[000A0000]            add r8, board
  1969 000010BC 4C89C9                      mov rcx, r9
  1970 000010BF B850000000                  mov rax, column_cells + 2
  1971 000010C4 48F7E9                      imul rcx
  1972 000010C7 4901C0                      add r8, rax
  1973 000010CA 41C60020                    mov byte [r8], char_space
  1974                                  
  1975                                      ; Calcular siguiente posición X
  1976 000010CE 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1977 000010D5 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1978 000010DC 488B05(B3140000)            mov rax, [ball3_direction_x]
  1979 000010E3 4901C0                      add r8, rax               ; Nueva posición X
  1980                                  
  1981                                      ; Calcular la dirección de memoria para la siguiente posición
  1982 000010E6 4D89C2                      mov r10, r8
  1983 000010E9 4981C2[000A0000]            add r10, board
  1984 000010F0 4C89C9                      mov rcx, r9
  1985 000010F3 B850000000                  mov rax, column_cells + 2
  1986 000010F8 48F7E9                      imul rcx
  1987 000010FB 4901C2                      add r10, rax
  1988                                  
  1989                                      ; Verificar si hay una X en la siguiente posición X
  1990 000010FE 418A02                      mov al, [r10]
  1991 00001101 3C58                        cmp al, 'X'
  1992 00001103 7565                        jne .check_block_x
  1993 00001105 48F71D(B3140000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  1994 0000110C E928010000                  jmp .end
  1995                                  
  1996                                      .move_with_pallet:
  1997                                          ; Borrar la posición actual de la bola
  1998 00001111 4C8B05(A3140000)                mov r8, [ball3_x_pos]
  1999 00001118 4C8B0D(AB140000)                mov r9, [ball3_y_pos]
  2000 0000111F 4D89C2                          mov r10, r8
  2001 00001122 4981C2[000A0000]                add r10, board
  2002 00001129 4C89C9                          mov rcx, r9
  2003 0000112C B850000000                      mov rax, column_cells + 2
  2004 00001131 48F7E9                          imul rcx
  2005 00001134 4901C2                          add r10, rax
  2006 00001137 41C60220                        mov byte [r10], char_space
  2007                                  
  2008                                          ; Actualizar posición X basada en la paleta
  2009 0000113B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2010 00001142 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2011 00001149 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2012 00001150 4C8905(A3140000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2013                                  
  2014                                          ; Mantener la bola una posición arriba de la paleta
  2015 00001157 4C8B0D(AB140000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2016 0000115E 4C890D(AB140000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2017                                  
  2018 00001165 E9CF000000                      jmp .end
  2019                                  
  2020                                  
  2021                                      .check_block_x:
  2022                                          ; Verificar colisión con bloques en X
  2023 0000116A 4150                            push r8     ; Guardar registros que usa check_block_collision
  2024 0000116C 4151                            push r9
  2025 0000116E 4152                            push r10
  2026 00001170 E849070000                      call check_block_collision
  2027 00001175 415A                            pop r10
  2028 00001177 4159                            pop r9
  2029 00001179 4158                            pop r8
  2030 0000117B 4885C0                          test rax, rax
  2031 0000117E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2032 00001180 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2033 00001187 E9AD000000                      jmp .end
  2034                                  
  2035                                      .check_paddle_x:
  2036                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2037 0000118C 41803A3D                        cmp byte [r10], char_equal
  2038 00001190 750C                            jne .check_y_movement
  2039 00001192 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2040 00001199 E99B000000                      jmp .end
  2041                                  
  2042                                      .check_y_movement:
  2043                                          ; Calcular siguiente posición Y
  2044 0000119E 488B05(BB140000)                mov rax, [ball3_direction_y]
  2045 000011A5 4901C1                          add r9, rax                  ; Nueva posición Y
  2046                                  
  2047                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2048 000011A8 4D89C2                          mov r10, r8
  2049 000011AB 4981C2[000A0000]                add r10, board
  2050 000011B2 4C89C9                          mov rcx, r9
  2051 000011B5 B850000000                      mov rax, column_cells + 2
  2052 000011BA 48F7E9                          imul rcx
  2053 000011BD 4901C2                          add r10, rax
  2054                                  
  2055                                          ; Verificar si hay una X en la siguiente posición Y
  2056 000011C0 418A02                          mov al, [r10]
  2057 000011C3 3C58                            cmp al, 'X'
  2058 000011C5 7509                            jne .check_block_y
  2059 000011C7 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2060 000011CE EB69                            jmp .end
  2061                                  
  2062                                      .check_block_y:
  2063                                          ; Verificar colisión con bloques en Y
  2064 000011D0 4150                            push r8     ; Guardar registros que usa check_block_collision
  2065 000011D2 4151                            push r9
  2066 000011D4 4152                            push r10
  2067 000011D6 E8E3060000                      call check_block_collision
  2068 000011DB 415A                            pop r10
  2069 000011DD 4159                            pop r9
  2070 000011DF 4158                            pop r8
  2071 000011E1 4885C0                          test rax, rax
  2072 000011E4 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2073 000011E6 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2074 000011ED EB4A                            jmp .end
  2075                                  
  2076                                      .check_paddle_y:
  2077                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2078 000011EF 41803A3D                        cmp byte [r10], char_equal
  2079 000011F3 7536                            jne .update_position
  2080                                  
  2081                                          ; Verificar si el poder catch está activo
  2082 000011F5 803D(58180000)01                cmp byte [catch_power_active], 1
  2083 000011FC 7524                            jne .normal_bounce
  2084                                  
  2085                                          ; Activar el modo "atrapado"
  2086 000011FE C605(5B180000)01                mov byte [ball_caught_3], 1
  2087                                          
  2088                                          ; Guardar la posición X actual de la bola como offset
  2089 00001205 488B05(A3140000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2090 0000120C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2091 00001213 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2092 00001219 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2093                                          
  2094 00001220 EB17                            jmp .end
  2095                                  
  2096                                      .normal_bounce:
  2097 00001222 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2098 00001229 EB0E                            jmp .end
  2099                                  
  2100                                  
  2101                                      .update_position:
  2102 0000122B 4C8905(A3140000)                mov [ball3_x_pos], r8
  2103 00001232 4C890D(AB140000)                mov [ball3_y_pos], r9
  2104                                  
  2105                                      .end:
  2106 00001239 C3                              ret
  2107                                  
  2108                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2109                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2110                                  process_catch_release:
  2111 0000123A 55                          push rbp
  2112 0000123B 4889E5                      mov  rbp, rsp
  2113                                  
  2114                                      ; Verificar si el poder está activo
  2115 0000123E 803D(58180000)01            cmp byte [catch_power_active], 1
  2116 00001245 0F8586000000                jne .no_catch_power
  2117                                  
  2118                                      ; Verificar si se presionó 'c'
  2119 0000124B 803D(64180000)63            cmp byte [last_key], 'c'
  2120 00001252 757D                        jne .no_catch_power
  2121                                  
  2122                                      ; Ahora revisamos bola 1
  2123 00001254 803D(59180000)01            cmp byte [ball_caught], 1
  2124 0000125B 751F                        jne .check_ball2
  2125                                      ; Suelta la bola 1
  2126 0000125D C605(59180000)00            mov byte [ball_caught], 0
  2127 00001264 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  2127 0000126C 000000             
  2128 0000126F 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  2128 00001277 FFFFFF             
  2129 0000127A EB4E                        jmp .finish
  2130                                  
  2131                                  .check_ball2:
  2132 0000127C 803D(5A180000)01            cmp byte [ball_caught_2], 1
  2133 00001283 751F                        jne .check_ball3
  2134                                      ; Suelta la bola 2
  2135 00001285 C605(5A180000)00            mov byte [ball_caught_2], 0
  2136 0000128C 48C705(91140000)01-         mov qword [ball2_direction_x], 1
  2136 00001294 000000             
  2137 00001297 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  2137 0000129F FFFFFF             
  2138 000012A2 EB26                        jmp .finish
  2139                                  
  2140                                  .check_ball3:
  2141 000012A4 803D(5B180000)01            cmp byte [ball_caught_3], 1
  2142 000012AB 751D                        jne .finish
  2143                                      ; Suelta la bola 3
  2144 000012AD C605(5B180000)00            mov byte [ball_caught_3], 0
  2145 000012B4 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  2145 000012BC 000000             
  2146 000012BF 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  2146 000012C7 FFFFFF             
  2147                                  
  2148                                  .finish:
  2149                                      ; Limpiar la tecla
  2150 000012CA C605(64180000)00            mov byte [last_key], 0
  2151                                  
  2152                                  .no_catch_power:
  2153 000012D1 5D                          pop rbp
  2154 000012D2 C3                          ret
  2155                                  
  2156                                  
  2157                                  
  2158                                  display_level_number:
  2159 000012D3 55                          push rbp
  2160 000012D4 4889E5                      mov rbp, rsp
  2161                                      
  2162                                      ; Limpiar la pantalla primero
  2163                                      print clear, clear_length
    82 000012D7 B801000000          <1>  mov eax, sys_write
    83 000012DC BF01000000          <1>  mov edi, 1
    84 000012E1 48BE-               <1>  mov rsi, %1
    84 000012E3 [1000000000000000]  <1>
    85 000012EB BA07000000          <1>  mov edx, %2
    86 000012F0 0F05                <1>  syscall
  2164                                      
  2165                                      ; Calcular la posición central para el mensaje
  2166                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2167 000012F2 B84E000000                  mov rax, column_cells
  2168 000012F7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2169 000012FB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2170                                      
  2171                                      ; Calcular la fila central
  2172 000012FE BB20000000                  mov rbx, row_cells
  2173 00001303 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2174                                      
  2175                                      ; Calcular el offset en el buffer
  2176 00001306 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2177 0000130B 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2178 0000130E 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2179                                      
  2180                                      ; Escribir "NIVEL " en la posición calculada
  2181 00001311 488DB8[000A0000]            lea rdi, [board + rax]
  2182 00001318 48BE-                       mov rsi, level_msg
  2182 0000131A [2414000000000000] 
  2183 00001322 B906000000                  mov rcx, level_msg_len
  2184 00001327 F3A4                        rep movsb
  2185                                      
  2186                                      ; Escribir el número del nivel
  2187 00001329 8A05(F9140000)              mov al, [current_level]
  2188 0000132F 0430                        add al, '0'                 ; convertir a ASCII
  2189 00001331 8807                        mov [rdi], al
  2190                                      
  2191                                      ; Mostrar el board con el mensaje
  2192                                      print board, board_size
    82 00001333 B801000000          <1>  mov eax, sys_write
    83 00001338 BF01000000          <1>  mov edi, 1
    84 0000133D 48BE-               <1>  mov rsi, %1
    84 0000133F [000A000000000000]  <1>
    85 00001347 BA000A0000          <1>  mov edx, %2
    86 0000134C 0F05                <1>  syscall
  2193                                      
  2194                                      ; Esperar un segundo
  2195 0000134E B823000000                  mov rax, sys_nanosleep
  2196 00001353 48BF-                       mov rdi, level_display_time
  2196 00001355 [2F14000000000000] 
  2197 0000135D 4831F6                      xor rsi, rsi
  2198 00001360 0F05                        syscall
  2199                                      
  2200 00001362 5D                          pop rbp
  2201 00001363 C3                          ret
  2202                                  
  2203                                  ; Función para inicializar un tablero vacío
  2204                                  init_empty_board:
  2205 00001364 56                          push rsi
  2206 00001365 57                          push rdi
  2207 00001366 51                          push rcx
  2208 00001367 50                          push rax
  2209                                  
  2210 00001368 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2211 0000136F 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2212 00001376 B9000A0000                  mov rcx, board_template_size
  2213 0000137B F3A4                        rep movsb                   ; Copiar el tablero
  2214                                  
  2215 0000137D 58                          pop rax
  2216 0000137E 59                          pop rcx
  2217 0000137F 5F                          pop rdi
  2218 00001380 5E                          pop rsi
  2219 00001381 C3                          ret
  2220                                  
  2221                                  
  2222                                  init_level:
  2223                                            ; Asegurarse que las otras bolas están desactivadas
  2224 00001382 C605(A2140000)00            mov byte [ball2_active], 0
  2225 00001389 C605(C4140000)00            mov byte [ball3_active], 0
  2226 00001390 C605(65180000)00            mov byte [laser_power_active], 0
  2227 00001397 E816F4FFFF                  call clear_lasers
  2228 0000139C 488B05(4F140000)            mov rax, [default_pallet_size]
  2229 000013A3 488905(47140000)            mov [pallet_size], rax
  2230 000013AA 48C705(40180000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2230 000013B2 000000             
  2231                                  
  2232                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2233                                          ; Reiniciar letras activas
  2234 000013B5 488D3D(99160000)            lea rdi, [letters_map]
  2235 000013BC B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2236 000013C1 4831C0                      xor rax, rax
  2237 000013C4 F3AA                        rep stosb                    ; Llenar con ceros
  2238                                      
  2239                                      ; Inicializar dirección de la bola (derecha y arriba)
  2240 000013C6 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2240 000013CE 000000             
  2241 000013D1 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2241 000013D9 FFFFFF             
  2242                                  
  2243                                  
  2244                                      ; Reiniciar contador de letras activas
  2245 000013DC 4831C0                      xor rax, rax
  2246 000013DF 8805(29180000)              mov [letters_count], al
  2247                                  
  2248                                      ; Reiniciar última letra capturada
  2249 000013E5 C605(2A180000)20            mov byte [last_letter], ' '
  2250 000013EC C605(A3150000)00            mov byte [destroyed_blocks], 0 
  2251 000013F3 E86CFFFFFF                  call init_empty_board
  2252 000013F8 E8D6FEFFFF                  call display_level_number
  2253 000013FD E8E5050000                  call init_enemies
  2254                                      
  2255 00001402 56                          push rsi
  2256 00001403 57                          push rdi
  2257 00001404 51                          push rcx
  2258 00001405 50                          push rax
  2259                                  
  2260 00001406 488D35(00000000)            lea rsi, [board_template]
  2261 0000140D 488D3D(000A0000)            lea rdi, [board]
  2262 00001414 B9000A0000                  mov rcx, board_template_size
  2263 00001419 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2264                                  
  2265 0000141B 58                          pop rax
  2266 0000141C 59                          pop rcx
  2267 0000141D 5F                          pop rdi
  2268 0000141E 5E                          pop rsi
  2269                                  
  2270 0000141F B90A000000                  mov rcx, 10
  2271 00001424 4831C0                      xor rax, rax
  2272 00001427 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2273 0000142E F3AA                        rep stosb      
  2274                                  
  2275                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2276 00001430 803D(F9140000)01            cmp byte [current_level], 1
  2277 00001437 7431                        je .level1
  2278 00001439 803D(F9140000)02            cmp byte [current_level], 2
  2279 00001440 7454                        je .level2
  2280 00001442 803D(F9140000)03            cmp byte [current_level], 3
  2281 00001449 7477                        je .level3
  2282 0000144B 803D(F9140000)04            cmp byte [current_level], 4
  2283 00001452 0F8492000000                je .level4
  2284 00001458 803D(F9140000)05            cmp byte [current_level], 5
  2285 0000145F 0F84AD000000                je .level5
  2286 00001465 E9D0000000                  jmp .done
  2287                                  
  2288                                  
  2289                                  
  2290                                      .level1:
  2291 0000146A C605(FA140000)08                mov byte [blocks_remaining], level1_blocks_count
  2292 00001471 4831C9                          xor rcx, rcx             
  2293                                          .init_loop1:
  2294 00001474 4883F908                            cmp rcx, level1_blocks_count
  2295 00001478 0F8DBC000000                        jge .done
  2296 0000147E 4889C8                              mov rax, rcx         
  2297 00001481 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2298 00001485 8A90[FE140000]                      mov dl, byte [level1_blocks + rax + 3]  
  2299 0000148B 8891[37150000]                      mov byte [block_states + rcx], dl
  2300 00001491 48FFC1                              inc rcx
  2301 00001494 EBDE                                jmp .init_loop1
  2302                                  
  2303                                      .level2:
  2304 00001496 C605(FA140000)01                mov byte [blocks_remaining], level2_blocks_count
  2305 0000149D 4831C9                          xor rcx, rcx             
  2306                                          .init_loop2:
  2307 000014A0 4883F901                            cmp rcx, level2_blocks_count
  2308 000014A4 0F8D90000000                        jge .done
  2309 000014AA 4889C8                              mov rax, rcx         
  2310 000014AD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2311 000014B1 8A90[26150000]                      mov dl, byte [level2_blocks + rax + 3]  
  2312 000014B7 8891[37150000]                      mov byte [block_states + rcx], dl
  2313 000014BD 48FFC1                              inc rcx
  2314 000014C0 EBDE                                jmp .init_loop2
  2315                                      .level3:
  2316 000014C2 C605(FA140000)01                mov byte [blocks_remaining], level3_blocks_count
  2317 000014C9 4831C9                          xor rcx, rcx             
  2318                                          .init_loop3:
  2319 000014CC 4883F901                            cmp rcx, level3_blocks_count
  2320 000014D0 7D68                                jge .done
  2321 000014D2 4889C8                              mov rax, rcx         
  2322 000014D5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2323 000014D9 8A90[2B150000]                      mov dl, byte [level3_blocks + rax + 3]  
  2324 000014DF 8891[37150000]                      mov byte [block_states + rcx], dl
  2325 000014E5 48FFC1                              inc rcx
  2326 000014E8 EBE2                                jmp .init_loop3
  2327                                  
  2328                                      .level4:
  2329 000014EA C605(FA140000)01                mov byte [blocks_remaining], level4_blocks_count
  2330 000014F1 4831C9                          xor rcx, rcx             
  2331                                          .init_loop4:
  2332 000014F4 4883F901                            cmp rcx, level4_blocks_count
  2333 000014F8 7D40                                jge .done
  2334 000014FA 4889C8                              mov rax, rcx         
  2335 000014FD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2336 00001501 8A90[30150000]                      mov dl, byte [level4_blocks + rax + 3]  
  2337 00001507 8891[37150000]                      mov byte [block_states + rcx], dl
  2338 0000150D 48FFC1                              inc rcx
  2339 00001510 EBE2                                jmp .init_loop4
  2340                                  
  2341                                      .level5:
  2342 00001512 C605(FA140000)01                mov byte [blocks_remaining], level5_blocks_count
  2343 00001519 4831C9                          xor rcx, rcx             
  2344                                          .init_loop5:
  2345 0000151C 4883F901                            cmp rcx, level5_blocks_count
  2346 00001520 7D18                                jge .done
  2347 00001522 4889C8                              mov rax, rcx         
  2348 00001525 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2349 00001529 8A90[35150000]                      mov dl, byte [level5_blocks + rax + 3]  
  2350 0000152F 8891[37150000]                      mov byte [block_states + rcx], dl
  2351 00001535 48FFC1                              inc rcx
  2352 00001538 EBE2                                jmp .init_loop5
  2353                                      .done:
  2354 0000153A C3                              ret
  2355                                  
  2356                                  
  2357                                  ; Función para verificar y manejar la transición de nivel
  2358                                  check_level_complete:
  2359                                      ; Verificar si quedan bloques
  2360 0000153B 803D(FA140000)00            cmp byte [blocks_remaining], 0
  2361 00001542 753C                        jne .not_complete
  2362                                      
  2363                                      ; Incrementar el nivel
  2364 00001544 FE05(F9140000)              inc byte [current_level]
  2365                                      
  2366                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2367 0000154A 803D(F9140000)06            cmp byte [current_level], 6
  2368 00001551 742E                        je game_win
  2369                                      
  2370                                      ; Reinicializar el juego para el siguiente nivel
  2371 00001553 E82AFEFFFF                  call init_level
  2372                                      
  2373                                      ; Reinicializar la posición de la bola y la paleta
  2374 00001558 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  2374 00001560 000000             
  2375 00001563 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  2375 0000156B 000000             
  2376 0000156E C605(7F140000)00            mov byte [ball_moving], 0
  2377 00001575 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2377 0000157C [36130000]         
  2378                                      
  2379                                      .not_complete:
  2380 00001580 C3                              ret
  2381                                  
  2382                                      ; Nueva función para manejar la victoria del juego
  2383                                  game_win:
  2384                                      ; Limpiar la pantalla primero
  2385                                      print clear, clear_length
    82 00001581 B801000000          <1>  mov eax, sys_write
    83 00001586 BF01000000          <1>  mov edi, 1
    84 0000158B 48BE-               <1>  mov rsi, %1
    84 0000158D [1000000000000000]  <1>
    85 00001595 BA07000000          <1>  mov edx, %2
    86 0000159A 0F05                <1>  syscall
  2386                                      
  2387                                      ; Mensaje de victoria
  2388 0000159C 488B05(9B150000)            mov rax, [current_score]    ; Obtener el puntaje final
  2389 000015A3 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2389 000015A5 [A415000000000000] 
  2390 000015AD E8B4010000                  call number_to_string
  2391                                      
  2392                                      ; Definir mensaje de victoria
  2393                                      section .data
  2394 000019CA C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2394 000019D3 616465732120C2A148-
  2394 000019DC 61732067616E61646F-
  2394 000019E5 210A0D             
  2395                                          win_msg_len: equ $ - win_msg
  2396 000019E8 50756E74616A652066-             score_msg: db "Puntaje final: "
  2396 000019F1 696E616C3A20       
  2397                                          score_msg_len: equ $ - score_msg
  2398                                      section .text
  2399                                      
  2400                                      ; Imprimir mensajes
  2401                                      print win_msg, win_msg_len
    82 000015B2 B801000000          <1>  mov eax, sys_write
    83 000015B7 BF01000000          <1>  mov edi, 1
    84 000015BC 48BE-               <1>  mov rsi, %1
    84 000015BE [CA19000000000000]  <1>
    85 000015C6 BA1E000000          <1>  mov edx, %2
    86 000015CB 0F05                <1>  syscall
  2402                                      print score_msg, score_msg_len
    82 000015CD B801000000          <1>  mov eax, sys_write
    83 000015D2 BF01000000          <1>  mov edi, 1
    84 000015D7 48BE-               <1>  mov rsi, %1
    84 000015D9 [E819000000000000]  <1>
    85 000015E1 BA0F000000          <1>  mov edx, %2
    86 000015E6 0F05                <1>  syscall
  2403                                      print number_buffer, 20
    82 000015E8 B801000000          <1>  mov eax, sys_write
    83 000015ED BF01000000          <1>  mov edi, 1
    84 000015F2 48BE-               <1>  mov rsi, %1
    84 000015F4 [A415000000000000]  <1>
    85 000015FC BA14000000          <1>  mov edx, %2
    86 00001601 0F05                <1>  syscall
  2404                                      
  2405                                      ; Esperar un momento antes de salir
  2406 00001603 48C705F2E9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2406 0000160C 0000               
  2407 0000160E 48C705EFE9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2407 00001617 0000               
  2408                                      sleeptime
    98 00001619 B823000000          <1>  mov eax, sys_nanosleep
    99 0000161E 48BF-               <1>  mov rdi, timespec
    99 00001620 [0000000000000000]  <1>
   100 00001628 31F6                <1>  xor esi, esi
   101 0000162A 0F05                <1>  syscall
  2409                                      
  2410 0000162C E9C80A0000                  jmp exit
  2411                                  
  2412                                  ; Función para imprimir los bloques
  2413                                  ; Función modificada para imprimir bloques
  2414                                  
  2415                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2416                                  get_current_level_blocks:
  2417 00001631 803D(F9140000)01            cmp byte [current_level], 1
  2418 00001638 7428                        je .level1
  2419 0000163A 803D(F9140000)02            cmp byte [current_level], 2
  2420 00001641 7427                        je .level2
  2421 00001643 803D(F9140000)03            cmp byte [current_level], 3
  2422 0000164A 7426                        je .level3
  2423 0000164C 803D(F9140000)04            cmp byte [current_level], 4
  2424 00001653 7425                        je .level4
  2425 00001655 803D(F9140000)05            cmp byte [current_level], 5
  2426 0000165C 7424                        je .level5
  2427                                      ; Si llegamos aquí, hay un error en el nivel
  2428 0000165E 4831C0                      xor rax, rax
  2429 00001661 C3                          ret
  2430                                  
  2431                                      .level1:
  2432 00001662 488D05(FB140000)                lea rax, [level1_blocks]
  2433 00001669 C3                              ret
  2434                                      .level2:
  2435 0000166A 488D05(23150000)                lea rax, [level2_blocks]
  2436 00001671 C3                              ret
  2437                                      .level3:
  2438 00001672 488D05(28150000)                lea rax, [level3_blocks]
  2439 00001679 C3                              ret
  2440                                      .level4:
  2441 0000167A 488D05(2D150000)                lea rax, [level4_blocks]
  2442 00001681 C3                              ret
  2443                                      .level5:
  2444 00001682 488D05(32150000)                lea rax, [level5_blocks]
  2445 00001689 C3                              ret
  2446                                  ; Función para obtener la cantidad de bloques del nivel actual
  2447                                  get_current_level_count:
  2448 0000168A 803D(F9140000)01            cmp byte [current_level], 1
  2449 00001691 7428                        je .level1
  2450 00001693 803D(F9140000)02            cmp byte [current_level], 2
  2451 0000169A 7425                        je .level2
  2452 0000169C 803D(F9140000)03            cmp byte [current_level], 3
  2453 000016A3 7422                        je .level3
  2454 000016A5 803D(F9140000)04            cmp byte [current_level], 4
  2455 000016AC 741F                        je .level4
  2456 000016AE 803D(F9140000)05            cmp byte [current_level], 5
  2457 000016B5 741C                        je .level5
  2458                                      ; Si llegamos aquí, hay un error en el nivel
  2459 000016B7 4831C0                      xor rax, rax
  2460 000016BA C3                          ret
  2461                                  
  2462                                      .level1:
  2463 000016BB B808000000                      mov rax, level1_blocks_count
  2464 000016C0 C3                              ret
  2465                                      .level2:
  2466 000016C1 B801000000                      mov rax, level2_blocks_count
  2467 000016C6 C3                              ret
  2468                                      .level3:
  2469 000016C7 B801000000                      mov rax, level3_blocks_count
  2470 000016CC C3                              ret
  2471                                      .level4:
  2472 000016CD B801000000                      mov rax, level4_blocks_count
  2473 000016D2 C3                              ret
  2474                                      .level5:
  2475 000016D3 B801000000                      mov rax, level5_blocks_count
  2476 000016D8 C3                              ret
  2477                                  
  2478                                  
  2479                                  print_blocks:
  2480 000016D9 55                          push rbp
  2481 000016DA 4889E5                      mov rbp, rsp
  2482                                      
  2483                                      ; Obtener puntero a los bloques del nivel actual
  2484 000016DD E84FFFFFFF                  call get_current_level_blocks
  2485 000016E2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2486                                      
  2487                                      ; Obtener cantidad de bloques del nivel actual
  2488 000016E5 E8A0FFFFFF                  call get_current_level_count
  2489 000016EA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2490                                      
  2491 000016ED 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2492                                      
  2493                                      .print_loop:
  2494 000016F0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2495 000016F3 7D6F                            jge .end
  2496                                          
  2497                                          ; Verificar si el bloque está activo
  2498 000016F5 490FB68424-                     movzx rax, byte [block_states + r12]
  2498 000016FA [37150000]         
  2499 000016FE 4885C0                          test rax, rax
  2500 00001701 745C                            jz .next_block
  2501                                          
  2502                                          ; Obtener posición y tipo del bloque usando r13
  2503 00001703 4C89E0                          mov rax, r12
  2504 00001706 486BC005                        imul rax, 5
  2505 0000170A 4C01E8                          add rax, r13
  2506 0000170D 448A00                          mov r8b, [rax]        ; X position
  2507 00001710 448A4801                        mov r9b, [rax + 1]    ; Y position
  2508 00001714 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2509                                  
  2510                                          ; El resto de la lógica de impresión permanece igual
  2511 00001718 4D0FB6C0                        movzx r8, r8b
  2512 0000171C 4D0FB6C9                        movzx r9, r9b
  2513 00001720 4981C0[000A0000]                add r8, board
  2514 00001727 B850000000                      mov rax, column_cells + 2
  2515 0000172C 49F7E1                          mul r9
  2516 0000172F 4901C0                          add r8, rax
  2517                                          
  2518 00001732 B906000000                      mov rcx, block_length
  2519 00001737 48BE-                           mov rsi, block_type_1
  2519 00001739 [D514000000000000] 
  2520 00001741 490FB6C2                        movzx rax, r10b
  2521 00001745 48FFC8                          dec rax
  2522 00001748 486BC006                        imul rax, block_length
  2523 0000174C 4801C6                          add rsi, rax
  2524                                          
  2525                                      .print_block_chars:
  2526 0000174F 8A06                            mov al, [rsi]
  2527 00001751 418800                          mov [r8], al
  2528 00001754 48FFC6                          inc rsi
  2529 00001757 49FFC0                          inc r8
  2530 0000175A 48FFC9                          dec rcx
  2531 0000175D 75F0                            jnz .print_block_chars
  2532                                          
  2533                                      .next_block:
  2534 0000175F 49FFC4                          inc r12
  2535 00001762 EB8C                            jmp .print_loop
  2536                                          
  2537                                      .end:
  2538 00001764 5D                              pop rbp
  2539 00001765 C3                              ret
  2540                                  
  2541                                  ; Función para convertir número a string
  2542                                  ; Input: RAX = número a convertir
  2543                                  ; RDI = buffer donde escribir el string
  2544                                  number_to_string:
  2545 00001766 53                          push rbx
  2546 00001767 52                          push rdx
  2547 00001768 56                          push rsi
  2548 00001769 BB0A000000                  mov rbx, 10          ; Divisor
  2549 0000176E B900000000                  mov rcx, 0          ; Contador de dígitos
  2550                                      
  2551                                      ; Si el número es 0, manejarlo especialmente
  2552 00001773 4885C0                      test rax, rax
  2553 00001776 7509                        jnz .convert_loop
  2554 00001778 C60730                      mov byte [rdi], '0'
  2555 0000177B C6470100                    mov byte [rdi + 1], 0
  2556 0000177F EB20                        jmp .end
  2557                                      
  2558                                      .convert_loop:
  2559 00001781 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2560 00001784 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2561 00001787 80C230                          add dl, '0'     ; Convertir a ASCII
  2562 0000178A 52                              push rdx        ; Guardar el dígito
  2563 0000178B 48FFC1                          inc rcx         ; Incrementar contador
  2564 0000178E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2565 00001791 75EE                            jnz .convert_loop
  2566                                          
  2567                                      .write_loop:
  2568 00001793 5A                              pop rdx         ; Obtener dígito
  2569 00001794 8817                            mov [rdi], dl   ; Escribir al buffer
  2570 00001796 48FFC7                          inc rdi         ; Siguiente posición
  2571 00001799 48FFC9                          dec rcx         ; Decrementar contador
  2572 0000179C 75F5                            jnz .write_loop
  2573                                          
  2574 0000179E C60700                      mov byte [rdi], 0   ; Null terminator
  2575                                      
  2576                                      .end:
  2577 000017A1 5E                          pop rsi
  2578 000017A2 5A                          pop rdx
  2579 000017A3 5B                          pop rbx
  2580 000017A4 C3                          ret
  2581                                  
  2582                                  ; Función para imprimir los labels
  2583                                  print_labels:
  2584 000017A5 55                          push rbp
  2585 000017A6 4889E5                      mov rbp, rsp
  2586                                  
  2587                                      ; Crear buffer temporal
  2588 000017A9 4883EC20                    sub rsp, 32
  2589                                  
  2590                                      ; Copiar labels a buffer temporal
  2591 000017AD 4889E7                      mov rdi, rsp
  2592 000017B0 488D35(50160000)            lea rsi, [score_label]
  2593 000017B7 B917000000                  mov rcx, score_label_len
  2594 000017BC F3A4                        rep movsb
  2595                                  
  2596                                      ; Convertir score a string
  2597 000017BE 488B05(9B150000)            mov rax, [current_score]
  2598 000017C5 48BF-                       mov rdi, number_buffer
  2598 000017C7 [A415000000000000] 
  2599 000017CF E892FFFFFF                  call number_to_string
  2600                                  
  2601                                      ; Calcular longitud del número
  2602 000017D4 B900000000                  mov rcx, 0
  2603 000017D9 48BF-                       mov rdi, number_buffer
  2603 000017DB [A415000000000000] 
  2604                                      .count_loop:
  2605 000017E3 803C0F00                        cmp byte [rdi + rcx], 0
  2606 000017E7 7405                            je .count_done
  2607 000017E9 48FFC1                          inc rcx
  2608 000017EC EBF5                            jmp .count_loop
  2609                                      .count_done:
  2610                                  
  2611                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2612 000017EE 4889E7                      mov rdi, rsp
  2613 000017F1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2614 000017F5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2615 000017FA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2616                                      .pad_loop:
  2617 000017FD 4885F6                          test rsi, rsi
  2618 00001800 740B                            jz .pad_done
  2619 00001802 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2620 00001805 48FFC7                          inc rdi
  2621 00001808 48FFCE                          dec rsi
  2622 0000180B EBF0                            jmp .pad_loop
  2623                                      .pad_done:
  2624                                  
  2625                                      ; Copiar el número
  2626 0000180D 48BE-                       mov rsi, number_buffer
  2626 0000180F [A415000000000000] 
  2627 00001817 F3A4                        rep movsb
  2628                                  
  2629                                      ; Imprimir el buffer completo
  2630                                      print rsp, score_label_len
    82 00001819 B801000000          <1>  mov eax, sys_write
    83 0000181E BF01000000          <1>  mov edi, 1
    84 00001823 4889E6              <1>  mov rsi, %1
    85 00001826 BA17000000          <1>  mov edx, %2
    86 0000182B 0F05                <1>  syscall
  2631                                  
  2632                                      ; Repetir proceso para bloques destruidos
  2633 0000182D 4889E7                      mov rdi, rsp
  2634 00001830 488D35(67160000)            lea rsi, [blocks_label]
  2635 00001837 B91B000000                  mov rcx, blocks_label_len
  2636 0000183C F3A4                        rep movsb
  2637                                  
  2638                                      ; Verificar que el `[` esté en su posición correcta
  2639 0000183E 4889E7                      mov rdi, rsp
  2640 00001841 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2641 00001845 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2642                                  
  2643                                      ; Convertir bloques destruidos a string
  2644 00001848 480FB605(A3150000)          movzx rax, byte [destroyed_blocks]
  2645 00001850 48BF-                       mov rdi, number_buffer
  2645 00001852 [A415000000000000] 
  2646 0000185A E807FFFFFF                  call number_to_string
  2647                                  
  2648                                      ; Calcular longitud del número
  2649 0000185F B900000000                  mov rcx, 0
  2650 00001864 48BF-                       mov rdi, number_buffer
  2650 00001866 [A415000000000000] 
  2651                                      .count_loop2:
  2652 0000186E 803C0F00                        cmp byte [rdi + rcx], 0
  2653 00001872 7405                            je .count_done2
  2654 00001874 48FFC1                          inc rcx
  2655 00001877 EBF5                            jmp .count_loop2
  2656                                      .count_done2:
  2657                                  
  2658                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2659 00001879 4889E7                      mov rdi, rsp
  2660 0000187C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2661 00001880 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2662 00001885 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2663                                      .pad_loop2:
  2664 00001888 4885F6                          test rsi, rsi
  2665 0000188B 740B                            jz .pad_done2
  2666 0000188D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2667 00001890 48FFC7                          inc rdi
  2668 00001893 48FFCE                          dec rsi
  2669 00001896 EBF0                            jmp .pad_loop2
  2670                                      .pad_done2:
  2671                                  
  2672                                      ; Copiar el número
  2673 00001898 48BE-                       mov rsi, number_buffer
  2673 0000189A [A415000000000000] 
  2674 000018A2 F3A4                        rep movsb
  2675                                  
  2676                                      ; Imprimir el buffer completo
  2677                                      print rsp, blocks_label_len
    82 000018A4 B801000000          <1>  mov eax, sys_write
    83 000018A9 BF01000000          <1>  mov edi, 1
    84 000018AE 4889E6              <1>  mov rsi, %1
    85 000018B1 BA1B000000          <1>  mov edx, %2
    86 000018B6 0F05                <1>  syscall
  2678                                  
  2679                                      ; Restaurar stack
  2680 000018B8 4883C420                    add rsp, 32
  2681 000018BC 5D                          pop rbp
  2682 000018BD C3                          ret
  2683                                  
  2684                                  
  2685                                  
  2686                                  check_block_collision:
  2687 000018BE 55                          push rbp
  2688 000018BF 4889E5                      mov rbp, rsp
  2689                                  
  2690                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2691 000018C2 418A02                      mov al, [r10]
  2692                                  
  2693                                      ; Verificar si el carácter es un bloque
  2694 000018C5 3C55                        cmp al, 'U'  
  2695 000018C7 7419                        je .possible
  2696 000018C9 3C4F                        cmp al, 'O'  
  2697 000018CB 7415                        je .possible
  2698 000018CD 3C44                        cmp al, 'D'  
  2699 000018CF 7411                        je .possible
  2700 000018D1 3C4C                        cmp al, 'L'  
  2701 000018D3 740D                        je .possible
  2702 000018D5 3C56                        cmp al, 'V'  
  2703 000018D7 7409                        je .possible
  2704 000018D9 3C38                        cmp al, '8'  
  2705 000018DB 7405                        je .possible
  2706                                  
  2707                                      ; No es bloque, salir
  2708 000018DD 4831C0                      xor rax, rax
  2709 000018E0 5D                          pop rbp
  2710 000018E1 C3                          ret
  2711                                  
  2712                                  .possible:
  2713 000018E2 53                          push rbx
  2714 000018E3 57                          push rdi
  2715 000018E4 56                          push rsi
  2716 000018E5 4154                        push r12
  2717 000018E7 4155                        push r13
  2718 000018E9 4156                        push r14
  2719 000018EB 4157                        push r15
  2720                                  
  2721                                      ; 1) Obtener base de los bloques del nivel actual
  2722 000018ED E83FFDFFFF                  call get_current_level_blocks
  2723 000018F2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2724                                  
  2725                                      ; 2) Obtener la cantidad de bloques
  2726 000018F5 E890FDFFFF                  call get_current_level_count
  2727 000018FA 4989C6                      mov r14, rax
  2728                                  
  2729 000018FD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2730                                  
  2731                                  .find_block_loop:
  2732 00001900 4D39F4                      cmp r12, r14
  2733 00001903 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2734                                  
  2735                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2736 00001909 4C89E0                      mov rax, r12
  2737 0000190C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2738 00001910 4C01E8                      add rax, r13
  2739 00001913 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2740                                  
  2741                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2742 00001916 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2742 0000191B [37150000]         
  2743 0000191F 4885DB                      test rbx, rbx
  2744 00001922 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2745                                  
  2746                                      ; Obtener coordenadas
  2747 00001928 418A17                      mov dl, [r15]         ; x
  2748 0000192B 418A4F01                    mov cl, [r15 + 1]     ; y
  2749                                  
  2750                                      ; Calcular posición en el board
  2751 0000192F 488D3D(000A0000)            lea rdi, [board]
  2752 00001936 4831C0                      xor rax, rax
  2753 00001939 B84E000000                  mov rax, column_cells
  2754 0000193E 4883C002                    add rax, 2
  2755 00001942 480FB6C9                    movzx rcx, cl         ; y
  2756 00001946 480FAFC1                    imul rax, rcx
  2757 0000194A 4801C7                      add rdi, rax
  2758 0000194D 480FB6C2                    movzx rax, dl         ; x
  2759 00001951 4801C7                      add rdi, rax
  2760                                  
  2761                                      ; Guardar la posición base del bloque
  2762 00001954 57                          push rdi
  2763                                  
  2764                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2765 00001955 4939FA                      cmp r10, rdi
  2766 00001958 7274                        jb .skip_collision
  2767 0000195A 488D5F06                    lea rbx, [rdi + block_length]
  2768 0000195E 4939DA                      cmp r10, rbx
  2769 00001961 736B                        jae .skip_collision
  2770                                  
  2771                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2772 00001963 41FE8C24[37150000]          dec byte [block_states + r12]
  2773                                      ; Volver a cargar durabilidad
  2774 0000196B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2774 00001970 [37150000]         
  2775 00001974 4885DB                      test rbx, rbx
  2776 00001977 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2777                                  
  2778                                      ; >>> Llegó a 0 => Bloque destruido
  2779 00001979 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2780 0000197A B906000000                  mov rcx, block_length
  2781                                  .clear_loop:
  2782 0000197F C60720                      mov byte [rdi], ' '
  2783 00001982 48FFC7                      inc rdi
  2784 00001985 E2F8                        loop .clear_loop
  2785                                  
  2786                                      ; Dibujar letra del bloque destruido
  2787 00001987 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2788 0000198B 4883EF06                    sub rdi, block_length
  2789 0000198F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2790                                      ; Después de escribir la letra en el tablero
  2791 00001991 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2792 00001995 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2793 00001999 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2794 0000199E E8C6EAFFFF                  call register_letter
  2795                                      ; Actualizar contadores globales
  2796 000019A3 FE0D(FA140000)              dec byte [blocks_remaining]
  2797 000019A9 FE05(A3150000)              inc byte [destroyed_blocks]
  2798                                  
  2799                                      ; Sumar puntos según el tipo
  2800 000019AF 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2801 000019B4 486BC00A                    imul rax, 10
  2802 000019B8 480105(9B150000)            add [current_score], rax
  2803                                  
  2804 000019BF B801000000                  mov rax, 1  ; colisión con destrucción
  2805 000019C4 EB14                        jmp .end_pop
  2806                                  
  2807                                  .update_display:
  2808                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2809 000019C6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2810 000019CB 5F                          pop rdi     ; pop que quedó pendiente
  2811 000019CC EB0C                        jmp .end_pop
  2812                                  
  2813                                  .skip_collision:
  2814 000019CE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2815                                  .next_block:
  2816 000019CF 49FFC4                      inc r12
  2817 000019D2 E929FFFFFF                  jmp .find_block_loop
  2818                                  
  2819                                  .no_block_found:
  2820 000019D7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2821                                  
  2822                                  .end_pop:
  2823 000019DA 415F                        pop r15
  2824 000019DC 415E                        pop r14
  2825 000019DE 415D                        pop r13
  2826 000019E0 415C                        pop r12
  2827 000019E2 5E                          pop rsi
  2828 000019E3 5F                          pop rdi
  2829 000019E4 5B                          pop rbx
  2830 000019E5 5D                          pop rbp
  2831 000019E6 C3                          ret
  2832                                  
  2833                                  
  2834                                  
  2835                                  init_enemies:
  2836 000019E7 55                          push rbp
  2837 000019E8 4889E5                      mov rbp, rsp
  2838                                      ; Reiniciar contadores de movimiento
  2839 000019EB C605(E6150000)00            mov byte [enemy_move_total], 0
  2840 000019F2 C605(E7150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2841                                      ; Limpiar estado previo de enemigos
  2842 000019F9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2843 000019FE 488D3D(BD150000)            lea rdi, [enemies]
  2844 00001A05 30C0                        xor al, al
  2845 00001A07 F3AA                        rep stosb ; Limpiar datos de enemigos
  2846                                      
  2847                                      ; Marcar todos los enemigos como inactivos
  2848 00001A09 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2849 00001A10 30C0                        xor al, al
  2850 00001A12 B90A000000                  mov rcx, 10
  2851 00001A17 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2852                                  
  2853 00001A19 5D                          pop rbp
  2854 00001A1A C3                          ret
  2855                                  
  2856                                  
  2857                                  random_move_enemy:
  2858 00001A1B 55                          push rbp
  2859 00001A1C 4889E5                      mov  rbp, rsp
  2860 00001A1F 53                          push rbx
  2861 00001A20 52                          push rdx
  2862 00001A21 57                          push rdi
  2863                                  
  2864                                      ; r12 = índice del enemigo
  2865                                      ; 1) obtener puntero al enemigo i
  2866 00001A22 4C89E0                      mov rax, r12
  2867 00001A25 486BC003                    imul rax, 3
  2868 00001A29 488D98[BD150000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  2869                                  
  2870                                      ; 2) Cargar X, Y actuales
  2871 00001A30 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  2872 00001A34 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  2873                                  
  2874                                      ; Limpiar posición actual en el tablero antes de mover
  2875 00001A39 4150                        push r8
  2876 00001A3B 4151                        push r9
  2877 00001A3D B84E000000                  mov rax, column_cells
  2878 00001A42 4883C002                    add rax, 2
  2879 00001A46 49F7E1                      mul r9
  2880 00001A49 4C01C0                      add rax, r8
  2881 00001A4C 488DB8[000A0000]            lea rdi, [board + rax]
  2882 00001A53 C60720                      mov byte [rdi], ' '         ; Limpiar rastro
  2883 00001A56 4159                        pop r9
  2884 00001A58 4158                        pop r8
  2885                                  
  2886                                      ; 3) "Aleatorio" => tomamos [enemy_move_counter] & 3
  2887 00001A5A 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2888 00001A62 4883E003                    and rax, 3
  2889                                  
  2890 00001A66 4883F800                    cmp rax, 0
  2891 00001A6A 741B                        je .move_left
  2892 00001A6C 4883F801                    cmp rax, 1
  2893 00001A70 7410                        je .move_right
  2894 00001A72 4883F802                    cmp rax, 2
  2895 00001A76 7405                        je .move_up
  2896                                      ; si es 3 => mover abajo
  2897                                  .move_down:
  2898 00001A78 49FFC1                      inc r9
  2899 00001A7B EB0D                        jmp .apply
  2900                                  
  2901                                  .move_up:
  2902 00001A7D 49FFC9                      dec r9
  2903 00001A80 EB08                        jmp .apply
  2904                                  
  2905                                  .move_right:
  2906 00001A82 49FFC0                      inc r8
  2907 00001A85 EB03                        jmp .apply
  2908                                  
  2909                                  .move_left:
  2910 00001A87 49FFC8                      dec r8
  2911                                  
  2912                                  .apply:
  2913                                      ; Verificar límites del tablero antes de aplicar el movimiento
  2914 00001A8A 4983F801                    cmp r8, 1                    ; Borde izquierdo
  2915 00001A8E 7E5B                        jle .invalid_move
  2916 00001A90 4983F84E                    cmp r8, column_cells        ; Borde derecho
  2917 00001A94 7D55                        jge .invalid_move
  2918 00001A96 4983F901                    cmp r9, 1                    ; Borde superior
  2919 00001A9A 7E4F                        jle .invalid_move
  2920 00001A9C 4983F920                    cmp r9, row_cells          ; Borde inferior
  2921 00001AA0 7D49                        jge .invalid_move
  2922                                  
  2923                                      ; Verificar colisión con bloques
  2924 00001AA2 4150                        push r8
  2925 00001AA4 4151                        push r9
  2926 00001AA6 B84E000000                  mov rax, column_cells
  2927 00001AAB 4883C002                    add rax, 2
  2928 00001AAF 49F7E1                      mul r9
  2929 00001AB2 4C01C0                      add rax, r8
  2930 00001AB5 488DB8[000A0000]            lea rdi, [board + rax]
  2931 00001ABC 8A07                        mov al, [rdi]
  2932                                      
  2933                                      ; Verificar si hay un bloque en la nueva posición
  2934 00001ABE 3C55                        cmp al, 'U'
  2935 00001AC0 7425                        je .pop_and_invalid
  2936 00001AC2 3C4F                        cmp al, 'O'
  2937 00001AC4 7421                        je .pop_and_invalid
  2938 00001AC6 3C44                        cmp al, 'D'
  2939 00001AC8 741D                        je .pop_and_invalid
  2940 00001ACA 3C4C                        cmp al, 'L'
  2941 00001ACC 7419                        je .pop_and_invalid
  2942 00001ACE 3C56                        cmp al, 'V'
  2943 00001AD0 7415                        je .pop_and_invalid
  2944 00001AD2 3C38                        cmp al, '8'
  2945 00001AD4 7411                        je .pop_and_invalid
  2946 00001AD6 3C58                        cmp al, 'X'
  2947 00001AD8 740D                        je .pop_and_invalid
  2948                                      
  2949 00001ADA 4159                        pop r9
  2950 00001ADC 4158                        pop r8
  2951                                      
  2952                                      ; Si llegamos aquí, el movimiento es válido
  2953 00001ADE 448803                      mov byte [rbx], r8b
  2954 00001AE1 44884B01                    mov byte [rbx + 1], r9b
  2955 00001AE5 EB0D                        jmp .end
  2956                                  
  2957                                  .pop_and_invalid:
  2958 00001AE7 4159                        pop r9
  2959 00001AE9 4158                        pop r8
  2960                                  
  2961                                  .invalid_move:
  2962                                      ; Restaurar posición original
  2963 00001AEB 4C0FB603                    movzx r8, byte [rbx]
  2964 00001AEF 4C0FB64B01                  movzx r9, byte [rbx + 1]
  2965                                  
  2966                                  .end:
  2967 00001AF4 5F                          pop rdi
  2968 00001AF5 5A                          pop rdx
  2969 00001AF6 5B                          pop rbx
  2970 00001AF7 5D                          pop rbp
  2971 00001AF8 C3                          ret
  2972                                  
  2973                                  ; Función para mover enemigos
  2974                                  move_enemies:
  2975 00001AF9 55                          push rbp
  2976 00001AFA 4889E5                      mov rbp, rsp
  2977                                      
  2978                                      ; Incrementar contador de movimiento
  2979 00001AFD FE05(E4150000)              inc byte [enemy_move_counter]
  2980 00001B03 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2981 00001B0B 3A05(E5150000)              cmp al, [enemy_move_delay]
  2982 00001B11 0F851E020000                jne .end
  2983                                      
  2984                                      ; Resetear contador
  2985 00001B17 C605(E4150000)00            mov byte [enemy_move_counter], 0
  2986                                      
  2987 00001B1E 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2988                                      
  2989                                      .enemy_loop:
  2990 00001B21 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2991 00001B25 0F8D0A020000                    jge .end
  2992                                          
  2993                                          ; Calcular offset del enemigo actual
  2994 00001B2B 4C89E0                          mov rax, r12
  2995 00001B2E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2996 00001B32 488DB0[BD150000]                lea rsi, [enemies + rax]
  2997                                          
  2998                                          ; Verificar si el enemigo está activo
  2999 00001B39 807E0201                        cmp byte [rsi + 2], 1
  3000 00001B3D 0F85EA010000                    jne .next_enemy
  3001                                          
  3002                                          ; Obtener posición actual
  3003 00001B43 4C0FB606                        movzx r8, byte [rsi]            ; X
  3004 00001B47 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3005                                          
  3006 00001B4C 488D3D(9C190000)                lea rdi, [enemy_last_x]
  3007 00001B53 4C01E7                          add rdi, r12
  3008 00001B56 8A07                            mov al, [rdi]             ; al = last_x
  3009                                  
  3010 00001B58 488D15(A6190000)                lea rdx, [enemy_last_y]
  3011 00001B5F 4C01E2                          add rdx, r12
  3012 00001B62 8A22                            mov ah, [rdx]             ; ah = last_y
  3013                                  
  3014                                          ; r8 = X actual del enemigo
  3015                                          ; r9 = Y actual del enemigo
  3016                                  
  3017                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3018 00001B64 88E2                            mov dl, ah      ; dl = old_Y
  3019 00001B66 4488CB                          mov bl, r9b     ; bl = new_Y
  3020 00001B69 38DA                            cmp dl, bl
  3021 00001B6B 752C                            jne .not_stuck
  3022                                  
  3023                                          ; => SI son iguales => pasa al siguiente check
  3024 00001B6D 88C2                            mov dl, al      ; dl = old_X
  3025 00001B6F 4488C3                          mov bl, r8b     ; bl = new_X
  3026 00001B72 38DA                            cmp dl, bl
  3027 00001B74 7523                            jne .not_stuck
  3028                                  
  3029                                          ; => MISMA POSICIÓN (STUCK)
  3030 00001B76 488D1D(B0190000)                lea rbx, [enemy_stuck_count]
  3031 00001B7D 4C01E3                          add rbx, r12
  3032 00001B80 FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3033                                  
  3034                                          ; Verificar si supera umbral, digamos 3
  3035 00001B82 480FB60B                        movzx rcx, byte [rbx]
  3036 00001B86 4883F902                        cmp rcx, 2
  3037 00001B8A 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3038                                  
  3039                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3040                                          ;  1) resetear el stuck_count
  3041 00001B8C C60300                          mov byte [rbx], 0
  3042                                  
  3043                                          ;  2) cambiar random
  3044 00001B8F E887FEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3045 00001B94 E994010000                      jmp .next_enemy
  3046                                  
  3047                                      .not_stuck:
  3048                                          ; => Se movió
  3049 00001B99 488D1D(B0190000)                lea rbx, [enemy_stuck_count]
  3050 00001BA0 4C01E3                          add rbx, r12
  3051 00001BA3 C60300                          mov byte [rbx], 0            ; Resetear
  3052                                  
  3053                                          ; Guardar su nueva posición en “last_x, last_y”
  3054 00001BA6 488D3D(9C190000)                lea rdi, [enemy_last_x]
  3055 00001BAD 4C01E7                          add rdi, r12
  3056 00001BB0 448807                          mov [rdi], r8b
  3057                                          
  3058 00001BB3 488D3D(A6190000)                lea rdi, [enemy_last_y]
  3059 00001BBA 4C01E7                          add rdi, r12
  3060 00001BBD 44880F                          mov [rdi], r9b
  3061                                  
  3062                                          ; Limpiar posición actual antes de mover
  3063                                      .check_normal_move:
  3064 00001BC0 4150                            push r8
  3065 00001BC2 4151                            push r9
  3066 00001BC4 B84E000000                      mov rax, column_cells
  3067 00001BC9 4883C002                        add rax, 2
  3068 00001BCD 49F7E1                          mul r9
  3069 00001BD0 4C01C0                          add rax, r8
  3070 00001BD3 488DB8[000A0000]                lea rdi, [board + rax]
  3071 00001BDA C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3072 00001BDD 4159                            pop r9
  3073 00001BDF 4158                            pop r8
  3074                                  
  3075                                          ; Determinar comportamiento basado en índice
  3076 00001BE1 4C89E0                          mov rax, r12
  3077 00001BE4 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3078 00001BE8 4885C0                          test rax, rax
  3079 00001BEB 7402                            jz .chase_ball
  3080 00001BED EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  3081                                          
  3082                                          ; Perseguir bola (comportamiento original)
  3083                                      .chase_ball:
  3084 00001BEF 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3085 00001BF6 4D39D0                          cmp r8, r10
  3086 00001BF9 0F8F96000000                    jg .move_left
  3087 00001BFF 0F8C95000000                    jl .move_right
  3088                                          
  3089 00001C05 4C8B15(67140000)                mov r10, [ball_y_pos]
  3090 00001C0C 4D39D1                          cmp r9, r10
  3091 00001C0F 0F8F8A000000                    jg .move_up
  3092 00001C15 0F8C89000000                    jl .move_down
  3093 00001C1B E9A5000000                      jmp .check_collision
  3094                                          
  3095                                      .chase_paddle:
  3096                                          ; Obtener la posición X actual de la paleta
  3097 00001C20 4C8B15(3F140000)                mov r10, [pallet_position]
  3098 00001C27 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  3099                                          
  3100                                          ; Calcular la posición X real de la paleta
  3101 00001C2E 4C89D0                          mov rax, r10
  3102 00001C31 BB4E000000                      mov rbx, column_cells
  3103 00001C36 4883C302                        add rbx, 2                  ; Añadir newline chars
  3104 00001C3A 4831D2                          xor rdx, rdx
  3105 00001C3D 48F7F3                          div rbx                     ; rax = y, rdx = x
  3106                                          
  3107                                          ; rdx ahora contiene la posición X de la paleta
  3108                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  3109 00001C40 488B0D(47140000)                mov rcx, [pallet_size]
  3110 00001C47 48D1E9                          shr rcx, 1                  ; Dividir por 2
  3111 00001C4A 4801CA                          add rdx, rcx
  3112                                          
  3113                                          ; Comparar con posición X del enemigo y mover gradualmente
  3114 00001C4D 4939D0                          cmp r8, rdx
  3115 00001C50 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  3116 00001C52 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  3117 00001C54 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  3118                                  
  3119                                      .check_y_paddle:
  3120                                          ; La Y de la paleta siempre es row_cells - 2
  3121 00001C56 41BA20000000                    mov r10, row_cells
  3122 00001C5C 4983EA02                        sub r10, 2
  3123                                          
  3124                                          ; Comparar con posición Y del enemigo y mover gradualmente
  3125 00001C60 4D39D1                          cmp r9, r10
  3126 00001C63 7404                            je .no_movement            ; Si está en la misma Y, no mover
  3127 00001C65 7F38                            jg .move_up               ; Si está abajo, mover arriba
  3128 00001C67 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  3129                                          
  3130                                      .no_movement:
  3131 00001C69 EB5A                            jmp .check_collision
  3132                                  
  3133                                      ; También agregar una nueva sección para el movimiento suave
  3134                                      .smooth_transition:
  3135                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  3136 00001C6B 8A05(E7150000)                  mov al, [enemy_target]
  3137 00001C71 84C0                            test al, al
  3138 00001C73 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  3139                                          
  3140                                          ; Verificar distancia en X
  3141 00001C75 4989D2                          mov r10, rdx              ; Posición X objetivo
  3142 00001C78 4D29C2                          sub r10, r8               ; Calcular diferencia
  3143 00001C7B 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  3144 00001C7F 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  3145 00001C81 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  3146 00001C85 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  3147 00001C87 EB3C                            jmp .check_collision
  3148                                          
  3149                                      .limit_right_movement:
  3150 00001C89 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  3151 00001C8D EB36                            jmp .check_collision
  3152                                          
  3153                                      .limit_left_movement:
  3154 00001C8F 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  3155 00001C93 EB30                            jmp .check_collision
  3156                                      .move_left:
  3157 00001C95 49FFC8                          dec r8
  3158 00001C98 EB0F                            jmp .check_vertical
  3159                                          
  3160                                      .move_right:
  3161 00001C9A 49FFC0                          inc r8
  3162 00001C9D EB0A                            jmp .check_vertical
  3163                                          
  3164                                      .move_up:
  3165 00001C9F 49FFC9                          dec r9
  3166 00001CA2 EB21                            jmp .check_collision
  3167                                          
  3168                                      .move_down:
  3169 00001CA4 49FFC1                          inc r9
  3170 00001CA7 EB1C                            jmp .check_collision
  3171                                          
  3172                                      .check_vertical:
  3173 00001CA9 8A05(E7150000)                  mov al, [enemy_target]
  3174 00001CAF 84C0                            test al, al
  3175 00001CB1 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  3176 00001CB7 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  3177 00001CBE 4D39D1                          cmp r9, r10
  3178 00001CC1 7FDC                            jg .move_up
  3179 00001CC3 7CDF                            jl .move_down
  3180                                          
  3181                                      .check_collision:
  3182                                          ; Verificar colisión con bordes
  3183 00001CC5 4983F801                        cmp r8, 1                       ; Borde izquierdo
  3184 00001CC9 7E62                            jle .next_enemy
  3185 00001CCB 4983F84E                        cmp r8, column_cells
  3186 00001CCF 7D5C                            jge .next_enemy
  3187 00001CD1 4983F901                        cmp r9, 1                       ; Borde superior
  3188 00001CD5 7E56                            jle .next_enemy
  3189 00001CD7 4983F920                        cmp r9, row_cells
  3190 00001CDB 7D50                            jge .next_enemy
  3191                                          
  3192                                          ; Verificar colisión con bloques antes de moverse
  3193 00001CDD 4150                            push r8
  3194 00001CDF 4151                            push r9
  3195 00001CE1 4152                            push r10
  3196                                          
  3197                                          ; Calcular posición en el tablero para verificar
  3198 00001CE3 B84E000000                      mov rax, column_cells
  3199 00001CE8 4883C002                        add rax, 2
  3200 00001CEC 49F7E1                          mul r9
  3201 00001CEF 4C01C0                          add rax, r8
  3202 00001CF2 4C8D90[000A0000]                lea r10, [board + rax]
  3203                                          
  3204                                          ; Verificar si hay un bloque en la nueva posición
  3205 00001CF9 418A02                          mov al, [r10]
  3206 00001CFC 3C55                            cmp al, 'U'
  3207 00001CFE 7427                            je .invalid_move
  3208 00001D00 3C4F                            cmp al, 'O'
  3209 00001D02 7423                            je .invalid_move
  3210 00001D04 3C44                            cmp al, 'D'
  3211 00001D06 741F                            je .invalid_move
  3212 00001D08 3C4C                            cmp al, 'L'
  3213 00001D0A 741B                            je .invalid_move
  3214 00001D0C 3C56                            cmp al, 'V'
  3215 00001D0E 7417                            je .invalid_move
  3216 00001D10 3C38                            cmp al, '8'
  3217 00001D12 7413                            je .invalid_move
  3218 00001D14 3C58                            cmp al, 'X'
  3219 00001D16 740F                            je .invalid_move
  3220                                          
  3221 00001D18 415A                            pop r10
  3222 00001D1A 4159                            pop r9
  3223 00001D1C 4158                            pop r8
  3224                                          
  3225                                          ; Guardar nueva posición si es válida
  3226 00001D1E 448806                          mov [rsi], r8b
  3227 00001D21 44884E01                        mov [rsi + 1], r9b
  3228 00001D25 EB06                            jmp .next_enemy
  3229                                          
  3230                                      .invalid_move:
  3231 00001D27 415A                            pop r10
  3232 00001D29 4159                            pop r9
  3233 00001D2B 4158                            pop r8
  3234                                          
  3235                                      .next_enemy:
  3236 00001D2D 49FFC4                          inc r12
  3237 00001D30 E9ECFDFFFF                      jmp .enemy_loop
  3238                                          
  3239                                      .end:
  3240 00001D35 5D                              pop rbp
  3241 00001D36 C3                              ret
  3242                                  
  3243                                  get_current_spawn_points:
  3244 00001D37 55                          push rbp
  3245 00001D38 4889E5                      mov rbp, rsp
  3246                                      
  3247 00001D3B 480FB605(F9140000)          movzx rax, byte [current_level]
  3248 00001D43 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3249 00001D46 488B04C5[1B160000]          mov rax, [spawn_points_table + rax * 8]
  3250                                      
  3251 00001D4E 5D                          pop rbp
  3252 00001D4F C3                          ret
  3253                                  
  3254                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3255                                  check_enemy_spawn:
  3256 00001D50 55                          push rbp
  3257 00001D51 4889E5                      mov rbp, rsp
  3258                                      
  3259                                      ; Obtener spawn points del nivel actual
  3260 00001D54 E8DEFFFFFF                  call get_current_spawn_points
  3261 00001D59 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3262                                      
  3263                                      ; Obtener cantidad de bloques destruidos
  3264 00001D5C 4C0FB62D(A3150000)          movzx r13, byte [destroyed_blocks]
  3265                                      
  3266                                      ; Verificar cada punto de spawn
  3267 00001D64 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3268                                      
  3269                                      .check_loop:
  3270 00001D67 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3271 00001D6B 7D4E                            jge .end
  3272                                          
  3273                                          ; Verificar si este spawn point ya fue usado
  3274 00001D6D 80B9[46160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3275 00001D74 7440                            je .next_enemy
  3276                                          
  3277                                          ; Verificar si este enemigo ya está activo
  3278 00001D76 4889C8                          mov rax, rcx
  3279 00001D79 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3280 00001D7D 488DB0[BD150000]                lea rsi, [enemies + rax]
  3281 00001D84 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3282 00001D88 742C                            je .next_enemy
  3283                                          
  3284                                          ; Verificar si debemos spawnear este enemigo
  3285 00001D8A 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3286 00001D8F 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3287 00001D92 7522                            jne .next_enemy
  3288                                          
  3289                                          ; Marcar este spawn point como usado
  3290 00001D94 C681[46160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3291                                          
  3292                                          ; Spawner nuevo enemigo
  3293 00001D9B B004                            mov al, 4
  3294 00001D9D 00C8                            add al, cl       ; con 'rcx' como índice
  3295 00001D9F 8806                            mov [rsi], al
  3296 00001DA1 C6460102                        mov byte [rsi+1], 2
  3297 00001DA5 C6460201                        mov byte [rsi+2], 1
  3298                                  
  3299                                          ; Inicializar comportamiento
  3300 00001DA9 4889C8                          mov rax, rcx
  3301 00001DAC 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3302 00001DB0 8805(45160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3303                                          
  3304                                      .next_enemy:
  3305 00001DB6 48FFC1                          inc rcx
  3306 00001DB9 EBAC                            jmp .check_loop
  3307                                          
  3308                                      .end:
  3309 00001DBB 5D                              pop rbp
  3310 00001DBC C3                              ret
  3311                                  
  3312                                  
  3313                                  ; Función para dibujar enemigos
  3314                                  print_enemies:
  3315 00001DBD 55                          push rbp
  3316 00001DBE 4889E5                      mov rbp, rsp
  3317                                      
  3318 00001DC1 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3319                                      
  3320                                      .print_loop:
  3321 00001DC4 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3322 00001DC8 7D4B                            jge .end
  3323                                          
  3324                                          ; Calcular offset del enemigo actual
  3325 00001DCA 4C89E0                          mov rax, r12
  3326 00001DCD 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3327 00001DD1 488DB0[BD150000]                lea rsi, [enemies + rax]
  3328                                          
  3329                                          ; Verificar si el enemigo está activo
  3330 00001DD8 807E0201                        cmp byte [rsi + 2], 1
  3331 00001DDC 7532                            jne .next_enemy
  3332                                          
  3333                                          ; Calcular posición en el tablero
  3334 00001DDE 4C0FB606                        movzx r8, byte [rsi]            ; X
  3335 00001DE2 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3336                                          
  3337                                          ; Calcular offset en el tablero
  3338 00001DE7 B84E000000                      mov rax, column_cells
  3339 00001DEC 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3340 00001DF0 49F7E1                          mul r9
  3341 00001DF3 4C01C0                          add rax, r8
  3342 00001DF6 488DB8[000A0000]                lea rdi, [board + rax]
  3343                                          
  3344                                          ; Obtener carácter del enemigo según el nivel
  3345 00001DFD 480FB605(F9140000)              movzx rax, byte [current_level]
  3346 00001E05 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3347 00001E08 8A80[B8150000]                  mov al, [enemy_chars + rax]
  3348                                          
  3349                                          ; Dibujar enemigo
  3350 00001E0E 8807                            mov [rdi], al
  3351                                          
  3352                                      .next_enemy:
  3353 00001E10 49FFC4                          inc r12
  3354 00001E13 EBAF                            jmp .print_loop
  3355                                          
  3356                                      .end:
  3357 00001E15 5D                              pop rbp
  3358 00001E16 C3                              ret
  3359                                  
  3360                                  ; Función para verificar colisión con enemigos
  3361                                  ; Función para verificar colisión con enemigos
  3362                                  check_enemy_collision:
  3363 00001E17 55                          push rbp
  3364 00001E18 4889E5                      mov rbp, rsp
  3365                                      
  3366 00001E1B 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3367 00001E1E 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3368                                      
  3369                                      .check_loop:
  3370 00001E21 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3371 00001E25 0F8DE9000000                    jge .end
  3372                                          
  3373                                          ; Calcular offset del enemigo actual
  3374 00001E2B 4C89E1                          mov rcx, r12
  3375 00001E2E 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3376 00001E32 488DB1[BD150000]                lea rsi, [enemies + rcx]
  3377                                          
  3378                                          ; Verificar si el enemigo está activo
  3379 00001E39 807E0201                        cmp byte [rsi + 2], 1
  3380 00001E3D 0F85C9000000                    jne .next_enemy
  3381                                          
  3382                                          ; Verificar colisión con la bola
  3383 00001E43 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3384 00001E47 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3385                                          
  3386                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3387 00001E4C 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3388 00001E53 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3389                                          
  3390                                          ; Comprobar colisión vertical (misma columna)
  3391 00001E5A 4D39C2                          cmp r10, r8
  3392 00001E5D 7525                            jne .check_horizontal
  3393 00001E5F 4D29CB                          sub r11, r9
  3394 00001E62 4983FB01                        cmp r11, 1
  3395 00001E66 7F1C                            jg .check_horizontal
  3396 00001E68 4983FBFF                        cmp r11, -1
  3397 00001E6C 7C16                            jl .check_horizontal
  3398                                          
  3399                                          ; Colisión vertical detectada
  3400 00001E6E E8A3000000                      call destroy_enemy
  3401 00001E73 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3402 00001E7A B801000000                      mov rax, 1
  3403 00001E7F E990000000                      jmp .end
  3404                                          
  3405                                      .check_horizontal:
  3406                                          ; Comprobar colisión horizontal (misma fila)
  3407 00001E84 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3408 00001E8B 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3409 00001E92 4D39CB                          cmp r11, r9
  3410 00001E95 7522                            jne .check_paddle
  3411 00001E97 4D29C2                          sub r10, r8
  3412 00001E9A 4983FA01                        cmp r10, 1
  3413 00001E9E 7F19                            jg .check_paddle
  3414 00001EA0 4983FAFF                        cmp r10, -1
  3415 00001EA4 7C13                            jl .check_paddle
  3416                                          
  3417                                          ; Colisión horizontal detectada
  3418 00001EA6 E86B000000                      call destroy_enemy
  3419 00001EAB 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3420 00001EB2 B801000000                      mov rax, 1
  3421 00001EB7 EB5B                            jmp .end
  3422                                          
  3423                                      .check_paddle:
  3424                                          ; Verificar colisión con la paleta
  3425 00001EB9 4C8B15(3F140000)                mov r10, [pallet_position]
  3426 00001EC0 4981EA[000A0000]                sub r10, board
  3427 00001EC7 4C89D0                          mov rax, r10
  3428 00001ECA 41BB4E000000                    mov r11, column_cells
  3429 00001ED0 4983C302                        add r11, 2
  3430 00001ED4 4831D2                          xor rdx, rdx
  3431 00001ED7 49F7F3                          div r11                     ; División para obtener la posición Y
  3432 00001EDA 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3433                                          
  3434 00001EDD 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3435                                          
  3436                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3437 00001EE4 41BD20000000                    mov r13, row_cells
  3438 00001EEA 4983ED02                        sub r13, 2                 ; Y de la paleta
  3439 00001EEE 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3440 00001EF1 7519                            jne .next_enemy
  3441                                          
  3442                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3443 00001EF3 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3444 00001EF6 7C14                            jl .next_enemy
  3445                                          
  3446 00001EF8 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3447 00001EFB 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3448 00001EFE 7F0C                            jg .next_enemy
  3449                                          
  3450                                          ; Si llegamos aquí, hay colisión con la paleta
  3451 00001F00 E811000000                      call destroy_enemy        ; Destruir el enemigo
  3452 00001F05 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3453 00001F0A EB08                            jmp .end
  3454                                          
  3455                                      .next_enemy:
  3456 00001F0C 49FFC4                          inc r12
  3457 00001F0F E90DFFFFFF                      jmp .check_loop
  3458                                          
  3459                                      .end:
  3460 00001F14 5D                              pop rbp
  3461 00001F15 C3                              ret
  3462                                  
  3463                                  ; Función para destruir un enemigo
  3464                                  destroy_enemy:
  3465                                      ; Desactivar enemigo
  3466 00001F16 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3467                                  
  3468                                      ; Sumar puntos por destruir enemigo
  3469 00001F1A 488B05(DC150000)            mov rax, [enemy_points]
  3470 00001F21 480105(9B150000)            add [current_score], rax
  3471                                  
  3472                                      ; No tocar bloques destruidos aquí
  3473 00001F28 C3                          ret
  3474                                  
  3475                                  
  3476                                  _start:
  3477 00001F29 E8FDE1FFFF              	call canonical_off
  3478 00001F2E E853010000              	call start_screen
  3479 00001F33 E84AF4FFFF                  call init_level
  3480 00001F38 E8AAFAFFFF                  call init_enemies
  3481 00001F3D EB00                    	jmp .main_loop
  3482                                  	
  3483                                  
  3484                                      .main_loop:
  3485 00001F3F E861F8FFFF                      call print_labels
  3486 00001F44 E890F7FFFF                      call print_blocks
  3487 00001F49 E8ECE5FFFF                      call move_letters
  3488 00001F4E E8ABE8FFFF                      call update_lasers
  3489 00001F53 E857E5FFFF                      call print_letters
  3490 00001F58 E84CECFFFF                      call print_pallet
  3491                                          
  3492                                          ; Mover bola principal solo si está activa
  3493 00001F5D 803D(80140000)01                cmp byte [ball_active], 1
  3494 00001F64 7505                            jne .skip_ball1
  3495 00001F66 E856EDFFFF                          call move_ball
  3496                                          .skip_ball1:
  3497                                  
  3498                                          ; Mover bola 2 si está activa
  3499 00001F6B 803D(A2140000)01                cmp byte [ball2_active], 1
  3500 00001F72 7505                            jne .skip_ball2
  3501 00001F74 E81BEFFFFF                          call move_ball_2
  3502                                          .skip_ball2:
  3503                                  
  3504                                          ; Mover bola 3 si está activa
  3505 00001F79 803D(C4140000)01                cmp byte [ball3_active], 1
  3506 00001F80 7505                            jne .skip_ball3
  3507 00001F82 E8E0F0FFFF                          call move_ball_3
  3508                                          .skip_ball3:
  3509                                  
  3510 00001F87 E86AE3FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3511 00001F8C E84CE2FFFF                      call print_lives
  3512                                  
  3513                                          ; Imprimir solo las bolas activas
  3514 00001F91 803D(80140000)01                cmp byte [ball_active], 1
  3515 00001F98 7505                            jne .no_pb1
  3516 00001F9A E892EBFFFF                          call print_ball
  3517                                          .no_pb1:
  3518                                  
  3519 00001F9F 803D(A2140000)01                cmp byte [ball2_active], 1
  3520 00001FA6 7505                            jne .no_pb2
  3521 00001FA8 E8ACEBFFFF                          call print_ball_2
  3522                                          .no_pb2:
  3523                                  
  3524 00001FAD 803D(C4140000)01                cmp byte [ball3_active], 1
  3525 00001FB4 7505                            jne .no_pb3
  3526 00001FB6 E8C6EBFFFF                          call print_ball_3
  3527                                          .no_pb3:
  3528                                  
  3529 00001FBB E87BF5FFFF                      call check_level_complete
  3530 00001FC0 E88BFDFFFF                      call check_enemy_spawn
  3531 00001FC5 E82FFBFFFF                      call move_enemies
  3532 00001FCA E848FEFFFF                      call check_enemy_collision
  3533 00001FCF E8E9FDFFFF                      call print_enemies
  3534                                  		print board, board_size				
    82 00001FD4 B801000000          <1>  mov eax, sys_write
    83 00001FD9 BF01000000          <1>  mov edi, 1
    84 00001FDE 48BE-               <1>  mov rsi, %1
    84 00001FE0 [000A000000000000]  <1>
    85 00001FE8 BA000A0000          <1>  mov edx, %2
    86 00001FED 0F05                <1>  syscall
  3535                                  		;setnonblocking	
  3536                                  	.read_more:	
  3537                                  	    getchar	
    90 00001FEF B800000000          <1>  mov rax, sys_read
    91 00001FF4 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001FF9 48BE-               <1>  mov rsi, input_char
    92 00001FFB [0000000000000000]  <1>
    93 00002003 BA01000000          <1>  mov rdx, 1
    94 00002008 0F05                <1>  syscall
  3538 0000200A 4883F801                	    cmp rax, 1
  3539 0000200E 7543                    	    jne .done
  3540                                  	
  3541 00002010 8A05(00000000)          	    mov al, [input_char]
  3542 00002016 8805(64180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3543                                  	
  3544 0000201C 3C61                    	    cmp al, 'a'
  3545 0000201E 750E                    	    jne .not_left
  3546 00002020 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3547 00002027 E8B2EBFFFF              	    call move_pallet
  3548 0000202C EB25                    	    jmp .done
  3549                                  	
  3550                                      .not_left:
  3551 0000202E 3C64                    	    cmp al, 'd'
  3552 00002030 750C                    	    jne .not_right
  3553 00002032 BF01000000              	    mov rdi, right_direction
  3554 00002037 E8A2EBFFFF              	    call move_pallet
  3555 0000203C EB15                    	    jmp .done
  3556                                  	
  3557                                      .not_right:
  3558 0000203E 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3559 00002040 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3560                                  	
  3561 00002042 3C71                    	    cmp al, 'q' 
  3562 00002044 0F84AF000000            	    je exit
  3563 0000204A EBA3                    	    jmp .read_more
  3564                                  	
  3565                                      .release_ball:
  3566 0000204C E8E9F1FFFF              	    call process_catch_release
  3567 00002051 EB00                    	    jmp .done
  3568                                  	
  3569                                      .done:
  3570                                  	    sleeptime
    98 00002053 B823000000          <1>  mov eax, sys_nanosleep
    99 00002058 48BF-               <1>  mov rdi, timespec
    99 0000205A [0000000000000000]  <1>
   100 00002062 31F6                <1>  xor esi, esi
   101 00002064 0F05                <1>  syscall
  3571                                  	    print clear, clear_length
    82 00002066 B801000000          <1>  mov eax, sys_write
    83 0000206B BF01000000          <1>  mov edi, 1
    84 00002070 48BE-               <1>  mov rsi, %1
    84 00002072 [1000000000000000]  <1>
    85 0000207A BA07000000          <1>  mov edx, %2
    86 0000207F 0F05                <1>  syscall
  3572 00002081 E9B9FEFFFF              	    jmp .main_loop
  3573                                  
  3574                                  
  3575                                  
  3576                                  
  3577                                  start_screen:
  3578                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00002086 B801000000          <1>  mov eax, sys_write
    83 0000208B BF01000000          <1>  mov edi, 1
    84 00002090 48BE-               <1>  mov rsi, %1
    84 00002092 [1000000000000000]  <1>
    85 0000209A BA07000000          <1>  mov edx, %2
    86 0000209F 0F05                <1>  syscall
  3579                                      print msg1, msg1_length
    82 000020A1 B801000000          <1>  mov eax, sys_write
    83 000020A6 BF01000000          <1>  mov edi, 1
    84 000020AB 48BE-               <1>  mov rsi, %1
    84 000020AD [1700000000000000]  <1>
    85 000020B5 BA14010000          <1>  mov edx, %2
    86 000020BA 0F05                <1>  syscall
  3580                                      
  3581                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3582                                          getchar                 ; Esperamos una tecla
    90 000020BC B800000000          <1>  mov rax, sys_read
    91 000020C1 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000020C6 48BE-               <1>  mov rsi, input_char
    92 000020C8 [0000000000000000]  <1>
    93 000020D0 BA01000000          <1>  mov rdx, 1
    94 000020D5 0F05                <1>  syscall
  3583 000020D7 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3584 000020DB 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3585                                          
  3586                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000020DD B801000000          <1>  mov eax, sys_write
    83 000020E2 BF01000000          <1>  mov edi, 1
    84 000020E7 48BE-               <1>  mov rsi, %1
    84 000020E9 [1000000000000000]  <1>
    85 000020F1 BA07000000          <1>  mov edx, %2
    86 000020F6 0F05                <1>  syscall
  3587 000020F8 C3                          ret
  3588                                  
  3589                                  exit: 
  3590 000020F9 E86FE0FFFF              	call canonical_on
  3591 000020FE B83C000000              	mov    rax, 60
  3592 00002103 BF00000000                  mov    rdi, 0
  3593 00002108 0F05                        syscall
  3594                                  
