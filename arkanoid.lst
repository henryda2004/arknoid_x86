     1                                  bits 64;codigo destinado a arcquitectura de 64 bits
     2                                  default rel;configura el uso de direcciones relativas, que son mas flecibles
     3                                  
     4                                  
     5                                  ;RAX: Registro acumulador. Se utiliza generalmente para operaciones aritméticas y como valor de retorno de funciones.
     6                                  ;RBX: Registro base. Generalmente preservado entre llamadas a funciones.
     7                                  ;RCX: Contador. Usado en operaciones de repetición y bucles.
     8                                  ;RDX: Registro de datos. Se usa en operaciones aritméticas complejas y como argumento adicional en llamadas a funciones.
     9                                  ;RDI y RSI: Usados para pasar parámetros en las llamadas a funciones. RDI es el primer argumento, RSI el segundo.
    10                                  ;RBP: Registro base del marco de pila. Usado para rastrear la base del stack frame en funciones.
    11                                  ;RSP: Puntero de pila. Rastrea el tope de la pila.
    12                                  ;R8-R15: Registros adicionales introducidos en x86-64 para proporcionar más flexibilidad.
    13                                  
    14                                  
    15                                  
    16                                  ; definiciones de llamadas al sistema operativo
    17                                  sys_read: equ 0	;equ es como define y estos numeros se basan en la tabla se syscalls de x86
    18                                  sys_write:	equ 1
    19                                  sys_nanosleep:	equ 35
    20                                  sys_time:	equ 201
    21                                  sys_fcntl:	equ 72
    22                                  
    23                                  ;configurcaion de archivo descriptor
    24                                  STDIN_FILENO: equ 0
    25                                  
    26                                  F_SETFL:	equ 0x0004
    27                                  O_NONBLOCK: equ 0x0004
    28                                  
    29                                  ;screen clean definition
    30                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    31                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    32                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    33                                  
    34                                  ;intervalos de tiempo utilizados
    35                                  timespec:
    36 00000000 0000000000000000            tv_sec  dq 0
    37 00000008 002D310100000000            tv_nsec dq 20000000
    38                                  
    39                                  
    40                                  ;This is for cleaning up the screen
    41 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H";27 es el codigo de escape, [2J limpia la pantalla y [H mueve el cursor al inicio
    42                                  clear_length:	equ $-clear
    43                                  	
    44                                  	
    45                                  
    46                                  ; Start Message
    47 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD;salto de linea y retorno de carro
    47 00000020 45434E4F4C4F474943-
    47 00000029 4F20444520434F5354-
    47 00000032 412052494341202020-
    47 0000003B 20202020200A0D     
    48 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    48 0000004B 525155495445435455-
    48 00000054 524120444520434F4D-
    48 0000005D 50555441444F524153-
    48 00000066 204920202020202020-
    48 0000006F 200A0D             
    49 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    49 0000007B 5354554449414E5445-
    49 00000084 3A2048454E5259204E-
    49 0000008D 554E455A2050455245-
    49 00000096 5A2020202020202020-
    49 0000009F 0A0D               
    50 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    50 000000AA 524F4645534F523A20-
    50 000000B3 45524E4553544F2052-
    50 000000BC 495645524120414C56-
    50 000000C5 415241444F20202020-
    50 000000CE 202020200A0D       
    51 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    51 000000DD 524B414E4F49442052-
    51 000000E6 4554524F2020202020-
    51 000000EF 2020200A0D         
    52 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    52 000000FD 524553494F4E452043-
    52 00000106 55414C515549455220-
    52 0000010F 5445434C4120504152-
    52 00000118 4120494E4943494152-
    52 00000121 20202020202020200A-
    52 0000012A 0D                 
    53                                  msg1_length: equ $-msg1;calcula la longitud del mensaje
    54                                  msg2_length: equ $-msg2
    55                                  msg3_length: equ $-msg3
    56                                  msg4_length: equ $-msg4
    57                                  msg5_length: equ $-msg5
    58                                  msg6_length: equ $-msg6
    59                                  
    60                                  ; Usefull macros
    61                                  
    62                                  
    63                                  
    64                                  %macro setnonblocking 0;este macro se encarga de configurar el archivo descriptor para que no bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    65                                  	mov rax, sys_fcntl
    66                                      mov rdi, STDIN_FILENO
    67                                      mov rsi, F_SETFL
    68                                      mov rdx, O_NONBLOCK
    69                                      syscall
    70                                  %endmacro
    71                                  
    72                                  %macro unsetnonblocking 0;este macro se encarga de configurar el archivo descriptor para que bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    73                                  	mov rax, sys_fcntl
    74                                      mov rdi, STDIN_FILENO
    75                                      mov rsi, F_SETFL
    76                                      mov rdx, 0
    77                                      syscall
    78                                  %endmacro
    79                                  
    80                                  %macro full_line 0;este macro se encarga de dibujar una linea completa en la pantalla, se usa para dibujar el tablero
    81                                      times column_cells db "X"
    82                                      db 0x0a, 0xD
    83                                  %endmacro
    84                                  
    85                                  %macro hollow_line 0;este macro se encarga de dibujar una linea hueca en la pantalla, se usa para dibujar el tablero
    86                                      db "X"
    87                                      times column_cells-2 db " "
    88                                      db "X", 0x0a, 0xD
    89                                  %endmacro
    90                                  
    91                                  
    92                                  %macro print 2;este se usa para imprimir en pantalla, se encarga de escribir en pantalla
    93                                  	mov eax, sys_write
    94                                  	mov edi, 1 	; stdout
    95                                  	mov rsi, %1
    96                                  	mov edx, %2
    97                                  	syscall
    98                                  %endmacro
    99                                  
   100                                  %macro getchar 0;este se usa para leer una tecla presionada, se encarga de leer una tecla presionada
   101                                  	mov     rax, sys_read
   102                                      mov     rdi, STDIN_FILENO
   103                                      mov     rsi, input_char
   104                                      mov     rdx, 1 ; number of bytes
   105                                      syscall         ;read text input from keyboard
   106                                  %endmacro
   107                                  
   108                                  %macro sleeptime 0;este se usa para dormir el programa por un tiempo determinado, se encarga de dormir el programa por un tiempo determinado
   109                                  	mov eax, sys_nanosleep
   110                                  	mov rdi, timespec
   111                                  	xor esi, esi		; ignore remaining time in case of call interruption
   112                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   113                                  %endmacro
   114                                  
   115                                  
   116                                  
   117                                  global _start;se declara la etiqueta global _start, que es el punto de entrada del programa
   118                                  
   119                                  section .bss;seccion bss, se usa para declarar variables no inicializadas
   120                                  
   121 00000000 ??                      input_char: resb 1;reserva un byte para almacenar la tecla presionada
   122                                  
   123                                  section .data;seccion data, se usa para declarar variables inicializadas
   124                                  
   125                                  	; Guardamos la plantilla del tablero (32 filas)
   126                                      board_template:;se declara la plantilla del tablero, se hace asi porque se necesita dibujar el tablero en pantalla
   127                                          full_line
    81 00000000 58<rep 50h>         <1>  times column_cells db "X"
    82 00000050 0A0D                <1>  db 0x0a, 0xD
   128                                          %rep 30
   129                                          hollow_line
   130                                          %endrep
   129                              <1>  hollow_line
    86 00000052 58                  <2>  db "X"
    87 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000A4 58                  <2>  db "X"
    87 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000F6 58                  <2>  db "X"
    87 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000148 58                  <2>  db "X"
    87 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000019A 58                  <2>  db "X"
    87 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000001EC 58                  <2>  db "X"
    87 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000023E 58                  <2>  db "X"
    87 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000290 58                  <2>  db "X"
    87 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000002E2 58                  <2>  db "X"
    87 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000334 58                  <2>  db "X"
    87 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000386 58                  <2>  db "X"
    87 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000003D8 58                  <2>  db "X"
    87 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000042A 58                  <2>  db "X"
    87 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000047C 58                  <2>  db "X"
    87 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000004CE 58                  <2>  db "X"
    87 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000520 58                  <2>  db "X"
    87 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000572 58                  <2>  db "X"
    87 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000005C4 58                  <2>  db "X"
    87 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000616 58                  <2>  db "X"
    87 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000668 58                  <2>  db "X"
    87 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000006BA 58                  <2>  db "X"
    87 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000070C 58                  <2>  db "X"
    87 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000075E 58                  <2>  db "X"
    87 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000007B0 58                  <2>  db "X"
    87 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000802 58                  <2>  db "X"
    87 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000854 58                  <2>  db "X"
    87 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008A6 58                  <2>  db "X"
    87 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008F8 58                  <2>  db "X"
    87 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000094A 58                  <2>  db "X"
    87 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000099C 58                  <2>  db "X"
    87 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   131                                          full_line
    81 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    82 00000A3E 0A0D                <1>  db 0x0a, 0xD
   132                                      board_template_size: equ $ - board_template;esto calcula el tamaño de la plantilla del tablero
   133                                  
   134                                      ; Espacio real que se usará en la ejecución
   135 00000A40 00<rep A40h>                board: times board_template_size db 0;times sirve para repetir un valor, en este caso se repite el tamaño de la plantilla del tablero
   136                                      board_size: equ board_template_size
   137                                  
   138                                  	; Added for the terminal issue
   139 00001480 00<rep 24h>             	termios:        times 36 db 0;termios es una estructura que se usa para configurar el terminal, se inicializa en 0
   140                                  	stdin:          equ 0;stdin es el archivo descriptor del terminal, se inicializa en 0
   141                                  	ICANON:         equ 1<<1;ICANON es una bandera que se usa para configurar el terminal, se inicializa en 1<<1
   142                                  	ECHO:           equ 1<<3;ECHO es una bandera que se usa para configurar el terminal, se inicializa en 1<<3
   143                                  	VTIME: 			equ 5;VTIME es una bandera que se usa para configurar el terminal, se inicializa en 5
   144                                  	VMIN:			equ 6;VMIN es una bandera que se usa para configurar el terminal, se inicializa en 6
   145                                  	CC_C:			equ 18;CC_C es una bandera que se usa para configurar el terminal, se inicializa en 18
   146                                  
   147                                  section .text
   148                                  canonical_off:;esta funcion se encarga de apagar el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser borrado porque no se necesita
   149 0000012B E86F000000                      call read_stdin_termios
   150                                  
   151                                          ; aqui abajo que pasa es que se apaga el bit de canonical en los flags de modo local, eso significa que se apaga el modo canonico
   152 00000130 50                              push rax
   153 00000131 B802000000                      mov eax, ICANON
   154 00000136 F7D0                            not eax
   155 00000138 2105(8C140000)                  and [termios+12], eax
   156 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   157 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   158 0000014C 58                              pop rax
   159                                  
   160 0000014D E86C000000                      call write_stdin_termios
   161 00000152 C3                              ret
   162                                  
   163                                  echo_off:;esta funcion se encarga de apagar el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se apga porque no se necesita
   164 00000153 E847000000                      call read_stdin_termios
   165                                  
   166                                          ; abajo lo que pasa esque se apaga el bit de echo en los flags de modo local, eso significa que se apaga el eco
   167 00000158 50                              push rax
   168 00000159 B808000000                      mov eax, ECHO
   169 0000015E F7D0                            not eax
   170 00000160 2105(8C140000)                  and [termios+12], eax
   171 00000166 58                              pop rax
   172                                  
   173 00000167 E852000000                      call write_stdin_termios
   174 0000016C C3                              ret
   175                                  
   176                                  canonical_on:;esta funcion se encarga de encender el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser encendido porque se necesita
   177 0000016D E82D000000                      call read_stdin_termios
   178                                  
   179                                          ; esto lo que hace es que prende el bit de canonical en los flags de modo local, eso significa que se prende el modo canonico
   180 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   181 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   182 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   183 00000187 E832000000                      call write_stdin_termios
   184 0000018C C3                              ret
   185                                  
   186                                  echo_on:;esta funcion se encarga de encender el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se enciende porque se necesita
   187 0000018D E80D000000                      call read_stdin_termios
   188                                  
   189                                          ; set echo bit in local mode flags
   190 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   191                                  
   192 00000199 E820000000                      call write_stdin_termios
   193 0000019E C3                              ret
   194                                  
   195                                  read_stdin_termios:;esta funcion se encarga de leer la configuracion del terminal, lo hace mediante una llamada al sistema
   196 0000019F 50                              push rax
   197 000001A0 53                              push rbx
   198 000001A1 51                              push rcx
   199 000001A2 52                              push rdx
   200                                  
   201 000001A3 B836000000                      mov eax, 36h
   202 000001A8 BB00000000                      mov ebx, stdin
   203 000001AD B901540000                      mov ecx, 5401h
   204 000001B2 BA[80140000]                    mov edx, termios
   205 000001B7 CD80                            int 80h
   206                                  
   207 000001B9 5A                              pop rdx
   208 000001BA 59                              pop rcx
   209 000001BB 5B                              pop rbx
   210 000001BC 58                              pop rax
   211 000001BD C3                              ret
   212                                  
   213                                  write_stdin_termios:;esta funcion se encarga de escribir la configuracion del terminal, lo hace mediante una llamada al sistema
   214 000001BE 50                              push rax
   215 000001BF 53                              push rbx
   216 000001C0 51                              push rcx
   217 000001C1 52                              push rdx
   218                                  
   219 000001C2 B836000000                      mov eax, 36h
   220 000001C7 BB00000000                      mov ebx, stdin
   221 000001CC B902540000                      mov ecx, 5402h
   222 000001D1 BA[80140000]                    mov edx, termios
   223 000001D6 CD80                            int 80h
   224                                  
   225 000001D8 5A                              pop rdx
   226 000001D9 59                              pop rcx
   227 000001DA 5B                              pop rbx
   228 000001DB 58                              pop rax
   229 000001DC C3                              ret
   230                                  
   231                                  
   232                                  char_equal: equ 61;se inicializa el caracter "="
   233                                  char_space: equ 32;se inicializa el caracter " "
   234                                  char_O: equ 79;se inicializa el caracter "O"
   235                                  left_direction: equ -1;se inicializa la direccion izquierda
   236                                  right_direction: equ 1;se inicializa la direccion derecha
   237                                  
   238                                  
   239                                  section .data
   240                                  
   241                                  ; Mensajes para los niveles
   242 000014A4 4E4956454C20                level_msg: db "NIVEL "
   243                                      level_msg_len: equ $ - level_msg
   244 000014AA 31                          level_1_char: db "1"
   245 000014AB 32                          level_2_char: db "2"
   246 000014AC 33                          level_3_char: db "3"
   247 000014AD 34                          level_4_char: db "4"
   248 000014AE 35                          level_5_char: db "5"
   249                                      level_char_len: equ 1
   250                                  
   251                                      ; Timespec para la pausa del mensaje de nivel
   252                                      level_display_time:
   253 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   254 000014B7 0000000000000000                lvl_tv_nsec dq 0
   255                                          
   256 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   257 000014C7 0500000000000000            pallet_size dq 5
   258 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   259 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   260                                  
   261 000014DF 2800000000000000        	ball_x_pos: dq 40
   262 000014E7 1C00000000000000        	ball_y_pos: dq 28
   263 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   264 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   265 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   266 00001500 00                          ball_active db 0
   267                                  
   268 00001501 0000000000000000            ball2_x_pos:        dq 0
   269 00001509 0000000000000000            ball2_y_pos:        dq 0
   270 00001511 0000000000000000            ball2_direction_x:  dq 0
   271 00001519 0000000000000000            ball2_direction_y:  dq 0
   272 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   273 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   274                                  
   275                                      ; -- Pelota 3 --
   276 00001523 0000000000000000            ball3_x_pos:        dq 0
   277 0000152B 0000000000000000            ball3_y_pos:        dq 0
   278 00001533 0000000000000000            ball3_direction_x:  dq 0
   279 0000153B 0000000000000000            ball3_direction_y:  dq 0
   280 00001543 00                          ball3_moving:       db 0
   281 00001544 00                          ball3_active:       db 0
   282                                  
   283                                  
   284                                  ; Definir los límites de la pantalla o área de juego
   285                                      board_top_left_x equ 1
   286                                      board_top_left_y equ 1
   287                                      board_bottom_right_x equ column_cells - 1
   288                                      board_bottom_right_y equ row_cells
   289                                  
   290                                      ; Limites laterales
   291                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   292                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   293                                  
   294                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   295 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   296 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   297                                  
   298                                      ; Definición de tipos de bloques
   299 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   300 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   301 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   302 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   303 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   304 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   305                                      block_length: equ 6        ; Longitud de cada bloque
   306                                  
   307                                      ; Estructura para el nivel actual
   308 00001579 01                          current_level db 1
   309 0000157A 00                          blocks_remaining db 0
   310                                  
   311                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   312                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   313                                      level1_blocks:
   314                                          ; Tercera fila (tipo 3)
   315 0000157B 0105050220                      db 1, 5, 5, 2, ' '   
   316 00001580 0705050220                      db 7, 5, 5, 2, ' '    
   317 00001585 0D05050220                      db 13, 5, 5, 2, ' '   
   318 0000158A 1305050220                      db 19, 5, 5, 2, ' '   
   319 0000158F 1905050220                      db 25, 5, 5, 2, ' '   
   320 00001594 1F05050220                      db 31, 5, 5, 2, ' '   
   321 00001599 2505050220                      db 37, 5, 5, 2, ' '   
   322 0000159E 2B05050220                      db 43, 5, 5, 2, ' '   
   323 000015A3 3105050220                      db 49, 5, 5, 2, ' '   
   324 000015A8 3705050220                      db 55, 5, 5, 2, ' '   
   325 000015AD 3D05050220                      db 61, 5, 5, 2, ' '  
   326 000015B2 4305050220                      db 67, 5, 5, 2, ' '   
   327 000015B7 4905050220                      db 73, 5, 5, 2, ' '   
   328                                  
   329 000015BC 0106040145                      db 1, 6, 4, 1, 'E'   
   330 000015C1 0706020153                      db 7, 6, 2, 1, 'S'    
   331 000015C6 0D06040153                      db 13, 6, 4, 1, 'S'   
   332 000015CB 1306020153                      db 19, 6, 2, 1, 'S'   
   333 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   334 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   335 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   336 000015DF 2B06020143                      db 43, 6, 2, 1, 'C'   
   337 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   338 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   339 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   340 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   341 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   342                                  
   343 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   344 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   345 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   346 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   347 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   348 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   349 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   350 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   351 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   352 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   353 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   354 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   355 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   356                                  
   357 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   358 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   359 00001648 0D08040150                      db 13, 8, 4, 1, 'P'   
   360 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   361 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   362 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   363 0000165C 2508040145                      db 37, 8, 4, 1, 'E'   
   364 00001661 2B08020143                      db 43, 8, 2, 1, 'C'   
   365 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   366 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   367 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   368 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   369 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   370                                  
   371 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   372 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   373 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   374 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   375 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   376 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   377 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   378 000016A2 2B09030120                      db 43, 9, 3, 1, ' '     
   379 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   380 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   381 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   382 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   383 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   384                                  
   385 000016C0 010A040145                      db 1, 10, 4, 1, 'E'   
   386 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   387 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   388 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   389 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   390 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   391 000016DE 250A040143                      db 37, 10, 4, 1, 'C'   
   392 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   393 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   394 000016ED 370A020144                      db 55, 10, 2, 1, 'D'   
   395 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   396 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   397 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   398                                  
   399                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   400                                  
   401                                      ; Nivel 2: Bloques de prueba
   402                                      level2_blocks:
   403 00001701 0103040120                      db 1, 3, 4, 1, ' '
   404                                  
   405 00001706 0104030120                      db 1, 4, 3, 1, ' '   
   406 0000170B 0704040120                      db 7, 4, 4, 1, ' '   
   407                                                  
   408 00001710 0105020120                      db 1, 5, 2, 1, ' '   
   409 00001715 0705030120                      db 7, 5, 3, 1, ' '
   410 0000171A 0D05040144                      db 13, 5, 4, 1, 'D'
   411                                  
   412 0000171F 0106010120                      db 1, 6, 1, 1, ' '   
   413 00001724 0706020120                      db 7, 6, 2, 1, ' '
   414 00001729 0D06030120                      db 13, 6, 3, 1, ' '
   415 0000172E 1306040120                      db 19, 6, 4, 1, ' '   
   416                                  
   417 00001733 0107040120                      db 1, 7, 4, 1, ' '   
   418 00001738 0707010120                      db 7, 7, 1, 1, ' '
   419 0000173D 0D07020120                      db 13, 7, 2, 1, ' '
   420 00001742 1307030120                      db 19, 7, 3, 1, ' '  
   421 00001747 1907040120                      db 25, 7, 4, 1, ' '   
   422                                  
   423 0000174C 0108030120                      db 1, 8, 3, 1, ' '   
   424 00001751 0708040120                      db 7, 8, 4, 1, ' '
   425 00001756 0D08010120                      db 13, 8, 1, 1, ' '
   426 0000175B 1308020120                      db 19, 8, 2, 1, ' '  
   427 00001760 1908030120                      db 25, 8, 3, 1, ' ' 
   428 00001765 1F08040120                      db 31, 8, 4, 1, ' '   
   429                                  
   430 0000176A 0109020120                      db 1, 9, 2, 1, ' '   
   431 0000176F 0709030120                      db 7, 9, 3, 1, ' '
   432 00001774 0D09040120                      db 13, 9, 4, 1, ' '
   433 00001779 1309010120                      db 19, 9, 1, 1, ' '  
   434 0000177E 1909020120                      db 25, 9, 2, 1, ' ' 
   435 00001783 1F09030143                      db 31, 9, 3, 1, 'C' 
   436 00001788 2509040120                      db 37, 9, 4, 1, ' '   
   437                                  
   438 0000178D 010A010120                      db 1, 10, 1, 1, ' '   
   439 00001792 070A020120                      db 7, 10, 2, 1, ' '
   440 00001797 0D0A030120                      db 13, 10, 3, 1, ' '
   441 0000179C 130A040120                      db 19, 10, 4, 1, ' '  
   442 000017A1 190A010120                      db 25, 10, 1, 1, ' ' 
   443 000017A6 1F0A020120                      db 31, 10, 2, 1, ' ' 
   444 000017AB 250A03014C                      db 37, 10, 3, 1, 'L'  
   445 000017B0 2B0A040120                      db 43, 10, 4, 1, ' '   
   446                                  
   447 000017B5 010B040120                      db 1, 11, 4, 1, ' '   
   448 000017BA 070B010120                      db 7, 11, 1, 1, ' '
   449 000017BF 0D0B020120                      db 13, 11, 2, 1, ' '
   450 000017C4 130B030144                      db 19, 11, 3, 1, 'D'  
   451 000017C9 190B040120                      db 25, 11, 4, 1, ' ' 
   452 000017CE 1F0B010120                      db 31, 11, 1, 1, ' ' 
   453 000017D3 250B020120                      db 37, 11, 2, 1, ' '  
   454 000017D8 2B0B030120                      db 43, 11, 3, 1, ' ' 
   455 000017DD 310B040120                      db 49, 11, 4, 1, ' '   
   456                                  
   457 000017E2 010C030120                      db 1, 12, 3, 1, ' '   
   458 000017E7 070C040120                      db 7, 12, 4, 1, ' '
   459 000017EC 0D0C010120                      db 13, 12, 1, 1, ' '
   460 000017F1 130C020120                      db 19, 12, 2, 1, ' '  
   461 000017F6 190C030120                      db 25, 12, 3, 1, ' ' 
   462 000017FB 1F0C040120                      db 31, 12, 4, 1, ' ' 
   463 00001800 250C010120                      db 37, 12, 1, 1, ' '  
   464 00001805 2B0C020120                      db 43, 12, 2, 1, ' ' 
   465 0000180A 310C030120                      db 49, 12, 3, 1, ' '
   466 0000180F 370C040120                      db 55, 12, 4, 1, ' '   
   467                                  
   468 00001814 010D020120                      db 1, 13, 2, 1, ' '   
   469 00001819 070D030120                      db 7, 13, 3, 1, ' '
   470 0000181E 0D0D040120                      db 13, 13, 4, 1, ' '
   471 00001823 130D010144                      db 19, 13, 1, 1, 'D'  
   472 00001828 190D020120                      db 25, 13, 2, 1, ' ' 
   473 0000182D 1F0D030120                      db 31, 13, 3, 1, ' ' 
   474 00001832 250D040120                      db 37, 13, 4, 1, ' '  
   475 00001837 2B0D010120                      db 43, 13, 1, 1, ' ' 
   476 0000183C 310D020120                      db 49, 13, 2, 1, ' '
   477 00001841 370D030120                      db 55, 13, 3, 1, ' ' 
   478 00001846 3D0D040120                      db 61, 13, 4, 1, ' '   
   479                                  
   480 0000184B 010E010120                      db 1, 14, 1, 1, ' '   
   481 00001850 070E020120                      db 7, 14, 2, 1, ' '
   482 00001855 0D0E030120                      db 13, 14, 3, 1, ' '
   483 0000185A 130E040120                      db 19, 14, 4, 1, ' '  
   484 0000185F 190E010120                      db 25, 14, 1, 1, ' ' 
   485 00001864 1F0E020120                      db 31, 14, 2, 1, ' ' 
   486 00001869 250E030120                      db 37, 14, 3, 1, ' '  
   487 0000186E 2B0E040120                      db 43, 14, 4, 1, ' ' 
   488 00001873 310E010120                      db 49, 14, 1, 1, ' '
   489 00001878 370E020120                      db 55, 14, 2, 1, ' ' 
   490 0000187D 3D0E030120                      db 61, 14, 3, 1, ' '  
   491 00001882 430E040120                      db 67, 14, 4, 1, ' '   
   492                                  
   493 00001887 010F050220                      db 1, 15, 5, 2, ' '   
   494 0000188C 070F050220                      db 7, 15, 5, 2, ' '
   495 00001891 0D0F050220                      db 13, 15, 5, 2, ' '
   496 00001896 130F050220                      db 19, 15, 5, 2, ' '  
   497 0000189B 190F050220                      db 25, 15, 5, 2, ' ' 
   498 000018A0 1F0F050220                      db 31, 15, 5, 2, ' ' 
   499 000018A5 250F050220                      db 37, 15, 5, 2, ' '  
   500 000018AA 2B0F050220                      db 43, 15, 5, 2, ' ' 
   501 000018AF 310F050220                      db 49, 15, 5, 2, ' '
   502 000018B4 370F050220                      db 55, 15, 5, 2, ' ' 
   503 000018B9 3D0F050220                      db 61, 15, 5, 2, ' '  
   504 000018BE 430F050220                      db 67, 15, 5, 2, ' '
   505 000018C3 490F040120                      db 73, 15, 4, 1, ' '   
   506                                         
   507                                  
   508                                      level2_blocks_count equ 91
   509                                  
   510                                      ; Nivel 3
   511                                      level3_blocks:
   512                                  
   513 000018C8 0102010120                      db 1, 2, 1, 1, ' '   
   514 000018CD 0702020120                      db 7, 2, 2, 1, ' '    
   515 000018D2 0D02010120                      db 13, 2, 1, 1, ' '   
   516 000018D7 1302020120                      db 19, 2, 2, 1, ' '   
   517 000018DC 1902010120                      db 25, 2, 1, 1, ' '   
   518 000018E1 1F02020120                      db 31, 2, 2, 1, ' '   
   519 000018E6 2502010120                      db 37, 2, 1, 1, ' '   
   520 000018EB 2B02020120                      db 43, 2, 2, 1, ' '   
   521 000018F0 3102010120                      db 49, 2, 1, 1, ' '   
   522 000018F5 3702020120                      db 55, 2, 2, 1, ' '   
   523 000018FA 3D02010120                      db 61, 2, 1, 1, ' '  
   524 000018FF 4302020120                      db 67, 2, 2, 1, ' '   
   525 00001904 4902010120                      db 73, 2, 1, 1, ' ' 
   526                                  
   527 00001909 0106040120                      db 1, 6, 4, 1, ' '   
   528 0000190E 0706040120                      db 7, 6, 4, 1, ' '    
   529 00001913 0D06040120                      db 13, 6, 4, 1, ' '   
   530 00001918 1306066320                      db 19, 6, 6, 99, ' '   
   531 0000191D 1906066320                      db 25, 6, 6, 99, ' '   
   532 00001922 1F06066320                      db 31, 6, 6, 99, ' '   
   533 00001927 2506066320                      db 37, 6, 6, 99, ' '   
   534 0000192C 2B06066320                      db 43, 6, 6, 99, ' '   
   535 00001931 3106066320                      db 49, 6, 6, 99, ' '   
   536 00001936 3706066320                      db 55, 6, 6, 99, ' '   
   537 0000193B 3D06066320                      db 61, 6, 6, 99, ' '  
   538 00001940 4306066320                      db 67, 6, 6, 99, ' '   
   539 00001945 4906066320                      db 73, 6, 6, 99, ' ' 
   540                                  
   541 0000194A 0108040120                      db 1, 8, 4, 1, ' '   
   542 0000194F 0708030120                      db 7, 8, 3, 1, ' '    
   543 00001954 0D08040120                      db 13, 8, 4, 1, ' '   
   544 00001959 1308030120                      db 19, 8, 3, 1, ' '   
   545 0000195E 1908040120                      db 25, 8, 4, 1, ' '   
   546 00001963 1F08030120                      db 31, 8, 3, 1, ' '   
   547 00001968 2508040120                      db 37, 8, 4, 1, ' '   
   548 0000196D 2B08030120                      db 43, 8, 3, 1, ' '   
   549 00001972 3108040120                      db 49, 8, 4, 1, ' '   
   550 00001977 3708030120                      db 55, 8, 3, 1, ' '   
   551 0000197C 3D08040120                      db 61, 8, 4, 1, ' '  
   552 00001981 4308030120                      db 67, 8, 3, 1, ' '   
   553 00001986 4908040120                      db 73, 8, 4, 1, ' ' 
   554                                  
   555 0000198B 010B066320                      db 1, 11, 6, 99, ' '   
   556 00001990 070B066320                      db 7, 11, 6, 99, ' '    
   557 00001995 0D0B066320                      db 13, 11, 6, 99, ' '   
   558 0000199A 130B066320                      db 19, 11, 6, 99, ' '   
   559 0000199F 190B066320                      db 25, 11, 6, 99, ' '   
   560 000019A4 1F0B066320                      db 31, 11, 6, 99, ' '   
   561 000019A9 250B066320                      db 37, 11, 6, 99, ' '   
   562 000019AE 2B0B066320                      db 43, 11, 6, 99, ' '   
   563 000019B3 310B066320                      db 49, 11, 6, 99, ' '   
   564 000019B8 370B066320                      db 55, 11, 6, 99, ' '   
   565 000019BD 3D0B030144                      db 61, 11, 3, 1, 'D'  
   566 000019C2 430B030120                      db 67, 11, 3, 1, ' '   
   567 000019C7 490B030120                      db 73, 11, 3, 1, ' ' 
   568                                  
   569 000019CC 010D010144                      db 1, 13, 1, 1, 'D'   
   570 000019D1 070D020150                      db 7, 13, 2, 1, 'P'    
   571 000019D6 0D0D010143                      db 13, 13, 1, 1, 'C'   
   572 000019DB 130D020120                      db 19, 13, 2, 1, ' '   
   573 000019E0 190D010120                      db 25, 13, 1, 1, ' '   
   574 000019E5 1F0D020120                      db 31, 13, 2, 1, ' '   
   575 000019EA 250D010120                      db 37, 13, 1, 1, ' '   
   576 000019EF 2B0D020120                      db 43, 13, 2, 1, ' '   
   577 000019F4 310D010120                      db 49, 13, 1, 1, ' '   
   578 000019F9 370D020120                      db 55, 13, 2, 1, ' '   
   579 000019FE 3D0D010120                      db 61, 13, 1, 1, ' '  
   580 00001A03 430D020120                      db 67, 13, 2, 1, ' '   
   581 00001A08 490D010120                      db 73, 13, 1, 1, ' ' 
   582                                  
   583 00001A0D 010F020120                      db 1, 15, 2, 1, ' '   
   584 00001A12 070F020120                      db 7, 15, 2, 1, ' '    
   585 00001A17 0D0F020120                      db 13, 15, 2, 1, ' '   
   586 00001A1C 130F066320                      db 19, 15, 6, 99, ' '   
   587 00001A21 190F066320                      db 25, 15, 6, 99, ' '   
   588 00001A26 1F0F066320                      db 31, 15, 6, 99, ' '   
   589 00001A2B 250F066320                      db 37, 15, 6, 99, ' '   
   590 00001A30 2B0F066320                      db 43, 15, 6, 99, ' '   
   591 00001A35 310F066320                      db 49, 15, 6, 99, ' '   
   592 00001A3A 370F066320                      db 55, 15, 6, 99, ' '   
   593 00001A3F 3D0F066320                      db 61, 15, 6, 99, ' '  
   594 00001A44 430F066320                      db 67, 15, 6, 99, ' '   
   595 00001A49 490F066320                      db 73, 15, 6, 99, ' ' 
   596                                  
   597 00001A4E 0112020120                      db 1, 18, 2, 1, ' '   
   598 00001A53 0712030120                      db 7, 18, 3, 1, ' '    
   599 00001A58 0D12020144                      db 13, 18, 2, 1, 'D'   
   600 00001A5D 1312030120                      db 19, 18, 3, 1, ' '   
   601 00001A62 1912020120                      db 25, 18, 2, 1, ' '   
   602 00001A67 1F12030120                      db 31, 18, 3, 1, ' '   
   603 00001A6C 2512020120                      db 37, 18, 2, 1, ' '   
   604 00001A71 2B12030120                      db 43, 18, 3, 1, ' '   
   605 00001A76 3112020120                      db 49, 18, 2, 1, ' '   
   606 00001A7B 3712030144                      db 55, 18, 3, 1, 'D'   
   607 00001A80 3D12020120                      db 61, 18, 2, 1, ' '  
   608 00001A85 4312030143                      db 67, 18, 3, 1, 'C'   
   609 00001A8A 4912020120                      db 73, 18, 2, 1, ' ' 
   610                                  
   611                                  
   612 00001A8F 0114066320                      db 1, 20, 6, 99, ' '   
   613 00001A94 0714066320                      db 7, 20, 6, 99, ' '    
   614 00001A99 0D14066320                      db 13, 20, 6, 99, ' '   
   615 00001A9E 1314066320                      db 19, 20, 6, 99, ' '   
   616 00001AA3 1914066320                      db 25, 20, 6, 99, ' '   
   617 00001AA8 1F14066320                      db 31, 20, 6, 99, ' '   
   618 00001AAD 2514066320                      db 37, 20, 6, 99, ' '   
   619 00001AB2 2B14066320                      db 43, 20, 6, 99, ' '   
   620 00001AB7 3114066320                      db 49, 20, 6, 99, ' '   
   621 00001ABC 3714066320                      db 55, 20, 6, 99, ' '   
   622 00001AC1 3D14010120                      db 61, 20, 1, 1, ' '  
   623 00001AC6 4314010153                      db 67, 20, 1, 1, 'S'   
   624 00001ACB 4914010143                      db 73, 20, 1, 1, 'C' 
   625                                  
   626                                      level3_blocks_count equ 104
   627                                  
   628                                      ; Nivel 4
   629                                      level4_blocks:
   630                                  
   631 00001AD0 0704010120                      db 7, 4, 1, 1, ' '    
   632 00001AD5 0D04020120                      db 13, 4, 2, 1, ' '   
   633 00001ADA 1304030120                      db 19, 4, 3, 1, ' '   
   634 00001ADF 1904050220                      db 25, 4, 5, 2, ' '   
   635 00001AE4 1F04020120                      db 31, 4, 2, 1, ' '
   636                                  
   637 00001AE9 2B04010120                      db 43, 4, 1, 1, ' '   
   638 00001AEE 3104020120                      db 49, 4, 2, 1, ' '   
   639 00001AF3 3704030144                      db 55, 4, 3, 1, 'D'   
   640 00001AF8 3D04040120                      db 61, 4, 4, 1, ' '  
   641 00001AFD 4304020120                      db 67, 4, 2, 1, ' ' 
   642                                  
   643 00001B02 0705020120                      db 7, 5, 2, 1, ' '    
   644 00001B07 0D05030120                      db 13, 5, 3, 1, ' '   
   645 00001B0C 1305050220                      db 19, 5, 5, 2, ' '   
   646 00001B11 1905020120                      db 25, 5, 2, 1, ' '   
   647 00001B16 1F05010120                      db 31, 5, 1, 1, ' '
   648                                  
   649 00001B1B 2B05020120                      db 43, 5, 2, 1, ' '   
   650 00001B20 3105030120                      db 49, 5, 3, 1, ' '   
   651 00001B25 3705040120                      db 55, 5, 4, 1, ' '   
   652 00001B2A 3D05020120                      db 61, 5, 2, 1, ' '  
   653 00001B2F 4305050220                      db 67, 5, 5, 2, ' '  
   654                                  
   655 00001B34 0706030120                      db 7, 6, 3, 1, ' '    
   656 00001B39 0D06050220                      db 13, 6, 5, 2, ' '   
   657 00001B3E 1306020120                      db 19, 6, 2, 1, ' '   
   658 00001B43 1906010120                      db 25, 6, 1, 1, ' '   
   659 00001B48 1F06020120                      db 31, 6, 2, 1, ' '
   660                                  
   661 00001B4D 2B06030120                      db 43, 6, 3, 1, ' '   
   662 00001B52 3106040120                      db 49, 6, 4, 1, ' '   
   663 00001B57 3706020120                      db 55, 6, 2, 1, ' '   
   664 00001B5C 3D06050220                      db 61, 6, 5, 2, ' '  
   665 00001B61 4306020120                      db 67, 6, 2, 1, ' '
   666                                  
   667 00001B66 0707050220                      db 7, 7, 5, 2, ' '    
   668 00001B6B 0D07020120                      db 13, 7, 2, 1, ' '   
   669 00001B70 1307010120                      db 19, 7, 1, 1, ' '   
   670 00001B75 1907020120                      db 25, 7, 2, 1, ' '   
   671 00001B7A 1F07030120                      db 31, 7, 3, 1, ' '
   672                                  
   673 00001B7F 2B07040120                      db 43, 7, 4, 1, ' '   
   674 00001B84 3107020120                      db 49, 7, 2, 1, ' '   
   675 00001B89 3707050220                      db 55, 7, 5, 2, ' '   
   676 00001B8E 3D07020120                      db 61, 7, 2, 1, ' '  
   677 00001B93 4307030120                      db 67, 7, 3, 1, ' '
   678                                  
   679 00001B98 0708020120                      db 7, 8, 2, 1, ' '    
   680 00001B9D 0D08010120                      db 13, 8, 1, 1, ' '   
   681 00001BA2 1308020120                      db 19, 8, 2, 1, ' '   
   682 00001BA7 1908030120                      db 25, 8, 3, 1, ' '   
   683 00001BAC 1F08040120                      db 31, 8, 4, 1, ' '
   684                                  
   685 00001BB1 2B08020120                      db 43, 8, 2, 1, ' '   
   686 00001BB6 3108050220                      db 49, 8, 5, 2, ' '   
   687 00001BBB 3708020120                      db 55, 8, 2, 1, ' '   
   688 00001BC0 3D08030120                      db 61, 8, 3, 1, ' '  
   689 00001BC5 4308040120                      db 67, 8, 4, 1, ' '
   690                                  
   691 00001BCA 0709010120                      db 7, 9, 1, 1, ' '    
   692 00001BCF 0D09020120                      db 13, 9, 2, 1, ' '   
   693 00001BD4 1309030120                      db 19, 9, 3, 1, ' '   
   694 00001BD9 1909040120                      db 25, 9, 4, 1, ' '   
   695 00001BDE 1F09020120                      db 31, 9, 2, 1, ' '
   696                                  
   697 00001BE3 2B09050220                      db 43, 9, 5, 2, ' '   
   698 00001BE8 3109020120                      db 49, 9, 2, 1, ' '   
   699 00001BED 3709030120                      db 55, 9, 3, 1, ' '   
   700 00001BF2 3D09040120                      db 61, 9, 4, 1, ' '  
   701 00001BF7 4309020120                      db 67, 9, 2, 1, ' '
   702                                  
   703 00001BFC 070A020120                      db 7, 10, 2, 1, ' '    
   704 00001C01 0D0A030120                      db 13, 10, 3, 1, ' '   
   705 00001C06 130A040120                      db 19, 10, 4, 1, ' '   
   706 00001C0B 190A020120                      db 25, 10, 2, 1, ' '   
   707 00001C10 1F0A010120                      db 31, 10, 1, 1, ' '
   708                                  
   709 00001C15 2B0A020120                      db 43, 10, 2, 1, ' '   
   710 00001C1A 310A030120                      db 49, 10, 3, 1, ' '   
   711 00001C1F 370A040120                      db 55, 10, 4, 1, ' '   
   712 00001C24 3D0A020120                      db 61, 10, 2, 1, ' '  
   713 00001C29 430A010120                      db 67, 10, 1, 1, ' '
   714                                  
   715 00001C2E 070B030120                      db 7, 11, 3, 1, ' '   
   716 00001C33 0D0B040120                      db 13, 11, 4, 1, ' '   
   717 00001C38 130B020120                      db 19, 11, 2, 1, ' '   
   718 00001C3D 190B010120                      db 25, 11, 1, 1, ' '  
   719 00001C42 1F0B050220                      db 31, 11, 5, 2, ' '
   720                                  
   721 00001C47 2B0B030120                      db 43, 11, 3, 1, ' '   
   722 00001C4C 310B040120                      db 49, 11, 4, 1, ' '   
   723 00001C51 370B020120                      db 55, 11, 2, 1, ' '   
   724 00001C56 3D0B010120                      db 61, 11, 1, 1, ' '  
   725 00001C5B 430B020120                      db 67, 11, 2, 1, ' '
   726                                  
   727 00001C60 070C040120                      db 7, 12, 4, 1, ' '   
   728 00001C65 0D0C020120                      db 13, 12, 2, 1, ' '   
   729 00001C6A 130C010120                      db 19, 12, 1, 1, ' '   
   730 00001C6F 190C050220                      db 25, 12, 5, 2, ' '  
   731 00001C74 1F0C030120                      db 31, 12, 3, 1, ' '
   732                                  
   733 00001C79 2B0C040120                      db 43, 12, 4, 1, ' '    
   734 00001C7E 310C020120                      db 49, 12, 2, 1, ' '   
   735 00001C83 370C010120                      db 55, 12, 1, 1, ' '   
   736 00001C88 3D0C020120                      db 61, 12, 2, 1, ' '   
   737 00001C8D 430C030120                      db 67, 12, 3, 1, ' '
   738                                  
   739 00001C92 070D020120                      db 7, 13, 2, 1, ' '   
   740 00001C97 0D0D010120                      db 13, 13, 1, 1, ' '   
   741 00001C9C 130D050220                      db 19, 13, 5, 2, ' '   
   742 00001CA1 190D030143                      db 25, 13, 3, 1, 'C'  
   743 00001CA6 1F0D040120                      db 31, 13, 4, 1, ' '
   744                                  
   745 00001CAB 2B0D020120                      db 43, 13, 2, 1, ' '    
   746 00001CB0 310D010120                      db 49, 13, 1, 1, ' '   
   747 00001CB5 370D020120                      db 55, 13, 2, 1, ' '   
   748 00001CBA 3D0D030120                      db 61, 13, 3, 1, ' '   
   749 00001CBF 430D050220                      db 67, 13, 5, 2, ' '
   750                                  
   751 00001CC4 070E010120                      db 7, 14, 1, 1, ' '   
   752 00001CC9 0D0E050220                      db 13, 14, 5, 2, ' '   
   753 00001CCE 130E030120                      db 19, 14, 3, 1, ' '   
   754 00001CD3 190E040120                      db 25, 14, 4, 1, ' '  
   755 00001CD8 1F0E020120                      db 31, 14, 2, 1, ' '
   756                                  
   757 00001CDD 2B0E010120                      db 43, 14, 1, 1, ' '    
   758 00001CE2 310E020120                      db 49, 14, 2, 1, ' '   
   759 00001CE7 370E030120                      db 55, 14, 3, 1, ' '   
   760 00001CEC 3D0E050220                      db 61, 14, 5, 2, ' '   
   761 00001CF1 430E020120                      db 67, 14, 2, 1, ' '
   762                                  
   763 00001CF6 070F050220                      db 7, 15, 5, 2, ' '   
   764 00001CFB 0D0F030120                      db 13, 15, 3, 1, ' '   
   765 00001D00 130F040120                      db 19, 15, 4, 1, ' '   
   766 00001D05 190F020120                      db 25, 15, 2, 1, ' '  
   767 00001D0A 1F0F010120                      db 31, 15, 1, 1, ' '
   768                                  
   769 00001D0F 2B0F020145                      db 43, 15, 2, 1, 'E'    
   770 00001D14 310F03014C                      db 49, 15, 3, 1, 'L'   
   771 00001D19 370F050220                      db 55, 15, 5, 2, ' '   
   772 00001D1E 3D0F020120                      db 61, 15, 2, 1, ' '   
   773 00001D23 430F010120                      db 67, 15, 1, 1, ' '
   774                                  
   775 00001D28 0710030120                      db 7, 16, 3, 1, ' '   
   776 00001D2D 0D10040120                      db 13, 16, 4, 1, ' '   
   777 00001D32 1310020120                      db 19, 16, 2, 1, ' '   
   778 00001D37 1910010120                      db 25, 16, 1, 1, ' '  
   779 00001D3C 1F10020120                      db 31, 16, 2, 1, ' '
   780                                  
   781 00001D41 2B10030120                      db 43, 16, 3, 1, ' '    
   782 00001D46 3110050220                      db 49, 16, 5, 2, ' '   
   783 00001D4B 3710020120                      db 55, 16, 2, 1, ' '   
   784 00001D50 3D10010120                      db 61, 16, 1, 1, ' '   
   785 00001D55 4310020120                      db 67, 16, 2, 1, ' '
   786                                  
   787 00001D5A 0711040120                      db 7, 17, 4, 1, ' '   
   788 00001D5F 0D11020120                      db 13, 17, 2, 1, ' '   
   789 00001D64 1311010120                      db 19, 17, 1, 1, ' '   
   790 00001D69 1911020120                      db 25, 17, 2, 1, ' '  
   791 00001D6E 1F11030120                      db 31, 17, 3, 1, ' '
   792                                  
   793 00001D73 2B11050220                      db 43, 17, 5, 2, ' '    
   794 00001D78 3111020120                      db 49, 17, 2, 1, ' '    
   795 00001D7D 3711010120                      db 55, 17, 1, 1, ' '   
   796 00001D82 3D11020120                      db 61, 17, 2, 1, ' '   
   797 00001D87 4311030120                      db 67, 17, 3, 1, ' '
   798                                  
   799                                      level4_blocks_count equ 140
   800                                  
   801                                      ; Nivel 5
   802                                      level5_blocks:
   803                                  
   804 00001D8C 1303020145                      db 19, 3, 2, 1, 'E'   
   805 00001D91 3703020120                      db 55, 3, 2, 1, ' '   
   806                                  
   807 00001D96 1304020120                      db 19, 4, 2, 1, ' '   
   808 00001D9B 370402014C                      db 55, 4, 2, 1, 'L' 
   809                                  
   810 00001DA0 1905020120                      db 25, 5, 2, 1, ' '   
   811 00001DA5 3105020153                      db 49, 5, 2, 1, 'S'   
   812                                  
   813 00001DAA 1906020120                      db 25, 6, 2, 1, ' '   
   814 00001DAF 3106020120                      db 49, 6, 2, 1, ' '   
   815                                  
   816 00001DB4 1307050220                      db 19, 7, 5, 2, ' '   
   817 00001DB9 1907050220                      db 25, 7, 5, 2, ' '  
   818 00001DBE 1F07050220                      db 31, 7, 5, 2, ' '
   819 00001DC3 2507050220                      db 37, 7, 5, 2, ' '
   820 00001DC8 2B07050220                      db 43, 7, 5, 2, ' '    
   821 00001DCD 3107050220                      db 49, 7, 5, 2, ' '    
   822 00001DD2 3707050220                      db 55, 7, 5, 2, ' '   
   823                                  
   824 00001DD7 1308050220                      db 19, 8, 5, 2, ' '   
   825 00001DDC 1908050220                      db 25, 8, 5, 2, ' '  
   826 00001DE1 1F08050220                      db 31, 8, 5, 2, ' '
   827 00001DE6 2508050220                      db 37, 8, 5, 2, ' '
   828 00001DEB 2B08050220                      db 43, 8, 5, 2, ' '    
   829 00001DF0 3108050220                      db 49, 8, 5, 2, ' '    
   830 00001DF5 3708050220                      db 55, 8, 5, 2, ' '   
   831                                  
   832 00001DFA 0D09050220                      db 13, 9, 5, 2, ' '   
   833 00001DFF 1309050220                      db 19, 9, 5, 2, ' '   
   834 00001E04 1909040143                      db 25, 9, 4, 1, 'C'  
   835 00001E09 1F09050220                      db 31, 9, 5, 2, ' '
   836 00001E0E 2509050220                      db 37, 9, 5, 2, ' '
   837 00001E13 2B09050220                      db 43, 9, 5, 2, ' '    
   838 00001E18 3109040144                      db 49, 9, 4, 1, 'D'    
   839 00001E1D 3709050220                      db 55, 9, 5, 2, ' '   
   840 00001E22 3D09050220                      db 61, 9, 5, 2, ' '  
   841                                  
   842 00001E27 0D0A050220                      db 13, 10, 5, 2, ' '   
   843 00001E2C 130A050220                      db 19, 10, 5, 2, ' '   
   844 00001E31 190A040120                      db 25, 10, 4, 1, ' '  
   845 00001E36 1F0A050220                      db 31, 10, 5, 2, ' '
   846 00001E3B 250A050220                      db 37, 10, 5, 2, ' '
   847 00001E40 2B0A050220                      db 43, 10, 5, 2, ' '    
   848 00001E45 310A040120                      db 49, 10, 4, 1, ' '    
   849 00001E4A 370A050220                      db 55, 10, 5, 2, ' '   
   850 00001E4F 3D0A050220                      db 61, 10, 5, 2, ' '   
   851                                          
   852 00001E54 070B050220                      db 7, 11, 5, 2, ' '   
   853 00001E59 0D0B050220                      db 13, 11, 5, 2, ' '   
   854 00001E5E 130B050220                      db 19, 11, 5, 2, ' '   
   855 00001E63 190B050220                      db 25, 11, 5, 2, ' '  
   856 00001E68 1F0B050220                      db 31, 11, 5, 2, ' '
   857 00001E6D 250B050220                      db 37, 11, 5, 2, ' '
   858 00001E72 2B0B050220                      db 43, 11, 5, 2, ' '    
   859 00001E77 310B050220                      db 49, 11, 5, 2, ' '    
   860 00001E7C 370B050220                      db 55, 11, 5, 2, ' '   
   861 00001E81 3D0B050220                      db 61, 11, 5, 2, ' '   
   862 00001E86 430B050220                      db 67, 11, 5, 2, ' '
   863                                  
   864 00001E8B 070C050220                      db 7, 12, 5, 2, ' '   
   865 00001E90 0D0C050220                      db 13, 12, 5, 2, ' '   
   866 00001E95 130C050220                      db 19, 12, 5, 2, ' '   
   867 00001E9A 190C050220                      db 25, 12, 5, 2, ' '  
   868 00001E9F 1F0C050220                      db 31, 12, 5, 2, ' '
   869 00001EA4 250C050220                      db 37, 12, 5, 2, ' '
   870 00001EA9 2B0C050220                      db 43, 12, 5, 2, ' '    
   871 00001EAE 310C050220                      db 49, 12, 5, 2, ' '    
   872 00001EB3 370C050220                      db 55, 12, 5, 2, ' '   
   873 00001EB8 3D0C050220                      db 61, 12, 5, 2, ' '   
   874 00001EBD 430C050220                      db 67, 12, 5, 2, ' '
   875                                  
   876 00001EC2 070D050220                      db 7, 13, 5, 2, ' '   
   877 00001EC7 0D0D050220                      db 13, 13, 5, 2, ' '   
   878 00001ECC 130D050220                      db 19, 13, 5, 2, ' '   
   879 00001ED1 190D050220                      db 25, 13, 5, 2, ' '  
   880 00001ED6 1F0D050220                      db 31, 13, 5, 2, ' '
   881 00001EDB 250D050220                      db 37, 13, 5, 2, ' '
   882 00001EE0 2B0D050220                      db 43, 13, 5, 2, ' '    
   883 00001EE5 310D050220                      db 49, 13, 5, 2, ' '    
   884 00001EEA 370D050220                      db 55, 13, 5, 2, ' '   
   885 00001EEF 3D0D050220                      db 61, 13, 5, 2, ' '   
   886 00001EF4 430D050220                      db 67, 13, 5, 2, ' '
   887                                  
   888                                          
   889 00001EF9 070E050220                      db 7, 14, 5, 2, ' '   
   890 00001EFE 130E050220                      db 19, 14, 5, 2, ' '   
   891 00001F03 190E050220                      db 25, 14, 5, 2, ' '  
   892 00001F08 1F0E050220                      db 31, 14, 5, 2, ' '
   893 00001F0D 250E050220                      db 37, 14, 5, 2, ' '
   894 00001F12 2B0E050220                      db 43, 14, 5, 2, ' '    
   895 00001F17 310E050220                      db 49, 14, 5, 2, ' '    
   896 00001F1C 370E050220                      db 55, 14, 5, 2, ' '   
   897 00001F21 430E050220                      db 67, 14, 5, 2, ' '
   898                                  
   899 00001F26 070F050220                      db 7, 15, 5, 2, ' '   
   900 00001F2B 130F050220                      db 19, 15, 5, 2, ' '      
   901 00001F30 370F050220                      db 55, 15, 5, 2, ' '   
   902 00001F35 430F050220                      db 67, 15, 5, 2, ' '
   903                                   
   904 00001F3A 0710050220                      db 7, 16, 5, 2, ' '   
   905 00001F3F 1310050220                      db 19, 16, 5, 2, ' '      
   906 00001F44 3710050220                      db 55, 16, 5, 2, ' '   
   907 00001F49 4310050220                      db 67, 16, 5, 2, ' '
   908                                  
   909                                  
   910 00001F4E 1911050220                      db 25, 17, 5, 2, ' '  
   911 00001F53 1F11050220                      db 31, 17, 5, 2, ' '
   912 00001F58 2B11050220                      db 43, 17, 5, 2, ' '    
   913 00001F5D 3111050220                      db 49, 17, 5, 2, ' ' 
   914                                  
   915 00001F62 1912050220                      db 25, 18, 5, 2, ' '  
   916 00001F67 1F12050220                      db 31, 18, 5, 2, ' '
   917 00001F6C 2B12050220                      db 43, 18, 5, 2, ' '    
   918 00001F71 3112050220                      db 49, 18, 5, 2, ' ' 
   919                                  
   920                                      level5_blocks_count equ 98
   921                                  
   922                                      ; Array para mantener el estado de los bloques
   923 00001F76 00<rep C8h>                 block_states: times 200 db 0  ; Durabilidad actual de cada bloque
   924                                  
   925                                      
   926                                      ; Variables para almacenar los valores
   927 0000203E 0000000000000000            current_score dq 0          ; Score actual
   928 00002046 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   929                                      
   930                                      ; Buffer para convertir números a string
   931 00002047 00<rep 14h>                 number_buffer: times 20 db 0
   932                                  
   933 0000205B 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   934                                      
   935                                      ; Estructura para los enemigos (x, y, activo)
   936 00002060 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   937 0000207E 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   938                                      
   939 0000207F 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   940 00002087 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   941 00002088 0A                          enemy_move_delay db 10           ; Mover enemigos cada N ciclos
   942 00002089 00                          enemy_move_total db 0      ; Contador total de movimientos
   943 0000208A 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   944 0000208B 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   945                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   946 0000208C 323C464BE4F8788CA0-         level1_spawn_points: db 50, 60, 70, 75, 740, 760, 120, 140, 160, 180    ; 10 enemigos
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946 00002095 B4                 
   947 00002096 001E3246556E8296AA-         level2_spawn_points: db 0, 30, 50, 70, 85, 110, 130, 150, 170, 190    ; 10 enemigos
   947 0000209F BE                 
   948 000020A0 00000032373C646464-         level3_spawn_points: db 0, 0, 0, 50, 55, 60, 100, 100, 100, 100   ; 10 enemigos
   948 000020A9 64                 
   949 000020AA 00040F1E2832465A64-         level4_spawn_points: db 0, 4, 15, 30, 40, 50, 70, 90, 100, 120  ; 10 enemigos
   949 000020B3 78                 
   950 000020B4 00000A141E2328323C-         level5_spawn_points: db 0, 0, 10, 20, 30, 35, 40, 50, 60, 80 ; 10 enemigos
   950 000020BD 50                 
   951                                          ; Arreglo de punteros a los spawn points de cada nivel
   952                                      spawn_points_table:
   953 000020BE [8C20000000000000]              dq level1_spawn_points
   954 000020C6 [9620000000000000]              dq level2_spawn_points
   955 000020CE [A020000000000000]              dq level3_spawn_points
   956 000020D6 [AA20000000000000]              dq level4_spawn_points
   957 000020DE [B420000000000000]              dq level5_spawn_points
   958                                  
   959                                      ; Variables para el comportamiento de enemigos
   960 000020E6 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   961 000020E7 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   962 000020E8 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   963 000020E9 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   964                                  
   965 000020F3 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   965 000020FC 5B2020202020202020-
   965 00002105 20205D0A0D         
   966                                      score_label_len: equ $ - score_label
   967 0000210A 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   967 00002113 657374727569646F73-
   967 0000211C 3A205B2020205D0A0D 
   968                                      blocks_label_len: equ $ - blocks_label
   969                                      
   970                                      ; Posición donde insertar los números en los labels
   971                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   972                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   973                                      
   974                                      ; Definición de las vidas (x, y, estado)
   975                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   976                                      lives_data: 
   977 00002125 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   978 00002128 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   979 0000212B 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   980 0000212E 081E00                          db 8, 30, 0     ; Vida 4 (inactiva)
   981 00002131 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   982 00002134 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   983 00002137 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   984                                      lives_count equ 7    ; Total de vidas
   985 0000213A 5E                          life_char db "^"    
   986 0000213B 03                          current_lives db 3   ; Contador de vidas activas actual
   987                                  
   988                                  ; Estructura para almacenar las letras y sus posiciones
   989                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   990 0000213C 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   991 000022CC 00                          letters_count db 0   
   992 000022CD 20                          last_letter db ' '    ; Variable para almacenar la última letra
   993 000022CE 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   993 000022D7 75616C3A205B205D0A-
   993 000022E0 0D                 
   994                                      last_letter_msg_len equ $ - last_letter_msg
   995 000022E1 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   996 000022E2 07                          max_lives db 7              ; Máximo número de vidas permitidas
   997 000022E3 0700000000000000            ball_speed dq 7             ; Velocidad normal de la bola
   998 000022EB 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   999 000022F3 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
  1000                                     
  1001 000022FB 00                          initial_catch_active db 0   ; 0 = inactivo, 1 = activo
  1002                                  
  1003 000022FC 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
  1004 000022FD 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
  1005 000022FE 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
  1006 000022FF 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
  1007                                  
  1008 00002300 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
  1009 00002308 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
  1010                                  
  1011 00002309 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
  1012 0000230A 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
  1013 0000230B 00                          laser_count: db 0                ; Contador de láseres activos
  1014 0000230C 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
  1015 000023D4 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
  1016                                  
  1017                                      balls_data:     ; Array para almacenar hasta 3 bolas
  1018                                          ; Bola 1 (principal)
  1019 000023DC 0000000000000000                dq 0        ; x_pos
  1020 000023E4 0000000000000000                dq 0        ; y_pos
  1021 000023EC 0100000000000000                dq 1        ; direction_x
  1022 000023F4 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1023 000023FC 01                              db 1        ; active
  1024                                          ; Bola 2
  1025 000023FD 0000000000000000                dq 0        ; x_pos
  1026 00002405 0000000000000000                dq 0        ; y_pos
  1027 0000240D FFFFFFFFFFFFFFFF                dq -1       ; direction_x
  1028 00002415 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1029 0000241D 00                              db 0        ; active
  1030                                          ; Bola 3
  1031 0000241E 0000000000000000                dq 0        ; x_pos
  1032 00002426 0000000000000000                dq 0        ; y_pos
  1033 0000242E 0000000000000000                dq 0        ; direction_x
  1034 00002436 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1035 0000243E 00                              db 0        ; active
  1036                                      
  1037 0000243F 01                          balls_count db 1     ; Contador de bolas activas
  1038                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
  1039 00002440 00<rep Ah>                  enemy_last_x:       times 10 db 0
  1040 0000244A 00<rep Ah>                  enemy_last_y:       times 10 db 0
  1041 00002454 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
  1042 0000245E 00                          letter_move_counter db 0
  1043                                      initial_ball_offset_x equ 2    ; Offset desde el centro de la paleta
  1044                                      initial_ball_offset_y equ -1   ; Offset vertical desde la paleta
  1045                                  
  1046 0000245F C2A148617320706572-         game_over_msg db '¡Has perdido!', 10, 'Puntaje final: '
  1046 00002468 6469646F210A50756E-
  1046 00002471 74616A652066696E61-
  1046 0000247A 6C3A20             
  1047                                      game_over_len equ $ - game_over_msg
  1048 0000247D 0A                          newline db 10
  1049                                      newline_len equ 1
  1050                                  
  1051 0000247E C2A146656C69636964-         game_win_msg db '¡Felicidades, ganaste!', 10, 'Puntaje final: '
  1051 00002487 616465732C2067616E-
  1051 00002490 61737465210A50756E-
  1051 00002499 74616A652066696E61-
  1051 000024A2 6C3A20             
  1052                                      game_win_len equ $ - game_win_msg
  1053                                  
  1054                                  
  1055                                  section .text
  1056                                  
  1057                                  
  1058                                  print_lives:; Función para imprimir las vidas en la parte inferior
  1059 000001DD 55                          push rbp; Guardar el puntero de la base
  1060 000001DE 4889E5                      mov rbp, rsp; Establecer el puntero de la base
  1061                                      
  1062 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
  1063                                      
  1064                                      .print_loop:; Bucle para imprimir todas las vidas
  1065 000001E4 4983FC07                        cmp r12, lives_count; Verificar si se han impreso todas las vidas
  1066 000001E8 7D45                            jge .end; Si se han impreso todas las vidas, terminar
  1067                                          
  1068                                          ; Calcular offset de la vida actual
  1069 000001EA 4C89E0                          mov rax, r12    ; Calcular offset en el arreglo de vidas
  1070 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
  1071 000001F1 488DB0[25210000]                lea rsi, [lives_data + rax]    ; Cargar dirección de la vida actual
  1072                                          
  1073                                          ; Calcular posición en el tablero
  1074 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
  1075 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1076                                          
  1077                                          ; Calcular offset en el tablero
  1078 00000201 B850000000                      mov rax, column_cells        ; Ancho del tablero
  1079 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1080 0000020A 49F7E1                          mul r9                        ; Multiplicar por Y
  1081 0000020D 4C01C0                          add rax, r8                    ; Sumar X
  1082 00000210 488DB8[400A0000]                lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1083                                          
  1084                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
  1085 00000217 807E0201                        cmp byte [rsi + 2], 1     ; Verificar si la vida está activa
  1086 0000021B 7405                            je .draw_active           ; Si está activa, dibujar el carácter de vida 
  1087                                          
  1088                                          ; Si está inactiva, dibujar espacio
  1089 0000021D C60720                          mov byte [rdi], ' '
  1090 00000220 EB08                            jmp .next_life
  1091                                          
  1092                                      .draw_active:
  1093                                          ; Si está activa, dibujar el símbolo de vida
  1094 00000222 8A05(3A210000)                  mov al, [life_char]
  1095 00000228 8807                            mov [rdi], al
  1096                                          
  1097                                      .next_life:
  1098 0000022A 49FFC4                          inc r12
  1099 0000022D EBB5                            jmp .print_loop
  1100                                          
  1101                                      .end:
  1102 0000022F 5D                              pop rbp
  1103 00000230 C3                              ret
  1104                                  
  1105                                  ; Función para desactivar una vida
  1106                                  
  1107                                  lose_life:
  1108 00000231 55                          push rbp    ; Guardar el puntero de la base
  1109 00000232 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1110                                      
  1111                                      ; Verificar si aún quedan vidas
  1112 00000235 803D(3B210000)00            cmp byte [current_lives], 0   ; Verificar si quedan vidas
  1113 0000023C 0F84AB000000                je .game_lost             ; Si no quedan vidas, perder el juego
  1114                                      
  1115                                      ; Encontrar la última vida activa
  1116 00000242 B907000000                  mov rcx, lives_count    ; Cantidad total de vidas
  1117 00000247 48FFC9                      dec rcx               ; Índice de la última vida
  1118                                      
  1119                                      .find_active_life:  ; Bucle para encontrar la última vida activa
  1120 0000024A 4889C8                          mov rax, rcx    ; Calcular offset en el arreglo de vidas
  1121 0000024D 486BC003                        imul rax, 3    ; Cada vida ocupa 3 bytes (x, y, estado)
  1122 00000251 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Cargar dirección de la vida actual
  1123 00000258 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si la vida está activa
  1124 0000025C 740A                            je .deactivate_life   ; Si está activa, desactivarla
  1125 0000025E 48FFC9                          dec rcx   ; Si no está activa, probar con la siguiente vida
  1126 00000261 79E7                            jns .find_active_life   ; Si aún quedan vidas, continuar buscando
  1127 00000263 E985000000                      jmp .game_lost  ; Si no quedan vidas, perder el juego
  1128                                          
  1129                                      .deactivate_life:   ; Desactivar la vida encontrada
  1130                                          ; Borrar vida visualmente y en datos
  1131 00000268 4C0FB606                        movzx r8, byte [rsi]    ; X
  1132 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]    ; Y
  1133 00000271 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1134 00000276 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1135 0000027A 49F7E1                          mul r9  ; Multiplicar por Y
  1136 0000027D 4C01C0                          add rax, r8 ; Sumar X
  1137 00000280 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1138 00000287 C60720                          mov byte [rdi], ' ' ; Borrar visual
  1139 0000028A C6460200                        mov byte [rsi + 2], 0   ; Desactivar vida
  1140 0000028E FE0D(3B210000)                  dec byte [current_lives]    ; Decrementar contador de vidas
  1141                                          
  1142                                          ; Borrar paleta anterior
  1143 00000294 4C8B05(BF140000)                mov r8, [pallet_position]   ; Posición de la paleta
  1144 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]  ; Tamaño de la paleta
  1145                                          .erase_pallet_loop: ; Bucle para borrar la paleta
  1146 000002A2 41C60020                            mov byte [r8], ' '  ; Borrar visualmente
  1147 000002A6 49FFC0                              inc r8  ; Siguiente byte
  1148 000002A9 48FFC9                              dec rcx ; Decrementar contador
  1149 000002AC 75F4                                jnz .erase_pallet_loop  ; Si no se ha borrado toda la paleta, continuar
  1150                                          
  1151                                          ; Reiniciar solo la bola principal
  1152 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40      ; Posición inicial de la bola
  1152 000002B6 000000             
  1153 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28    ; Posición inicial de la bola
  1153 000002C1 000000             
  1154 000002C4 C605(FF140000)00                mov byte [ball_moving], 0   ; Detener la bola
  1155 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
  1156 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1156 000002D9 [B0130000]         
  1157                                          
  1158                                          ; Asegurarse que las otras bolas están desactivadas
  1159 000002DD C605(22150000)00                mov byte [ball2_active], 0  ; Desactivar bola 2
  1160 000002E4 C605(44150000)00                mov byte [ball3_active], 0      ; Desactivar bola 3
  1161                                          
  1162 000002EB EB07                            jmp .end    ; Salir
  1163                                          
  1164                                      .game_lost:
  1165 000002ED E823010000                      call game_lost  ; Perder el juego
  1166 000002F2 EB00                            jmp .end    ; Salir
  1167                                          
  1168                                      .end:
  1169 000002F4 5D                              pop rbp   ; Restaurar el puntero de la base
  1170 000002F5 C3                              ret  ; Retornar
  1171                                  ; Función modificada para verificar colisión con el borde inferior
  1172                                  check_bottom_collision:   ; Función para verificar colisión con el borde inferior
  1173 000002F6 55                          push rbp    ; Guardar el puntero de la base
  1174 000002F7 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1175                                      
  1176                                  
  1177                                      ; Verificar bola principal
  1178 000002FA 803D(00150000)01            cmp byte [ball_active], 1   ; Verificar si la bola principal está activa
  1179 00000301 7542                        jne .check_ball2        ; Si no está activa, verificar bola 2
  1180 00000303 488B05(E7140000)            mov rax, [ball_y_pos]   ; Obtener posición Y de la bola principal
  1181 0000030A 4883F81E                    cmp rax, row_cells - 2      ; Verificar si ha llegado al borde inferior
  1182 0000030E 7535                        jne .check_ball2    ; Si no ha llegado al borde, verificar bola 2
  1183                                      
  1184                                      ; Borrar visualmente la bola principal
  1185 00000310 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Obtener posición X de la bola principal
  1186 00000317 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Obtener posición Y de la bola principal
  1187 0000031E 4981C0[400A0000]            add r8, board        ; Calcular dirección en el tablero
  1188 00000325 4C89C9                      mov rcx, r9        ; Calcular offset en el tablero
  1189 00000328 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  1190 0000032D 48F7E9                      imul rcx    ; Multiplicar por Y
  1191 00000330 4901C0                      add r8, rax   ; Sumar X
  1192 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1193                                      
  1194 00000337 C605(00150000)00            mov byte [ball_active], 0   ; Desactivar bola principal
  1195 0000033E C605(FF140000)00            mov byte [ball_moving], 0   ; Detener la bola principal
  1196                                  
  1197                                  .check_ball2:   ; Verificar bola 2
  1198 00000345 803D(22150000)01            cmp byte [ball2_active], 1  ; Verificar si la bola 2 está activa
  1199 0000034C 7542                        jne .check_ball3    ; Si no está activa, verificar bola 3
  1200 0000034E 488B05(09150000)            mov rax, [ball2_y_pos]  ; Obtener
  1201 00000355 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1202 00000359 7535                        jne .check_ball3    ; Si no ha llegado al borde, verificar bola 3
  1203                                      ; Borrar visualmente la bola 2
  1204 0000035B 4C8B05(01150000)            mov r8, [ball2_x_pos]    
  1205 00000362 4C8B0D(09150000)            mov r9, [ball2_y_pos]    
  1206 00000369 4981C0[400A0000]            add r8, board        
  1207 00000370 4C89C9                      mov rcx, r9        
  1208 00000373 B852000000                  mov rax, column_cells + 2   
  1209 00000378 48F7E9                      imul rcx    
  1210 0000037B 4901C0                      add r8, rax   
  1211 0000037E 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1212                                      
  1213 00000382 C605(22150000)00            mov byte [ball2_active], 0      
  1214 00000389 C605(21150000)00            mov byte [ball2_moving], 0    
  1215                                  .check_ball3:   ; Verificar bola 3
  1216 00000390 803D(44150000)01            cmp byte [ball3_active], 1  ; Verificar si la bola 3 está activa
  1217 00000397 7542                        jne .check_active_balls   ; Si no está activa, verificar bolas activas
  1218 00000399 488B05(2B150000)            mov rax, [ball3_y_pos]  ; Obtener posición Y de la bola 3
  1219 000003A0 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1220 000003A4 7535                        jne .check_active_balls  ; Si no ha llegado al borde, verificar bolas activas
  1221 000003A6 4C8B05(23150000)            mov r8, [ball3_x_pos]    
  1222 000003AD 4C8B0D(2B150000)            mov r9, [ball3_y_pos]    
  1223 000003B4 4981C0[400A0000]            add r8, board        
  1224 000003BB 4C89C9                      mov rcx, r9        
  1225 000003BE B852000000                  mov rax, column_cells + 2   
  1226 000003C3 48F7E9                      imul rcx    
  1227 000003C6 4901C0                      add r8, rax   
  1228 000003C9 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1229                                      
  1230 000003CD C605(44150000)00            mov byte [ball3_active], 0  
  1231 000003D4 C605(43150000)00            mov byte [ball3_moving], 0  
  1232                                  
  1233                                  .check_active_balls:        
  1234                                      ; Verificar si quedan bolas activas
  1235 000003DB 4831C9                      xor rcx, rcx    ; Contar bolas activas
  1236                                      
  1237                                      ; Contar bolas activas
  1238 000003DE 8A05(00150000)              mov al, byte [ball_active]  ; Verificar si la bola principal está activa
  1239 000003E4 4801C1                      add rcx, rax    ; Sumar al contador
  1240 000003E7 8A05(22150000)              mov al, byte [ball2_active] ; Verificar si la bola 2 está activa
  1241 000003ED 4801C1                      add rcx, rax    ; Sumar al contador
  1242 000003F0 8A05(44150000)              mov al, byte [ball3_active] ; Verificar si la bola 3 está activa
  1243 000003F6 4801C1                      add rcx, rax    ; Sumar al contador
  1244                                      
  1245                                      ; Si no hay bolas activas y quedan bloques, perder vida
  1246 000003F9 4885C9                      test rcx, rcx   ; Verificar si hay bolas activas
  1247 000003FC 7515                        jnz .balls_remain   ; Si hay bolas activas, salir
  1248                                      
  1249 000003FE 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Verificar si quedan bloques
  1250 00000405 740C                        je .balls_remain               ; Si no quedan bloques, no perder vida
  1251                                      
  1252 00000407 E825FEFFFF                  call lose_life
  1253 0000040C C605(00150000)01            mov byte [ball_active], 1      ; Reactivar bola principal
  1254                                      
  1255                                  .balls_remain:  ; Si quedan bolas, continuar
  1256 00000413 5D                          pop rbp     ; Restaurar el puntero de la base
  1257 00000414 C3                          ret    ; Retornar
  1258                                  
  1259                                  ; Nueva función para game over
  1260                                  game_lost:
  1261 00000415 55                          push rbp
  1262 00000416 4889E5                      mov rbp, rsp
  1263                                      
  1264                                      ; Limpiar pantalla
  1265 00000419 48BE-                       mov rsi, clear
  1265 0000041B [1000000000000000] 
  1266 00000423 BA07000000                  mov rdx, clear_length
  1267 00000428 B801000000                  mov eax, sys_write
  1268 0000042D BF01000000                  mov edi, 1
  1269 00000432 0F05                        syscall
  1270                                      
  1271                                      ; Imprimir mensaje de Game Over
  1272 00000434 48BE-                       mov rsi, game_over_msg
  1272 00000436 [5F24000000000000] 
  1273 0000043E BA1E000000                  mov rdx, game_over_len
  1274 00000443 B801000000                  mov eax, sys_write
  1275 00000448 BF01000000                  mov edi, 1
  1276 0000044D 0F05                        syscall
  1277                                      
  1278                                      ; Convertir score a string
  1279 0000044F 488B05(3E200000)            mov rax, [current_score]
  1280 00000456 48BF-                       mov rdi, number_buffer
  1280 00000458 [4720000000000000] 
  1281 00000460 E881150000                  call number_to_string
  1282                                      
  1283                                      ; Calcular longitud del número convertido
  1284 00000465 B900000000                  mov rcx, 0
  1285 0000046A 48BF-                       mov rdi, number_buffer
  1285 0000046C [4720000000000000] 
  1286                                  .count_loop:
  1287 00000474 803C0F00                    cmp byte [rdi + rcx], 0
  1288 00000478 7405                        je .print_score
  1289 0000047A 48FFC1                      inc rcx
  1290 0000047D EBF5                        jmp .count_loop
  1291                                  
  1292                                  .print_score:
  1293                                      ; Imprimir el score
  1294 0000047F 48BE-                       mov rsi, number_buffer
  1294 00000481 [4720000000000000] 
  1295 00000489 4889CA                      mov rdx, rcx
  1296 0000048C B801000000                  mov eax, sys_write
  1297 00000491 BF01000000                  mov edi, 1
  1298 00000496 0F05                        syscall
  1299                                      
  1300                                      ; Imprimir nueva línea
  1301 00000498 48BE-                       mov rsi, newline
  1301 0000049A [7D24000000000000] 
  1302 000004A2 BA01000000                  mov rdx, newline_len
  1303 000004A7 B801000000                  mov eax, sys_write
  1304 000004AC BF01000000                  mov edi, 1
  1305 000004B1 0F05                        syscall
  1306                                      
  1307                                  .wait_q:
  1308                                      ; Esperar por la tecla 'q'
  1309 000004B3 B800000000                  mov rax, sys_read
  1310 000004B8 BF00000000                  mov rdi, STDIN_FILENO
  1311 000004BD 48BE-                       mov rsi, input_char
  1311 000004BF [0000000000000000] 
  1312 000004C7 BA01000000                  mov rdx, 1
  1313 000004CC 0F05                        syscall
  1314                                      
  1315 000004CE 803D(00000000)71            cmp byte [input_char], 'q'
  1316 000004D5 75DC                        jne .wait_q
  1317                                  
  1318 000004D7 E9881F0000                  jmp exit
  1319                                      
  1320 000004DC 5D                          pop rbp
  1321 000004DD C3                          ret
  1322                                  ; Función para registrar una nueva letra en el mapa
  1323                                  ; Entrada:
  1324                                  ;   al - letra a registrar
  1325                                  ;   r8b - posición x
  1326                                  ;   r9b - posición y
  1327                                  register_letter:        
  1328 000004DE 55                          push rbp    ; Guardar el puntero de la base
  1329 000004DF 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1330 000004E2 53                          push rbx    ; Guardar registros
  1331 000004E3 51                          push rcx    ; Guardar registros
  1332                                      
  1333 000004E4 3C20                        cmp al, ' '   ; Verificar si es un espacio
  1334 000004E6 7438                        je .end      ; Si es un espacio, salir
  1335                                  
  1336                                      ; Encontrar un espacio libre en el mapa
  1337 000004E8 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1338 000004EB 480FB615(CC220000)          movzx rdx, byte [letters_count] ; Cantidad de letras registradas
  1339                                      
  1340                                      .find_slot:
  1341 000004F3 4883F964                        cmp rcx, 100              ; Máximo de letras
  1342 000004F7 7D27                            jge .end                  ; Si no hay espacio, salir
  1343                                          
  1344 000004F9 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1345 00000501 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
  1346 00000505 7405                            je .found_slot
  1347                                          
  1348 00000507 48FFC1                          inc rcx   ; Probar con la siguiente letra
  1349 0000050A EBE7                            jmp .find_slot  ; Continuar buscando
  1350                                          
  1351                                      .found_slot:
  1352                                          ; Guardar la información de la letra
  1353 0000050C 448803                          mov [rbx], r8b           ; x
  1354 0000050F 44884B01                        mov [rbx + 1], r9b       ; y
  1355 00000513 884302                          mov [rbx + 2], al        ; letra
  1356 00000516 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
  1357                                          
  1358 0000051A FE05(CC220000)                  inc byte [letters_count]
  1359                                          
  1360                                      .end:
  1361 00000520 59                              pop rcx
  1362 00000521 5B                              pop rbx
  1363 00000522 5D                              pop rbp
  1364 00000523 C3                              ret
  1365                                  
  1366                                  ; Función para imprimir todas las letras registradas
  1367                                  print_letters:
  1368 00000524 55                          push rbp        ; Guardar el puntero de la base
  1369 00000525 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1370 00000528 53                          push rbx    ; Guardar registros
  1371 00000529 51                          push rcx    ; Guardar registros
  1372                                      
  1373 0000052A 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1374                                      
  1375                                      .print_loop:
  1376 0000052D 4883F964                        cmp rcx, 100              ; Máximo de letras
  1377 00000531 7D37                            jge .end              ; Si no hay más letras, salir
  1378                                          
  1379                                          ; Obtener puntero a la letra actual
  1380 00000533 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]
  1381                                          
  1382                                          ; Verificar si está activa
  1383 0000053B 807B0300                        cmp byte [rbx + 3], 0
  1384 0000053F 7424                            je .next_letter
  1385                                          
  1386                                          ; Calcular posición en el tablero
  1387 00000541 4C0FB603                        movzx r8, byte [rbx]      ; x
  1388 00000545 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
  1389                                          
  1390                                          ; Calcular offset en el tablero
  1391 0000054A B850000000                      mov rax, column_cells
  1392 0000054F 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
  1393 00000553 49F7E1                          mul r9
  1394 00000556 4C01C0                          add rax, r8
  1395 00000559 488DB8[400A0000]                lea rdi, [board + rax]  ; Dirección en el tablero
  1396                                          
  1397                                          ; Imprimir la letra
  1398 00000560 8A4302                          mov al, [rbx + 2]   ; Obtener la letra
  1399 00000563 8807                            mov [rdi], al    ; Imprimir la letra
  1400                                          
  1401                                      .next_letter:
  1402 00000565 48FFC1                          inc rcx   ; Siguiente letra
  1403 00000568 EBC3                            jmp .print_loop ; Continuar imprimiendo
  1404                                          
  1405                                      .end:
  1406 0000056A 59                              pop rcx   ; Restaurar registros
  1407 0000056B 5B                              pop rbx  ; Restaurar registros
  1408 0000056C 5D                              pop rbp ; Restaurar el puntero de la base
  1409 0000056D C3                              ret   ; Retornar
  1410                                  
  1411                                  ; Función para borrar una letra específica
  1412                                  ; Entrada:
  1413                                  ;   r8b - posición x
  1414                                  ;   r9b - posición y
  1415                                  remove_letter:
  1416 0000056E 55                          push rbp
  1417 0000056F 4889E5                      mov rbp, rsp
  1418 00000572 53                          push rbx    ; Guardar registros
  1419 00000573 51                          push rcx    ; Guardar registros
  1420                                      
  1421 00000574 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1422                                      
  1423                                      .find_loop:     
  1424 00000577 4883F964                        cmp rcx, 100              ; Máximo de letras
  1425 0000057B 7D2E                            jge .end
  1426                                          
  1427 0000057D 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1428                                          
  1429                                          ; Verificar si está activa y coincide la posición
  1430 00000585 807B0300                        cmp byte [rbx + 3], 0
  1431 00000589 741B                            je .next_letter   ; Si no está activa, probar con la siguiente letra
  1432                                          
  1433 0000058B 8A03                            mov al, [rbx]   ; x
  1434 0000058D 4438C0                          cmp al, r8b    ; Verificar si coincide la posición x
  1435 00000590 7514                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1436                                          
  1437 00000592 8A4301                          mov al, [rbx + 1]   ; y
  1438 00000595 4438C8                          cmp al, r9b   ; Verificar si coincide la posición y
  1439 00000598 750C                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1440                                          
  1441                                          ; Encontrada la letra, desactivarla 
  1442 0000059A C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1443 0000059E FE0D(CC220000)                  dec byte [letters_count]        ; Decrementar contador de letras
  1444 000005A4 EB05                            jmp .end
  1445                                          
  1446                                      .next_letter:
  1447 000005A6 48FFC1                          inc rcx  ; Siguiente letra
  1448 000005A9 EBCC                            jmp .find_loop  ; Continuar buscando
  1449                                          
  1450                                      .end:
  1451 000005AB 59                              pop rcx
  1452 000005AC 5B                              pop rbx
  1453 000005AD 5D                              pop rbp
  1454 000005AE C3                              ret
  1455                                  ; Función para mover las letras hacia abajo
  1456                                  move_letters:
  1457 000005AF 55                          push rbp    ; Guardar el puntero de la base
  1458 000005B0 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1459 000005B3 53                          push rbx    ; Guardar registros
  1460 000005B4 57                          push rdi    ; Guardar registros
  1461 000005B5 56                          push rsi    ; Guardar registros
  1462 000005B6 4150                        push r8    ; Guardar registros
  1463 000005B8 4151                        push r9   ; Guardar registros
  1464 000005BA 4152                        push r10    ; Guardar registros
  1465 000005BC 4153                        push r11    ; Guardar registros
  1466                                  
  1467 000005BE 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1468                                  
  1469                                      ; Verificar si debemos mover la letra en este frame
  1470 000005C1 FE05(5E240000)              inc byte [letter_move_counter]    ; Incrementar contador
  1471 000005C7 803D(5E240000)0B            cmp byte [letter_move_counter], 11 ; Ajusta este número para cambiar velocidad
  1472 000005CE 0F8C20020000                jl .skip_all                         ; Si no es momento de mover, terminar
  1473 000005D4 C605(5E240000)00            mov byte [letter_move_counter], 0 ; Resetear contador
  1474                                  
  1475                                      .move_loop:
  1476 000005DB 4883F964                        cmp rcx, 100          ; Máximo de letras, se hace esta verificacion porque se pueden borrar letras
  1477 000005DF 0F8D0D020000                    jge .print_last_letter  ; Si no hay más letras, imprimir la última letra
  1478                                          
  1479 000005E5 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1480 000005ED 807B0300                        cmp byte [rbx + 3], 0   ; Verificar si está activa
  1481 000005F1 0F84F3010000                    je .next_letter       ; Si no está activa, probar con la siguiente letra
  1482                                  
  1483 000005F7 4C0FB603                        movzx r8, byte [rbx]    ; x
  1484 000005FB 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1485                                  
  1486 00000600 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1487 00000605 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1488 00000609 49F7E1                          mul r9  ; Multiplicar por Y
  1489 0000060C 4C01C0                          add rax, r8 ; Sumar X
  1490 0000060F 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1491 00000616 C60720                          mov byte [rdi], ' ' ; Borrar visualmente la letra
  1492                                  
  1493 00000619 FE4301                          inc byte [rbx + 1]  ; Mover la letra hacia abajo
  1494 0000061C 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1495                                  
  1496 00000621 4983F91F                        cmp r9, row_cells - 1   ; Verificar si ha llegado al borde inferior
  1497 00000625 7C09                            jl .check_pallet_collision  ; Si no ha llegado al borde, verificar colisión con la paleta
  1498                                  
  1499 00000627 C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1500 0000062B E9BA010000                      jmp .next_letter    ; Probar con la siguiente letra
  1501                                  
  1502                                          .check_pallet_collision:    ; Verificar colisión con la paleta
  1503 00000630 B850000000                          mov rax, column_cells   ; Ancho del tablero
  1504 00000635 4883C002                            add rax, 2  ; Incluir caracteres de nueva línea
  1505 00000639 49F7E1                              mul r9  ; Multiplicar por Y
  1506 0000063C 4C01C0                              add rax, r8 ; Sumar X
  1507 0000063F 488DB8[400A0000]                    lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1508                                  
  1509 00000646 8A07                                mov al, [rdi]   ; Obtener el carácter actual
  1510 00000648 3C20                                cmp al, ' '  ; Verificar si es un espacio
  1511 0000064A 0F849A010000                        je .next_letter ; Si es un espacio, probar con la siguiente letra
  1512 00000650 3C3D                                cmp al, char_equal  ; Verificar si es la paleta
  1513 00000652 740A                                je .capture_letter  ; Si es la paleta, capturar la letra
  1514                                  
  1515 00000654 8A4302                              mov al, [rbx + 2]   ; Obtener la letra
  1516 00000657 8807                                mov [rdi], al   ; Imprimir la letra
  1517 00000659 E98C010000                          jmp .next_letter    ; Probar con la siguiente letra
  1518                                  
  1519                                          .capture_letter:    ; Capturar la letra
  1520                                              ; Obtener la nueva letra
  1521 0000065E 8A4302                              mov al, [rbx + 2]
  1522                                              
  1523                                              ; Comparar con la última letra
  1524 00000661 3A05(CD220000)                      cmp al, [last_letter]
  1525 00000667 7407                                je .same_letter
  1526                                              
  1527                                              ; Es una letra diferente, resetear el procesamiento
  1528 00000669 C605(E1220000)00                    mov byte [current_power_processed], 0
  1529                                              
  1530                                              .same_letter:
  1531                                              ; Guardar la nueva letra
  1532 00000670 8805(CD220000)                      mov [last_letter], al
  1533                                              
  1534                                              ; Verificar si es 'E' para extender la paleta
  1535 00000676 3C45                                cmp al, 'E'
  1536 00000678 7450                                je .extend_pallet
  1537                                              
  1538                                              ; Verificar si es 'P' para añadir vida
  1539 0000067A 3C50                                cmp al, 'P'
  1540 0000067C 7478                                je .check_add_life
  1541                                  
  1542 0000067E 3C53                                cmp al, 'S'
  1543 00000680 0F84B4000000                        je .slow_ball
  1544                                  
  1545 00000686 3C43                                cmp al, 'C'
  1546 00000688 0F84D8000000                        je .activate_catch
  1547                                              
  1548 0000068E 3C4C                                cmp al, 'L'
  1549 00000690 0F84F9000000                        je .activate_laser
  1550                                  
  1551 00000696 3C44                                cmp al, 'D'
  1552 00000698 0F841A010000                        je .activate_split
  1553                                  
  1554                                              ; Si no es ningún power-up, restaurar tamaño normal
  1555 0000069E 488B05(CF140000)                    mov rax, [default_pallet_size]
  1556 000006A5 488905(C7140000)                    mov [pallet_size], rax
  1557 000006AC 48C705(E3220000)07-                 mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1557 000006B4 000000             
  1558 000006B7 C605(FC220000)00                    mov byte [catch_power_active], 0
  1559 000006BE C605(09230000)00                    mov byte [laser_power_active], 0
  1560 000006C5 E91C010000                          jmp .finish_capture
  1561                                  
  1562                                              .extend_pallet:
  1563 000006CA C605(09230000)00                        mov byte [laser_power_active], 0
  1564 000006D1 C605(FC220000)00                        mov byte [catch_power_active], 0
  1565 000006D8 48C705(E3220000)07-                     mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1565 000006E0 000000             
  1566 000006E3 488B05(D7140000)                        mov rax, [extended_pallet_size]
  1567 000006EA 488905(C7140000)                        mov [pallet_size], rax
  1568 000006F1 E9F0000000                              jmp .finish_capture
  1569                                  
  1570                                              .check_add_life:
  1571 000006F6 C605(09230000)00                        mov byte [laser_power_active], 0
  1572 000006FD C605(FC220000)00                        mov byte [catch_power_active], 0
  1573 00000704 488B05(CF140000)                        mov rax, [default_pallet_size]
  1574 0000070B 488905(C7140000)                        mov [pallet_size], rax
  1575 00000712 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1575 0000071A 000000             
  1576                                                  ; Verificar si ya procesamos este power-up
  1577 0000071D 803D(E1220000)00                        cmp byte [current_power_processed], 0
  1578 00000724 0F85BC000000                            jne .finish_capture
  1579                                                  
  1580                                                  ; Preservar registros importantes
  1581 0000072A 51                                      push rcx
  1582 0000072B 53                                      push rbx
  1583                                                  
  1584                                                  ; Marcar como procesado
  1585 0000072C C605(E1220000)01                        mov byte [current_power_processed], 1
  1586                                                  
  1587                                                  ; Añadir una vida
  1588 00000733 E8A8040000                              call add_life
  1589                                                  
  1590                                                  ; Restaurar registros
  1591 00000738 5B                                      pop rbx
  1592 00000739 59                                      pop rcx
  1593                                                  
  1594                                              .slow_ball:
  1595 0000073A C605(09230000)00                        mov byte [laser_power_active], 0
  1596 00000741 C605(FC220000)00                        mov byte [catch_power_active], 0                
  1597 00000748 488B05(CF140000)                        mov rax, [default_pallet_size]
  1598 0000074F 488905(C7140000)                        mov [pallet_size], rax
  1599 00000756 48C705(E3220000)0A-                     mov qword [ball_speed], 10    ; Activar velocidad lenta
  1599 0000075E 000000             
  1600 00000761 E980000000                              jmp .finish_capture
  1601                                  
  1602                                              .activate_catch:
  1603 00000766 C605(09230000)00                        mov byte [laser_power_active], 0
  1604 0000076D 488B05(CF140000)                        mov rax, [default_pallet_size]
  1605 00000774 488905(C7140000)                        mov [pallet_size], rax
  1606 0000077B 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1606 00000783 000000             
  1607 00000786 C605(FC220000)01                        mov byte [catch_power_active], 1
  1608 0000078D EB57                                    jmp .finish_capture
  1609                                  
  1610                                              .activate_laser:
  1611 0000078F C605(FC220000)00                        mov byte [catch_power_active], 0
  1612 00000796 488B05(CF140000)                        mov rax, [default_pallet_size]
  1613 0000079D 488905(C7140000)                        mov [pallet_size], rax
  1614 000007A4 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1614 000007AC 000000             
  1615 000007AF C605(09230000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1616 000007B6 EB2E                                    jmp .finish_capture
  1617                                  
  1618                                              .activate_split:
  1619 000007B8 C605(09230000)00                        mov byte [laser_power_active], 0
  1620 000007BF C605(FC220000)00                        mov byte [catch_power_active], 0
  1621 000007C6 488B05(CF140000)                        mov rax, [default_pallet_size]
  1622 000007CD 488905(C7140000)                        mov [pallet_size], rax
  1623 000007D4 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1623 000007DC 000000             
  1624 000007DF E8DF000000                              call activate_split_power
  1625 000007E4 EB00                                    jmp .finish_capture
  1626                                  
  1627                                              .finish_capture:
  1628 000007E6 C6430300                                mov byte [rbx + 3], 0
  1629                                  
  1630                                          .next_letter:
  1631 000007EA 48FFC1                              inc rcx
  1632 000007ED E9E9FDFFFF                          jmp .move_loop
  1633                                  
  1634                                      .print_last_letter:
  1635                                          ; ;; en vez de imprimir, saltamos
  1636 000007F2 EB0D                            jmp .end
  1637                                  
  1638                                  
  1639                                      .skip_all:                        ; Nueva etiqueta para saltar todo cuando no movemos
  1640 000007F4 415B                            pop r11                       ; Restaurar registros
  1641 000007F6 415A                            pop r10                      ; Restaurar registros
  1642 000007F8 4159                            pop r9
  1643 000007FA 4158                            pop r8
  1644 000007FC 5E                              pop rsi
  1645 000007FD 5F                              pop rdi
  1646 000007FE 5B                              pop rbx
  1647 000007FF 5D                              pop rbp
  1648 00000800 C3                              ret
  1649                                  
  1650                                      .end:
  1651 00000801 415B                            pop r11
  1652 00000803 415A                            pop r10
  1653 00000805 4159                            pop r9
  1654 00000807 4158                            pop r8
  1655 00000809 5E                              pop rsi
  1656 0000080A 5F                              pop rdi
  1657 0000080B 5B                              pop rbx
  1658 0000080C 5D                              pop rbp
  1659 0000080D C3                              ret
  1660                                  
  1661                                  print_power_label:  ; Función para imprimir el mensaje de poder actual
  1662 0000080E 55                          push rbp
  1663 0000080F 4889E5                      mov  rbp, rsp
  1664                                      
  1665                                      ; Crear buffer temporal
  1666 00000812 4883EC20                    sub rsp, 32
  1667                                      
  1668                                      ; Copiar el mensaje base al buffer
  1669 00000816 4889E7                      mov rdi, rsp
  1670 00000819 48BE-                       mov rsi, last_letter_msg
  1670 0000081B [CE22000000000000] 
  1671 00000823 B913000000                  mov rcx, last_letter_msg_len
  1672 00000828 F3A4                        rep movsb
  1673                                      
  1674                                      ; Insertar la última letra capturada
  1675 0000082A 8A05(CD220000)              mov al, [last_letter]
  1676 00000830 8844240F                    mov byte [rsp + 15], al    ; Asumiendo que 15 es la posición correcta
  1677                                      
  1678                                      ; Imprimir el buffer completo
  1679                                      print rsp, last_letter_msg_len
    93 00000834 B801000000          <1>  mov eax, sys_write
    94 00000839 BF01000000          <1>  mov edi, 1
    95 0000083E 4889E6              <1>  mov rsi, %1
    96 00000841 BA13000000          <1>  mov edx, %2
    97 00000846 0F05                <1>  syscall
  1680                                      
  1681                                      ; Restaurar stack
  1682 00000848 4883C420                    add rsp, 32
  1683 0000084C 5D                          pop rbp
  1684 0000084D C3                          ret
  1685                                  
  1686                                  clear_lasers:
  1687 0000084E 55                          push rbp
  1688 0000084F 4889E5                      mov  rbp, rsp
  1689                                  
  1690                                      ; Recorrer el array de láseres
  1691 00000852 4831C9                      xor rcx, rcx                ; Índice del láser
  1692 00000855 480FB61D(0B230000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1693                                  
  1694                                      .clear_loop:
  1695 0000085D 4839D9                          cmp rcx, rbx
  1696 00000860 7D2F                            jge .done                ; Salir si no quedan láseres
  1697                                  
  1698                                          ; Obtener posición del láser actual
  1699 00000862 488DB409[0C230000]              lea rsi, [lasers + rcx * 2]
  1700 0000086A 4C0FB606                        movzx r8, byte [rsi]     ; X
  1701 0000086E 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1702                                  
  1703                                          ; Calcular posición en el tablero
  1704 00000873 B850000000                      mov rax, column_cells
  1705 00000878 4883C002                        add rax, 2
  1706 0000087C 49F7E1                          mul r9
  1707 0000087F 4C01C0                          add rax, r8
  1708 00000882 488DB8[400A0000]                lea rdi, [board + rax]
  1709                                  
  1710                                          ; Borrar el láser visualmente
  1711 00000889 C60720                          mov byte [rdi], ' '
  1712                                  
  1713                                          ; Pasar al siguiente láser
  1714 0000088C 48FFC1                          inc rcx
  1715 0000088F EBCC                            jmp .clear_loop
  1716                                  
  1717                                      .done:
  1718                                          ; Resetear contador de láseres
  1719 00000891 C605(0B230000)00                mov byte [laser_count], 0
  1720                                  
  1721 00000898 5D                              pop rbp
  1722 00000899 C3                              ret
  1723                                  
  1724                                  
  1725                                  ; Nueva función para actualizar los láseres
  1726                                  update_lasers:
  1727 0000089A 55                          push rbp
  1728 0000089B 4889E5                      mov rbp, rsp
  1729                                      
  1730                                      ; Verificar si el poder láser está activo
  1731 0000089E 803D(09230000)00            cmp byte [laser_power_active], 0
  1732 000008A5 741A                        je .end
  1733                                      
  1734                                      ; Verificar si se presionó la tecla de espacio
  1735 000008A7 803D(08230000)20            cmp byte [last_key], ' '
  1736 000008AE 750C                        jne .skip_shooting
  1737                                      
  1738                                      ; Disparar nuevos láseres
  1739 000008B0 E8FD000000                  call shoot_lasers
  1740 000008B5 C605(08230000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1741                                      
  1742                                      .skip_shooting:
  1743                                      ; Mover los láseres existentes
  1744 000008BC E88B010000                  call move_lasers
  1745                                      
  1746                                      .end:
  1747 000008C1 5D                              pop rbp
  1748 000008C2 C3                              ret
  1749                                  
  1750                                  activate_split_power:; Función para activar el poder de división de bolas
  1751 000008C3 55                          push rbp    ; Guardar el puntero de la base
  1752 000008C4 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1753 000008C7 50                          push rax    ; Guardar registros
  1754 000008C8 53                          push rbx    
  1755 000008C9 51                          push rcx
  1756 000008CA 52                          push rdx
  1757                                      
  1758                                      ; Si ambas bolas extra ya están activas, salimos
  1759 000008CB 8A0D(22150000)              mov cl, byte [ball2_active]
  1760 000008D1 220D(44150000)              and cl, byte [ball3_active]
  1761 000008D7 80F901                      cmp cl, 1   ; Verificar si ambas bolas están activas
  1762 000008DA 0F84CC000000                je .end   ; Si ambas bolas están activas, salir
  1763                                      
  1764                                  .find_active_ball:
  1765                                      ; Guardar posición de la bola activa
  1766 000008E0 4831C0                      xor rax, rax    ; Limpiar rax
  1767 000008E3 4831DB                      xor rbx, rbx    ; Limpiar rbx
  1768                                      
  1769                                      ; Revisar ball1
  1770 000008E6 803D(00150000)01            cmp byte [ball_active], 1
  1771 000008ED 7417                        je .use_ball1
  1772                                      
  1773                                      ; Revisar ball2
  1774 000008EF 803D(22150000)01            cmp byte [ball2_active], 1
  1775 000008F6 741E                        je .use_ball2
  1776                                      
  1777                                      ; Revisar ball3
  1778 000008F8 803D(44150000)01            cmp byte [ball3_active], 1
  1779 000008FF 7425                        je .use_ball3
  1780                                      
  1781 00000901 E9A6000000                  jmp .end        ; Si no hay bolas activas, salimos
  1782                                  
  1783                                  .use_ball1:
  1784 00000906 488B05(DF140000)            mov rax, qword [ball_x_pos]; Cargar posición de la bola principal
  1785 0000090D 488B1D(E7140000)            mov rbx, qword [ball_y_pos]     ; Cargar posición de la bola principal
  1786 00000914 EB20                        jmp .create_missing_balls
  1787                                  
  1788                                  .use_ball2:
  1789 00000916 488B05(01150000)            mov rax, qword [ball2_x_pos]    ; Cargar posición de la bola 2
  1790 0000091D 488B1D(09150000)            mov rbx, qword [ball2_y_pos]    ; Cargar posición de la bola 2
  1791 00000924 EB10                        jmp .create_missing_balls
  1792                                  
  1793                                  .use_ball3:
  1794 00000926 488B05(23150000)            mov rax, qword [ball3_x_pos]    ; Cargar posición de la bola 3
  1795 0000092D 488B1D(2B150000)            mov rbx, qword [ball3_y_pos]    ; Cargar posición de la bola 3
  1796 00000934 EB00                        jmp .create_missing_balls
  1797                                  
  1798                                  .create_missing_balls:
  1799                                      ; Intentar crear ball2 si no está activa    
  1800 00000936 803D(22150000)01            cmp byte [ball2_active], 1
  1801 0000093D 7432                        je .create_ball3    ; Si ball2 ya está activa, intentar crear ball3
  1802                                      
  1803                                      ; Crear ball2
  1804 0000093F 488905(01150000)            mov qword [ball2_x_pos], rax    ; Copiar posición de la bola activa
  1805 00000946 48891D(09150000)            mov qword [ball2_y_pos], rbx    ; Copiar posición de la bola activa
  1806 0000094D 48C705(11150000)FF-         mov qword [ball2_direction_x], -1   ; Dirección opuesta
  1806 00000955 FFFFFF             
  1807 00000958 48C705(19150000)FF-         mov qword [ball2_direction_y], -1   ; Dirección opuesta
  1807 00000960 FFFFFF             
  1808 00000963 C605(21150000)01            mov byte [ball2_moving], 1  ; Activar movimiento
  1809 0000096A C605(22150000)01            mov byte [ball2_active], 1  ; Activar bola2
  1810                                      
  1811                                  .create_ball3:
  1812                                      ; Intentar crear ball3 si no está activa
  1813 00000971 803D(44150000)01            cmp byte [ball3_active], 1
  1814 00000978 7432                        je .end
  1815                                      
  1816                                      ; Crear ball3
  1817 0000097A 488905(23150000)            mov qword [ball3_x_pos], rax    ; Copiar posición de la bola activa
  1818 00000981 48891D(2B150000)            mov qword [ball3_y_pos], rbx    ; Copiar posición de la bola activa
  1819 00000988 48C705(33150000)01-         mov qword [ball3_direction_x], 1    ; Dirección opuesta
  1819 00000990 000000             
  1820 00000993 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1       ; Dirección opuesta
  1820 0000099B FFFFFF             
  1821 0000099E C605(43150000)01            mov byte [ball3_moving], 1
  1822 000009A5 C605(44150000)01            mov byte [ball3_active], 1  
  1823                                  
  1824                                  .end:
  1825 000009AC 5A                          pop rdx   ; Restaurar registros
  1826 000009AD 59                          pop rcx
  1827 000009AE 5B                          pop rbx
  1828 000009AF 58                          pop rax
  1829 000009B0 5D                          pop rbp
  1830 000009B1 C3                          ret
  1831                                  
  1832                                  
  1833                                  shoot_lasers:   ; Función para disparar láseres
  1834 000009B2 55                          push rbp    ; Guardar el puntero de la base
  1835 000009B3 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1836 000009B6 53                          push rbx
  1837                                      
  1838                                      ; Verificar si hay espacio para más láseres
  1839 000009B7 480FB605(0B230000)          movzx rax, byte [laser_count]
  1840 000009BF 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1841 000009C3 0F8D80000000                jge .end
  1842                                      
  1843                                      ; Obtener posición de la paleta
  1844 000009C9 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición de la paleta
  1845 000009D0 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1846                                      
  1847                                      ; Calcular coordenadas x,y
  1848 000009D7 4C89C0                      mov rax, r8                 ; Posición de la paleta
  1849 000009DA 41B950000000                mov r9, column_cells    ; Ancho del tablero
  1850 000009E0 4983C102                    add r9, 2                     ; Ancho total de línea
  1851 000009E4 4831D2                      xor rdx, rdx             ; Limpiar rdx
  1852 000009E7 49F7F1                      div r9                        ; rax = y, rdx = x
  1853                                      
  1854                                      ; Guardar coordenadas
  1855 000009EA 4989C2                      mov r10, rax                  ; Y en r10
  1856 000009ED 4989D3                      mov r11, rdx                  ; X en r11
  1857                                      
  1858                                      ; Validar coordenadas
  1859 000009F0 4983FA00                    cmp r10, 0  ; Verificar si está en la primera fila
  1860 000009F4 7C53                        jl .end   ; Si está en la primera fila, salir
  1861 000009F6 4983FA20                    cmp r10, row_cells  ; Verificar si está en la última fila
  1862 000009FA 7D4D                        jge .end    ; Si está en la última fila, salir
  1863 000009FC 4983FB00                    cmp r11, 0  ; Verificar si está en la primera columna
  1864 00000A00 7C47                        jl .end  ; Si está en la primera columna, salir
  1865 00000A02 4983FB50                    cmp r11, column_cells   ; Verificar si está en la última columna
  1866 00000A06 7D41                        jge .end    ; Si está en la última columna, salir
  1867                                      
  1868                                      ; Calcular índice para el primer láser
  1869 00000A08 480FB61D(0B230000)          movzx rbx, byte [laser_count]
  1870 00000A10 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1871                                      
  1872                                      ; Primer láser (izquierda)
  1873 00000A14 488DBB[0C230000]            lea rdi, [lasers + rbx]   ; Dirección del láser
  1874 00000A1B 44881F                      mov [rdi], r11b              ; X
  1875 00000A1E 4488D0                      mov al, r10b              ; Y - 1
  1876 00000A21 FEC8                        dec al                       ; Y - 1
  1877 00000A23 884701                      mov [rdi + 1], al           ; Y
  1878                                      
  1879                                      ; Segundo láser (derecha)
  1880 00000A26 4488D8                      mov al, r11b
  1881 00000A29 0205(C7140000)              add al, byte [pallet_size]  ; X + tamaño de la paleta
  1882 00000A2F FEC8                        dec al                       ; Ajustar para el último carácter
  1883 00000A31 488DBB[0E230000]            lea rdi, [lasers + rbx + 2]
  1884 00000A38 8807                        mov [rdi], al               ; X
  1885 00000A3A 4488D0                      mov al, r10b
  1886 00000A3D FEC8                        dec al                      ; Y - 1
  1887 00000A3F 884701                      mov [rdi + 1], al          ; Y
  1888                                      
  1889                                      ; Incrementar contador de láseres
  1890 00000A42 8005(0B230000)02            add byte [laser_count], 2
  1891                                      
  1892                                      
  1893                                      .end:
  1894 00000A49 5B                              pop rbx
  1895 00000A4A 5D                              pop rbp
  1896 00000A4B C3                              ret
  1897                                  
  1898                                  ; ============================================================
  1899                                  ; NUEVA FUNCIÓN move_lasers 
  1900                                  ; ============================================================
  1901                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1902                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1903                                  ; ============================================================
  1904                                  move_lasers:
  1905 00000A4C 55                          push rbp
  1906 00000A4D 4889E5                      mov  rbp, rsp
  1907 00000A50 53                          push rbx
  1908 00000A51 57                          push rdi
  1909 00000A52 56                          push rsi
  1910 00000A53 4154                        push r12
  1911 00000A55 4155                        push r13
  1912 00000A57 4156                        push r14
  1913 00000A59 4157                        push r15
  1914                                  
  1915                                      ; 1) Tomamos la cantidad de láseres
  1916 00000A5B 480FB60D(0B230000)          movzx rcx, byte [laser_count]
  1917 00000A63 4885C9                      test rcx, rcx
  1918 00000A66 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1919                                  
  1920                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1921 00000A6C 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1922                                  
  1923                                  .loop_lasers:
  1924                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1925 00000A6F 488DB409[0C230000]          lea rsi, [lasers + rcx*2]
  1926                                  
  1927                                      ; 2) Cargar x,y actuales del láser
  1928 00000A77 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1929 00000A7B 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1930                                  
  1931                                      ; 3) Borrar el láser de su posición actual en pantalla
  1932                                      ;    (por si en el ciclo anterior se había dibujado)
  1933 00000A80 B850000000                  mov rax, column_cells
  1934 00000A85 4883C002                    add rax, 2
  1935 00000A89 49F7E1                      mul r9
  1936 00000A8C 4C01C0                      add rax, r8
  1937 00000A8F 488DB8[400A0000]            lea rdi, [board + rax]
  1938 00000A96 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1939                                  
  1940                                      ; 4) Mover el láser hacia arriba (y - 1)
  1941 00000A99 49FFC9                      dec r9
  1942                                  
  1943                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1944 00000A9C 4983F901                    cmp r9, 1
  1945 00000AA0 7C57                        jl .delete_laser
  1946                                  
  1947                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1948 00000AA2 44884E01                    mov byte [rsi + 1], r9b
  1949                                  
  1950                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1951                                      ;    - Primero colisión con bloques
  1952                                      ; ---------------------------------------------------------
  1953                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1954 00000AA6 B850000000                  mov rax, column_cells
  1955 00000AAB 4883C002                    add rax, 2
  1956 00000AAF 49F7E1                      mul r9
  1957 00000AB2 4C01C0                      add rax, r8
  1958 00000AB5 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1959                                  
  1960                                      ; Revisar si hay bloque
  1961 00000ABC 51                          push rcx
  1962 00000ABD 56                          push rsi
  1963 00000ABE 57                          push rdi
  1964 00000ABF 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1965 00000AC2 E877100000                  call check_block_collision
  1966 00000AC7 5F                          pop rdi
  1967 00000AC8 5E                          pop rsi
  1968 00000AC9 59                          pop rcx
  1969                                  
  1970 00000ACA 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1971 00000ACD 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1972                                  
  1973                                      ;    - Luego colisión con enemigos
  1974                                      ; ---------------------------------------------------------
  1975 00000ACF 51                          push rcx
  1976 00000AD0 56                          push rsi
  1977 00000AD1 57                          push rdi
  1978                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1979                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1980                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1981                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1982                                      ;
  1983                                      ; Hacemos algo como:
  1984 00000AD2 4989FA                      mov r10, rdi
  1985 00000AD5 E85A000000                  call check_laser_enemy_collision
  1986 00000ADA 5F                          pop rdi
  1987 00000ADB 5E                          pop rsi
  1988 00000ADC 59                          pop rcx
  1989                                  
  1990 00000ADD 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1991 00000AE0 7517                        jnz .delete_laser
  1992                                  
  1993                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1994 00000AE2 8A05(0A230000)              mov al, [laser_symbol]
  1995 00000AE8 8807                        mov [rdi], al
  1996                                  
  1997                                  .next_laser:
  1998                                      ; Pasamos al láser anterior en el array
  1999 00000AEA 48FFC9                      dec rcx
  2000 00000AED 4883F9FF                    cmp rcx, -1
  2001 00000AF1 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  2002 00000AF7 EB2E                        jmp .fin
  2003                                  
  2004                                  ; -----------------------------------------------------------------
  2005                                  ; Subrutina interna: .delete_laser
  2006                                  ; -----------------------------------------------------------------
  2007                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  2008                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  2009                                  .delete_laser:
  2010 00000AF9 4C0FB625(0B230000)          movzx r12, byte [laser_count]
  2011 00000B01 49FFCC                      dec r12                    ; r12 = índice del último láser
  2012 00000B04 4939CC                      cmp r12, rcx
  2013 00000B07 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  2014                                  
  2015                                      ; Copiamos el último láser a la posición actual
  2016 00000B09 488DBC09[0C230000]          lea rdi, [lasers + rcx*2]
  2017 00000B11 4B8DB424[0C230000]          lea rsi, [lasers + r12*2]
  2018 00000B19 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  2019 00000B1C 668907                      mov [rdi], ax             ; copiamos X,Y
  2020                                  
  2021                                  .just_decrement:
  2022 00000B1F FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2023 00000B25 EBC3                        jmp .next_laser
  2024                                  
  2025                                  .fin:
  2026 00000B27 415F                        pop r15
  2027 00000B29 415E                        pop r14
  2028 00000B2B 415D                        pop r13
  2029 00000B2D 415C                        pop r12
  2030 00000B2F 5E                          pop rsi
  2031 00000B30 5F                          pop rdi
  2032 00000B31 5B                          pop rbx
  2033 00000B32 5D                          pop rbp
  2034 00000B33 C3                          ret
  2035                                  
  2036                                  
  2037                                  ; Nueva función para verificar colisión entre láser y enemigos
  2038                                  ; ==========================================================
  2039                                  ; NUEVA check_laser_enemy_collision
  2040                                  ; ==========================================================
  2041                                  check_laser_enemy_collision:    ; Función para verificar colisión entre láser y enemigos
  2042 00000B34 55                          push rbp        
  2043 00000B35 4889E5                      mov  rbp, rsp
  2044                                      
  2045 00000B38 4D31ED                      xor r13, r13            ; Índice del enemigo
  2046 00000B3B 4831C0                      xor rax, rax            ; 0 = no colisión
  2047                                  
  2048                                  .loop_enemies:      ; Iterar sobre los enemigos
  2049 00000B3E 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  2050 00000B42 7D64                        jge .end            ; Si no hay más enemigos, salir
  2051                                  
  2052                                      ; r13 * 3 => offset del enemigo i
  2053 00000B44 4C89E9                      mov rcx, r13        ; r13 = i
  2054 00000B47 486BC903                    imul rcx, 3        ; rcx = i * 3
  2055 00000B4B 488DB1[60200000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  2056                                  
  2057                                      ; Verificar si está activo
  2058 00000B52 807E0201                    cmp byte [rsi+2], 1 
  2059 00000B56 754B                        jne .next_enemy       ; Si no está activo, probar con el siguiente enemigo
  2060                                  
  2061                                      ; Cargar posición X/Y del enemigo
  2062 00000B58 4C0FB636                    movzx r14, byte [rsi]      ; X
  2063 00000B5C 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  2064                                  
  2065                                      ; Comparar con posición del láser (r8=X, r9=Y)
  2066 00000B61 4D39F0                      cmp r8, r14
  2067 00000B64 753D                        jne .next_enemy        ; Si no coincide X, probar con el siguiente enemigo
  2068 00000B66 4D39F9                      cmp r9, r15
  2069 00000B69 7538                        jne .next_enemy     ; Si no coincide Y, probar con el siguiente enemigo
  2070                                  
  2071                                      ; ==== Colisión detectada con láser ====
  2072                                  
  2073                                      ; 1) Desactivar enemigo
  2074 00000B6B C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  2075                                  
  2076                                      ; 2) Sumar puntos
  2077 00000B6F 488B05(7F200000)            mov rax, [enemy_points]  ; Puntos por enemigo
  2078 00000B76 480105(3E200000)            add [current_score], rax
  2079                                  
  2080                                      ; 3) Borrar del board, SOLO si no coincide con la paleta
  2081                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  2082 00000B7D 4983FF1E                    cmp r15, row_cells - 2
  2083 00000B81 7419                        je .skip_erase
  2084                                  
  2085                                      ; Borrar visualmente del board
  2086 00000B83 B850000000                  mov rax, column_cells   ; Ancho del tablero
  2087 00000B88 4883C002                    add rax, 2            ; Incluir caracteres de nueva línea
  2088 00000B8C 49F7E7                      mul r15              ; Multiplicar por Y
  2089 00000B8F 4C01F0                      add rax, r14     ; Sumar X
  2090 00000B92 488DB8[400A0000]            lea rdi, [board + rax]      ; Dirección en el tablero
  2091 00000B99 C60720                      mov byte [rdi], ' '       ; Borrar enemigo visualmente
  2092                                  
  2093                                  .skip_erase:
  2094                                  
  2095                                      ; 4) Devolver rax=1 => colisión con enemigo
  2096 00000B9C B801000000                  mov rax, 1  
  2097 00000BA1 EB05                        jmp .end
  2098                                  
  2099                                  .next_enemy:    ; Pasar al siguiente enemigo
  2100 00000BA3 49FFC5                      inc r13       ; Siguiente enemigo
  2101 00000BA6 EB96                        jmp .loop_enemies   ; Iterar
  2102                                  
  2103                                  .end:
  2104 00000BA8 5D                          pop rbp
  2105 00000BA9 C3                          ret
  2106                                  
  2107                                  
  2108                                  ; Función auxiliar para eliminar un láser específico
  2109                                  remove_laser:
  2110 00000BAA 55                          push rbp    
  2111 00000BAB 4889E5                      mov rbp, rsp
  2112                                  
  2113                                      ; Borrar el láser del tablero
  2114 00000BAE 41C60220                    mov byte [r10], ' '
  2115                                  
  2116                                      ; Mover el último láser a esta posición si no es el último
  2117 00000BB2 480FB605(0B230000)          movzx rax, byte [laser_count]
  2118 00000BBA 48FFC8                      dec rax                    ; Índice del último láser
  2119 00000BBD 4939C4                      cmp r12, rax              ; Comparar con láser actual
  2120 00000BC0 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  2121                                  
  2122                                      ; Copiar último láser a la posición actual
  2123 00000BC2 4B8DBC24[0C230000]          lea rdi, [lasers + r12*2]   ; Dirección del último láser
  2124 00000BCA 488DB400[0C230000]          lea rsi, [lasers + rax*2]   ; Dirección del láser actual
  2125 00000BD2 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  2126 00000BD5 668917                      mov [rdi], dx
  2127                                  
  2128                                  .just_decrease:
  2129 00000BD8 FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2130                                  
  2131 00000BDE 5D                          pop rbp
  2132 00000BDF C3                          ret
  2133                                  
  2134                                  add_life:   ; Función para añadir una vida
  2135 00000BE0 55                          push rbp
  2136 00000BE1 4889E5                      mov rbp, rsp    
  2137 00000BE4 53                          push rbx
  2138 00000BE5 51                          push rcx
  2139 00000BE6 57                          push rdi
  2140 00000BE7 56                          push rsi
  2141 00000BE8 4150                        push r8
  2142 00000BEA 4151                        push r9
  2143                                      
  2144                                      ; Verificar si ya tenemos el máximo de vidas
  2145 00000BEC 480FB605(3B210000)          movzx rax, byte [current_lives]
  2146 00000BF4 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  2147 00000BF8 7D2C                        jge .end
  2148                                      
  2149                                      ; Incrementar el contador de vidas
  2150 00000BFA FE05(3B210000)              inc byte [current_lives]
  2151                                      
  2152                                      ; Encontrar la siguiente vida inactiva
  2153 00000C00 4831C9                      xor rcx, rcx
  2154                                      
  2155                                      .find_inactive:     
  2156 00000C03 4883F907                        cmp rcx, lives_count    ; Verificar si llegamos al final
  2157 00000C07 7D1D                            jge .end    
  2158                                          
  2159                                          ; Calcular offset de la vida actual
  2160 00000C09 4889C8                          mov rax, rcx    ; Índice de la vida
  2161 00000C0C 486BC003                        imul rax, 3    ; Cada vida usa 3 bytes
  2162 00000C10 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Dirección de la vida actual
  2163                                          
  2164                                          ; Verificar si está inactiva
  2165 00000C17 807E0200                        cmp byte [rsi + 2], 0
  2166 00000C1B 7405                            je .activate_life   ; Si está inactiva, activarla
  2167                                          
  2168 00000C1D 48FFC1                          inc rcx   ; Probar con la siguiente vida
  2169 00000C20 EBE1                            jmp .find_inactive  ; Continuar buscando
  2170                                          
  2171                                      .activate_life:
  2172                                          ; Activar la vida
  2173 00000C22 C6460201                        mov byte [rsi + 2], 1
  2174                                          
  2175                                      .end:
  2176 00000C26 4159                            pop r9
  2177 00000C28 4158                            pop r8
  2178 00000C2A 5E                              pop rsi
  2179 00000C2B 5F                              pop rdi
  2180 00000C2C 59                              pop rcx
  2181 00000C2D 5B                              pop rbx
  2182 00000C2E 5D                              pop rbp
  2183 00000C2F C3                              ret
  2184                                  
  2185                                  
  2186                                  print_ball:
  2187 00000C30 4C8B05(DF140000)        	mov r8, [ball_x_pos]    ; Cargar posición X de la bola
  2188 00000C37 4C8B0D(E7140000)        	mov r9, [ball_y_pos]    ; Cargar posición Y de la bola
  2189 00000C3E 4981C0[400A0000]        	add r8, board       ; Añadir offset del tablero
  2190                                  
  2191 00000C45 4C89C9                  	mov rcx, r9        ; Y
  2192 00000C48 B852000000              	mov rax, column_cells + 2   ; Ancho del tablero
  2193 00000C4D 48F7E9                  	imul rcx     ; Multiplicar por Y
  2194                                  	
  2195 00000C50 4901C0                  	add r8, rax   ; Sumar X
  2196 00000C53 41C6004F                	mov byte [r8], char_O       ; Dibujar la bola en el tablero
  2197 00000C57 C3                      	ret
  2198                                  
  2199                                  print_ball_2:   ; Función para imprimir la segunda bola
  2200 00000C58 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X de la segunda bola
  2201 00000C5F 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y de la segunda bola
  2202 00000C66 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2203 00000C6D 4C89C9                      mov rcx, r9     ; Y
  2204 00000C70 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2205 00000C75 48F7E9                      imul rcx    ; Multiplicar por Y
  2206 00000C78 4901C0                      add r8, rax  ; Sumar X
  2207 00000C7B 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2208 00000C7F C3                          ret     ; Retornar
  2209                                  
  2210                                  print_ball_3:   ; Función para imprimir la tercera bola
  2211 00000C80 4C8B05(23150000)            mov r8, [ball3_x_pos]   ; Cargar posición X de la tercera bola
  2212 00000C87 4C8B0D(2B150000)            mov r9, [ball3_y_pos]   ; Cargar posición Y de la tercera bola
  2213 00000C8E 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2214 00000C95 4C89C9                      mov rcx, r9   ; Y
  2215 00000C98 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2216 00000C9D 48F7E9                      imul rcx    ; Multiplicar por Y
  2217 00000CA0 4901C0                      add r8, rax  ; Sumar X
  2218 00000CA3 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2219 00000CA7 C3                          ret    ; Retornar
  2220                                  
  2221                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  2222                                  	
  2223                                  print_pallet:
  2224                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  2225 00000CA8 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición actual de la paleta
  2226 00000CAF 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño actual de la paleta
  2227                                      .clear_pallet:  ; Bucle para borrar la paleta
  2228 00000CB6 41C60020                        mov byte [r8], char_space   ; Borrar carácter actual
  2229 00000CBA 49FFC0                          inc r8  ; Mover al siguiente carácter
  2230 00000CBD 48FFC9                          dec rcx ; Decrementar contador
  2231 00000CC0 75F4                            jnz .clear_pallet   ; Repetir si no hemos terminado
  2232                                  
  2233                                      ; Luego dibujar la nueva paleta con el tamaño actual
  2234 00000CC2 4C8B05(BF140000)            mov r8, [pallet_position]
  2235 00000CC9 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño de la paleta
  2236                                      .write_pallet:  ; Bucle para escribir la paleta
  2237 00000CD0 41C6003D                        mov byte [r8], char_equal   ; Dibujar carácter actual
  2238 00000CD4 49FFC0                          inc r8  ; Mover al siguiente carácter
  2239 00000CD7 48FFC9                          dec rcx ; Decrementar contador
  2240 00000CDA 75F4                            jnz .write_pallet   ; Repetir si no hemos terminado
  2241                                  
  2242 00000CDC C3                          ret
  2243                                  
  2244                                  move_pallet:    ; Función para mover la paleta
  2245                                      
  2246 00000CDD 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2247 00000CE4 7507                        jne .continue_movement  ; Si la bola se está moviendo, continuar
  2248 00000CE6 C605(FF140000)01            mov byte [ball_moving], 1   ; Marcar la bola como en movimiento
  2249                                  
  2250                                      .continue_movement:
  2251 00000CED 4883FFFF                        cmp rdi, left_direction  ; Verificar si la dirección es a la izquierda
  2252 00000CF1 7531                            jne .move_right  ; Si no es a la izquierda, mover a la derecha
  2253                                  
  2254                                          .move_left:         
  2255                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  2256 00000CF3 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2257 00000CFA 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  2258 00000CFD 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2259 00000D00 3C58                                cmp al, 'X'        ; Comparar si es una X
  2260 00000D02 744D                                je .end            ; Si es X, no mover
  2261                                              
  2262 00000D04 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2263 00000D0B 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2264 00000D12 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  2265 00000D18 49FFC8                              dec r8            ; Mover a la izquierda
  2266 00000D1B 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2267 00000D22 EB2D                                jmp .end    ; Salir
  2268                                              
  2269                                          .move_right:
  2270                                              ; Verificar si la siguiente posición después de la paleta sería una X
  2271 00000D24 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2272 00000D2B 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2273 00000D32 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  2274 00000D35 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2275 00000D38 3C58                                cmp al, 'X'        ; Comparar si es una X
  2276 00000D3A 7415                                je .end            ; Si es X, no mover
  2277                                              
  2278 00000D3C 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2279 00000D43 41C60020                            mov byte [r8], char_space   ; Borrar primer carácter de la paleta
  2280 00000D47 49FFC0                              inc r8          ; Mover a la derecha
  2281 00000D4A 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2282                                          .end:
  2283 00000D51 C3                                  ret
  2284                                  
  2285                                  
  2286                                  
  2287                                              
  2288                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  2289                                  update_caught_ball_position:    ; Función para actualizar la posición de la bola atrapada
  2290 00000D52 55                          push rbp    ; Guardar el puntero de la base
  2291 00000D53 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  2292                                      
  2293                                      ; Calcular la nueva posición de la bola basada en la paleta
  2294 00000D56 4C8B05(BF140000)            mov r8, [pallet_position]   ; Obtener posición actual de la paleta
  2295 00000D5D 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  2296 00000D64 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2297 00000D69 4831D2                      xor rdx, rdx      ; Limpiar rdx
  2298 00000D6C 48F7F0                      div rax                ; División para obtener X,Y
  2299                                      
  2300                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  2301 00000D6F 4989C1                      mov r9, rax            ; Y de la paleta
  2302 00000D72 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  2303                                      
  2304                                      ; Añadir el offset guardado a la posición X
  2305 00000D75 4889D0                      mov rax, rdx
  2306 00000D78 480305(00230000)            add rax, [ball_catch_offset]    ; Añadir el offset guardado
  2307 00000D7F 488905(DF140000)            mov [ball_x_pos], rax   ; Guardar nueva posición X
  2308 00000D86 4C890D(E7140000)            mov [ball_y_pos], r9    ; Guardar nueva posición Y
  2309                                      
  2310 00000D8D 5D                          pop rbp
  2311 00000D8E C3                          ret
  2312                                  
  2313                                  
  2314                                  move_all_balls:
  2315 00000D8F 55                          push rbp
  2316 00000D90 4889E5                      mov rbp, rsp
  2317 00000D93 53                          push rbx
  2318                                      
  2319                                      ; Inicializar contador de bolas
  2320 00000D94 4831DB                      xor rbx, rbx
  2321                                      
  2322                                  .loop_balls:
  2323                                      ; Verificar si hemos procesado todas las bolas
  2324 00000D97 3A1D(3F240000)              cmp bl, byte [balls_count]  ; Comparar con la cantidad de bolas
  2325 00000D9D 7D1D                        jge .end    ; Si hemos procesado todas las bolas, salir
  2326                                      
  2327                                      ; Calcular offset de la bola actual
  2328 00000D9F B821000000                  mov rax, BALL_STRUCT_SIZE
  2329 00000DA4 48F7E3                      mul rbx   ; Multiplicar por el índice de la bola
  2330                                      
  2331                                      ; Verificar si la bola está activa
  2332 00000DA7 80B8[FC230000]01            cmp byte [balls_data + rax + 32], 1
  2333 00000DAE 7507                        jne .next_ball  ; Si la bola no está activa, pasar a la siguiente
  2334                                      
  2335                                      ; Guardar offset en la pila
  2336 00000DB0 50                          push rax
  2337                                      
  2338                                      ; Llamar a move_ball con los parámetros de esta bola
  2339 00000DB1 E809000000                  call move_ball
  2340                                      
  2341                                      ; Restaurar offset
  2342 00000DB6 58                          pop rax
  2343                                      
  2344                                  .next_ball:     ; Pasar a la siguiente bola
  2345 00000DB7 48FFC3                      inc rbx  ; Incrementar contador de bolas
  2346 00000DBA EBDB                        jmp .loop_balls ; Repetir el ciclo
  2347                                      
  2348                                  .end:
  2349 00000DBC 5B                          pop rbx
  2350 00000DBD 5D                          pop rbp
  2351 00000DBE C3                          ret
  2352                                  
  2353                                  move_ball:  ; Función para mover una bola
  2354                                  
  2355 00000DBF 803D(FD220000)01            cmp byte [ball_caught], 1   ; Verificar si la bola está atrapada
  2356 00000DC6 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2357                                  
  2358 00000DCC 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2359 00000DD3 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2360                                  
  2361                                      ; Incrementar contador de velocidad
  2362 00000DD9 48FF05(F3220000)            inc qword [speed_counter]
  2363                                      
  2364                                      ; Verificar si debemos mover la bola en este ciclo
  2365 00000DE0 488B05(F3220000)            mov rax, [speed_counter]
  2366 00000DE7 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2367 00000DEE 0F8C9D010000                jl .end  ; Si no es tiempo de mover la bola, salir
  2368                                      
  2369                                      ; Resetear contador de velocidad
  2370 00000DF4 48C705(F3220000)00-         mov qword [speed_counter], 0    ; Resetear contador
  2370 00000DFC 000000             
  2371                                  
  2372                                      ; Borrar la posición actual de la bola
  2373 00000DFF 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2374 00000E06 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2375 00000E0D 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2376 00000E14 4C89C9                      mov rcx, r9   ; Y
  2377 00000E17 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2378 00000E1C 48F7E9                      imul rcx    ; Multiplicar por Y
  2379 00000E1F 4901C0                      add r8, rax  ; Sumar X
  2380 00000E22 41C60020                    mov byte [r8], char_space   ; Borrar la bola de la posición actual
  2381                                  
  2382                                      ; Calcular siguiente posición X
  2383 00000E26 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2384 00000E2D 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2385 00000E34 488B05(EF140000)            mov rax, [ball_direction_x]  ; Cargar dirección X de la bola
  2386 00000E3B 4901C0                      add r8, rax               ; Nueva posición X
  2387                                  
  2388                                      ; Calcular la dirección de memoria para la siguiente posición
  2389 00000E3E 4D89C2                      mov r10, r8
  2390 00000E41 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2391 00000E48 4C89C9                      mov rcx, r9   ; Y
  2392 00000E4B B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2393 00000E50 48F7E9                      imul rcx    ; Multiplicar por Y
  2394 00000E53 4901C2                      add r10, rax    ; Sumar X
  2395                                  
  2396                                      ; Verificar si hay una X en la siguiente posición X
  2397 00000E56 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2398 00000E59 3C58                        cmp al, 'X'     ; Comparar con X
  2399 00000E5B 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2400 00000E5D 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  2401 00000E64 E928010000                  jmp .end    ; Salir
  2402                                  
  2403                                      .move_with_pallet:  ; Mover la bola con la paleta
  2404                                          ; Borrar la posición actual de la bola
  2405 00000E69 4C8B05(DF140000)                mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2406 00000E70 4C8B0D(E7140000)                mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2407 00000E77 4D89C2                          mov r10, r8   ; Guardar posición X actual
  2408 00000E7A 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2409 00000E81 4C89C9                          mov rcx, r9  ; Y
  2410 00000E84 B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2411 00000E89 48F7E9                          imul rcx    ; Multiplicar por Y
  2412 00000E8C 4901C2                          add r10, rax    ; Sumar X
  2413 00000E8F 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2414                                  
  2415                                          ; Actualizar posición X basada en la paleta
  2416 00000E93 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2417 00000E9A 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2418 00000EA1 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2419 00000EA8 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  2420                                  
  2421                                          ; Mantener la bola una posición arriba de la paleta
  2422 00000EAF 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  2423 00000EB6 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  2424                                  
  2425 00000EBD E9CF000000                      jmp .end
  2426                                  
  2427                                  
  2428                                      .check_block_x: 
  2429                                          ; Verificar colisión con bloques en X
  2430 00000EC2 4150                            push r8     ; Guardar registros que usa check_block_collision
  2431 00000EC4 4151                            push r9     ; Guardar registros que usa check_block_collision
  2432 00000EC6 4152                            push r10    ; Guardar registros que usa check_block_collision
  2433 00000EC8 E8710C0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2434 00000ECD 415A                            pop r10    ; Restaurar registros
  2435 00000ECF 4159                            pop r9   ; Restaurar registros
  2436 00000ED1 4158                            pop r8  ; Restaurar registros
  2437 00000ED3 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2438 00000ED6 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2439 00000ED8 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  2440 00000EDF E9AD000000                      jmp .end    ; Salir
  2441                                  
  2442                                      .check_paddle_x:
  2443                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2444 00000EE4 41803A3D                        cmp byte [r10], char_equal  ; Comparar con el carácter de la paleta
  2445 00000EE8 750C                            jne .check_y_movement   ; Si no es la paleta, verificar movimiento en Y
  2446 00000EEA 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  2447 00000EF1 E99B000000                      jmp .end
  2448                                  
  2449                                      .check_y_movement:  ; Verificar movimiento en Y
  2450                                          ; Calcular siguiente posición Y
  2451 00000EF6 488B05(F7140000)                mov rax, [ball_direction_y] ; Cargar dirección Y de la bola
  2452 00000EFD 4901C1                          add r9, rax                  ; Nueva posición Y
  2453                                  
  2454                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2455 00000F00 4D89C2                          mov r10, r8
  2456 00000F03 4981C2[400A0000]                    add r10, board  ; Añadir offset del tablero
  2457 00000F0A 4C89C9                              mov rcx, r9  ; Y
  2458 00000F0D B852000000                          mov rax, column_cells + 2   ; Ancho del tablero 
  2459 00000F12 48F7E9                          imul rcx    ; Multiplicar por Y
  2460 00000F15 4901C2                          add r10, rax    ; Sumar X
  2461                                  
  2462                                          ; Verificar si hay una X en la siguiente posición Y
  2463 00000F18 418A02                          mov al, [r10]       ; Cargar el carácter en la siguiente posición
  2464 00000F1B 3C58                            cmp al, 'X'    ; Comparar con X
  2465 00000F1D 7509                            jne .check_block_y  ; Si no hay X, verificar colisión con bloques
  2466 00000F1F 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  2467 00000F26 EB69                            jmp .end    ; Salir
  2468                                  
  2469                                      .check_block_y:
  2470                                          ; Verificar colisión con bloques en Y
  2471 00000F28 4150                            push r8     ; Guardar registros que usa check_block_collision
  2472 00000F2A 4151                            push r9    ; Guardar registros que usa check_block_collision
  2473 00000F2C 4152                            push r10    ; Guardar registros que usa check_block_collision
  2474 00000F2E E80B0C0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2475 00000F33 415A                            pop r10   ; Restaurar registros
  2476 00000F35 4159                            pop r9  ; Restaurar registros
  2477 00000F37 4158                            pop r8  ; Restaurar registros
  2478 00000F39 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2479 00000F3C 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2480 00000F3E 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  2481 00000F45 EB4A                            jmp .end
  2482                                  
  2483                                      .check_paddle_y:
  2484                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2485 00000F47 41803A3D                        cmp byte [r10], char_equal
  2486 00000F4B 7536                            jne .update_position    ; Si no es la paleta, actualizar posición
  2487                                  
  2488                                          ; Verificar si el poder catch está activo
  2489 00000F4D 803D(FC220000)01                cmp byte [catch_power_active], 1
  2490 00000F54 7524                            jne .normal_bounce  ; Si no está activo, rebotar normalmente
  2491                                  
  2492                                          ; Activar el modo "atrapado"
  2493 00000F56 C605(FD220000)01                mov byte [ball_caught], 1   ; Marcar la bola como atrapada
  2494                                          
  2495                                          ; Guardar la posición X actual de la bola como offset
  2496 00000F5D 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  2497 00000F64 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2498 00000F6B 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2499 00000F71 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2500                                          
  2501 00000F78 EB17                            jmp .end
  2502                                  
  2503                                      .normal_bounce:
  2504 00000F7A 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  2505 00000F81 EB0E                            jmp .end
  2506                                  
  2507                                  
  2508                                      .update_position:   ; Actualizar la posición de la bola
  2509 00000F83 4C8905(DF140000)                mov [ball_x_pos], r8    ; Guardar nueva posición X
  2510 00000F8A 4C890D(E7140000)                mov [ball_y_pos], r9        ; Guardar nueva posición Y
  2511                                  
  2512                                      .end:
  2513 00000F91 C3                              ret
  2514                                  
  2515                                  
  2516                                  move_ball_2:
  2517                                  
  2518 00000F92 803D(FE220000)01            cmp byte [ball_caught_2], 1  ; Verificar si la bola está atrapada
  2519 00000F99 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2520                                  
  2521 00000F9F 803D(21150000)00            cmp byte [ball2_moving], 0  ; Verificar si la bola está en movimiento
  2522 00000FA6 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2523                                  
  2524                                      ; Incrementar contador de velocidad
  2525 00000FAC 48FF05(F3220000)            inc qword [speed_counter]   ; Incrementar contador de velocidad
  2526                                      
  2527                                      ; Verificar si debemos mover la bola en este ciclo
  2528 00000FB3 488B05(F3220000)            mov rax, [speed_counter]
  2529 00000FBA 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2530 00000FC1 0F8C9D010000                jl .end
  2531                                      
  2532                                      ; Resetear contador de velocidad
  2533 00000FC7 48C705(F3220000)00-         mov qword [speed_counter], 0
  2533 00000FCF 000000             
  2534                                  
  2535                                      ; Borrar la posición actual de la bola
  2536 00000FD2 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2537 00000FD9 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2538 00000FE0 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2539 00000FE7 4C89C9                      mov rcx, r9  ; Y
  2540 00000FEA B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2541 00000FEF 48F7E9                      imul rcx    ; Multiplicar por Y
  2542 00000FF2 4901C0                      add r8, rax     ; Sumar X
  2543 00000FF5 41C60020                    mov byte [r8], char_space       ; Borrar la bola de la posición actual
  2544                                  
  2545                                      ; Calcular siguiente posición X
  2546 00000FF9 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2547 00001000 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2548 00001007 488B05(11150000)            mov rax, [ball2_direction_x]    ; Cargar dirección X de la bola
  2549 0000100E 4901C0                      add r8, rax               ; Nueva posición X
  2550                                  
  2551                                      ; Calcular la dirección de memoria para la siguiente posición
  2552 00001011 4D89C2                      mov r10, r8  ; Guardar posición X actual
  2553 00001014 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2554 0000101B 4C89C9                      mov rcx, r9 ; Y
  2555 0000101E B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2556 00001023 48F7E9                      imul rcx    ; Multiplicar por Y
  2557 00001026 4901C2                      add r10, rax    ; Sumar X
  2558                                  
  2559                                      ; Verificar si hay una X en la siguiente posición X
  2560 00001029 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2561 0000102C 3C58                        cmp al, 'X'    ; Comparar con X
  2562 0000102E 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2563 00001030 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  2564 00001037 E928010000                  jmp .end    ; Salir
  2565                                  
  2566                                      .move_with_pallet:
  2567                                          ; Borrar la posición actual de la bola
  2568 0000103C 4C8B05(01150000)                mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2569 00001043 4C8B0D(09150000)                mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2570 0000104A 4D89C2                          mov r10, r8  ; Guardar posición X actual
  2571 0000104D 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2572 00001054 4C89C9                          mov rcx, r9 ; Y
  2573 00001057 B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2574 0000105C 48F7E9                          imul rcx    ; Multiplicar por Y
  2575 0000105F 4901C2                          add r10, rax    ; Sumar X
  2576 00001062 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2577                                  
  2578                                          ; Actualizar posición X basada en la paleta
  2579 00001066 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2580 0000106D 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2581 00001074 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2582 0000107B 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  2583                                  
  2584                                          ; Mantener la bola una posición arriba de la paleta
  2585 00001082 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  2586 00001089 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  2587                                  
  2588 00001090 E9CF000000                      jmp .end
  2589                                  
  2590                                  
  2591                                      .check_block_x:
  2592                                          ; Verificar colisión con bloques en X
  2593 00001095 4150                            push r8     ; Guardar registros que usa check_block_collision
  2594 00001097 4151                            push r9
  2595 00001099 4152                            push r10    ; Guardar registros que usa check_block_collision
  2596 0000109B E89E0A0000                      call check_block_collision      
  2597 000010A0 415A                            pop r10   ; Restaurar registros
  2598 000010A2 4159                            pop r9
  2599 000010A4 4158                            pop r8
  2600 000010A6 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2601 000010A9 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2602 000010AB 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  2603 000010B2 E9AD000000                      jmp .end
  2604                                  
  2605                                      .check_paddle_x:
  2606                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2607 000010B7 41803A3D                        cmp byte [r10], char_equal  
  2608 000010BB 750C                            jne .check_y_movement
  2609 000010BD 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  2610 000010C4 E99B000000                      jmp .end
  2611                                  
  2612                                      .check_y_movement:
  2613                                          ; Calcular siguiente posición Y
  2614 000010C9 488B05(19150000)                mov rax, [ball2_direction_y]
  2615 000010D0 4901C1                          add r9, rax                  ; Nueva posición Y
  2616                                  
  2617                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2618 000010D3 4D89C2                          mov r10, r8
  2619 000010D6 4981C2[400A0000]                add r10, board
  2620 000010DD 4C89C9                          mov rcx, r9
  2621 000010E0 B852000000                      mov rax, column_cells + 2
  2622 000010E5 48F7E9                          imul rcx
  2623 000010E8 4901C2                          add r10, rax
  2624                                  
  2625                                          ; Verificar si hay una X en la siguiente posición Y
  2626 000010EB 418A02                          mov al, [r10]
  2627 000010EE 3C58                            cmp al, 'X'     ; Comparar con X
  2628 000010F0 7509                            jne .check_block_y
  2629 000010F2 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  2630 000010F9 EB69                            jmp .end
  2631                                  
  2632                                      .check_block_y:
  2633                                          ; Verificar colisión con bloques en Y
  2634 000010FB 4150                            push r8     ; Guardar registros que usa check_block_collision
  2635 000010FD 4151                            push r9
  2636 000010FF 4152                            push r10
  2637 00001101 E8380A0000                      call check_block_collision
  2638 00001106 415A                            pop r10
  2639 00001108 4159                            pop r9
  2640 0000110A 4158                            pop r8
  2641 0000110C 4885C0                          test rax, rax
  2642 0000110F 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2643 00001111 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  2644 00001118 EB4A                            jmp .end
  2645                                  
  2646                                      .check_paddle_y:
  2647                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2648 0000111A 41803A3D                        cmp byte [r10], char_equal
  2649 0000111E 7536                            jne .update_position
  2650                                  
  2651                                          ; Verificar si el poder catch está activo
  2652 00001120 803D(FC220000)01                cmp byte [catch_power_active], 1
  2653 00001127 7524                            jne .normal_bounce
  2654                                  
  2655                                          ; Activar el modo "atrapado"
  2656 00001129 C605(FE220000)01                mov byte [ball_caught_2], 1
  2657                                          
  2658                                          ; Guardar la posición X actual de la bola como offset
  2659 00001130 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2660 00001137 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2661 0000113E 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2662 00001144 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2663                                          
  2664 0000114B EB17                            jmp .end
  2665                                  
  2666                                      .normal_bounce:
  2667 0000114D 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2668 00001154 EB0E                            jmp .end
  2669                                  
  2670                                  
  2671                                      .update_position:
  2672 00001156 4C8905(01150000)                mov [ball2_x_pos], r8
  2673 0000115D 4C890D(09150000)                mov [ball2_y_pos], r9
  2674                                  
  2675                                      .end:
  2676 00001164 C3                              ret
  2677                                  
  2678                                  move_ball_3:    ; Función para mover la tercera bola
  2679                                  
  2680 00001165 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2681 0000116C 0F849D000000                je .move_with_pallet
  2682                                  
  2683 00001172 803D(43150000)00            cmp byte [ball3_moving], 0
  2684 00001179 0F84B8010000                je .end
  2685                                  
  2686                                      ; Incrementar contador de velocidad
  2687 0000117F 48FF05(F3220000)            inc qword [speed_counter]
  2688                                      
  2689                                      ; Verificar si debemos mover la bola en este ciclo
  2690 00001186 488B05(F3220000)            mov rax, [speed_counter]
  2691 0000118D 483B05(E3220000)            cmp rax, [ball_speed]
  2692 00001194 0F8C9D010000                jl .end
  2693                                      
  2694                                      ; Resetear contador de velocidad
  2695 0000119A 48C705(F3220000)00-         mov qword [speed_counter], 0
  2695 000011A2 000000             
  2696                                  
  2697                                      ; Borrar la posición actual de la bola
  2698 000011A5 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2699 000011AC 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2700 000011B3 4981C0[400A0000]            add r8, board
  2701 000011BA 4C89C9                      mov rcx, r9
  2702 000011BD B852000000                  mov rax, column_cells + 2
  2703 000011C2 48F7E9                      imul rcx
  2704 000011C5 4901C0                      add r8, rax
  2705 000011C8 41C60020                    mov byte [r8], char_space
  2706                                  
  2707                                      ; Calcular siguiente posición X
  2708 000011CC 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2709 000011D3 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2710 000011DA 488B05(33150000)            mov rax, [ball3_direction_x]
  2711 000011E1 4901C0                      add r8, rax               ; Nueva posición X
  2712                                  
  2713                                      ; Calcular la dirección de memoria para la siguiente posición
  2714 000011E4 4D89C2                      mov r10, r8
  2715 000011E7 4981C2[400A0000]            add r10, board
  2716 000011EE 4C89C9                      mov rcx, r9
  2717 000011F1 B852000000                  mov rax, column_cells + 2
  2718 000011F6 48F7E9                      imul rcx
  2719 000011F9 4901C2                      add r10, rax
  2720                                  
  2721                                      ; Verificar si hay una X en la siguiente posición X
  2722 000011FC 418A02                      mov al, [r10]
  2723 000011FF 3C58                        cmp al, 'X'
  2724 00001201 7565                        jne .check_block_x
  2725 00001203 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2726 0000120A E928010000                  jmp .end
  2727                                  
  2728                                      .move_with_pallet:
  2729                                          ; Borrar la posición actual de la bola
  2730 0000120F 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2731 00001216 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2732 0000121D 4D89C2                          mov r10, r8
  2733 00001220 4981C2[400A0000]                add r10, board
  2734 00001227 4C89C9                          mov rcx, r9
  2735 0000122A B852000000                      mov rax, column_cells + 2
  2736 0000122F 48F7E9                          imul rcx
  2737 00001232 4901C2                          add r10, rax
  2738 00001235 41C60220                        mov byte [r10], char_space
  2739                                  
  2740                                          ; Actualizar posición X basada en la paleta
  2741 00001239 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2742 00001240 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2743 00001247 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2744 0000124E 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2745                                  
  2746                                          ; Mantener la bola una posición arriba de la paleta
  2747 00001255 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2748 0000125C 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2749                                  
  2750 00001263 E9CF000000                      jmp .end
  2751                                  
  2752                                  
  2753                                      .check_block_x:
  2754                                          ; Verificar colisión con bloques en X
  2755 00001268 4150                            push r8     ; Guardar registros que usa check_block_collision
  2756 0000126A 4151                            push r9
  2757 0000126C 4152                            push r10
  2758 0000126E E8CB080000                      call check_block_collision
  2759 00001273 415A                            pop r10
  2760 00001275 4159                            pop r9
  2761 00001277 4158                            pop r8
  2762 00001279 4885C0                          test rax, rax
  2763 0000127C 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2764 0000127E 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2765 00001285 E9AD000000                      jmp .end
  2766                                  
  2767                                      .check_paddle_x:
  2768                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2769 0000128A 41803A3D                        cmp byte [r10], char_equal
  2770 0000128E 750C                            jne .check_y_movement
  2771 00001290 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2772 00001297 E99B000000                      jmp .end
  2773                                  
  2774                                      .check_y_movement:
  2775                                          ; Calcular siguiente posición Y
  2776 0000129C 488B05(3B150000)                mov rax, [ball3_direction_y]
  2777 000012A3 4901C1                          add r9, rax                  ; Nueva posición Y
  2778                                  
  2779                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2780 000012A6 4D89C2                          mov r10, r8
  2781 000012A9 4981C2[400A0000]                add r10, board
  2782 000012B0 4C89C9                          mov rcx, r9
  2783 000012B3 B852000000                      mov rax, column_cells + 2
  2784 000012B8 48F7E9                          imul rcx
  2785 000012BB 4901C2                          add r10, rax
  2786                                  
  2787                                          ; Verificar si hay una X en la siguiente posición Y
  2788 000012BE 418A02                          mov al, [r10]
  2789 000012C1 3C58                            cmp al, 'X'
  2790 000012C3 7509                            jne .check_block_y
  2791 000012C5 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2792 000012CC EB69                            jmp .end
  2793                                  
  2794                                      .check_block_y:
  2795                                          ; Verificar colisión con bloques en Y
  2796 000012CE 4150                            push r8     ; Guardar registros que usa check_block_collision
  2797 000012D0 4151                            push r9
  2798 000012D2 4152                            push r10
  2799 000012D4 E865080000                      call check_block_collision
  2800 000012D9 415A                            pop r10
  2801 000012DB 4159                            pop r9
  2802 000012DD 4158                            pop r8
  2803 000012DF 4885C0                          test rax, rax
  2804 000012E2 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2805 000012E4 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2806 000012EB EB4A                            jmp .end
  2807                                  
  2808                                      .check_paddle_y:
  2809                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2810 000012ED 41803A3D                        cmp byte [r10], char_equal
  2811 000012F1 7536                            jne .update_position
  2812                                  
  2813                                          ; Verificar si el poder catch está activo
  2814 000012F3 803D(FC220000)01                cmp byte [catch_power_active], 1
  2815 000012FA 7524                            jne .normal_bounce
  2816                                  
  2817                                          ; Activar el modo "atrapado"
  2818 000012FC C605(FF220000)01                mov byte [ball_caught_3], 1
  2819                                          
  2820                                          ; Guardar la posición X actual de la bola como offset
  2821 00001303 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2822 0000130A 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2823 00001311 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2824 00001317 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2825                                          
  2826 0000131E EB17                            jmp .end
  2827                                  
  2828                                      .normal_bounce:
  2829 00001320 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2830 00001327 EB0E                            jmp .end
  2831                                  
  2832                                  
  2833                                      .update_position:
  2834 00001329 4C8905(23150000)                mov [ball3_x_pos], r8
  2835 00001330 4C890D(2B150000)                mov [ball3_y_pos], r9
  2836                                  
  2837                                      .end:
  2838 00001337 C3                              ret
  2839                                  
  2840                                  ; función para procesar la tecla C cuando la bola está atrapada
  2841                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2842                                  process_catch_release:
  2843 00001338 55                          push rbp
  2844 00001339 4889E5                      mov  rbp, rsp
  2845                                  
  2846                                      ; Verificar si el poder de catch está activo
  2847 0000133C 803D(FC220000)01            cmp byte [catch_power_active], 1
  2848 00001343 0F8531010000                jne .no_catch_power
  2849                                  
  2850                                      ; Verificar si se presionó 'c' (derecha y arriba)
  2851 00001349 803D(08230000)63            cmp byte [last_key], 'c'
  2852 00001350 7412                        je .release_right
  2853                                      
  2854                                      ; Verificar si se presionó 'x' (izquierda y arriba)
  2855 00001352 803D(08230000)78            cmp byte [last_key], 'x'
  2856 00001359 0F8487000000                je .release_left
  2857                                      
  2858 0000135F E916010000                  jmp .no_catch_power
  2859                                  
  2860                                  .release_right:
  2861                                      ; Liberar la bola hacia la derecha
  2862 00001364 803D(FD220000)01            cmp byte [ball_caught], 1
  2863 0000136B 7522                        jne .check_ball2_right
  2864 0000136D C605(FD220000)00            mov byte [ball_caught], 0
  2865 00001374 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Derecha
  2865 0000137C 000000             
  2866 0000137F 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2866 00001387 FFFFFF             
  2867 0000138A E9CD000000                  jmp .release_complete
  2868                                  
  2869                                  .check_ball2_right:
  2870 0000138F 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2871 00001396 7522                        jne .check_ball3_right
  2872 00001398 C605(FE220000)00            mov byte [ball_caught_2], 0
  2873 0000139F 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2873 000013A7 000000             
  2874 000013AA 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2874 000013B2 FFFFFF             
  2875 000013B5 E9A2000000                  jmp .release_complete
  2876                                  
  2877                                  .check_ball3_right:
  2878 000013BA 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2879 000013C1 0F8595000000                jne .release_complete
  2880 000013C7 C605(FF220000)00            mov byte [ball_caught_3], 0
  2881 000013CE 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2881 000013D6 000000             
  2882 000013D9 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2882 000013E1 FFFFFF             
  2883 000013E4 EB76                        jmp .release_complete
  2884                                  
  2885                                  .release_left:
  2886                                      ; Liberar la bola hacia la izquierda
  2887 000013E6 803D(FD220000)01            cmp byte [ball_caught], 1
  2888 000013ED 751F                        jne .check_ball2_left
  2889 000013EF C605(FD220000)00            mov byte [ball_caught], 0
  2890 000013F6 48C705(EF140000)FF-         mov qword [ball_direction_x], -1   ; Izquierda
  2890 000013FE FFFFFF             
  2891 00001401 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2891 00001409 FFFFFF             
  2892 0000140C EB4E                        jmp .release_complete
  2893                                  
  2894                                  .check_ball2_left:
  2895 0000140E 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2896 00001415 751F                        jne .check_ball3_left
  2897 00001417 C605(FE220000)00            mov byte [ball_caught_2], 0
  2898 0000141E 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  2898 00001426 FFFFFF             
  2899 00001429 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2899 00001431 FFFFFF             
  2900 00001434 EB26                        jmp .release_complete
  2901                                  
  2902                                  .check_ball3_left:
  2903 00001436 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2904 0000143D 751D                        jne .release_complete
  2905 0000143F C605(FF220000)00            mov byte [ball_caught_3], 0
  2906 00001446 48C705(33150000)FF-         mov qword [ball3_direction_x], -1
  2906 0000144E FFFFFF             
  2907 00001451 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2907 00001459 FFFFFF             
  2908                                  
  2909                                  .release_complete:
  2910                                      ; Si era el catch inicial, desactivarlo
  2911 0000145C 803D(FB220000)01            cmp byte [initial_catch_active], 1
  2912 00001463 750E                        jne .finish
  2913 00001465 C605(FB220000)00            mov byte [initial_catch_active], 0
  2914 0000146C C605(FC220000)00            mov byte [catch_power_active], 0  ; Desactivar poder de catch después de la 1ra vez
  2915                                  
  2916                                  .finish:
  2917 00001473 C605(08230000)00            mov byte [last_key], 0  ; Limpiar la tecla
  2918                                  .no_catch_power:
  2919 0000147A 5D                          pop rbp
  2920 0000147B C3                          ret
  2921                                  
  2922                                  
  2923                                  
  2924                                  display_level_number:   ; Función para mostrar el número del nivel
  2925 0000147C 55                          push rbp
  2926 0000147D 4889E5                      mov rbp, rsp
  2927                                      
  2928                                      ; Limpiar la pantalla primero
  2929                                      print clear, clear_length
    93 00001480 B801000000          <1>  mov eax, sys_write
    94 00001485 BF01000000          <1>  mov edi, 1
    95 0000148A 48BE-               <1>  mov rsi, %1
    95 0000148C [1000000000000000]  <1>
    96 00001494 BA07000000          <1>  mov edx, %2
    97 00001499 0F05                <1>  syscall
  2930                                      
  2931                                      ; Calcular la posición central para el mensaje
  2932                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2933 0000149B B850000000                  mov rax, column_cells
  2934 000014A0 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2935 000014A4 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2936                                      
  2937                                      ; Calcular la fila central
  2938 000014A7 BB20000000                  mov rbx, row_cells
  2939 000014AC 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2940                                      
  2941                                      ; Calcular el offset en el buffer
  2942 000014AF B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2943 000014B4 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2944 000014B7 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2945                                      
  2946                                      ; Escribir "NIVEL " en la posición calculada
  2947 000014BA 488DB8[400A0000]            lea rdi, [board + rax]
  2948 000014C1 48BE-                       mov rsi, level_msg       ; mensaje "NIVEL "
  2948 000014C3 [A414000000000000] 
  2949 000014CB B906000000                  mov rcx, level_msg_len  ; longitud del mensaje
  2950 000014D0 F3A4                        rep movsb
  2951                                      
  2952                                      ; Escribir el número del nivel
  2953 000014D2 8A05(79150000)              mov al, [current_level]
  2954 000014D8 0430                        add al, '0'                 ; convertir a ASCII
  2955 000014DA 8807                        mov [rdi], al
  2956                                      
  2957                                      ; Mostrar el board con el mensaje
  2958                                      print board, board_size
    93 000014DC B801000000          <1>  mov eax, sys_write
    94 000014E1 BF01000000          <1>  mov edi, 1
    95 000014E6 48BE-               <1>  mov rsi, %1
    95 000014E8 [400A000000000000]  <1>
    96 000014F0 BA400A0000          <1>  mov edx, %2
    97 000014F5 0F05                <1>  syscall
  2959                                      
  2960                                      ; Esperar un segundo
  2961 000014F7 B823000000                  mov rax, sys_nanosleep
  2962 000014FC 48BF-                       mov rdi, level_display_time
  2962 000014FE [AF14000000000000] 
  2963 00001506 4831F6                      xor rsi, rsi
  2964 00001509 0F05                        syscall
  2965                                      
  2966 0000150B 5D                          pop rbp
  2967 0000150C C3                          ret
  2968                                  
  2969                                  ; Función para inicializar un tablero vacío
  2970                                  init_empty_board:   ; Inicializar un tablero vacío
  2971 0000150D 56                          push rsi
  2972 0000150E 57                          push rdi
  2973 0000150F 51                          push rcx
  2974 00001510 50                          push rax
  2975                                  
  2976 00001511 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2977 00001518 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2978 0000151F B9400A0000                  mov rcx, board_template_size
  2979 00001524 F3A4                        rep movsb                   ; Copiar el tablero
  2980                                  
  2981 00001526 58                          pop rax
  2982 00001527 59                          pop rcx
  2983 00001528 5F                          pop rdi
  2984 00001529 5E                          pop rsi
  2985 0000152A C3                          ret
  2986                                  
  2987                                  clear_enemies_from_board:   ; Función para limpiar los enemigos del tablero
  2988 0000152B 55                          push rbp
  2989 0000152C 4889E5                      mov rbp, rsp
  2990 0000152F 56                          push rsi
  2991 00001530 57                          push rdi
  2992                                  
  2993                                      ; Primero limpiar board
  2994 00001531 B9400A0000                  mov rcx, board_size      
  2995 00001536 488D35(400A0000)            lea rsi, [board]         
  2996                                  
  2997                                  .clear_loop:
  2998 0000153D 4883F900                    cmp rcx, 0              
  2999 00001541 741F                        je .clear_template      ; En vez de terminar, vamos a limpiar template
  3000                                      
  3001 00001543 8A06                        mov al, [rsi]           
  3002 00001545 3C40                        cmp al, '@'             
  3003 00001547 740E                        je .make_space
  3004 00001549 3C23                        cmp al, '#'             
  3005 0000154B 740A                        je .make_space
  3006 0000154D 3C24                        cmp al, '$'             
  3007 0000154F 7406                        je .make_space
  3008 00001551 3C26                        cmp al, '&'             
  3009 00001553 7402                        je .make_space
  3010                                      
  3011 00001555 EB03                        jmp .next               
  3012                                  
  3013                                  .make_space:
  3014 00001557 C60620                      mov byte [rsi], ' '         ; Reemplazar enemigo con espacio
  3015                                  
  3016                                  .next:
  3017 0000155A 48FFC6                      inc rsi                 
  3018 0000155D 48FFC9                      dec rcx                
  3019 00001560 EBDB                        jmp .clear_loop        
  3020                                  
  3021                                  .clear_template:
  3022                                      ; Ahora limpiar board_template
  3023 00001562 B9400A0000                  mov rcx, board_template_size
  3024 00001567 488D35(00000000)            lea rsi, [board_template]   
  3025                                  
  3026                                  .template_loop: ; Bucle para limpiar la plantilla
  3027 0000156E 4883F900                    cmp rcx, 0
  3028 00001572 741F                        je .end
  3029                                      
  3030 00001574 8A06                        mov al, [rsi]
  3031 00001576 3C40                        cmp al, '@'
  3032 00001578 740E                        je .make_space_template
  3033 0000157A 3C23                        cmp al, '#'
  3034 0000157C 740A                        je .make_space_template
  3035 0000157E 3C24                        cmp al, '$'
  3036 00001580 7406                        je .make_space_template
  3037 00001582 3C26                        cmp al, '&'
  3038 00001584 7402                        je .make_space_template
  3039                                      
  3040 00001586 EB03                        jmp .next_template
  3041                                  
  3042                                  .make_space_template:
  3043 00001588 C60620                      mov byte [rsi], ' '
  3044                                  
  3045                                  .next_template:
  3046 0000158B 48FFC6                      inc rsi
  3047 0000158E 48FFC9                      dec rcx
  3048 00001591 EBDB                        jmp .template_loop
  3049                                  
  3050                                  .end:
  3051 00001593 5F                          pop rdi
  3052 00001594 5E                          pop rsi
  3053 00001595 5D                          pop rbp
  3054 00001596 C3                          ret
  3055                                  
  3056                                  
  3057                                  init_level:  ; Función para inicializar un nivel
  3058 00001597 E88FFFFFFF                  call clear_enemies_from_board
  3059 0000159C C605(22150000)00            mov byte [ball2_active], 0
  3060 000015A3 C605(44150000)00            mov byte [ball3_active], 0
  3061 000015AA C605(09230000)00            mov byte [laser_power_active], 0
  3062 000015B1 E898F2FFFF                  call clear_lasers
  3063 000015B6 488B05(CF140000)            mov rax, [default_pallet_size]
  3064 000015BD 488905(C7140000)            mov [pallet_size], rax
  3065 000015C4 48C705(E3220000)07-         mov qword [ball_speed], 7    ; Restaurar velocidad normal
  3065 000015CC 000000             
  3066                                  
  3067                                      ; 1) Copiamos board_template en board para que quede limpio
  3068                                          ; Reiniciar letras activas
  3069 000015CF 488D3D(3C210000)            lea rdi, [letters_map]
  3070 000015D6 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  3071 000015DB 4831C0                      xor rax, rax
  3072 000015DE F3AA                        rep stosb                    ; Llenar con ceros
  3073                                      
  3074                                      ; Inicializar dirección de la bola (derecha y arriba)
  3075 000015E0 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  3075 000015E8 000000             
  3076 000015EB 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  3076 000015F3 FFFFFF             
  3077                                  
  3078                                      ; En init_level, después de inicializar las direcciones
  3079 000015F6 C605(FC220000)01            mov byte [catch_power_active], 1    ; Activar el poder catch
  3080 000015FD C605(FD220000)01            mov byte [ball_caught], 1           ; Marcar la bola como atrapada
  3081 00001604 C605(FB220000)01            mov byte [initial_catch_active], 1  ; Marcar que es el catch inicial
  3082                                  
  3083                                      ; Calcular y guardar el offset inicial de la bola respecto a la paleta
  3084 0000160B 488B05(DF140000)            mov rax, [ball_x_pos]              ; Posición X actual de la bola
  3085 00001612 482B05(BF140000)            sub rax, [pallet_position]         ; Restar la posición de la paleta
  3086 00001619 4805[400A0000]              add rax, board                     ; Ajustar por el offset del tablero
  3087 0000161F 488905(00230000)            mov [ball_catch_offset], rax       ; Guardar el offset
  3088                                  
  3089                                  
  3090                                  
  3091                                      ; Reiniciar contador de letras activas
  3092 00001626 4831C0                      xor rax, rax
  3093 00001629 8805(CC220000)              mov [letters_count], al
  3094                                  
  3095                                      ; Reiniciar última letra capturada
  3096 0000162F C605(CD220000)20            mov byte [last_letter], ' '
  3097 00001636 C605(46200000)00            mov byte [destroyed_blocks], 0 
  3098 0000163D E8CBFEFFFF                  call init_empty_board
  3099 00001642 E835FEFFFF                  call display_level_number
  3100                                  
  3101 00001647 56                          push rsi
  3102 00001648 57                          push rdi
  3103 00001649 51                          push rcx
  3104 0000164A 50                          push rax
  3105                                  
  3106 0000164B 488D35(00000000)            lea rsi, [board_template]
  3107 00001652 488D3D(400A0000)            lea rdi, [board]
  3108 00001659 B9400A0000                  mov rcx, board_template_size
  3109 0000165E F3A4                        rep movsb                 ; Copiamos la plantilla a board
  3110                                  
  3111 00001660 58                          pop rax
  3112 00001661 59                          pop rcx
  3113 00001662 5F                          pop rdi
  3114 00001663 5E                          pop rsi
  3115                                  
  3116 00001664 B90A000000                  mov rcx, 10
  3117 00001669 4831C0                      xor rax, rax
  3118 0000166C 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3119 00001673 F3AA                        rep stosb   
  3120 00001675 E8ED050000                  call init_enemies   
  3121                                  
  3122                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  3123 0000167A 803D(79150000)01            cmp byte [current_level], 1
  3124 00001681 7431                        je .level1
  3125 00001683 803D(79150000)02            cmp byte [current_level], 2
  3126 0000168A 7454                        je .level2
  3127 0000168C 803D(79150000)03            cmp byte [current_level], 3
  3128 00001693 7477                        je .level3
  3129 00001695 803D(79150000)04            cmp byte [current_level], 4
  3130 0000169C 0F8492000000                je .level4
  3131 000016A2 803D(79150000)05            cmp byte [current_level], 5
  3132 000016A9 0F84B0000000                je .level5
  3133 000016AF E9D3000000                  jmp .done
  3134                                  
  3135                                  
  3136                                  
  3137                                      .level1:
  3138 000016B4 C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  3139 000016BB 4831C9                          xor rcx, rcx             
  3140                                          .init_loop1:    ; Bucle para inicializar los bloques del nivel 1
  3141 000016BE 4883F94E                            cmp rcx, level1_blocks_count
  3142 000016C2 0F8DBF000000                        jge .done   ; Si ya inicializamos todos los bloques, terminar
  3143 000016C8 4889C8                              mov rax, rcx              
  3144 000016CB 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3145 000016CF 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]       
  3146 000016D5 8891[761F0000]                      mov byte [block_states + rcx], dl
  3147 000016DB 48FFC1                              inc rcx        ; Incrementar contador
  3148 000016DE EBDE                                jmp .init_loop1
  3149                                  
  3150                                      .level2:
  3151 000016E0 C605(7A150000)5B                mov byte [blocks_remaining], level2_blocks_count    ; Inicializar el contador de bloques restantes
  3152 000016E7 4831C9                          xor rcx, rcx             
  3153                                          .init_loop2:
  3154 000016EA 4883F95B                            cmp rcx, level2_blocks_count
  3155 000016EE 0F8D93000000                        jge .done
  3156 000016F4 4889C8                              mov rax, rcx         
  3157 000016F7 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3158 000016FB 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  3159 00001701 8891[761F0000]                      mov byte [block_states + rcx], dl
  3160 00001707 48FFC1                              inc rcx
  3161 0000170A EBDE                                jmp .init_loop2
  3162                                      .level3:
  3163 0000170C C605(7A150000)40                mov byte [blocks_remaining], 64
  3164 00001713 4831C9                          xor rcx, rcx             
  3165                                          .init_loop3:
  3166 00001716 4883F968                            cmp rcx, level3_blocks_count
  3167 0000171A 7D6B                                jge .done
  3168 0000171C 4889C8                              mov rax, rcx         
  3169 0000171F 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3170 00001723 8A90[CB180000]                      mov dl, byte [level3_blocks + rax + 3]  
  3171 00001729 8891[761F0000]                      mov byte [block_states + rcx], dl
  3172 0000172F 48FFC1                              inc rcx
  3173 00001732 EBE2                                jmp .init_loop3
  3174                                  
  3175                                      .level4:
  3176 00001734 C605(7A150000)8C                mov byte [blocks_remaining], level4_blocks_count
  3177 0000173B 4831C9                          xor rcx, rcx             
  3178                                          .init_loop4:
  3179 0000173E 4881F98C000000                      cmp rcx, level4_blocks_count
  3180 00001745 7D40                                jge .done
  3181 00001747 4889C8                              mov rax, rcx         
  3182 0000174A 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3183 0000174E 8A90[D31A0000]                      mov dl, byte [level4_blocks + rax + 3]  
  3184 00001754 8891[761F0000]                      mov byte [block_states + rcx], dl
  3185 0000175A 48FFC1                              inc rcx
  3186 0000175D EBDF                                jmp .init_loop4
  3187                                  
  3188                                      .level5:
  3189 0000175F C605(7A150000)62                mov byte [blocks_remaining], level5_blocks_count
  3190 00001766 4831C9                          xor rcx, rcx             
  3191                                          .init_loop5:
  3192 00001769 4883F962                            cmp rcx, level5_blocks_count
  3193 0000176D 7D18                                jge .done
  3194 0000176F 4889C8                              mov rax, rcx         
  3195 00001772 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3196 00001776 8A90[8F1D0000]                      mov dl, byte [level5_blocks + rax + 3]  
  3197 0000177C 8891[761F0000]                      mov byte [block_states + rcx], dl
  3198 00001782 48FFC1                              inc rcx
  3199 00001785 EBE2                                jmp .init_loop5
  3200                                      .done:
  3201 00001787 C3                              ret
  3202                                  
  3203                                  
  3204                                  ; Función para verificar y manejar la transición de nivel
  3205                                  check_level_complete:   ; Verificar si el nivel está completo
  3206                                      ; Verificar si quedan bloques
  3207 00001788 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Si no quedan bloques
  3208 0000178F 7556                        jne .not_complete            ; No completado, continuar con el nivel actual
  3209                                      
  3210                                      ; Incrementar el nivel
  3211 00001791 FE05(79150000)              inc byte [current_level]    ; Incrementar el nivel
  3212                                      
  3213                                      ; Verificar si hemos completado todos los niveles
  3214 00001797 803D(79150000)06            cmp byte [current_level], 6 ; Si hemos completado todos los niveles
  3215 0000179E 7448                        je game_win               ; Ganar el juego
  3216                                      
  3217                                  
  3218 000017A0 E886FDFFFF                  call clear_enemies_from_board
  3219                                      ; Primero establecer las posiciones seguras
  3220 000017A5 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  3220 000017AC [B0130000]         
  3221 000017B0 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  3221 000017B8 000000             
  3222 000017BB 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  3222 000017C3 000000             
  3223 000017C6 C605(FF140000)00            mov byte [ball_moving], 0
  3224                                      
  3225                                      ; Asegurar que la bola esté en un estado seguro
  3226 000017CD C605(FC220000)01            mov byte [catch_power_active], 1
  3227 000017D4 C605(FD220000)01            mov byte [ball_caught], 1
  3228 000017DB C605(FB220000)01            mov byte [initial_catch_active], 1
  3229                                      
  3230                                      ; Reinicializar el juego para el siguiente nivel
  3231 000017E2 E8B0FDFFFF                  call init_level
  3232                                      
  3233                                  .not_complete:
  3234 000017E7 C3                          ret
  3235                                  
  3236                                      ; Nueva función para manejar la victoria del juego
  3237                                  game_win:
  3238 000017E8 55                          push rbp
  3239 000017E9 4889E5                      mov rbp, rsp
  3240                                      
  3241                                      ; Limpiar pantalla
  3242 000017EC 48BE-                       mov rsi, clear
  3242 000017EE [1000000000000000] 
  3243 000017F6 BA07000000                  mov rdx, clear_length
  3244 000017FB B801000000                  mov eax, sys_write
  3245 00001800 BF01000000                  mov edi, 1
  3246 00001805 0F05                        syscall
  3247                                      
  3248                                      ; Imprimir mensaje de Game Over
  3249 00001807 48BE-                       mov rsi, game_win_msg
  3249 00001809 [7E24000000000000] 
  3250 00001811 BA27000000                  mov rdx, game_win_len
  3251 00001816 B801000000                  mov eax, sys_write
  3252 0000181B BF01000000                  mov edi, 1
  3253 00001820 0F05                        syscall
  3254                                      
  3255                                      ; Convertir score a string
  3256 00001822 488B05(3E200000)            mov rax, [current_score]
  3257 00001829 48BF-                       mov rdi, number_buffer
  3257 0000182B [4720000000000000] 
  3258 00001833 E8AE010000                  call number_to_string
  3259                                      
  3260                                      ; Calcular longitud del número convertido
  3261 00001838 B900000000                  mov rcx, 0
  3262 0000183D 48BF-                       mov rdi, number_buffer
  3262 0000183F [4720000000000000] 
  3263                                  .count_loop:
  3264 00001847 803C0F00                    cmp byte [rdi + rcx], 0
  3265 0000184B 7405                        je .print_score
  3266 0000184D 48FFC1                      inc rcx
  3267 00001850 EBF5                        jmp .count_loop
  3268                                  
  3269                                  .print_score:
  3270                                      ; Imprimir el score
  3271 00001852 48BE-                       mov rsi, number_buffer
  3271 00001854 [4720000000000000] 
  3272 0000185C 4889CA                      mov rdx, rcx
  3273 0000185F B801000000                  mov eax, sys_write
  3274 00001864 BF01000000                  mov edi, 1
  3275 00001869 0F05                        syscall
  3276                                      
  3277                                      ; Imprimir nueva línea
  3278 0000186B 48BE-                       mov rsi, newline
  3278 0000186D [7D24000000000000] 
  3279 00001875 BA01000000                  mov rdx, newline_len
  3280 0000187A B801000000                  mov eax, sys_write
  3281 0000187F BF01000000                  mov edi, 1
  3282 00001884 0F05                        syscall
  3283                                      
  3284                                  .wait_q:
  3285                                      ; Esperar por la tecla 'q'
  3286 00001886 B800000000                  mov rax, sys_read
  3287 0000188B BF00000000                  mov rdi, STDIN_FILENO
  3288 00001890 48BE-                       mov rsi, input_char
  3288 00001892 [0000000000000000] 
  3289 0000189A BA01000000                  mov rdx, 1
  3290 0000189F 0F05                        syscall
  3291                                      
  3292 000018A1 803D(00000000)71            cmp byte [input_char], 'q'
  3293 000018A8 75DC                        jne .wait_q
  3294                                  
  3295 000018AA E9B50B0000                  jmp exit
  3296                                      
  3297 000018AF 5D                          pop rbp
  3298 000018B0 C3                          ret
  3299                                  
  3300                                  ; unción para obtener el puntero a los bloques del nivel actual
  3301                                  get_current_level_blocks:
  3302 000018B1 803D(79150000)01            cmp byte [current_level], 1
  3303 000018B8 7428                        je .level1
  3304 000018BA 803D(79150000)02            cmp byte [current_level], 2
  3305 000018C1 7427                        je .level2
  3306 000018C3 803D(79150000)03            cmp byte [current_level], 3
  3307 000018CA 7426                        je .level3
  3308 000018CC 803D(79150000)04            cmp byte [current_level], 4
  3309 000018D3 7425                        je .level4
  3310 000018D5 803D(79150000)05            cmp byte [current_level], 5
  3311 000018DC 7424                        je .level5
  3312                                      ; Si llegamos aquí, hay un error en el nivel
  3313 000018DE 4831C0                      xor rax, rax
  3314 000018E1 C3                          ret
  3315                                  
  3316                                      .level1:
  3317 000018E2 488D05(7B150000)                lea rax, [level1_blocks]
  3318 000018E9 C3                              ret
  3319                                      .level2:
  3320 000018EA 488D05(01170000)                lea rax, [level2_blocks]
  3321 000018F1 C3                              ret
  3322                                      .level3:
  3323 000018F2 488D05(C8180000)                lea rax, [level3_blocks]
  3324 000018F9 C3                              ret
  3325                                      .level4:
  3326 000018FA 488D05(D01A0000)                lea rax, [level4_blocks]
  3327 00001901 C3                              ret
  3328                                      .level5:
  3329 00001902 488D05(8C1D0000)                lea rax, [level5_blocks]
  3330 00001909 C3                              ret
  3331                                  ; Función para obtener la cantidad de bloques del nivel actual
  3332                                  get_current_level_count:
  3333 0000190A 803D(79150000)01            cmp byte [current_level], 1
  3334 00001911 7428                        je .level1
  3335 00001913 803D(79150000)02            cmp byte [current_level], 2
  3336 0000191A 7425                        je .level2
  3337 0000191C 803D(79150000)03            cmp byte [current_level], 3
  3338 00001923 7422                        je .level3
  3339 00001925 803D(79150000)04            cmp byte [current_level], 4
  3340 0000192C 741F                        je .level4
  3341 0000192E 803D(79150000)05            cmp byte [current_level], 5
  3342 00001935 741C                        je .level5
  3343                                      ; Si llegamos aquí, hay un error en el nivel
  3344 00001937 4831C0                      xor rax, rax
  3345 0000193A C3                          ret
  3346                                  
  3347                                      .level1:
  3348 0000193B B84E000000                      mov rax, level1_blocks_count
  3349 00001940 C3                              ret
  3350                                      .level2:
  3351 00001941 B85B000000                      mov rax, level2_blocks_count
  3352 00001946 C3                              ret
  3353                                      .level3:
  3354 00001947 B868000000                      mov rax, level3_blocks_count
  3355 0000194C C3                              ret
  3356                                      .level4:
  3357 0000194D B88C000000                      mov rax, level4_blocks_count
  3358 00001952 C3                              ret
  3359                                      .level5:
  3360 00001953 B862000000                      mov rax, level5_blocks_count
  3361 00001958 C3                              ret
  3362                                  
  3363                                  ; Función para imprimir los bloques del nivel actual
  3364                                  print_blocks:   ; Imprimir los bloques del nivel actual
  3365 00001959 55                          push rbp                  ; Guardar el puntero de la pila
  3366 0000195A 4889E5                      mov rbp, rsp          ; Establecer el puntero de la pila
  3367                                      
  3368                                      ; Obtener puntero a los bloques del nivel actual
  3369 0000195D E84FFFFFFF                  call get_current_level_blocks
  3370 00001962 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  3371                                      
  3372                                      ; Obtener cantidad de bloques del nivel actual
  3373 00001965 E8A0FFFFFF                  call get_current_level_count
  3374 0000196A 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  3375                                      
  3376 0000196D 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  3377                                      
  3378                                      .print_loop:              ; Bucle para imprimir los bloques
  3379 00001970 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  3380 00001973 7D6F                            jge .end              ; Si ya imprimimos todos los bloques, terminar
  3381                                          
  3382                                          ; Verificar si el bloque está activo
  3383 00001975 490FB68424-                     movzx rax, byte [block_states + r12]
  3383 0000197A [761F0000]         
  3384 0000197E 4885C0                          test rax, rax
  3385 00001981 745C                            jz .next_block
  3386                                          
  3387                                          ; Obtener posición y tipo del bloque usando r13
  3388 00001983 4C89E0                          mov rax, r12
  3389 00001986 486BC005                        imul rax, 5
  3390 0000198A 4C01E8                          add rax, r13
  3391 0000198D 448A00                          mov r8b, [rax]        ; X position
  3392 00001990 448A4801                        mov r9b, [rax + 1]    ; Y position
  3393 00001994 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  3394                                  
  3395                                          ; El resto de la lógica de impresión permanece igual
  3396 00001998 4D0FB6C0                        movzx r8, r8b
  3397 0000199C 4D0FB6C9                        movzx r9, r9b
  3398 000019A0 4981C0[400A0000]                add r8, board
  3399 000019A7 B852000000                      mov rax, column_cells + 2
  3400 000019AC 49F7E1                          mul r9
  3401 000019AF 4901C0                          add r8, rax
  3402                                          
  3403 000019B2 B906000000                      mov rcx, block_length
  3404 000019B7 48BE-                           mov rsi, block_type_1
  3404 000019B9 [5515000000000000] 
  3405 000019C1 490FB6C2                        movzx rax, r10b
  3406 000019C5 48FFC8                          dec rax
  3407 000019C8 486BC006                        imul rax, block_length
  3408 000019CC 4801C6                          add rsi, rax
  3409                                          
  3410                                      .print_block_chars:   ; Bucle para imprimir los caracteres del bloque
  3411 000019CF 8A06                            mov al, [rsi]   ; Obtener el carácter
  3412 000019D1 418800                          mov [r8], al    ; Escribir en el tablero
  3413 000019D4 48FFC6                          inc rsi        ; Siguiente carácter
  3414 000019D7 49FFC0                          inc r8          ; Siguiente posición
  3415 000019DA 48FFC9                          dec rcx        ; Decrementar contador
  3416 000019DD 75F0                            jnz .print_block_chars  ; Repetir si no hemos terminado
  3417                                          
  3418                                      .next_block:      ; Continuar con el siguiente bloque
  3419 000019DF 49FFC4                          inc r12         ; Incrementar el índice del bloque
  3420 000019E2 EB8C                            jmp .print_loop ; Repetir el bucle
  3421                                          
  3422                                      .end:
  3423 000019E4 5D                              pop rbp
  3424 000019E5 C3                              ret
  3425                                  
  3426                                  ; Función para convertir número a string
  3427                                  ; Input: RAX = número a convertir
  3428                                  ; RDI = buffer donde escribir el string
  3429                                  number_to_string:
  3430 000019E6 53                          push rbx
  3431 000019E7 52                          push rdx
  3432 000019E8 56                          push rsi
  3433 000019E9 BB0A000000                  mov rbx, 10          ; Divisor
  3434 000019EE B900000000                  mov rcx, 0          ; Contador de dígitos
  3435                                      
  3436                                      ; Si el número es 0, manejarlo especialmente
  3437 000019F3 4885C0                      test rax, rax
  3438 000019F6 7509                        jnz .convert_loop   ; Saltar si no es 0
  3439 000019F8 C60730                      mov byte [rdi], '0'
  3440 000019FB C6470100                    mov byte [rdi + 1], 0   ; Null terminator
  3441 000019FF EB20                        jmp .end
  3442                                      
  3443                                      .convert_loop:
  3444 00001A01 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  3445 00001A04 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  3446 00001A07 80C230                          add dl, '0'     ; Convertir a ASCII
  3447 00001A0A 52                              push rdx        ; Guardar el dígito
  3448 00001A0B 48FFC1                          inc rcx         ; Incrementar contador
  3449 00001A0E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  3450 00001A11 75EE                            jnz .convert_loop
  3451                                          
  3452                                      .write_loop:
  3453 00001A13 5A                              pop rdx         ; Obtener dígito
  3454 00001A14 8817                            mov [rdi], dl   ; Escribir al buffer
  3455 00001A16 48FFC7                          inc rdi         ; Siguiente posición
  3456 00001A19 48FFC9                          dec rcx         ; Decrementar contador
  3457 00001A1C 75F5                            jnz .write_loop
  3458                                          
  3459 00001A1E C60700                      mov byte [rdi], 0   ; Null terminator
  3460                                      
  3461                                      .end:
  3462 00001A21 5E                          pop rsi
  3463 00001A22 5A                          pop rdx
  3464 00001A23 5B                          pop rbx
  3465 00001A24 C3                          ret
  3466                                  
  3467                                  ; Función para imprimir los labels
  3468                                  print_labels:
  3469 00001A25 55                          push rbp
  3470 00001A26 4889E5                      mov rbp, rsp
  3471                                  
  3472                                      ; Crear buffer temporal
  3473 00001A29 4883EC20                    sub rsp, 32
  3474                                  
  3475                                      ; Copiar labels a buffer temporal
  3476 00001A2D 4889E7                      mov rdi, rsp
  3477 00001A30 488D35(F3200000)            lea rsi, [score_label]
  3478 00001A37 B917000000                  mov rcx, score_label_len
  3479 00001A3C F3A4                        rep movsb
  3480                                  
  3481                                      ; Convertir score a string
  3482 00001A3E 488B05(3E200000)            mov rax, [current_score]
  3483 00001A45 48BF-                       mov rdi, number_buffer
  3483 00001A47 [4720000000000000] 
  3484 00001A4F E892FFFFFF                  call number_to_string
  3485                                  
  3486                                      ; Calcular longitud del número
  3487 00001A54 B900000000                  mov rcx, 0
  3488 00001A59 48BF-                       mov rdi, number_buffer
  3488 00001A5B [4720000000000000] 
  3489                                      .count_loop:        ; Bucle para contar la longitud del número
  3490 00001A63 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3491 00001A67 7405                            je .count_done       ; Si es así, terminar
  3492 00001A69 48FFC1                          inc rcx             ; Incrementar contador
  3493 00001A6C EBF5                            jmp .count_loop    ; Repetir el bucle
  3494                                      .count_done:      ; Conteo terminado
  3495                                  
  3496                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3497 00001A6E 4889E7                      mov rdi, rsp      ; Inicializar RDI al buffer temporal
  3498 00001A71 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  3499 00001A75 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  3500 00001A7A 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  3501                                      .pad_loop:                 ; Bucle para añadir padding
  3502 00001A7D 4885F6                          test rsi, rsi       ; Verificar si terminamos
  3503 00001A80 740B                            jz .pad_done    ; Si es así, terminar
  3504 00001A82 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3505 00001A85 48FFC7                          inc rdi            ; Siguiente posición
  3506 00001A88 48FFCE                          dec rsi           ; Decrementar contador
  3507 00001A8B EBF0                            jmp .pad_loop   ; Repetir el bucle
  3508                                      .pad_done:    ; Padding añadido
  3509                                  
  3510                                      ; Copiar el número
  3511 00001A8D 48BE-                       mov rsi, number_buffer  ; Inicializar RSI al número
  3511 00001A8F [4720000000000000] 
  3512 00001A97 F3A4                        rep movsb            ; Copiar el número al buffer temporal
  3513                                  
  3514                                      ; Imprimir el buffer completo   
  3515                                      print rsp, score_label_len  ; Imprimir el buffer
    93 00001A99 B801000000          <1>  mov eax, sys_write
    94 00001A9E BF01000000          <1>  mov edi, 1
    95 00001AA3 4889E6              <1>  mov rsi, %1
    96 00001AA6 BA17000000          <1>  mov edx, %2
    97 00001AAB 0F05                <1>  syscall
  3516                                  
  3517                                      ; Repetir proceso para bloques destruidos   
  3518 00001AAD 4889E7                      mov rdi, rsp    ; Inicializar RDI al buffer temporal
  3519 00001AB0 488D35(0A210000)            lea rsi, [blocks_label] ; Inicializar RSI al label de bloques
  3520 00001AB7 B91B000000                  mov rcx, blocks_label_len   ; Longitud del label
  3521 00001ABC F3A4                        rep movsb   ; Copiar el label al buffer temporal
  3522                                  
  3523                                      ; Verificar que el `[` esté en su posición correcta
  3524 00001ABE 4889E7                      mov rdi, rsp
  3525 00001AC1 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  3526 00001AC5 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  3527                                  
  3528                                      ; Convertir bloques destruidos a string
  3529 00001AC8 480FB605(46200000)          movzx rax, byte [destroyed_blocks]  ; Obtener el número de bloques destruidos
  3530 00001AD0 48BF-                       mov rdi, number_buffer      ; Convertir a string
  3530 00001AD2 [4720000000000000] 
  3531 00001ADA E807FFFFFF                  call number_to_string   ; Convertir a string
  3532                                  
  3533                                      ; Calcular longitud del número
  3534 00001ADF B900000000                  mov rcx, 0
  3535 00001AE4 48BF-                       mov rdi, number_buffer  ; Inicializar RDI al número
  3535 00001AE6 [4720000000000000] 
  3536                                      .count_loop2:     ; Bucle para contar la longitud del número
  3537 00001AEE 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3538 00001AF2 7405                            je .count_done2   ; Si es así, terminar
  3539 00001AF4 48FFC1                          inc rcx          ; Incrementar contador
  3540 00001AF7 EBF5                            jmp .count_loop2    ; Repetir el bucle
  3541                                      .count_done2:   ; Conteo terminado
  3542                                  
  3543                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3544 00001AF9 4889E7                      mov rdi, rsp
  3545 00001AFC 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  3546 00001B00 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  3547 00001B05 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  3548                                      .pad_loop2:
  3549 00001B08 4885F6                          test rsi, rsi    ; Verificar si terminamos
  3550 00001B0B 740B                            jz .pad_done2   ; Si es así, terminar
  3551 00001B0D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3552 00001B10 48FFC7                          inc rdi
  3553 00001B13 48FFCE                          dec rsi
  3554 00001B16 EBF0                            jmp .pad_loop2  ; Repetir el bucle
  3555                                      .pad_done2:
  3556                                  
  3557                                      ; Copiar el número
  3558 00001B18 48BE-                       mov rsi, number_buffer
  3558 00001B1A [4720000000000000] 
  3559 00001B22 F3A4                        rep movsb
  3560                                  
  3561                                      ; Imprimir el buffer completo
  3562                                      print rsp, blocks_label_len
    93 00001B24 B801000000          <1>  mov eax, sys_write
    94 00001B29 BF01000000          <1>  mov edi, 1
    95 00001B2E 4889E6              <1>  mov rsi, %1
    96 00001B31 BA1B000000          <1>  mov edx, %2
    97 00001B36 0F05                <1>  syscall
  3563                                  
  3564                                      ; Restaurar stack
  3565 00001B38 4883C420                    add rsp, 32     
  3566 00001B3C 5D                          pop rbp
  3567 00001B3D C3                          ret
  3568                                  
  3569                                  
  3570                                  
  3571                                  check_block_collision:  ; Función para verificar colisión con bloques
  3572 00001B3E 55                          push rbp              ; Guardar el puntero de la pila
  3573 00001B3F 4889E5                      mov rbp, rsp      ; Establecer el puntero de la pila
  3574                                  
  3575                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  3576 00001B42 418A02                      mov al, [r10]
  3577                                  
  3578                                      ; Verificar si el carácter es un bloque
  3579 00001B45 3C55                        cmp al, 'U'  
  3580 00001B47 7419                        je .possible
  3581 00001B49 3C4F                        cmp al, 'O'  
  3582 00001B4B 7415                        je .possible
  3583 00001B4D 3C44                        cmp al, 'D'  
  3584 00001B4F 7411                        je .possible
  3585 00001B51 3C4C                        cmp al, 'L'  
  3586 00001B53 740D                        je .possible
  3587 00001B55 3C56                        cmp al, 'V'  
  3588 00001B57 7409                        je .possible
  3589 00001B59 3C38                        cmp al, '8'  
  3590 00001B5B 7405                        je .possible
  3591                                  
  3592                                      ; No es bloque, salir
  3593 00001B5D 4831C0                      xor rax, rax
  3594 00001B60 5D                          pop rbp
  3595 00001B61 C3                          ret
  3596                                  
  3597                                  .possible:
  3598 00001B62 53                          push rbx
  3599 00001B63 57                          push rdi
  3600 00001B64 56                          push rsi
  3601 00001B65 4154                        push r12
  3602 00001B67 4155                        push r13
  3603 00001B69 4156                        push r14
  3604 00001B6B 4157                        push r15
  3605                                  
  3606                                      ; 1) Obtener base de los bloques del nivel actual
  3607 00001B6D E83FFDFFFF                  call get_current_level_blocks
  3608 00001B72 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  3609                                  
  3610                                      ; 2) Obtener la cantidad de bloques
  3611 00001B75 E890FDFFFF                  call get_current_level_count
  3612 00001B7A 4989C6                      mov r14, rax
  3613                                  
  3614 00001B7D 4D31E4                      xor r12, r12  ; Índice del bloque actual
  3615                                  
  3616                                  .find_block_loop:
  3617 00001B80 4D39F4                      cmp r12, r14
  3618 00001B83 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  3619                                  
  3620                                      ; Calcular puntero base del bloque actual en levelX_blocks
  3621 00001B89 4C89E0                      mov rax, r12
  3622 00001B8C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  3623 00001B90 4C01E8                      add rax, r13
  3624 00001B93 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  3625                                  
  3626                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  3627 00001B96 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  3627 00001B9B [761F0000]         
  3628 00001B9F 4885DB                      test rbx, rbx
  3629 00001BA2 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  3630                                  
  3631                                      ; Obtener coordenadas
  3632 00001BA8 418A17                      mov dl, [r15]         ; x
  3633 00001BAB 418A4F01                    mov cl, [r15 + 1]     ; y
  3634                                  
  3635                                      ; Calcular posición en el board
  3636 00001BAF 488D3D(400A0000)            lea rdi, [board]
  3637 00001BB6 4831C0                      xor rax, rax
  3638 00001BB9 B850000000                  mov rax, column_cells
  3639 00001BBE 4883C002                    add rax, 2
  3640 00001BC2 480FB6C9                    movzx rcx, cl         ; y
  3641 00001BC6 480FAFC1                    imul rax, rcx
  3642 00001BCA 4801C7                      add rdi, rax
  3643 00001BCD 480FB6C2                    movzx rax, dl         ; x
  3644 00001BD1 4801C7                      add rdi, rax
  3645                                  
  3646                                      ; Guardar la posición base del bloque
  3647 00001BD4 57                          push rdi
  3648                                  
  3649                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  3650 00001BD5 4939FA                      cmp r10, rdi
  3651 00001BD8 7274                        jb .skip_collision
  3652 00001BDA 488D5F06                    lea rbx, [rdi + block_length]
  3653 00001BDE 4939DA                      cmp r10, rbx
  3654 00001BE1 736B                        jae .skip_collision
  3655                                  
  3656                                      ; ------- Hay colisión, reducir durabilidad en block_states
  3657 00001BE3 41FE8C24[761F0000]          dec byte [block_states + r12]
  3658                                      ; Volver a cargar durabilidad
  3659 00001BEB 490FB69C24-                 movzx rbx, byte [block_states + r12]
  3659 00001BF0 [761F0000]         
  3660 00001BF4 4885DB                      test rbx, rbx
  3661 00001BF7 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  3662                                  
  3663                                      ; >>> Llegó a 0 => Bloque destruido
  3664 00001BF9 5F                          pop rdi  ; recuperar puntero base del bloque en board
  3665 00001BFA B906000000                  mov rcx, block_length
  3666                                  .clear_loop:
  3667 00001BFF C60720                      mov byte [rdi], ' '
  3668 00001C02 48FFC7                      inc rdi
  3669 00001C05 E2F8                        loop .clear_loop
  3670                                  
  3671                                      ; Dibujar letra del bloque destruido
  3672 00001C07 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  3673 00001C0B 4883EF06                    sub rdi, block_length
  3674 00001C0F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  3675                                      ; Después de escribir la letra en el tablero
  3676 00001C11 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  3677 00001C15 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  3678 00001C19 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  3679 00001C1E E8BBE8FFFF                  call register_letter
  3680                                      ; Actualizar contadores globales
  3681 00001C23 FE0D(7A150000)              dec byte [blocks_remaining]
  3682 00001C29 FE05(46200000)              inc byte [destroyed_blocks]
  3683                                  
  3684                                      ; Sumar puntos según el tipo
  3685 00001C2F 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  3686 00001C34 486BC00A                    imul rax, 10
  3687 00001C38 480105(3E200000)            add [current_score], rax
  3688                                  
  3689 00001C3F B801000000                  mov rax, 1  ; colisión con destrucción
  3690 00001C44 EB14                        jmp .end_pop
  3691                                  
  3692                                  .update_display:
  3693                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  3694 00001C46 B801000000                  mov rax, 1  ; colisión con "rebote"  
  3695 00001C4B 5F                          pop rdi     ; pop que quedó pendiente
  3696 00001C4C EB0C                        jmp .end_pop
  3697                                  
  3698                                  .skip_collision:
  3699 00001C4E 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  3700                                  .next_block:
  3701 00001C4F 49FFC4                      inc r12
  3702 00001C52 E929FFFFFF                  jmp .find_block_loop
  3703                                  
  3704                                  .no_block_found:
  3705 00001C57 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  3706                                  
  3707                                  .end_pop:
  3708 00001C5A 415F                        pop r15
  3709 00001C5C 415E                        pop r14
  3710 00001C5E 415D                        pop r13
  3711 00001C60 415C                        pop r12
  3712 00001C62 5E                          pop rsi
  3713 00001C63 5F                          pop rdi
  3714 00001C64 5B                          pop rbx
  3715 00001C65 5D                          pop rbp
  3716 00001C66 C3                          ret
  3717                                  
  3718                                  
  3719                                  
  3720                                  init_enemies:   ; Función para inicializar los enemigos
  3721 00001C67 55                          push rbp    
  3722 00001C68 4889E5                      mov rbp, rsp
  3723                                      
  3724                                      ; Reiniciar contadores de movimiento
  3725 00001C6B C605(89200000)00            mov byte [enemy_move_total], 0
  3726 00001C72 C605(8A200000)00            mov byte [enemy_target], 0
  3727                                      
  3728                                      ; Limpiar completamente el array de enemigos
  3729 00001C79 B91E000000                  mov rcx, 30  ; 10 enemigos * 3 bytes cada uno
  3730 00001C7E 488D3D(60200000)            lea rdi, [enemies]
  3731 00001C85 30C0                        xor al, al
  3732 00001C87 F3AA                        rep stosb    ; Llenar todo con ceros
  3733                                      
  3734                                      ; Marcar todos los spawns como no activados
  3735 00001C89 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3736 00001C90 B90A000000                  mov rcx, 10 ; 10 spawns
  3737 00001C95 F3AA                        rep stosb   ; Llenar con ceros
  3738                                      
  3739 00001C97 5D                          pop rbp
  3740 00001C98 C3                          ret
  3741                                  
  3742                                  
  3743                                  random_move_enemy:  ; Función para mover un enemigo aleatoriamente
  3744 00001C99 55                          push rbp        ; Guardar el puntero de la pila
  3745 00001C9A 4889E5                      mov  rbp, rsp
  3746 00001C9D 53                          push rbx
  3747 00001C9E 52                          push rdx
  3748 00001C9F 57                          push rdi
  3749                                  
  3750                                      ; r12 = índice del enemigo
  3751                                      ; 1) obtener puntero al enemigo i
  3752 00001CA0 4C89E0                      mov rax, r12
  3753 00001CA3 486BC003                    imul rax, 3                ; Cada enemigo ocupa 3 bytes
  3754 00001CA7 488D98[60200000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  3755                                  
  3756                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  3757 00001CAE 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  3758 00001CB2 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  3759                                  
  3760                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  3761 00001CB7 480FB605(87200000)          movzx rax, byte [enemy_move_counter]
  3762 00001CBF 4883E003                    and rax, 3  ; rax = [enemy_move_counter] & 3
  3763                                  
  3764 00001CC3 4883F800                    cmp rax, 0  ; si es 0 => mover abajo
  3765 00001CC7 741B                        je .try_left    ; si es 1 => mover izquierda
  3766 00001CC9 4883F801                    cmp rax, 1  ; si es 1 => mover izquierda
  3767 00001CCD 7410                        je .try_right   ; si es 2 => mover derecha
  3768 00001CCF 4883F802                    cmp rax, 2  ; si es 2 => mover derecha
  3769 00001CD3 7405                        je .try_up
  3770                                      ; si es 3 => mover abajo
  3771                                  .try_down:
  3772 00001CD5 49FFC1                      inc r9  ; mover abajo
  3773 00001CD8 EB0D                        jmp .check_valid    ; saltar a la verificación de validez
  3774                                  
  3775                                  .try_up:    ; mover arriba
  3776 00001CDA 49FFC9                      dec r9  ; mover arriba
  3777 00001CDD EB08                        jmp .check_valid    ; saltar a la verificación de validez
  3778                                  
  3779                                  .try_right:   ; mover derecha
  3780 00001CDF 49FFC0                      inc r8  ; mover derecha
  3781 00001CE2 EB03                        jmp .check_valid
  3782                                  
  3783                                  .try_left:
  3784 00001CE4 49FFC8                      dec r8
  3785                                  
  3786                                  .check_valid:
  3787                                      ; 4) Verificar límites
  3788 00001CE7 4983F801                    cmp r8, 1                    
  3789 00001CEB 0F8EA4000000                jle .invalid_move
  3790 00001CF1 4983F850                    cmp r8, column_cells        
  3791 00001CF5 0F8D9A000000                jge .invalid_move
  3792 00001CFB 4983F901                    cmp r9, 1                    
  3793 00001CFF 0F8E90000000                jle .invalid_move
  3794 00001D05 4983F920                    cmp r9, row_cells          
  3795 00001D09 0F8D86000000                jge .invalid_move
  3796                                  
  3797                                      ; 5) Verificar colisión con bloques/enemigos
  3798 00001D0F 4150                        push r8
  3799 00001D11 4151                        push r9
  3800 00001D13 B850000000                  mov rax, column_cells       ; rax = column_cells
  3801 00001D18 4883C002                    add rax, 2                ; rax = column_cells + 2
  3802 00001D1C 49F7E1                      mul r9                  ; rax = (column_cells + 2) * r9
  3803 00001D1F 4C01C0                      add rax, r8             ; rax = (column_cells + 2) * r9 + r8
  3804 00001D22 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * r9 + r8]
  3805 00001D29 8A07                        mov al, [rdi]        ; al = board[(column_cells + 2) * r9 + r8]
  3806                                  
  3807                                      ; Revisa si es bloque o borde
  3808 00001D2B 3C55                        cmp al, 'U'
  3809 00001D2D 7462                        je .pop_and_invalid
  3810 00001D2F 3C4F                        cmp al, 'O'
  3811 00001D31 745E                        je .pop_and_invalid
  3812 00001D33 3C44                        cmp al, 'D'
  3813 00001D35 745A                        je .pop_and_invalid
  3814 00001D37 3C4C                        cmp al, 'L'
  3815 00001D39 7456                        je .pop_and_invalid
  3816 00001D3B 3C56                        cmp al, 'V'
  3817 00001D3D 7452                        je .pop_and_invalid
  3818 00001D3F 3C38                        cmp al, '8'
  3819 00001D41 744E                        je .pop_and_invalid
  3820 00001D43 3C58                        cmp al, 'X'
  3821 00001D45 744A                        je .pop_and_invalid
  3822                                  
  3823                                      ; Revisa si hay enemigo
  3824 00001D47 3C40                        cmp al, '@'
  3825 00001D49 7446                        je .pop_and_invalid
  3826 00001D4B 3C23                        cmp al, '#'
  3827 00001D4D 7442                        je .pop_and_invalid
  3828 00001D4F 3C24                        cmp al, '$'
  3829 00001D51 743E                        je .pop_and_invalid
  3830 00001D53 3C26                        cmp al, '&'
  3831 00001D55 743A                        je .pop_and_invalid
  3832                                  
  3833 00001D57 E808030000                  call check_enemy_at_position
  3834 00001D5C 4883F801                    cmp rax, 1
  3835 00001D60 742F                        je .pop_and_invalid
  3836                                  
  3837                                      ; ------------------------------
  3838                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3839                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3840                                      ; ------------------------------
  3841 00001D62 4159                        pop r9
  3842 00001D64 4158                        pop r8
  3843                                  
  3844                                      ; (A) Borrar la posición antigua en el board
  3845                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3846 00001D66 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3847 00001D6A 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3848 00001D6F B850000000                  mov rax, column_cells
  3849 00001D74 4883C002                    add rax, 2              ; rax = column_cells + 2
  3850 00001D78 49F7E3                      mul r11                ; rax = (column_cells + 2) * oldY
  3851 00001D7B 4C01D0                      add rax, r10
  3852 00001D7E 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * oldY + oldX]
  3853 00001D85 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3854                                  
  3855                                      ; (B) Guardar la nueva X,Y en la estructura
  3856 00001D88 448803                      mov byte [rbx], r8b
  3857 00001D8B 44884B01                    mov byte [rbx + 1], r9b
  3858                                  
  3859 00001D8F EB0D                        jmp .done
  3860                                  
  3861                                  .pop_and_invalid:
  3862 00001D91 4159                        pop r9
  3863 00001D93 4158                        pop r8
  3864                                  
  3865                                  .invalid_move:
  3866                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3867 00001D95 4C0FB603                    movzx r8, byte [rbx]
  3868 00001D99 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3869                                      ; Se queda donde estaba
  3870                                  .done:
  3871 00001D9E 5F                          pop rdi
  3872 00001D9F 5A                          pop rdx
  3873 00001DA0 5B                          pop rbx
  3874 00001DA1 5D                          pop rbp
  3875 00001DA2 C3                          ret
  3876                                  
  3877                                  
  3878                                  ; Función para mover enemigos
  3879                                  move_enemies:   ; Mover enemigos
  3880 00001DA3 55                          push rbp    ; Guardar el puntero de la pila
  3881 00001DA4 4889E5                      mov rbp, rsp    ; Establecer el puntero de la pila
  3882                                      
  3883                                      ; Incrementar contador de movimiento
  3884 00001DA7 FE05(87200000)              inc byte [enemy_move_counter]   ; Incrementar el contador de movimiento
  3885 00001DAD 480FB605(87200000)          movzx rax, byte [enemy_move_counter]    ; rax = enemy_move_counter
  3886 00001DB5 3A05(88200000)              cmp al, [enemy_move_delay]  ; Verificar si es hora de mover
  3887 00001DBB 0F85A1020000                jne .end
  3888                                      
  3889                                      ; Resetear contador
  3890 00001DC1 C605(87200000)00            mov byte [enemy_move_counter], 0
  3891                                      
  3892 00001DC8 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3893                                      
  3894                                      .enemy_loop:
  3895 00001DCB 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3896 00001DCF 0F8D8D020000                    jge .end                    ; Si ya movimos todos los enemigos, terminar
  3897                                          
  3898                                          ; Calcular offset del enemigo actual
  3899 00001DD5 4C89E0                          mov rax, r12                ; rax = r12
  3900 00001DD8 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3901 00001DDC 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[r12]
  3902                                          
  3903                                          ; Verificar si el enemigo está activo
  3904 00001DE3 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si el enemigo está activo
  3905 00001DE7 0F856D020000                    jne .next_enemy        ; Si no está activo, pasar al siguiente enemigo
  3906                                          
  3907                                          ; Obtener posición actual
  3908 00001DED 4C0FB606                        movzx r8, byte [rsi]            ; X
  3909 00001DF1 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3910                                          
  3911 00001DF6 488D3D(40240000)                lea rdi, [enemy_last_x]        ; rdi = &enemy_last_x
  3912 00001DFD 4C01E7                          add rdi, r12            ; rdi = &enemy_last_x[r12]
  3913 00001E00 8A07                            mov al, [rdi]             ; al = last_x
  3914                                  
  3915 00001E02 488D15(4A240000)                lea rdx, [enemy_last_y]       ; rdx = &enemy_last_y
  3916 00001E09 4C01E2                          add rdx, r12        ; rdx = &enemy_last_y[r12]
  3917 00001E0C 8A22                            mov ah, [rdx]             ; ah = last_y
  3918                                  
  3919                                          ; r8 = X actual del enemigo
  3920                                          ; r9 = Y actual del enemigo
  3921                                  
  3922                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3923 00001E0E 88E2                            mov dl, ah      ; dl = old_Y
  3924 00001E10 4488CB                          mov bl, r9b     ; bl = new_Y
  3925 00001E13 38DA                            cmp dl, bl    ; Comparar Y
  3926 00001E15 752C                            jne .not_stuck      ; Si son diferentes, no está pegado
  3927                                  
  3928                                          ; => SI son iguales => pasa al siguiente check
  3929 00001E17 88C2                            mov dl, al      ; dl = old_X
  3930 00001E19 4488C3                          mov bl, r8b     ; bl = new_X
  3931 00001E1C 38DA                            cmp dl, bl  ; Comparar X
  3932 00001E1E 7523                            jne .not_stuck    ; Si son diferentes, no está pegado
  3933                                  
  3934                                          ; => MISMA POSICIÓN (STUCK)
  3935 00001E20 488D1D(54240000)                lea rbx, [enemy_stuck_count]    ; rbx = &enemy_stuck_count
  3936 00001E27 4C01E3                          add rbx, r12        ; rbx = &enemy_stuck_count[r12]
  3937 00001E2A FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3938                                  
  3939                                          ; Verificar si supera umbral, digamos 3
  3940 00001E2C 480FB60B                        movzx rcx, byte [rbx]    ; rcx = stuck_count
  3941 00001E30 4883F902                        cmp rcx, 2      ; Si llega a 3, forzar movimiento aleatorio
  3942 00001E34 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3943                                  
  3944                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3945                                          ;  1) resetear el stuck_count
  3946 00001E36 C60300                          mov byte [rbx], 0
  3947                                  
  3948                                          ;  2) cambiar random
  3949 00001E39 E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3950 00001E3E E917020000                      jmp .next_enemy 
  3951                                  
  3952                                      .not_stuck:
  3953                                          ; => Se movió
  3954 00001E43 488D1D(54240000)                lea rbx, [enemy_stuck_count]
  3955 00001E4A 4C01E3                          add rbx, r12    ; rbx = &enemy_stuck_count[r12]
  3956 00001E4D C60300                          mov byte [rbx], 0            ; Resetear
  3957                                  
  3958                                          ; Guardar su nueva posición en “last_x, last_y”
  3959 00001E50 488D3D(40240000)                lea rdi, [enemy_last_x]
  3960 00001E57 4C01E7                          add rdi, r12    ; rdi = &enemy_last_x[r12]
  3961 00001E5A 448807                          mov [rdi], r8b      ; Guardar X
  3962                                          
  3963 00001E5D 488D3D(4A240000)                lea rdi, [enemy_last_y]
  3964 00001E64 4C01E7                          add rdi, r12
  3965 00001E67 44880F                          mov [rdi], r9b
  3966                                  
  3967                                          ; Limpiar posición actual antes de mover
  3968                                      .check_normal_move:
  3969 00001E6A 4150                            push r8
  3970 00001E6C 4151                            push r9
  3971 00001E6E B850000000                      mov rax, column_cells    ; rax = column_cells
  3972 00001E73 4883C002                        add rax, 2            ; rax = column_cells + 2
  3973 00001E77 49F7E1                          mul r9            ; rax = (column_cells + 2) * Y
  3974 00001E7A 4C01C0                          add rax, r8       ; rax = (column_cells + 2) * Y + X
  3975 00001E7D 488DB8[400A0000]                lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  3976 00001E84 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3977 00001E87 4159                            pop r9          ; Recuperar Y
  3978 00001E89 4158                            pop r8      ; Restaurar X, Y
  3979                                  
  3980                                          ; Determinar comportamiento basado en índice
  3981 00001E8B 4C89E0                          mov rax, r12
  3982 00001E8E 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3983 00001E92 4885C0                          test rax, rax
  3984 00001E95 7405                            jz .chase_ball
  3985 00001E97 E996000000                      jmp .chase_paddle             ; Si es 1, perseguir paleta
  3986                                          
  3987                                          ; Perseguir bola (comportamiento original)
  3988                                      .chase_ball:
  3989                                          ; Primero intentar con la bola principal
  3990 00001E9C 803D(00150000)01                cmp byte [ball_active], 1
  3991 00001EA3 7414                            je .use_ball1
  3992                                          
  3993                                          ; Si no está activa, probar con ball2
  3994 00001EA5 803D(22150000)01                cmp byte [ball2_active], 1
  3995 00001EAC 7414                            je .use_ball2
  3996                                          
  3997                                          ; Si no está activa, probar con ball3
  3998 00001EAE 803D(44150000)01                cmp byte [ball3_active], 1
  3999 00001EB5 7414                            je .use_ball3
  4000                                          
  4001                                          ; Si no hay bolas activas, perseguir la paleta
  4002 00001EB7 EB79                            jmp .chase_paddle
  4003                                  
  4004                                      .use_ball1:
  4005 00001EB9 4C8B15(DF140000)                mov r10, [ball_x_pos]   ; r10 = ball_x_pos
  4006 00001EC0 EB12                            jmp .compare_positions
  4007                                  
  4008                                      .use_ball2:         
  4009 00001EC2 4C8B15(01150000)                mov r10, [ball2_x_pos]
  4010 00001EC9 EB09                            jmp .compare_positions
  4011                                  
  4012                                      .use_ball3:
  4013 00001ECB 4C8B15(23150000)                mov r10, [ball3_x_pos]
  4014 00001ED2 EB00                            jmp .compare_positions
  4015                                  
  4016                                      .compare_positions:
  4017                                          ; Comparar X
  4018 00001ED4 4D39D0                          cmp r8, r10
  4019 00001ED7 0F8FCA000000                    jg .move_left
  4020 00001EDD 0F8CC9000000                    jl .move_right
  4021                                          
  4022                                          ; Si llegamos aquí, las X son iguales
  4023                                          ; Ahora comparar Y según qué bola estemos siguiendo
  4024 00001EE3 803D(00150000)01                cmp byte [ball_active], 1
  4025 00001EEA 7417                            je .check_ball1_y
  4026 00001EEC 803D(22150000)01                cmp byte [ball2_active], 1
  4027 00001EF3 7417                            je .check_ball2_y
  4028 00001EF5 803D(44150000)01                cmp byte [ball3_active], 1
  4029 00001EFC 7417                            je .check_ball3_y
  4030 00001EFE E9D4000000                      jmp .check_collision
  4031                                  
  4032                                      .check_ball1_y:
  4033 00001F03 4C8B15(E7140000)                mov r10, [ball_y_pos]
  4034 00001F0A EB12                            jmp .compare_y
  4035                                  
  4036                                      .check_ball2_y:
  4037 00001F0C 4C8B15(09150000)                mov r10, [ball2_y_pos]
  4038 00001F13 EB09                            jmp .compare_y
  4039                                  
  4040                                      .check_ball3_y:
  4041 00001F15 4C8B15(2B150000)                mov r10, [ball3_y_pos]
  4042 00001F1C EB00                            jmp .compare_y
  4043                                  
  4044                                      .compare_y:
  4045 00001F1E 4D39D1                          cmp r9, r10
  4046 00001F21 0F8F8A000000                    jg .move_up
  4047 00001F27 0F8C89000000                    jl .move_down
  4048 00001F2D E9A5000000                      jmp .check_collision
  4049                                          
  4050                                      .chase_paddle:
  4051                                          ; Obtener la posición X actual de la paleta
  4052 00001F32 4C8B15(BF140000)                mov r10, [pallet_position]
  4053 00001F39 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  4054                                          
  4055                                          ; Calcular la posición X real de la paleta
  4056 00001F40 4C89D0                          mov rax, r10
  4057 00001F43 BB50000000                      mov rbx, column_cells
  4058 00001F48 4883C302                        add rbx, 2                  ; Añadir newline chars
  4059 00001F4C 4831D2                          xor rdx, rdx
  4060 00001F4F 48F7F3                          div rbx                     ; rax = y, rdx = x
  4061                                          
  4062                                          ; rdx ahora contiene la posición X de la paleta
  4063                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  4064 00001F52 488B0D(C7140000)                mov rcx, [pallet_size]
  4065 00001F59 48D1E9                          shr rcx, 1                  ; Dividir por 2
  4066 00001F5C 4801CA                          add rdx, rcx
  4067                                          
  4068                                          ; Comparar con posición X del enemigo y mover gradualmente
  4069 00001F5F 4939D0                          cmp r8, rdx
  4070 00001F62 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  4071 00001F64 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  4072 00001F66 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  4073                                  
  4074                                      .check_y_paddle:
  4075                                          ; La Y de la paleta siempre es row_cells - 2
  4076 00001F68 41BA20000000                    mov r10, row_cells
  4077 00001F6E 4983EA02                        sub r10, 2
  4078                                          
  4079                                          ; Comparar con posición Y del enemigo y mover gradualmente
  4080 00001F72 4D39D1                          cmp r9, r10
  4081 00001F75 7404                            je .no_movement            ; Si está en la misma Y, no mover
  4082 00001F77 7F38                            jg .move_up               ; Si está abajo, mover arriba
  4083 00001F79 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  4084                                          
  4085                                      .no_movement:
  4086 00001F7B EB5A                            jmp .check_collision
  4087                                  
  4088                                      ; También agregar una nueva sección para el movimiento suave
  4089                                      .smooth_transition:
  4090                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  4091 00001F7D 8A05(8A200000)                  mov al, [enemy_target]
  4092 00001F83 84C0                            test al, al
  4093 00001F85 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  4094                                          
  4095                                          ; Verificar distancia en X
  4096 00001F87 4989D2                          mov r10, rdx              ; Posición X objetivo
  4097 00001F8A 4D29C2                          sub r10, r8               ; Calcular diferencia
  4098 00001F8D 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  4099 00001F91 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  4100 00001F93 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  4101 00001F97 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  4102 00001F99 EB3C                            jmp .check_collision
  4103                                          
  4104                                      .limit_right_movement:
  4105 00001F9B 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  4106 00001F9F EB36                            jmp .check_collision
  4107                                          
  4108                                      .limit_left_movement:
  4109 00001FA1 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  4110 00001FA5 EB30                            jmp .check_collision
  4111                                      .move_left:
  4112 00001FA7 49FFC8                          dec r8
  4113 00001FAA EB0F                            jmp .check_vertical
  4114                                          
  4115                                      .move_right:
  4116 00001FAC 49FFC0                          inc r8
  4117 00001FAF EB0A                            jmp .check_vertical
  4118                                          
  4119                                      .move_up:
  4120 00001FB1 49FFC9                          dec r9
  4121 00001FB4 EB21                            jmp .check_collision
  4122                                          
  4123                                      .move_down:
  4124 00001FB6 49FFC1                          inc r9
  4125 00001FB9 EB1C                            jmp .check_collision
  4126                                          
  4127                                      .check_vertical:
  4128 00001FBB 8A05(8A200000)                  mov al, [enemy_target]
  4129 00001FC1 84C0                            test al, al
  4130 00001FC3 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  4131 00001FC9 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  4132 00001FD0 4D39D1                          cmp r9, r10
  4133 00001FD3 7FDC                            jg .move_up
  4134 00001FD5 7CDF                            jl .move_down
  4135                                          
  4136                                      .check_collision:
  4137                                          ; Verificar colisión con bordes
  4138 00001FD7 4983F801                        cmp r8, 1                       ; Borde izquierdo
  4139 00001FDB 7E7D                            jle .next_enemy
  4140 00001FDD 4983F850                        cmp r8, column_cells
  4141 00001FE1 7D77                            jge .next_enemy
  4142 00001FE3 4983F901                        cmp r9, 1                       ; Borde superior
  4143 00001FE7 7E71                            jle .next_enemy
  4144 00001FE9 4983F920                        cmp r9, row_cells
  4145 00001FED 7D6B                            jge .next_enemy
  4146                                          
  4147                                          ; Verificar colisión con bloques antes de moverse
  4148 00001FEF 4150                            push r8
  4149 00001FF1 4151                            push r9
  4150 00001FF3 4152                            push r10
  4151                                          
  4152                                          ; Calcular posición en el tablero para verificar
  4153 00001FF5 B850000000                      mov rax, column_cells
  4154 00001FFA 4883C002                        add rax, 2
  4155 00001FFE 49F7E1                          mul r9
  4156 00002001 4C01C0                          add rax, r8
  4157 00002004 4C8D90[400A0000]                lea r10, [board + rax]
  4158                                          
  4159                                          ; Verificar si hay un bloque en la nueva posición
  4160 0000200B 418A02                          mov al, [r10]
  4161 0000200E 3C55                            cmp al, 'U'
  4162 00002010 7442                            je .invalid_move
  4163 00002012 3C4F                            cmp al, 'O'
  4164 00002014 743E                            je .invalid_move
  4165 00002016 3C44                            cmp al, 'D'
  4166 00002018 743A                            je .invalid_move
  4167 0000201A 3C4C                            cmp al, 'L'
  4168 0000201C 7436                            je .invalid_move
  4169 0000201E 3C56                            cmp al, 'V'
  4170 00002020 7432                            je .invalid_move
  4171 00002022 3C38                            cmp al, '8'
  4172 00002024 742E                            je .invalid_move
  4173 00002026 3C58                            cmp al, 'X'
  4174 00002028 742A                            je .invalid_move
  4175 0000202A 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  4176 0000202C 7426                            je .invalid_move
  4177 0000202E 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  4178 00002030 7422                            je .invalid_move
  4179 00002032 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  4180 00002034 741E                            je .invalid_move
  4181 00002036 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  4182 00002038 741A                            je .invalid_move
  4183                                          
  4184 0000203A E825000000                      call check_enemy_at_position
  4185 0000203F 4883F801                        cmp rax, 1
  4186 00002043 740F                            je .invalid_move
  4187 00002045 415A                            pop r10
  4188 00002047 4159                            pop r9
  4189 00002049 4158                            pop r8
  4190                                          
  4191                                          ; Guardar nueva posición si es válida
  4192 0000204B 448806                          mov [rsi], r8b
  4193 0000204E 44884E01                        mov [rsi + 1], r9b
  4194 00002052 EB06                            jmp .next_enemy
  4195                                          
  4196                                      .invalid_move:
  4197 00002054 415A                            pop r10
  4198 00002056 4159                            pop r9
  4199 00002058 4158                            pop r8
  4200                                          
  4201                                      .next_enemy:
  4202 0000205A 49FFC4                          inc r12
  4203 0000205D E969FDFFFF                      jmp .enemy_loop
  4204                                          
  4205                                      .end:
  4206 00002062 5D                              pop rbp
  4207 00002063 C3                              ret
  4208                                  
  4209                                  check_enemy_at_position:    ; Función para verificar si hay un enemigo en una posición
  4210 00002064 55                          push rbp
  4211 00002065 4889E5                      mov rbp, rsp
  4212                                      
  4213                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  4214 00002068 B850000000                  mov rax, column_cells
  4215 0000206D 4883C002                    add rax, 2
  4216 00002071 49F7E1                      mul r9                ; rax = (column_cells + 2) * Y
  4217 00002074 4C01C0                      add rax, r8   ; rax = (column_cells + 2) * Y + X
  4218 00002077 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  4219 0000207E 480FB607                    movzx rax, byte [rdi]   ; rax = board[(column_cells + 2) * Y + X]
  4220                                      
  4221                                      ; Verificar todos los caracteres de enemigos
  4222 00002082 3C40                        cmp al, '@'
  4223 00002084 7411                        je .enemy_found
  4224 00002086 3C23                        cmp al, '#'
  4225 00002088 740D                        je .enemy_found
  4226 0000208A 3C24                        cmp al, '$'
  4227 0000208C 7409                        je .enemy_found
  4228 0000208E 3C26                        cmp al, '&'
  4229 00002090 7405                        je .enemy_found
  4230                                      
  4231 00002092 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  4232 00002095 EB05                        jmp .end
  4233                                      
  4234                                  .enemy_found:
  4235 00002097 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  4236                                      
  4237                                  .end:
  4238 0000209C 5D                          pop rbp
  4239 0000209D C3                          ret
  4240                                  
  4241                                  get_current_spawn_points:   ; Función para obtener los puntos de spawn del nivel actual
  4242 0000209E 55                          push rbp
  4243 0000209F 4889E5                      mov rbp, rsp
  4244                                      
  4245 000020A2 480FB605(79150000)          movzx rax, byte [current_level] ; Obtener nivel actual
  4246 000020AA 48FFC8                      dec rax                         ; Ajustar para índice base 0
  4247 000020AD 488B04C5[BE200000]          mov rax, [spawn_points_table + rax * 8] ; Obtener puntero a puntos de spawn
  4248                                      
  4249 000020B5 5D                          pop rbp
  4250 000020B6 C3                          ret
  4251                                  
  4252                                  ; Función para verificar si debe aparecer un nuevo enemigo
  4253                                  check_enemy_spawn:  ; Verificar si debe aparecer un nuevo enemigo
  4254 000020B7 55                          push rbp                ; Guardar el puntero de la pila
  4255 000020B8 4889E5                      mov rbp, rsp        ; Establecer el puntero de la pila
  4256                                      
  4257                                      ; Obtener spawn points del nivel actual
  4258 000020BB E8DEFFFFFF                  call get_current_spawn_points
  4259 000020C0 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  4260                                      
  4261                                      ; Obtener cantidad de bloques destruidos
  4262 000020C3 4C0FB62D(46200000)          movzx r13, byte [destroyed_blocks]
  4263                                      
  4264                                      ; Verificar cada punto de spawn
  4265 000020CB 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  4266                                      
  4267                                      .check_loop:
  4268 000020CE 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  4269 000020D2 7D4E                            jge .end
  4270                                          
  4271                                          ; Verificar si este spawn point ya fue usado
  4272 000020D4 80B9[E9200000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  4273 000020DB 7440                            je .next_enemy
  4274                                          
  4275                                          ; Verificar si este enemigo ya está activo
  4276 000020DD 4889C8                          mov rax, rcx
  4277 000020E0 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4278 000020E4 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[rcx]
  4279 000020EB 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  4280 000020EF 742C                            je .next_enemy
  4281                                          
  4282                                          ; Verificar si debemos spawnear este enemigo
  4283 000020F1 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  4284 000020F6 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  4285 000020F9 7522                            jne .next_enemy               ; Si no coincide, pasar al siguiente
  4286                                          
  4287                                          ; Marcar este spawn point como usado
  4288 000020FB C681[E9200000]01                mov byte [enemy_spawns_triggered + rcx], 1  ; Marcar como usado
  4289                                  
  4290                                          ; Spawner nuevo enemigo
  4291 00002102 B004                            mov al, 4                   ; Nivel de X
  4292 00002104 00C8                            add al, cl       ; con 'rcx' como índice
  4293 00002106 8806                            mov [rsi], al            ; X
  4294 00002108 C6460101                        mov byte [rsi+1], 1    ; Y
  4295 0000210C C6460201                        mov byte [rsi+2], 1   ; Activar enemigo
  4296                                  
  4297                                          ; Inicializar comportamiento
  4298 00002110 4889C8                          mov rax, rcx            ; rax = rcx
  4299 00002113 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  4300 00002117 8805(E8200000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  4301                                          
  4302                                      .next_enemy:
  4303 0000211D 48FFC1                          inc rcx
  4304 00002120 EBAC                            jmp .check_loop
  4305                                          
  4306                                      .end:
  4307 00002122 5D                              pop rbp
  4308 00002123 C3                              ret
  4309                                  
  4310                                  
  4311                                  ; Función para dibujar enemigos
  4312                                  print_enemies:
  4313 00002124 55                          push rbp
  4314 00002125 4889E5                      mov rbp, rsp
  4315                                      
  4316 00002128 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4317                                      
  4318                                      .print_loop:
  4319 0000212B 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  4320 0000212F 7D4B                            jge .end
  4321                                          
  4322                                          ; Calcular offset del enemigo actual
  4323 00002131 4C89E0                          mov rax, r12
  4324 00002134 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4325 00002138 488DB0[60200000]                lea rsi, [enemies + rax]
  4326                                          
  4327                                          ; Verificar si el enemigo está activo
  4328 0000213F 807E0201                        cmp byte [rsi + 2], 1
  4329 00002143 7532                            jne .next_enemy
  4330                                          
  4331                                          ; Calcular posición en el tablero
  4332 00002145 4C0FB606                        movzx r8, byte [rsi]            ; X
  4333 00002149 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  4334                                          
  4335                                          ; Calcular offset en el tablero
  4336 0000214E B850000000                      mov rax, column_cells
  4337 00002153 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  4338 00002157 49F7E1                          mul r9                        ; rax = (column_cells + 2) * Y
  4339 0000215A 4C01C0                          add rax, r8                    ; rax = (column_cells + 2) * Y + X
  4340 0000215D 488DB8[400A0000]                lea rdi, [board + rax]
  4341                                          
  4342                                          ; Obtener carácter del enemigo según el nivel
  4343 00002164 480FB605(79150000)              movzx rax, byte [current_level]
  4344 0000216C 48FFC8                          dec rax                         ; Ajustar para índice base 0
  4345 0000216F 8A80[5B200000]                  mov al, [enemy_chars + rax]
  4346                                          
  4347                                          ; Dibujar enemigo
  4348 00002175 8807                            mov [rdi], al
  4349                                          
  4350                                      .next_enemy:
  4351 00002177 49FFC4                          inc r12
  4352 0000217A EBAF                            jmp .print_loop
  4353                                          
  4354                                      .end:
  4355 0000217C 5D                              pop rbp
  4356 0000217D C3                              ret
  4357                                  
  4358                                  ; Función para verificar colisión con enemigos
  4359                                  check_enemy_collision:  ; Verificar colisión con enemigos
  4360 0000217E 55                          push rbp
  4361 0000217F 4889E5                      mov rbp, rsp
  4362                                      
  4363 00002182 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4364 00002185 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  4365                                      
  4366                                      .check_loop:
  4367 00002188 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  4368 0000218C 0F8DE9000000                    jge .end
  4369                                          
  4370                                          ; Calcular offset del enemigo actual
  4371 00002192 4C89E1                          mov rcx, r12
  4372 00002195 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  4373 00002199 488DB1[60200000]                lea rsi, [enemies + rcx]
  4374                                          
  4375                                          ; Verificar si el enemigo está activo
  4376 000021A0 807E0201                        cmp byte [rsi + 2], 1
  4377 000021A4 0F85C9000000                    jne .next_enemy
  4378                                          
  4379                                          ; Verificar colisión con la bola
  4380 000021AA 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  4381 000021AE 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  4382                                          
  4383                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  4384 000021B3 4C8B15(DF140000)                mov r10, [ball_x_pos]
  4385 000021BA 4C8B1D(E7140000)                mov r11, [ball_y_pos]        ; Posición de la bola
  4386                                          
  4387                                          ; Comprobar colisión vertical (misma columna)
  4388 000021C1 4D39C2                          cmp r10, r8
  4389 000021C4 7525                            jne .check_horizontal     ; Si no está en la misma columna, verificar horizontal
  4390 000021C6 4D29CB                          sub r11, r9         ; Calcular diferencia de Y
  4391 000021C9 4983FB01                        cmp r11, 1              ; Si la bola está justo arriba del enemigo
  4392 000021CD 7F1C                            jg .check_horizontal    ; Si está más arriba, verificar horizontal
  4393 000021CF 4983FBFF                        cmp r11, -1
  4394 000021D3 7C16                            jl .check_horizontal    ; Si está más abajo, verificar horizontal
  4395                                          
  4396                                          ; Colisión vertical detectada   
  4397 000021D5 E8A3000000                      call destroy_enemy      ; Destruir el enemigo
  4398 000021DA 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  4399 000021E1 B801000000                      mov rax, 1
  4400 000021E6 E990000000                      jmp .end
  4401                                          
  4402                                      .check_horizontal:      
  4403                                          ; Comprobar colisión horizontal (misma fila)
  4404 000021EB 4C8B15(DF140000)                mov r10, [ball_x_pos]     ; Posición de la bola
  4405 000021F2 4C8B1D(E7140000)                mov r11, [ball_y_pos]   ; Posición de la bola
  4406 000021F9 4D39CB                          cmp r11, r9            ; Comparar Y de la bola con Y del enemigo
  4407 000021FC 7522                            jne .check_paddle   ; Si no están en la misma fila, verificar con la paleta
  4408 000021FE 4D29C2                          sub r10, r8        ; Calcular diferencia de X
  4409 00002201 4983FA01                        cmp r10, 1        ; Si la bola está justo a la izquierda del enemigo
  4410 00002205 7F19                            jg .check_paddle    ; Si está más a la izquierda, verificar con la paleta
  4411 00002207 4983FAFF                        cmp r10, -1      ; Si la bola está justo a la derecha del enemigo
  4412 0000220B 7C13                            jl .check_paddle    ; Si está más a la derecha, verificar con la paleta
  4413                                          
  4414                                          ; Colisión horizontal detectada
  4415 0000220D E86B000000                      call destroy_enemy    ; Destruir el enemigo
  4416 00002212 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  4417 00002219 B801000000                      mov rax, 1          ; Indicar que hubo colisión
  4418 0000221E EB5B                            jmp .end        ; Terminar
  4419                                  
  4420                                      .check_paddle:
  4421                                          ; Verificar colisión con la paleta
  4422 00002220 4C8B15(BF140000)                mov r10, [pallet_position]  ; Posición de la paleta
  4423 00002227 4981EA[400A0000]                sub r10, board            ; Convertir a offset relativo
  4424 0000222E 4C89D0                          mov rax, r10          ; rax = r10
  4425 00002231 41BB50000000                    mov r11, column_cells   ; r11 = column_cells
  4426 00002237 4983C302                        add r11, 2          ; r11 = column_cells + 2
  4427 0000223B 4831D2                          xor rdx, rdx    ; rdx = 0
  4428 0000223E 49F7F3                          div r11                     ; División para obtener la posición Y
  4429 00002241 4989D3                          mov r11, rdx               ; X de la paleta en r11
  4430                                          
  4431 00002244 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  4432                                          
  4433                                          ; Verificar si el enemigo está en la misma fila que la paleta
  4434 0000224B 41BD20000000                    mov r13, row_cells
  4435 00002251 4983ED02                        sub r13, 2                 ; Y de la paleta
  4436 00002255 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  4437 00002258 7519                            jne .next_enemy
  4438                                          
  4439                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  4440 0000225A 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  4441 0000225D 7C14                            jl .next_enemy
  4442                                          
  4443 0000225F 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  4444 00002262 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  4445 00002265 7F0C                            jg .next_enemy
  4446                                          
  4447                                          ; Si llegamos aquí, hay colisión con la paleta
  4448 00002267 E811000000                      call destroy_enemy        ; Destruir el enemigo
  4449 0000226C B801000000                      mov rax, 1                ; Indicar que hubo colisión
  4450 00002271 EB08                            jmp .end
  4451                                          
  4452                                      .next_enemy:
  4453 00002273 49FFC4                          inc r12
  4454 00002276 E90DFFFFFF                      jmp .check_loop   ; Verificar el siguiente enemigo
  4455                                          
  4456                                      .end:
  4457 0000227B 5D                              pop rbp
  4458 0000227C C3                              ret
  4459                                  
  4460                                  ; Función para destruir un enemigo
  4461                                  destroy_enemy:
  4462                                      ; Desactivar enemigo
  4463 0000227D C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  4464                                  
  4465                                      ; Sumar puntos por destruir enemigo
  4466 00002281 488B05(7F200000)            mov rax, [enemy_points]
  4467 00002288 480105(3E200000)            add [current_score], rax
  4468                                  
  4469                                      ; No tocar bloques destruidos aquí
  4470 0000228F C3                          ret
  4471                                  
  4472                                  
  4473                                  _start:   
  4474 00002290 E896DEFFFF              	call canonical_off  ; Desactivar modo canónico
  4475 00002295 E857010000              	call start_screen   ; Mostrar pantalla de inicio
  4476 0000229A E8F8F2FFFF                  call init_level    ; Inicializar el nivel
  4477 0000229F EB00                    	jmp .main_loop    ; Saltar al bucle principal
  4478                                  	
  4479                                  
  4480                                      .main_loop:     ; Bucle principal
  4481 000022A1 E87FF7FFFF                      call print_labels   ; Imprimir etiquetas
  4482 000022A6 E8AEF6FFFF                      call print_blocks   ; Imprimir bloques
  4483 000022AB E846E0FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  4484 000022B0 E828DFFFFF                      call print_lives
  4485 000022B5 E8F5E2FFFF                      call move_letters   ; Mover letras
  4486 000022BA E8DBE5FFFF                      call update_lasers          ; Actualizar láseres
  4487 000022BF E860E2FFFF                      call print_letters  ; Imprimir letras
  4488 000022C4 E8DFE9FFFF                      call print_pallet   ; Imprimir paleta
  4489                                          
  4490                                          ; Mover bola principal solo si está activa
  4491 000022C9 803D(00150000)01                cmp byte [ball_active], 1
  4492 000022D0 7505                            jne .skip_ball1
  4493 000022D2 E8E8EAFFFF                          call move_ball
  4494                                          .skip_ball1:
  4495                                  
  4496                                          ; Mover bola 2 si está activa
  4497 000022D7 803D(22150000)01                cmp byte [ball2_active], 1
  4498 000022DE 7505                            jne .skip_ball2
  4499 000022E0 E8ADECFFFF                          call move_ball_2
  4500                                          .skip_ball2:
  4501                                  
  4502                                          ; Mover bola 3 si está activa
  4503 000022E5 803D(44150000)01                cmp byte [ball3_active], 1
  4504 000022EC 7505                            jne .skip_ball3
  4505 000022EE E872EEFFFF                          call move_ball_3
  4506                                          .skip_ball3:
  4507                                  
  4508                                  
  4509                                  
  4510                                          ; Imprimir solo las bolas activas
  4511 000022F3 803D(00150000)01                cmp byte [ball_active], 1
  4512 000022FA 7505                            jne .no_pb1
  4513 000022FC E82FE9FFFF                          call print_ball
  4514                                          .no_pb1:
  4515                                  
  4516 00002301 803D(22150000)01                cmp byte [ball2_active], 1
  4517 00002308 7505                            jne .no_pb2
  4518 0000230A E849E9FFFF                          call print_ball_2
  4519                                          .no_pb2:
  4520                                  
  4521 0000230F 803D(44150000)01                cmp byte [ball3_active], 1
  4522 00002316 7505                            jne .no_pb3
  4523 00002318 E863E9FFFF                          call print_ball_3
  4524                                          .no_pb3:
  4525                                  
  4526 0000231D E866F4FFFF                      call check_level_complete
  4527 00002322 E890FDFFFF                      call check_enemy_spawn
  4528 00002327 E877FAFFFF                      call move_enemies
  4529 0000232C E84DFEFFFF                      call check_enemy_collision
  4530 00002331 E8EEFDFFFF                      call print_enemies
  4531 00002336 E8D3E4FFFF                      call print_power_label
  4532                                  		print board, board_size				
    93 0000233B B801000000          <1>  mov eax, sys_write
    94 00002340 BF01000000          <1>  mov edi, 1
    95 00002345 48BE-               <1>  mov rsi, %1
    95 00002347 [400A000000000000]  <1>
    96 0000234F BA400A0000          <1>  mov edx, %2
    97 00002354 0F05                <1>  syscall
  4533                                  		;setnonblocking	
  4534                                  	.read_more:	    
  4535                                  	    getchar	    ; Leer una tecla
   101 00002356 B800000000          <1>  mov rax, sys_read
   102 0000235B BF00000000          <1>  mov rdi, STDIN_FILENO
   103 00002360 48BE-               <1>  mov rsi, input_char
   103 00002362 [0000000000000000]  <1>
   104 0000236A BA01000000          <1>  mov rdx, 1
   105 0000236F 0F05                <1>  syscall
  4536 00002371 4883F801                	    cmp rax, 1  ; Verificar si se presionó una tecla
  4537 00002375 7547                    	    jne .done   ; Si no se presionó ninguna tecla, terminar
  4538                                  	
  4539 00002377 8A05(00000000)          	    mov al, [input_char]
  4540 0000237D 8805(08230000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  4541                                  	
  4542 00002383 3C61                    	    cmp al, 'a'            ; Verificar si se presionó la tecla 'a'
  4543 00002385 750E                    	    jne .not_left       ; Si no se presionó, verificar si se presionó 'd'
  4544 00002387 48C7C7FFFFFFFF          	    mov rdi, left_direction    ; Si sí, mover la paleta a la izquierda
  4545 0000238E E84AE9FFFF              	    call move_pallet    ; Mover la paleta
  4546 00002393 EB29                    	    jmp .done        ; Terminar
  4547                                  	
  4548                                      .not_left:  
  4549 00002395 3C64                    	    cmp al, 'd'           ; Verificar si se presionó la tecla 'd'
  4550 00002397 750C                    	    jne .not_right    ; Si no se presionó, verificar si se presionó 'c'
  4551 00002399 BF01000000              	    mov rdi, right_direction    ; Si sí, mover la paleta a la derecha
  4552 0000239E E83AE9FFFF              	    call move_pallet    ; Mover la paleta
  4553 000023A3 EB19                    	    jmp .done     ; Terminar
  4554                                  	
  4555                                      .not_right:
  4556 000023A5 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  4557 000023A7 740E                    	    je .release_ball        ; Si sí, liberar la bola
  4558                                  	
  4559 000023A9 3C78                            cmp al, 'x'             ; Verificar si se presionó la tecla 'c'
  4560 000023AB 740A                    	    je .release_ball        ; Si sí, liberar la bola
  4561                                  	
  4562                                  
  4563 000023AD 3C71                    	    cmp al, 'q' 
  4564 000023AF 0F84AF000000            	    je exit
  4565 000023B5 EB9F                    	    jmp .read_more
  4566                                  	
  4567                                      .release_ball:
  4568 000023B7 E87CEFFFFF              	    call process_catch_release
  4569 000023BC EB00                    	    jmp .done
  4570                                  	
  4571                                      .done:
  4572                                  	    sleeptime
   109 000023BE B823000000          <1>  mov eax, sys_nanosleep
   110 000023C3 48BF-               <1>  mov rdi, timespec
   110 000023C5 [0000000000000000]  <1>
   111 000023CD 31F6                <1>  xor esi, esi
   112 000023CF 0F05                <1>  syscall
  4573                                  	    print clear, clear_length
    93 000023D1 B801000000          <1>  mov eax, sys_write
    94 000023D6 BF01000000          <1>  mov edi, 1
    95 000023DB 48BE-               <1>  mov rsi, %1
    95 000023DD [1000000000000000]  <1>
    96 000023E5 BA07000000          <1>  mov edx, %2
    97 000023EA 0F05                <1>  syscall
  4574 000023EC E9B0FEFFFF              	    jmp .main_loop
  4575                                  
  4576                                  
  4577                                  
  4578                                  
  4579                                  start_screen:
  4580                                      print clear, clear_length    ; Limpiamos la pantalla primero
    93 000023F1 B801000000          <1>  mov eax, sys_write
    94 000023F6 BF01000000          <1>  mov edi, 1
    95 000023FB 48BE-               <1>  mov rsi, %1
    95 000023FD [1000000000000000]  <1>
    96 00002405 BA07000000          <1>  mov edx, %2
    97 0000240A 0F05                <1>  syscall
  4581                                      print msg1, msg1_length
    93 0000240C B801000000          <1>  mov eax, sys_write
    94 00002411 BF01000000          <1>  mov edi, 1
    95 00002416 48BE-               <1>  mov rsi, %1
    95 00002418 [1700000000000000]  <1>
    96 00002420 BA14010000          <1>  mov edx, %2
    97 00002425 0F05                <1>  syscall
  4582                                      
  4583                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  4584                                          getchar                 ; Esperamos una tecla
   101 00002427 B800000000          <1>  mov rax, sys_read
   102 0000242C BF00000000          <1>  mov rdi, STDIN_FILENO
   103 00002431 48BE-               <1>  mov rsi, input_char
   103 00002433 [0000000000000000]  <1>
   104 0000243B BA01000000          <1>  mov rdx, 1
   105 00002440 0F05                <1>  syscall
  4585 00002442 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  4586 00002446 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  4587                                          
  4588                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    93 00002448 B801000000          <1>  mov eax, sys_write
    94 0000244D BF01000000          <1>  mov edi, 1
    95 00002452 48BE-               <1>  mov rsi, %1
    95 00002454 [1000000000000000]  <1>
    96 0000245C BA07000000          <1>  mov edx, %2
    97 00002461 0F05                <1>  syscall
  4589 00002463 C3                          ret
  4590                                  
  4591                                  exit: 
  4592 00002464 E804DDFFFF              	call canonical_on
  4593 00002469 B83C000000              	mov    rax, 60
  4594 0000246E BF00000000                  mov    rdi, 0
  4595 00002473 0F05                        syscall
  4596                                  
