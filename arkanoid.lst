     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293 000014CA 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   294 000014CF 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   295 000014D4 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   296 000014D9 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   297                                  
   298                                  
   299                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   300                                  
   301                                      ; Nivel 2: Bloques de prueba
   302                                      level2_blocks:
   303 000014DE 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   304                                      level2_blocks_count equ 1
   305                                  
   306                                      ; Nivel 3
   307                                      level3_blocks:
   308 000014E3 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   309                                  
   310                                      level3_blocks_count equ 1
   311                                  
   312                                      ; Nivel 4
   313                                      level4_blocks:
   314 000014E8 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   315                                      level4_blocks_count equ 1
   316                                  
   317                                      ; Nivel 5
   318                                      level5_blocks:
   319 000014ED 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   320                                      level5_blocks_count equ 1
   321                                  
   322                                      ; Array para mantener el estado de los bloques
   323 000014F2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   324                                  
   325                                      
   326                                      ; Variables para almacenar los valores
   327 00001556 0000000000000000            current_score dq 0          ; Score actual
   328 0000155E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   329                                      
   330                                      ; Buffer para convertir números a string
   331 0000155F 00<rep 14h>                 number_buffer: times 20 db 0
   332                                  
   333 00001573 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   334                                      
   335                                      ; Estructura para los enemigos (x, y, activo)
   336 00001578 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   337 00001596 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   338                                      
   339 00001597 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   340 0000159F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   341 000015A0 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   342 000015A1 00                          enemy_move_total db 0      ; Contador total de movimientos
   343 000015A2 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   344 000015A3 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   345                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   346                                      ; Añade esto en la sección .dataa
   347 000015A4 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   347 000015AD 12                 
   348 000015AE 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   348 000015B7 13                 
   349 000015B8 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   349 000015C1 1B                 
   350 000015C2 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   350 000015CB 1C                 
   351 000015CC 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   351 000015D5 2D                 
   352                                          ; Arreglo de punteros a los spawn points de cada nivel
   353                                      spawn_points_table:
   354 000015D6 [A415000000000000]              dq level1_spawn_points
   355 000015DE [AE15000000000000]              dq level2_spawn_points
   356 000015E6 [B815000000000000]              dq level3_spawn_points
   357 000015EE [C215000000000000]              dq level4_spawn_points
   358 000015F6 [CC15000000000000]              dq level5_spawn_points
   359                                  
   360                                      ; Variables para el comportamiento de enemigos
   361 000015FE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   362 000015FF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   363 00001600 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   364 00001601 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   365                                  
   366 0000160B 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   366 00001614 5B2020202020202020-
   366 0000161D 20205D0A0D         
   367                                      score_label_len: equ $ - score_label
   368 00001622 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   368 0000162B 657374727569646F73-
   368 00001634 3A205B2020205D0A0D 
   369                                      blocks_label_len: equ $ - blocks_label
   370                                      
   371                                      ; Posición donde insertar los números en los labels
   372                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   373                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   374                                      
   375                                      ; Definición de las vidas (x, y, estado)
   376                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   377                                      lives_data: 
   378 0000163D 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   379 00001640 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   380 00001643 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   381 00001646 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   382 00001649 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   383 0000164C 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   384 0000164F 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   385                                      lives_count equ 7    ; Total de vidas
   386 00001652 5E                          life_char db "^"    
   387 00001653 04                          current_lives db 4   ; Contador de vidas activas actual
   388                                  
   389                                  ; Estructura para almacenar las letras y sus posiciones
   390                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   391 00001654 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   392 000017E4 00                          letters_count db 0   
   393 000017E5 20                          last_letter db ' '    ; Variable para almacenar la última letra
   394 000017E6 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   394 000017EF 75616C3A205B205D0A-
   394 000017F8 0D                 
   395                                      last_letter_msg_len equ $ - last_letter_msg
   396 000017F9 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   397 000017FA 07                          max_lives db 7              ; Máximo número de vidas permitidas
   398 000017FB 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   399 00001803 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   400 0000180B 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   401                                  
   402 00001813 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   403 00001814 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   404 00001815 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   405 0000181D 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   406                                  
   407 0000181E 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   408 0000181F 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   409 00001820 00                          laser_count: db 0                ; Contador de láseres activos
   410 00001821 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   411 000018E9 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   412                                  
   413                                  section .text
   414                                  
   415                                  
   416                                  print_lives:
   417 000001DD 55                          push rbp
   418 000001DE 4889E5                      mov rbp, rsp
   419                                      
   420 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   421                                      
   422                                      .print_loop:
   423 000001E4 4983FC07                        cmp r12, lives_count
   424 000001E8 7D45                            jge .end
   425                                          
   426                                          ; Calcular offset de la vida actual
   427 000001EA 4C89E0                          mov rax, r12
   428 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   429 000001F1 488DB0[3D160000]                lea rsi, [lives_data + rax]
   430                                          
   431                                          ; Calcular posición en el tablero
   432 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   433 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   434                                          
   435                                          ; Calcular offset en el tablero
   436 00000201 B84E000000                      mov rax, column_cells
   437 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   438 0000020A 49F7E1                          mul r9
   439 0000020D 4C01C0                          add rax, r8
   440 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   441                                          
   442                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   443 00000217 807E0201                        cmp byte [rsi + 2], 1
   444 0000021B 7405                            je .draw_active
   445                                          
   446                                          ; Si está inactiva, dibujar espacio
   447 0000021D C60720                          mov byte [rdi], ' '
   448 00000220 EB08                            jmp .next_life
   449                                          
   450                                      .draw_active:
   451                                          ; Si está activa, dibujar el símbolo de vida
   452 00000222 8A05(52160000)                  mov al, [life_char]
   453 00000228 8807                            mov [rdi], al
   454                                          
   455                                      .next_life:
   456 0000022A 49FFC4                          inc r12
   457 0000022D EBB5                            jmp .print_loop
   458                                          
   459                                      .end:
   460 0000022F 5D                              pop rbp
   461 00000230 C3                              ret
   462                                  
   463                                  ; Función para desactivar una vida
   464                                  ; Función modificada para perder una vida
   465                                  lose_life:
   466 00000231 55                          push rbp
   467 00000232 4889E5                      mov rbp, rsp
   468                                      
   469                                      ; Verificar si aún quedan vidas
   470 00000235 803D(53160000)00            cmp byte [current_lives], 0
   471 0000023C 0F8493000000                je .game_lost
   472                                      
   473                                      ; Encontrar la última vida activa
   474 00000242 B907000000                  mov rcx, lives_count
   475 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   476                                      
   477                                      .find_active_life:
   478 0000024A 4889C8                          mov rax, rcx
   479 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   480 00000251 488DB0[3D160000]                lea rsi, [lives_data + rax]
   481 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   482 0000025C 7407                            je .deactivate_life
   483 0000025E 48FFC9                          dec rcx
   484 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   485 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   486                                          
   487                                      .deactivate_life:
   488                                          ; Calcular posición correcta en el tablero para borrar la vida
   489 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   490 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   491                                          
   492                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   493 0000026E B84E000000                      mov rax, column_cells
   494 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   495 00000277 49F7E1                          mul r9
   496 0000027A 4C01C0                          add rax, r8
   497 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   498                                          
   499                                          ; Borrar visualmente la vida
   500 00000284 C60720                          mov byte [rdi], ' '             
   501                                          
   502                                          ; Desactivar la vida en los datos
   503 00000287 C6460200                        mov byte [rsi + 2], 0          
   504 0000028B FE0D(53160000)                  dec byte [current_lives]
   505                                          
   506                                          ; Borrar visualmente la paleta anterior
   507 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   508 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   509                                          .erase_pallet_loop:
   510 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   511 000002A3 49FFC0                              inc r8
   512 000002A6 48FFC9                              dec rcx
   513 000002A9 75F4                                jnz .erase_pallet_loop
   514                                          
   515                                  
   516                                          ; Reiniciar posición de la bola y la paleta
   517 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   517 000002B3 000000             
   518 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   518 000002BE 000000             
   519 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   520 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   520 000002CF [36130000]         
   521                                          
   522 000002D3 EB07                            jmp .end
   523                                          
   524                                      .game_lost:
   525 000002D5 E81C000000                      call game_lost
   526 000002DA EB00                            jmp .end
   527                                          
   528                                      .end:
   529 000002DC 5D                              pop rbp
   530 000002DD C3                              ret
   531                                  ; Función modificada para verificar colisión con el borde inferior
   532                                  check_bottom_collision:
   533 000002DE 55                          push rbp
   534 000002DF 4889E5                      mov rbp, rsp
   535                                      
   536                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   537 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   538 000002E9 4883F81E                    cmp rax, row_cells - 2
   539 000002ED 7505                        jne .no_collision
   540                                      
   541                                      ; Si hay colisión, perder una vida
   542 000002EF E83DFFFFFF                  call lose_life
   543                                      
   544                                      .no_collision:
   545 000002F4 5D                              pop rbp
   546 000002F5 C3                              ret
   547                                  
   548                                  ; Nueva función para game over
   549                                  game_lost:
   550                                      ; Limpiar la pantalla
   551                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   552                                      
   553                                      ; Mostrar mensaje de derrota
   554                                      section .data
   555 000018F1 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   555 000018FA 6469646F210A0D     
   556                                          lost_msg_len: equ $ - lost_msg
   557                                      section .text
   558                                      
   559                                      ; Imprimir mensaje de derrota
   560                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [F118000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   561                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [1F19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   562                                      
   563                                      ; Mostrar puntaje final
   564 00000347 488B05(56150000)            mov rax, [current_score]
   565 0000034E 48BF-                       mov rdi, number_buffer
   565 00000350 [5F15000000000000] 
   566 00000358 E8EA0D0000                  call number_to_string
   567                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [5F15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   568                                      
   569                                      ; Esperar un momento antes de salir
   570 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   570 00000381 0000               
   571 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   571 0000038C 0000               
   572                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   573                                      
   574 000003A1 E995150000                  jmp exit
   575                                  
   576                                  
   577                                  ; Función para registrar una nueva letra en el mapa
   578                                  ; Entrada:
   579                                  ;   al - letra a registrar
   580                                  ;   r8b - posición x
   581                                  ;   r9b - posición y
   582                                  register_letter:
   583 000003A6 55                          push rbp
   584 000003A7 4889E5                      mov rbp, rsp
   585 000003AA 53                          push rbx
   586 000003AB 51                          push rcx
   587                                      
   588 000003AC 3C20                        cmp al, ' '
   589 000003AE 7438                        je .end
   590                                  
   591                                      ; Encontrar un espacio libre en el mapa
   592 000003B0 4831C9                      xor rcx, rcx
   593 000003B3 480FB615(E4170000)          movzx rdx, byte [letters_count]
   594                                      
   595                                      .find_slot:
   596 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   597 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   598                                          
   599 000003C1 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   600 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   601 000003CD 7405                            je .found_slot
   602                                          
   603 000003CF 48FFC1                          inc rcx
   604 000003D2 EBE7                            jmp .find_slot
   605                                          
   606                                      .found_slot:
   607                                          ; Guardar la información de la letra
   608 000003D4 448803                          mov [rbx], r8b           ; x
   609 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   610 000003DB 884302                          mov [rbx + 2], al        ; letra
   611 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   612                                          
   613 000003E2 FE05(E4170000)                  inc byte [letters_count]
   614                                          
   615                                      .end:
   616 000003E8 59                              pop rcx
   617 000003E9 5B                              pop rbx
   618 000003EA 5D                              pop rbp
   619 000003EB C3                              ret
   620                                  
   621                                  ; Función para imprimir todas las letras registradas
   622                                  print_letters:
   623 000003EC 55                          push rbp
   624 000003ED 4889E5                      mov rbp, rsp
   625 000003F0 53                          push rbx
   626 000003F1 51                          push rcx
   627                                      
   628 000003F2 4831C9                      xor rcx, rcx
   629                                      
   630                                      .print_loop:
   631 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   632 000003F9 7D37                            jge .end
   633                                          
   634                                          ; Obtener puntero a la letra actual
   635 000003FB 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   636                                          
   637                                          ; Verificar si está activa
   638 00000403 807B0300                        cmp byte [rbx + 3], 0
   639 00000407 7424                            je .next_letter
   640                                          
   641                                          ; Calcular posición en el tablero
   642 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   643 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   644                                          
   645                                          ; Calcular offset en el tablero
   646 00000412 B84E000000                      mov rax, column_cells
   647 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   648 0000041B 49F7E1                          mul r9
   649 0000041E 4C01C0                          add rax, r8
   650 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   651                                          
   652                                          ; Imprimir la letra
   653 00000428 8A4302                          mov al, [rbx + 2]
   654 0000042B 8807                            mov [rdi], al
   655                                          
   656                                      .next_letter:
   657 0000042D 48FFC1                          inc rcx
   658 00000430 EBC3                            jmp .print_loop
   659                                          
   660                                      .end:
   661 00000432 59                              pop rcx
   662 00000433 5B                              pop rbx
   663 00000434 5D                              pop rbp
   664 00000435 C3                              ret
   665                                  
   666                                  ; Función para borrar una letra específica
   667                                  ; Entrada:
   668                                  ;   r8b - posición x
   669                                  ;   r9b - posición y
   670                                  remove_letter:
   671 00000436 55                          push rbp
   672 00000437 4889E5                      mov rbp, rsp
   673 0000043A 53                          push rbx
   674 0000043B 51                          push rcx
   675                                      
   676 0000043C 4831C9                      xor rcx, rcx
   677                                      
   678                                      .find_loop:
   679 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   680 00000443 7D2E                            jge .end
   681                                          
   682 00000445 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   683                                          
   684                                          ; Verificar si está activa y coincide la posición
   685 0000044D 807B0300                        cmp byte [rbx + 3], 0
   686 00000451 741B                            je .next_letter
   687                                          
   688 00000453 8A03                            mov al, [rbx]
   689 00000455 4438C0                          cmp al, r8b
   690 00000458 7514                            jne .next_letter
   691                                          
   692 0000045A 8A4301                          mov al, [rbx + 1]
   693 0000045D 4438C8                          cmp al, r9b
   694 00000460 750C                            jne .next_letter
   695                                          
   696                                          ; Encontrada la letra, desactivarla
   697 00000462 C6430300                        mov byte [rbx + 3], 0
   698 00000466 FE0D(E4170000)                  dec byte [letters_count]
   699 0000046C EB05                            jmp .end
   700                                          
   701                                      .next_letter:
   702 0000046E 48FFC1                          inc rcx
   703 00000471 EBCC                            jmp .find_loop
   704                                          
   705                                      .end:
   706 00000473 59                              pop rcx
   707 00000474 5B                              pop rbx
   708 00000475 5D                              pop rbp
   709 00000476 C3                              ret
   710                                  ; Función para mover las letras hacia abajo
   711                                  move_letters:
   712 00000477 55                          push rbp
   713 00000478 4889E5                      mov rbp, rsp
   714 0000047B 53                          push rbx
   715 0000047C 57                          push rdi
   716 0000047D 56                          push rsi
   717 0000047E 4150                        push r8
   718 00000480 4151                        push r9
   719 00000482 4152                        push r10
   720 00000484 4153                        push r11
   721                                  
   722 00000486 4831C9                      xor rcx, rcx
   723                                  
   724                                      .move_loop:
   725 00000489 4883F964                        cmp rcx, 100
   726 0000048D 0F8DAD010000                    jge .print_last_letter
   727                                          
   728 00000493 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   729 0000049B 807B0300                        cmp byte [rbx + 3], 0
   730 0000049F 0F8493010000                    je .next_letter
   731                                  
   732 000004A5 4C0FB603                        movzx r8, byte [rbx]
   733 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   734                                  
   735 000004AE B84E000000                      mov rax, column_cells
   736 000004B3 4883C002                        add rax, 2
   737 000004B7 49F7E1                          mul r9
   738 000004BA 4C01C0                          add rax, r8
   739 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   740 000004C4 C60720                          mov byte [rdi], ' '
   741                                  
   742 000004C7 FE4301                          inc byte [rbx + 1]
   743 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   744                                  
   745 000004CF 4983F91F                        cmp r9, row_cells - 1
   746 000004D3 7C09                            jl .check_pallet_collision
   747                                  
   748 000004D5 C6430300                        mov byte [rbx + 3], 0
   749 000004D9 E95A010000                      jmp .next_letter
   750                                  
   751                                          .check_pallet_collision:
   752 000004DE B84E000000                          mov rax, column_cells
   753 000004E3 4883C002                            add rax, 2
   754 000004E7 49F7E1                              mul r9
   755 000004EA 4C01C0                              add rax, r8
   756 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   757                                  
   758 000004F4 8A07                                mov al, [rdi]
   759 000004F6 3C20                                cmp al, ' '
   760 000004F8 0F843A010000                        je .next_letter
   761 000004FE 3C3D                                cmp al, char_equal
   762 00000500 740A                                je .capture_letter
   763                                  
   764 00000502 8A4302                              mov al, [rbx + 2]
   765 00000505 8807                                mov [rdi], al
   766 00000507 E92C010000                          jmp .next_letter
   767                                  
   768                                          .capture_letter:
   769                                              ; Obtener la nueva letra
   770 0000050C 8A4302                              mov al, [rbx + 2]
   771                                              
   772                                              ; Comparar con la última letra
   773 0000050F 3A05(E5170000)                      cmp al, [last_letter]
   774 00000515 7407                                je .same_letter
   775                                              
   776                                              ; Es una letra diferente, resetear el procesamiento
   777 00000517 C605(F9170000)00                    mov byte [current_power_processed], 0
   778                                              
   779                                              .same_letter:
   780                                              ; Guardar la nueva letra
   781 0000051E 8805(E5170000)                      mov [last_letter], al
   782                                              
   783                                              ; Verificar si es 'E' para extender la paleta
   784 00000524 3C45                                cmp al, 'E'
   785 00000526 7441                                je .extend_pallet
   786                                              
   787                                              ; Verificar si es 'P' para añadir vida
   788 00000528 3C50                                cmp al, 'P'
   789 0000052A 7462                                je .check_add_life
   790                                  
   791 0000052C 3C53                                cmp al, 'S'
   792 0000052E 0F8493000000                        je .slow_ball
   793                                  
   794 00000534 3C43                                cmp al, 'C'
   795 00000536 0F84AD000000                        je .activate_catch
   796                                              
   797 0000053C 3C4C                                cmp al, 'L'
   798 0000053E 0F84C7000000                        je .activate_laser
   799                                  
   800                                              ; Si no es ningún power-up, restaurar tamaño normal
   801 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   802 0000054B 488905(47140000)                    mov [pallet_size], rax
   803 00000552 48C705(FB170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 0000055A 000000             
   804 0000055D C605(13180000)00                    mov byte [catch_power_active], 0
   805 00000564 E9CB000000                          jmp .finish_capture
   806                                  
   807                                              .extend_pallet:
   808 00000569 C605(13180000)00                        mov byte [catch_power_active], 0
   809 00000570 48C705(FB170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   809 00000578 000000             
   810 0000057B 488B05(57140000)                        mov rax, [extended_pallet_size]
   811 00000582 488905(47140000)                        mov [pallet_size], rax
   812 00000589 E9A6000000                              jmp .finish_capture
   813                                  
   814                                              .check_add_life:
   815 0000058E C605(13180000)00                        mov byte [catch_power_active], 0
   816 00000595 488B05(4F140000)                        mov rax, [default_pallet_size]
   817 0000059C 488905(47140000)                        mov [pallet_size], rax
   818 000005A3 48C705(FB170000)01-                     mov qword [ball_speed], 1 
   818 000005AB 000000             
   819                                                  ; Verificar si ya procesamos este power-up
   820 000005AE 803D(F9170000)00                        cmp byte [current_power_processed], 0
   821 000005B5 757D                                    jne .finish_capture
   822                                                  
   823                                                  ; Preservar registros importantes
   824 000005B7 51                                      push rcx
   825 000005B8 53                                      push rbx
   826                                                  
   827                                                  ; Marcar como procesado
   828 000005B9 C605(F9170000)01                        mov byte [current_power_processed], 1
   829                                                  
   830                                                  ; Añadir una vida
   831 000005C0 E891030000                              call add_life
   832                                                  
   833                                                  ; Restaurar registros
   834 000005C5 5B                                      pop rbx
   835 000005C6 59                                      pop rcx
   836                                                  
   837                                              .slow_ball:
   838 000005C7 C605(13180000)00                        mov byte [catch_power_active], 0                
   839 000005CE 488B05(4F140000)                        mov rax, [default_pallet_size]
   840 000005D5 488905(47140000)                        mov [pallet_size], rax
   841 000005DC 48C705(FB170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   841 000005E4 000000             
   842 000005E7 EB4B                                    jmp .finish_capture
   843                                  
   844                                              .activate_catch:
   845 000005E9 488B05(4F140000)                        mov rax, [default_pallet_size]
   846 000005F0 488905(47140000)                        mov [pallet_size], rax
   847 000005F7 48C705(FB170000)01-                     mov qword [ball_speed], 1
   847 000005FF 000000             
   848 00000602 C605(13180000)01                        mov byte [catch_power_active], 1
   849 00000609 EB29                                    jmp .finish_capture
   850                                  
   851                                              .activate_laser:
   852 0000060B C605(13180000)00                        mov byte [catch_power_active], 0
   853 00000612 488B05(4F140000)                        mov rax, [default_pallet_size]
   854 00000619 488905(47140000)                        mov [pallet_size], rax
   855 00000620 48C705(FB170000)01-                     mov qword [ball_speed], 1
   855 00000628 000000             
   856 0000062B C605(1E180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   857 00000632 EB00                                    jmp .finish_capture
   858                                  
   859                                              .finish_capture:
   860 00000634 C6430300                                mov byte [rbx + 3], 0
   861                                  
   862                                          .next_letter:
   863 00000638 48FFC1                              inc rcx
   864 0000063B E949FEFFFF                          jmp .move_loop
   865                                  
   866                                      .print_last_letter:
   867                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000640 B801000000          <1>  mov eax, sys_write
    83 00000645 BF01000000          <1>  mov edi, 1
    84 0000064A 48BE-               <1>  mov rsi, %1
    84 0000064C [E617000000000000]  <1>
    85 00000654 BA10000000          <1>  mov edx, %2
    86 00000659 0F05                <1>  syscall
   868 0000065B 8A05(E5170000)                  mov al, [last_letter]
   869 00000661 8805(F5170000)                  mov [last_letter_msg + 15], al
   870                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [F617000000000000]  <1>
    85 0000067B BA03000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   871                                  
   872                                      .end:
   873 00000682 415B                            pop r11
   874 00000684 415A                            pop r10
   875 00000686 4159                            pop r9
   876 00000688 4158                            pop r8
   877 0000068A 5E                              pop rsi
   878 0000068B 5F                              pop rdi
   879 0000068C 5B                              pop rbx
   880 0000068D 5D                              pop rbp
   881 0000068E C3                              ret
   882                                  
   883                                  
   884                                  
   885                                  ; Nueva función para actualizar los láseres
   886                                  update_lasers:
   887 0000068F 55                          push rbp
   888 00000690 4889E5                      mov rbp, rsp
   889                                      
   890                                      ; Verificar si el poder láser está activo
   891 00000693 803D(1E180000)00            cmp byte [laser_power_active], 0
   892 0000069A 741A                        je .end
   893                                      
   894                                      ; Verificar si se presionó la tecla de espacio
   895 0000069C 803D(1D180000)20            cmp byte [last_key], ' '
   896 000006A3 750C                        jne .skip_shooting
   897                                      
   898                                      ; Disparar nuevos láseres
   899 000006A5 E80E000000                  call shoot_lasers
   900 000006AA C605(1D180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   901                                      
   902                                      .skip_shooting:
   903                                      ; Mover los láseres existentes
   904 000006B1 E89C000000                  call move_lasers
   905                                      
   906                                      .end:
   907 000006B6 5D                              pop rbp
   908 000006B7 C3                              ret
   909                                  
   910                                  shoot_lasers:
   911 000006B8 55                          push rbp
   912 000006B9 4889E5                      mov rbp, rsp
   913 000006BC 53                          push rbx
   914                                      
   915                                      ; Verificar si hay espacio para más láseres
   916 000006BD 480FB605(20180000)          movzx rax, byte [laser_count]
   917 000006C5 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   918 000006C9 0F8D80000000                jge .end
   919                                      
   920                                      ; Obtener posición de la paleta
   921 000006CF 4C8B05(3F140000)            mov r8, [pallet_position]
   922 000006D6 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   923                                      
   924                                      ; Calcular coordenadas x,y
   925 000006DD 4C89C0                      mov rax, r8
   926 000006E0 41B94E000000                mov r9, column_cells
   927 000006E6 4983C102                    add r9, 2                     ; Ancho total de línea
   928 000006EA 4831D2                      xor rdx, rdx
   929 000006ED 49F7F1                      div r9                        ; rax = y, rdx = x
   930                                      
   931                                      ; Guardar coordenadas
   932 000006F0 4989C2                      mov r10, rax                  ; Y en r10
   933 000006F3 4989D3                      mov r11, rdx                  ; X en r11
   934                                      
   935                                      ; Validar coordenadas
   936 000006F6 4983FA00                    cmp r10, 0
   937 000006FA 7C53                        jl .end
   938 000006FC 4983FA20                    cmp r10, row_cells
   939 00000700 7D4D                        jge .end
   940 00000702 4983FB00                    cmp r11, 0
   941 00000706 7C47                        jl .end
   942 00000708 4983FB4E                    cmp r11, column_cells
   943 0000070C 7D41                        jge .end
   944                                      
   945                                      ; Calcular índice para el primer láser
   946 0000070E 480FB61D(20180000)          movzx rbx, byte [laser_count]
   947 00000716 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   948                                      
   949                                      ; Primer láser (izquierda)
   950 0000071A 488DBB[21180000]            lea rdi, [lasers + rbx]
   951 00000721 44881F                      mov [rdi], r11b              ; X
   952 00000724 4488D0                      mov al, r10b
   953 00000727 FEC8                        dec al                       ; Y - 1
   954 00000729 884701                      mov [rdi + 1], al           ; Y
   955                                      
   956                                      ; Segundo láser (derecha)
   957 0000072C 4488D8                      mov al, r11b
   958 0000072F 0205(47140000)              add al, byte [pallet_size]
   959 00000735 FEC8                        dec al                       ; Ajustar para el último carácter
   960 00000737 488DBB[23180000]            lea rdi, [lasers + rbx + 2]
   961 0000073E 8807                        mov [rdi], al               ; X
   962 00000740 4488D0                      mov al, r10b
   963 00000743 FEC8                        dec al                      ; Y - 1
   964 00000745 884701                      mov [rdi + 1], al          ; Y
   965                                      
   966                                      ; Incrementar contador de láseres
   967 00000748 8005(20180000)02            add byte [laser_count], 2
   968                                      
   969                                      
   970                                      .end:
   971 0000074F 5B                              pop rbx
   972 00000750 5D                              pop rbp
   973 00000751 C3                              ret
   974                                  
   975                                  ; Función corregida para mover láseres
   976                                  ; Función corregida para mover láseres
   977                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
   978                                  
   979                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
   980                                  ; ============================================================
   981                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
   982                                  ; ============================================================
   983                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
   984                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
   985                                  ; ============================================================
   986                                  move_lasers:
   987 00000752 55                          push rbp
   988 00000753 4889E5                      mov  rbp, rsp
   989 00000756 53                          push rbx
   990 00000757 57                          push rdi
   991 00000758 56                          push rsi
   992 00000759 4154                        push r12
   993 0000075B 4155                        push r13
   994 0000075D 4156                        push r14
   995 0000075F 4157                        push r15
   996                                  
   997                                      ; 1) Tomamos la cantidad de láseres
   998 00000761 480FB60D(20180000)          movzx rcx, byte [laser_count]
   999 00000769 4885C9                      test rcx, rcx
  1000 0000076C 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1001                                  
  1002                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1003 00000772 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1004                                  
  1005                                  .loop_lasers:
  1006                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1007 00000775 488DB409[21180000]          lea rsi, [lasers + rcx*2]
  1008                                  
  1009                                      ; 2) Cargar x,y actuales del láser
  1010 0000077D 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1011 00000781 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1012                                  
  1013                                      ; 3) Borrar el láser de su posición actual en pantalla
  1014                                      ;    (por si en el ciclo anterior se había dibujado)
  1015 00000786 B84E000000                  mov rax, column_cells
  1016 0000078B 4883C002                    add rax, 2
  1017 0000078F 49F7E1                      mul r9
  1018 00000792 4C01C0                      add rax, r8
  1019 00000795 488DB8[000A0000]            lea rdi, [board + rax]
  1020 0000079C C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1021                                  
  1022                                      ; 4) Mover el láser hacia arriba (y - 1)
  1023 0000079F 49FFC9                      dec r9
  1024                                  
  1025                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1026 000007A2 4983F901                    cmp r9, 1
  1027 000007A6 7C57                        jl .delete_laser
  1028                                  
  1029                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1030 000007A8 44884E01                    mov byte [rsi + 1], r9b
  1031                                  
  1032                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1033                                      ;    - Primero colisión con bloques
  1034                                      ; ---------------------------------------------------------
  1035                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1036 000007AC B84E000000                  mov rax, column_cells
  1037 000007B1 4883C002                    add rax, 2
  1038 000007B5 49F7E1                      mul r9
  1039 000007B8 4C01C0                      add rax, r8
  1040 000007BB 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1041                                  
  1042                                      ; Revisar si hay bloque
  1043 000007C2 51                          push rcx
  1044 000007C3 56                          push rsi
  1045 000007C4 57                          push rdi
  1046 000007C5 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1047 000007C8 E8D20A0000                  call check_block_collision
  1048 000007CD 5F                          pop rdi
  1049 000007CE 5E                          pop rsi
  1050 000007CF 59                          pop rcx
  1051                                  
  1052 000007D0 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1053 000007D3 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1054                                  
  1055                                      ;    - Luego colisión con enemigos
  1056                                      ; ---------------------------------------------------------
  1057 000007D5 51                          push rcx
  1058 000007D6 56                          push rsi
  1059 000007D7 57                          push rdi
  1060                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1061                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1062                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1063                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1064                                      ;
  1065                                      ; Hacemos algo como:
  1066 000007D8 4989FA                      mov r10, rdi
  1067 000007DB E8F6000000                  call check_laser_enemy_collision
  1068 000007E0 5F                          pop rdi
  1069 000007E1 5E                          pop rsi
  1070 000007E2 59                          pop rcx
  1071                                  
  1072 000007E3 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1073 000007E6 7517                        jnz .delete_laser
  1074                                  
  1075                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1076 000007E8 8A05(1F180000)              mov al, [laser_symbol]
  1077 000007EE 8807                        mov [rdi], al
  1078                                  
  1079                                  .next_laser:
  1080                                      ; Pasamos al láser anterior en el array
  1081 000007F0 48FFC9                      dec rcx
  1082 000007F3 4883F9FF                    cmp rcx, -1
  1083 000007F7 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1084 000007FD EB2E                        jmp .fin
  1085                                  
  1086                                  ; -----------------------------------------------------------------
  1087                                  ; Subrutina interna: .delete_laser
  1088                                  ; -----------------------------------------------------------------
  1089                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1090                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1091                                  .delete_laser:
  1092 000007FF 4C0FB625(20180000)          movzx r12, byte [laser_count]
  1093 00000807 49FFCC                      dec r12                    ; r12 = índice del último láser
  1094 0000080A 4939CC                      cmp r12, rcx
  1095 0000080D 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1096                                  
  1097                                      ; Copiamos el último láser a la posición actual
  1098 0000080F 488DBC09[21180000]          lea rdi, [lasers + rcx*2]
  1099 00000817 4B8DB424[21180000]          lea rsi, [lasers + r12*2]
  1100 0000081F 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1101 00000822 668907                      mov [rdi], ax             ; copiamos X,Y
  1102                                  
  1103                                  .just_decrement:
  1104 00000825 FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1105 0000082B EBC3                        jmp .next_laser
  1106                                  
  1107                                  .fin:
  1108 0000082D 415F                        pop r15
  1109 0000082F 415E                        pop r14
  1110 00000831 415D                        pop r13
  1111 00000833 415C                        pop r12
  1112 00000835 5E                          pop rsi
  1113 00000836 5F                          pop rdi
  1114 00000837 5B                          pop rbx
  1115 00000838 5D                          pop rbp
  1116 00000839 C3                          ret
  1117                                  
  1118                                  
  1119                                  
  1120                                  ; Nueva función para verificar colisión de láser con bloques y enemigos
  1121                                  check_laser_collisions:
  1122 0000083A 55                          push rbp
  1123 0000083B 4889E5                      mov rbp, rsp
  1124 0000083E 53                          push rbx
  1125 0000083F 4154                        push r12
  1126 00000841 4155                        push r13
  1127 00000843 4156                        push r14
  1128 00000845 4157                        push r15
  1129                                  
  1130                                      ; Recorrer todos los láseres activos
  1131 00000847 480FB60D(20180000)          movzx rcx, byte [laser_count]
  1132 0000084F 4885C9                      test rcx, rcx
  1133 00000852 7477                        jz .end              ; Si no hay láseres, salir
  1134                                  
  1135 00000854 4D31E4                      xor r12, r12        ; Índice del láser
  1136                                  
  1137                                  .check_laser_loop:
  1138                                      ; Obtener posición del láser actual
  1139 00000857 4B8DB424[21180000]          lea rsi, [lasers + r12*2]    ; Cada láser usa 2 bytes (x,y)
  1140 0000085F 4C0FB606                    movzx r8, byte [rsi]         ; X del láser
  1141 00000863 4C0FB64E01                  movzx r9, byte [rsi + 1]     ; Y del láser
  1142                                  
  1143                                      ; Calcular posición en el tablero
  1144 00000868 B84E000000                  mov rax, column_cells
  1145 0000086D 4883C002                    add rax, 2
  1146 00000871 49F7E1                      mul r9
  1147 00000874 4C01C0                      add rax, r8
  1148 00000877 4C8D90[000A0000]            lea r10, [board + rax]       ; r10 = puntero a la posición en el tablero
  1149                                  
  1150                                      ; 1. Verificar colisión con bloques
  1151 0000087E 4150                        push r8
  1152 00000880 4151                        push r9
  1153 00000882 4152                        push r10
  1154 00000884 4154                        push r12
  1155 00000886 51                          push rcx
  1156 00000887 E8130A0000                  call check_block_collision    ; Usar la función existente de colisión de bloques
  1157 0000088C 59                          pop rcx
  1158 0000088D 415C                        pop r12
  1159 0000088F 415A                        pop r10
  1160 00000891 4159                        pop r9
  1161 00000893 4158                        pop r8
  1162                                  
  1163 00000895 4885C0                      test rax, rax
  1164 00000898 7407                        jz .check_enemies            ; Si no hay colisión con bloque, verificar enemigos
  1165                                  
  1166                                      ; Si hubo colisión con bloque, eliminar el láser
  1167 0000089A E881000000                  call remove_laser
  1168 0000089F EB21                        jmp .next_laser
  1169                                  
  1170                                  .check_enemies:
  1171                                      ; 2. Verificar colisión con enemigos
  1172 000008A1 4150                        push r8
  1173 000008A3 4151                        push r9
  1174 000008A5 4152                        push r10
  1175 000008A7 4154                        push r12
  1176 000008A9 51                          push rcx
  1177 000008AA E827000000                  call check_laser_enemy_collision
  1178 000008AF 59                          pop rcx
  1179 000008B0 415C                        pop r12
  1180 000008B2 415A                        pop r10
  1181 000008B4 4159                        pop r9
  1182 000008B6 4158                        pop r8
  1183                                  
  1184 000008B8 4885C0                      test rax, rax
  1185 000008BB 7405                        jz .next_laser              ; Si no hay colisión con enemigo, continuar
  1186                                  
  1187                                      ; Si hubo colisión con enemigo, eliminar el láser
  1188 000008BD E85E000000                  call remove_laser
  1189                                  
  1190                                  .next_laser:
  1191 000008C2 4983C401                    add r12, 1                  ; Siguiente láser
  1192 000008C6 4939CC                      cmp r12, rcx
  1193 000008C9 7C8C                        jl .check_laser_loop
  1194                                  
  1195                                  .end:
  1196 000008CB 415F                        pop r15
  1197 000008CD 415E                        pop r14
  1198 000008CF 415D                        pop r13
  1199 000008D1 415C                        pop r12
  1200 000008D3 5B                          pop rbx
  1201 000008D4 5D                          pop rbp
  1202 000008D5 C3                          ret
  1203                                  
  1204                                  ; Nueva función para verificar colisión entre láser y enemigos
  1205                                  check_laser_enemy_collision:
  1206 000008D6 55                          push rbp
  1207 000008D7 4889E5                      mov rbp, rsp
  1208                                      
  1209 000008DA 4D31ED                      xor r13, r13                    ; Índice del enemigo
  1210 000008DD 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1211                                      
  1212                                  .check_loop:
  1213 000008E0 4983FD05                    cmp r13, 5                      ; Máximo 5 enemigos
  1214 000008E4 7D38                        jge .end
  1215                                      
  1216                                      ; Calcular offset del enemigo actual
  1217 000008E6 4C89E9                      mov rcx, r13
  1218 000008E9 486BC903                    imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1219 000008ED 488DB1[78150000]            lea rsi, [enemies + rcx]
  1220                                      
  1221                                      ; Verificar si el enemigo está activo
  1222 000008F4 807E0201                    cmp byte [rsi + 2], 1
  1223 000008F8 751F                        jne .next_enemy
  1224                                      
  1225                                      ; Obtener posición del enemigo
  1226 000008FA 4C0FB636                    movzx r14, byte [rsi]           ; X enemigo
  1227 000008FE 4C0FB67E01                  movzx r15, byte [rsi + 1]       ; Y enemigo
  1228                                      
  1229                                      ; Verificar colisión
  1230 00000903 4D39F0                      cmp r8, r14                     ; Comparar X del láser con X del enemigo
  1231 00000906 7511                        jne .next_enemy
  1232 00000908 4D39F9                      cmp r9, r15                     ; Comparar Y del láser con Y del enemigo
  1233 0000090B 750C                        jne .next_enemy
  1234                                      
  1235                                      ; Colisión detectada
  1236 0000090D E8900E0000                  call destroy_enemy              ; Destruir enemigo
  1237 00000912 B801000000                  mov rax, 1                      ; Indicar colisión
  1238 00000917 EB05                        jmp .end
  1239                                      
  1240                                  .next_enemy:
  1241 00000919 49FFC5                      inc r13
  1242 0000091C EBC2                        jmp .check_loop
  1243                                      
  1244                                  .end:
  1245 0000091E 5D                          pop rbp
  1246 0000091F C3                          ret
  1247                                  
  1248                                  ; Función auxiliar para eliminar un láser específico
  1249                                  remove_laser:
  1250 00000920 55                          push rbp
  1251 00000921 4889E5                      mov rbp, rsp
  1252                                  
  1253                                      ; Borrar el láser del tablero
  1254 00000924 41C60220                    mov byte [r10], ' '
  1255                                  
  1256                                      ; Mover el último láser a esta posición si no es el último
  1257 00000928 480FB605(20180000)          movzx rax, byte [laser_count]
  1258 00000930 48FFC8                      dec rax                    ; Índice del último láser
  1259 00000933 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1260 00000936 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1261                                  
  1262                                      ; Copiar último láser a la posición actual
  1263 00000938 4B8DBC24[21180000]          lea rdi, [lasers + r12*2]
  1264 00000940 488DB400[21180000]          lea rsi, [lasers + rax*2]
  1265 00000948 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1266 0000094B 668917                      mov [rdi], dx
  1267                                  
  1268                                  .just_decrease:
  1269 0000094E FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1270                                  
  1271 00000954 5D                          pop rbp
  1272 00000955 C3                          ret
  1273                                  
  1274                                  add_life:
  1275 00000956 55                          push rbp
  1276 00000957 4889E5                      mov rbp, rsp
  1277 0000095A 53                          push rbx
  1278 0000095B 51                          push rcx
  1279 0000095C 57                          push rdi
  1280 0000095D 56                          push rsi
  1281 0000095E 4150                        push r8
  1282 00000960 4151                        push r9
  1283                                      
  1284                                      ; Verificar si ya tenemos el máximo de vidas
  1285 00000962 480FB605(53160000)          movzx rax, byte [current_lives]
  1286 0000096A 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1287 0000096E 7D2C                        jge .end
  1288                                      
  1289                                      ; Incrementar el contador de vidas
  1290 00000970 FE05(53160000)              inc byte [current_lives]
  1291                                      
  1292                                      ; Encontrar la siguiente vida inactiva
  1293 00000976 4831C9                      xor rcx, rcx
  1294                                      
  1295                                      .find_inactive:
  1296 00000979 4883F907                        cmp rcx, lives_count
  1297 0000097D 7D1D                            jge .end
  1298                                          
  1299                                          ; Calcular offset de la vida actual
  1300 0000097F 4889C8                          mov rax, rcx
  1301 00000982 486BC003                        imul rax, 3
  1302 00000986 488DB0[3D160000]                lea rsi, [lives_data + rax]
  1303                                          
  1304                                          ; Verificar si está inactiva
  1305 0000098D 807E0200                        cmp byte [rsi + 2], 0
  1306 00000991 7405                            je .activate_life
  1307                                          
  1308 00000993 48FFC1                          inc rcx
  1309 00000996 EBE1                            jmp .find_inactive
  1310                                          
  1311                                      .activate_life:
  1312                                          ; Activar la vida
  1313 00000998 C6460201                        mov byte [rsi + 2], 1
  1314                                          
  1315                                      .end:
  1316 0000099C 4159                            pop r9
  1317 0000099E 4158                            pop r8
  1318 000009A0 5E                              pop rsi
  1319 000009A1 5F                              pop rdi
  1320 000009A2 59                              pop rcx
  1321 000009A3 5B                              pop rbx
  1322 000009A4 5D                              pop rbp
  1323 000009A5 C3                              ret
  1324                                  
  1325                                  
  1326                                  print_ball:
  1327 000009A6 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1328 000009AD 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1329 000009B4 4981C0[000A0000]        	add r8, board
  1330                                  
  1331 000009BB 4C89C9                  	mov rcx, r9
  1332 000009BE B850000000              	mov rax, column_cells + 2
  1333 000009C3 48F7E9                  	imul rcx
  1334                                  	
  1335 000009C6 4901C0                  	add r8, rax
  1336 000009C9 41C6004F                	mov byte [r8], char_O
  1337 000009CD C3                      	ret
  1338                                  
  1339                                  	
  1340                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1341                                  	
  1342                                  print_pallet:
  1343                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1344 000009CE 4C8B05(3F140000)            mov r8, [pallet_position]
  1345 000009D5 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1346                                      .clear_pallet:
  1347 000009DC 41C60020                        mov byte [r8], char_space
  1348 000009E0 49FFC0                          inc r8
  1349 000009E3 48FFC9                          dec rcx
  1350 000009E6 75F4                            jnz .clear_pallet
  1351                                  
  1352                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1353 000009E8 4C8B05(3F140000)            mov r8, [pallet_position]
  1354 000009EF 488B0D(47140000)            mov rcx, [pallet_size]
  1355                                      .write_pallet:
  1356 000009F6 41C6003D                        mov byte [r8], char_equal
  1357 000009FA 49FFC0                          inc r8
  1358 000009FD 48FFC9                          dec rcx
  1359 00000A00 75F4                            jnz .write_pallet
  1360                                  
  1361 00000A02 C3                          ret
  1362                                  
  1363                                  move_pallet:
  1364                                      
  1365 00000A03 803D(7F140000)00            cmp byte [ball_moving], 0
  1366 00000A0A 7507                        jne .continue_movement
  1367 00000A0C C605(7F140000)01            mov byte [ball_moving], 1
  1368                                  
  1369                                      .continue_movement:
  1370 00000A13 4883FFFF                        cmp rdi, left_direction
  1371 00000A17 7531                            jne .move_right
  1372                                  
  1373                                          .move_left:
  1374                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1375 00000A19 4C8B05(3F140000)                    mov r8, [pallet_position]
  1376 00000A20 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1377 00000A23 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1378 00000A26 3C58                                cmp al, 'X'        ; Comparar si es una X
  1379 00000A28 744E                                je .end            ; Si es X, no mover
  1380                                              
  1381 00000A2A 4C8B05(3F140000)                    mov r8, [pallet_position]
  1382 00000A31 4C8B0D(47140000)                    mov r9, [pallet_size]
  1383 00000A38 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1384 00000A3E 49FFC8                              dec r8
  1385 00000A41 4C8905(3F140000)                    mov [pallet_position], r8
  1386 00000A48 EB2E                                jmp .end
  1387                                              
  1388                                          .move_right:
  1389                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1390 00000A4A 4C8B05(3F140000)                    mov r8, [pallet_position]
  1391 00000A51 4C8B0D(47140000)                    mov r9, [pallet_size]
  1392 00000A58 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1393 00000A5B 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1394 00000A5F 3C58                                cmp al, 'X'        ; Comparar si es una X
  1395 00000A61 7415                                je .end            ; Si es X, no mover
  1396                                              
  1397 00000A63 4C8B05(3F140000)                    mov r8, [pallet_position]
  1398 00000A6A 41C60020                            mov byte [r8], char_space
  1399 00000A6E 49FFC0                              inc r8
  1400 00000A71 4C8905(3F140000)                    mov [pallet_position], r8
  1401                                          .end:
  1402 00000A78 C3                                  ret
  1403                                  
  1404                                  
  1405                                  
  1406                                              
  1407                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1408                                  update_caught_ball_position:
  1409 00000A79 55                          push rbp
  1410 00000A7A 4889E5                      mov rbp, rsp
  1411                                      
  1412                                      ; Calcular la nueva posición de la bola basada en la paleta
  1413 00000A7D 4C8B05(3F140000)            mov r8, [pallet_position]
  1414 00000A84 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1415 00000A8B B850000000                  mov rax, column_cells + 2
  1416 00000A90 4831D2                      xor rdx, rdx
  1417 00000A93 48F7F0                      div rax                ; División para obtener X,Y
  1418                                      
  1419                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1420 00000A96 4989C1                      mov r9, rax            ; Y de la paleta
  1421 00000A99 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1422                                      
  1423                                      ; Añadir el offset guardado a la posición X
  1424 00000A9C 4889D0                      mov rax, rdx
  1425 00000A9F 480305(15180000)            add rax, [ball_catch_offset]
  1426 00000AA6 488905(5F140000)            mov [ball_x_pos], rax
  1427 00000AAD 4C890D(67140000)            mov [ball_y_pos], r9
  1428                                      
  1429 00000AB4 5D                          pop rbp
  1430 00000AB5 C3                          ret
  1431                                  move_ball:
  1432                                  
  1433 00000AB6 803D(14180000)01            cmp byte [ball_caught], 1
  1434 00000ABD 0F849D000000                je .move_with_pallet
  1435                                  
  1436 00000AC3 803D(7F140000)00            cmp byte [ball_moving], 0
  1437 00000ACA 0F84B8010000                je .end
  1438                                  
  1439                                      ; Incrementar contador de velocidad
  1440 00000AD0 48FF05(0B180000)            inc qword [speed_counter]
  1441                                      
  1442                                      ; Verificar si debemos mover la bola en este ciclo
  1443 00000AD7 488B05(0B180000)            mov rax, [speed_counter]
  1444 00000ADE 483B05(FB170000)            cmp rax, [ball_speed]
  1445 00000AE5 0F8C9D010000                jl .end
  1446                                      
  1447                                      ; Resetear contador de velocidad
  1448 00000AEB 48C705(0B180000)00-         mov qword [speed_counter], 0
  1448 00000AF3 000000             
  1449                                  
  1450                                      ; Borrar la posición actual de la bola
  1451 00000AF6 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1452 00000AFD 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1453 00000B04 4981C0[000A0000]            add r8, board
  1454 00000B0B 4C89C9                      mov rcx, r9
  1455 00000B0E B850000000                  mov rax, column_cells + 2
  1456 00000B13 48F7E9                      imul rcx
  1457 00000B16 4901C0                      add r8, rax
  1458 00000B19 41C60020                    mov byte [r8], char_space
  1459                                  
  1460                                      ; Calcular siguiente posición X
  1461 00000B1D 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1462 00000B24 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1463 00000B2B 488B05(6F140000)            mov rax, [ball_direction_x]
  1464 00000B32 4901C0                      add r8, rax               ; Nueva posición X
  1465                                  
  1466                                      ; Calcular la dirección de memoria para la siguiente posición
  1467 00000B35 4D89C2                      mov r10, r8
  1468 00000B38 4981C2[000A0000]            add r10, board
  1469 00000B3F 4C89C9                      mov rcx, r9
  1470 00000B42 B850000000                  mov rax, column_cells + 2
  1471 00000B47 48F7E9                      imul rcx
  1472 00000B4A 4901C2                      add r10, rax
  1473                                  
  1474                                      ; Verificar si hay una X en la siguiente posición X
  1475 00000B4D 418A02                      mov al, [r10]
  1476 00000B50 3C58                        cmp al, 'X'
  1477 00000B52 7565                        jne .check_block_x
  1478 00000B54 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1479 00000B5B E928010000                  jmp .end
  1480                                  
  1481                                      .move_with_pallet:
  1482                                          ; Borrar la posición actual de la bola
  1483 00000B60 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1484 00000B67 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1485 00000B6E 4D89C2                          mov r10, r8
  1486 00000B71 4981C2[000A0000]                add r10, board
  1487 00000B78 4C89C9                          mov rcx, r9
  1488 00000B7B B850000000                      mov rax, column_cells + 2
  1489 00000B80 48F7E9                          imul rcx
  1490 00000B83 4901C2                          add r10, rax
  1491 00000B86 41C60220                        mov byte [r10], char_space
  1492                                  
  1493                                          ; Actualizar posición X basada en la paleta
  1494 00000B8A 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1495 00000B91 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1496 00000B98 4C0305(15180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1497 00000B9F 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1498                                  
  1499                                          ; Mantener la bola una posición arriba de la paleta
  1500 00000BA6 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1501 00000BAD 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1502                                  
  1503 00000BB4 E9CF000000                      jmp .end
  1504                                  
  1505                                  
  1506                                      .check_block_x:
  1507                                          ; Verificar colisión con bloques en X
  1508 00000BB9 4150                            push r8     ; Guardar registros que usa check_block_collision
  1509 00000BBB 4151                            push r9
  1510 00000BBD 4152                            push r10
  1511 00000BBF E8DB060000                      call check_block_collision
  1512 00000BC4 415A                            pop r10
  1513 00000BC6 4159                            pop r9
  1514 00000BC8 4158                            pop r8
  1515 00000BCA 4885C0                          test rax, rax
  1516 00000BCD 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1517 00000BCF 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1518 00000BD6 E9AD000000                      jmp .end
  1519                                  
  1520                                      .check_paddle_x:
  1521                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1522 00000BDB 41803A3D                        cmp byte [r10], char_equal
  1523 00000BDF 750C                            jne .check_y_movement
  1524 00000BE1 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1525 00000BE8 E99B000000                      jmp .end
  1526                                  
  1527                                      .check_y_movement:
  1528                                          ; Calcular siguiente posición Y
  1529 00000BED 488B05(77140000)                mov rax, [ball_direction_y]
  1530 00000BF4 4901C1                          add r9, rax                  ; Nueva posición Y
  1531                                  
  1532                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1533 00000BF7 4D89C2                          mov r10, r8
  1534 00000BFA 4981C2[000A0000]                add r10, board
  1535 00000C01 4C89C9                          mov rcx, r9
  1536 00000C04 B850000000                      mov rax, column_cells + 2
  1537 00000C09 48F7E9                          imul rcx
  1538 00000C0C 4901C2                          add r10, rax
  1539                                  
  1540                                          ; Verificar si hay una X en la siguiente posición Y
  1541 00000C0F 418A02                          mov al, [r10]
  1542 00000C12 3C58                            cmp al, 'X'
  1543 00000C14 7509                            jne .check_block_y
  1544 00000C16 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1545 00000C1D EB69                            jmp .end
  1546                                  
  1547                                      .check_block_y:
  1548                                          ; Verificar colisión con bloques en Y
  1549 00000C1F 4150                            push r8     ; Guardar registros que usa check_block_collision
  1550 00000C21 4151                            push r9
  1551 00000C23 4152                            push r10
  1552 00000C25 E875060000                      call check_block_collision
  1553 00000C2A 415A                            pop r10
  1554 00000C2C 4159                            pop r9
  1555 00000C2E 4158                            pop r8
  1556 00000C30 4885C0                          test rax, rax
  1557 00000C33 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1558 00000C35 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1559 00000C3C EB4A                            jmp .end
  1560                                  
  1561                                      .check_paddle_y:
  1562                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1563 00000C3E 41803A3D                        cmp byte [r10], char_equal
  1564 00000C42 7536                            jne .update_position
  1565                                  
  1566                                          ; Verificar si el poder catch está activo
  1567 00000C44 803D(13180000)01                cmp byte [catch_power_active], 1
  1568 00000C4B 7524                            jne .normal_bounce
  1569                                  
  1570                                          ; Activar el modo "atrapado"
  1571 00000C4D C605(14180000)01                mov byte [ball_caught], 1
  1572                                          
  1573                                          ; Guardar la posición X actual de la bola como offset
  1574 00000C54 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1575 00000C5B 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1576 00000C62 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1577 00000C68 488905(15180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1578                                          
  1579 00000C6F EB17                            jmp .end
  1580                                  
  1581                                      .normal_bounce:
  1582 00000C71 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1583 00000C78 EB0E                            jmp .end
  1584                                  
  1585                                  
  1586                                      .update_position:
  1587 00000C7A 4C8905(5F140000)                mov [ball_x_pos], r8
  1588 00000C81 4C890D(67140000)                mov [ball_y_pos], r9
  1589                                  
  1590                                      .end:
  1591 00000C88 C3                              ret
  1592                                  
  1593                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1594                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1595                                  process_catch_release:
  1596 00000C89 55                          push rbp
  1597 00000C8A 4889E5                      mov rbp, rsp
  1598                                  
  1599                                      ; Verificar si la bola está atrapada
  1600 00000C8D 803D(14180000)00            cmp byte [ball_caught], 0
  1601 00000C94 7436                        je .end
  1602                                  
  1603                                      ; Verificar si el poder catch está activo
  1604 00000C96 803D(13180000)01            cmp byte [catch_power_active], 1
  1605 00000C9D 752D                        jne .end
  1606                                  
  1607                                      ; Verificar si se presionó la tecla 'c'
  1608 00000C9F 803D(1D180000)63            cmp byte [last_key], 'c'
  1609 00000CA6 7524                        jne .end
  1610                                  
  1611                                      ; Liberar la bola y asignar dirección inicial
  1612 00000CA8 C605(14180000)00            mov byte [ball_caught], 0
  1613 00000CAF 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1613 00000CB7 000000             
  1614 00000CBA 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1614 00000CC2 FFFFFF             
  1615                                  
  1616                                      ; Limpiar la tecla procesada
  1617 00000CC5 C605(1D180000)00            mov byte [last_key], 0
  1618                                  
  1619                                      .end:
  1620 00000CCC 5D                              pop rbp
  1621 00000CCD C3                              ret
  1622                                  
  1623                                  
  1624                                  display_level_number:
  1625 00000CCE 55                          push rbp
  1626 00000CCF 4889E5                      mov rbp, rsp
  1627                                      
  1628                                      ; Limpiar la pantalla primero
  1629                                      print clear, clear_length
    82 00000CD2 B801000000          <1>  mov eax, sys_write
    83 00000CD7 BF01000000          <1>  mov edi, 1
    84 00000CDC 48BE-               <1>  mov rsi, %1
    84 00000CDE [1000000000000000]  <1>
    85 00000CE6 BA07000000          <1>  mov edx, %2
    86 00000CEB 0F05                <1>  syscall
  1630                                      
  1631                                      ; Calcular la posición central para el mensaje
  1632                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1633 00000CED B84E000000                  mov rax, column_cells
  1634 00000CF2 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1635 00000CF6 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1636                                      
  1637                                      ; Calcular la fila central
  1638 00000CF9 BB20000000                  mov rbx, row_cells
  1639 00000CFE 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1640                                      
  1641                                      ; Calcular el offset en el buffer
  1642 00000D01 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1643 00000D06 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1644 00000D09 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1645                                      
  1646                                      ; Escribir "NIVEL " en la posición calculada
  1647 00000D0C 488DB8[000A0000]            lea rdi, [board + rax]
  1648 00000D13 48BE-                       mov rsi, level_msg
  1648 00000D15 [2414000000000000] 
  1649 00000D1D B906000000                  mov rcx, level_msg_len
  1650 00000D22 F3A4                        rep movsb
  1651                                      
  1652                                      ; Escribir el número del nivel
  1653 00000D24 8A05(B4140000)              mov al, [current_level]
  1654 00000D2A 0430                        add al, '0'                 ; convertir a ASCII
  1655 00000D2C 8807                        mov [rdi], al
  1656                                      
  1657                                      ; Mostrar el board con el mensaje
  1658                                      print board, board_size
    82 00000D2E B801000000          <1>  mov eax, sys_write
    83 00000D33 BF01000000          <1>  mov edi, 1
    84 00000D38 48BE-               <1>  mov rsi, %1
    84 00000D3A [000A000000000000]  <1>
    85 00000D42 BA000A0000          <1>  mov edx, %2
    86 00000D47 0F05                <1>  syscall
  1659                                      
  1660                                      ; Esperar un segundo
  1661 00000D49 B823000000                  mov rax, sys_nanosleep
  1662 00000D4E 48BF-                       mov rdi, level_display_time
  1662 00000D50 [2F14000000000000] 
  1663 00000D58 4831F6                      xor rsi, rsi
  1664 00000D5B 0F05                        syscall
  1665                                      
  1666 00000D5D 5D                          pop rbp
  1667 00000D5E C3                          ret
  1668                                  
  1669                                  ; Función para inicializar un tablero vacío
  1670                                  init_empty_board:
  1671 00000D5F 56                          push rsi
  1672 00000D60 57                          push rdi
  1673 00000D61 51                          push rcx
  1674 00000D62 50                          push rax
  1675                                  
  1676 00000D63 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1677 00000D6A 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1678 00000D71 B9000A0000                  mov rcx, board_template_size
  1679 00000D76 F3A4                        rep movsb                   ; Copiar el tablero
  1680                                  
  1681 00000D78 58                          pop rax
  1682 00000D79 59                          pop rcx
  1683 00000D7A 5F                          pop rdi
  1684 00000D7B 5E                          pop rsi
  1685 00000D7C C3                          ret
  1686                                  
  1687                                  
  1688                                  init_level:
  1689                                  
  1690 00000D7D 488B05(4F140000)            mov rax, [default_pallet_size]
  1691 00000D84 488905(47140000)            mov [pallet_size], rax
  1692 00000D8B 48C705(FB170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1692 00000D93 000000             
  1693                                  
  1694                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1695                                          ; Reiniciar letras activas
  1696 00000D96 488D3D(54160000)            lea rdi, [letters_map]
  1697 00000D9D B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1698 00000DA2 4831C0                      xor rax, rax
  1699 00000DA5 F3AA                        rep stosb                    ; Llenar con ceros
  1700                                      
  1701                                      ; Inicializar dirección de la bola (derecha y arriba)
  1702 00000DA7 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1702 00000DAF 000000             
  1703 00000DB2 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1703 00000DBA FFFFFF             
  1704                                  
  1705                                  
  1706                                      ; Reiniciar contador de letras activas
  1707 00000DBD 4831C0                      xor rax, rax
  1708 00000DC0 8805(E4170000)              mov [letters_count], al
  1709                                  
  1710                                      ; Reiniciar última letra capturada
  1711 00000DC6 C605(E5170000)20            mov byte [last_letter], ' '
  1712 00000DCD C605(5E150000)00            mov byte [destroyed_blocks], 0 
  1713 00000DD4 E886FFFFFF                  call init_empty_board
  1714 00000DD9 E8F0FEFFFF                  call display_level_number
  1715 00000DDE E8E5050000                  call init_enemies
  1716                                      
  1717 00000DE3 56                          push rsi
  1718 00000DE4 57                          push rdi
  1719 00000DE5 51                          push rcx
  1720 00000DE6 50                          push rax
  1721                                  
  1722 00000DE7 488D35(00000000)            lea rsi, [board_template]
  1723 00000DEE 488D3D(000A0000)            lea rdi, [board]
  1724 00000DF5 B9000A0000                  mov rcx, board_template_size
  1725 00000DFA F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1726                                  
  1727 00000DFC 58                          pop rax
  1728 00000DFD 59                          pop rcx
  1729 00000DFE 5F                          pop rdi
  1730 00000DFF 5E                          pop rsi
  1731                                  
  1732 00000E00 B90A000000                  mov rcx, 10
  1733 00000E05 4831C0                      xor rax, rax
  1734 00000E08 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  1735 00000E0F F3AA                        rep stosb      
  1736                                  
  1737                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1738 00000E11 803D(B4140000)01            cmp byte [current_level], 1
  1739 00000E18 7431                        je .level1
  1740 00000E1A 803D(B4140000)02            cmp byte [current_level], 2
  1741 00000E21 7454                        je .level2
  1742 00000E23 803D(B4140000)03            cmp byte [current_level], 3
  1743 00000E2A 7477                        je .level3
  1744 00000E2C 803D(B4140000)04            cmp byte [current_level], 4
  1745 00000E33 0F8492000000                je .level4
  1746 00000E39 803D(B4140000)05            cmp byte [current_level], 5
  1747 00000E40 0F84AD000000                je .level5
  1748 00000E46 E9D0000000                  jmp .done
  1749                                  
  1750                                  
  1751                                  
  1752                                      .level1:
  1753 00000E4B C605(B5140000)08                mov byte [blocks_remaining], level1_blocks_count
  1754 00000E52 4831C9                          xor rcx, rcx             
  1755                                          .init_loop1:
  1756 00000E55 4883F908                            cmp rcx, level1_blocks_count
  1757 00000E59 0F8DBC000000                        jge .done
  1758 00000E5F 4889C8                              mov rax, rcx         
  1759 00000E62 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1760 00000E66 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1761 00000E6C 8891[F2140000]                      mov byte [block_states + rcx], dl
  1762 00000E72 48FFC1                              inc rcx
  1763 00000E75 EBDE                                jmp .init_loop1
  1764                                  
  1765                                      .level2:
  1766 00000E77 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1767 00000E7E 4831C9                          xor rcx, rcx             
  1768                                          .init_loop2:
  1769 00000E81 4883F901                            cmp rcx, level2_blocks_count
  1770 00000E85 0F8D90000000                        jge .done
  1771 00000E8B 4889C8                              mov rax, rcx         
  1772 00000E8E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1773 00000E92 8A90[E1140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1774 00000E98 8891[F2140000]                      mov byte [block_states + rcx], dl
  1775 00000E9E 48FFC1                              inc rcx
  1776 00000EA1 EBDE                                jmp .init_loop2
  1777                                      .level3:
  1778 00000EA3 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1779 00000EAA 4831C9                          xor rcx, rcx             
  1780                                          .init_loop3:
  1781 00000EAD 4883F901                            cmp rcx, level3_blocks_count
  1782 00000EB1 7D68                                jge .done
  1783 00000EB3 4889C8                              mov rax, rcx         
  1784 00000EB6 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1785 00000EBA 8A90[E6140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1786 00000EC0 8891[F2140000]                      mov byte [block_states + rcx], dl
  1787 00000EC6 48FFC1                              inc rcx
  1788 00000EC9 EBE2                                jmp .init_loop3
  1789                                  
  1790                                      .level4:
  1791 00000ECB C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1792 00000ED2 4831C9                          xor rcx, rcx             
  1793                                          .init_loop4:
  1794 00000ED5 4883F901                            cmp rcx, level4_blocks_count
  1795 00000ED9 7D40                                jge .done
  1796 00000EDB 4889C8                              mov rax, rcx         
  1797 00000EDE 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1798 00000EE2 8A90[EB140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1799 00000EE8 8891[F2140000]                      mov byte [block_states + rcx], dl
  1800 00000EEE 48FFC1                              inc rcx
  1801 00000EF1 EBE2                                jmp .init_loop4
  1802                                  
  1803                                      .level5:
  1804 00000EF3 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1805 00000EFA 4831C9                          xor rcx, rcx             
  1806                                          .init_loop5:
  1807 00000EFD 4883F901                            cmp rcx, level5_blocks_count
  1808 00000F01 7D18                                jge .done
  1809 00000F03 4889C8                              mov rax, rcx         
  1810 00000F06 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1811 00000F0A 8A90[F0140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1812 00000F10 8891[F2140000]                      mov byte [block_states + rcx], dl
  1813 00000F16 48FFC1                              inc rcx
  1814 00000F19 EBE2                                jmp .init_loop5
  1815                                      .done:
  1816 00000F1B C3                              ret
  1817                                  
  1818                                  
  1819                                  ; Función para verificar y manejar la transición de nivel
  1820                                  check_level_complete:
  1821                                      ; Verificar si quedan bloques
  1822 00000F1C 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1823 00000F23 753C                        jne .not_complete
  1824                                      
  1825                                      ; Incrementar el nivel
  1826 00000F25 FE05(B4140000)              inc byte [current_level]
  1827                                      
  1828                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1829 00000F2B 803D(B4140000)06            cmp byte [current_level], 6
  1830 00000F32 742E                        je game_win
  1831                                      
  1832                                      ; Reinicializar el juego para el siguiente nivel
  1833 00000F34 E844FEFFFF                  call init_level
  1834                                      
  1835                                      ; Reinicializar la posición de la bola y la paleta
  1836 00000F39 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1836 00000F41 000000             
  1837 00000F44 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1837 00000F4C 000000             
  1838 00000F4F C605(7F140000)00            mov byte [ball_moving], 0
  1839 00000F56 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1839 00000F5D [36130000]         
  1840                                      
  1841                                      .not_complete:
  1842 00000F61 C3                              ret
  1843                                  
  1844                                      ; Nueva función para manejar la victoria del juego
  1845                                  game_win:
  1846                                      ; Limpiar la pantalla primero
  1847                                      print clear, clear_length
    82 00000F62 B801000000          <1>  mov eax, sys_write
    83 00000F67 BF01000000          <1>  mov edi, 1
    84 00000F6C 48BE-               <1>  mov rsi, %1
    84 00000F6E [1000000000000000]  <1>
    85 00000F76 BA07000000          <1>  mov edx, %2
    86 00000F7B 0F05                <1>  syscall
  1848                                      
  1849                                      ; Mensaje de victoria
  1850 00000F7D 488B05(56150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1851 00000F84 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1851 00000F86 [5F15000000000000] 
  1852 00000F8E E8B4010000                  call number_to_string
  1853                                      
  1854                                      ; Definir mensaje de victoria
  1855                                      section .data
  1856 00001901 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1856 0000190A 616465732120C2A148-
  1856 00001913 61732067616E61646F-
  1856 0000191C 210A0D             
  1857                                          win_msg_len: equ $ - win_msg
  1858 0000191F 50756E74616A652066-             score_msg: db "Puntaje final: "
  1858 00001928 696E616C3A20       
  1859                                          score_msg_len: equ $ - score_msg
  1860                                      section .text
  1861                                      
  1862                                      ; Imprimir mensajes
  1863                                      print win_msg, win_msg_len
    82 00000F93 B801000000          <1>  mov eax, sys_write
    83 00000F98 BF01000000          <1>  mov edi, 1
    84 00000F9D 48BE-               <1>  mov rsi, %1
    84 00000F9F [0119000000000000]  <1>
    85 00000FA7 BA1E000000          <1>  mov edx, %2
    86 00000FAC 0F05                <1>  syscall
  1864                                      print score_msg, score_msg_len
    82 00000FAE B801000000          <1>  mov eax, sys_write
    83 00000FB3 BF01000000          <1>  mov edi, 1
    84 00000FB8 48BE-               <1>  mov rsi, %1
    84 00000FBA [1F19000000000000]  <1>
    85 00000FC2 BA0F000000          <1>  mov edx, %2
    86 00000FC7 0F05                <1>  syscall
  1865                                      print number_buffer, 20
    82 00000FC9 B801000000          <1>  mov eax, sys_write
    83 00000FCE BF01000000          <1>  mov edi, 1
    84 00000FD3 48BE-               <1>  mov rsi, %1
    84 00000FD5 [5F15000000000000]  <1>
    85 00000FDD BA14000000          <1>  mov edx, %2
    86 00000FE2 0F05                <1>  syscall
  1866                                      
  1867                                      ; Esperar un momento antes de salir
  1868 00000FE4 48C70511F0FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1868 00000FED 0000               
  1869 00000FEF 48C7050EF0FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1869 00000FF8 0000               
  1870                                      sleeptime
    98 00000FFA B823000000          <1>  mov eax, sys_nanosleep
    99 00000FFF 48BF-               <1>  mov rdi, timespec
    99 00001001 [0000000000000000]  <1>
   100 00001009 31F6                <1>  xor esi, esi
   101 0000100B 0F05                <1>  syscall
  1871                                      
  1872 0000100D E929090000                  jmp exit
  1873                                  
  1874                                  ; Función para imprimir los bloques
  1875                                  ; Función modificada para imprimir bloques
  1876                                  
  1877                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1878                                  get_current_level_blocks:
  1879 00001012 803D(B4140000)01            cmp byte [current_level], 1
  1880 00001019 7428                        je .level1
  1881 0000101B 803D(B4140000)02            cmp byte [current_level], 2
  1882 00001022 7427                        je .level2
  1883 00001024 803D(B4140000)03            cmp byte [current_level], 3
  1884 0000102B 7426                        je .level3
  1885 0000102D 803D(B4140000)04            cmp byte [current_level], 4
  1886 00001034 7425                        je .level4
  1887 00001036 803D(B4140000)05            cmp byte [current_level], 5
  1888 0000103D 7424                        je .level5
  1889                                      ; Si llegamos aquí, hay un error en el nivel
  1890 0000103F 4831C0                      xor rax, rax
  1891 00001042 C3                          ret
  1892                                  
  1893                                      .level1:
  1894 00001043 488D05(B6140000)                lea rax, [level1_blocks]
  1895 0000104A C3                              ret
  1896                                      .level2:
  1897 0000104B 488D05(DE140000)                lea rax, [level2_blocks]
  1898 00001052 C3                              ret
  1899                                      .level3:
  1900 00001053 488D05(E3140000)                lea rax, [level3_blocks]
  1901 0000105A C3                              ret
  1902                                      .level4:
  1903 0000105B 488D05(E8140000)                lea rax, [level4_blocks]
  1904 00001062 C3                              ret
  1905                                      .level5:
  1906 00001063 488D05(ED140000)                lea rax, [level5_blocks]
  1907 0000106A C3                              ret
  1908                                  ; Función para obtener la cantidad de bloques del nivel actual
  1909                                  get_current_level_count:
  1910 0000106B 803D(B4140000)01            cmp byte [current_level], 1
  1911 00001072 7428                        je .level1
  1912 00001074 803D(B4140000)02            cmp byte [current_level], 2
  1913 0000107B 7425                        je .level2
  1914 0000107D 803D(B4140000)03            cmp byte [current_level], 3
  1915 00001084 7422                        je .level3
  1916 00001086 803D(B4140000)04            cmp byte [current_level], 4
  1917 0000108D 741F                        je .level4
  1918 0000108F 803D(B4140000)05            cmp byte [current_level], 5
  1919 00001096 741C                        je .level5
  1920                                      ; Si llegamos aquí, hay un error en el nivel
  1921 00001098 4831C0                      xor rax, rax
  1922 0000109B C3                          ret
  1923                                  
  1924                                      .level1:
  1925 0000109C B808000000                      mov rax, level1_blocks_count
  1926 000010A1 C3                              ret
  1927                                      .level2:
  1928 000010A2 B801000000                      mov rax, level2_blocks_count
  1929 000010A7 C3                              ret
  1930                                      .level3:
  1931 000010A8 B801000000                      mov rax, level3_blocks_count
  1932 000010AD C3                              ret
  1933                                      .level4:
  1934 000010AE B801000000                      mov rax, level4_blocks_count
  1935 000010B3 C3                              ret
  1936                                      .level5:
  1937 000010B4 B801000000                      mov rax, level5_blocks_count
  1938 000010B9 C3                              ret
  1939                                  
  1940                                  
  1941                                  print_blocks:
  1942 000010BA 55                          push rbp
  1943 000010BB 4889E5                      mov rbp, rsp
  1944                                      
  1945                                      ; Obtener puntero a los bloques del nivel actual
  1946 000010BE E84FFFFFFF                  call get_current_level_blocks
  1947 000010C3 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1948                                      
  1949                                      ; Obtener cantidad de bloques del nivel actual
  1950 000010C6 E8A0FFFFFF                  call get_current_level_count
  1951 000010CB 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1952                                      
  1953 000010CE 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1954                                      
  1955                                      .print_loop:
  1956 000010D1 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1957 000010D4 7D6F                            jge .end
  1958                                          
  1959                                          ; Verificar si el bloque está activo
  1960 000010D6 490FB68424-                     movzx rax, byte [block_states + r12]
  1960 000010DB [F2140000]         
  1961 000010DF 4885C0                          test rax, rax
  1962 000010E2 745C                            jz .next_block
  1963                                          
  1964                                          ; Obtener posición y tipo del bloque usando r13
  1965 000010E4 4C89E0                          mov rax, r12
  1966 000010E7 486BC005                        imul rax, 5
  1967 000010EB 4C01E8                          add rax, r13
  1968 000010EE 448A00                          mov r8b, [rax]        ; X position
  1969 000010F1 448A4801                        mov r9b, [rax + 1]    ; Y position
  1970 000010F5 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1971                                  
  1972                                          ; El resto de la lógica de impresión permanece igual
  1973 000010F9 4D0FB6C0                        movzx r8, r8b
  1974 000010FD 4D0FB6C9                        movzx r9, r9b
  1975 00001101 4981C0[000A0000]                add r8, board
  1976 00001108 B850000000                      mov rax, column_cells + 2
  1977 0000110D 49F7E1                          mul r9
  1978 00001110 4901C0                          add r8, rax
  1979                                          
  1980 00001113 B906000000                      mov rcx, block_length
  1981 00001118 48BE-                           mov rsi, block_type_1
  1981 0000111A [9014000000000000] 
  1982 00001122 490FB6C2                        movzx rax, r10b
  1983 00001126 48FFC8                          dec rax
  1984 00001129 486BC006                        imul rax, block_length
  1985 0000112D 4801C6                          add rsi, rax
  1986                                          
  1987                                      .print_block_chars:
  1988 00001130 8A06                            mov al, [rsi]
  1989 00001132 418800                          mov [r8], al
  1990 00001135 48FFC6                          inc rsi
  1991 00001138 49FFC0                          inc r8
  1992 0000113B 48FFC9                          dec rcx
  1993 0000113E 75F0                            jnz .print_block_chars
  1994                                          
  1995                                      .next_block:
  1996 00001140 49FFC4                          inc r12
  1997 00001143 EB8C                            jmp .print_loop
  1998                                          
  1999                                      .end:
  2000 00001145 5D                              pop rbp
  2001 00001146 C3                              ret
  2002                                  
  2003                                  ; Función para convertir número a string
  2004                                  ; Input: RAX = número a convertir
  2005                                  ; RDI = buffer donde escribir el string
  2006                                  number_to_string:
  2007 00001147 53                          push rbx
  2008 00001148 52                          push rdx
  2009 00001149 56                          push rsi
  2010 0000114A BB0A000000                  mov rbx, 10          ; Divisor
  2011 0000114F B900000000                  mov rcx, 0          ; Contador de dígitos
  2012                                      
  2013                                      ; Si el número es 0, manejarlo especialmente
  2014 00001154 4885C0                      test rax, rax
  2015 00001157 7509                        jnz .convert_loop
  2016 00001159 C60730                      mov byte [rdi], '0'
  2017 0000115C C6470100                    mov byte [rdi + 1], 0
  2018 00001160 EB20                        jmp .end
  2019                                      
  2020                                      .convert_loop:
  2021 00001162 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2022 00001165 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2023 00001168 80C230                          add dl, '0'     ; Convertir a ASCII
  2024 0000116B 52                              push rdx        ; Guardar el dígito
  2025 0000116C 48FFC1                          inc rcx         ; Incrementar contador
  2026 0000116F 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2027 00001172 75EE                            jnz .convert_loop
  2028                                          
  2029                                      .write_loop:
  2030 00001174 5A                              pop rdx         ; Obtener dígito
  2031 00001175 8817                            mov [rdi], dl   ; Escribir al buffer
  2032 00001177 48FFC7                          inc rdi         ; Siguiente posición
  2033 0000117A 48FFC9                          dec rcx         ; Decrementar contador
  2034 0000117D 75F5                            jnz .write_loop
  2035                                          
  2036 0000117F C60700                      mov byte [rdi], 0   ; Null terminator
  2037                                      
  2038                                      .end:
  2039 00001182 5E                          pop rsi
  2040 00001183 5A                          pop rdx
  2041 00001184 5B                          pop rbx
  2042 00001185 C3                          ret
  2043                                  
  2044                                  ; Función para imprimir los labels
  2045                                  print_labels:
  2046 00001186 55                          push rbp
  2047 00001187 4889E5                      mov rbp, rsp
  2048                                  
  2049                                      ; Crear buffer temporal
  2050 0000118A 4883EC20                    sub rsp, 32
  2051                                  
  2052                                      ; Copiar labels a buffer temporal
  2053 0000118E 4889E7                      mov rdi, rsp
  2054 00001191 488D35(0B160000)            lea rsi, [score_label]
  2055 00001198 B917000000                  mov rcx, score_label_len
  2056 0000119D F3A4                        rep movsb
  2057                                  
  2058                                      ; Convertir score a string
  2059 0000119F 488B05(56150000)            mov rax, [current_score]
  2060 000011A6 48BF-                       mov rdi, number_buffer
  2060 000011A8 [5F15000000000000] 
  2061 000011B0 E892FFFFFF                  call number_to_string
  2062                                  
  2063                                      ; Calcular longitud del número
  2064 000011B5 B900000000                  mov rcx, 0
  2065 000011BA 48BF-                       mov rdi, number_buffer
  2065 000011BC [5F15000000000000] 
  2066                                      .count_loop:
  2067 000011C4 803C0F00                        cmp byte [rdi + rcx], 0
  2068 000011C8 7405                            je .count_done
  2069 000011CA 48FFC1                          inc rcx
  2070 000011CD EBF5                            jmp .count_loop
  2071                                      .count_done:
  2072                                  
  2073                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2074 000011CF 4889E7                      mov rdi, rsp
  2075 000011D2 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2076 000011D6 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2077 000011DB 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2078                                      .pad_loop:
  2079 000011DE 4885F6                          test rsi, rsi
  2080 000011E1 740B                            jz .pad_done
  2081 000011E3 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2082 000011E6 48FFC7                          inc rdi
  2083 000011E9 48FFCE                          dec rsi
  2084 000011EC EBF0                            jmp .pad_loop
  2085                                      .pad_done:
  2086                                  
  2087                                      ; Copiar el número
  2088 000011EE 48BE-                       mov rsi, number_buffer
  2088 000011F0 [5F15000000000000] 
  2089 000011F8 F3A4                        rep movsb
  2090                                  
  2091                                      ; Imprimir el buffer completo
  2092                                      print rsp, score_label_len
    82 000011FA B801000000          <1>  mov eax, sys_write
    83 000011FF BF01000000          <1>  mov edi, 1
    84 00001204 4889E6              <1>  mov rsi, %1
    85 00001207 BA17000000          <1>  mov edx, %2
    86 0000120C 0F05                <1>  syscall
  2093                                  
  2094                                      ; Repetir proceso para bloques destruidos
  2095 0000120E 4889E7                      mov rdi, rsp
  2096 00001211 488D35(22160000)            lea rsi, [blocks_label]
  2097 00001218 B91B000000                  mov rcx, blocks_label_len
  2098 0000121D F3A4                        rep movsb
  2099                                  
  2100                                      ; Verificar que el `[` esté en su posición correcta
  2101 0000121F 4889E7                      mov rdi, rsp
  2102 00001222 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2103 00001226 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2104                                  
  2105                                      ; Convertir bloques destruidos a string
  2106 00001229 480FB605(5E150000)          movzx rax, byte [destroyed_blocks]
  2107 00001231 48BF-                       mov rdi, number_buffer
  2107 00001233 [5F15000000000000] 
  2108 0000123B E807FFFFFF                  call number_to_string
  2109                                  
  2110                                      ; Calcular longitud del número
  2111 00001240 B900000000                  mov rcx, 0
  2112 00001245 48BF-                       mov rdi, number_buffer
  2112 00001247 [5F15000000000000] 
  2113                                      .count_loop2:
  2114 0000124F 803C0F00                        cmp byte [rdi + rcx], 0
  2115 00001253 7405                            je .count_done2
  2116 00001255 48FFC1                          inc rcx
  2117 00001258 EBF5                            jmp .count_loop2
  2118                                      .count_done2:
  2119                                  
  2120                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2121 0000125A 4889E7                      mov rdi, rsp
  2122 0000125D 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2123 00001261 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2124 00001266 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2125                                      .pad_loop2:
  2126 00001269 4885F6                          test rsi, rsi
  2127 0000126C 740B                            jz .pad_done2
  2128 0000126E C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2129 00001271 48FFC7                          inc rdi
  2130 00001274 48FFCE                          dec rsi
  2131 00001277 EBF0                            jmp .pad_loop2
  2132                                      .pad_done2:
  2133                                  
  2134                                      ; Copiar el número
  2135 00001279 48BE-                       mov rsi, number_buffer
  2135 0000127B [5F15000000000000] 
  2136 00001283 F3A4                        rep movsb
  2137                                  
  2138                                      ; Imprimir el buffer completo
  2139                                      print rsp, blocks_label_len
    82 00001285 B801000000          <1>  mov eax, sys_write
    83 0000128A BF01000000          <1>  mov edi, 1
    84 0000128F 4889E6              <1>  mov rsi, %1
    85 00001292 BA1B000000          <1>  mov edx, %2
    86 00001297 0F05                <1>  syscall
  2140                                  
  2141                                      ; Restaurar stack
  2142 00001299 4883C420                    add rsp, 32
  2143 0000129D 5D                          pop rbp
  2144 0000129E C3                          ret
  2145                                  
  2146                                  
  2147                                  
  2148                                  check_block_collision:
  2149 0000129F 55                          push rbp
  2150 000012A0 4889E5                      mov rbp, rsp
  2151                                  
  2152                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2153 000012A3 418A02                      mov al, [r10]
  2154                                  
  2155                                      ; Verificar si el carácter es un bloque
  2156 000012A6 3C55                        cmp al, 'U'  
  2157 000012A8 7419                        je .possible
  2158 000012AA 3C4F                        cmp al, 'O'  
  2159 000012AC 7415                        je .possible
  2160 000012AE 3C44                        cmp al, 'D'  
  2161 000012B0 7411                        je .possible
  2162 000012B2 3C4C                        cmp al, 'L'  
  2163 000012B4 740D                        je .possible
  2164 000012B6 3C56                        cmp al, 'V'  
  2165 000012B8 7409                        je .possible
  2166 000012BA 3C38                        cmp al, '8'  
  2167 000012BC 7405                        je .possible
  2168                                  
  2169                                      ; No es bloque, salir
  2170 000012BE 4831C0                      xor rax, rax
  2171 000012C1 5D                          pop rbp
  2172 000012C2 C3                          ret
  2173                                  
  2174                                  .possible:
  2175 000012C3 53                          push rbx
  2176 000012C4 57                          push rdi
  2177 000012C5 56                          push rsi
  2178 000012C6 4154                        push r12
  2179 000012C8 4155                        push r13
  2180 000012CA 4156                        push r14
  2181 000012CC 4157                        push r15
  2182                                  
  2183                                      ; 1) Obtener base de los bloques del nivel actual
  2184 000012CE E83FFDFFFF                  call get_current_level_blocks
  2185 000012D3 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2186                                  
  2187                                      ; 2) Obtener la cantidad de bloques
  2188 000012D6 E890FDFFFF                  call get_current_level_count
  2189 000012DB 4989C6                      mov r14, rax
  2190                                  
  2191 000012DE 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2192                                  
  2193                                  .find_block_loop:
  2194 000012E1 4D39F4                      cmp r12, r14
  2195 000012E4 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2196                                  
  2197                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2198 000012EA 4C89E0                      mov rax, r12
  2199 000012ED 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2200 000012F1 4C01E8                      add rax, r13
  2201 000012F4 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2202                                  
  2203                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2204 000012F7 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2204 000012FC [F2140000]         
  2205 00001300 4885DB                      test rbx, rbx
  2206 00001303 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2207                                  
  2208                                      ; Obtener coordenadas
  2209 00001309 418A17                      mov dl, [r15]         ; x
  2210 0000130C 418A4F01                    mov cl, [r15 + 1]     ; y
  2211                                  
  2212                                      ; Calcular posición en el board
  2213 00001310 488D3D(000A0000)            lea rdi, [board]
  2214 00001317 4831C0                      xor rax, rax
  2215 0000131A B84E000000                  mov rax, column_cells
  2216 0000131F 4883C002                    add rax, 2
  2217 00001323 480FB6C9                    movzx rcx, cl         ; y
  2218 00001327 480FAFC1                    imul rax, rcx
  2219 0000132B 4801C7                      add rdi, rax
  2220 0000132E 480FB6C2                    movzx rax, dl         ; x
  2221 00001332 4801C7                      add rdi, rax
  2222                                  
  2223                                      ; Guardar la posición base del bloque
  2224 00001335 57                          push rdi
  2225                                  
  2226                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2227 00001336 4939FA                      cmp r10, rdi
  2228 00001339 7274                        jb .skip_collision
  2229 0000133B 488D5F06                    lea rbx, [rdi + block_length]
  2230 0000133F 4939DA                      cmp r10, rbx
  2231 00001342 736B                        jae .skip_collision
  2232                                  
  2233                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2234 00001344 41FE8C24[F2140000]          dec byte [block_states + r12]
  2235                                      ; Volver a cargar durabilidad
  2236 0000134C 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2236 00001351 [F2140000]         
  2237 00001355 4885DB                      test rbx, rbx
  2238 00001358 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2239                                  
  2240                                      ; >>> Llegó a 0 => Bloque destruido
  2241 0000135A 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2242 0000135B B906000000                  mov rcx, block_length
  2243                                  .clear_loop:
  2244 00001360 C60720                      mov byte [rdi], ' '
  2245 00001363 48FFC7                      inc rdi
  2246 00001366 E2F8                        loop .clear_loop
  2247                                  
  2248                                      ; Dibujar letra del bloque destruido
  2249 00001368 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2250 0000136C 4883EF06                    sub rdi, block_length
  2251 00001370 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2252                                      ; Después de escribir la letra en el tablero
  2253 00001372 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2254 00001376 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2255 0000137A 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2256 0000137F E822F0FFFF                  call register_letter
  2257                                      ; Actualizar contadores globales
  2258 00001384 FE0D(B5140000)              dec byte [blocks_remaining]
  2259 0000138A FE05(5E150000)              inc byte [destroyed_blocks]
  2260                                  
  2261                                      ; Sumar puntos según el tipo
  2262 00001390 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2263 00001395 486BC00A                    imul rax, 10
  2264 00001399 480105(56150000)            add [current_score], rax
  2265                                  
  2266 000013A0 B801000000                  mov rax, 1  ; colisión con destrucción
  2267 000013A5 EB14                        jmp .end_pop
  2268                                  
  2269                                  .update_display:
  2270                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2271 000013A7 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2272 000013AC 5F                          pop rdi     ; pop que quedó pendiente
  2273 000013AD EB0C                        jmp .end_pop
  2274                                  
  2275                                  .skip_collision:
  2276 000013AF 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2277                                  .next_block:
  2278 000013B0 49FFC4                      inc r12
  2279 000013B3 E929FFFFFF                  jmp .find_block_loop
  2280                                  
  2281                                  .no_block_found:
  2282 000013B8 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2283                                  
  2284                                  .end_pop:
  2285 000013BB 415F                        pop r15
  2286 000013BD 415E                        pop r14
  2287 000013BF 415D                        pop r13
  2288 000013C1 415C                        pop r12
  2289 000013C3 5E                          pop rsi
  2290 000013C4 5F                          pop rdi
  2291 000013C5 5B                          pop rbx
  2292 000013C6 5D                          pop rbp
  2293 000013C7 C3                          ret
  2294                                  
  2295                                  
  2296                                  
  2297                                  init_enemies:
  2298 000013C8 55                          push rbp
  2299 000013C9 4889E5                      mov rbp, rsp
  2300                                      ; Reiniciar contadores de movimiento
  2301 000013CC C605(A1150000)00            mov byte [enemy_move_total], 0
  2302 000013D3 C605(A2150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2303                                      ; Limpiar estado previo de enemigos
  2304 000013DA B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2305 000013DF 488D3D(78150000)            lea rdi, [enemies]
  2306 000013E6 30C0                        xor al, al
  2307 000013E8 F3AA                        rep stosb ; Limpiar datos de enemigos
  2308                                      
  2309                                      ; Marcar todos los enemigos como inactivos
  2310 000013EA 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  2311 000013F1 30C0                        xor al, al
  2312 000013F3 B90A000000                  mov rcx, 10
  2313 000013F8 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2314                                  
  2315 000013FA 5D                          pop rbp
  2316 000013FB C3                          ret
  2317                                  
  2318                                  
  2319                                  ; Función para mover enemigos
  2320                                  move_enemies:
  2321 000013FC 55                          push rbp
  2322 000013FD 4889E5                      mov rbp, rsp
  2323                                      
  2324                                      ; Incrementar contador de movimiento
  2325 00001400 FE05(9F150000)              inc byte [enemy_move_counter]
  2326 00001406 480FB605(9F150000)          movzx rax, byte [enemy_move_counter]
  2327 0000140E 3A05(A0150000)              cmp al, [enemy_move_delay]
  2328 00001414 0F85AA010000                jne .end
  2329                                      
  2330                                      ; Resetear contador
  2331 0000141A C605(9F150000)00            mov byte [enemy_move_counter], 0
  2332                                      
  2333 00001421 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2334                                      
  2335                                      .enemy_loop:
  2336 00001424 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2337 00001428 0F8D96010000                    jge .end
  2338                                          
  2339                                          ; Calcular offset del enemigo actual
  2340 0000142E 4C89E0                          mov rax, r12
  2341 00001431 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2342 00001435 488DB0[78150000]                lea rsi, [enemies + rax]
  2343                                          
  2344                                          ; Verificar si el enemigo está activo
  2345 0000143C 807E0201                        cmp byte [rsi + 2], 1
  2346 00001440 0F8576010000                    jne .next_enemy
  2347                                          
  2348                                          ; Obtener posición actual
  2349 00001446 4C0FB606                        movzx r8, byte [rsi]            ; X
  2350 0000144A 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2351                                          
  2352                                          ; Limpiar posición actual antes de mover
  2353 0000144F 4150                            push r8
  2354 00001451 4151                            push r9
  2355 00001453 B84E000000                      mov rax, column_cells
  2356 00001458 4883C002                        add rax, 2
  2357 0000145C 49F7E1                          mul r9
  2358 0000145F 4C01C0                          add rax, r8
  2359 00001462 488DB8[000A0000]                lea rdi, [board + rax]
  2360 00001469 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2361 0000146C 4159                            pop r9
  2362 0000146E 4158                            pop r8
  2363                                  
  2364                                          ; Determinar comportamiento basado en índice
  2365 00001470 4C89E0                          mov rax, r12
  2366 00001473 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2367 00001477 4885C0                          test rax, rax
  2368 0000147A 7402                            jz .chase_ball
  2369 0000147C EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2370                                          
  2371                                          ; Perseguir bola (comportamiento original)
  2372                                      .chase_ball:
  2373 0000147E 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2374 00001485 4D39D0                          cmp r8, r10
  2375 00001488 0F8F96000000                    jg .move_left
  2376 0000148E 0F8C95000000                    jl .move_right
  2377                                          
  2378 00001494 4C8B15(67140000)                mov r10, [ball_y_pos]
  2379 0000149B 4D39D1                          cmp r9, r10
  2380 0000149E 0F8F8A000000                    jg .move_up
  2381 000014A4 0F8C89000000                    jl .move_down
  2382 000014AA E9A5000000                      jmp .check_collision
  2383                                          
  2384                                      .chase_paddle:
  2385                                          ; Obtener la posición X actual de la paleta
  2386 000014AF 4C8B15(3F140000)                mov r10, [pallet_position]
  2387 000014B6 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2388                                          
  2389                                          ; Calcular la posición X real de la paleta
  2390 000014BD 4C89D0                          mov rax, r10
  2391 000014C0 BB4E000000                      mov rbx, column_cells
  2392 000014C5 4883C302                        add rbx, 2                  ; Añadir newline chars
  2393 000014C9 4831D2                          xor rdx, rdx
  2394 000014CC 48F7F3                          div rbx                     ; rax = y, rdx = x
  2395                                          
  2396                                          ; rdx ahora contiene la posición X de la paleta
  2397                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2398 000014CF 488B0D(47140000)                mov rcx, [pallet_size]
  2399 000014D6 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2400 000014D9 4801CA                          add rdx, rcx
  2401                                          
  2402                                          ; Comparar con posición X del enemigo y mover gradualmente
  2403 000014DC 4939D0                          cmp r8, rdx
  2404 000014DF 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2405 000014E1 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2406 000014E3 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2407                                  
  2408                                      .check_y_paddle:
  2409                                          ; La Y de la paleta siempre es row_cells - 2
  2410 000014E5 41BA20000000                    mov r10, row_cells
  2411 000014EB 4983EA02                        sub r10, 2
  2412                                          
  2413                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2414 000014EF 4D39D1                          cmp r9, r10
  2415 000014F2 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2416 000014F4 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2417 000014F6 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2418                                          
  2419                                      .no_movement:
  2420 000014F8 EB5A                            jmp .check_collision
  2421                                  
  2422                                      ; También agregar una nueva sección para el movimiento suave
  2423                                      .smooth_transition:
  2424                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2425 000014FA 8A05(A2150000)                  mov al, [enemy_target]
  2426 00001500 84C0                            test al, al
  2427 00001502 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2428                                          
  2429                                          ; Verificar distancia en X
  2430 00001504 4989D2                          mov r10, rdx              ; Posición X objetivo
  2431 00001507 4D29C2                          sub r10, r8               ; Calcular diferencia
  2432 0000150A 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2433 0000150E 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2434 00001510 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2435 00001514 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2436 00001516 EB3C                            jmp .check_collision
  2437                                          
  2438                                      .limit_right_movement:
  2439 00001518 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2440 0000151C EB36                            jmp .check_collision
  2441                                          
  2442                                      .limit_left_movement:
  2443 0000151E 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2444 00001522 EB30                            jmp .check_collision
  2445                                      .move_left:
  2446 00001524 49FFC8                          dec r8
  2447 00001527 EB0F                            jmp .check_vertical
  2448                                          
  2449                                      .move_right:
  2450 00001529 49FFC0                          inc r8
  2451 0000152C EB0A                            jmp .check_vertical
  2452                                          
  2453                                      .move_up:
  2454 0000152E 49FFC9                          dec r9
  2455 00001531 EB21                            jmp .check_collision
  2456                                          
  2457                                      .move_down:
  2458 00001533 49FFC1                          inc r9
  2459 00001536 EB1C                            jmp .check_collision
  2460                                          
  2461                                      .check_vertical:
  2462 00001538 8A05(A2150000)                  mov al, [enemy_target]
  2463 0000153E 84C0                            test al, al
  2464 00001540 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2465 00001546 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2466 0000154D 4D39D1                          cmp r9, r10
  2467 00001550 7FDC                            jg .move_up
  2468 00001552 7CDF                            jl .move_down
  2469                                          
  2470                                      .check_collision:
  2471                                          ; Verificar colisión con bordes
  2472 00001554 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2473 00001558 7E62                            jle .next_enemy
  2474 0000155A 4983F84E                        cmp r8, column_cells
  2475 0000155E 7D5C                            jge .next_enemy
  2476 00001560 4983F901                        cmp r9, 1                       ; Borde superior
  2477 00001564 7E56                            jle .next_enemy
  2478 00001566 4983F920                        cmp r9, row_cells
  2479 0000156A 7D50                            jge .next_enemy
  2480                                          
  2481                                          ; Verificar colisión con bloques antes de moverse
  2482 0000156C 4150                            push r8
  2483 0000156E 4151                            push r9
  2484 00001570 4152                            push r10
  2485                                          
  2486                                          ; Calcular posición en el tablero para verificar
  2487 00001572 B84E000000                      mov rax, column_cells
  2488 00001577 4883C002                        add rax, 2
  2489 0000157B 49F7E1                          mul r9
  2490 0000157E 4C01C0                          add rax, r8
  2491 00001581 4C8D90[000A0000]                lea r10, [board + rax]
  2492                                          
  2493                                          ; Verificar si hay un bloque en la nueva posición
  2494 00001588 418A02                          mov al, [r10]
  2495 0000158B 3C55                            cmp al, 'U'
  2496 0000158D 7427                            je .invalid_move
  2497 0000158F 3C4F                            cmp al, 'O'
  2498 00001591 7423                            je .invalid_move
  2499 00001593 3C44                            cmp al, 'D'
  2500 00001595 741F                            je .invalid_move
  2501 00001597 3C4C                            cmp al, 'L'
  2502 00001599 741B                            je .invalid_move
  2503 0000159B 3C56                            cmp al, 'V'
  2504 0000159D 7417                            je .invalid_move
  2505 0000159F 3C38                            cmp al, '8'
  2506 000015A1 7413                            je .invalid_move
  2507 000015A3 3C58                            cmp al, 'X'
  2508 000015A5 740F                            je .invalid_move
  2509                                          
  2510 000015A7 415A                            pop r10
  2511 000015A9 4159                            pop r9
  2512 000015AB 4158                            pop r8
  2513                                          
  2514                                          ; Guardar nueva posición si es válida
  2515 000015AD 448806                          mov [rsi], r8b
  2516 000015B0 44884E01                        mov [rsi + 1], r9b
  2517 000015B4 EB06                            jmp .next_enemy
  2518                                          
  2519                                      .invalid_move:
  2520 000015B6 415A                            pop r10
  2521 000015B8 4159                            pop r9
  2522 000015BA 4158                            pop r8
  2523                                          
  2524                                      .next_enemy:
  2525 000015BC 49FFC4                          inc r12
  2526 000015BF E960FEFFFF                      jmp .enemy_loop
  2527                                          
  2528                                      .end:
  2529 000015C4 5D                              pop rbp
  2530 000015C5 C3                              ret
  2531                                  
  2532                                  get_current_spawn_points:
  2533 000015C6 55                          push rbp
  2534 000015C7 4889E5                      mov rbp, rsp
  2535                                      
  2536 000015CA 480FB605(B4140000)          movzx rax, byte [current_level]
  2537 000015D2 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2538 000015D5 488B04C5[D6150000]          mov rax, [spawn_points_table + rax * 8]
  2539                                      
  2540 000015DD 5D                          pop rbp
  2541 000015DE C3                          ret
  2542                                  
  2543                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2544                                  check_enemy_spawn:
  2545 000015DF 55                          push rbp
  2546 000015E0 4889E5                      mov rbp, rsp
  2547                                      
  2548                                      ; Obtener spawn points del nivel actual
  2549 000015E3 E8DEFFFFFF                  call get_current_spawn_points
  2550 000015E8 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2551                                      
  2552                                      ; Obtener cantidad de bloques destruidos
  2553 000015EB 4C0FB62D(5E150000)          movzx r13, byte [destroyed_blocks]
  2554                                      
  2555                                      ; Verificar cada punto de spawn
  2556 000015F3 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2557                                      
  2558                                      .check_loop:
  2559 000015F6 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2560 000015FA 7D4B                            jge .end
  2561                                          
  2562                                          ; Verificar si este spawn point ya fue usado
  2563 000015FC 80B9[01160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2564 00001603 743D                            je .next_enemy
  2565                                          
  2566                                          ; Verificar si este enemigo ya está activo
  2567 00001605 4889C8                          mov rax, rcx
  2568 00001608 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2569 0000160C 488DB0[78150000]                lea rsi, [enemies + rax]
  2570 00001613 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2571 00001617 7429                            je .next_enemy
  2572                                          
  2573                                          ; Verificar si debemos spawnear este enemigo
  2574 00001619 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2575 0000161E 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2576 00001621 751F                            jne .next_enemy
  2577                                          
  2578                                          ; Marcar este spawn point como usado
  2579 00001623 C681[01160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2580                                          
  2581                                          ; Spawner nuevo enemigo
  2582 0000162A C60628                          mov byte [rsi], 40             ; X inicial
  2583 0000162D C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2584 00001631 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2585                                          
  2586                                          ; Inicializar comportamiento
  2587 00001635 4889C8                          mov rax, rcx
  2588 00001638 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2589 0000163C 8805(00160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2590                                          
  2591                                      .next_enemy:
  2592 00001642 48FFC1                          inc rcx
  2593 00001645 EBAF                            jmp .check_loop
  2594                                          
  2595                                      .end:
  2596 00001647 5D                              pop rbp
  2597 00001648 C3                              ret
  2598                                  
  2599                                  
  2600                                  ; Función para dibujar enemigos
  2601                                  print_enemies:
  2602 00001649 55                          push rbp
  2603 0000164A 4889E5                      mov rbp, rsp
  2604                                      
  2605 0000164D 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2606                                      
  2607                                      .print_loop:
  2608 00001650 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2609 00001654 7D4B                            jge .end
  2610                                          
  2611                                          ; Calcular offset del enemigo actual
  2612 00001656 4C89E0                          mov rax, r12
  2613 00001659 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2614 0000165D 488DB0[78150000]                lea rsi, [enemies + rax]
  2615                                          
  2616                                          ; Verificar si el enemigo está activo
  2617 00001664 807E0201                        cmp byte [rsi + 2], 1
  2618 00001668 7532                            jne .next_enemy
  2619                                          
  2620                                          ; Calcular posición en el tablero
  2621 0000166A 4C0FB606                        movzx r8, byte [rsi]            ; X
  2622 0000166E 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2623                                          
  2624                                          ; Calcular offset en el tablero
  2625 00001673 B84E000000                      mov rax, column_cells
  2626 00001678 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2627 0000167C 49F7E1                          mul r9
  2628 0000167F 4C01C0                          add rax, r8
  2629 00001682 488DB8[000A0000]                lea rdi, [board + rax]
  2630                                          
  2631                                          ; Obtener carácter del enemigo según el nivel
  2632 00001689 480FB605(B4140000)              movzx rax, byte [current_level]
  2633 00001691 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2634 00001694 8A80[73150000]                  mov al, [enemy_chars + rax]
  2635                                          
  2636                                          ; Dibujar enemigo
  2637 0000169A 8807                            mov [rdi], al
  2638                                          
  2639                                      .next_enemy:
  2640 0000169C 49FFC4                          inc r12
  2641 0000169F EBAF                            jmp .print_loop
  2642                                          
  2643                                      .end:
  2644 000016A1 5D                              pop rbp
  2645 000016A2 C3                              ret
  2646                                  
  2647                                  ; Función para verificar colisión con enemigos
  2648                                  ; Función para verificar colisión con enemigos
  2649                                  check_enemy_collision:
  2650 000016A3 55                          push rbp
  2651 000016A4 4889E5                      mov rbp, rsp
  2652                                      
  2653 000016A7 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2654 000016AA 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2655                                      
  2656                                      .check_loop:
  2657 000016AD 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2658 000016B1 0F8DE9000000                    jge .end
  2659                                          
  2660                                          ; Calcular offset del enemigo actual
  2661 000016B7 4C89E1                          mov rcx, r12
  2662 000016BA 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2663 000016BE 488DB1[78150000]                lea rsi, [enemies + rcx]
  2664                                          
  2665                                          ; Verificar si el enemigo está activo
  2666 000016C5 807E0201                        cmp byte [rsi + 2], 1
  2667 000016C9 0F85C9000000                    jne .next_enemy
  2668                                          
  2669                                          ; Verificar colisión con la bola
  2670 000016CF 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2671 000016D3 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2672                                          
  2673                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2674 000016D8 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2675 000016DF 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2676                                          
  2677                                          ; Comprobar colisión vertical (misma columna)
  2678 000016E6 4D39C2                          cmp r10, r8
  2679 000016E9 7525                            jne .check_horizontal
  2680 000016EB 4D29CB                          sub r11, r9
  2681 000016EE 4983FB01                        cmp r11, 1
  2682 000016F2 7F1C                            jg .check_horizontal
  2683 000016F4 4983FBFF                        cmp r11, -1
  2684 000016F8 7C16                            jl .check_horizontal
  2685                                          
  2686                                          ; Colisión vertical detectada
  2687 000016FA E8A3000000                      call destroy_enemy
  2688 000016FF 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2689 00001706 B801000000                      mov rax, 1
  2690 0000170B E990000000                      jmp .end
  2691                                          
  2692                                      .check_horizontal:
  2693                                          ; Comprobar colisión horizontal (misma fila)
  2694 00001710 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2695 00001717 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2696 0000171E 4D39CB                          cmp r11, r9
  2697 00001721 7522                            jne .check_paddle
  2698 00001723 4D29C2                          sub r10, r8
  2699 00001726 4983FA01                        cmp r10, 1
  2700 0000172A 7F19                            jg .check_paddle
  2701 0000172C 4983FAFF                        cmp r10, -1
  2702 00001730 7C13                            jl .check_paddle
  2703                                          
  2704                                          ; Colisión horizontal detectada
  2705 00001732 E86B000000                      call destroy_enemy
  2706 00001737 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2707 0000173E B801000000                      mov rax, 1
  2708 00001743 EB5B                            jmp .end
  2709                                          
  2710                                      .check_paddle:
  2711                                          ; Verificar colisión con la paleta
  2712 00001745 4C8B15(3F140000)                mov r10, [pallet_position]
  2713 0000174C 4981EA[000A0000]                sub r10, board
  2714 00001753 4C89D0                          mov rax, r10
  2715 00001756 41BB4E000000                    mov r11, column_cells
  2716 0000175C 4983C302                        add r11, 2
  2717 00001760 4831D2                          xor rdx, rdx
  2718 00001763 49F7F3                          div r11                     ; División para obtener la posición Y
  2719 00001766 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2720                                          
  2721 00001769 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2722                                          
  2723                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2724 00001770 41BD20000000                    mov r13, row_cells
  2725 00001776 4983ED02                        sub r13, 2                 ; Y de la paleta
  2726 0000177A 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2727 0000177D 7519                            jne .next_enemy
  2728                                          
  2729                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2730 0000177F 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2731 00001782 7C14                            jl .next_enemy
  2732                                          
  2733 00001784 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2734 00001787 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2735 0000178A 7F0C                            jg .next_enemy
  2736                                          
  2737                                          ; Si llegamos aquí, hay colisión con la paleta
  2738 0000178C E811000000                      call destroy_enemy        ; Destruir el enemigo
  2739 00001791 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2740 00001796 EB08                            jmp .end
  2741                                          
  2742                                      .next_enemy:
  2743 00001798 49FFC4                          inc r12
  2744 0000179B E90DFFFFFF                      jmp .check_loop
  2745                                          
  2746                                      .end:
  2747 000017A0 5D                              pop rbp
  2748 000017A1 C3                              ret
  2749                                  
  2750                                  ; Función para destruir un enemigo
  2751                                  destroy_enemy:
  2752                                      ; Desactivar enemigo
  2753 000017A2 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2754                                  
  2755                                      ; Sumar puntos por destruir enemigo
  2756 000017A6 488B05(97150000)            mov rax, [enemy_points]
  2757 000017AD 480105(56150000)            add [current_score], rax
  2758                                  
  2759                                      ; No tocar bloques destruidos aquí
  2760 000017B4 C3                          ret
  2761                                  
  2762                                  
  2763                                  _start:
  2764 000017B5 E871E9FFFF              	call canonical_off
  2765 000017BA E809010000              	call start_screen
  2766 000017BF E8B9F5FFFF                  call init_level
  2767 000017C4 E8FFFBFFFF                  call init_enemies
  2768 000017C9 EB00                    	jmp .main_loop
  2769                                  	
  2770                                  
  2771                                  	.main_loop:
  2772 000017CB E8B6F9FFFF                      call print_labels
  2773 000017D0 E8E5F8FFFF                      call print_blocks
  2774 000017D5 E89DECFFFF                      call move_letters
  2775 000017DA E8B0EEFFFF                      call update_lasers
  2776 000017DF E808ECFFFF                      call print_letters
  2777 000017E4 E8E5F1FFFF              		call print_pallet
  2778 000017E9 E8C8F2FFFF                      call move_ball
  2779 000017EE E8EBEAFFFF                      call check_bottom_collision
  2780 000017F3 E8E5E9FFFF                      call print_lives
  2781 000017F8 E81FF7FFFF                      call check_level_complete
  2782 000017FD E8DDFDFFFF                      call check_enemy_spawn
  2783 00001802 E8F5FBFFFF                      call move_enemies
  2784 00001807 E897FEFFFF                      call check_enemy_collision
  2785 0000180C E838FEFFFF                      call print_enemies
  2786 00001811 E890F1FFFF              		call print_ball
  2787                                  		print board, board_size				
    82 00001816 B801000000          <1>  mov eax, sys_write
    83 0000181B BF01000000          <1>  mov edi, 1
    84 00001820 48BE-               <1>  mov rsi, %1
    84 00001822 [000A000000000000]  <1>
    85 0000182A BA000A0000          <1>  mov edx, %2
    86 0000182F 0F05                <1>  syscall
  2788                                  		;setnonblocking	
  2789                                  	.read_more:	
  2790                                  	    getchar	
    90 00001831 B800000000          <1>  mov rax, sys_read
    91 00001836 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000183B 48BE-               <1>  mov rsi, input_char
    92 0000183D [0000000000000000]  <1>
    93 00001845 BA01000000          <1>  mov rdx, 1
    94 0000184A 0F05                <1>  syscall
  2791 0000184C 4883F801                	    cmp rax, 1
  2792 00001850 7543                    	    jne .done
  2793                                  	
  2794 00001852 8A05(00000000)          	    mov al, [input_char]
  2795 00001858 8805(1D180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2796                                  	
  2797 0000185E 3C61                    	    cmp al, 'a'
  2798 00001860 750E                    	    jne .not_left
  2799 00001862 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2800 00001869 E895F1FFFF              	    call move_pallet
  2801 0000186E EB25                    	    jmp .done
  2802                                  	
  2803                                      .not_left:
  2804 00001870 3C64                    	    cmp al, 'd'
  2805 00001872 750C                    	    jne .not_right
  2806 00001874 BF01000000              	    mov rdi, right_direction
  2807 00001879 E885F1FFFF              	    call move_pallet
  2808 0000187E EB15                    	    jmp .done
  2809                                  	
  2810                                      .not_right:
  2811 00001880 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2812 00001882 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2813                                  	
  2814 00001884 3C71                    	    cmp al, 'q' 
  2815 00001886 0F84AF000000            	    je exit
  2816 0000188C EBA3                    	    jmp .read_more
  2817                                  	
  2818                                      .release_ball:
  2819 0000188E E8F6F3FFFF              	    call process_catch_release
  2820 00001893 EB00                    	    jmp .done
  2821                                  	
  2822                                      .done:
  2823                                  	    sleeptime
    98 00001895 B823000000          <1>  mov eax, sys_nanosleep
    99 0000189A 48BF-               <1>  mov rdi, timespec
    99 0000189C [0000000000000000]  <1>
   100 000018A4 31F6                <1>  xor esi, esi
   101 000018A6 0F05                <1>  syscall
  2824                                  	    print clear, clear_length
    82 000018A8 B801000000          <1>  mov eax, sys_write
    83 000018AD BF01000000          <1>  mov edi, 1
    84 000018B2 48BE-               <1>  mov rsi, %1
    84 000018B4 [1000000000000000]  <1>
    85 000018BC BA07000000          <1>  mov edx, %2
    86 000018C1 0F05                <1>  syscall
  2825 000018C3 E903FFFFFF              	    jmp .main_loop
  2826                                  
  2827                                  
  2828                                  
  2829                                  
  2830                                  start_screen:
  2831                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000018C8 B801000000          <1>  mov eax, sys_write
    83 000018CD BF01000000          <1>  mov edi, 1
    84 000018D2 48BE-               <1>  mov rsi, %1
    84 000018D4 [1000000000000000]  <1>
    85 000018DC BA07000000          <1>  mov edx, %2
    86 000018E1 0F05                <1>  syscall
  2832                                      print msg1, msg1_length
    82 000018E3 B801000000          <1>  mov eax, sys_write
    83 000018E8 BF01000000          <1>  mov edi, 1
    84 000018ED 48BE-               <1>  mov rsi, %1
    84 000018EF [1700000000000000]  <1>
    85 000018F7 BA14010000          <1>  mov edx, %2
    86 000018FC 0F05                <1>  syscall
  2833                                      
  2834                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2835                                          getchar                 ; Esperamos una tecla
    90 000018FE B800000000          <1>  mov rax, sys_read
    91 00001903 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001908 48BE-               <1>  mov rsi, input_char
    92 0000190A [0000000000000000]  <1>
    93 00001912 BA01000000          <1>  mov rdx, 1
    94 00001917 0F05                <1>  syscall
  2836 00001919 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2837 0000191D 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2838                                          
  2839                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000191F B801000000          <1>  mov eax, sys_write
    83 00001924 BF01000000          <1>  mov edi, 1
    84 00001929 48BE-               <1>  mov rsi, %1
    84 0000192B [1000000000000000]  <1>
    85 00001933 BA07000000          <1>  mov edx, %2
    86 00001938 0F05                <1>  syscall
  2840 0000193A C3                          ret
  2841                                  
  2842                                  exit: 
  2843 0000193B E82DE8FFFF              	call canonical_on
  2844 00001940 B83C000000              	mov    rax, 60
  2845 00001945 BF00000000                  mov    rdi, 0
  2846 0000194A 0F05                        syscall
  2847                                  
