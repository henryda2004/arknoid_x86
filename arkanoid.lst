     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030244                      db 58, 7, 3, 2, 'D'    ; Bloque 7
   290 000014BB 3D09030145                      db 61, 9, 3, 1, 'E'    ; Bloque 7
   291 000014C0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   292                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   293                                  
   294                                      ; Nivel 2: Bloques de prueba
   295                                      level2_blocks:
   296 000014C5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   297                                      level2_blocks_count equ 1
   298                                  
   299                                      ; Nivel 3
   300                                      level3_blocks:
   301 000014CA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   302                                  
   303                                      level3_blocks_count equ 1
   304                                  
   305                                      ; Nivel 4
   306                                      level4_blocks:
   307 000014CF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   308                                      level4_blocks_count equ 1
   309                                  
   310                                      ; Nivel 5
   311                                      level5_blocks:
   312 000014D4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   313                                      level5_blocks_count equ 1
   314                                  
   315                                      ; Array para mantener el estado de los bloques
   316 000014D9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   317                                  
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153D 0000000000000000            current_score dq 0          ; Score actual
   321 00001545 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001546 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 0000155A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000157D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   331                                      
   332 0000157E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001586 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001587 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   335 00001588 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001589 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 0000158A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   339                                      ; Añade esto en la sección .dataa
   340 0000158B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   340 00001594 12                 
   341 00001595 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   341 0000159E 13                 
   342 0000159F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   342 000015A8 1B                 
   343 000015A9 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   343 000015B2 1C                 
   344 000015B3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   344 000015BC 2D                 
   345                                          ; Arreglo de punteros a los spawn points de cada nivel
   346                                      spawn_points_table:
   347 000015BD [8B15000000000000]              dq level1_spawn_points
   348 000015C5 [9515000000000000]              dq level2_spawn_points
   349 000015CD [9F15000000000000]              dq level3_spawn_points
   350 000015D5 [A915000000000000]              dq level4_spawn_points
   351 000015DD [B315000000000000]              dq level5_spawn_points
   352                                  
   353                                      ; Variables para el comportamiento de enemigos
   354 000015E5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   355 000015E6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   356 000015E7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   357 000015E8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   358                                  
   359 000015F2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   359 000015FB 5B2020202020202020-
   359 00001604 20205D0A0D         
   360                                      score_label_len: equ $ - score_label
   361 00001609 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   361 00001612 657374727569646F73-
   361 0000161B 3A205B2020205D0A0D 
   362                                      blocks_label_len: equ $ - blocks_label
   363                                      
   364                                      ; Posición donde insertar los números en los labels
   365                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   366                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   367                                      
   368                                      ; Definición de las vidas (x, y, estado)
   369                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   370                                      lives_data: 
   371 00001624 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   372 00001627 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   373 0000162A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   374 0000162D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   375 00001630 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   376 00001633 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   377 00001636 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   378                                      lives_count equ 7    ; Total de vidas
   379 00001639 5E                          life_char db "^"    
   380 0000163A 07                          current_lives db 7   ; Contador de vidas activas actual
   381                                  
   382                                  ; Estructura para almacenar las letras y sus posiciones
   383                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   384 0000163B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   385 000017CB 00                          letters_count db 0   
   386 000017CC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   387 000017CD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   387 000017D6 75616C3A205B205D0A-
   387 000017DF 0D                 
   388                                      last_letter_msg_len equ $ - last_letter_msg
   389                                  section .text
   390                                  
   391                                  
   392                                  print_lives:
   393 000001DD 55                          push rbp
   394 000001DE 4889E5                      mov rbp, rsp
   395                                      
   396 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   397                                      
   398                                      .print_loop:
   399 000001E4 4983FC07                        cmp r12, lives_count
   400 000001E8 7D45                            jge .end
   401                                          
   402                                          ; Calcular offset de la vida actual
   403 000001EA 4C89E0                          mov rax, r12
   404 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   405 000001F1 488DB0[24160000]                lea rsi, [lives_data + rax]
   406                                          
   407                                          ; Calcular posición en el tablero
   408 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   409 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   410                                          
   411                                          ; Calcular offset en el tablero
   412 00000201 B84E000000                      mov rax, column_cells
   413 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   414 0000020A 49F7E1                          mul r9
   415 0000020D 4C01C0                          add rax, r8
   416 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   417                                          
   418                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   419 00000217 807E0201                        cmp byte [rsi + 2], 1
   420 0000021B 7405                            je .draw_active
   421                                          
   422                                          ; Si está inactiva, dibujar espacio
   423 0000021D C60720                          mov byte [rdi], ' '
   424 00000220 EB08                            jmp .next_life
   425                                          
   426                                      .draw_active:
   427                                          ; Si está activa, dibujar el símbolo de vida
   428 00000222 8A05(39160000)                  mov al, [life_char]
   429 00000228 8807                            mov [rdi], al
   430                                          
   431                                      .next_life:
   432 0000022A 49FFC4                          inc r12
   433 0000022D EBB5                            jmp .print_loop
   434                                          
   435                                      .end:
   436 0000022F 5D                              pop rbp
   437 00000230 C3                              ret
   438                                  
   439                                  ; Función para desactivar una vida
   440                                  ; Función modificada para perder una vida
   441                                  lose_life:
   442 00000231 55                          push rbp
   443 00000232 4889E5                      mov rbp, rsp
   444                                      
   445                                      ; Verificar si aún quedan vidas
   446 00000235 803D(3A160000)00            cmp byte [current_lives], 0
   447 0000023C 0F8493000000                je .game_lost
   448                                      
   449                                      ; Encontrar la última vida activa
   450 00000242 B907000000                  mov rcx, lives_count
   451 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   452                                      
   453                                      .find_active_life:
   454 0000024A 4889C8                          mov rax, rcx
   455 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   456 00000251 488DB0[24160000]                lea rsi, [lives_data + rax]
   457 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   458 0000025C 7407                            je .deactivate_life
   459 0000025E 48FFC9                          dec rcx
   460 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   461 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   462                                          
   463                                      .deactivate_life:
   464                                          ; Calcular posición correcta en el tablero para borrar la vida
   465 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   466 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   467                                          
   468                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   469 0000026E B84E000000                      mov rax, column_cells
   470 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   471 00000277 49F7E1                          mul r9
   472 0000027A 4C01C0                          add rax, r8
   473 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   474                                          
   475                                          ; Borrar visualmente la vida
   476 00000284 C60720                          mov byte [rdi], ' '             
   477                                          
   478                                          ; Desactivar la vida en los datos
   479 00000287 C6460200                        mov byte [rsi + 2], 0          
   480 0000028B FE0D(3A160000)                  dec byte [current_lives]
   481                                          
   482                                          ; Borrar visualmente la paleta anterior
   483 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   484 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   485                                          .erase_pallet_loop:
   486 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   487 000002A3 49FFC0                              inc r8
   488 000002A6 48FFC9                              dec rcx
   489 000002A9 75F4                                jnz .erase_pallet_loop
   490                                          
   491                                  
   492                                          ; Reiniciar posición de la bola y la paleta
   493 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   493 000002B3 000000             
   494 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   494 000002BE 000000             
   495 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   496 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   496 000002CF [36130000]         
   497                                          
   498 000002D3 EB07                            jmp .end
   499                                          
   500                                      .game_lost:
   501 000002D5 E81C000000                      call game_lost
   502 000002DA EB00                            jmp .end
   503                                          
   504                                      .end:
   505 000002DC 5D                              pop rbp
   506 000002DD C3                              ret
   507                                  ; Función modificada para verificar colisión con el borde inferior
   508                                  check_bottom_collision:
   509 000002DE 55                          push rbp
   510 000002DF 4889E5                      mov rbp, rsp
   511                                      
   512                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   513 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   514 000002E9 4883F81E                    cmp rax, row_cells - 2
   515 000002ED 7505                        jne .no_collision
   516                                      
   517                                      ; Si hay colisión, perder una vida
   518 000002EF E83DFFFFFF                  call lose_life
   519                                      
   520                                      .no_collision:
   521 000002F4 5D                              pop rbp
   522 000002F5 C3                              ret
   523                                  
   524                                  ; Nueva función para game over
   525                                  game_lost:
   526                                      ; Limpiar la pantalla
   527                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   528                                      
   529                                      ; Mostrar mensaje de derrota
   530                                      section .data
   531 000017E0 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   531 000017E9 6469646F210A0D     
   532                                          lost_msg_len: equ $ - lost_msg
   533                                      section .text
   534                                      
   535                                      ; Imprimir mensaje de derrota
   536                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [E017000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   537                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [0E18000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   538                                      
   539                                      ; Mostrar puntaje final
   540 00000347 488B05(3D150000)            mov rax, [current_score]
   541 0000034E 48BF-                       mov rdi, number_buffer
   541 00000350 [4615000000000000] 
   542 00000358 E86F080000                  call number_to_string
   543                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   544                                      
   545                                      ; Esperar un momento antes de salir
   546 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   546 00000381 0000               
   547 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   547 0000038C 0000               
   548                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   549                                      
   550 000003A1 E904100000                  jmp exit
   551                                  
   552                                  
   553                                  ; Función para registrar una nueva letra en el mapa
   554                                  ; Entrada:
   555                                  ;   al - letra a registrar
   556                                  ;   r8b - posición x
   557                                  ;   r9b - posición y
   558                                  register_letter:
   559 000003A6 55                          push rbp
   560 000003A7 4889E5                      mov rbp, rsp
   561 000003AA 53                          push rbx
   562 000003AB 51                          push rcx
   563                                      
   564 000003AC 3C20                        cmp al, ' '
   565 000003AE 7438                        je .end
   566                                  
   567                                      ; Encontrar un espacio libre en el mapa
   568 000003B0 4831C9                      xor rcx, rcx
   569 000003B3 480FB615(CB170000)          movzx rdx, byte [letters_count]
   570                                      
   571                                      .find_slot:
   572 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   573 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   574                                          
   575 000003C1 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   576 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   577 000003CD 7405                            je .found_slot
   578                                          
   579 000003CF 48FFC1                          inc rcx
   580 000003D2 EBE7                            jmp .find_slot
   581                                          
   582                                      .found_slot:
   583                                          ; Guardar la información de la letra
   584 000003D4 448803                          mov [rbx], r8b           ; x
   585 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   586 000003DB 884302                          mov [rbx + 2], al        ; letra
   587 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   588                                          
   589 000003E2 FE05(CB170000)                  inc byte [letters_count]
   590                                          
   591                                      .end:
   592 000003E8 59                              pop rcx
   593 000003E9 5B                              pop rbx
   594 000003EA 5D                              pop rbp
   595 000003EB C3                              ret
   596                                  
   597                                  ; Función para imprimir todas las letras registradas
   598                                  print_letters:
   599 000003EC 55                          push rbp
   600 000003ED 4889E5                      mov rbp, rsp
   601 000003F0 53                          push rbx
   602 000003F1 51                          push rcx
   603                                      
   604 000003F2 4831C9                      xor rcx, rcx
   605                                      
   606                                      .print_loop:
   607 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   608 000003F9 7D37                            jge .end
   609                                          
   610                                          ; Obtener puntero a la letra actual
   611 000003FB 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   612                                          
   613                                          ; Verificar si está activa
   614 00000403 807B0300                        cmp byte [rbx + 3], 0
   615 00000407 7424                            je .next_letter
   616                                          
   617                                          ; Calcular posición en el tablero
   618 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   619 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   620                                          
   621                                          ; Calcular offset en el tablero
   622 00000412 B84E000000                      mov rax, column_cells
   623 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   624 0000041B 49F7E1                          mul r9
   625 0000041E 4C01C0                          add rax, r8
   626 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   627                                          
   628                                          ; Imprimir la letra
   629 00000428 8A4302                          mov al, [rbx + 2]
   630 0000042B 8807                            mov [rdi], al
   631                                          
   632                                      .next_letter:
   633 0000042D 48FFC1                          inc rcx
   634 00000430 EBC3                            jmp .print_loop
   635                                          
   636                                      .end:
   637 00000432 59                              pop rcx
   638 00000433 5B                              pop rbx
   639 00000434 5D                              pop rbp
   640 00000435 C3                              ret
   641                                  
   642                                  ; Función para borrar una letra específica
   643                                  ; Entrada:
   644                                  ;   r8b - posición x
   645                                  ;   r9b - posición y
   646                                  remove_letter:
   647 00000436 55                          push rbp
   648 00000437 4889E5                      mov rbp, rsp
   649 0000043A 53                          push rbx
   650 0000043B 51                          push rcx
   651                                      
   652 0000043C 4831C9                      xor rcx, rcx
   653                                      
   654                                      .find_loop:
   655 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   656 00000443 7D2E                            jge .end
   657                                          
   658 00000445 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   659                                          
   660                                          ; Verificar si está activa y coincide la posición
   661 0000044D 807B0300                        cmp byte [rbx + 3], 0
   662 00000451 741B                            je .next_letter
   663                                          
   664 00000453 8A03                            mov al, [rbx]
   665 00000455 4438C0                          cmp al, r8b
   666 00000458 7514                            jne .next_letter
   667                                          
   668 0000045A 8A4301                          mov al, [rbx + 1]
   669 0000045D 4438C8                          cmp al, r9b
   670 00000460 750C                            jne .next_letter
   671                                          
   672                                          ; Encontrada la letra, desactivarla
   673 00000462 C6430300                        mov byte [rbx + 3], 0
   674 00000466 FE0D(CB170000)                  dec byte [letters_count]
   675 0000046C EB05                            jmp .end
   676                                          
   677                                      .next_letter:
   678 0000046E 48FFC1                          inc rcx
   679 00000471 EBCC                            jmp .find_loop
   680                                          
   681                                      .end:
   682 00000473 59                              pop rcx
   683 00000474 5B                              pop rbx
   684 00000475 5D                              pop rbp
   685 00000476 C3                              ret
   686                                  ; Función para mover las letras hacia abajo
   687                                  move_letters:
   688 00000477 55                          push rbp
   689 00000478 4889E5                      mov rbp, rsp
   690 0000047B 53                          push rbx
   691 0000047C 57                          push rdi
   692 0000047D 56                          push rsi
   693                                  
   694 0000047E 4831C9                      xor rcx, rcx
   695                                  
   696                                      .move_loop:
   697 00000481 4883F964                        cmp rcx, 100
   698 00000485 0F8DA6000000                    jge .print_last_letter
   699                                          
   700 0000048B 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   701 00000493 807B0300                        cmp byte [rbx + 3], 0
   702 00000497 0F848C000000                    je .next_letter
   703                                  
   704 0000049D 4C0FB603                        movzx r8, byte [rbx]
   705 000004A1 4C0FB64B01                      movzx r9, byte [rbx + 1]
   706                                  
   707 000004A6 B84E000000                      mov rax, column_cells
   708 000004AB 4883C002                        add rax, 2
   709 000004AF 49F7E1                          mul r9
   710 000004B2 4C01C0                          add rax, r8
   711 000004B5 488DB8[000A0000]                lea rdi, [board + rax]
   712 000004BC C60720                          mov byte [rdi], ' '
   713                                  
   714 000004BF FE4301                          inc byte [rbx + 1]
   715 000004C2 4C0FB64B01                      movzx r9, byte [rbx + 1]
   716                                  
   717 000004C7 4983F91F                        cmp r9, row_cells - 1
   718 000004CB 7C06                            jl .check_pallet_collision
   719                                  
   720 000004CD C6430300                        mov byte [rbx + 3], 0
   721 000004D1 EB56                            jmp .next_letter
   722                                  
   723                                          .check_pallet_collision:
   724 000004D3 B84E000000                          mov rax, column_cells
   725 000004D8 4883C002                            add rax, 2
   726 000004DC 49F7E1                              mul r9
   727 000004DF 4C01C0                              add rax, r8
   728 000004E2 488DB8[000A0000]                    lea rdi, [board + rax]
   729                                  
   730 000004E9 8A07                                mov al, [rdi]
   731 000004EB 3C20                                cmp al, ' '
   732 000004ED 743A                                je .next_letter
   733 000004EF 3C3D                                cmp al, char_equal
   734 000004F1 7407                                je .capture_letter
   735                                  
   736 000004F3 8A4302                              mov al, [rbx + 2]
   737 000004F6 8807                                mov [rdi], al
   738 000004F8 EB2F                                jmp .next_letter
   739                                  
   740                                          .capture_letter:
   741 000004FA 8A4302                              mov al, [rbx + 2]
   742 000004FD 8805(CC170000)                      mov [last_letter], al
   743                                              
   744                                              ; Verificar si la letra es 'E'
   745 00000503 3C45                                cmp al, 'E'
   746 00000505 7410                                je .extend_pallet
   747                                              
   748                                              ; Si no es 'E', restaurar tamaño normal
   749 00000507 488B05(4F140000)                    mov rax, [default_pallet_size]
   750 0000050E 488905(47140000)                    mov [pallet_size], rax
   751 00000515 EB0E                                jmp .finish_capture
   752                                  
   753                                              .extend_pallet:
   754 00000517 488B05(57140000)                        mov rax, [extended_pallet_size]
   755 0000051E 488905(47140000)                        mov [pallet_size], rax
   756                                  
   757                                              .finish_capture:
   758 00000525 C6430300                                mov byte [rbx + 3], 0
   759                                  
   760                                          .next_letter:
   761 00000529 48FFC1                              inc rcx
   762 0000052C E950FFFFFF                          jmp .move_loop
   763                                  
   764                                      .print_last_letter:
   765                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000531 B801000000          <1>  mov eax, sys_write
    83 00000536 BF01000000          <1>  mov edi, 1
    84 0000053B 48BE-               <1>  mov rsi, %1
    84 0000053D [CD17000000000000]  <1>
    85 00000545 BA10000000          <1>  mov edx, %2
    86 0000054A 0F05                <1>  syscall
   766 0000054C 8A05(CC170000)                  mov al, [last_letter]
   767 00000552 8805(DC170000)                  mov [last_letter_msg + 15], al
   768                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000558 B801000000          <1>  mov eax, sys_write
    83 0000055D BF01000000          <1>  mov edi, 1
    84 00000562 48BE-               <1>  mov rsi, %1
    84 00000564 [DD17000000000000]  <1>
    85 0000056C BA03000000          <1>  mov edx, %2
    86 00000571 0F05                <1>  syscall
   769                                  
   770                                      .end:
   771 00000573 5E                              pop rsi
   772 00000574 5F                              pop rdi
   773 00000575 5B                              pop rbx
   774 00000576 5D                              pop rbp
   775 00000577 C3                              ret
   776                                  
   777                                  print_ball:
   778 00000578 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   779 0000057F 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   780 00000586 4981C0[000A0000]        	add r8, board
   781                                  
   782 0000058D 4C89C9                  	mov rcx, r9
   783 00000590 B850000000              	mov rax, column_cells + 2
   784 00000595 48F7E9                  	imul rcx
   785                                  	
   786 00000598 4901C0                  	add r8, rax
   787 0000059B 41C6004F                	mov byte [r8], char_O
   788 0000059F C3                      	ret
   789                                  
   790                                  	
   791                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   792                                  	
   793                                  print_pallet:
   794                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   795 000005A0 4C8B05(3F140000)            mov r8, [pallet_position]
   796 000005A7 488B0D(57140000)            mov rcx, [extended_pallet_size]
   797                                      .clear_pallet:
   798 000005AE 41C60020                        mov byte [r8], char_space
   799 000005B2 49FFC0                          inc r8
   800 000005B5 48FFC9                          dec rcx
   801 000005B8 75F4                            jnz .clear_pallet
   802                                  
   803                                      ; Luego dibujar la nueva paleta con el tamaño actual
   804 000005BA 4C8B05(3F140000)            mov r8, [pallet_position]
   805 000005C1 488B0D(47140000)            mov rcx, [pallet_size]
   806                                      .write_pallet:
   807 000005C8 41C6003D                        mov byte [r8], char_equal
   808 000005CC 49FFC0                          inc r8
   809 000005CF 48FFC9                          dec rcx
   810 000005D2 75F4                            jnz .write_pallet
   811                                  
   812 000005D4 C3                          ret
   813                                  
   814                                  move_pallet:
   815                                      
   816 000005D5 803D(7F140000)00            cmp byte [ball_moving], 0
   817 000005DC 7507                        jne .continue_movement
   818 000005DE C605(7F140000)01            mov byte [ball_moving], 1
   819                                  
   820                                      .continue_movement:
   821 000005E5 4883FFFF                        cmp rdi, left_direction
   822 000005E9 7531                            jne .move_right
   823                                  
   824                                          .move_left:
   825                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   826 000005EB 4C8B05(3F140000)                    mov r8, [pallet_position]
   827 000005F2 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   828 000005F5 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   829 000005F8 3C58                                cmp al, 'X'        ; Comparar si es una X
   830 000005FA 744D                                je .end            ; Si es X, no mover
   831                                              
   832 000005FC 4C8B05(3F140000)                    mov r8, [pallet_position]
   833 00000603 4C8B0D(47140000)                    mov r9, [pallet_size]
   834 0000060A 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   835 00000610 49FFC8                              dec r8
   836 00000613 4C8905(3F140000)                    mov [pallet_position], r8
   837 0000061A EB2D                                jmp .end
   838                                              
   839                                          .move_right:
   840                                              ; Verificar si la siguiente posición después de la paleta sería una X
   841 0000061C 4C8B05(3F140000)                    mov r8, [pallet_position]
   842 00000623 4C8B0D(47140000)                    mov r9, [pallet_size]
   843 0000062A 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   844 0000062D 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   845 00000630 3C58                                cmp al, 'X'        ; Comparar si es una X
   846 00000632 7415                                je .end            ; Si es X, no mover
   847                                              
   848 00000634 4C8B05(3F140000)                    mov r8, [pallet_position]
   849 0000063B 41C60020                            mov byte [r8], char_space
   850 0000063F 49FFC0                              inc r8
   851 00000642 4C8905(3F140000)                    mov [pallet_position], r8
   852                                          .end:
   853 00000649 C3                                  ret
   854                                  
   855                                  move_ball:
   856                                      ; Si la bola no está en movimiento, no hacer nada
   857 0000064A 803D(7F140000)00            cmp byte [ball_moving], 0
   858 00000651 0F8406010000                je .end
   859                                  
   860                                      ; Borrar la posición actual de la bola
   861 00000657 4C8B05(5F140000)            mov r8, [ball_x_pos]
   862 0000065E 4C8B0D(67140000)            mov r9, [ball_y_pos]
   863 00000665 4981C0[000A0000]            add r8, board
   864 0000066C 4C89C9                      mov rcx, r9
   865 0000066F B850000000                  mov rax, column_cells + 2
   866 00000674 48F7E9                      imul rcx
   867 00000677 4901C0                      add r8, rax
   868 0000067A 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   869                                  
   870                                      ; Calcular siguiente posición X
   871 0000067E 4C8B05(5F140000)            mov r8, [ball_x_pos]
   872 00000685 4C8B0D(67140000)            mov r9, [ball_y_pos]
   873 0000068C 488B05(6F140000)            mov rax, [ball_direction_x]
   874 00000693 4901C0                      add r8, rax                  ; Nueva posición X
   875                                  
   876                                      ; Calcular la dirección de memoria para la siguiente posición
   877 00000696 4D89C2                      mov r10, r8
   878 00000699 4981C2[000A0000]            add r10, board
   879 000006A0 4C89C9                      mov rcx, r9
   880 000006A3 B850000000                  mov rax, column_cells + 2
   881 000006A8 48F7E9                      imul rcx
   882 000006AB 4901C2                      add r10, rax
   883                                  
   884                                      ; Verificar si hay una X en la siguiente posición X
   885 000006AE 418A02                      mov al, [r10]
   886 000006B1 3C58                        cmp al, 'X'
   887 000006B3 750C                        jne .check_block_x
   888 000006B5 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   889 000006BC E99C000000                  jmp .end
   890                                  
   891                                      .check_block_x:
   892                                          ; Verificar colisión con bloques en X
   893 000006C1 4150                            push r8     ; Guardar registros que usa check_block_collision
   894 000006C3 4151                            push r9
   895 000006C5 4152                            push r10
   896 000006C7 E858060000                      call check_block_collision
   897 000006CC 415A                            pop r10
   898 000006CE 4159                            pop r9
   899 000006D0 4158                            pop r8
   900 000006D2 4885C0                          test rax, rax
   901 000006D5 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   902 000006D7 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   903 000006DE EB7D                            jmp .end
   904                                  
   905                                      .check_paddle_x:
   906                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   907 000006E0 41803A3D                        cmp byte [r10], char_equal
   908 000006E4 7509                            jne .check_y_movement
   909 000006E6 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   910 000006ED EB6E                            jmp .end
   911                                  
   912                                      .check_y_movement:
   913                                          ; Calcular siguiente posición Y
   914 000006EF 488B05(77140000)                mov rax, [ball_direction_y]
   915 000006F6 4901C1                          add r9, rax                  ; Nueva posición Y
   916                                  
   917                                          ; Calcular la dirección de memoria para la siguiente posición Y
   918 000006F9 4D89C2                          mov r10, r8
   919 000006FC 4981C2[000A0000]                add r10, board
   920 00000703 4C89C9                          mov rcx, r9
   921 00000706 B850000000                      mov rax, column_cells + 2
   922 0000070B 48F7E9                          imul rcx
   923 0000070E 4901C2                          add r10, rax
   924                                  
   925                                          ; Verificar si hay una X en la siguiente posición Y
   926 00000711 418A02                          mov al, [r10]
   927 00000714 3C58                            cmp al, 'X'
   928 00000716 7509                            jne .check_block_y
   929 00000718 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   930 0000071F EB3C                            jmp .end
   931                                  
   932                                      .check_block_y:
   933                                          ; Verificar colisión con bloques en Y
   934 00000721 4150                            push r8     ; Guardar registros que usa check_block_collision
   935 00000723 4151                            push r9
   936 00000725 4152                            push r10
   937 00000727 E8F8050000                      call check_block_collision
   938 0000072C 415A                            pop r10
   939 0000072E 4159                            pop r9
   940 00000730 4158                            pop r8
   941 00000732 4885C0                          test rax, rax
   942 00000735 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   943 00000737 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   944 0000073E EB1D                            jmp .end
   945                                  
   946                                      .check_paddle_y:
   947                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   948 00000740 41803A3D                    cmp byte [r10], char_equal
   949 00000744 7509                        jne .update_position
   950 00000746 48F71D(77140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   951 0000074D EB0E                        jmp .end
   952                                  
   953                                  
   954                                      .update_position:
   955 0000074F 4C8905(5F140000)                mov [ball_x_pos], r8
   956 00000756 4C890D(67140000)                mov [ball_y_pos], r9
   957                                  
   958                                      .end:
   959 0000075D C3                              ret
   960                                  
   961                                  ; Función para inicializar el nivel
   962                                  ; Función para inicializar el nivel
   963                                  ; Función para mostrar el número de nivel
   964                                  display_level_number:
   965 0000075E 55                          push rbp
   966 0000075F 4889E5                      mov rbp, rsp
   967                                      
   968                                      ; Limpiar la pantalla primero
   969                                      print clear, clear_length
    82 00000762 B801000000          <1>  mov eax, sys_write
    83 00000767 BF01000000          <1>  mov edi, 1
    84 0000076C 48BE-               <1>  mov rsi, %1
    84 0000076E [1000000000000000]  <1>
    85 00000776 BA07000000          <1>  mov edx, %2
    86 0000077B 0F05                <1>  syscall
   970                                      
   971                                      ; Calcular la posición central para el mensaje
   972                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   973 0000077D B84E000000                  mov rax, column_cells
   974 00000782 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   975 00000786 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   976                                      
   977                                      ; Calcular la fila central
   978 00000789 BB20000000                  mov rbx, row_cells
   979 0000078E 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   980                                      
   981                                      ; Calcular el offset en el buffer
   982 00000791 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   983 00000796 48F7E3                      mul rbx                     ; multiplicar por la fila central
   984 00000799 4801D8                      add rax, rbx                ; añadir el offset horizontal
   985                                      
   986                                      ; Escribir "NIVEL " en la posición calculada
   987 0000079C 488DB8[000A0000]            lea rdi, [board + rax]
   988 000007A3 48BE-                       mov rsi, level_msg
   988 000007A5 [2414000000000000] 
   989 000007AD B906000000                  mov rcx, level_msg_len
   990 000007B2 F3A4                        rep movsb
   991                                      
   992                                      ; Escribir el número del nivel
   993 000007B4 8A05(B4140000)              mov al, [current_level]
   994 000007BA 0430                        add al, '0'                 ; convertir a ASCII
   995 000007BC 8807                        mov [rdi], al
   996                                      
   997                                      ; Mostrar el board con el mensaje
   998                                      print board, board_size
    82 000007BE B801000000          <1>  mov eax, sys_write
    83 000007C3 BF01000000          <1>  mov edi, 1
    84 000007C8 48BE-               <1>  mov rsi, %1
    84 000007CA [000A000000000000]  <1>
    85 000007D2 BA000A0000          <1>  mov edx, %2
    86 000007D7 0F05                <1>  syscall
   999                                      
  1000                                      ; Esperar un segundo
  1001 000007D9 B823000000                  mov rax, sys_nanosleep
  1002 000007DE 48BF-                       mov rdi, level_display_time
  1002 000007E0 [2F14000000000000] 
  1003 000007E8 4831F6                      xor rsi, rsi
  1004 000007EB 0F05                        syscall
  1005                                      
  1006 000007ED 5D                          pop rbp
  1007 000007EE C3                          ret
  1008                                  
  1009                                  ; Función para inicializar un tablero vacío
  1010                                  init_empty_board:
  1011 000007EF 56                          push rsi
  1012 000007F0 57                          push rdi
  1013 000007F1 51                          push rcx
  1014 000007F2 50                          push rax
  1015                                  
  1016 000007F3 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1017 000007FA 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1018 00000801 B9000A0000                  mov rcx, board_template_size
  1019 00000806 F3A4                        rep movsb                   ; Copiar el tablero
  1020                                  
  1021 00000808 58                          pop rax
  1022 00000809 59                          pop rcx
  1023 0000080A 5F                          pop rdi
  1024 0000080B 5E                          pop rsi
  1025 0000080C C3                          ret
  1026                                  
  1027                                  
  1028                                  init_level:
  1029                                  
  1030 0000080D 488B05(4F140000)            mov rax, [default_pallet_size]
  1031 00000814 488905(47140000)            mov [pallet_size], rax
  1032                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1033                                          ; Reiniciar letras activas
  1034 0000081B 488D3D(3B160000)            lea rdi, [letters_map]
  1035 00000822 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1036 00000827 4831C0                      xor rax, rax
  1037 0000082A F3AA                        rep stosb                    ; Llenar con ceros
  1038                                      
  1039                                      ; Inicializar dirección de la bola (derecha y arriba)
  1040 0000082C 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1040 00000834 000000             
  1041 00000837 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1041 0000083F FFFFFF             
  1042                                  
  1043                                  
  1044                                      ; Reiniciar contador de letras activas
  1045 00000842 4831C0                      xor rax, rax
  1046 00000845 8805(CB170000)              mov [letters_count], al
  1047                                  
  1048                                      ; Reiniciar última letra capturada
  1049 0000084B C605(CC170000)20            mov byte [last_letter], ' '
  1050 00000852 C605(45150000)00            mov byte [destroyed_blocks], 0 
  1051 00000859 E891FFFFFF                  call init_empty_board
  1052 0000085E E8FBFEFFFF                  call display_level_number
  1053 00000863 E8E5050000                  call init_enemies
  1054                                      
  1055 00000868 56                          push rsi
  1056 00000869 57                          push rdi
  1057 0000086A 51                          push rcx
  1058 0000086B 50                          push rax
  1059                                  
  1060 0000086C 488D35(00000000)            lea rsi, [board_template]
  1061 00000873 488D3D(000A0000)            lea rdi, [board]
  1062 0000087A B9000A0000                  mov rcx, board_template_size
  1063 0000087F F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1064                                  
  1065 00000881 58                          pop rax
  1066 00000882 59                          pop rcx
  1067 00000883 5F                          pop rdi
  1068 00000884 5E                          pop rsi
  1069                                  
  1070 00000885 B90A000000                  mov rcx, 10
  1071 0000088A 4831C0                      xor rax, rax
  1072 0000088D 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1073 00000894 F3AA                        rep stosb      
  1074                                  
  1075                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1076 00000896 803D(B4140000)01            cmp byte [current_level], 1
  1077 0000089D 7431                        je .level1
  1078 0000089F 803D(B4140000)02            cmp byte [current_level], 2
  1079 000008A6 7454                        je .level2
  1080 000008A8 803D(B4140000)03            cmp byte [current_level], 3
  1081 000008AF 7477                        je .level3
  1082 000008B1 803D(B4140000)04            cmp byte [current_level], 4
  1083 000008B8 0F8492000000                je .level4
  1084 000008BE 803D(B4140000)05            cmp byte [current_level], 5
  1085 000008C5 0F84AD000000                je .level5
  1086 000008CB E9D0000000                  jmp .done
  1087                                  
  1088                                  
  1089                                  
  1090                                      .level1:
  1091 000008D0 C605(B5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1092 000008D7 4831C9                          xor rcx, rcx             
  1093                                          .init_loop1:
  1094 000008DA 4883F903                            cmp rcx, level1_blocks_count
  1095 000008DE 0F8DBC000000                        jge .done
  1096 000008E4 4889C8                              mov rax, rcx         
  1097 000008E7 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1098 000008EB 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1099 000008F1 8891[D9140000]                      mov byte [block_states + rcx], dl
  1100 000008F7 48FFC1                              inc rcx
  1101 000008FA EBDE                                jmp .init_loop1
  1102                                  
  1103                                      .level2:
  1104 000008FC C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1105 00000903 4831C9                          xor rcx, rcx             
  1106                                          .init_loop2:
  1107 00000906 4883F901                            cmp rcx, level2_blocks_count
  1108 0000090A 0F8D90000000                        jge .done
  1109 00000910 4889C8                              mov rax, rcx         
  1110 00000913 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1111 00000917 8A90[C8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1112 0000091D 8891[D9140000]                      mov byte [block_states + rcx], dl
  1113 00000923 48FFC1                              inc rcx
  1114 00000926 EBDE                                jmp .init_loop2
  1115                                      .level3:
  1116 00000928 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1117 0000092F 4831C9                          xor rcx, rcx             
  1118                                          .init_loop3:
  1119 00000932 4883F901                            cmp rcx, level3_blocks_count
  1120 00000936 7D68                                jge .done
  1121 00000938 4889C8                              mov rax, rcx         
  1122 0000093B 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1123 0000093F 8A90[CD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1124 00000945 8891[D9140000]                      mov byte [block_states + rcx], dl
  1125 0000094B 48FFC1                              inc rcx
  1126 0000094E EBE2                                jmp .init_loop3
  1127                                  
  1128                                      .level4:
  1129 00000950 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1130 00000957 4831C9                          xor rcx, rcx             
  1131                                          .init_loop4:
  1132 0000095A 4883F901                            cmp rcx, level4_blocks_count
  1133 0000095E 7D40                                jge .done
  1134 00000960 4889C8                              mov rax, rcx         
  1135 00000963 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1136 00000967 8A90[D2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1137 0000096D 8891[D9140000]                      mov byte [block_states + rcx], dl
  1138 00000973 48FFC1                              inc rcx
  1139 00000976 EBE2                                jmp .init_loop4
  1140                                  
  1141                                      .level5:
  1142 00000978 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1143 0000097F 4831C9                          xor rcx, rcx             
  1144                                          .init_loop5:
  1145 00000982 4883F901                            cmp rcx, level5_blocks_count
  1146 00000986 7D18                                jge .done
  1147 00000988 4889C8                              mov rax, rcx         
  1148 0000098B 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1149 0000098F 8A90[D7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1150 00000995 8891[D9140000]                      mov byte [block_states + rcx], dl
  1151 0000099B 48FFC1                              inc rcx
  1152 0000099E EBE2                                jmp .init_loop5
  1153                                      .done:
  1154 000009A0 C3                              ret
  1155                                  
  1156                                  
  1157                                  ; Función para verificar y manejar la transición de nivel
  1158                                  check_level_complete:
  1159                                      ; Verificar si quedan bloques
  1160 000009A1 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1161 000009A8 753C                        jne .not_complete
  1162                                      
  1163                                      ; Incrementar el nivel
  1164 000009AA FE05(B4140000)              inc byte [current_level]
  1165                                      
  1166                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1167 000009B0 803D(B4140000)06            cmp byte [current_level], 6
  1168 000009B7 742E                        je game_win
  1169                                      
  1170                                      ; Reinicializar el juego para el siguiente nivel
  1171 000009B9 E84FFEFFFF                  call init_level
  1172                                      
  1173                                      ; Reinicializar la posición de la bola y la paleta
  1174 000009BE 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1174 000009C6 000000             
  1175 000009C9 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1175 000009D1 000000             
  1176 000009D4 C605(7F140000)00            mov byte [ball_moving], 0
  1177 000009DB 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1177 000009E2 [36130000]         
  1178                                      
  1179                                      .not_complete:
  1180 000009E6 C3                              ret
  1181                                  
  1182                                      ; Nueva función para manejar la victoria del juego
  1183                                  game_win:
  1184                                      ; Limpiar la pantalla primero
  1185                                      print clear, clear_length
    82 000009E7 B801000000          <1>  mov eax, sys_write
    83 000009EC BF01000000          <1>  mov edi, 1
    84 000009F1 48BE-               <1>  mov rsi, %1
    84 000009F3 [1000000000000000]  <1>
    85 000009FB BA07000000          <1>  mov edx, %2
    86 00000A00 0F05                <1>  syscall
  1186                                      
  1187                                      ; Mensaje de victoria
  1188 00000A02 488B05(3D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1189 00000A09 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1189 00000A0B [4615000000000000] 
  1190 00000A13 E8B4010000                  call number_to_string
  1191                                      
  1192                                      ; Definir mensaje de victoria
  1193                                      section .data
  1194 000017F0 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1194 000017F9 616465732120C2A148-
  1194 00001802 61732067616E61646F-
  1194 0000180B 210A0D             
  1195                                          win_msg_len: equ $ - win_msg
  1196 0000180E 50756E74616A652066-             score_msg: db "Puntaje final: "
  1196 00001817 696E616C3A20       
  1197                                          score_msg_len: equ $ - score_msg
  1198                                      section .text
  1199                                      
  1200                                      ; Imprimir mensajes
  1201                                      print win_msg, win_msg_len
    82 00000A18 B801000000          <1>  mov eax, sys_write
    83 00000A1D BF01000000          <1>  mov edi, 1
    84 00000A22 48BE-               <1>  mov rsi, %1
    84 00000A24 [F017000000000000]  <1>
    85 00000A2C BA1E000000          <1>  mov edx, %2
    86 00000A31 0F05                <1>  syscall
  1202                                      print score_msg, score_msg_len
    82 00000A33 B801000000          <1>  mov eax, sys_write
    83 00000A38 BF01000000          <1>  mov edi, 1
    84 00000A3D 48BE-               <1>  mov rsi, %1
    84 00000A3F [0E18000000000000]  <1>
    85 00000A47 BA0F000000          <1>  mov edx, %2
    86 00000A4C 0F05                <1>  syscall
  1203                                      print number_buffer, 20
    82 00000A4E B801000000          <1>  mov eax, sys_write
    83 00000A53 BF01000000          <1>  mov edi, 1
    84 00000A58 48BE-               <1>  mov rsi, %1
    84 00000A5A [4615000000000000]  <1>
    85 00000A62 BA14000000          <1>  mov edx, %2
    86 00000A67 0F05                <1>  syscall
  1204                                      
  1205                                      ; Esperar un momento antes de salir
  1206 00000A69 48C7058CF5FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1206 00000A72 0000               
  1207 00000A74 48C70589F5FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1207 00000A7D 0000               
  1208                                      sleeptime
    98 00000A7F B823000000          <1>  mov eax, sys_nanosleep
    99 00000A84 48BF-               <1>  mov rdi, timespec
    99 00000A86 [0000000000000000]  <1>
   100 00000A8E 31F6                <1>  xor esi, esi
   101 00000A90 0F05                <1>  syscall
  1209                                      
  1210 00000A92 E913090000                  jmp exit
  1211                                  
  1212                                  ; Función para imprimir los bloques
  1213                                  ; Función modificada para imprimir bloques
  1214                                  
  1215                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1216                                  get_current_level_blocks:
  1217 00000A97 803D(B4140000)01            cmp byte [current_level], 1
  1218 00000A9E 7428                        je .level1
  1219 00000AA0 803D(B4140000)02            cmp byte [current_level], 2
  1220 00000AA7 7427                        je .level2
  1221 00000AA9 803D(B4140000)03            cmp byte [current_level], 3
  1222 00000AB0 7426                        je .level3
  1223 00000AB2 803D(B4140000)04            cmp byte [current_level], 4
  1224 00000AB9 7425                        je .level4
  1225 00000ABB 803D(B4140000)05            cmp byte [current_level], 5
  1226 00000AC2 7424                        je .level5
  1227                                      ; Si llegamos aquí, hay un error en el nivel
  1228 00000AC4 4831C0                      xor rax, rax
  1229 00000AC7 C3                          ret
  1230                                  
  1231                                      .level1:
  1232 00000AC8 488D05(B6140000)                lea rax, [level1_blocks]
  1233 00000ACF C3                              ret
  1234                                      .level2:
  1235 00000AD0 488D05(C5140000)                lea rax, [level2_blocks]
  1236 00000AD7 C3                              ret
  1237                                      .level3:
  1238 00000AD8 488D05(CA140000)                lea rax, [level3_blocks]
  1239 00000ADF C3                              ret
  1240                                      .level4:
  1241 00000AE0 488D05(CF140000)                lea rax, [level4_blocks]
  1242 00000AE7 C3                              ret
  1243                                      .level5:
  1244 00000AE8 488D05(D4140000)                lea rax, [level5_blocks]
  1245 00000AEF C3                              ret
  1246                                  ; Función para obtener la cantidad de bloques del nivel actual
  1247                                  get_current_level_count:
  1248 00000AF0 803D(B4140000)01            cmp byte [current_level], 1
  1249 00000AF7 7428                        je .level1
  1250 00000AF9 803D(B4140000)02            cmp byte [current_level], 2
  1251 00000B00 7425                        je .level2
  1252 00000B02 803D(B4140000)03            cmp byte [current_level], 3
  1253 00000B09 7422                        je .level3
  1254 00000B0B 803D(B4140000)04            cmp byte [current_level], 4
  1255 00000B12 741F                        je .level4
  1256 00000B14 803D(B4140000)05            cmp byte [current_level], 5
  1257 00000B1B 741C                        je .level5
  1258                                      ; Si llegamos aquí, hay un error en el nivel
  1259 00000B1D 4831C0                      xor rax, rax
  1260 00000B20 C3                          ret
  1261                                  
  1262                                      .level1:
  1263 00000B21 B803000000                      mov rax, level1_blocks_count
  1264 00000B26 C3                              ret
  1265                                      .level2:
  1266 00000B27 B801000000                      mov rax, level2_blocks_count
  1267 00000B2C C3                              ret
  1268                                      .level3:
  1269 00000B2D B801000000                      mov rax, level3_blocks_count
  1270 00000B32 C3                              ret
  1271                                      .level4:
  1272 00000B33 B801000000                      mov rax, level4_blocks_count
  1273 00000B38 C3                              ret
  1274                                      .level5:
  1275 00000B39 B801000000                      mov rax, level5_blocks_count
  1276 00000B3E C3                              ret
  1277                                  
  1278                                  
  1279                                  print_blocks:
  1280 00000B3F 55                          push rbp
  1281 00000B40 4889E5                      mov rbp, rsp
  1282                                      
  1283                                      ; Obtener puntero a los bloques del nivel actual
  1284 00000B43 E84FFFFFFF                  call get_current_level_blocks
  1285 00000B48 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1286                                      
  1287                                      ; Obtener cantidad de bloques del nivel actual
  1288 00000B4B E8A0FFFFFF                  call get_current_level_count
  1289 00000B50 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1290                                      
  1291 00000B53 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1292                                      
  1293                                      .print_loop:
  1294 00000B56 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1295 00000B59 7D6F                            jge .end
  1296                                          
  1297                                          ; Verificar si el bloque está activo
  1298 00000B5B 490FB68424-                     movzx rax, byte [block_states + r12]
  1298 00000B60 [D9140000]         
  1299 00000B64 4885C0                          test rax, rax
  1300 00000B67 745C                            jz .next_block
  1301                                          
  1302                                          ; Obtener posición y tipo del bloque usando r13
  1303 00000B69 4C89E0                          mov rax, r12
  1304 00000B6C 486BC005                        imul rax, 5
  1305 00000B70 4C01E8                          add rax, r13
  1306 00000B73 448A00                          mov r8b, [rax]        ; X position
  1307 00000B76 448A4801                        mov r9b, [rax + 1]    ; Y position
  1308 00000B7A 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1309                                  
  1310                                          ; El resto de la lógica de impresión permanece igual
  1311 00000B7E 4D0FB6C0                        movzx r8, r8b
  1312 00000B82 4D0FB6C9                        movzx r9, r9b
  1313 00000B86 4981C0[000A0000]                add r8, board
  1314 00000B8D B850000000                      mov rax, column_cells + 2
  1315 00000B92 49F7E1                          mul r9
  1316 00000B95 4901C0                          add r8, rax
  1317                                          
  1318 00000B98 B906000000                      mov rcx, block_length
  1319 00000B9D 48BE-                           mov rsi, block_type_1
  1319 00000B9F [9014000000000000] 
  1320 00000BA7 490FB6C2                        movzx rax, r10b
  1321 00000BAB 48FFC8                          dec rax
  1322 00000BAE 486BC006                        imul rax, block_length
  1323 00000BB2 4801C6                          add rsi, rax
  1324                                          
  1325                                      .print_block_chars:
  1326 00000BB5 8A06                            mov al, [rsi]
  1327 00000BB7 418800                          mov [r8], al
  1328 00000BBA 48FFC6                          inc rsi
  1329 00000BBD 49FFC0                          inc r8
  1330 00000BC0 48FFC9                          dec rcx
  1331 00000BC3 75F0                            jnz .print_block_chars
  1332                                          
  1333                                      .next_block:
  1334 00000BC5 49FFC4                          inc r12
  1335 00000BC8 EB8C                            jmp .print_loop
  1336                                          
  1337                                      .end:
  1338 00000BCA 5D                              pop rbp
  1339 00000BCB C3                              ret
  1340                                  
  1341                                  ; Función para convertir número a string
  1342                                  ; Input: RAX = número a convertir
  1343                                  ; RDI = buffer donde escribir el string
  1344                                  number_to_string:
  1345 00000BCC 53                          push rbx
  1346 00000BCD 52                          push rdx
  1347 00000BCE 56                          push rsi
  1348 00000BCF BB0A000000                  mov rbx, 10          ; Divisor
  1349 00000BD4 B900000000                  mov rcx, 0          ; Contador de dígitos
  1350                                      
  1351                                      ; Si el número es 0, manejarlo especialmente
  1352 00000BD9 4885C0                      test rax, rax
  1353 00000BDC 7509                        jnz .convert_loop
  1354 00000BDE C60730                      mov byte [rdi], '0'
  1355 00000BE1 C6470100                    mov byte [rdi + 1], 0
  1356 00000BE5 EB20                        jmp .end
  1357                                      
  1358                                      .convert_loop:
  1359 00000BE7 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1360 00000BEA 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1361 00000BED 80C230                          add dl, '0'     ; Convertir a ASCII
  1362 00000BF0 52                              push rdx        ; Guardar el dígito
  1363 00000BF1 48FFC1                          inc rcx         ; Incrementar contador
  1364 00000BF4 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1365 00000BF7 75EE                            jnz .convert_loop
  1366                                          
  1367                                      .write_loop:
  1368 00000BF9 5A                              pop rdx         ; Obtener dígito
  1369 00000BFA 8817                            mov [rdi], dl   ; Escribir al buffer
  1370 00000BFC 48FFC7                          inc rdi         ; Siguiente posición
  1371 00000BFF 48FFC9                          dec rcx         ; Decrementar contador
  1372 00000C02 75F5                            jnz .write_loop
  1373                                          
  1374 00000C04 C60700                      mov byte [rdi], 0   ; Null terminator
  1375                                      
  1376                                      .end:
  1377 00000C07 5E                          pop rsi
  1378 00000C08 5A                          pop rdx
  1379 00000C09 5B                          pop rbx
  1380 00000C0A C3                          ret
  1381                                  
  1382                                  ; Función para imprimir los labels
  1383                                  print_labels:
  1384 00000C0B 55                          push rbp
  1385 00000C0C 4889E5                      mov rbp, rsp
  1386                                  
  1387                                      ; Crear buffer temporal
  1388 00000C0F 4883EC20                    sub rsp, 32
  1389                                  
  1390                                      ; Copiar labels a buffer temporal
  1391 00000C13 4889E7                      mov rdi, rsp
  1392 00000C16 488D35(F2150000)            lea rsi, [score_label]
  1393 00000C1D B917000000                  mov rcx, score_label_len
  1394 00000C22 F3A4                        rep movsb
  1395                                  
  1396                                      ; Convertir score a string
  1397 00000C24 488B05(3D150000)            mov rax, [current_score]
  1398 00000C2B 48BF-                       mov rdi, number_buffer
  1398 00000C2D [4615000000000000] 
  1399 00000C35 E892FFFFFF                  call number_to_string
  1400                                  
  1401                                      ; Calcular longitud del número
  1402 00000C3A B900000000                  mov rcx, 0
  1403 00000C3F 48BF-                       mov rdi, number_buffer
  1403 00000C41 [4615000000000000] 
  1404                                      .count_loop:
  1405 00000C49 803C0F00                        cmp byte [rdi + rcx], 0
  1406 00000C4D 7405                            je .count_done
  1407 00000C4F 48FFC1                          inc rcx
  1408 00000C52 EBF5                            jmp .count_loop
  1409                                      .count_done:
  1410                                  
  1411                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1412 00000C54 4889E7                      mov rdi, rsp
  1413 00000C57 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1414 00000C5B BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1415 00000C60 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1416                                      .pad_loop:
  1417 00000C63 4885F6                          test rsi, rsi
  1418 00000C66 740B                            jz .pad_done
  1419 00000C68 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1420 00000C6B 48FFC7                          inc rdi
  1421 00000C6E 48FFCE                          dec rsi
  1422 00000C71 EBF0                            jmp .pad_loop
  1423                                      .pad_done:
  1424                                  
  1425                                      ; Copiar el número
  1426 00000C73 48BE-                       mov rsi, number_buffer
  1426 00000C75 [4615000000000000] 
  1427 00000C7D F3A4                        rep movsb
  1428                                  
  1429                                      ; Imprimir el buffer completo
  1430                                      print rsp, score_label_len
    82 00000C7F B801000000          <1>  mov eax, sys_write
    83 00000C84 BF01000000          <1>  mov edi, 1
    84 00000C89 4889E6              <1>  mov rsi, %1
    85 00000C8C BA17000000          <1>  mov edx, %2
    86 00000C91 0F05                <1>  syscall
  1431                                  
  1432                                      ; Repetir proceso para bloques destruidos
  1433 00000C93 4889E7                      mov rdi, rsp
  1434 00000C96 488D35(09160000)            lea rsi, [blocks_label]
  1435 00000C9D B91B000000                  mov rcx, blocks_label_len
  1436 00000CA2 F3A4                        rep movsb
  1437                                  
  1438                                      ; Verificar que el `[` esté en su posición correcta
  1439 00000CA4 4889E7                      mov rdi, rsp
  1440 00000CA7 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1441 00000CAB C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1442                                  
  1443                                      ; Convertir bloques destruidos a string
  1444 00000CAE 480FB605(45150000)          movzx rax, byte [destroyed_blocks]
  1445 00000CB6 48BF-                       mov rdi, number_buffer
  1445 00000CB8 [4615000000000000] 
  1446 00000CC0 E807FFFFFF                  call number_to_string
  1447                                  
  1448                                      ; Calcular longitud del número
  1449 00000CC5 B900000000                  mov rcx, 0
  1450 00000CCA 48BF-                       mov rdi, number_buffer
  1450 00000CCC [4615000000000000] 
  1451                                      .count_loop2:
  1452 00000CD4 803C0F00                        cmp byte [rdi + rcx], 0
  1453 00000CD8 7405                            je .count_done2
  1454 00000CDA 48FFC1                          inc rcx
  1455 00000CDD EBF5                            jmp .count_loop2
  1456                                      .count_done2:
  1457                                  
  1458                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1459 00000CDF 4889E7                      mov rdi, rsp
  1460 00000CE2 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1461 00000CE6 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1462 00000CEB 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1463                                      .pad_loop2:
  1464 00000CEE 4885F6                          test rsi, rsi
  1465 00000CF1 740B                            jz .pad_done2
  1466 00000CF3 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1467 00000CF6 48FFC7                          inc rdi
  1468 00000CF9 48FFCE                          dec rsi
  1469 00000CFC EBF0                            jmp .pad_loop2
  1470                                      .pad_done2:
  1471                                  
  1472                                      ; Copiar el número
  1473 00000CFE 48BE-                       mov rsi, number_buffer
  1473 00000D00 [4615000000000000] 
  1474 00000D08 F3A4                        rep movsb
  1475                                  
  1476                                      ; Imprimir el buffer completo
  1477                                      print rsp, blocks_label_len
    82 00000D0A B801000000          <1>  mov eax, sys_write
    83 00000D0F BF01000000          <1>  mov edi, 1
    84 00000D14 4889E6              <1>  mov rsi, %1
    85 00000D17 BA1B000000          <1>  mov edx, %2
    86 00000D1C 0F05                <1>  syscall
  1478                                  
  1479                                      ; Restaurar stack
  1480 00000D1E 4883C420                    add rsp, 32
  1481 00000D22 5D                          pop rbp
  1482 00000D23 C3                          ret
  1483                                  
  1484                                  
  1485                                  
  1486                                  check_block_collision:
  1487 00000D24 55                          push rbp
  1488 00000D25 4889E5                      mov rbp, rsp
  1489                                  
  1490                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1491 00000D28 418A02                      mov al, [r10]
  1492                                  
  1493                                      ; Verificar si el carácter es un bloque
  1494 00000D2B 3C55                        cmp al, 'U'  
  1495 00000D2D 7419                        je .possible
  1496 00000D2F 3C4F                        cmp al, 'O'  
  1497 00000D31 7415                        je .possible
  1498 00000D33 3C44                        cmp al, 'D'  
  1499 00000D35 7411                        je .possible
  1500 00000D37 3C4C                        cmp al, 'L'  
  1501 00000D39 740D                        je .possible
  1502 00000D3B 3C56                        cmp al, 'V'  
  1503 00000D3D 7409                        je .possible
  1504 00000D3F 3C38                        cmp al, '8'  
  1505 00000D41 7405                        je .possible
  1506                                  
  1507                                      ; No es bloque, salir
  1508 00000D43 4831C0                      xor rax, rax
  1509 00000D46 5D                          pop rbp
  1510 00000D47 C3                          ret
  1511                                  
  1512                                  .possible:
  1513 00000D48 53                          push rbx
  1514 00000D49 57                          push rdi
  1515 00000D4A 56                          push rsi
  1516 00000D4B 4154                        push r12
  1517 00000D4D 4155                        push r13
  1518 00000D4F 4156                        push r14
  1519 00000D51 4157                        push r15
  1520                                  
  1521                                      ; 1) Obtener base de los bloques del nivel actual
  1522 00000D53 E83FFDFFFF                  call get_current_level_blocks
  1523 00000D58 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1524                                  
  1525                                      ; 2) Obtener la cantidad de bloques
  1526 00000D5B E890FDFFFF                  call get_current_level_count
  1527 00000D60 4989C6                      mov r14, rax
  1528                                  
  1529 00000D63 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1530                                  
  1531                                  .find_block_loop:
  1532 00000D66 4D39F4                      cmp r12, r14
  1533 00000D69 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1534                                  
  1535                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1536 00000D6F 4C89E0                      mov rax, r12
  1537 00000D72 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1538 00000D76 4C01E8                      add rax, r13
  1539 00000D79 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1540                                  
  1541                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1542 00000D7C 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1542 00000D81 [D9140000]         
  1543 00000D85 4885DB                      test rbx, rbx
  1544 00000D88 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1545                                  
  1546                                      ; Obtener coordenadas
  1547 00000D8E 418A17                      mov dl, [r15]         ; x
  1548 00000D91 418A4F01                    mov cl, [r15 + 1]     ; y
  1549                                  
  1550                                      ; Calcular posición en el board
  1551 00000D95 488D3D(000A0000)            lea rdi, [board]
  1552 00000D9C 4831C0                      xor rax, rax
  1553 00000D9F B84E000000                  mov rax, column_cells
  1554 00000DA4 4883C002                    add rax, 2
  1555 00000DA8 480FB6C9                    movzx rcx, cl         ; y
  1556 00000DAC 480FAFC1                    imul rax, rcx
  1557 00000DB0 4801C7                      add rdi, rax
  1558 00000DB3 480FB6C2                    movzx rax, dl         ; x
  1559 00000DB7 4801C7                      add rdi, rax
  1560                                  
  1561                                      ; Guardar la posición base del bloque
  1562 00000DBA 57                          push rdi
  1563                                  
  1564                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1565 00000DBB 4939FA                      cmp r10, rdi
  1566 00000DBE 7274                        jb .skip_collision
  1567 00000DC0 488D5F06                    lea rbx, [rdi + block_length]
  1568 00000DC4 4939DA                      cmp r10, rbx
  1569 00000DC7 736B                        jae .skip_collision
  1570                                  
  1571                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1572 00000DC9 41FE8C24[D9140000]          dec byte [block_states + r12]
  1573                                      ; Volver a cargar durabilidad
  1574 00000DD1 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1574 00000DD6 [D9140000]         
  1575 00000DDA 4885DB                      test rbx, rbx
  1576 00000DDD 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1577                                  
  1578                                      ; >>> Llegó a 0 => Bloque destruido
  1579 00000DDF 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1580 00000DE0 B906000000                  mov rcx, block_length
  1581                                  .clear_loop:
  1582 00000DE5 C60720                      mov byte [rdi], ' '
  1583 00000DE8 48FFC7                      inc rdi
  1584 00000DEB E2F8                        loop .clear_loop
  1585                                  
  1586                                      ; Dibujar letra del bloque destruido
  1587 00000DED 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1588 00000DF1 4883EF06                    sub rdi, block_length
  1589 00000DF5 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1590                                      ; Después de escribir la letra en el tablero
  1591 00000DF7 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1592 00000DFB 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1593 00000DFF 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1594 00000E04 E89DF5FFFF                  call register_letter
  1595                                      ; Actualizar contadores globales
  1596 00000E09 FE0D(B5140000)              dec byte [blocks_remaining]
  1597 00000E0F FE05(45150000)              inc byte [destroyed_blocks]
  1598                                  
  1599                                      ; Sumar puntos según el tipo
  1600 00000E15 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1601 00000E1A 486BC00A                    imul rax, 10
  1602 00000E1E 480105(3D150000)            add [current_score], rax
  1603                                  
  1604 00000E25 B801000000                  mov rax, 1  ; colisión con destrucción
  1605 00000E2A EB14                        jmp .end_pop
  1606                                  
  1607                                  .update_display:
  1608                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1609 00000E2C B801000000                  mov rax, 1  ; colisión con "rebote"  
  1610 00000E31 5F                          pop rdi     ; pop que quedó pendiente
  1611 00000E32 EB0C                        jmp .end_pop
  1612                                  
  1613                                  .skip_collision:
  1614 00000E34 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1615                                  .next_block:
  1616 00000E35 49FFC4                      inc r12
  1617 00000E38 E929FFFFFF                  jmp .find_block_loop
  1618                                  
  1619                                  .no_block_found:
  1620 00000E3D 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1621                                  
  1622                                  .end_pop:
  1623 00000E40 415F                        pop r15
  1624 00000E42 415E                        pop r14
  1625 00000E44 415D                        pop r13
  1626 00000E46 415C                        pop r12
  1627 00000E48 5E                          pop rsi
  1628 00000E49 5F                          pop rdi
  1629 00000E4A 5B                          pop rbx
  1630 00000E4B 5D                          pop rbp
  1631 00000E4C C3                          ret
  1632                                  
  1633                                  
  1634                                  
  1635                                  init_enemies:
  1636 00000E4D 55                          push rbp
  1637 00000E4E 4889E5                      mov rbp, rsp
  1638                                      ; Reiniciar contadores de movimiento
  1639 00000E51 C605(88150000)00            mov byte [enemy_move_total], 0
  1640 00000E58 C605(89150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1641                                      ; Limpiar estado previo de enemigos
  1642 00000E5F B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1643 00000E64 488D3D(5F150000)            lea rdi, [enemies]
  1644 00000E6B 30C0                        xor al, al
  1645 00000E6D F3AA                        rep stosb ; Limpiar datos de enemigos
  1646                                      
  1647                                      ; Marcar todos los enemigos como inactivos
  1648 00000E6F 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1649 00000E76 30C0                        xor al, al
  1650 00000E78 B90A000000                  mov rcx, 10
  1651 00000E7D F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1652                                  
  1653 00000E7F 5D                          pop rbp
  1654 00000E80 C3                          ret
  1655                                  
  1656                                  
  1657                                  ; Función para mover enemigos
  1658                                  move_enemies:
  1659 00000E81 55                          push rbp
  1660 00000E82 4889E5                      mov rbp, rsp
  1661                                      
  1662                                      ; Incrementar contador de movimiento
  1663 00000E85 FE05(86150000)              inc byte [enemy_move_counter]
  1664 00000E8B 480FB605(86150000)          movzx rax, byte [enemy_move_counter]
  1665 00000E93 3A05(87150000)              cmp al, [enemy_move_delay]
  1666 00000E99 0F85AA010000                jne .end
  1667                                      
  1668                                      ; Resetear contador
  1669 00000E9F C605(86150000)00            mov byte [enemy_move_counter], 0
  1670                                      
  1671 00000EA6 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1672                                      
  1673                                      .enemy_loop:
  1674 00000EA9 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1675 00000EAD 0F8D96010000                    jge .end
  1676                                          
  1677                                          ; Calcular offset del enemigo actual
  1678 00000EB3 4C89E0                          mov rax, r12
  1679 00000EB6 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1680 00000EBA 488DB0[5F150000]                lea rsi, [enemies + rax]
  1681                                          
  1682                                          ; Verificar si el enemigo está activo
  1683 00000EC1 807E0201                        cmp byte [rsi + 2], 1
  1684 00000EC5 0F8576010000                    jne .next_enemy
  1685                                          
  1686                                          ; Obtener posición actual
  1687 00000ECB 4C0FB606                        movzx r8, byte [rsi]            ; X
  1688 00000ECF 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1689                                          
  1690                                          ; Limpiar posición actual antes de mover
  1691 00000ED4 4150                            push r8
  1692 00000ED6 4151                            push r9
  1693 00000ED8 B84E000000                      mov rax, column_cells
  1694 00000EDD 4883C002                        add rax, 2
  1695 00000EE1 49F7E1                          mul r9
  1696 00000EE4 4C01C0                          add rax, r8
  1697 00000EE7 488DB8[000A0000]                lea rdi, [board + rax]
  1698 00000EEE C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1699 00000EF1 4159                            pop r9
  1700 00000EF3 4158                            pop r8
  1701                                  
  1702                                          ; Determinar comportamiento basado en índice
  1703 00000EF5 4C89E0                          mov rax, r12
  1704 00000EF8 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1705 00000EFC 4885C0                          test rax, rax
  1706 00000EFF 7402                            jz .chase_ball
  1707 00000F01 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1708                                          
  1709                                          ; Perseguir bola (comportamiento original)
  1710                                      .chase_ball:
  1711 00000F03 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1712 00000F0A 4D39D0                          cmp r8, r10
  1713 00000F0D 0F8F96000000                    jg .move_left
  1714 00000F13 0F8C95000000                    jl .move_right
  1715                                          
  1716 00000F19 4C8B15(67140000)                mov r10, [ball_y_pos]
  1717 00000F20 4D39D1                          cmp r9, r10
  1718 00000F23 0F8F8A000000                    jg .move_up
  1719 00000F29 0F8C89000000                    jl .move_down
  1720 00000F2F E9A5000000                      jmp .check_collision
  1721                                          
  1722                                      .chase_paddle:
  1723                                          ; Obtener la posición X actual de la paleta
  1724 00000F34 4C8B15(3F140000)                mov r10, [pallet_position]
  1725 00000F3B 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1726                                          
  1727                                          ; Calcular la posición X real de la paleta
  1728 00000F42 4C89D0                          mov rax, r10
  1729 00000F45 BB4E000000                      mov rbx, column_cells
  1730 00000F4A 4883C302                        add rbx, 2                  ; Añadir newline chars
  1731 00000F4E 4831D2                          xor rdx, rdx
  1732 00000F51 48F7F3                          div rbx                     ; rax = y, rdx = x
  1733                                          
  1734                                          ; rdx ahora contiene la posición X de la paleta
  1735                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1736 00000F54 488B0D(47140000)                mov rcx, [pallet_size]
  1737 00000F5B 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1738 00000F5E 4801CA                          add rdx, rcx
  1739                                          
  1740                                          ; Comparar con posición X del enemigo y mover gradualmente
  1741 00000F61 4939D0                          cmp r8, rdx
  1742 00000F64 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1743 00000F66 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1744 00000F68 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1745                                  
  1746                                      .check_y_paddle:
  1747                                          ; La Y de la paleta siempre es row_cells - 2
  1748 00000F6A 41BA20000000                    mov r10, row_cells
  1749 00000F70 4983EA02                        sub r10, 2
  1750                                          
  1751                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1752 00000F74 4D39D1                          cmp r9, r10
  1753 00000F77 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1754 00000F79 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1755 00000F7B 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1756                                          
  1757                                      .no_movement:
  1758 00000F7D EB5A                            jmp .check_collision
  1759                                  
  1760                                      ; También agregar una nueva sección para el movimiento suave
  1761                                      .smooth_transition:
  1762                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1763 00000F7F 8A05(89150000)                  mov al, [enemy_target]
  1764 00000F85 84C0                            test al, al
  1765 00000F87 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1766                                          
  1767                                          ; Verificar distancia en X
  1768 00000F89 4989D2                          mov r10, rdx              ; Posición X objetivo
  1769 00000F8C 4D29C2                          sub r10, r8               ; Calcular diferencia
  1770 00000F8F 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1771 00000F93 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1772 00000F95 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1773 00000F99 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1774 00000F9B EB3C                            jmp .check_collision
  1775                                          
  1776                                      .limit_right_movement:
  1777 00000F9D 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1778 00000FA1 EB36                            jmp .check_collision
  1779                                          
  1780                                      .limit_left_movement:
  1781 00000FA3 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1782 00000FA7 EB30                            jmp .check_collision
  1783                                      .move_left:
  1784 00000FA9 49FFC8                          dec r8
  1785 00000FAC EB0F                            jmp .check_vertical
  1786                                          
  1787                                      .move_right:
  1788 00000FAE 49FFC0                          inc r8
  1789 00000FB1 EB0A                            jmp .check_vertical
  1790                                          
  1791                                      .move_up:
  1792 00000FB3 49FFC9                          dec r9
  1793 00000FB6 EB21                            jmp .check_collision
  1794                                          
  1795                                      .move_down:
  1796 00000FB8 49FFC1                          inc r9
  1797 00000FBB EB1C                            jmp .check_collision
  1798                                          
  1799                                      .check_vertical:
  1800 00000FBD 8A05(89150000)                  mov al, [enemy_target]
  1801 00000FC3 84C0                            test al, al
  1802 00000FC5 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1803 00000FCB 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1804 00000FD2 4D39D1                          cmp r9, r10
  1805 00000FD5 7FDC                            jg .move_up
  1806 00000FD7 7CDF                            jl .move_down
  1807                                          
  1808                                      .check_collision:
  1809                                          ; Verificar colisión con bordes
  1810 00000FD9 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1811 00000FDD 7E62                            jle .next_enemy
  1812 00000FDF 4983F84E                        cmp r8, column_cells
  1813 00000FE3 7D5C                            jge .next_enemy
  1814 00000FE5 4983F901                        cmp r9, 1                       ; Borde superior
  1815 00000FE9 7E56                            jle .next_enemy
  1816 00000FEB 4983F920                        cmp r9, row_cells
  1817 00000FEF 7D50                            jge .next_enemy
  1818                                          
  1819                                          ; Verificar colisión con bloques antes de moverse
  1820 00000FF1 4150                            push r8
  1821 00000FF3 4151                            push r9
  1822 00000FF5 4152                            push r10
  1823                                          
  1824                                          ; Calcular posición en el tablero para verificar
  1825 00000FF7 B84E000000                      mov rax, column_cells
  1826 00000FFC 4883C002                        add rax, 2
  1827 00001000 49F7E1                          mul r9
  1828 00001003 4C01C0                          add rax, r8
  1829 00001006 4C8D90[000A0000]                lea r10, [board + rax]
  1830                                          
  1831                                          ; Verificar si hay un bloque en la nueva posición
  1832 0000100D 418A02                          mov al, [r10]
  1833 00001010 3C55                            cmp al, 'U'
  1834 00001012 7427                            je .invalid_move
  1835 00001014 3C4F                            cmp al, 'O'
  1836 00001016 7423                            je .invalid_move
  1837 00001018 3C44                            cmp al, 'D'
  1838 0000101A 741F                            je .invalid_move
  1839 0000101C 3C4C                            cmp al, 'L'
  1840 0000101E 741B                            je .invalid_move
  1841 00001020 3C56                            cmp al, 'V'
  1842 00001022 7417                            je .invalid_move
  1843 00001024 3C38                            cmp al, '8'
  1844 00001026 7413                            je .invalid_move
  1845 00001028 3C58                            cmp al, 'X'
  1846 0000102A 740F                            je .invalid_move
  1847                                          
  1848 0000102C 415A                            pop r10
  1849 0000102E 4159                            pop r9
  1850 00001030 4158                            pop r8
  1851                                          
  1852                                          ; Guardar nueva posición si es válida
  1853 00001032 448806                          mov [rsi], r8b
  1854 00001035 44884E01                        mov [rsi + 1], r9b
  1855 00001039 EB06                            jmp .next_enemy
  1856                                          
  1857                                      .invalid_move:
  1858 0000103B 415A                            pop r10
  1859 0000103D 4159                            pop r9
  1860 0000103F 4158                            pop r8
  1861                                          
  1862                                      .next_enemy:
  1863 00001041 49FFC4                          inc r12
  1864 00001044 E960FEFFFF                      jmp .enemy_loop
  1865                                          
  1866                                      .end:
  1867 00001049 5D                              pop rbp
  1868 0000104A C3                              ret
  1869                                  
  1870                                  get_current_spawn_points:
  1871 0000104B 55                          push rbp
  1872 0000104C 4889E5                      mov rbp, rsp
  1873                                      
  1874 0000104F 480FB605(B4140000)          movzx rax, byte [current_level]
  1875 00001057 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1876 0000105A 488B04C5[BD150000]          mov rax, [spawn_points_table + rax * 8]
  1877                                      
  1878 00001062 5D                          pop rbp
  1879 00001063 C3                          ret
  1880                                  
  1881                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1882                                  check_enemy_spawn:
  1883 00001064 55                          push rbp
  1884 00001065 4889E5                      mov rbp, rsp
  1885                                      
  1886                                      ; Obtener spawn points del nivel actual
  1887 00001068 E8DEFFFFFF                  call get_current_spawn_points
  1888 0000106D 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1889                                      
  1890                                      ; Obtener cantidad de bloques destruidos
  1891 00001070 4C0FB62D(45150000)          movzx r13, byte [destroyed_blocks]
  1892                                      
  1893                                      ; Verificar cada punto de spawn
  1894 00001078 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1895                                      
  1896                                      .check_loop:
  1897 0000107B 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1898 0000107F 7D4B                            jge .end
  1899                                          
  1900                                          ; Verificar si este spawn point ya fue usado
  1901 00001081 80B9[E8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1902 00001088 743D                            je .next_enemy
  1903                                          
  1904                                          ; Verificar si este enemigo ya está activo
  1905 0000108A 4889C8                          mov rax, rcx
  1906 0000108D 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1907 00001091 488DB0[5F150000]                lea rsi, [enemies + rax]
  1908 00001098 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1909 0000109C 7429                            je .next_enemy
  1910                                          
  1911                                          ; Verificar si debemos spawnear este enemigo
  1912 0000109E 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1913 000010A3 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1914 000010A6 751F                            jne .next_enemy
  1915                                          
  1916                                          ; Marcar este spawn point como usado
  1917 000010A8 C681[E8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1918                                          
  1919                                          ; Spawner nuevo enemigo
  1920 000010AF C60628                          mov byte [rsi], 40             ; X inicial
  1921 000010B2 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1922 000010B6 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1923                                          
  1924                                          ; Inicializar comportamiento
  1925 000010BA 4889C8                          mov rax, rcx
  1926 000010BD 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1927 000010C1 8805(E7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1928                                          
  1929                                      .next_enemy:
  1930 000010C7 48FFC1                          inc rcx
  1931 000010CA EBAF                            jmp .check_loop
  1932                                          
  1933                                      .end:
  1934 000010CC 5D                              pop rbp
  1935 000010CD C3                              ret
  1936                                  
  1937                                  
  1938                                  ; Función para dibujar enemigos
  1939                                  print_enemies:
  1940 000010CE 55                          push rbp
  1941 000010CF 4889E5                      mov rbp, rsp
  1942                                      
  1943 000010D2 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1944                                      
  1945                                      .print_loop:
  1946 000010D5 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1947 000010D9 7D4B                            jge .end
  1948                                          
  1949                                          ; Calcular offset del enemigo actual
  1950 000010DB 4C89E0                          mov rax, r12
  1951 000010DE 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1952 000010E2 488DB0[5F150000]                lea rsi, [enemies + rax]
  1953                                          
  1954                                          ; Verificar si el enemigo está activo
  1955 000010E9 807E0201                        cmp byte [rsi + 2], 1
  1956 000010ED 7532                            jne .next_enemy
  1957                                          
  1958                                          ; Calcular posición en el tablero
  1959 000010EF 4C0FB606                        movzx r8, byte [rsi]            ; X
  1960 000010F3 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1961                                          
  1962                                          ; Calcular offset en el tablero
  1963 000010F8 B84E000000                      mov rax, column_cells
  1964 000010FD 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1965 00001101 49F7E1                          mul r9
  1966 00001104 4C01C0                          add rax, r8
  1967 00001107 488DB8[000A0000]                lea rdi, [board + rax]
  1968                                          
  1969                                          ; Obtener carácter del enemigo según el nivel
  1970 0000110E 480FB605(B4140000)              movzx rax, byte [current_level]
  1971 00001116 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1972 00001119 8A80[5A150000]                  mov al, [enemy_chars + rax]
  1973                                          
  1974                                          ; Dibujar enemigo
  1975 0000111F 8807                            mov [rdi], al
  1976                                          
  1977                                      .next_enemy:
  1978 00001121 49FFC4                          inc r12
  1979 00001124 EBAF                            jmp .print_loop
  1980                                          
  1981                                      .end:
  1982 00001126 5D                              pop rbp
  1983 00001127 C3                              ret
  1984                                  
  1985                                  ; Función para verificar colisión con enemigos
  1986                                  ; Función para verificar colisión con enemigos
  1987                                  check_enemy_collision:
  1988 00001128 55                          push rbp
  1989 00001129 4889E5                      mov rbp, rsp
  1990                                      
  1991 0000112C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1992 0000112F 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1993                                      
  1994                                      .check_loop:
  1995 00001132 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1996 00001136 0F8DE9000000                    jge .end
  1997                                          
  1998                                          ; Calcular offset del enemigo actual
  1999 0000113C 4C89E1                          mov rcx, r12
  2000 0000113F 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2001 00001143 488DB1[5F150000]                lea rsi, [enemies + rcx]
  2002                                          
  2003                                          ; Verificar si el enemigo está activo
  2004 0000114A 807E0201                        cmp byte [rsi + 2], 1
  2005 0000114E 0F85C9000000                    jne .next_enemy
  2006                                          
  2007                                          ; Verificar colisión con la bola
  2008 00001154 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2009 00001158 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2010                                          
  2011                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2012 0000115D 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2013 00001164 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2014                                          
  2015                                          ; Comprobar colisión vertical (misma columna)
  2016 0000116B 4D39C2                          cmp r10, r8
  2017 0000116E 7525                            jne .check_horizontal
  2018 00001170 4D29CB                          sub r11, r9
  2019 00001173 4983FB01                        cmp r11, 1
  2020 00001177 7F1C                            jg .check_horizontal
  2021 00001179 4983FBFF                        cmp r11, -1
  2022 0000117D 7C16                            jl .check_horizontal
  2023                                          
  2024                                          ; Colisión vertical detectada
  2025 0000117F E8A3000000                      call destroy_enemy
  2026 00001184 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2027 0000118B B801000000                      mov rax, 1
  2028 00001190 E990000000                      jmp .end
  2029                                          
  2030                                      .check_horizontal:
  2031                                          ; Comprobar colisión horizontal (misma fila)
  2032 00001195 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2033 0000119C 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2034 000011A3 4D39CB                          cmp r11, r9
  2035 000011A6 7522                            jne .check_paddle
  2036 000011A8 4D29C2                          sub r10, r8
  2037 000011AB 4983FA01                        cmp r10, 1
  2038 000011AF 7F19                            jg .check_paddle
  2039 000011B1 4983FAFF                        cmp r10, -1
  2040 000011B5 7C13                            jl .check_paddle
  2041                                          
  2042                                          ; Colisión horizontal detectada
  2043 000011B7 E86B000000                      call destroy_enemy
  2044 000011BC 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2045 000011C3 B801000000                      mov rax, 1
  2046 000011C8 EB5B                            jmp .end
  2047                                          
  2048                                      .check_paddle:
  2049                                          ; Verificar colisión con la paleta
  2050 000011CA 4C8B15(3F140000)                mov r10, [pallet_position]
  2051 000011D1 4981EA[000A0000]                sub r10, board
  2052 000011D8 4C89D0                          mov rax, r10
  2053 000011DB 41BB4E000000                    mov r11, column_cells
  2054 000011E1 4983C302                        add r11, 2
  2055 000011E5 4831D2                          xor rdx, rdx
  2056 000011E8 49F7F3                          div r11                     ; División para obtener la posición Y
  2057 000011EB 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2058                                          
  2059 000011EE 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2060                                          
  2061                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2062 000011F5 41BD20000000                    mov r13, row_cells
  2063 000011FB 4983ED02                        sub r13, 2                 ; Y de la paleta
  2064 000011FF 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2065 00001202 7519                            jne .next_enemy
  2066                                          
  2067                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2068 00001204 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2069 00001207 7C14                            jl .next_enemy
  2070                                          
  2071 00001209 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2072 0000120C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2073 0000120F 7F0C                            jg .next_enemy
  2074                                          
  2075                                          ; Si llegamos aquí, hay colisión con la paleta
  2076 00001211 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2077 00001216 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2078 0000121B EB08                            jmp .end
  2079                                          
  2080                                      .next_enemy:
  2081 0000121D 49FFC4                          inc r12
  2082 00001220 E90DFFFFFF                      jmp .check_loop
  2083                                          
  2084                                      .end:
  2085 00001225 5D                              pop rbp
  2086 00001226 C3                              ret
  2087                                  
  2088                                  ; Función para destruir un enemigo
  2089                                  destroy_enemy:
  2090                                      ; Desactivar enemigo
  2091 00001227 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2092                                  
  2093                                      ; Sumar puntos por destruir enemigo
  2094 0000122B 488B05(7E150000)            mov rax, [enemy_points]
  2095 00001232 480105(3D150000)            add [current_score], rax
  2096                                  
  2097                                      ; No tocar bloques destruidos aquí
  2098 00001239 C3                          ret
  2099                                  
  2100                                  
  2101                                  _start:
  2102 0000123A E8ECEEFFFF              	call canonical_off
  2103 0000123F E8F3000000              	call start_screen
  2104 00001244 E8C4F5FFFF                  call init_level
  2105 00001249 E8FFFBFFFF                  call init_enemies
  2106 0000124E EB00                    	jmp .main_loop
  2107                                  	
  2108                                  
  2109                                  	.main_loop:
  2110 00001250 E8B6F9FFFF                      call print_labels
  2111 00001255 E8E5F8FFFF                      call print_blocks
  2112 0000125A E818F2FFFF                      call move_letters
  2113 0000125F E888F1FFFF                      call print_letters
  2114 00001264 E837F3FFFF              		call print_pallet
  2115 00001269 E8DCF3FFFF                      call move_ball
  2116 0000126E E86BF0FFFF                      call check_bottom_collision
  2117 00001273 E865EFFFFF                      call print_lives
  2118 00001278 E824F7FFFF                      call check_level_complete
  2119 0000127D E8E2FDFFFF                      call check_enemy_spawn
  2120 00001282 E8FAFBFFFF                      call move_enemies
  2121 00001287 E89CFEFFFF                      call check_enemy_collision
  2122 0000128C E83DFEFFFF                      call print_enemies
  2123 00001291 E8E2F2FFFF              		call print_ball
  2124                                  		print board, board_size				
    82 00001296 B801000000          <1>  mov eax, sys_write
    83 0000129B BF01000000          <1>  mov edi, 1
    84 000012A0 48BE-               <1>  mov rsi, %1
    84 000012A2 [000A000000000000]  <1>
    85 000012AA BA000A0000          <1>  mov edx, %2
    86 000012AF 0F05                <1>  syscall
  2125                                  		;setnonblocking	
  2126                                  	.read_more:	
  2127                                  		getchar	
    90 000012B1 B800000000          <1>  mov rax, sys_read
    91 000012B6 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000012BB 48BE-               <1>  mov rsi, input_char
    92 000012BD [0000000000000000]  <1>
    93 000012C5 BA01000000          <1>  mov rdx, 1
    94 000012CA 0F05                <1>  syscall
  2128                                  		
  2129 000012CC 4883F801                		cmp rax, 1
  2130 000012D0 7532                        	jne .done
  2131                                  		
  2132 000012D2 8A05(00000000)          		mov al,[input_char]
  2133                                  
  2134 000012D8 3C61                    		cmp al, 'a'
  2135 000012DA 750E                    	    jne .not_left
  2136 000012DC 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2137 000012E3 E8EDF2FFFF              		call move_pallet
  2138 000012E8 EB1A                    	    jmp .done
  2139                                  		
  2140                                  		.not_left:
  2141 000012EA 3C64                    		 	cmp al, 'd'
  2142 000012EC 750C                    	    	jne .not_right
  2143 000012EE BF01000000              			mov rdi, right_direction
  2144 000012F3 E8DDF2FFFF              	    	call move_pallet
  2145 000012F8 EB0A                        		jmp .done		
  2146                                  
  2147                                  		.not_right:
  2148                                  
  2149 000012FA 3C71                        		cmp al, 'q'
  2150 000012FC 0F84A8000000                		je exit
  2151                                  
  2152 00001302 EBAD                    			jmp .read_more
  2153                                  		
  2154                                  		.done:	
  2155                                  			;unsetnonblocking		
  2156                                  			sleeptime	
    98 00001304 B823000000          <1>  mov eax, sys_nanosleep
    99 00001309 48BF-               <1>  mov rdi, timespec
    99 0000130B [0000000000000000]  <1>
   100 00001313 31F6                <1>  xor esi, esi
   101 00001315 0F05                <1>  syscall
  2157                                  			print clear, clear_length
    82 00001317 B801000000          <1>  mov eax, sys_write
    83 0000131C BF01000000          <1>  mov edi, 1
    84 00001321 48BE-               <1>  mov rsi, %1
    84 00001323 [1000000000000000]  <1>
    85 0000132B BA07000000          <1>  mov edx, %2
    86 00001330 0F05                <1>  syscall
  2158 00001332 E919FFFFFF                  		jmp .main_loop
  2159                                  
  2160                                  
  2161                                  
  2162                                  start_screen:
  2163                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001337 B801000000          <1>  mov eax, sys_write
    83 0000133C BF01000000          <1>  mov edi, 1
    84 00001341 48BE-               <1>  mov rsi, %1
    84 00001343 [1000000000000000]  <1>
    85 0000134B BA07000000          <1>  mov edx, %2
    86 00001350 0F05                <1>  syscall
  2164                                      print msg1, msg1_length
    82 00001352 B801000000          <1>  mov eax, sys_write
    83 00001357 BF01000000          <1>  mov edi, 1
    84 0000135C 48BE-               <1>  mov rsi, %1
    84 0000135E [1700000000000000]  <1>
    85 00001366 BA14010000          <1>  mov edx, %2
    86 0000136B 0F05                <1>  syscall
  2165                                      
  2166                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2167                                          getchar                 ; Esperamos una tecla
    90 0000136D B800000000          <1>  mov rax, sys_read
    91 00001372 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001377 48BE-               <1>  mov rsi, input_char
    92 00001379 [0000000000000000]  <1>
    93 00001381 BA01000000          <1>  mov rdx, 1
    94 00001386 0F05                <1>  syscall
  2168 00001388 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2169 0000138C 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2170                                          
  2171                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000138E B801000000          <1>  mov eax, sys_write
    83 00001393 BF01000000          <1>  mov edi, 1
    84 00001398 48BE-               <1>  mov rsi, %1
    84 0000139A [1000000000000000]  <1>
    85 000013A2 BA07000000          <1>  mov edx, %2
    86 000013A7 0F05                <1>  syscall
  2172 000013A9 C3                          ret
  2173                                  
  2174                                  exit: 
  2175 000013AA E8BEEDFFFF              	call canonical_on
  2176 000013AF B83C000000              	mov    rax, 60
  2177 000013B4 BF00000000                  mov    rdi, 0
  2178 000013B9 0F05                        syscall
  2179                                  
