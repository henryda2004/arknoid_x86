     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 38070301                        db 56, 7, 3, 1    ; Bloque 7
   288 000014AA 14070301                        db 20, 7, 3, 1    ; Bloque 7
   289 000014AE 1E070301                        db 30, 7, 3, 1    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B2 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014B6 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BA 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014BE 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                   ;Modificar los labels para tener un ancho fijo
   317 00001526 50756E74616A653A20-         score_label db "Puntaje: 000000", 0xA, 0xD  ; 6 dígitos para el puntaje
   317 0000152F 3030303030300A0D   
   318                                      score_label_len equ $ - score_label
   319 00001537 426C6F717565732064-         blocks_label db "Bloques destruidos: 000", 0xA, 0xD  ; 3 dígitos para bloques
   319 00001540 657374727569646F73-
   319 00001549 3A203030300A0D     
   320                                      blocks_label_len equ $ - blocks_label
   321                                      
   322                                      ; Variables para almacenar los valores
   323 00001550 0000000000000000            current_score dq 0          ; Score actual
   324 00001558 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   325                                      
   326                                      ; Buffer para convertir números a string
   327 00001559 00<rep 14h>                 number_buffer: times 20 db 0
   328 0000156D 00<rep 14h>                 temp_buffer times 20 db 0
   329                                  
   330 00001581 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   331                                      
   332                                      ; Estructura para los enemigos (x, y, activo)
   333 00001586 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   334 000015A4 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   335                                      
   336 000015A5 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   337 000015AD 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   338 000015AE 01                          enemy_move_delay db 1           ; Mover enemigos cada N ciclos
   339 000015AF 00                          enemy_move_total db 0      ; Contador total de movimientos
   340 000015B0 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   341 000015B1 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   342                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   343                                      ; Añade esto en la sección .dataa
   344 000015B2 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   344 000015BB 12                 
   345 000015BC 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   345 000015C5 13                 
   346 000015C6 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   346 000015CF 1B                 
   347 000015D0 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   347 000015D9 1C                 
   348 000015DA 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   348 000015E3 2D                 
   349                                          ; Arreglo de punteros a los spawn points de cada nivel
   350                                      spawn_points_table:
   351 000015E4 [B215000000000000]              dq level1_spawn_points
   352 000015EC [BC15000000000000]              dq level2_spawn_points
   353 000015F4 [C615000000000000]              dq level3_spawn_points
   354 000015FC [D015000000000000]              dq level4_spawn_points
   355 00001604 [DA15000000000000]              dq level5_spawn_points
   356                                  
   357                                      ; Variables para el comportamiento de enemigos
   358 0000160C 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   359 0000160D 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   360 0000160E 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 0000160F 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   362                                  
   363                                  section .text
   364                                  
   365                                  ;	Function: print_ball
   366                                  ; This function displays the position of the ball
   367                                  ; Arguments: none
   368                                  ;
   369                                  ; Return:
   370                                  ;	Void
   371                                  print_ball:
   372 000001DD 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   373 000001E4 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   374 000001EB 4981C0[000A0000]        	add r8, board
   375                                  
   376 000001F2 4C89C9                  	mov rcx, r9
   377 000001F5 B850000000              	mov rax, column_cells + 2
   378 000001FA 48F7E9                  	imul rcx
   379                                  	
   380 000001FD 4901C0                  	add r8, rax
   381 00000200 41C6004F                	mov byte [r8], char_O
   382 00000204 C3                      	ret
   383                                  
   384                                  	
   385                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   386                                  	
   387                                  
   388                                  
   389                                  
   390                                  ;	Function: print_pallet
   391                                  ; This function moves the pallet in the game
   392                                  ; Arguments: none
   393                                  ;
   394                                  ; Return;
   395                                  ;	void
   396                                  print_pallet:
   397 00000205 4C8B05(3F140000)        	mov r8, [pallet_position]
   398 0000020C 488B0D(47140000)        	mov rcx, [pallet_size]
   399                                  	.write_pallet:
   400 00000213 41C6003D                		mov byte [r8], char_equal
   401 00000217 49FFC0                  		inc r8
   402 0000021A 48FFC9                  		dec rcx
   403 0000021D 75F4                    		jnz .write_pallet
   404                                  
   405 0000021F C3                      	ret
   406                                  	
   407                                  ;	Function: move_pallet
   408                                  ; This function is in charge of moving the pallet in a given direction
   409                                  ; Arguments:
   410                                  ;	rdi: left direction or right direction
   411                                  ;
   412                                  ; Return:
   413                                  ;	void
   414                                  move_pallet:
   415                                      
   416 00000220 803D(6F140000)00            cmp byte [ball_moving], 0
   417 00000227 7507                        jne .continue_movement
   418 00000229 C605(6F140000)01            mov byte [ball_moving], 1
   419                                  
   420                                      .continue_movement:
   421 00000230 4883FFFF                        cmp rdi, left_direction
   422 00000234 7531                            jne .move_right
   423                                  
   424                                          .move_left:
   425                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   426 00000236 4C8B05(3F140000)                    mov r8, [pallet_position]
   427 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   428 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   429 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   430 00000245 744D                                je .end            ; Si es X, no mover
   431                                              
   432 00000247 4C8B05(3F140000)                    mov r8, [pallet_position]
   433 0000024E 4C8B0D(47140000)                    mov r9, [pallet_size]
   434 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   435 0000025B 49FFC8                              dec r8
   436 0000025E 4C8905(3F140000)                    mov [pallet_position], r8
   437 00000265 EB2D                                jmp .end
   438                                              
   439                                          .move_right:
   440                                              ; Verificar si la siguiente posición después de la paleta sería una X
   441 00000267 4C8B05(3F140000)                    mov r8, [pallet_position]
   442 0000026E 4C8B0D(47140000)                    mov r9, [pallet_size]
   443 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   444 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   445 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   446 0000027D 7415                                je .end            ; Si es X, no mover
   447                                              
   448 0000027F 4C8B05(3F140000)                    mov r8, [pallet_position]
   449 00000286 41C60020                            mov byte [r8], char_space
   450 0000028A 49FFC0                              inc r8
   451 0000028D 4C8905(3F140000)                    mov [pallet_position], r8
   452                                          .end:
   453 00000294 C3                                  ret
   454                                  
   455                                  move_ball:
   456                                      ; Si la bola no está en movimiento, no hacer nada
   457 00000295 803D(6F140000)00            cmp byte [ball_moving], 0
   458 0000029C 0F8406010000                je .end
   459                                  
   460                                      ; Borrar la posición actual de la bola
   461 000002A2 4C8B05(4F140000)            mov r8, [ball_x_pos]
   462 000002A9 4C8B0D(57140000)            mov r9, [ball_y_pos]
   463 000002B0 4981C0[000A0000]            add r8, board
   464 000002B7 4C89C9                      mov rcx, r9
   465 000002BA B850000000                  mov rax, column_cells + 2
   466 000002BF 48F7E9                      imul rcx
   467 000002C2 4901C0                      add r8, rax
   468 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   469                                  
   470                                      ; Calcular siguiente posición X
   471 000002C9 4C8B05(4F140000)            mov r8, [ball_x_pos]
   472 000002D0 4C8B0D(57140000)            mov r9, [ball_y_pos]
   473 000002D7 488B05(5F140000)            mov rax, [ball_direction_x]
   474 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   475                                  
   476                                      ; Calcular la dirección de memoria para la siguiente posición
   477 000002E1 4D89C2                      mov r10, r8
   478 000002E4 4981C2[000A0000]            add r10, board
   479 000002EB 4C89C9                      mov rcx, r9
   480 000002EE B850000000                  mov rax, column_cells + 2
   481 000002F3 48F7E9                      imul rcx
   482 000002F6 4901C2                      add r10, rax
   483                                  
   484                                      ; Verificar si hay una X en la siguiente posición X
   485 000002F9 418A02                      mov al, [r10]
   486 000002FC 3C58                        cmp al, 'X'
   487 000002FE 750C                        jne .check_block_x
   488 00000300 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   489 00000307 E99C000000                  jmp .end
   490                                  
   491                                      .check_block_x:
   492                                          ; Verificar colisión con bloques en X
   493 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   494 0000030E 4151                            push r9
   495 00000310 4152                            push r10
   496 00000312 E860060000                      call check_block_collision
   497 00000317 415A                            pop r10
   498 00000319 4159                            pop r9
   499 0000031B 4158                            pop r8
   500 0000031D 4885C0                          test rax, rax
   501 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   502 00000322 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   503 00000329 EB7D                            jmp .end
   504                                  
   505                                      .check_paddle_x:
   506                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   507 0000032B 41803A3D                        cmp byte [r10], char_equal
   508 0000032F 7509                            jne .check_y_movement
   509 00000331 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   510 00000338 EB6E                            jmp .end
   511                                  
   512                                      .check_y_movement:
   513                                          ; Calcular siguiente posición Y
   514 0000033A 488B05(67140000)                mov rax, [ball_direction_y]
   515 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   516                                  
   517                                          ; Calcular la dirección de memoria para la siguiente posición Y
   518 00000344 4D89C2                          mov r10, r8
   519 00000347 4981C2[000A0000]                add r10, board
   520 0000034E 4C89C9                          mov rcx, r9
   521 00000351 B850000000                      mov rax, column_cells + 2
   522 00000356 48F7E9                          imul rcx
   523 00000359 4901C2                          add r10, rax
   524                                  
   525                                          ; Verificar si hay una X en la siguiente posición Y
   526 0000035C 418A02                          mov al, [r10]
   527 0000035F 3C58                            cmp al, 'X'
   528 00000361 7509                            jne .check_block_y
   529 00000363 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   530 0000036A EB3C                            jmp .end
   531                                  
   532                                      .check_block_y:
   533                                          ; Verificar colisión con bloques en Y
   534 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   535 0000036E 4151                            push r9
   536 00000370 4152                            push r10
   537 00000372 E800060000                      call check_block_collision
   538 00000377 415A                            pop r10
   539 00000379 4159                            pop r9
   540 0000037B 4158                            pop r8
   541 0000037D 4885C0                          test rax, rax
   542 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   543 00000382 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   544 00000389 EB1D                            jmp .end
   545                                  
   546                                      .check_paddle_y:
   547                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   548 0000038B 41803A3D                    cmp byte [r10], char_equal
   549 0000038F 7509                        jne .update_position
   550 00000391 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   551 00000398 EB0E                        jmp .end
   552                                  
   553                                  
   554                                      .update_position:
   555 0000039A 4C8905(4F140000)                mov [ball_x_pos], r8
   556 000003A1 4C890D(57140000)                mov [ball_y_pos], r9
   557                                  
   558                                      .end:
   559 000003A8 C3                              ret
   560                                  
   561                                  ; Función para inicializar el nivel
   562                                  ; Función para inicializar el nivel
   563                                  ; Función para mostrar el número de nivel
   564                                  display_level_number:
   565 000003A9 55                          push rbp
   566 000003AA 4889E5                      mov rbp, rsp
   567                                      
   568                                      ; Limpiar la pantalla primero
   569                                      print clear, clear_length
    82 000003AD B801000000          <1>  mov eax, sys_write
    83 000003B2 BF01000000          <1>  mov edi, 1
    84 000003B7 48BE-               <1>  mov rsi, %1
    84 000003B9 [1000000000000000]  <1>
    85 000003C1 BA07000000          <1>  mov edx, %2
    86 000003C6 0F05                <1>  syscall
   570                                      
   571                                      ; Calcular la posición central para el mensaje
   572                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   573 000003C8 B84E000000                  mov rax, column_cells
   574 000003CD 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   575 000003D1 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   576                                      
   577                                      ; Calcular la fila central
   578 000003D4 BB20000000                  mov rbx, row_cells
   579 000003D9 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   580                                      
   581                                      ; Calcular el offset en el buffer
   582 000003DC B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   583 000003E1 48F7E3                      mul rbx                     ; multiplicar por la fila central
   584 000003E4 4801D8                      add rax, rbx                ; añadir el offset horizontal
   585                                      
   586                                      ; Escribir "NIVEL " en la posición calculada
   587 000003E7 488DB8[000A0000]            lea rdi, [board + rax]
   588 000003EE 48BE-                       mov rsi, level_msg
   588 000003F0 [2414000000000000] 
   589 000003F8 B906000000                  mov rcx, level_msg_len
   590 000003FD F3A4                        rep movsb
   591                                      
   592                                      ; Escribir el número del nivel
   593 000003FF 8A05(A4140000)              mov al, [current_level]
   594 00000405 0430                        add al, '0'                 ; convertir a ASCII
   595 00000407 8807                        mov [rdi], al
   596                                      
   597                                      ; Mostrar el board con el mensaje
   598                                      print board, board_size
    82 00000409 B801000000          <1>  mov eax, sys_write
    83 0000040E BF01000000          <1>  mov edi, 1
    84 00000413 48BE-               <1>  mov rsi, %1
    84 00000415 [000A000000000000]  <1>
    85 0000041D BA000A0000          <1>  mov edx, %2
    86 00000422 0F05                <1>  syscall
   599                                      
   600                                      ; Esperar un segundo
   601 00000424 B823000000                  mov rax, sys_nanosleep
   602 00000429 48BF-                       mov rdi, level_display_time
   602 0000042B [2F14000000000000] 
   603 00000433 4831F6                      xor rsi, rsi
   604 00000436 0F05                        syscall
   605                                      
   606 00000438 5D                          pop rbp
   607 00000439 C3                          ret
   608                                  
   609                                  ; Función para inicializar un tablero vacío
   610                                  init_empty_board:
   611 0000043A 56                          push rsi
   612 0000043B 57                          push rdi
   613 0000043C 51                          push rcx
   614 0000043D 50                          push rax
   615                                  
   616 0000043E 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   617 00000445 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   618 0000044C B9000A0000                  mov rcx, board_template_size
   619 00000451 F3A4                        rep movsb                   ; Copiar el tablero
   620                                  
   621 00000453 58                          pop rax
   622 00000454 59                          pop rcx
   623 00000455 5F                          pop rdi
   624 00000456 5E                          pop rsi
   625 00000457 C3                          ret
   626                                  
   627                                  
   628                                  init_level:
   629                                      ; 1) Copiamos board_template en board para que quede "virgen"
   630 00000458 C605(58150000)00            mov byte [destroyed_blocks], 0 
   631 0000045F E8D6FFFFFF                  call init_empty_board
   632 00000464 E840FFFFFF                  call display_level_number
   633 00000469 E808060000                  call init_enemies
   634                                      
   635 0000046E 56                          push rsi
   636 0000046F 57                          push rdi
   637 00000470 51                          push rcx
   638 00000471 50                          push rax
   639                                  
   640 00000472 488D35(00000000)            lea rsi, [board_template]
   641 00000479 488D3D(000A0000)            lea rdi, [board]
   642 00000480 B9000A0000                  mov rcx, board_template_size
   643 00000485 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   644                                  
   645 00000487 58                          pop rax
   646 00000488 59                          pop rcx
   647 00000489 5F                          pop rdi
   648 0000048A 5E                          pop rsi
   649                                  
   650 0000048B B90A000000                  mov rcx, 10
   651 00000490 4831C0                      xor rax, rax
   652 00000493 488D3D(0F160000)            lea rdi, [enemy_spawns_triggered]
   653 0000049A F3AA                        rep stosb      
   654                                  
   655                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   656 0000049C 803D(A4140000)01            cmp byte [current_level], 1
   657 000004A3 7431                        je .level1
   658 000004A5 803D(A4140000)02            cmp byte [current_level], 2
   659 000004AC 7454                        je .level2
   660 000004AE 803D(A4140000)03            cmp byte [current_level], 3
   661 000004B5 7477                        je .level3
   662 000004B7 803D(A4140000)04            cmp byte [current_level], 4
   663 000004BE 0F8492000000                je .level4
   664 000004C4 803D(A4140000)05            cmp byte [current_level], 5
   665 000004CB 0F84AD000000                je .level5
   666 000004D1 E9D0000000                  jmp .done
   667                                  
   668                                  
   669                                  
   670                                      .level1:
   671 000004D6 C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
   672 000004DD 4831C9                          xor rcx, rcx             
   673                                          .init_loop1:
   674 000004E0 4883F903                            cmp rcx, level1_blocks_count
   675 000004E4 0F8DBC000000                        jge .done
   676 000004EA 4889C8                              mov rax, rcx         
   677 000004ED 48C1E002                            shl rax, 2          
   678 000004F1 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   679 000004F7 8891[C2140000]                      mov byte [block_states + rcx], dl
   680 000004FD 48FFC1                              inc rcx
   681 00000500 EBDE                                jmp .init_loop1
   682                                  
   683                                      .level2:
   684 00000502 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   685 00000509 4831C9                          xor rcx, rcx             
   686                                          .init_loop2:
   687 0000050C 4883F901                            cmp rcx, level2_blocks_count
   688 00000510 0F8D90000000                        jge .done
   689 00000516 4889C8                              mov rax, rcx         
   690 00000519 48C1E002                            shl rax, 2          
   691 0000051D 8A90[B5140000]                      mov dl, byte [level2_blocks + rax + 3]  
   692 00000523 8891[C2140000]                      mov byte [block_states + rcx], dl
   693 00000529 48FFC1                              inc rcx
   694 0000052C EBDE                                jmp .init_loop2
   695                                      .level3:
   696 0000052E C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   697 00000535 4831C9                          xor rcx, rcx             
   698                                          .init_loop3:
   699 00000538 4883F901                            cmp rcx, level3_blocks_count
   700 0000053C 7D68                                jge .done
   701 0000053E 4889C8                              mov rax, rcx         
   702 00000541 48C1E002                            shl rax, 2          
   703 00000545 8A90[B9140000]                      mov dl, byte [level3_blocks + rax + 3]  
   704 0000054B 8891[C2140000]                      mov byte [block_states + rcx], dl
   705 00000551 48FFC1                              inc rcx
   706 00000554 EBE2                                jmp .init_loop3
   707                                  
   708                                      .level4:
   709 00000556 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   710 0000055D 4831C9                          xor rcx, rcx             
   711                                          .init_loop4:
   712 00000560 4883F901                            cmp rcx, level4_blocks_count
   713 00000564 7D40                                jge .done
   714 00000566 4889C8                              mov rax, rcx         
   715 00000569 48C1E002                            shl rax, 2          
   716 0000056D 8A90[BD140000]                      mov dl, byte [level4_blocks + rax + 3]  
   717 00000573 8891[C2140000]                      mov byte [block_states + rcx], dl
   718 00000579 48FFC1                              inc rcx
   719 0000057C EBE2                                jmp .init_loop4
   720                                  
   721                                      .level5:
   722 0000057E C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   723 00000585 4831C9                          xor rcx, rcx             
   724                                          .init_loop5:
   725 00000588 4883F901                            cmp rcx, level5_blocks_count
   726 0000058C 7D18                                jge .done
   727 0000058E 4889C8                              mov rax, rcx         
   728 00000591 48C1E002                            shl rax, 2          
   729 00000595 8A90[C1140000]                      mov dl, byte [level5_blocks + rax + 3]  
   730 0000059B 8891[C2140000]                      mov byte [block_states + rcx], dl
   731 000005A1 48FFC1                              inc rcx
   732 000005A4 EBE2                                jmp .init_loop5
   733                                      .done:
   734 000005A6 C3                              ret
   735                                  
   736                                  
   737                                  ; Función para verificar y manejar la transición de nivel
   738                                  check_level_complete:
   739                                      ; Verificar si quedan bloques
   740 000005A7 803D(A5140000)00            cmp byte [blocks_remaining], 0
   741 000005AE 753C                        jne .not_complete
   742                                      
   743                                      ; Incrementar el nivel
   744 000005B0 FE05(A4140000)              inc byte [current_level]
   745                                      
   746                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   747 000005B6 803D(A4140000)06            cmp byte [current_level], 6
   748 000005BD 742E                        je game_win
   749                                      
   750                                      ; Reinicializar el juego para el siguiente nivel
   751 000005BF E894FEFFFF                  call init_level
   752                                      
   753                                      ; Reinicializar la posición de la bola y la paleta
   754 000005C4 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   754 000005CC 000000             
   755 000005CF 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   755 000005D7 000000             
   756 000005DA C605(6F140000)00            mov byte [ball_moving], 0
   757 000005E1 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   757 000005E8 [38130000]         
   758                                      
   759                                      .not_complete:
   760 000005EC C3                              ret
   761                                  
   762                                      ; Nueva función para manejar la victoria del juego
   763                                  game_win:
   764                                      ; Limpiar la pantalla primero
   765                                      print clear, clear_length
    82 000005ED B801000000          <1>  mov eax, sys_write
    83 000005F2 BF01000000          <1>  mov edi, 1
    84 000005F7 48BE-               <1>  mov rsi, %1
    84 000005F9 [1000000000000000]  <1>
    85 00000601 BA07000000          <1>  mov edx, %2
    86 00000606 0F05                <1>  syscall
   766                                      
   767                                      ; Mensaje de victoria
   768 00000608 488B05(50150000)            mov rax, [current_score]    ; Obtener el puntaje final
   769 0000060F 48BF-                       mov rdi, number_buffer      ; Convertir a string
   769 00000611 [5915000000000000] 
   770 00000619 E8AE010000                  call number_to_string
   771                                      
   772                                      ; Definir mensaje de victoria
   773                                      section .data
   774 00001619 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   774 00001622 616465732120C2A148-
   774 0000162B 61732067616E61646F-
   774 00001634 210A0D             
   775                                          win_msg_len: equ $ - win_msg
   776 00001637 50756E74616A652066-             score_msg: db "Puntaje final: "
   776 00001640 696E616C3A20       
   777                                          score_msg_len: equ $ - score_msg
   778                                      section .text
   779                                      
   780                                      ; Imprimir mensajes
   781                                      print win_msg, win_msg_len
    82 0000061E B801000000          <1>  mov eax, sys_write
    83 00000623 BF01000000          <1>  mov edi, 1
    84 00000628 48BE-               <1>  mov rsi, %1
    84 0000062A [1916000000000000]  <1>
    85 00000632 BA1E000000          <1>  mov edx, %2
    86 00000637 0F05                <1>  syscall
   782                                      print score_msg, score_msg_len
    82 00000639 B801000000          <1>  mov eax, sys_write
    83 0000063E BF01000000          <1>  mov edi, 1
    84 00000643 48BE-               <1>  mov rsi, %1
    84 00000645 [3716000000000000]  <1>
    85 0000064D BA0F000000          <1>  mov edx, %2
    86 00000652 0F05                <1>  syscall
   783                                      print number_buffer, 20
    82 00000654 B801000000          <1>  mov eax, sys_write
    83 00000659 BF01000000          <1>  mov edi, 1
    84 0000065E 48BE-               <1>  mov rsi, %1
    84 00000660 [5915000000000000]  <1>
    85 00000668 BA14000000          <1>  mov edx, %2
    86 0000066D 0F05                <1>  syscall
   784                                      
   785                                      ; Esperar un momento antes de salir
   786 0000066F 48C70586F9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   786 00000678 0000               
   787 0000067A 48C70583F9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   787 00000683 0000               
   788                                      sleeptime
    98 00000685 B823000000          <1>  mov eax, sys_nanosleep
    99 0000068A 48BF-               <1>  mov rdi, timespec
    99 0000068C [0000000000000000]  <1>
   100 00000694 31F6                <1>  xor esi, esi
   101 00000696 0F05                <1>  syscall
   789                                      
   790 00000698 E922090000                  jmp exit
   791                                  
   792                                  ; Función para imprimir los bloques
   793                                  ; Función modificada para imprimir bloques
   794                                  
   795                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   796                                  get_current_level_blocks:
   797 0000069D 803D(A4140000)01            cmp byte [current_level], 1
   798 000006A4 7428                        je .level1
   799 000006A6 803D(A4140000)02            cmp byte [current_level], 2
   800 000006AD 7427                        je .level2
   801 000006AF 803D(A4140000)03            cmp byte [current_level], 3
   802 000006B6 7426                        je .level3
   803 000006B8 803D(A4140000)04            cmp byte [current_level], 4
   804 000006BF 7425                        je .level4
   805 000006C1 803D(A4140000)05            cmp byte [current_level], 5
   806 000006C8 7424                        je .level5
   807                                      ; Si llegamos aquí, hay un error en el nivel
   808 000006CA 4831C0                      xor rax, rax
   809 000006CD C3                          ret
   810                                  
   811                                      .level1:
   812 000006CE 488D05(A6140000)                lea rax, [level1_blocks]
   813 000006D5 C3                              ret
   814                                      .level2:
   815 000006D6 488D05(B2140000)                lea rax, [level2_blocks]
   816 000006DD C3                              ret
   817                                      .level3:
   818 000006DE 488D05(B6140000)                lea rax, [level3_blocks]
   819 000006E5 C3                              ret
   820                                      .level4:
   821 000006E6 488D05(BA140000)                lea rax, [level4_blocks]
   822 000006ED C3                              ret
   823                                      .level5:
   824 000006EE 488D05(BE140000)                lea rax, [level5_blocks]
   825 000006F5 C3                              ret
   826                                  ; Función para obtener la cantidad de bloques del nivel actual
   827                                  get_current_level_count:
   828 000006F6 803D(A4140000)01            cmp byte [current_level], 1
   829 000006FD 7428                        je .level1
   830 000006FF 803D(A4140000)02            cmp byte [current_level], 2
   831 00000706 7425                        je .level2
   832 00000708 803D(A4140000)03            cmp byte [current_level], 3
   833 0000070F 7422                        je .level3
   834 00000711 803D(A4140000)04            cmp byte [current_level], 4
   835 00000718 741F                        je .level4
   836 0000071A 803D(A4140000)05            cmp byte [current_level], 5
   837 00000721 741C                        je .level5
   838                                      ; Si llegamos aquí, hay un error en el nivel
   839 00000723 4831C0                      xor rax, rax
   840 00000726 C3                          ret
   841                                  
   842                                      .level1:
   843 00000727 B803000000                      mov rax, level1_blocks_count
   844 0000072C C3                              ret
   845                                      .level2:
   846 0000072D B801000000                      mov rax, level2_blocks_count
   847 00000732 C3                              ret
   848                                      .level3:
   849 00000733 B801000000                      mov rax, level3_blocks_count
   850 00000738 C3                              ret
   851                                      .level4:
   852 00000739 B801000000                      mov rax, level4_blocks_count
   853 0000073E C3                              ret
   854                                      .level5:
   855 0000073F B801000000                      mov rax, level5_blocks_count
   856 00000744 C3                              ret
   857                                  
   858                                  
   859                                  print_blocks:
   860 00000745 55                          push rbp
   861 00000746 4889E5                      mov rbp, rsp
   862                                      
   863                                      ; Obtener puntero a los bloques del nivel actual
   864 00000749 E84FFFFFFF                  call get_current_level_blocks
   865 0000074E 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   866                                      
   867                                      ; Obtener cantidad de bloques del nivel actual
   868 00000751 E8A0FFFFFF                  call get_current_level_count
   869 00000756 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   870                                      
   871 00000759 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   872                                      
   873                                      .print_loop:
   874 0000075C 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   875 0000075F 7D69                            jge .end
   876                                          
   877                                          ; Verificar si el bloque está activo
   878 00000761 490FB68424-                     movzx rax, byte [block_states + r12]
   878 00000766 [C2140000]         
   879 0000076A 4885C0                          test rax, rax
   880 0000076D 7456                            jz .next_block
   881                                          
   882                                          ; Obtener posición y tipo del bloque usando r13
   883 0000076F 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   884 00000774 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   885 00000779 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   886                                          
   887                                          ; El resto de la lógica de impresión permanece igual
   888 0000077E 4D0FB6C0                        movzx r8, r8b
   889 00000782 4D0FB6C9                        movzx r9, r9b
   890 00000786 4981C0[000A0000]                add r8, board
   891 0000078D B850000000                      mov rax, column_cells + 2
   892 00000792 49F7E1                          mul r9
   893 00000795 4901C0                          add r8, rax
   894                                          
   895 00000798 B906000000                      mov rcx, block_length
   896 0000079D 48BE-                           mov rsi, block_type_1
   896 0000079F [8014000000000000] 
   897 000007A7 490FB6C2                        movzx rax, r10b
   898 000007AB 48FFC8                          dec rax
   899 000007AE 486BC006                        imul rax, block_length
   900 000007B2 4801C6                          add rsi, rax
   901                                          
   902                                      .print_block_chars:
   903 000007B5 8A06                            mov al, [rsi]
   904 000007B7 418800                          mov [r8], al
   905 000007BA 48FFC6                          inc rsi
   906 000007BD 49FFC0                          inc r8
   907 000007C0 48FFC9                          dec rcx
   908 000007C3 75F0                            jnz .print_block_chars
   909                                          
   910                                      .next_block:
   911 000007C5 49FFC4                          inc r12
   912 000007C8 EB92                            jmp .print_loop
   913                                          
   914                                      .end:
   915 000007CA 5D                              pop rbp
   916 000007CB C3                              ret
   917                                  
   918                                  ; Función para convertir número a string
   919                                  ; Input: RAX = número a convertir
   920                                  ; RDI = buffer donde escribir el string
   921                                  number_to_string:
   922 000007CC 53                          push rbx
   923 000007CD 52                          push rdx
   924 000007CE 56                          push rsi
   925 000007CF BB0A000000                  mov rbx, 10          ; Divisor
   926 000007D4 B900000000                  mov rcx, 0          ; Contador de dígitos
   927                                      
   928                                      ; Si el número es 0, manejarlo especialmente
   929 000007D9 4885C0                      test rax, rax
   930 000007DC 7509                        jnz .convert_loop
   931 000007DE C60730                      mov byte [rdi], '0'
   932 000007E1 C6470100                    mov byte [rdi + 1], 0
   933 000007E5 EB20                        jmp .end
   934                                      
   935                                      .convert_loop:
   936 000007E7 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   937 000007EA 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   938 000007ED 80C230                          add dl, '0'     ; Convertir a ASCII
   939 000007F0 52                              push rdx        ; Guardar el dígito
   940 000007F1 48FFC1                          inc rcx         ; Incrementar contador
   941 000007F4 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
   942 000007F7 75EE                            jnz .convert_loop
   943                                          
   944                                      .write_loop:
   945 000007F9 5A                              pop rdx         ; Obtener dígito
   946 000007FA 8817                            mov [rdi], dl   ; Escribir al buffer
   947 000007FC 48FFC7                          inc rdi         ; Siguiente posición
   948 000007FF 48FFC9                          dec rcx         ; Decrementar contador
   949 00000802 75F5                            jnz .write_loop
   950                                          
   951 00000804 C60700                      mov byte [rdi], 0   ; Null terminator
   952                                      
   953                                      .end:
   954 00000807 5E                          pop rsi
   955 00000808 5A                          pop rdx
   956 00000809 5B                          pop rbx
   957 0000080A C3                          ret
   958                                  
   959                                  ; Función para imprimir los labels
   960                                  ; Función modificada para convertir número a string con padding
   961                                  number_to_string_padded:
   962 0000080B 55                          push rbp
   963 0000080C 4889E5                      mov rbp, rsp
   964 0000080F 53                          push rbx
   965 00000810 52                          push rdx
   966 00000811 56                          push rsi
   967                                      
   968                                      ; Primero, limpiar el buffer temporal
   969 00000812 B914000000                  mov rcx, 20
   970 00000817 48BF-                       mov rdi, temp_buffer
   970 00000819 [6D15000000000000] 
   971 00000821 30C0                        xor al, al
   972 00000823 F3AA                        rep stosb
   973                                      
   974 00000825 48BF-                       mov rdi, temp_buffer
   974 00000827 [6D15000000000000] 
   975 0000082F BB0A000000                  mov rbx, 10          ; Divisor
   976 00000834 B900000000                  mov rcx, 0          ; Contador de dígitos
   977                                      
   978                                      ; Si el número es 0, manejarlo especialmente
   979 00000839 4885C0                      test rax, rax
   980 0000083C 7509                        jnz .convert_loop
   981 0000083E C605(6D150000)30            mov byte [temp_buffer], '0'
   982 00000845 EB27                        jmp .pad_zeros
   983                                      
   984                                      .convert_loop:
   985 00000847 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   986 0000084A 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   987 0000084D 80C230                          add dl, '0'     ; Convertir a ASCII
   988 00000850 52                              push rdx        ; Guardar el dígito
   989 00000851 48FFC1                          inc rcx         ; Incrementar contador
   990 00000854 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
   991 00000857 75EE                            jnz .convert_loop
   992                                          
   993                                      ; Escribir los dígitos al buffer temporal
   994 00000859 48BF-                       mov rdi, temp_buffer
   994 0000085B [6D15000000000000] 
   995                                      .write_loop:
   996 00000863 5A                              pop rdx         ; Obtener dígito
   997 00000864 8817                            mov [rdi], dl   ; Escribir al buffer
   998 00000866 48FFC7                          inc rdi         ; Siguiente posición
   999 00000869 48FFC9                          dec rcx         ; Decrementar contador
  1000 0000086C 75F5                            jnz .write_loop
  1001                                          
  1002                                      .pad_zeros:
  1003                                          ; r8 contiene el número de dígitos deseados
  1004 0000086E 48BF-                           mov rdi, temp_buffer
  1004 00000870 [6D15000000000000] 
  1005 00000878 E847000000                      call strlen     ; Obtener longitud actual
  1006 0000087D 4C89C1                          mov rcx, r8     ; Número deseado de dígitos
  1007 00000880 4829C1                          sub rcx, rax    ; Calcular cuántos ceros necesitamos
  1008 00000883 7E3A                            jle .end        ; Si no necesitamos ceros, terminar
  1009                                          
  1010                                          ; Mover los dígitos existentes a la derecha
  1011 00000885 48BE-                           mov rsi, temp_buffer
  1011 00000887 [6D15000000000000] 
  1012 0000088F 4801C6                          add rsi, rax    ; Apuntar al final de la cadena actual
  1013 00000892 48BF-                           mov rdi, temp_buffer
  1013 00000894 [6D15000000000000] 
  1014 0000089C 4801CF                          add rdi, rcx    ; Apuntar a donde deben moverse los dígitos
  1015 0000089F 4801C7                          add rdi, rax
  1016 000008A2 48FFCF                          dec rdi
  1017 000008A5 48FFCE                          dec rsi
  1018 000008A8 FD                              std             ; Dirección de cadena inversa
  1019 000008A9 F3A4                            rep movsb
  1020                                          
  1021                                          ; Rellenar con ceros
  1022 000008AB 48BF-                           mov rdi, temp_buffer
  1022 000008AD [6D15000000000000] 
  1023 000008B5 B030                            mov al, '0'
  1024 000008B7 4C89C1                          mov rcx, r8
  1025 000008BA 4829C1                          sub rcx, rax    ; rcx = número de ceros necesarios
  1026 000008BD F3AA                            rep stosb
  1027                                          
  1028                                      .end:
  1029 000008BF 5E                              pop rsi
  1030 000008C0 5A                              pop rdx
  1031 000008C1 5B                              pop rbx
  1032 000008C2 5D                              pop rbp
  1033 000008C3 C3                              ret
  1034                                  
  1035                                  ; Función auxiliar para obtener la longitud de una cadena
  1036                                  strlen:
  1037 000008C4 51                          push rcx
  1038 000008C5 4831C9                      xor rcx, rcx
  1039                                      .loop:
  1040 000008C8 803C0F00                        cmp byte [rdi + rcx], 0
  1041 000008CC 7405                            je .done
  1042 000008CE 48FFC1                          inc rcx
  1043 000008D1 EBF5                            jmp .loop
  1044                                      .done:
  1045 000008D3 4889C8                          mov rax, rcx
  1046 000008D6 59                              pop rcx
  1047 000008D7 C3                              ret
  1048                                  
  1049                                  ; Función modificada para imprimir los labels
  1050                                  print_labels:
  1051 000008D8 55                          push rbp
  1052 000008D9 4889E5                      mov rbp, rsp
  1053                                      
  1054                                      ; Convertir puntaje con padding
  1055 000008DC 488B05(50150000)            mov rax, [current_score]
  1056 000008E3 41B806000000                mov r8, 6           ; Queremos 6 dígitos para el puntaje
  1057 000008E9 E81DFFFFFF                  call number_to_string_padded
  1058                                      
  1059                                      ; Copiar el puntaje al label
  1060 000008EE 48BF-                       mov rdi, score_label
  1060 000008F0 [2615000000000000] 
  1061 000008F8 4883C709                    add rdi, 9          ; Saltar "Puntaje: "
  1062 000008FC 48BE-                       mov rsi, temp_buffer
  1062 000008FE [6D15000000000000] 
  1063 00000906 B906000000                  mov rcx, 6
  1064 0000090B F3A4                        rep movsb
  1065                                      
  1066                                      ; Imprimir el label del puntaje
  1067                                      print score_label, score_label_len
    82 0000090D B801000000          <1>  mov eax, sys_write
    83 00000912 BF01000000          <1>  mov edi, 1
    84 00000917 48BE-               <1>  mov rsi, %1
    84 00000919 [2615000000000000]  <1>
    85 00000921 BA11000000          <1>  mov edx, %2
    86 00000926 0F05                <1>  syscall
  1068                                      
  1069                                      ; Convertir bloques destruidos con padding
  1070 00000928 480FB605(58150000)          movzx rax, byte [destroyed_blocks]
  1071 00000930 41B803000000                mov r8, 3           ; Queremos 3 dígitos para los bloques
  1072 00000936 E8D0FEFFFF                  call number_to_string_padded
  1073                                      
  1074                                      ; Copiar los bloques destruidos al label
  1075 0000093B 48BF-                       mov rdi, blocks_label
  1075 0000093D [3715000000000000] 
  1076 00000945 4883C713                    add rdi, 19         ; Saltar "Bloques destruidos: "
  1077 00000949 48BE-                       mov rsi, temp_buffer
  1077 0000094B [6D15000000000000] 
  1078 00000953 B903000000                  mov rcx, 3
  1079 00000958 F3A4                        rep movsb
  1080                                      
  1081                                      ; Imprimir el label de bloques destruidos
  1082                                      print blocks_label, blocks_label_len
    82 0000095A B801000000          <1>  mov eax, sys_write
    83 0000095F BF01000000          <1>  mov edi, 1
    84 00000964 48BE-               <1>  mov rsi, %1
    84 00000966 [3715000000000000]  <1>
    85 0000096E BA19000000          <1>  mov edx, %2
    86 00000973 0F05                <1>  syscall
  1083                                      
  1084 00000975 5D                          pop rbp
  1085 00000976 C3                          ret
  1086                                  
  1087                                  ; Función modificada para detectar colisión
  1088                                  ; Función mejorada para detectar colisión y manejar la física
  1089                                  ; Función corregida para manejar colisiones con bloques completos
  1090                                  ;---------------------------------------------------------
  1091                                  ; check_block_collision:
  1092                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1093                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1094                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1095                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1096                                  ;   retorna 0.
  1097                                  ;---------------------------------------------------------
  1098                                  ;--------------------------------------
  1099                                  ; check_block_collision
  1100                                  ;--------------------------------------
  1101                                  ; Actualizar check_block_collision para usar el nivel actual
  1102                                  check_block_collision:
  1103 00000977 55                          push rbp
  1104 00000978 4889E5                      mov rbp, rsp
  1105                                  
  1106 0000097B 418A02                      mov al, [r10]
  1107                                  
  1108                                      ; Verificación de caracteres igual que antes...
  1109 0000097E 3C55                        cmp al, 'U'  
  1110 00000980 7419                        je .possible
  1111 00000982 3C4F                        cmp al, 'O'  
  1112 00000984 7415                        je .possible
  1113 00000986 3C44                        cmp al, 'D'  
  1114 00000988 7411                        je .possible
  1115 0000098A 3C4C                        cmp al, 'L'  
  1116 0000098C 740D                        je .possible
  1117 0000098E 3C56                        cmp al, 'V'  
  1118 00000990 7409                        je .possible
  1119 00000992 3C38                        cmp al, '8'  
  1120 00000994 7405                        je .possible
  1121                                  
  1122 00000996 4831C0                      xor rax, rax
  1123 00000999 5D                          pop rbp
  1124 0000099A C3                          ret
  1125                                  
  1126                                      .possible:
  1127 0000099B 53                              push rbx
  1128 0000099C 57                              push rdi
  1129 0000099D 56                              push rsi
  1130 0000099E 4154                            push r12
  1131                                  
  1132                                          ; Obtener puntero a los bloques del nivel actual
  1133 000009A0 E8F8FCFFFF                      call get_current_level_blocks
  1134 000009A5 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
  1135                                          
  1136                                          ; Obtener cantidad de bloques del nivel actual
  1137 000009A8 E849FDFFFF                      call get_current_level_count
  1138 000009AD 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
  1139                                  
  1140 000009B0 4D31E4                          xor r12, r12
  1141                                      .find_block_loop:
  1142 000009B3 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1143 000009B6 0F8DB0000000                    jge .no_block_found
  1144                                  
  1145                                          ; El resto de la lógica de verificación de colisiones...
  1146 000009BC 418A9C24[C2140000]              mov bl, [block_states + r12]
  1147 000009C4 84DB                            test bl, bl
  1148 000009C6 0F8498000000                    jz .next_block
  1149                                  
  1150                                          ; Usar r13 para acceder a los bloques del nivel actual
  1151 000009CC 4C89E8                          mov rax, r13
  1152 000009CF 4D6BE404                        imul r12, 4
  1153 000009D3 4C01E0                          add rax, r12
  1154 000009D6 8A10                            mov dl, [rax]       ; x
  1155 000009D8 8A4801                          mov cl, [rax+1]     ; y
  1156                                  
  1157                                          ; Revertir r12
  1158 000009DB 4D89E4                          mov r12, r12
  1159 000009DE 49C1EC02                        shr r12, 2
  1160                                  
  1161                                          ; La misma lógica de detección de colisiones...
  1162 000009E2 488D3D(000A0000)                lea rdi, [board]
  1163 000009E9 4831C0                          xor rax, rax
  1164 000009EC B850000000                      mov rax, column_cells + 2
  1165 000009F1 480FB6C9                        movzx rcx, cl
  1166 000009F5 480FAFC1                        imul rax, rcx
  1167 000009F9 4801C7                          add rdi, rax
  1168 000009FC 480FB6C2                        movzx rax, dl
  1169 00000A00 4801C7                          add rdi, rax
  1170                                  
  1171 00000A03 4939FA                          cmp r10, rdi
  1172 00000A06 725C                            jb .next_block
  1173 00000A08 488D5F06                        lea rbx, [rdi + 6]
  1174 00000A0C 4939DA                          cmp r10, rbx
  1175 00000A0F 7353                            jae .next_block
  1176                                  
  1177                                          ; Manejo de colisión igual que antes...
  1178 00000A11 41FE8C24[C2140000]              dec byte [block_states + r12]
  1179 00000A19 418A9C24[C2140000]              mov bl, [block_states + r12]
  1180 00000A21 84DB                            test bl, bl
  1181 00000A23 7533                            jnz .still_alive
  1182                                  
  1183 00000A25 B906000000                      mov rcx, block_length
  1184                                      .erase_block_chars:
  1185 00000A2A C60720                          mov byte [rdi], char_space
  1186 00000A2D 48FFC7                          inc rdi
  1187 00000A30 E2F8                            loop .erase_block_chars
  1188                                  
  1189 00000A32 FE0D(A5140000)                  dec byte [blocks_remaining]
  1190 00000A38 FE05(58150000)                  inc byte [destroyed_blocks]     ; Incrementar contador de bloques destruidos
  1191                                      
  1192                                          ; Calcular puntos basado en la durabilidad original del bloque
  1193 00000A3E 4C89E0                          mov rax, r12                    ; Índice del bloque
  1194 00000A41 486BC004                        imul rax, 4                     ; Multiplicar por 4 (tamaño de cada entrada)
  1195 00000A45 4C01E8                          add rax, r13                    ; Agregar base de los bloques
  1196 00000A48 480FB64002                      movzx rax, byte [rax + 2]       ; Obtener tipo de bloque (durabilidad original)
  1197 00000A4D 486BC00A                        imul rax, 10                    ; Multiplicar por 10
  1198 00000A51 480105(50150000)                add [current_score], rax        ; Agregar al score total
  1199                                  
  1200                                      .still_alive:
  1201 00000A58 B801000000                      mov rax, 1
  1202 00000A5D 415C                            pop r12
  1203 00000A5F 5E                              pop rsi
  1204 00000A60 5F                              pop rdi
  1205 00000A61 5B                              pop rbx
  1206 00000A62 5D                              pop rbp
  1207 00000A63 C3                              ret
  1208                                  
  1209                                      .next_block:
  1210 00000A64 49FFC4                          inc r12
  1211 00000A67 E947FFFFFF                      jmp .find_block_loop
  1212                                  
  1213                                      .no_block_found:
  1214 00000A6C 4831C0                          xor rax, rax
  1215 00000A6F 415C                            pop r12
  1216 00000A71 5E                              pop rsi
  1217 00000A72 5F                              pop rdi
  1218 00000A73 5B                              pop rbx
  1219 00000A74 5D                              pop rbp
  1220 00000A75 C3                              ret
  1221                                  
  1222                                  init_enemies:
  1223 00000A76 55                          push rbp
  1224 00000A77 4889E5                      mov rbp, rsp
  1225                                      ; Reiniciar contadores de movimiento
  1226 00000A7A C605(AF150000)00            mov byte [enemy_move_total], 0
  1227 00000A81 C605(B0150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1228                                      ; Limpiar estado previo de enemigos
  1229 00000A88 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1230 00000A8D 488D3D(86150000)            lea rdi, [enemies]
  1231 00000A94 30C0                        xor al, al
  1232 00000A96 F3AA                        rep stosb ; Limpiar datos de enemigos
  1233                                      
  1234                                      ; Marcar todos los enemigos como inactivos
  1235 00000A98 488D3D(0F160000)            lea rdi, [enemy_spawns_triggered]
  1236 00000A9F 30C0                        xor al, al
  1237 00000AA1 B90A000000                  mov rcx, 10
  1238 00000AA6 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1239                                  
  1240 00000AA8 5D                          pop rbp
  1241 00000AA9 C3                          ret
  1242                                  
  1243                                  
  1244                                  ; Función para mover enemigos
  1245                                  move_enemies:
  1246 00000AAA 55                          push rbp
  1247 00000AAB 4889E5                      mov rbp, rsp
  1248                                      
  1249                                      ; Incrementar contador de movimiento
  1250 00000AAE FE05(AD150000)              inc byte [enemy_move_counter]
  1251 00000AB4 480FB605(AD150000)          movzx rax, byte [enemy_move_counter]
  1252 00000ABC 3A05(AE150000)              cmp al, [enemy_move_delay]
  1253 00000AC2 0F85AA010000                jne .end
  1254                                      
  1255                                      ; Resetear contador
  1256 00000AC8 C605(AD150000)00            mov byte [enemy_move_counter], 0
  1257                                      
  1258 00000ACF 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1259                                      
  1260                                      .enemy_loop:
  1261 00000AD2 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1262 00000AD6 0F8D96010000                    jge .end
  1263                                          
  1264                                          ; Calcular offset del enemigo actual
  1265 00000ADC 4C89E0                          mov rax, r12
  1266 00000ADF 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1267 00000AE3 488DB0[86150000]                lea rsi, [enemies + rax]
  1268                                          
  1269                                          ; Verificar si el enemigo está activo
  1270 00000AEA 807E0201                        cmp byte [rsi + 2], 1
  1271 00000AEE 0F8576010000                    jne .next_enemy
  1272                                          
  1273                                          ; Obtener posición actual
  1274 00000AF4 4C0FB606                        movzx r8, byte [rsi]            ; X
  1275 00000AF8 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1276                                          
  1277                                          ; Limpiar posición actual antes de mover
  1278 00000AFD 4150                            push r8
  1279 00000AFF 4151                            push r9
  1280 00000B01 B84E000000                      mov rax, column_cells
  1281 00000B06 4883C002                        add rax, 2
  1282 00000B0A 49F7E1                          mul r9
  1283 00000B0D 4C01C0                          add rax, r8
  1284 00000B10 488DB8[000A0000]                lea rdi, [board + rax]
  1285 00000B17 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1286 00000B1A 4159                            pop r9
  1287 00000B1C 4158                            pop r8
  1288                                  
  1289                                          ; Determinar comportamiento basado en índice
  1290 00000B1E 4C89E0                          mov rax, r12
  1291 00000B21 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1292 00000B25 4885C0                          test rax, rax
  1293 00000B28 7402                            jz .chase_ball
  1294 00000B2A EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1295                                          
  1296                                          ; Perseguir bola (comportamiento original)
  1297                                      .chase_ball:
  1298 00000B2C 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1299 00000B33 4D39D0                          cmp r8, r10
  1300 00000B36 0F8F96000000                    jg .move_left
  1301 00000B3C 0F8C95000000                    jl .move_right
  1302                                          
  1303 00000B42 4C8B15(57140000)                mov r10, [ball_y_pos]
  1304 00000B49 4D39D1                          cmp r9, r10
  1305 00000B4C 0F8F8A000000                    jg .move_up
  1306 00000B52 0F8C89000000                    jl .move_down
  1307 00000B58 E9A5000000                      jmp .check_collision
  1308                                          
  1309                                      .chase_paddle:
  1310                                          ; Obtener la posición X actual de la paleta
  1311 00000B5D 4C8B15(3F140000)                mov r10, [pallet_position]
  1312 00000B64 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1313                                          
  1314                                          ; Calcular la posición X real de la paleta
  1315 00000B6B 4C89D0                          mov rax, r10
  1316 00000B6E BB4E000000                      mov rbx, column_cells
  1317 00000B73 4883C302                        add rbx, 2                  ; Añadir newline chars
  1318 00000B77 4831D2                          xor rdx, rdx
  1319 00000B7A 48F7F3                          div rbx                     ; rax = y, rdx = x
  1320                                          
  1321                                          ; rdx ahora contiene la posición X de la paleta
  1322                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1323 00000B7D 488B0D(47140000)                mov rcx, [pallet_size]
  1324 00000B84 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1325 00000B87 4801CA                          add rdx, rcx
  1326                                          
  1327                                          ; Comparar con posición X del enemigo y mover gradualmente
  1328 00000B8A 4939D0                          cmp r8, rdx
  1329 00000B8D 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1330 00000B8F 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1331 00000B91 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1332                                  
  1333                                      .check_y_paddle:
  1334                                          ; La Y de la paleta siempre es row_cells - 2
  1335 00000B93 41BA20000000                    mov r10, row_cells
  1336 00000B99 4983EA02                        sub r10, 2
  1337                                          
  1338                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1339 00000B9D 4D39D1                          cmp r9, r10
  1340 00000BA0 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1341 00000BA2 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1342 00000BA4 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1343                                          
  1344                                      .no_movement:
  1345 00000BA6 EB5A                            jmp .check_collision
  1346                                  
  1347                                      ; También agregar una nueva sección para el movimiento suave
  1348                                      .smooth_transition:
  1349                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1350 00000BA8 8A05(B0150000)                  mov al, [enemy_target]
  1351 00000BAE 84C0                            test al, al
  1352 00000BB0 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1353                                          
  1354                                          ; Verificar distancia en X
  1355 00000BB2 4989D2                          mov r10, rdx              ; Posición X objetivo
  1356 00000BB5 4D29C2                          sub r10, r8               ; Calcular diferencia
  1357 00000BB8 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1358 00000BBC 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1359 00000BBE 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1360 00000BC2 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1361 00000BC4 EB3C                            jmp .check_collision
  1362                                          
  1363                                      .limit_right_movement:
  1364 00000BC6 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1365 00000BCA EB36                            jmp .check_collision
  1366                                          
  1367                                      .limit_left_movement:
  1368 00000BCC 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1369 00000BD0 EB30                            jmp .check_collision
  1370                                      .move_left:
  1371 00000BD2 49FFC8                          dec r8
  1372 00000BD5 EB0F                            jmp .check_vertical
  1373                                          
  1374                                      .move_right:
  1375 00000BD7 49FFC0                          inc r8
  1376 00000BDA EB0A                            jmp .check_vertical
  1377                                          
  1378                                      .move_up:
  1379 00000BDC 49FFC9                          dec r9
  1380 00000BDF EB21                            jmp .check_collision
  1381                                          
  1382                                      .move_down:
  1383 00000BE1 49FFC1                          inc r9
  1384 00000BE4 EB1C                            jmp .check_collision
  1385                                          
  1386                                      .check_vertical:
  1387 00000BE6 8A05(B0150000)                  mov al, [enemy_target]
  1388 00000BEC 84C0                            test al, al
  1389 00000BEE 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1390 00000BF4 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1391 00000BFB 4D39D1                          cmp r9, r10
  1392 00000BFE 7FDC                            jg .move_up
  1393 00000C00 7CDF                            jl .move_down
  1394                                          
  1395                                      .check_collision:
  1396                                          ; Verificar colisión con bordes
  1397 00000C02 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1398 00000C06 7E62                            jle .next_enemy
  1399 00000C08 4983F84E                        cmp r8, column_cells
  1400 00000C0C 7D5C                            jge .next_enemy
  1401 00000C0E 4983F901                        cmp r9, 1                       ; Borde superior
  1402 00000C12 7E56                            jle .next_enemy
  1403 00000C14 4983F920                        cmp r9, row_cells
  1404 00000C18 7D50                            jge .next_enemy
  1405                                          
  1406                                          ; Verificar colisión con bloques antes de moverse
  1407 00000C1A 4150                            push r8
  1408 00000C1C 4151                            push r9
  1409 00000C1E 4152                            push r10
  1410                                          
  1411                                          ; Calcular posición en el tablero para verificar
  1412 00000C20 B84E000000                      mov rax, column_cells
  1413 00000C25 4883C002                        add rax, 2
  1414 00000C29 49F7E1                          mul r9
  1415 00000C2C 4C01C0                          add rax, r8
  1416 00000C2F 4C8D90[000A0000]                lea r10, [board + rax]
  1417                                          
  1418                                          ; Verificar si hay un bloque en la nueva posición
  1419 00000C36 418A02                          mov al, [r10]
  1420 00000C39 3C55                            cmp al, 'U'
  1421 00000C3B 7427                            je .invalid_move
  1422 00000C3D 3C4F                            cmp al, 'O'
  1423 00000C3F 7423                            je .invalid_move
  1424 00000C41 3C44                            cmp al, 'D'
  1425 00000C43 741F                            je .invalid_move
  1426 00000C45 3C4C                            cmp al, 'L'
  1427 00000C47 741B                            je .invalid_move
  1428 00000C49 3C56                            cmp al, 'V'
  1429 00000C4B 7417                            je .invalid_move
  1430 00000C4D 3C38                            cmp al, '8'
  1431 00000C4F 7413                            je .invalid_move
  1432 00000C51 3C58                            cmp al, 'X'
  1433 00000C53 740F                            je .invalid_move
  1434                                          
  1435 00000C55 415A                            pop r10
  1436 00000C57 4159                            pop r9
  1437 00000C59 4158                            pop r8
  1438                                          
  1439                                          ; Guardar nueva posición si es válida
  1440 00000C5B 448806                          mov [rsi], r8b
  1441 00000C5E 44884E01                        mov [rsi + 1], r9b
  1442 00000C62 EB06                            jmp .next_enemy
  1443                                          
  1444                                      .invalid_move:
  1445 00000C64 415A                            pop r10
  1446 00000C66 4159                            pop r9
  1447 00000C68 4158                            pop r8
  1448                                          
  1449                                      .next_enemy:
  1450 00000C6A 49FFC4                          inc r12
  1451 00000C6D E960FEFFFF                      jmp .enemy_loop
  1452                                          
  1453                                      .end:
  1454 00000C72 5D                              pop rbp
  1455 00000C73 C3                              ret
  1456                                  
  1457                                  get_current_spawn_points:
  1458 00000C74 55                          push rbp
  1459 00000C75 4889E5                      mov rbp, rsp
  1460                                      
  1461 00000C78 480FB605(A4140000)          movzx rax, byte [current_level]
  1462 00000C80 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1463 00000C83 488B04C5[E4150000]          mov rax, [spawn_points_table + rax * 8]
  1464                                      
  1465 00000C8B 5D                          pop rbp
  1466 00000C8C C3                          ret
  1467                                  
  1468                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1469                                  check_enemy_spawn:
  1470 00000C8D 55                          push rbp
  1471 00000C8E 4889E5                      mov rbp, rsp
  1472                                      
  1473                                      ; Obtener spawn points del nivel actual
  1474 00000C91 E8DEFFFFFF                  call get_current_spawn_points
  1475 00000C96 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1476                                      
  1477                                      ; Obtener cantidad de bloques destruidos
  1478 00000C99 4C0FB62D(58150000)          movzx r13, byte [destroyed_blocks]
  1479                                      
  1480                                      ; Verificar cada punto de spawn
  1481 00000CA1 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1482                                      
  1483                                      .check_loop:
  1484 00000CA4 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1485 00000CA8 7D4B                            jge .end
  1486                                          
  1487                                          ; Verificar si este spawn point ya fue usado
  1488 00000CAA 80B9[0F160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1489 00000CB1 743D                            je .next_enemy
  1490                                          
  1491                                          ; Verificar si este enemigo ya está activo
  1492 00000CB3 4889C8                          mov rax, rcx
  1493 00000CB6 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1494 00000CBA 488DB0[86150000]                lea rsi, [enemies + rax]
  1495 00000CC1 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1496 00000CC5 7429                            je .next_enemy
  1497                                          
  1498                                          ; Verificar si debemos spawnear este enemigo
  1499 00000CC7 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1500 00000CCC 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1501 00000CCF 751F                            jne .next_enemy
  1502                                          
  1503                                          ; Marcar este spawn point como usado
  1504 00000CD1 C681[0F160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1505                                          
  1506                                          ; Spawner nuevo enemigo
  1507 00000CD8 C60628                          mov byte [rsi], 40             ; X inicial
  1508 00000CDB C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1509 00000CDF C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1510                                          
  1511                                          ; Inicializar comportamiento
  1512 00000CE3 4889C8                          mov rax, rcx
  1513 00000CE6 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1514 00000CEA 8805(0E160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1515                                          
  1516                                      .next_enemy:
  1517 00000CF0 48FFC1                          inc rcx
  1518 00000CF3 EBAF                            jmp .check_loop
  1519                                          
  1520                                      .end:
  1521 00000CF5 5D                              pop rbp
  1522 00000CF6 C3                              ret
  1523                                  
  1524                                  
  1525                                  ; Función para dibujar enemigos
  1526                                  print_enemies:
  1527 00000CF7 55                          push rbp
  1528 00000CF8 4889E5                      mov rbp, rsp
  1529                                      
  1530 00000CFB 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1531                                      
  1532                                      .print_loop:
  1533 00000CFE 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1534 00000D02 7D4B                            jge .end
  1535                                          
  1536                                          ; Calcular offset del enemigo actual
  1537 00000D04 4C89E0                          mov rax, r12
  1538 00000D07 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1539 00000D0B 488DB0[86150000]                lea rsi, [enemies + rax]
  1540                                          
  1541                                          ; Verificar si el enemigo está activo
  1542 00000D12 807E0201                        cmp byte [rsi + 2], 1
  1543 00000D16 7532                            jne .next_enemy
  1544                                          
  1545                                          ; Calcular posición en el tablero
  1546 00000D18 4C0FB606                        movzx r8, byte [rsi]            ; X
  1547 00000D1C 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1548                                          
  1549                                          ; Calcular offset en el tablero
  1550 00000D21 B84E000000                      mov rax, column_cells
  1551 00000D26 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1552 00000D2A 49F7E1                          mul r9
  1553 00000D2D 4C01C0                          add rax, r8
  1554 00000D30 488DB8[000A0000]                lea rdi, [board + rax]
  1555                                          
  1556                                          ; Obtener carácter del enemigo según el nivel
  1557 00000D37 480FB605(A4140000)              movzx rax, byte [current_level]
  1558 00000D3F 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1559 00000D42 8A80[81150000]                  mov al, [enemy_chars + rax]
  1560                                          
  1561                                          ; Dibujar enemigo
  1562 00000D48 8807                            mov [rdi], al
  1563                                          
  1564                                      .next_enemy:
  1565 00000D4A 49FFC4                          inc r12
  1566 00000D4D EBAF                            jmp .print_loop
  1567                                          
  1568                                      .end:
  1569 00000D4F 5D                              pop rbp
  1570 00000D50 C3                              ret
  1571                                  
  1572                                  ; Función para verificar colisión con enemigos
  1573                                  ; Función para verificar colisión con enemigos
  1574                                  check_enemy_collision:
  1575 00000D51 55                          push rbp
  1576 00000D52 4889E5                      mov rbp, rsp
  1577                                      
  1578 00000D55 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1579 00000D58 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1580                                      
  1581                                      .check_loop:
  1582 00000D5B 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1583 00000D5F 0F8DE9000000                    jge .end
  1584                                          
  1585                                          ; Calcular offset del enemigo actual
  1586 00000D65 4C89E1                          mov rcx, r12
  1587 00000D68 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1588 00000D6C 488DB1[86150000]                lea rsi, [enemies + rcx]
  1589                                          
  1590                                          ; Verificar si el enemigo está activo
  1591 00000D73 807E0201                        cmp byte [rsi + 2], 1
  1592 00000D77 0F85C9000000                    jne .next_enemy
  1593                                          
  1594                                          ; Verificar colisión con la bola
  1595 00000D7D 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1596 00000D81 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1597                                          
  1598                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1599 00000D86 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1600 00000D8D 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1601                                          
  1602                                          ; Comprobar colisión vertical (misma columna)
  1603 00000D94 4D39C2                          cmp r10, r8
  1604 00000D97 7525                            jne .check_horizontal
  1605 00000D99 4D29CB                          sub r11, r9
  1606 00000D9C 4983FB01                        cmp r11, 1
  1607 00000DA0 7F1C                            jg .check_horizontal
  1608 00000DA2 4983FBFF                        cmp r11, -1
  1609 00000DA6 7C16                            jl .check_horizontal
  1610                                          
  1611                                          ; Colisión vertical detectada
  1612 00000DA8 E8A3000000                      call destroy_enemy
  1613 00000DAD 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1614 00000DB4 B801000000                      mov rax, 1
  1615 00000DB9 E990000000                      jmp .end
  1616                                          
  1617                                      .check_horizontal:
  1618                                          ; Comprobar colisión horizontal (misma fila)
  1619 00000DBE 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1620 00000DC5 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1621 00000DCC 4D39CB                          cmp r11, r9
  1622 00000DCF 7522                            jne .check_paddle
  1623 00000DD1 4D29C2                          sub r10, r8
  1624 00000DD4 4983FA01                        cmp r10, 1
  1625 00000DD8 7F19                            jg .check_paddle
  1626 00000DDA 4983FAFF                        cmp r10, -1
  1627 00000DDE 7C13                            jl .check_paddle
  1628                                          
  1629                                          ; Colisión horizontal detectada
  1630 00000DE0 E86B000000                      call destroy_enemy
  1631 00000DE5 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1632 00000DEC B801000000                      mov rax, 1
  1633 00000DF1 EB5B                            jmp .end
  1634                                          
  1635                                      .check_paddle:
  1636                                          ; Verificar colisión con la paleta
  1637 00000DF3 4C8B15(3F140000)                mov r10, [pallet_position]
  1638 00000DFA 4981EA[000A0000]                sub r10, board
  1639 00000E01 4C89D0                          mov rax, r10
  1640 00000E04 41BB4E000000                    mov r11, column_cells
  1641 00000E0A 4983C302                        add r11, 2
  1642 00000E0E 4831D2                          xor rdx, rdx
  1643 00000E11 49F7F3                          div r11                     ; División para obtener la posición Y
  1644 00000E14 4989D3                          mov r11, rdx               ; X de la paleta en r11
  1645                                          
  1646 00000E17 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  1647                                          
  1648                                          ; Verificar si el enemigo está en la misma fila que la paleta
  1649 00000E1E 41BD20000000                    mov r13, row_cells
  1650 00000E24 4983ED02                        sub r13, 2                 ; Y de la paleta
  1651 00000E28 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  1652 00000E2B 7519                            jne .next_enemy
  1653                                          
  1654                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  1655 00000E2D 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  1656 00000E30 7C14                            jl .next_enemy
  1657                                          
  1658 00000E32 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  1659 00000E35 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  1660 00000E38 7F0C                            jg .next_enemy
  1661                                          
  1662                                          ; Si llegamos aquí, hay colisión con la paleta
  1663 00000E3A E811000000                      call destroy_enemy        ; Destruir el enemigo
  1664 00000E3F B801000000                      mov rax, 1                ; Indicar que hubo colisión
  1665 00000E44 EB08                            jmp .end
  1666                                          
  1667                                      .next_enemy:
  1668 00000E46 49FFC4                          inc r12
  1669 00000E49 E90DFFFFFF                      jmp .check_loop
  1670                                          
  1671                                      .end:
  1672 00000E4E 5D                              pop rbp
  1673 00000E4F C3                              ret
  1674                                  
  1675                                  ; Función para destruir un enemigo
  1676                                  destroy_enemy:
  1677                                      ; Desactivar enemigo
  1678 00000E50 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  1679                                  
  1680                                      ; Sumar puntos por destruir enemigo
  1681 00000E54 488B05(A5150000)            mov rax, [enemy_points]
  1682 00000E5B 480105(50150000)            add [current_score], rax
  1683                                  
  1684                                      ; No tocar bloques destruidos aquí
  1685 00000E62 C3                          ret
  1686                                  
  1687                                  
  1688                                  _start:
  1689 00000E63 E8C3F2FFFF              	call canonical_off
  1690 00000E68 E8DF000000              	call start_screen
  1691 00000E6D E8E6F5FFFF                  call init_level
  1692 00000E72 E8FFFBFFFF                  call init_enemies
  1693 00000E77 EB00                    	jmp .main_loop
  1694                                  	
  1695                                  
  1696                                  	.main_loop:
  1697 00000E79 E85AFAFFFF                      call print_labels
  1698 00000E7E E882F3FFFF              		call print_pallet
  1699 00000E83 E80DF4FFFF                      call move_ball
  1700 00000E88 E8B8F8FFFF                      call print_blocks
  1701 00000E8D E815F7FFFF                      call check_level_complete
  1702 00000E92 E8F6FDFFFF                      call check_enemy_spawn
  1703 00000E97 E80EFCFFFF                      call move_enemies
  1704 00000E9C E8B0FEFFFF                      call check_enemy_collision
  1705 00000EA1 E851FEFFFF                      call print_enemies
  1706 00000EA6 E832F3FFFF              		call print_ball
  1707                                  		print board, board_size				
    82 00000EAB B801000000          <1>  mov eax, sys_write
    83 00000EB0 BF01000000          <1>  mov edi, 1
    84 00000EB5 48BE-               <1>  mov rsi, %1
    84 00000EB7 [000A000000000000]  <1>
    85 00000EBF BA000A0000          <1>  mov edx, %2
    86 00000EC4 0F05                <1>  syscall
  1708                                  		;setnonblocking	
  1709                                  	.read_more:	
  1710                                  		getchar	
    90 00000EC6 B800000000          <1>  mov rax, sys_read
    91 00000ECB BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000ED0 48BE-               <1>  mov rsi, input_char
    92 00000ED2 [0000000000000000]  <1>
    93 00000EDA BA01000000          <1>  mov rdx, 1
    94 00000EDF 0F05                <1>  syscall
  1711                                  		
  1712 00000EE1 4883F801                		cmp rax, 1
  1713 00000EE5 7532                        	jne .done
  1714                                  		
  1715 00000EE7 8A05(00000000)          		mov al,[input_char]
  1716                                  
  1717 00000EED 3C61                    		cmp al, 'a'
  1718 00000EEF 750E                    	    jne .not_left
  1719 00000EF1 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1720 00000EF8 E823F3FFFF              		call move_pallet
  1721 00000EFD EB1A                    	    jmp .done
  1722                                  		
  1723                                  		.not_left:
  1724 00000EFF 3C64                    		 	cmp al, 'd'
  1725 00000F01 750C                    	    	jne .not_right
  1726 00000F03 BF01000000              			mov rdi, right_direction
  1727 00000F08 E813F3FFFF              	    	call move_pallet
  1728 00000F0D EB0A                        		jmp .done		
  1729                                  
  1730                                  		.not_right:
  1731                                  
  1732 00000F0F 3C71                        		cmp al, 'q'
  1733 00000F11 0F84A8000000                		je exit
  1734                                  
  1735 00000F17 EBAD                    			jmp .read_more
  1736                                  		
  1737                                  		.done:	
  1738                                  			;unsetnonblocking		
  1739                                  			sleeptime	
    98 00000F19 B823000000          <1>  mov eax, sys_nanosleep
    99 00000F1E 48BF-               <1>  mov rdi, timespec
    99 00000F20 [0000000000000000]  <1>
   100 00000F28 31F6                <1>  xor esi, esi
   101 00000F2A 0F05                <1>  syscall
  1740                                  			print clear, clear_length
    82 00000F2C B801000000          <1>  mov eax, sys_write
    83 00000F31 BF01000000          <1>  mov edi, 1
    84 00000F36 48BE-               <1>  mov rsi, %1
    84 00000F38 [1000000000000000]  <1>
    85 00000F40 BA07000000          <1>  mov edx, %2
    86 00000F45 0F05                <1>  syscall
  1741 00000F47 E92DFFFFFF                  		jmp .main_loop
  1742                                  
  1743                                  
  1744                                  
  1745                                  start_screen:
  1746                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000F4C B801000000          <1>  mov eax, sys_write
    83 00000F51 BF01000000          <1>  mov edi, 1
    84 00000F56 48BE-               <1>  mov rsi, %1
    84 00000F58 [1000000000000000]  <1>
    85 00000F60 BA07000000          <1>  mov edx, %2
    86 00000F65 0F05                <1>  syscall
  1747                                      print msg1, msg1_length
    82 00000F67 B801000000          <1>  mov eax, sys_write
    83 00000F6C BF01000000          <1>  mov edi, 1
    84 00000F71 48BE-               <1>  mov rsi, %1
    84 00000F73 [1700000000000000]  <1>
    85 00000F7B BA14010000          <1>  mov edx, %2
    86 00000F80 0F05                <1>  syscall
  1748                                      
  1749                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1750                                          getchar                 ; Esperamos una tecla
    90 00000F82 B800000000          <1>  mov rax, sys_read
    91 00000F87 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000F8C 48BE-               <1>  mov rsi, input_char
    92 00000F8E [0000000000000000]  <1>
    93 00000F96 BA01000000          <1>  mov rdx, 1
    94 00000F9B 0F05                <1>  syscall
  1751 00000F9D 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1752 00000FA1 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1753                                          
  1754                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000FA3 B801000000          <1>  mov eax, sys_write
    83 00000FA8 BF01000000          <1>  mov edi, 1
    84 00000FAD 48BE-               <1>  mov rsi, %1
    84 00000FAF [1000000000000000]  <1>
    85 00000FB7 BA07000000          <1>  mov edx, %2
    86 00000FBC 0F05                <1>  syscall
  1755 00000FBE C3                          ret
  1756                                  
  1757                                  exit: 
  1758 00000FBF E8A9F1FFFF              	call canonical_on
  1759 00000FC4 B83C000000              	mov    rax, 60
  1760 00000FC9 BF00000000                  mov    rdi, 0
  1761 00000FCE 0F05                        syscall
  1762                                  
