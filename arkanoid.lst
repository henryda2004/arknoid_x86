     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001480 00                          ball_active db 0
   258                                  
   259 00001481 0000000000000000            ball2_x_pos:        dq 0
   260 00001489 0000000000000000            ball2_y_pos:        dq 0
   261 00001491 0000000000000000            ball2_direction_x:  dq 0
   262 00001499 0000000000000000            ball2_direction_y:  dq 0
   263 000014A1 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 000014A2 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 000014A3 0000000000000000            ball3_x_pos:        dq 0
   268 000014AB 0000000000000000            ball3_y_pos:        dq 0
   269 000014B3 0000000000000000            ball3_direction_x:  dq 0
   270 000014BB 0000000000000000            ball3_direction_y:  dq 0
   271 000014C3 00                          ball3_moving:       db 0
   272 000014C4 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 000014C5 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 000014CD [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 000014D5 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 000014DB 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 000014E1 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 000014E7 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 000014ED 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 000014F3 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 000014F9 01                          current_level db 1
   300 000014FA 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 000014FB 3A07030143                      db 58, 7, 3, 1, 'C'    ; Bloque 7
   307 00001500 3D09030144                      db 61, 9, 3, 1, 'D'    ; Bloque 7
   308 00001505 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   309 0000150A 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   310 0000150F 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   311 00001514 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   312 00001519 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   313 0000151E 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   314                                  
   315                                  
   316                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   317                                  
   318                                      ; Nivel 2: Bloques de prueba
   319                                      level2_blocks:
   320 00001523 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   321                                      level2_blocks_count equ 1
   322                                  
   323                                      ; Nivel 3
   324                                      level3_blocks:
   325 00001528 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   326                                  
   327                                      level3_blocks_count equ 1
   328                                  
   329                                      ; Nivel 4
   330                                      level4_blocks:
   331 0000152D 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   332                                      level4_blocks_count equ 1
   333                                  
   334                                      ; Nivel 5
   335                                      level5_blocks:
   336 00001532 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   337                                      level5_blocks_count equ 1
   338                                  
   339                                      ; Array para mantener el estado de los bloques
   340 00001537 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   341                                  
   342                                      
   343                                      ; Variables para almacenar los valores
   344 0000159B 0000000000000000            current_score dq 0          ; Score actual
   345 000015A3 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   346                                      
   347                                      ; Buffer para convertir números a string
   348 000015A4 00<rep 14h>                 number_buffer: times 20 db 0
   349                                  
   350 000015B8 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   351                                      
   352                                      ; Estructura para los enemigos (x, y, activo)
   353 000015BD 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   354 000015DB 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   355                                      
   356 000015DC 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   357 000015E4 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   358 000015E5 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   359 000015E6 00                          enemy_move_total db 0      ; Contador total de movimientos
   360 000015E7 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 000015E8 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   362                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   363                                      ; Añade esto en la sección .dataa
   364 000015E9 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   364 000015F2 12                 
   365 000015F3 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   365 000015FC 13                 
   366 000015FD 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   366 00001606 1B                 
   367 00001607 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   367 00001610 1C                 
   368 00001611 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   368 0000161A 2D                 
   369                                          ; Arreglo de punteros a los spawn points de cada nivel
   370                                      spawn_points_table:
   371 0000161B [E915000000000000]              dq level1_spawn_points
   372 00001623 [F315000000000000]              dq level2_spawn_points
   373 0000162B [FD15000000000000]              dq level3_spawn_points
   374 00001633 [0716000000000000]              dq level4_spawn_points
   375 0000163B [1116000000000000]              dq level5_spawn_points
   376                                  
   377                                      ; Variables para el comportamiento de enemigos
   378 00001643 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   379 00001644 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   380 00001645 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   381 00001646 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   382                                  
   383 00001650 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   383 00001659 5B2020202020202020-
   383 00001662 20205D0A0D         
   384                                      score_label_len: equ $ - score_label
   385 00001667 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   385 00001670 657374727569646F73-
   385 00001679 3A205B2020205D0A0D 
   386                                      blocks_label_len: equ $ - blocks_label
   387                                      
   388                                      ; Posición donde insertar los números en los labels
   389                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   390                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   391                                      
   392                                      ; Definición de las vidas (x, y, estado)
   393                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   394                                      lives_data: 
   395 00001682 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   396 00001685 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   397 00001688 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   398 0000168B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   399 0000168E 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   400 00001691 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   401 00001694 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   402                                      lives_count equ 7    ; Total de vidas
   403 00001697 5E                          life_char db "^"    
   404 00001698 04                          current_lives db 4   ; Contador de vidas activas actual
   405                                  
   406                                  ; Estructura para almacenar las letras y sus posiciones
   407                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   408 00001699 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   409 00001829 00                          letters_count db 0   
   410 0000182A 20                          last_letter db ' '    ; Variable para almacenar la última letra
   411 0000182B 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   411 00001834 75616C3A205B205D0A-
   411 0000183D 0D                 
   412                                      last_letter_msg_len equ $ - last_letter_msg
   413 0000183E 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   414 0000183F 07                          max_lives db 7              ; Máximo número de vidas permitidas
   415 00001840 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   416 00001848 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   417 00001850 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   418                                  
   419 00001858 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   420 00001859 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   421 0000185A 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   422 00001862 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   423                                  
   424 00001863 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   425 00001864 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   426 00001865 00                          laser_count: db 0                ; Contador de láseres activos
   427 00001866 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   428 0000192E 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   429                                  
   430                                      balls_data:     ; Array para almacenar hasta 3 bolas
   431                                          ; Bola 1 (principal)
   432 00001936 0000000000000000                dq 0        ; x_pos
   433 0000193E 0000000000000000                dq 0        ; y_pos
   434 00001946 0100000000000000                dq 1        ; direction_x
   435 0000194E FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   436 00001956 01                              db 1        ; active
   437                                          ; Bola 2
   438 00001957 0000000000000000                dq 0        ; x_pos
   439 0000195F 0000000000000000                dq 0        ; y_pos
   440 00001967 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   441 0000196F FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   442 00001977 00                              db 0        ; active
   443                                          ; Bola 3
   444 00001978 0000000000000000                dq 0        ; x_pos
   445 00001980 0000000000000000                dq 0        ; y_pos
   446 00001988 0000000000000000                dq 0        ; direction_x
   447 00001990 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   448 00001998 00                              db 0        ; active
   449                                      
   450 00001999 01                          balls_count db 1     ; Contador de bolas activas
   451                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   452                                  
   453                                  
   454                                  section .text
   455                                  
   456                                  
   457                                  print_lives:
   458 000001DD 55                          push rbp
   459 000001DE 4889E5                      mov rbp, rsp
   460                                      
   461 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   462                                      
   463                                      .print_loop:
   464 000001E4 4983FC07                        cmp r12, lives_count
   465 000001E8 7D45                            jge .end
   466                                          
   467                                          ; Calcular offset de la vida actual
   468 000001EA 4C89E0                          mov rax, r12
   469 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   470 000001F1 488DB0[82160000]                lea rsi, [lives_data + rax]
   471                                          
   472                                          ; Calcular posición en el tablero
   473 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   474 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   475                                          
   476                                          ; Calcular offset en el tablero
   477 00000201 B84E000000                      mov rax, column_cells
   478 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   479 0000020A 49F7E1                          mul r9
   480 0000020D 4C01C0                          add rax, r8
   481 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   482                                          
   483                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   484 00000217 807E0201                        cmp byte [rsi + 2], 1
   485 0000021B 7405                            je .draw_active
   486                                          
   487                                          ; Si está inactiva, dibujar espacio
   488 0000021D C60720                          mov byte [rdi], ' '
   489 00000220 EB08                            jmp .next_life
   490                                          
   491                                      .draw_active:
   492                                          ; Si está activa, dibujar el símbolo de vida
   493 00000222 8A05(97160000)                  mov al, [life_char]
   494 00000228 8807                            mov [rdi], al
   495                                          
   496                                      .next_life:
   497 0000022A 49FFC4                          inc r12
   498 0000022D EBB5                            jmp .print_loop
   499                                          
   500                                      .end:
   501 0000022F 5D                              pop rbp
   502 00000230 C3                              ret
   503                                  
   504                                  ; Función para desactivar una vida
   505                                  ; Función modificada para perder una vida
   506                                  ; Modificar lose_life para reiniciar solo la bola principal
   507                                  lose_life:
   508 00000231 55                          push rbp
   509 00000232 4889E5                      mov rbp, rsp
   510                                      
   511                                      ; Verificar si aún quedan vidas
   512 00000235 803D(98160000)00            cmp byte [current_lives], 0
   513 0000023C 0F84AB000000                je .game_lost
   514                                      
   515                                      ; Encontrar la última vida activa
   516 00000242 B907000000                  mov rcx, lives_count
   517 00000247 48FFC9                      dec rcx
   518                                      
   519                                      .find_active_life:
   520 0000024A 4889C8                          mov rax, rcx
   521 0000024D 486BC003                        imul rax, 3
   522 00000251 488DB0[82160000]                lea rsi, [lives_data + rax]
   523 00000258 807E0201                        cmp byte [rsi + 2], 1
   524 0000025C 740A                            je .deactivate_life
   525 0000025E 48FFC9                          dec rcx
   526 00000261 79E7                            jns .find_active_life
   527 00000263 E985000000                      jmp .game_lost
   528                                          
   529                                      .deactivate_life:
   530                                          ; Borrar vida visualmente y en datos
   531 00000268 4C0FB606                        movzx r8, byte [rsi]
   532 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   533 00000271 B84E000000                      mov rax, column_cells
   534 00000276 4883C002                        add rax, 2
   535 0000027A 49F7E1                          mul r9
   536 0000027D 4C01C0                          add rax, r8
   537 00000280 488DB8[000A0000]                lea rdi, [board + rax]
   538 00000287 C60720                          mov byte [rdi], ' '
   539 0000028A C6460200                        mov byte [rsi + 2], 0
   540 0000028E FE0D(98160000)                  dec byte [current_lives]
   541                                          
   542                                          ; Borrar paleta anterior
   543 00000294 4C8B05(3F140000)                mov r8, [pallet_position]
   544 0000029B 488B0D(47140000)                mov rcx, [pallet_size]
   545                                          .erase_pallet_loop:
   546 000002A2 41C60020                            mov byte [r8], ' '
   547 000002A6 49FFC0                              inc r8
   548 000002A9 48FFC9                              dec rcx
   549 000002AC 75F4                                jnz .erase_pallet_loop
   550                                          
   551                                          ; Reiniciar solo la bola principal
   552 000002AE 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   552 000002B6 000000             
   553 000002B9 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   553 000002C1 000000             
   554 000002C4 C605(7F140000)00                mov byte [ball_moving], 0
   555 000002CB C605(80140000)01                mov byte [ball_active], 1       ; Activar bola principal
   556 000002D2 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   556 000002D9 [36130000]         
   557                                          
   558                                          ; Asegurarse que las otras bolas están desactivadas
   559 000002DD C605(A2140000)00                mov byte [ball2_active], 0
   560 000002E4 C605(C4140000)00                mov byte [ball3_active], 0
   561                                          
   562 000002EB EB07                            jmp .end
   563                                          
   564                                      .game_lost:
   565 000002ED E8C7000000                      call game_lost
   566 000002F2 EB00                            jmp .end
   567                                          
   568                                      .end:
   569 000002F4 5D                              pop rbp
   570 000002F5 C3                              ret
   571                                  ; Función modificada para verificar colisión con el borde inferior
   572                                  check_bottom_collision:
   573 000002F6 55                          push rbp
   574 000002F7 4889E5                      mov rbp, rsp
   575                                      
   576                                      ; Verificar bola principal
   577 000002FA 803D(80140000)01            cmp byte [ball_active], 1
   578 00000301 7542                        jne .check_ball2
   579 00000303 488B05(67140000)            mov rax, [ball_y_pos]
   580 0000030A 4883F81E                    cmp rax, row_cells - 2
   581 0000030E 7535                        jne .check_ball2
   582                                      
   583                                      ; Borrar visualmente la bola principal
   584 00000310 4C8B05(5F140000)            mov r8, [ball_x_pos]
   585 00000317 4C8B0D(67140000)            mov r9, [ball_y_pos]
   586 0000031E 4981C0[000A0000]            add r8, board
   587 00000325 4C89C9                      mov rcx, r9
   588 00000328 B850000000                  mov rax, column_cells + 2
   589 0000032D 48F7E9                      imul rcx
   590 00000330 4901C0                      add r8, rax
   591 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   592                                      
   593 00000337 C605(80140000)00            mov byte [ball_active], 0
   594 0000033E C605(7F140000)00            mov byte [ball_moving], 0
   595                                  
   596                                  .check_ball2:
   597 00000345 803D(A2140000)01            cmp byte [ball2_active], 1
   598 0000034C 751B                        jne .check_ball3
   599 0000034E 488B05(89140000)            mov rax, [ball2_y_pos]
   600 00000355 4883F81E                    cmp rax, row_cells - 2
   601 00000359 750E                        jne .check_ball3
   602 0000035B C605(A2140000)00            mov byte [ball2_active], 0
   603 00000362 C605(A1140000)00            mov byte [ball2_moving], 0
   604                                  
   605                                  .check_ball3:
   606 00000369 803D(C4140000)01            cmp byte [ball3_active], 1
   607 00000370 751B                        jne .check_active_balls
   608 00000372 488B05(AB140000)            mov rax, [ball3_y_pos]
   609 00000379 4883F81E                    cmp rax, row_cells - 2
   610 0000037D 750E                        jne .check_active_balls
   611 0000037F C605(C4140000)00            mov byte [ball3_active], 0
   612 00000386 C605(C3140000)00            mov byte [ball3_moving], 0
   613                                  
   614                                  .check_active_balls:
   615                                      ; Verificar si quedan bolas activas
   616 0000038D 4831C9                      xor rcx, rcx
   617 00000390 803D(80140000)01            cmp byte [ball_active], 1
   618 00000397 741E                        je .balls_remain
   619 00000399 803D(A2140000)01            cmp byte [ball2_active], 1
   620 000003A0 7415                        je .balls_remain
   621 000003A2 803D(C4140000)01            cmp byte [ball3_active], 1
   622 000003A9 740C                        je .balls_remain
   623                                      
   624                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   625 000003AB E881FEFFFF                  call lose_life
   626 000003B0 C605(80140000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   627                                      
   628                                  .balls_remain:
   629 000003B7 5D                          pop rbp
   630 000003B8 C3                          ret
   631                                  
   632                                  
   633                                  
   634                                  ; Nueva función para game over
   635                                  game_lost:
   636                                      ; Limpiar la pantalla
   637                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   638                                      
   639                                      ; Mostrar mensaje de derrota
   640                                      section .data
   641 0000199A C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   641 000019A3 6469646F210A0D     
   642                                          lost_msg_len: equ $ - lost_msg
   643                                      section .text
   644                                      
   645                                      ; Imprimir mensaje de derrota
   646                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [9A19000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   647                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [C819000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   648                                      
   649                                      ; Mostrar puntaje final
   650 0000040A 488B05(9B150000)            mov rax, [current_score]
   651 00000411 48BF-                       mov rdi, number_buffer
   651 00000413 [A415000000000000] 
   652 0000041B E8BA120000                  call number_to_string
   653                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [A415000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   654                                      
   655                                      ; Esperar un momento antes de salir
   656 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   656 00000444 0000               
   657 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   657 0000044F 0000               
   658                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   659                                      
   660 00000464 E9AF1A0000                  jmp exit
   661                                  
   662                                  
   663                                  ; Función para registrar una nueva letra en el mapa
   664                                  ; Entrada:
   665                                  ;   al - letra a registrar
   666                                  ;   r8b - posición x
   667                                  ;   r9b - posición y
   668                                  register_letter:
   669 00000469 55                          push rbp
   670 0000046A 4889E5                      mov rbp, rsp
   671 0000046D 53                          push rbx
   672 0000046E 51                          push rcx
   673                                      
   674 0000046F 3C20                        cmp al, ' '
   675 00000471 7438                        je .end
   676                                  
   677                                      ; Encontrar un espacio libre en el mapa
   678 00000473 4831C9                      xor rcx, rcx
   679 00000476 480FB615(29180000)          movzx rdx, byte [letters_count]
   680                                      
   681                                      .find_slot:
   682 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   683 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   684                                          
   685 00000484 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   686 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   687 00000490 7405                            je .found_slot
   688                                          
   689 00000492 48FFC1                          inc rcx
   690 00000495 EBE7                            jmp .find_slot
   691                                          
   692                                      .found_slot:
   693                                          ; Guardar la información de la letra
   694 00000497 448803                          mov [rbx], r8b           ; x
   695 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   696 0000049E 884302                          mov [rbx + 2], al        ; letra
   697 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   698                                          
   699 000004A5 FE05(29180000)                  inc byte [letters_count]
   700                                          
   701                                      .end:
   702 000004AB 59                              pop rcx
   703 000004AC 5B                              pop rbx
   704 000004AD 5D                              pop rbp
   705 000004AE C3                              ret
   706                                  
   707                                  ; Función para imprimir todas las letras registradas
   708                                  print_letters:
   709 000004AF 55                          push rbp
   710 000004B0 4889E5                      mov rbp, rsp
   711 000004B3 53                          push rbx
   712 000004B4 51                          push rcx
   713                                      
   714 000004B5 4831C9                      xor rcx, rcx
   715                                      
   716                                      .print_loop:
   717 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   718 000004BC 7D37                            jge .end
   719                                          
   720                                          ; Obtener puntero a la letra actual
   721 000004BE 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   722                                          
   723                                          ; Verificar si está activa
   724 000004C6 807B0300                        cmp byte [rbx + 3], 0
   725 000004CA 7424                            je .next_letter
   726                                          
   727                                          ; Calcular posición en el tablero
   728 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   729 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   730                                          
   731                                          ; Calcular offset en el tablero
   732 000004D5 B84E000000                      mov rax, column_cells
   733 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   734 000004DE 49F7E1                          mul r9
   735 000004E1 4C01C0                          add rax, r8
   736 000004E4 488DB8[000A0000]                lea rdi, [board + rax]
   737                                          
   738                                          ; Imprimir la letra
   739 000004EB 8A4302                          mov al, [rbx + 2]
   740 000004EE 8807                            mov [rdi], al
   741                                          
   742                                      .next_letter:
   743 000004F0 48FFC1                          inc rcx
   744 000004F3 EBC3                            jmp .print_loop
   745                                          
   746                                      .end:
   747 000004F5 59                              pop rcx
   748 000004F6 5B                              pop rbx
   749 000004F7 5D                              pop rbp
   750 000004F8 C3                              ret
   751                                  
   752                                  ; Función para borrar una letra específica
   753                                  ; Entrada:
   754                                  ;   r8b - posición x
   755                                  ;   r9b - posición y
   756                                  remove_letter:
   757 000004F9 55                          push rbp
   758 000004FA 4889E5                      mov rbp, rsp
   759 000004FD 53                          push rbx
   760 000004FE 51                          push rcx
   761                                      
   762 000004FF 4831C9                      xor rcx, rcx
   763                                      
   764                                      .find_loop:
   765 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   766 00000506 7D2E                            jge .end
   767                                          
   768 00000508 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   769                                          
   770                                          ; Verificar si está activa y coincide la posición
   771 00000510 807B0300                        cmp byte [rbx + 3], 0
   772 00000514 741B                            je .next_letter
   773                                          
   774 00000516 8A03                            mov al, [rbx]
   775 00000518 4438C0                          cmp al, r8b
   776 0000051B 7514                            jne .next_letter
   777                                          
   778 0000051D 8A4301                          mov al, [rbx + 1]
   779 00000520 4438C8                          cmp al, r9b
   780 00000523 750C                            jne .next_letter
   781                                          
   782                                          ; Encontrada la letra, desactivarla
   783 00000525 C6430300                        mov byte [rbx + 3], 0
   784 00000529 FE0D(29180000)                  dec byte [letters_count]
   785 0000052F EB05                            jmp .end
   786                                          
   787                                      .next_letter:
   788 00000531 48FFC1                          inc rcx
   789 00000534 EBCC                            jmp .find_loop
   790                                          
   791                                      .end:
   792 00000536 59                              pop rcx
   793 00000537 5B                              pop rbx
   794 00000538 5D                              pop rbp
   795 00000539 C3                              ret
   796                                  ; Función para mover las letras hacia abajo
   797                                  move_letters:
   798 0000053A 55                          push rbp
   799 0000053B 4889E5                      mov rbp, rsp
   800 0000053E 53                          push rbx
   801 0000053F 57                          push rdi
   802 00000540 56                          push rsi
   803 00000541 4150                        push r8
   804 00000543 4151                        push r9
   805 00000545 4152                        push r10
   806 00000547 4153                        push r11
   807                                  
   808 00000549 4831C9                      xor rcx, rcx
   809                                  
   810                                      .move_loop:
   811 0000054C 4883F964                        cmp rcx, 100
   812 00000550 0F8DE3010000                    jge .print_last_letter
   813                                          
   814 00000556 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   815 0000055E 807B0300                        cmp byte [rbx + 3], 0
   816 00000562 0F84C9010000                    je .next_letter
   817                                  
   818 00000568 4C0FB603                        movzx r8, byte [rbx]
   819 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
   820                                  
   821 00000571 B84E000000                      mov rax, column_cells
   822 00000576 4883C002                        add rax, 2
   823 0000057A 49F7E1                          mul r9
   824 0000057D 4C01C0                          add rax, r8
   825 00000580 488DB8[000A0000]                lea rdi, [board + rax]
   826 00000587 C60720                          mov byte [rdi], ' '
   827                                  
   828 0000058A FE4301                          inc byte [rbx + 1]
   829 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
   830                                  
   831 00000592 4983F91F                        cmp r9, row_cells - 1
   832 00000596 7C09                            jl .check_pallet_collision
   833                                  
   834 00000598 C6430300                        mov byte [rbx + 3], 0
   835 0000059C E990010000                      jmp .next_letter
   836                                  
   837                                          .check_pallet_collision:
   838 000005A1 B84E000000                          mov rax, column_cells
   839 000005A6 4883C002                            add rax, 2
   840 000005AA 49F7E1                              mul r9
   841 000005AD 4C01C0                              add rax, r8
   842 000005B0 488DB8[000A0000]                    lea rdi, [board + rax]
   843                                  
   844 000005B7 8A07                                mov al, [rdi]
   845 000005B9 3C20                                cmp al, ' '
   846 000005BB 0F8470010000                        je .next_letter
   847 000005C1 3C3D                                cmp al, char_equal
   848 000005C3 740A                                je .capture_letter
   849                                  
   850 000005C5 8A4302                              mov al, [rbx + 2]
   851 000005C8 8807                                mov [rdi], al
   852 000005CA E962010000                          jmp .next_letter
   853                                  
   854                                          .capture_letter:
   855                                              ; Obtener la nueva letra
   856 000005CF 8A4302                              mov al, [rbx + 2]
   857                                              
   858                                              ; Comparar con la última letra
   859 000005D2 3A05(2A180000)                      cmp al, [last_letter]
   860 000005D8 7407                                je .same_letter
   861                                              
   862                                              ; Es una letra diferente, resetear el procesamiento
   863 000005DA C605(3E180000)00                    mov byte [current_power_processed], 0
   864                                              
   865                                              .same_letter:
   866                                              ; Guardar la nueva letra
   867 000005E1 8805(2A180000)                      mov [last_letter], al
   868                                              
   869                                              ; Verificar si es 'E' para extender la paleta
   870 000005E7 3C45                                cmp al, 'E'
   871 000005E9 7450                                je .extend_pallet
   872                                              
   873                                              ; Verificar si es 'P' para añadir vida
   874 000005EB 3C50                                cmp al, 'P'
   875 000005ED 7478                                je .check_add_life
   876                                  
   877 000005EF 3C53                                cmp al, 'S'
   878 000005F1 0F84B4000000                        je .slow_ball
   879                                  
   880 000005F7 3C43                                cmp al, 'C'
   881 000005F9 0F84D5000000                        je .activate_catch
   882                                              
   883 000005FF 3C4C                                cmp al, 'L'
   884 00000601 0F84F6000000                        je .activate_laser
   885                                  
   886 00000607 3C44                                cmp al, 'D'
   887 00000609 0F8417010000                        je .activate_split
   888                                  
   889                                              ; Si no es ningún power-up, restaurar tamaño normal
   890 0000060F 488B05(4F140000)                    mov rax, [default_pallet_size]
   891 00000616 488905(47140000)                    mov [pallet_size], rax
   892 0000061D 48C705(40180000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   892 00000625 000000             
   893 00000628 C605(58180000)00                    mov byte [catch_power_active], 0
   894 0000062F C605(63180000)00                    mov byte [laser_power_active], 0
   895 00000636 E9F2000000                          jmp .finish_capture
   896                                  
   897                                              .extend_pallet:
   898 0000063B C605(63180000)00                        mov byte [laser_power_active], 0
   899 00000642 C605(58180000)00                        mov byte [catch_power_active], 0
   900 00000649 48C705(40180000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   900 00000651 000000             
   901 00000654 488B05(57140000)                        mov rax, [extended_pallet_size]
   902 0000065B 488905(47140000)                        mov [pallet_size], rax
   903 00000662 E9C6000000                              jmp .finish_capture
   904                                  
   905                                              .check_add_life:
   906 00000667 C605(63180000)00                        mov byte [laser_power_active], 0
   907 0000066E C605(58180000)00                        mov byte [catch_power_active], 0
   908 00000675 488B05(4F140000)                        mov rax, [default_pallet_size]
   909 0000067C 488905(47140000)                        mov [pallet_size], rax
   910 00000683 48C705(40180000)01-                     mov qword [ball_speed], 1 
   910 0000068B 000000             
   911                                                  ; Verificar si ya procesamos este power-up
   912 0000068E 803D(3E180000)00                        cmp byte [current_power_processed], 0
   913 00000695 0F8592000000                            jne .finish_capture
   914                                                  
   915                                                  ; Preservar registros importantes
   916 0000069B 51                                      push rcx
   917 0000069C 53                                      push rbx
   918                                                  
   919                                                  ; Marcar como procesado
   920 0000069D C605(3E180000)01                        mov byte [current_power_processed], 1
   921                                                  
   922                                                  ; Añadir una vida
   923 000006A4 E80E040000                              call add_life
   924                                                  
   925                                                  ; Restaurar registros
   926 000006A9 5B                                      pop rbx
   927 000006AA 59                                      pop rcx
   928                                                  
   929                                              .slow_ball:
   930 000006AB C605(63180000)00                        mov byte [laser_power_active], 0
   931 000006B2 C605(58180000)00                        mov byte [catch_power_active], 0                
   932 000006B9 488B05(4F140000)                        mov rax, [default_pallet_size]
   933 000006C0 488905(47140000)                        mov [pallet_size], rax
   934 000006C7 48C705(40180000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   934 000006CF 000000             
   935 000006D2 EB59                                    jmp .finish_capture
   936                                  
   937                                              .activate_catch:
   938 000006D4 C605(63180000)00                        mov byte [laser_power_active], 0
   939 000006DB 488B05(4F140000)                        mov rax, [default_pallet_size]
   940 000006E2 488905(47140000)                        mov [pallet_size], rax
   941 000006E9 48C705(40180000)01-                     mov qword [ball_speed], 1
   941 000006F1 000000             
   942 000006F4 C605(58180000)01                        mov byte [catch_power_active], 1
   943 000006FB EB30                                    jmp .finish_capture
   944                                  
   945                                              .activate_laser:
   946 000006FD C605(58180000)00                        mov byte [catch_power_active], 0
   947 00000704 488B05(4F140000)                        mov rax, [default_pallet_size]
   948 0000070B 488905(47140000)                        mov [pallet_size], rax
   949 00000712 48C705(40180000)01-                     mov qword [ball_speed], 1
   949 0000071A 000000             
   950 0000071D C605(63180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   951 00000724 EB07                                    jmp .finish_capture
   952                                  
   953                                              .activate_split:
   954 00000726 E8D2000000                              call activate_split_power
   955 0000072B EB00                                    jmp .finish_capture
   956                                  
   957                                              .finish_capture:
   958 0000072D C6430300                                mov byte [rbx + 3], 0
   959                                  
   960                                          .next_letter:
   961 00000731 48FFC1                              inc rcx
   962 00000734 E913FEFFFF                          jmp .move_loop
   963                                  
   964                                      .print_last_letter:
   965                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000739 B801000000          <1>  mov eax, sys_write
    83 0000073E BF01000000          <1>  mov edi, 1
    84 00000743 48BE-               <1>  mov rsi, %1
    84 00000745 [2B18000000000000]  <1>
    85 0000074D BA10000000          <1>  mov edx, %2
    86 00000752 0F05                <1>  syscall
   966 00000754 8A05(2A180000)                  mov al, [last_letter]
   967 0000075A 8805(3A180000)                  mov [last_letter_msg + 15], al
   968                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000760 B801000000          <1>  mov eax, sys_write
    83 00000765 BF01000000          <1>  mov edi, 1
    84 0000076A 48BE-               <1>  mov rsi, %1
    84 0000076C [3B18000000000000]  <1>
    85 00000774 BA03000000          <1>  mov edx, %2
    86 00000779 0F05                <1>  syscall
   969                                  
   970                                      .end:
   971 0000077B 415B                            pop r11
   972 0000077D 415A                            pop r10
   973 0000077F 4159                            pop r9
   974 00000781 4158                            pop r8
   975 00000783 5E                              pop rsi
   976 00000784 5F                              pop rdi
   977 00000785 5B                              pop rbx
   978 00000786 5D                              pop rbp
   979 00000787 C3                              ret
   980                                  
   981                                  
   982                                  clear_lasers:
   983 00000788 55                          push rbp
   984 00000789 4889E5                      mov  rbp, rsp
   985                                  
   986                                      ; Recorrer el array de láseres
   987 0000078C 4831C9                      xor rcx, rcx                ; Índice del láser
   988 0000078F 480FB61D(65180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   989                                  
   990                                      .clear_loop:
   991 00000797 4839D9                          cmp rcx, rbx
   992 0000079A 7D2F                            jge .done                ; Salir si no quedan láseres
   993                                  
   994                                          ; Obtener posición del láser actual
   995 0000079C 488DB409[66180000]              lea rsi, [lasers + rcx * 2]
   996 000007A4 4C0FB606                        movzx r8, byte [rsi]     ; X
   997 000007A8 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
   998                                  
   999                                          ; Calcular posición en el tablero
  1000 000007AD B84E000000                      mov rax, column_cells
  1001 000007B2 4883C002                        add rax, 2
  1002 000007B6 49F7E1                          mul r9
  1003 000007B9 4C01C0                          add rax, r8
  1004 000007BC 488DB8[000A0000]                lea rdi, [board + rax]
  1005                                  
  1006                                          ; Borrar el láser visualmente
  1007 000007C3 C60720                          mov byte [rdi], ' '
  1008                                  
  1009                                          ; Pasar al siguiente láser
  1010 000007C6 48FFC1                          inc rcx
  1011 000007C9 EBCC                            jmp .clear_loop
  1012                                  
  1013                                      .done:
  1014                                          ; Resetear contador de láseres
  1015 000007CB C605(65180000)00                mov byte [laser_count], 0
  1016                                  
  1017 000007D2 5D                              pop rbp
  1018 000007D3 C3                              ret
  1019                                  
  1020                                  
  1021                                  ; Nueva función para actualizar los láseres
  1022                                  update_lasers:
  1023 000007D4 55                          push rbp
  1024 000007D5 4889E5                      mov rbp, rsp
  1025                                      
  1026                                      ; Verificar si el poder láser está activo
  1027 000007D8 803D(63180000)00            cmp byte [laser_power_active], 0
  1028 000007DF 741A                        je .end
  1029                                      
  1030                                      ; Verificar si se presionó la tecla de espacio
  1031 000007E1 803D(62180000)20            cmp byte [last_key], ' '
  1032 000007E8 750C                        jne .skip_shooting
  1033                                      
  1034                                      ; Disparar nuevos láseres
  1035 000007EA E89A000000                  call shoot_lasers
  1036 000007EF C605(62180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1037                                      
  1038                                      .skip_shooting:
  1039                                      ; Mover los láseres existentes
  1040 000007F6 E828010000                  call move_lasers
  1041                                      
  1042                                      .end:
  1043 000007FB 5D                              pop rbp
  1044 000007FC C3                              ret
  1045                                  
  1046                                  activate_split_power:
  1047 000007FD 55                          push rbp
  1048 000007FE 4889E5                      mov rbp, rsp
  1049                                      
  1050                                      ; Verificar si la bola2 y bola3 ya están activas
  1051 00000801 803D(A2140000)01            cmp byte [ball2_active], 1
  1052 00000808 750B                        jne .enable_balls
  1053 0000080A 803D(C4140000)01            cmp byte [ball3_active], 1
  1054 00000811 7502                        jne .enable_balls
  1055                                      
  1056                                      ; Si ambas ya están activas, no hacemos nada.
  1057 00000813 EB72                        jmp .end
  1058                                  
  1059                                  .enable_balls:
  1060                                      ; Copiamos la posición de la bola principal
  1061 00000815 488B05(5F140000)            mov rax, [ball_x_pos]
  1062 0000081C 488905(81140000)            mov [ball2_x_pos], rax
  1063 00000823 488905(A3140000)            mov [ball3_x_pos], rax
  1064                                  
  1065 0000082A 488B05(67140000)            mov rax, [ball_y_pos]
  1066 00000831 488905(89140000)            mov [ball2_y_pos], rax
  1067 00000838 488905(AB140000)            mov [ball3_y_pos], rax
  1068                                  
  1069                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1070                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1071 0000083F 48C705(91140000)FF-         mov qword [ball2_direction_x], -1
  1071 00000847 FFFFFF             
  1072 0000084A 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  1072 00000852 FFFFFF             
  1073 00000855 C605(A1140000)01            mov byte [ball2_moving], 1
  1074 0000085C C605(A2140000)01            mov byte [ball2_active], 1
  1075                                  
  1076 00000863 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  1076 0000086B 000000             
  1077 0000086E 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  1077 00000876 FFFFFF             
  1078 00000879 C605(C3140000)01            mov byte [ball3_moving], 1
  1079 00000880 C605(C4140000)01            mov byte [ball3_active], 1
  1080                                  
  1081                                  .end:
  1082 00000887 5D                          pop rbp
  1083 00000888 C3                          ret
  1084                                  
  1085                                  
  1086                                  shoot_lasers:
  1087 00000889 55                          push rbp
  1088 0000088A 4889E5                      mov rbp, rsp
  1089 0000088D 53                          push rbx
  1090                                      
  1091                                      ; Verificar si hay espacio para más láseres
  1092 0000088E 480FB605(65180000)          movzx rax, byte [laser_count]
  1093 00000896 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1094 0000089A 0F8D80000000                jge .end
  1095                                      
  1096                                      ; Obtener posición de la paleta
  1097 000008A0 4C8B05(3F140000)            mov r8, [pallet_position]
  1098 000008A7 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
  1099                                      
  1100                                      ; Calcular coordenadas x,y
  1101 000008AE 4C89C0                      mov rax, r8
  1102 000008B1 41B94E000000                mov r9, column_cells
  1103 000008B7 4983C102                    add r9, 2                     ; Ancho total de línea
  1104 000008BB 4831D2                      xor rdx, rdx
  1105 000008BE 49F7F1                      div r9                        ; rax = y, rdx = x
  1106                                      
  1107                                      ; Guardar coordenadas
  1108 000008C1 4989C2                      mov r10, rax                  ; Y en r10
  1109 000008C4 4989D3                      mov r11, rdx                  ; X en r11
  1110                                      
  1111                                      ; Validar coordenadas
  1112 000008C7 4983FA00                    cmp r10, 0
  1113 000008CB 7C53                        jl .end
  1114 000008CD 4983FA20                    cmp r10, row_cells
  1115 000008D1 7D4D                        jge .end
  1116 000008D3 4983FB00                    cmp r11, 0
  1117 000008D7 7C47                        jl .end
  1118 000008D9 4983FB4E                    cmp r11, column_cells
  1119 000008DD 7D41                        jge .end
  1120                                      
  1121                                      ; Calcular índice para el primer láser
  1122 000008DF 480FB61D(65180000)          movzx rbx, byte [laser_count]
  1123 000008E7 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1124                                      
  1125                                      ; Primer láser (izquierda)
  1126 000008EB 488DBB[66180000]            lea rdi, [lasers + rbx]
  1127 000008F2 44881F                      mov [rdi], r11b              ; X
  1128 000008F5 4488D0                      mov al, r10b
  1129 000008F8 FEC8                        dec al                       ; Y - 1
  1130 000008FA 884701                      mov [rdi + 1], al           ; Y
  1131                                      
  1132                                      ; Segundo láser (derecha)
  1133 000008FD 4488D8                      mov al, r11b
  1134 00000900 0205(47140000)              add al, byte [pallet_size]
  1135 00000906 FEC8                        dec al                       ; Ajustar para el último carácter
  1136 00000908 488DBB[68180000]            lea rdi, [lasers + rbx + 2]
  1137 0000090F 8807                        mov [rdi], al               ; X
  1138 00000911 4488D0                      mov al, r10b
  1139 00000914 FEC8                        dec al                      ; Y - 1
  1140 00000916 884701                      mov [rdi + 1], al          ; Y
  1141                                      
  1142                                      ; Incrementar contador de láseres
  1143 00000919 8005(65180000)02            add byte [laser_count], 2
  1144                                      
  1145                                      
  1146                                      .end:
  1147 00000920 5B                              pop rbx
  1148 00000921 5D                              pop rbp
  1149 00000922 C3                              ret
  1150                                  
  1151                                  ; Función corregida para mover láseres
  1152                                  ; Función corregida para mover láseres
  1153                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1154                                  
  1155                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1156                                  ; ============================================================
  1157                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1158                                  ; ============================================================
  1159                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1160                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1161                                  ; ============================================================
  1162                                  move_lasers:
  1163 00000923 55                          push rbp
  1164 00000924 4889E5                      mov  rbp, rsp
  1165 00000927 53                          push rbx
  1166 00000928 57                          push rdi
  1167 00000929 56                          push rsi
  1168 0000092A 4154                        push r12
  1169 0000092C 4155                        push r13
  1170 0000092E 4156                        push r14
  1171 00000930 4157                        push r15
  1172                                  
  1173                                      ; 1) Tomamos la cantidad de láseres
  1174 00000932 480FB60D(65180000)          movzx rcx, byte [laser_count]
  1175 0000093A 4885C9                      test rcx, rcx
  1176 0000093D 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1177                                  
  1178                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1179 00000943 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1180                                  
  1181                                  .loop_lasers:
  1182                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1183 00000946 488DB409[66180000]          lea rsi, [lasers + rcx*2]
  1184                                  
  1185                                      ; 2) Cargar x,y actuales del láser
  1186 0000094E 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1187 00000952 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1188                                  
  1189                                      ; 3) Borrar el láser de su posición actual en pantalla
  1190                                      ;    (por si en el ciclo anterior se había dibujado)
  1191 00000957 B84E000000                  mov rax, column_cells
  1192 0000095C 4883C002                    add rax, 2
  1193 00000960 49F7E1                      mul r9
  1194 00000963 4C01C0                      add rax, r8
  1195 00000966 488DB8[000A0000]            lea rdi, [board + rax]
  1196 0000096D C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1197                                  
  1198                                      ; 4) Mover el láser hacia arriba (y - 1)
  1199 00000970 49FFC9                      dec r9
  1200                                  
  1201                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1202 00000973 4983F901                    cmp r9, 1
  1203 00000977 7C57                        jl .delete_laser
  1204                                  
  1205                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1206 00000979 44884E01                    mov byte [rsi + 1], r9b
  1207                                  
  1208                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1209                                      ;    - Primero colisión con bloques
  1210                                      ; ---------------------------------------------------------
  1211                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1212 0000097D B84E000000                  mov rax, column_cells
  1213 00000982 4883C002                    add rax, 2
  1214 00000986 49F7E1                      mul r9
  1215 00000989 4C01C0                      add rax, r8
  1216 0000098C 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1217                                  
  1218                                      ; Revisar si hay bloque
  1219 00000993 51                          push rcx
  1220 00000994 56                          push rsi
  1221 00000995 57                          push rdi
  1222 00000996 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1223 00000999 E8940E0000                  call check_block_collision
  1224 0000099E 5F                          pop rdi
  1225 0000099F 5E                          pop rsi
  1226 000009A0 59                          pop rcx
  1227                                  
  1228 000009A1 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1229 000009A4 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1230                                  
  1231                                      ;    - Luego colisión con enemigos
  1232                                      ; ---------------------------------------------------------
  1233 000009A6 51                          push rcx
  1234 000009A7 56                          push rsi
  1235 000009A8 57                          push rdi
  1236                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1237                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1238                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1239                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1240                                      ;
  1241                                      ; Hacemos algo como:
  1242 000009A9 4989FA                      mov r10, rdi
  1243 000009AC E85A000000                  call check_laser_enemy_collision
  1244 000009B1 5F                          pop rdi
  1245 000009B2 5E                          pop rsi
  1246 000009B3 59                          pop rcx
  1247                                  
  1248 000009B4 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1249 000009B7 7517                        jnz .delete_laser
  1250                                  
  1251                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1252 000009B9 8A05(64180000)              mov al, [laser_symbol]
  1253 000009BF 8807                        mov [rdi], al
  1254                                  
  1255                                  .next_laser:
  1256                                      ; Pasamos al láser anterior en el array
  1257 000009C1 48FFC9                      dec rcx
  1258 000009C4 4883F9FF                    cmp rcx, -1
  1259 000009C8 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1260 000009CE EB2E                        jmp .fin
  1261                                  
  1262                                  ; -----------------------------------------------------------------
  1263                                  ; Subrutina interna: .delete_laser
  1264                                  ; -----------------------------------------------------------------
  1265                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1266                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1267                                  .delete_laser:
  1268 000009D0 4C0FB625(65180000)          movzx r12, byte [laser_count]
  1269 000009D8 49FFCC                      dec r12                    ; r12 = índice del último láser
  1270 000009DB 4939CC                      cmp r12, rcx
  1271 000009DE 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1272                                  
  1273                                      ; Copiamos el último láser a la posición actual
  1274 000009E0 488DBC09[66180000]          lea rdi, [lasers + rcx*2]
  1275 000009E8 4B8DB424[66180000]          lea rsi, [lasers + r12*2]
  1276 000009F0 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1277 000009F3 668907                      mov [rdi], ax             ; copiamos X,Y
  1278                                  
  1279                                  .just_decrement:
  1280 000009F6 FE0D(65180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1281 000009FC EBC3                        jmp .next_laser
  1282                                  
  1283                                  .fin:
  1284 000009FE 415F                        pop r15
  1285 00000A00 415E                        pop r14
  1286 00000A02 415D                        pop r13
  1287 00000A04 415C                        pop r12
  1288 00000A06 5E                          pop rsi
  1289 00000A07 5F                          pop rdi
  1290 00000A08 5B                          pop rbx
  1291 00000A09 5D                          pop rbp
  1292 00000A0A C3                          ret
  1293                                  
  1294                                  
  1295                                  ; Nueva función para verificar colisión entre láser y enemigos
  1296                                  ; ==========================================================
  1297                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1298                                  ; ==========================================================
  1299                                  check_laser_enemy_collision:
  1300 00000A0B 55                          push rbp
  1301 00000A0C 4889E5                      mov  rbp, rsp
  1302                                      
  1303 00000A0F 4D31ED                      xor r13, r13            ; Índice del enemigo
  1304 00000A12 4831C0                      xor rax, rax            ; 0 = no colisión
  1305                                  
  1306                                  .loop_enemies:
  1307 00000A15 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1308 00000A19 7D64                        jge .end
  1309                                  
  1310                                      ; r13 * 3 => offset del enemigo i
  1311 00000A1B 4C89E9                      mov rcx, r13
  1312 00000A1E 486BC903                    imul rcx, 3
  1313 00000A22 488DB1[BD150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1314                                  
  1315                                      ; Verificar si está activo
  1316 00000A29 807E0201                    cmp byte [rsi+2], 1
  1317 00000A2D 754B                        jne .next_enemy
  1318                                  
  1319                                      ; Cargar posición X/Y del enemigo
  1320 00000A2F 4C0FB636                    movzx r14, byte [rsi]      ; X
  1321 00000A33 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1322                                  
  1323                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1324 00000A38 4D39F0                      cmp r8, r14
  1325 00000A3B 753D                        jne .next_enemy
  1326 00000A3D 4D39F9                      cmp r9, r15
  1327 00000A40 7538                        jne .next_enemy
  1328                                  
  1329                                      ; ==== Colisión detectada con láser ====
  1330                                  
  1331                                      ; 1) Desactivar enemigo
  1332 00000A42 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1333                                  
  1334                                      ; 2) Sumar puntos
  1335 00000A46 488B05(DC150000)            mov rax, [enemy_points]
  1336 00000A4D 480105(9B150000)            add [current_score], rax
  1337                                  
  1338                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1339                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1340 00000A54 4983FF1E                    cmp r15, row_cells - 2
  1341 00000A58 7419                        je .skip_erase
  1342                                  
  1343                                      ; Borrar visualmente del board
  1344 00000A5A B84E000000                  mov rax, column_cells
  1345 00000A5F 4883C002                    add rax, 2
  1346 00000A63 49F7E7                      mul r15
  1347 00000A66 4C01F0                      add rax, r14
  1348 00000A69 488DB8[000A0000]            lea rdi, [board + rax]
  1349 00000A70 C60720                      mov byte [rdi], ' '
  1350                                  
  1351                                  .skip_erase:
  1352                                  
  1353                                      ; 4) Devolver rax=1 => colisión con enemigo
  1354 00000A73 B801000000                  mov rax, 1
  1355 00000A78 EB05                        jmp .end
  1356                                  
  1357                                  .next_enemy:
  1358 00000A7A 49FFC5                      inc r13
  1359 00000A7D EB96                        jmp .loop_enemies
  1360                                  
  1361                                  .end:
  1362 00000A7F 5D                          pop rbp
  1363 00000A80 C3                          ret
  1364                                  
  1365                                  
  1366                                  ; Función auxiliar para eliminar un láser específico
  1367                                  remove_laser:
  1368 00000A81 55                          push rbp
  1369 00000A82 4889E5                      mov rbp, rsp
  1370                                  
  1371                                      ; Borrar el láser del tablero
  1372 00000A85 41C60220                    mov byte [r10], ' '
  1373                                  
  1374                                      ; Mover el último láser a esta posición si no es el último
  1375 00000A89 480FB605(65180000)          movzx rax, byte [laser_count]
  1376 00000A91 48FFC8                      dec rax                    ; Índice del último láser
  1377 00000A94 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1378 00000A97 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1379                                  
  1380                                      ; Copiar último láser a la posición actual
  1381 00000A99 4B8DBC24[66180000]          lea rdi, [lasers + r12*2]
  1382 00000AA1 488DB400[66180000]          lea rsi, [lasers + rax*2]
  1383 00000AA9 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1384 00000AAC 668917                      mov [rdi], dx
  1385                                  
  1386                                  .just_decrease:
  1387 00000AAF FE0D(65180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1388                                  
  1389 00000AB5 5D                          pop rbp
  1390 00000AB6 C3                          ret
  1391                                  
  1392                                  add_life:
  1393 00000AB7 55                          push rbp
  1394 00000AB8 4889E5                      mov rbp, rsp
  1395 00000ABB 53                          push rbx
  1396 00000ABC 51                          push rcx
  1397 00000ABD 57                          push rdi
  1398 00000ABE 56                          push rsi
  1399 00000ABF 4150                        push r8
  1400 00000AC1 4151                        push r9
  1401                                      
  1402                                      ; Verificar si ya tenemos el máximo de vidas
  1403 00000AC3 480FB605(98160000)          movzx rax, byte [current_lives]
  1404 00000ACB 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1405 00000ACF 7D2C                        jge .end
  1406                                      
  1407                                      ; Incrementar el contador de vidas
  1408 00000AD1 FE05(98160000)              inc byte [current_lives]
  1409                                      
  1410                                      ; Encontrar la siguiente vida inactiva
  1411 00000AD7 4831C9                      xor rcx, rcx
  1412                                      
  1413                                      .find_inactive:
  1414 00000ADA 4883F907                        cmp rcx, lives_count
  1415 00000ADE 7D1D                            jge .end
  1416                                          
  1417                                          ; Calcular offset de la vida actual
  1418 00000AE0 4889C8                          mov rax, rcx
  1419 00000AE3 486BC003                        imul rax, 3
  1420 00000AE7 488DB0[82160000]                lea rsi, [lives_data + rax]
  1421                                          
  1422                                          ; Verificar si está inactiva
  1423 00000AEE 807E0200                        cmp byte [rsi + 2], 0
  1424 00000AF2 7405                            je .activate_life
  1425                                          
  1426 00000AF4 48FFC1                          inc rcx
  1427 00000AF7 EBE1                            jmp .find_inactive
  1428                                          
  1429                                      .activate_life:
  1430                                          ; Activar la vida
  1431 00000AF9 C6460201                        mov byte [rsi + 2], 1
  1432                                          
  1433                                      .end:
  1434 00000AFD 4159                            pop r9
  1435 00000AFF 4158                            pop r8
  1436 00000B01 5E                              pop rsi
  1437 00000B02 5F                              pop rdi
  1438 00000B03 59                              pop rcx
  1439 00000B04 5B                              pop rbx
  1440 00000B05 5D                              pop rbp
  1441 00000B06 C3                              ret
  1442                                  
  1443                                  
  1444                                  print_ball:
  1445 00000B07 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1446 00000B0E 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1447 00000B15 4981C0[000A0000]        	add r8, board
  1448                                  
  1449 00000B1C 4C89C9                  	mov rcx, r9
  1450 00000B1F B850000000              	mov rax, column_cells + 2
  1451 00000B24 48F7E9                  	imul rcx
  1452                                  	
  1453 00000B27 4901C0                  	add r8, rax
  1454 00000B2A 41C6004F                	mov byte [r8], char_O
  1455 00000B2E C3                      	ret
  1456                                  
  1457                                  print_ball_2:
  1458 00000B2F 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1459 00000B36 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1460 00000B3D 4981C0[000A0000]            add r8, board
  1461 00000B44 4C89C9                      mov rcx, r9
  1462 00000B47 B850000000                  mov rax, column_cells + 2
  1463 00000B4C 48F7E9                      imul rcx
  1464 00000B4F 4901C0                      add r8, rax
  1465 00000B52 41C6004F                    mov byte [r8], char_O
  1466 00000B56 C3                          ret
  1467                                  
  1468                                  print_ball_3:
  1469 00000B57 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1470 00000B5E 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1471 00000B65 4981C0[000A0000]            add r8, board
  1472 00000B6C 4C89C9                      mov rcx, r9
  1473 00000B6F B850000000                  mov rax, column_cells + 2
  1474 00000B74 48F7E9                      imul rcx
  1475 00000B77 4901C0                      add r8, rax
  1476 00000B7A 41C6004F                    mov byte [r8], char_O
  1477 00000B7E C3                          ret
  1478                                  
  1479                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1480                                  	
  1481                                  print_pallet:
  1482                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1483 00000B7F 4C8B05(3F140000)            mov r8, [pallet_position]
  1484 00000B86 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1485                                      .clear_pallet:
  1486 00000B8D 41C60020                        mov byte [r8], char_space
  1487 00000B91 49FFC0                          inc r8
  1488 00000B94 48FFC9                          dec rcx
  1489 00000B97 75F4                            jnz .clear_pallet
  1490                                  
  1491                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1492 00000B99 4C8B05(3F140000)            mov r8, [pallet_position]
  1493 00000BA0 488B0D(47140000)            mov rcx, [pallet_size]
  1494                                      .write_pallet:
  1495 00000BA7 41C6003D                        mov byte [r8], char_equal
  1496 00000BAB 49FFC0                          inc r8
  1497 00000BAE 48FFC9                          dec rcx
  1498 00000BB1 75F4                            jnz .write_pallet
  1499                                  
  1500 00000BB3 C3                          ret
  1501                                  
  1502                                  move_pallet:
  1503                                      
  1504 00000BB4 803D(7F140000)00            cmp byte [ball_moving], 0
  1505 00000BBB 7507                        jne .continue_movement
  1506 00000BBD C605(7F140000)01            mov byte [ball_moving], 1
  1507                                  
  1508                                      .continue_movement:
  1509 00000BC4 4883FFFF                        cmp rdi, left_direction
  1510 00000BC8 7531                            jne .move_right
  1511                                  
  1512                                          .move_left:
  1513                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1514 00000BCA 4C8B05(3F140000)                    mov r8, [pallet_position]
  1515 00000BD1 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1516 00000BD4 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1517 00000BD7 3C58                                cmp al, 'X'        ; Comparar si es una X
  1518 00000BD9 744E                                je .end            ; Si es X, no mover
  1519                                              
  1520 00000BDB 4C8B05(3F140000)                    mov r8, [pallet_position]
  1521 00000BE2 4C8B0D(47140000)                    mov r9, [pallet_size]
  1522 00000BE9 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1523 00000BEF 49FFC8                              dec r8
  1524 00000BF2 4C8905(3F140000)                    mov [pallet_position], r8
  1525 00000BF9 EB2E                                jmp .end
  1526                                              
  1527                                          .move_right:
  1528                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1529 00000BFB 4C8B05(3F140000)                    mov r8, [pallet_position]
  1530 00000C02 4C8B0D(47140000)                    mov r9, [pallet_size]
  1531 00000C09 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1532 00000C0C 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1533 00000C10 3C58                                cmp al, 'X'        ; Comparar si es una X
  1534 00000C12 7415                                je .end            ; Si es X, no mover
  1535                                              
  1536 00000C14 4C8B05(3F140000)                    mov r8, [pallet_position]
  1537 00000C1B 41C60020                            mov byte [r8], char_space
  1538 00000C1F 49FFC0                              inc r8
  1539 00000C22 4C8905(3F140000)                    mov [pallet_position], r8
  1540                                          .end:
  1541 00000C29 C3                                  ret
  1542                                  
  1543                                  
  1544                                  
  1545                                              
  1546                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1547                                  update_caught_ball_position:
  1548 00000C2A 55                          push rbp
  1549 00000C2B 4889E5                      mov rbp, rsp
  1550                                      
  1551                                      ; Calcular la nueva posición de la bola basada en la paleta
  1552 00000C2E 4C8B05(3F140000)            mov r8, [pallet_position]
  1553 00000C35 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1554 00000C3C B850000000                  mov rax, column_cells + 2
  1555 00000C41 4831D2                      xor rdx, rdx
  1556 00000C44 48F7F0                      div rax                ; División para obtener X,Y
  1557                                      
  1558                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1559 00000C47 4989C1                      mov r9, rax            ; Y de la paleta
  1560 00000C4A 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1561                                      
  1562                                      ; Añadir el offset guardado a la posición X
  1563 00000C4D 4889D0                      mov rax, rdx
  1564 00000C50 480305(5A180000)            add rax, [ball_catch_offset]
  1565 00000C57 488905(5F140000)            mov [ball_x_pos], rax
  1566 00000C5E 4C890D(67140000)            mov [ball_y_pos], r9
  1567                                      
  1568 00000C65 5D                          pop rbp
  1569 00000C66 C3                          ret
  1570                                  
  1571                                  
  1572                                  move_all_balls:
  1573 00000C67 55                          push rbp
  1574 00000C68 4889E5                      mov rbp, rsp
  1575 00000C6B 53                          push rbx
  1576                                      
  1577                                      ; Inicializar contador de bolas
  1578 00000C6C 4831DB                      xor rbx, rbx
  1579                                      
  1580                                  .loop_balls:
  1581                                      ; Verificar si hemos procesado todas las bolas
  1582 00000C6F 3A1D(99190000)              cmp bl, byte [balls_count]
  1583 00000C75 7D1D                        jge .end
  1584                                      
  1585                                      ; Calcular offset de la bola actual
  1586 00000C77 B821000000                  mov rax, BALL_STRUCT_SIZE
  1587 00000C7C 48F7E3                      mul rbx
  1588                                      
  1589                                      ; Verificar si la bola está activa
  1590 00000C7F 80B8[56190000]01            cmp byte [balls_data + rax + 32], 1
  1591 00000C86 7507                        jne .next_ball
  1592                                      
  1593                                      ; Guardar offset en la pila
  1594 00000C88 50                          push rax
  1595                                      
  1596                                      ; Llamar a move_ball con los parámetros de esta bola
  1597 00000C89 E809000000                  call move_ball
  1598                                      
  1599                                      ; Restaurar offset
  1600 00000C8E 58                          pop rax
  1601                                      
  1602                                  .next_ball:
  1603 00000C8F 48FFC3                      inc rbx
  1604 00000C92 EBDB                        jmp .loop_balls
  1605                                      
  1606                                  .end:
  1607 00000C94 5B                          pop rbx
  1608 00000C95 5D                          pop rbp
  1609 00000C96 C3                          ret
  1610                                  
  1611                                  move_ball:
  1612                                  
  1613 00000C97 803D(59180000)01            cmp byte [ball_caught], 1
  1614 00000C9E 0F849D000000                je .move_with_pallet
  1615                                  
  1616 00000CA4 803D(7F140000)00            cmp byte [ball_moving], 0
  1617 00000CAB 0F84B8010000                je .end
  1618                                  
  1619                                      ; Incrementar contador de velocidad
  1620 00000CB1 48FF05(50180000)            inc qword [speed_counter]
  1621                                      
  1622                                      ; Verificar si debemos mover la bola en este ciclo
  1623 00000CB8 488B05(50180000)            mov rax, [speed_counter]
  1624 00000CBF 483B05(40180000)            cmp rax, [ball_speed]
  1625 00000CC6 0F8C9D010000                jl .end
  1626                                      
  1627                                      ; Resetear contador de velocidad
  1628 00000CCC 48C705(50180000)00-         mov qword [speed_counter], 0
  1628 00000CD4 000000             
  1629                                  
  1630                                      ; Borrar la posición actual de la bola
  1631 00000CD7 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1632 00000CDE 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1633 00000CE5 4981C0[000A0000]            add r8, board
  1634 00000CEC 4C89C9                      mov rcx, r9
  1635 00000CEF B850000000                  mov rax, column_cells + 2
  1636 00000CF4 48F7E9                      imul rcx
  1637 00000CF7 4901C0                      add r8, rax
  1638 00000CFA 41C60020                    mov byte [r8], char_space
  1639                                  
  1640                                      ; Calcular siguiente posición X
  1641 00000CFE 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1642 00000D05 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1643 00000D0C 488B05(6F140000)            mov rax, [ball_direction_x]
  1644 00000D13 4901C0                      add r8, rax               ; Nueva posición X
  1645                                  
  1646                                      ; Calcular la dirección de memoria para la siguiente posición
  1647 00000D16 4D89C2                      mov r10, r8
  1648 00000D19 4981C2[000A0000]            add r10, board
  1649 00000D20 4C89C9                      mov rcx, r9
  1650 00000D23 B850000000                  mov rax, column_cells + 2
  1651 00000D28 48F7E9                      imul rcx
  1652 00000D2B 4901C2                      add r10, rax
  1653                                  
  1654                                      ; Verificar si hay una X en la siguiente posición X
  1655 00000D2E 418A02                      mov al, [r10]
  1656 00000D31 3C58                        cmp al, 'X'
  1657 00000D33 7565                        jne .check_block_x
  1658 00000D35 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1659 00000D3C E928010000                  jmp .end
  1660                                  
  1661                                      .move_with_pallet:
  1662                                          ; Borrar la posición actual de la bola
  1663 00000D41 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1664 00000D48 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1665 00000D4F 4D89C2                          mov r10, r8
  1666 00000D52 4981C2[000A0000]                add r10, board
  1667 00000D59 4C89C9                          mov rcx, r9
  1668 00000D5C B850000000                      mov rax, column_cells + 2
  1669 00000D61 48F7E9                          imul rcx
  1670 00000D64 4901C2                          add r10, rax
  1671 00000D67 41C60220                        mov byte [r10], char_space
  1672                                  
  1673                                          ; Actualizar posición X basada en la paleta
  1674 00000D6B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1675 00000D72 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1676 00000D79 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1677 00000D80 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1678                                  
  1679                                          ; Mantener la bola una posición arriba de la paleta
  1680 00000D87 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1681 00000D8E 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1682                                  
  1683 00000D95 E9CF000000                      jmp .end
  1684                                  
  1685                                  
  1686                                      .check_block_x:
  1687                                          ; Verificar colisión con bloques en X
  1688 00000D9A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1689 00000D9C 4151                            push r9
  1690 00000D9E 4152                            push r10
  1691 00000DA0 E88D0A0000                      call check_block_collision
  1692 00000DA5 415A                            pop r10
  1693 00000DA7 4159                            pop r9
  1694 00000DA9 4158                            pop r8
  1695 00000DAB 4885C0                          test rax, rax
  1696 00000DAE 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1697 00000DB0 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1698 00000DB7 E9AD000000                      jmp .end
  1699                                  
  1700                                      .check_paddle_x:
  1701                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1702 00000DBC 41803A3D                        cmp byte [r10], char_equal
  1703 00000DC0 750C                            jne .check_y_movement
  1704 00000DC2 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1705 00000DC9 E99B000000                      jmp .end
  1706                                  
  1707                                      .check_y_movement:
  1708                                          ; Calcular siguiente posición Y
  1709 00000DCE 488B05(77140000)                mov rax, [ball_direction_y]
  1710 00000DD5 4901C1                          add r9, rax                  ; Nueva posición Y
  1711                                  
  1712                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1713 00000DD8 4D89C2                          mov r10, r8
  1714 00000DDB 4981C2[000A0000]                add r10, board
  1715 00000DE2 4C89C9                          mov rcx, r9
  1716 00000DE5 B850000000                      mov rax, column_cells + 2
  1717 00000DEA 48F7E9                          imul rcx
  1718 00000DED 4901C2                          add r10, rax
  1719                                  
  1720                                          ; Verificar si hay una X en la siguiente posición Y
  1721 00000DF0 418A02                          mov al, [r10]
  1722 00000DF3 3C58                            cmp al, 'X'
  1723 00000DF5 7509                            jne .check_block_y
  1724 00000DF7 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1725 00000DFE EB69                            jmp .end
  1726                                  
  1727                                      .check_block_y:
  1728                                          ; Verificar colisión con bloques en Y
  1729 00000E00 4150                            push r8     ; Guardar registros que usa check_block_collision
  1730 00000E02 4151                            push r9
  1731 00000E04 4152                            push r10
  1732 00000E06 E8270A0000                      call check_block_collision
  1733 00000E0B 415A                            pop r10
  1734 00000E0D 4159                            pop r9
  1735 00000E0F 4158                            pop r8
  1736 00000E11 4885C0                          test rax, rax
  1737 00000E14 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1738 00000E16 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1739 00000E1D EB4A                            jmp .end
  1740                                  
  1741                                      .check_paddle_y:
  1742                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1743 00000E1F 41803A3D                        cmp byte [r10], char_equal
  1744 00000E23 7536                            jne .update_position
  1745                                  
  1746                                          ; Verificar si el poder catch está activo
  1747 00000E25 803D(58180000)01                cmp byte [catch_power_active], 1
  1748 00000E2C 7524                            jne .normal_bounce
  1749                                  
  1750                                          ; Activar el modo "atrapado"
  1751 00000E2E C605(59180000)01                mov byte [ball_caught], 1
  1752                                          
  1753                                          ; Guardar la posición X actual de la bola como offset
  1754 00000E35 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1755 00000E3C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1756 00000E43 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1757 00000E49 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1758                                          
  1759 00000E50 EB17                            jmp .end
  1760                                  
  1761                                      .normal_bounce:
  1762 00000E52 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1763 00000E59 EB0E                            jmp .end
  1764                                  
  1765                                  
  1766                                      .update_position:
  1767 00000E5B 4C8905(5F140000)                mov [ball_x_pos], r8
  1768 00000E62 4C890D(67140000)                mov [ball_y_pos], r9
  1769                                  
  1770                                      .end:
  1771 00000E69 C3                              ret
  1772                                  
  1773                                  
  1774                                  move_ball_2:
  1775                                  
  1776 00000E6A 803D(59180000)01            cmp byte [ball_caught], 1
  1777 00000E71 0F849D000000                je .move_with_pallet
  1778                                  
  1779 00000E77 803D(A1140000)00            cmp byte [ball2_moving], 0
  1780 00000E7E 0F84B8010000                je .end
  1781                                  
  1782                                      ; Incrementar contador de velocidad
  1783 00000E84 48FF05(50180000)            inc qword [speed_counter]
  1784                                      
  1785                                      ; Verificar si debemos mover la bola en este ciclo
  1786 00000E8B 488B05(50180000)            mov rax, [speed_counter]
  1787 00000E92 483B05(40180000)            cmp rax, [ball_speed]
  1788 00000E99 0F8C9D010000                jl .end
  1789                                      
  1790                                      ; Resetear contador de velocidad
  1791 00000E9F 48C705(50180000)00-         mov qword [speed_counter], 0
  1791 00000EA7 000000             
  1792                                  
  1793                                      ; Borrar la posición actual de la bola
  1794 00000EAA 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1795 00000EB1 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1796 00000EB8 4981C0[000A0000]            add r8, board
  1797 00000EBF 4C89C9                      mov rcx, r9
  1798 00000EC2 B850000000                  mov rax, column_cells + 2
  1799 00000EC7 48F7E9                      imul rcx
  1800 00000ECA 4901C0                      add r8, rax
  1801 00000ECD 41C60020                    mov byte [r8], char_space
  1802                                  
  1803                                      ; Calcular siguiente posición X
  1804 00000ED1 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1805 00000ED8 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1806 00000EDF 488B05(91140000)            mov rax, [ball2_direction_x]
  1807 00000EE6 4901C0                      add r8, rax               ; Nueva posición X
  1808                                  
  1809                                      ; Calcular la dirección de memoria para la siguiente posición
  1810 00000EE9 4D89C2                      mov r10, r8
  1811 00000EEC 4981C2[000A0000]            add r10, board
  1812 00000EF3 4C89C9                      mov rcx, r9
  1813 00000EF6 B850000000                  mov rax, column_cells + 2
  1814 00000EFB 48F7E9                      imul rcx
  1815 00000EFE 4901C2                      add r10, rax
  1816                                  
  1817                                      ; Verificar si hay una X en la siguiente posición X
  1818 00000F01 418A02                      mov al, [r10]
  1819 00000F04 3C58                        cmp al, 'X'
  1820 00000F06 7565                        jne .check_block_x
  1821 00000F08 48F71D(91140000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1822 00000F0F E928010000                  jmp .end
  1823                                  
  1824                                      .move_with_pallet:
  1825                                          ; Borrar la posición actual de la bola
  1826 00000F14 4C8B05(81140000)                mov r8, [ball2_x_pos]
  1827 00000F1B 4C8B0D(89140000)                mov r9, [ball2_y_pos]
  1828 00000F22 4D89C2                          mov r10, r8
  1829 00000F25 4981C2[000A0000]                add r10, board
  1830 00000F2C 4C89C9                          mov rcx, r9
  1831 00000F2F B850000000                      mov rax, column_cells + 2
  1832 00000F34 48F7E9                          imul rcx
  1833 00000F37 4901C2                          add r10, rax
  1834 00000F3A 41C60220                        mov byte [r10], char_space
  1835                                  
  1836                                          ; Actualizar posición X basada en la paleta
  1837 00000F3E 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1838 00000F45 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1839 00000F4C 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1840 00000F53 4C8905(81140000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1841                                  
  1842                                          ; Mantener la bola una posición arriba de la paleta
  1843 00000F5A 4C8B0D(89140000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1844 00000F61 4C890D(89140000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1845                                  
  1846 00000F68 E9CF000000                      jmp .end
  1847                                  
  1848                                  
  1849                                      .check_block_x:
  1850                                          ; Verificar colisión con bloques en X
  1851 00000F6D 4150                            push r8     ; Guardar registros que usa check_block_collision
  1852 00000F6F 4151                            push r9
  1853 00000F71 4152                            push r10
  1854 00000F73 E8BA080000                      call check_block_collision
  1855 00000F78 415A                            pop r10
  1856 00000F7A 4159                            pop r9
  1857 00000F7C 4158                            pop r8
  1858 00000F7E 4885C0                          test rax, rax
  1859 00000F81 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1860 00000F83 48F71D(91140000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1861 00000F8A E9AD000000                      jmp .end
  1862                                  
  1863                                      .check_paddle_x:
  1864                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1865 00000F8F 41803A3D                        cmp byte [r10], char_equal
  1866 00000F93 750C                            jne .check_y_movement
  1867 00000F95 48F71D(91140000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1868 00000F9C E99B000000                      jmp .end
  1869                                  
  1870                                      .check_y_movement:
  1871                                          ; Calcular siguiente posición Y
  1872 00000FA1 488B05(99140000)                mov rax, [ball2_direction_y]
  1873 00000FA8 4901C1                          add r9, rax                  ; Nueva posición Y
  1874                                  
  1875                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1876 00000FAB 4D89C2                          mov r10, r8
  1877 00000FAE 4981C2[000A0000]                add r10, board
  1878 00000FB5 4C89C9                          mov rcx, r9
  1879 00000FB8 B850000000                      mov rax, column_cells + 2
  1880 00000FBD 48F7E9                          imul rcx
  1881 00000FC0 4901C2                          add r10, rax
  1882                                  
  1883                                          ; Verificar si hay una X en la siguiente posición Y
  1884 00000FC3 418A02                          mov al, [r10]
  1885 00000FC6 3C58                            cmp al, 'X'
  1886 00000FC8 7509                            jne .check_block_y
  1887 00000FCA 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1888 00000FD1 EB69                            jmp .end
  1889                                  
  1890                                      .check_block_y:
  1891                                          ; Verificar colisión con bloques en Y
  1892 00000FD3 4150                            push r8     ; Guardar registros que usa check_block_collision
  1893 00000FD5 4151                            push r9
  1894 00000FD7 4152                            push r10
  1895 00000FD9 E854080000                      call check_block_collision
  1896 00000FDE 415A                            pop r10
  1897 00000FE0 4159                            pop r9
  1898 00000FE2 4158                            pop r8
  1899 00000FE4 4885C0                          test rax, rax
  1900 00000FE7 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1901 00000FE9 48F71D(99140000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1902 00000FF0 EB4A                            jmp .end
  1903                                  
  1904                                      .check_paddle_y:
  1905                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1906 00000FF2 41803A3D                        cmp byte [r10], char_equal
  1907 00000FF6 7536                            jne .update_position
  1908                                  
  1909                                          ; Verificar si el poder catch está activo
  1910 00000FF8 803D(58180000)01                cmp byte [catch_power_active], 1
  1911 00000FFF 7524                            jne .normal_bounce
  1912                                  
  1913                                          ; Activar el modo "atrapado"
  1914 00001001 C605(59180000)01                mov byte [ball_caught], 1
  1915                                          
  1916                                          ; Guardar la posición X actual de la bola como offset
  1917 00001008 488B05(81140000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  1918 0000100F 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1919 00001016 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1920 0000101C 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1921                                          
  1922 00001023 EB17                            jmp .end
  1923                                  
  1924                                      .normal_bounce:
  1925 00001025 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  1926 0000102C EB0E                            jmp .end
  1927                                  
  1928                                  
  1929                                      .update_position:
  1930 0000102E 4C8905(81140000)                mov [ball2_x_pos], r8
  1931 00001035 4C890D(89140000)                mov [ball2_y_pos], r9
  1932                                  
  1933                                      .end:
  1934 0000103C C3                              ret
  1935                                  
  1936                                  move_ball_3:
  1937                                  
  1938 0000103D 803D(59180000)01            cmp byte [ball_caught], 1
  1939 00001044 0F849D000000                je .move_with_pallet
  1940                                  
  1941 0000104A 803D(C3140000)00            cmp byte [ball3_moving], 0
  1942 00001051 0F84B8010000                je .end
  1943                                  
  1944                                      ; Incrementar contador de velocidad
  1945 00001057 48FF05(50180000)            inc qword [speed_counter]
  1946                                      
  1947                                      ; Verificar si debemos mover la bola en este ciclo
  1948 0000105E 488B05(50180000)            mov rax, [speed_counter]
  1949 00001065 483B05(40180000)            cmp rax, [ball_speed]
  1950 0000106C 0F8C9D010000                jl .end
  1951                                      
  1952                                      ; Resetear contador de velocidad
  1953 00001072 48C705(50180000)00-         mov qword [speed_counter], 0
  1953 0000107A 000000             
  1954                                  
  1955                                      ; Borrar la posición actual de la bola
  1956 0000107D 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1957 00001084 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1958 0000108B 4981C0[000A0000]            add r8, board
  1959 00001092 4C89C9                      mov rcx, r9
  1960 00001095 B850000000                  mov rax, column_cells + 2
  1961 0000109A 48F7E9                      imul rcx
  1962 0000109D 4901C0                      add r8, rax
  1963 000010A0 41C60020                    mov byte [r8], char_space
  1964                                  
  1965                                      ; Calcular siguiente posición X
  1966 000010A4 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1967 000010AB 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1968 000010B2 488B05(B3140000)            mov rax, [ball3_direction_x]
  1969 000010B9 4901C0                      add r8, rax               ; Nueva posición X
  1970                                  
  1971                                      ; Calcular la dirección de memoria para la siguiente posición
  1972 000010BC 4D89C2                      mov r10, r8
  1973 000010BF 4981C2[000A0000]            add r10, board
  1974 000010C6 4C89C9                      mov rcx, r9
  1975 000010C9 B850000000                  mov rax, column_cells + 2
  1976 000010CE 48F7E9                      imul rcx
  1977 000010D1 4901C2                      add r10, rax
  1978                                  
  1979                                      ; Verificar si hay una X en la siguiente posición X
  1980 000010D4 418A02                      mov al, [r10]
  1981 000010D7 3C58                        cmp al, 'X'
  1982 000010D9 7565                        jne .check_block_x
  1983 000010DB 48F71D(B3140000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  1984 000010E2 E928010000                  jmp .end
  1985                                  
  1986                                      .move_with_pallet:
  1987                                          ; Borrar la posición actual de la bola
  1988 000010E7 4C8B05(A3140000)                mov r8, [ball3_x_pos]
  1989 000010EE 4C8B0D(AB140000)                mov r9, [ball3_y_pos]
  1990 000010F5 4D89C2                          mov r10, r8
  1991 000010F8 4981C2[000A0000]                add r10, board
  1992 000010FF 4C89C9                          mov rcx, r9
  1993 00001102 B850000000                      mov rax, column_cells + 2
  1994 00001107 48F7E9                          imul rcx
  1995 0000110A 4901C2                          add r10, rax
  1996 0000110D 41C60220                        mov byte [r10], char_space
  1997                                  
  1998                                          ; Actualizar posición X basada en la paleta
  1999 00001111 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2000 00001118 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2001 0000111F 4C0305(5A180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2002 00001126 4C8905(A3140000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2003                                  
  2004                                          ; Mantener la bola una posición arriba de la paleta
  2005 0000112D 4C8B0D(AB140000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2006 00001134 4C890D(AB140000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2007                                  
  2008 0000113B E9CF000000                      jmp .end
  2009                                  
  2010                                  
  2011                                      .check_block_x:
  2012                                          ; Verificar colisión con bloques en X
  2013 00001140 4150                            push r8     ; Guardar registros que usa check_block_collision
  2014 00001142 4151                            push r9
  2015 00001144 4152                            push r10
  2016 00001146 E8E7060000                      call check_block_collision
  2017 0000114B 415A                            pop r10
  2018 0000114D 4159                            pop r9
  2019 0000114F 4158                            pop r8
  2020 00001151 4885C0                          test rax, rax
  2021 00001154 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2022 00001156 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2023 0000115D E9AD000000                      jmp .end
  2024                                  
  2025                                      .check_paddle_x:
  2026                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2027 00001162 41803A3D                        cmp byte [r10], char_equal
  2028 00001166 750C                            jne .check_y_movement
  2029 00001168 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2030 0000116F E99B000000                      jmp .end
  2031                                  
  2032                                      .check_y_movement:
  2033                                          ; Calcular siguiente posición Y
  2034 00001174 488B05(BB140000)                mov rax, [ball3_direction_y]
  2035 0000117B 4901C1                          add r9, rax                  ; Nueva posición Y
  2036                                  
  2037                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2038 0000117E 4D89C2                          mov r10, r8
  2039 00001181 4981C2[000A0000]                add r10, board
  2040 00001188 4C89C9                          mov rcx, r9
  2041 0000118B B850000000                      mov rax, column_cells + 2
  2042 00001190 48F7E9                          imul rcx
  2043 00001193 4901C2                          add r10, rax
  2044                                  
  2045                                          ; Verificar si hay una X en la siguiente posición Y
  2046 00001196 418A02                          mov al, [r10]
  2047 00001199 3C58                            cmp al, 'X'
  2048 0000119B 7509                            jne .check_block_y
  2049 0000119D 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2050 000011A4 EB69                            jmp .end
  2051                                  
  2052                                      .check_block_y:
  2053                                          ; Verificar colisión con bloques en Y
  2054 000011A6 4150                            push r8     ; Guardar registros que usa check_block_collision
  2055 000011A8 4151                            push r9
  2056 000011AA 4152                            push r10
  2057 000011AC E881060000                      call check_block_collision
  2058 000011B1 415A                            pop r10
  2059 000011B3 4159                            pop r9
  2060 000011B5 4158                            pop r8
  2061 000011B7 4885C0                          test rax, rax
  2062 000011BA 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2063 000011BC 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2064 000011C3 EB4A                            jmp .end
  2065                                  
  2066                                      .check_paddle_y:
  2067                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2068 000011C5 41803A3D                        cmp byte [r10], char_equal
  2069 000011C9 7536                            jne .update_position
  2070                                  
  2071                                          ; Verificar si el poder catch está activo
  2072 000011CB 803D(58180000)01                cmp byte [catch_power_active], 1
  2073 000011D2 7524                            jne .normal_bounce
  2074                                  
  2075                                          ; Activar el modo "atrapado"
  2076 000011D4 C605(59180000)01                mov byte [ball_caught], 1
  2077                                          
  2078                                          ; Guardar la posición X actual de la bola como offset
  2079 000011DB 488B05(A3140000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2080 000011E2 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2081 000011E9 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2082 000011EF 488905(5A180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2083                                          
  2084 000011F6 EB17                            jmp .end
  2085                                  
  2086                                      .normal_bounce:
  2087 000011F8 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2088 000011FF EB0E                            jmp .end
  2089                                  
  2090                                  
  2091                                      .update_position:
  2092 00001201 4C8905(A3140000)                mov [ball3_x_pos], r8
  2093 00001208 4C890D(AB140000)                mov [ball3_y_pos], r9
  2094                                  
  2095                                      .end:
  2096 0000120F C3                              ret
  2097                                  
  2098                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2099                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2100                                  process_catch_release:
  2101 00001210 55                          push rbp
  2102 00001211 4889E5                      mov rbp, rsp
  2103                                  
  2104                                      ; Verificar si la bola está atrapada
  2105 00001214 803D(59180000)00            cmp byte [ball_caught], 0
  2106 0000121B 7436                        je .end
  2107                                  
  2108                                      ; Verificar si el poder catch está activo
  2109 0000121D 803D(58180000)01            cmp byte [catch_power_active], 1
  2110 00001224 752D                        jne .end
  2111                                  
  2112                                      ; Verificar si se presionó la tecla 'c'
  2113 00001226 803D(62180000)63            cmp byte [last_key], 'c'
  2114 0000122D 7524                        jne .end
  2115                                  
  2116                                      ; Liberar la bola y asignar dirección inicial
  2117 0000122F C605(59180000)00            mov byte [ball_caught], 0
  2118 00001236 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  2118 0000123E 000000             
  2119 00001241 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  2119 00001249 FFFFFF             
  2120                                  
  2121                                      ; Limpiar la tecla procesada
  2122 0000124C C605(62180000)00            mov byte [last_key], 0
  2123                                  
  2124                                      .end:
  2125 00001253 5D                              pop rbp
  2126 00001254 C3                              ret
  2127                                  
  2128                                  
  2129                                  display_level_number:
  2130 00001255 55                          push rbp
  2131 00001256 4889E5                      mov rbp, rsp
  2132                                      
  2133                                      ; Limpiar la pantalla primero
  2134                                      print clear, clear_length
    82 00001259 B801000000          <1>  mov eax, sys_write
    83 0000125E BF01000000          <1>  mov edi, 1
    84 00001263 48BE-               <1>  mov rsi, %1
    84 00001265 [1000000000000000]  <1>
    85 0000126D BA07000000          <1>  mov edx, %2
    86 00001272 0F05                <1>  syscall
  2135                                      
  2136                                      ; Calcular la posición central para el mensaje
  2137                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2138 00001274 B84E000000                  mov rax, column_cells
  2139 00001279 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2140 0000127D 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2141                                      
  2142                                      ; Calcular la fila central
  2143 00001280 BB20000000                  mov rbx, row_cells
  2144 00001285 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2145                                      
  2146                                      ; Calcular el offset en el buffer
  2147 00001288 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2148 0000128D 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2149 00001290 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2150                                      
  2151                                      ; Escribir "NIVEL " en la posición calculada
  2152 00001293 488DB8[000A0000]            lea rdi, [board + rax]
  2153 0000129A 48BE-                       mov rsi, level_msg
  2153 0000129C [2414000000000000] 
  2154 000012A4 B906000000                  mov rcx, level_msg_len
  2155 000012A9 F3A4                        rep movsb
  2156                                      
  2157                                      ; Escribir el número del nivel
  2158 000012AB 8A05(F9140000)              mov al, [current_level]
  2159 000012B1 0430                        add al, '0'                 ; convertir a ASCII
  2160 000012B3 8807                        mov [rdi], al
  2161                                      
  2162                                      ; Mostrar el board con el mensaje
  2163                                      print board, board_size
    82 000012B5 B801000000          <1>  mov eax, sys_write
    83 000012BA BF01000000          <1>  mov edi, 1
    84 000012BF 48BE-               <1>  mov rsi, %1
    84 000012C1 [000A000000000000]  <1>
    85 000012C9 BA000A0000          <1>  mov edx, %2
    86 000012CE 0F05                <1>  syscall
  2164                                      
  2165                                      ; Esperar un segundo
  2166 000012D0 B823000000                  mov rax, sys_nanosleep
  2167 000012D5 48BF-                       mov rdi, level_display_time
  2167 000012D7 [2F14000000000000] 
  2168 000012DF 4831F6                      xor rsi, rsi
  2169 000012E2 0F05                        syscall
  2170                                      
  2171 000012E4 5D                          pop rbp
  2172 000012E5 C3                          ret
  2173                                  
  2174                                  ; Función para inicializar un tablero vacío
  2175                                  init_empty_board:
  2176 000012E6 56                          push rsi
  2177 000012E7 57                          push rdi
  2178 000012E8 51                          push rcx
  2179 000012E9 50                          push rax
  2180                                  
  2181 000012EA 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2182 000012F1 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2183 000012F8 B9000A0000                  mov rcx, board_template_size
  2184 000012FD F3A4                        rep movsb                   ; Copiar el tablero
  2185                                  
  2186 000012FF 58                          pop rax
  2187 00001300 59                          pop rcx
  2188 00001301 5F                          pop rdi
  2189 00001302 5E                          pop rsi
  2190 00001303 C3                          ret
  2191                                  
  2192                                  
  2193                                  init_level:
  2194 00001304 C605(63180000)00            mov byte [laser_power_active], 0
  2195 0000130B E878F4FFFF                  call clear_lasers
  2196 00001310 488B05(4F140000)            mov rax, [default_pallet_size]
  2197 00001317 488905(47140000)            mov [pallet_size], rax
  2198 0000131E 48C705(40180000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2198 00001326 000000             
  2199                                  
  2200                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2201                                          ; Reiniciar letras activas
  2202 00001329 488D3D(99160000)            lea rdi, [letters_map]
  2203 00001330 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2204 00001335 4831C0                      xor rax, rax
  2205 00001338 F3AA                        rep stosb                    ; Llenar con ceros
  2206                                      
  2207                                      ; Inicializar dirección de la bola (derecha y arriba)
  2208 0000133A 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2208 00001342 000000             
  2209 00001345 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2209 0000134D FFFFFF             
  2210                                  
  2211                                  
  2212                                      ; Reiniciar contador de letras activas
  2213 00001350 4831C0                      xor rax, rax
  2214 00001353 8805(29180000)              mov [letters_count], al
  2215                                  
  2216                                      ; Reiniciar última letra capturada
  2217 00001359 C605(2A180000)20            mov byte [last_letter], ' '
  2218 00001360 C605(A3150000)00            mov byte [destroyed_blocks], 0 
  2219 00001367 E87AFFFFFF                  call init_empty_board
  2220 0000136C E8E4FEFFFF                  call display_level_number
  2221 00001371 E8E5050000                  call init_enemies
  2222                                      
  2223 00001376 56                          push rsi
  2224 00001377 57                          push rdi
  2225 00001378 51                          push rcx
  2226 00001379 50                          push rax
  2227                                  
  2228 0000137A 488D35(00000000)            lea rsi, [board_template]
  2229 00001381 488D3D(000A0000)            lea rdi, [board]
  2230 00001388 B9000A0000                  mov rcx, board_template_size
  2231 0000138D F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2232                                  
  2233 0000138F 58                          pop rax
  2234 00001390 59                          pop rcx
  2235 00001391 5F                          pop rdi
  2236 00001392 5E                          pop rsi
  2237                                  
  2238 00001393 B90A000000                  mov rcx, 10
  2239 00001398 4831C0                      xor rax, rax
  2240 0000139B 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2241 000013A2 F3AA                        rep stosb      
  2242                                  
  2243                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2244 000013A4 803D(F9140000)01            cmp byte [current_level], 1
  2245 000013AB 7431                        je .level1
  2246 000013AD 803D(F9140000)02            cmp byte [current_level], 2
  2247 000013B4 7454                        je .level2
  2248 000013B6 803D(F9140000)03            cmp byte [current_level], 3
  2249 000013BD 7477                        je .level3
  2250 000013BF 803D(F9140000)04            cmp byte [current_level], 4
  2251 000013C6 0F8492000000                je .level4
  2252 000013CC 803D(F9140000)05            cmp byte [current_level], 5
  2253 000013D3 0F84AD000000                je .level5
  2254 000013D9 E9D0000000                  jmp .done
  2255                                  
  2256                                  
  2257                                  
  2258                                      .level1:
  2259 000013DE C605(FA140000)08                mov byte [blocks_remaining], level1_blocks_count
  2260 000013E5 4831C9                          xor rcx, rcx             
  2261                                          .init_loop1:
  2262 000013E8 4883F908                            cmp rcx, level1_blocks_count
  2263 000013EC 0F8DBC000000                        jge .done
  2264 000013F2 4889C8                              mov rax, rcx         
  2265 000013F5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2266 000013F9 8A90[FE140000]                      mov dl, byte [level1_blocks + rax + 3]  
  2267 000013FF 8891[37150000]                      mov byte [block_states + rcx], dl
  2268 00001405 48FFC1                              inc rcx
  2269 00001408 EBDE                                jmp .init_loop1
  2270                                  
  2271                                      .level2:
  2272 0000140A C605(FA140000)01                mov byte [blocks_remaining], level2_blocks_count
  2273 00001411 4831C9                          xor rcx, rcx             
  2274                                          .init_loop2:
  2275 00001414 4883F901                            cmp rcx, level2_blocks_count
  2276 00001418 0F8D90000000                        jge .done
  2277 0000141E 4889C8                              mov rax, rcx         
  2278 00001421 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2279 00001425 8A90[26150000]                      mov dl, byte [level2_blocks + rax + 3]  
  2280 0000142B 8891[37150000]                      mov byte [block_states + rcx], dl
  2281 00001431 48FFC1                              inc rcx
  2282 00001434 EBDE                                jmp .init_loop2
  2283                                      .level3:
  2284 00001436 C605(FA140000)01                mov byte [blocks_remaining], level3_blocks_count
  2285 0000143D 4831C9                          xor rcx, rcx             
  2286                                          .init_loop3:
  2287 00001440 4883F901                            cmp rcx, level3_blocks_count
  2288 00001444 7D68                                jge .done
  2289 00001446 4889C8                              mov rax, rcx         
  2290 00001449 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2291 0000144D 8A90[2B150000]                      mov dl, byte [level3_blocks + rax + 3]  
  2292 00001453 8891[37150000]                      mov byte [block_states + rcx], dl
  2293 00001459 48FFC1                              inc rcx
  2294 0000145C EBE2                                jmp .init_loop3
  2295                                  
  2296                                      .level4:
  2297 0000145E C605(FA140000)01                mov byte [blocks_remaining], level4_blocks_count
  2298 00001465 4831C9                          xor rcx, rcx             
  2299                                          .init_loop4:
  2300 00001468 4883F901                            cmp rcx, level4_blocks_count
  2301 0000146C 7D40                                jge .done
  2302 0000146E 4889C8                              mov rax, rcx         
  2303 00001471 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2304 00001475 8A90[30150000]                      mov dl, byte [level4_blocks + rax + 3]  
  2305 0000147B 8891[37150000]                      mov byte [block_states + rcx], dl
  2306 00001481 48FFC1                              inc rcx
  2307 00001484 EBE2                                jmp .init_loop4
  2308                                  
  2309                                      .level5:
  2310 00001486 C605(FA140000)01                mov byte [blocks_remaining], level5_blocks_count
  2311 0000148D 4831C9                          xor rcx, rcx             
  2312                                          .init_loop5:
  2313 00001490 4883F901                            cmp rcx, level5_blocks_count
  2314 00001494 7D18                                jge .done
  2315 00001496 4889C8                              mov rax, rcx         
  2316 00001499 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2317 0000149D 8A90[35150000]                      mov dl, byte [level5_blocks + rax + 3]  
  2318 000014A3 8891[37150000]                      mov byte [block_states + rcx], dl
  2319 000014A9 48FFC1                              inc rcx
  2320 000014AC EBE2                                jmp .init_loop5
  2321                                      .done:
  2322 000014AE C3                              ret
  2323                                  
  2324                                  
  2325                                  ; Función para verificar y manejar la transición de nivel
  2326                                  check_level_complete:
  2327                                      ; Verificar si quedan bloques
  2328 000014AF 803D(FA140000)00            cmp byte [blocks_remaining], 0
  2329 000014B6 753C                        jne .not_complete
  2330                                      
  2331                                      ; Incrementar el nivel
  2332 000014B8 FE05(F9140000)              inc byte [current_level]
  2333                                      
  2334                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2335 000014BE 803D(F9140000)06            cmp byte [current_level], 6
  2336 000014C5 742E                        je game_win
  2337                                      
  2338                                      ; Reinicializar el juego para el siguiente nivel
  2339 000014C7 E838FEFFFF                  call init_level
  2340                                      
  2341                                      ; Reinicializar la posición de la bola y la paleta
  2342 000014CC 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  2342 000014D4 000000             
  2343 000014D7 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  2343 000014DF 000000             
  2344 000014E2 C605(7F140000)00            mov byte [ball_moving], 0
  2345 000014E9 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2345 000014F0 [36130000]         
  2346                                      
  2347                                      .not_complete:
  2348 000014F4 C3                              ret
  2349                                  
  2350                                      ; Nueva función para manejar la victoria del juego
  2351                                  game_win:
  2352                                      ; Limpiar la pantalla primero
  2353                                      print clear, clear_length
    82 000014F5 B801000000          <1>  mov eax, sys_write
    83 000014FA BF01000000          <1>  mov edi, 1
    84 000014FF 48BE-               <1>  mov rsi, %1
    84 00001501 [1000000000000000]  <1>
    85 00001509 BA07000000          <1>  mov edx, %2
    86 0000150E 0F05                <1>  syscall
  2354                                      
  2355                                      ; Mensaje de victoria
  2356 00001510 488B05(9B150000)            mov rax, [current_score]    ; Obtener el puntaje final
  2357 00001517 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2357 00001519 [A415000000000000] 
  2358 00001521 E8B4010000                  call number_to_string
  2359                                      
  2360                                      ; Definir mensaje de victoria
  2361                                      section .data
  2362 000019AA C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2362 000019B3 616465732120C2A148-
  2362 000019BC 61732067616E61646F-
  2362 000019C5 210A0D             
  2363                                          win_msg_len: equ $ - win_msg
  2364 000019C8 50756E74616A652066-             score_msg: db "Puntaje final: "
  2364 000019D1 696E616C3A20       
  2365                                          score_msg_len: equ $ - score_msg
  2366                                      section .text
  2367                                      
  2368                                      ; Imprimir mensajes
  2369                                      print win_msg, win_msg_len
    82 00001526 B801000000          <1>  mov eax, sys_write
    83 0000152B BF01000000          <1>  mov edi, 1
    84 00001530 48BE-               <1>  mov rsi, %1
    84 00001532 [AA19000000000000]  <1>
    85 0000153A BA1E000000          <1>  mov edx, %2
    86 0000153F 0F05                <1>  syscall
  2370                                      print score_msg, score_msg_len
    82 00001541 B801000000          <1>  mov eax, sys_write
    83 00001546 BF01000000          <1>  mov edi, 1
    84 0000154B 48BE-               <1>  mov rsi, %1
    84 0000154D [C819000000000000]  <1>
    85 00001555 BA0F000000          <1>  mov edx, %2
    86 0000155A 0F05                <1>  syscall
  2371                                      print number_buffer, 20
    82 0000155C B801000000          <1>  mov eax, sys_write
    83 00001561 BF01000000          <1>  mov edi, 1
    84 00001566 48BE-               <1>  mov rsi, %1
    84 00001568 [A415000000000000]  <1>
    85 00001570 BA14000000          <1>  mov edx, %2
    86 00001575 0F05                <1>  syscall
  2372                                      
  2373                                      ; Esperar un momento antes de salir
  2374 00001577 48C7057EEAFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2374 00001580 0000               
  2375 00001582 48C7057BEAFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2375 0000158B 0000               
  2376                                      sleeptime
    98 0000158D B823000000          <1>  mov eax, sys_nanosleep
    99 00001592 48BF-               <1>  mov rdi, timespec
    99 00001594 [0000000000000000]  <1>
   100 0000159C 31F6                <1>  xor esi, esi
   101 0000159E 0F05                <1>  syscall
  2377                                      
  2378 000015A0 E973090000                  jmp exit
  2379                                  
  2380                                  ; Función para imprimir los bloques
  2381                                  ; Función modificada para imprimir bloques
  2382                                  
  2383                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2384                                  get_current_level_blocks:
  2385 000015A5 803D(F9140000)01            cmp byte [current_level], 1
  2386 000015AC 7428                        je .level1
  2387 000015AE 803D(F9140000)02            cmp byte [current_level], 2
  2388 000015B5 7427                        je .level2
  2389 000015B7 803D(F9140000)03            cmp byte [current_level], 3
  2390 000015BE 7426                        je .level3
  2391 000015C0 803D(F9140000)04            cmp byte [current_level], 4
  2392 000015C7 7425                        je .level4
  2393 000015C9 803D(F9140000)05            cmp byte [current_level], 5
  2394 000015D0 7424                        je .level5
  2395                                      ; Si llegamos aquí, hay un error en el nivel
  2396 000015D2 4831C0                      xor rax, rax
  2397 000015D5 C3                          ret
  2398                                  
  2399                                      .level1:
  2400 000015D6 488D05(FB140000)                lea rax, [level1_blocks]
  2401 000015DD C3                              ret
  2402                                      .level2:
  2403 000015DE 488D05(23150000)                lea rax, [level2_blocks]
  2404 000015E5 C3                              ret
  2405                                      .level3:
  2406 000015E6 488D05(28150000)                lea rax, [level3_blocks]
  2407 000015ED C3                              ret
  2408                                      .level4:
  2409 000015EE 488D05(2D150000)                lea rax, [level4_blocks]
  2410 000015F5 C3                              ret
  2411                                      .level5:
  2412 000015F6 488D05(32150000)                lea rax, [level5_blocks]
  2413 000015FD C3                              ret
  2414                                  ; Función para obtener la cantidad de bloques del nivel actual
  2415                                  get_current_level_count:
  2416 000015FE 803D(F9140000)01            cmp byte [current_level], 1
  2417 00001605 7428                        je .level1
  2418 00001607 803D(F9140000)02            cmp byte [current_level], 2
  2419 0000160E 7425                        je .level2
  2420 00001610 803D(F9140000)03            cmp byte [current_level], 3
  2421 00001617 7422                        je .level3
  2422 00001619 803D(F9140000)04            cmp byte [current_level], 4
  2423 00001620 741F                        je .level4
  2424 00001622 803D(F9140000)05            cmp byte [current_level], 5
  2425 00001629 741C                        je .level5
  2426                                      ; Si llegamos aquí, hay un error en el nivel
  2427 0000162B 4831C0                      xor rax, rax
  2428 0000162E C3                          ret
  2429                                  
  2430                                      .level1:
  2431 0000162F B808000000                      mov rax, level1_blocks_count
  2432 00001634 C3                              ret
  2433                                      .level2:
  2434 00001635 B801000000                      mov rax, level2_blocks_count
  2435 0000163A C3                              ret
  2436                                      .level3:
  2437 0000163B B801000000                      mov rax, level3_blocks_count
  2438 00001640 C3                              ret
  2439                                      .level4:
  2440 00001641 B801000000                      mov rax, level4_blocks_count
  2441 00001646 C3                              ret
  2442                                      .level5:
  2443 00001647 B801000000                      mov rax, level5_blocks_count
  2444 0000164C C3                              ret
  2445                                  
  2446                                  
  2447                                  print_blocks:
  2448 0000164D 55                          push rbp
  2449 0000164E 4889E5                      mov rbp, rsp
  2450                                      
  2451                                      ; Obtener puntero a los bloques del nivel actual
  2452 00001651 E84FFFFFFF                  call get_current_level_blocks
  2453 00001656 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2454                                      
  2455                                      ; Obtener cantidad de bloques del nivel actual
  2456 00001659 E8A0FFFFFF                  call get_current_level_count
  2457 0000165E 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2458                                      
  2459 00001661 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2460                                      
  2461                                      .print_loop:
  2462 00001664 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2463 00001667 7D6F                            jge .end
  2464                                          
  2465                                          ; Verificar si el bloque está activo
  2466 00001669 490FB68424-                     movzx rax, byte [block_states + r12]
  2466 0000166E [37150000]         
  2467 00001672 4885C0                          test rax, rax
  2468 00001675 745C                            jz .next_block
  2469                                          
  2470                                          ; Obtener posición y tipo del bloque usando r13
  2471 00001677 4C89E0                          mov rax, r12
  2472 0000167A 486BC005                        imul rax, 5
  2473 0000167E 4C01E8                          add rax, r13
  2474 00001681 448A00                          mov r8b, [rax]        ; X position
  2475 00001684 448A4801                        mov r9b, [rax + 1]    ; Y position
  2476 00001688 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2477                                  
  2478                                          ; El resto de la lógica de impresión permanece igual
  2479 0000168C 4D0FB6C0                        movzx r8, r8b
  2480 00001690 4D0FB6C9                        movzx r9, r9b
  2481 00001694 4981C0[000A0000]                add r8, board
  2482 0000169B B850000000                      mov rax, column_cells + 2
  2483 000016A0 49F7E1                          mul r9
  2484 000016A3 4901C0                          add r8, rax
  2485                                          
  2486 000016A6 B906000000                      mov rcx, block_length
  2487 000016AB 48BE-                           mov rsi, block_type_1
  2487 000016AD [D514000000000000] 
  2488 000016B5 490FB6C2                        movzx rax, r10b
  2489 000016B9 48FFC8                          dec rax
  2490 000016BC 486BC006                        imul rax, block_length
  2491 000016C0 4801C6                          add rsi, rax
  2492                                          
  2493                                      .print_block_chars:
  2494 000016C3 8A06                            mov al, [rsi]
  2495 000016C5 418800                          mov [r8], al
  2496 000016C8 48FFC6                          inc rsi
  2497 000016CB 49FFC0                          inc r8
  2498 000016CE 48FFC9                          dec rcx
  2499 000016D1 75F0                            jnz .print_block_chars
  2500                                          
  2501                                      .next_block:
  2502 000016D3 49FFC4                          inc r12
  2503 000016D6 EB8C                            jmp .print_loop
  2504                                          
  2505                                      .end:
  2506 000016D8 5D                              pop rbp
  2507 000016D9 C3                              ret
  2508                                  
  2509                                  ; Función para convertir número a string
  2510                                  ; Input: RAX = número a convertir
  2511                                  ; RDI = buffer donde escribir el string
  2512                                  number_to_string:
  2513 000016DA 53                          push rbx
  2514 000016DB 52                          push rdx
  2515 000016DC 56                          push rsi
  2516 000016DD BB0A000000                  mov rbx, 10          ; Divisor
  2517 000016E2 B900000000                  mov rcx, 0          ; Contador de dígitos
  2518                                      
  2519                                      ; Si el número es 0, manejarlo especialmente
  2520 000016E7 4885C0                      test rax, rax
  2521 000016EA 7509                        jnz .convert_loop
  2522 000016EC C60730                      mov byte [rdi], '0'
  2523 000016EF C6470100                    mov byte [rdi + 1], 0
  2524 000016F3 EB20                        jmp .end
  2525                                      
  2526                                      .convert_loop:
  2527 000016F5 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2528 000016F8 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2529 000016FB 80C230                          add dl, '0'     ; Convertir a ASCII
  2530 000016FE 52                              push rdx        ; Guardar el dígito
  2531 000016FF 48FFC1                          inc rcx         ; Incrementar contador
  2532 00001702 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2533 00001705 75EE                            jnz .convert_loop
  2534                                          
  2535                                      .write_loop:
  2536 00001707 5A                              pop rdx         ; Obtener dígito
  2537 00001708 8817                            mov [rdi], dl   ; Escribir al buffer
  2538 0000170A 48FFC7                          inc rdi         ; Siguiente posición
  2539 0000170D 48FFC9                          dec rcx         ; Decrementar contador
  2540 00001710 75F5                            jnz .write_loop
  2541                                          
  2542 00001712 C60700                      mov byte [rdi], 0   ; Null terminator
  2543                                      
  2544                                      .end:
  2545 00001715 5E                          pop rsi
  2546 00001716 5A                          pop rdx
  2547 00001717 5B                          pop rbx
  2548 00001718 C3                          ret
  2549                                  
  2550                                  ; Función para imprimir los labels
  2551                                  print_labels:
  2552 00001719 55                          push rbp
  2553 0000171A 4889E5                      mov rbp, rsp
  2554                                  
  2555                                      ; Crear buffer temporal
  2556 0000171D 4883EC20                    sub rsp, 32
  2557                                  
  2558                                      ; Copiar labels a buffer temporal
  2559 00001721 4889E7                      mov rdi, rsp
  2560 00001724 488D35(50160000)            lea rsi, [score_label]
  2561 0000172B B917000000                  mov rcx, score_label_len
  2562 00001730 F3A4                        rep movsb
  2563                                  
  2564                                      ; Convertir score a string
  2565 00001732 488B05(9B150000)            mov rax, [current_score]
  2566 00001739 48BF-                       mov rdi, number_buffer
  2566 0000173B [A415000000000000] 
  2567 00001743 E892FFFFFF                  call number_to_string
  2568                                  
  2569                                      ; Calcular longitud del número
  2570 00001748 B900000000                  mov rcx, 0
  2571 0000174D 48BF-                       mov rdi, number_buffer
  2571 0000174F [A415000000000000] 
  2572                                      .count_loop:
  2573 00001757 803C0F00                        cmp byte [rdi + rcx], 0
  2574 0000175B 7405                            je .count_done
  2575 0000175D 48FFC1                          inc rcx
  2576 00001760 EBF5                            jmp .count_loop
  2577                                      .count_done:
  2578                                  
  2579                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2580 00001762 4889E7                      mov rdi, rsp
  2581 00001765 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2582 00001769 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2583 0000176E 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2584                                      .pad_loop:
  2585 00001771 4885F6                          test rsi, rsi
  2586 00001774 740B                            jz .pad_done
  2587 00001776 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2588 00001779 48FFC7                          inc rdi
  2589 0000177C 48FFCE                          dec rsi
  2590 0000177F EBF0                            jmp .pad_loop
  2591                                      .pad_done:
  2592                                  
  2593                                      ; Copiar el número
  2594 00001781 48BE-                       mov rsi, number_buffer
  2594 00001783 [A415000000000000] 
  2595 0000178B F3A4                        rep movsb
  2596                                  
  2597                                      ; Imprimir el buffer completo
  2598                                      print rsp, score_label_len
    82 0000178D B801000000          <1>  mov eax, sys_write
    83 00001792 BF01000000          <1>  mov edi, 1
    84 00001797 4889E6              <1>  mov rsi, %1
    85 0000179A BA17000000          <1>  mov edx, %2
    86 0000179F 0F05                <1>  syscall
  2599                                  
  2600                                      ; Repetir proceso para bloques destruidos
  2601 000017A1 4889E7                      mov rdi, rsp
  2602 000017A4 488D35(67160000)            lea rsi, [blocks_label]
  2603 000017AB B91B000000                  mov rcx, blocks_label_len
  2604 000017B0 F3A4                        rep movsb
  2605                                  
  2606                                      ; Verificar que el `[` esté en su posición correcta
  2607 000017B2 4889E7                      mov rdi, rsp
  2608 000017B5 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2609 000017B9 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2610                                  
  2611                                      ; Convertir bloques destruidos a string
  2612 000017BC 480FB605(A3150000)          movzx rax, byte [destroyed_blocks]
  2613 000017C4 48BF-                       mov rdi, number_buffer
  2613 000017C6 [A415000000000000] 
  2614 000017CE E807FFFFFF                  call number_to_string
  2615                                  
  2616                                      ; Calcular longitud del número
  2617 000017D3 B900000000                  mov rcx, 0
  2618 000017D8 48BF-                       mov rdi, number_buffer
  2618 000017DA [A415000000000000] 
  2619                                      .count_loop2:
  2620 000017E2 803C0F00                        cmp byte [rdi + rcx], 0
  2621 000017E6 7405                            je .count_done2
  2622 000017E8 48FFC1                          inc rcx
  2623 000017EB EBF5                            jmp .count_loop2
  2624                                      .count_done2:
  2625                                  
  2626                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2627 000017ED 4889E7                      mov rdi, rsp
  2628 000017F0 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2629 000017F4 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2630 000017F9 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2631                                      .pad_loop2:
  2632 000017FC 4885F6                          test rsi, rsi
  2633 000017FF 740B                            jz .pad_done2
  2634 00001801 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2635 00001804 48FFC7                          inc rdi
  2636 00001807 48FFCE                          dec rsi
  2637 0000180A EBF0                            jmp .pad_loop2
  2638                                      .pad_done2:
  2639                                  
  2640                                      ; Copiar el número
  2641 0000180C 48BE-                       mov rsi, number_buffer
  2641 0000180E [A415000000000000] 
  2642 00001816 F3A4                        rep movsb
  2643                                  
  2644                                      ; Imprimir el buffer completo
  2645                                      print rsp, blocks_label_len
    82 00001818 B801000000          <1>  mov eax, sys_write
    83 0000181D BF01000000          <1>  mov edi, 1
    84 00001822 4889E6              <1>  mov rsi, %1
    85 00001825 BA1B000000          <1>  mov edx, %2
    86 0000182A 0F05                <1>  syscall
  2646                                  
  2647                                      ; Restaurar stack
  2648 0000182C 4883C420                    add rsp, 32
  2649 00001830 5D                          pop rbp
  2650 00001831 C3                          ret
  2651                                  
  2652                                  
  2653                                  
  2654                                  check_block_collision:
  2655 00001832 55                          push rbp
  2656 00001833 4889E5                      mov rbp, rsp
  2657                                  
  2658                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2659 00001836 418A02                      mov al, [r10]
  2660                                  
  2661                                      ; Verificar si el carácter es un bloque
  2662 00001839 3C55                        cmp al, 'U'  
  2663 0000183B 7419                        je .possible
  2664 0000183D 3C4F                        cmp al, 'O'  
  2665 0000183F 7415                        je .possible
  2666 00001841 3C44                        cmp al, 'D'  
  2667 00001843 7411                        je .possible
  2668 00001845 3C4C                        cmp al, 'L'  
  2669 00001847 740D                        je .possible
  2670 00001849 3C56                        cmp al, 'V'  
  2671 0000184B 7409                        je .possible
  2672 0000184D 3C38                        cmp al, '8'  
  2673 0000184F 7405                        je .possible
  2674                                  
  2675                                      ; No es bloque, salir
  2676 00001851 4831C0                      xor rax, rax
  2677 00001854 5D                          pop rbp
  2678 00001855 C3                          ret
  2679                                  
  2680                                  .possible:
  2681 00001856 53                          push rbx
  2682 00001857 57                          push rdi
  2683 00001858 56                          push rsi
  2684 00001859 4154                        push r12
  2685 0000185B 4155                        push r13
  2686 0000185D 4156                        push r14
  2687 0000185F 4157                        push r15
  2688                                  
  2689                                      ; 1) Obtener base de los bloques del nivel actual
  2690 00001861 E83FFDFFFF                  call get_current_level_blocks
  2691 00001866 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2692                                  
  2693                                      ; 2) Obtener la cantidad de bloques
  2694 00001869 E890FDFFFF                  call get_current_level_count
  2695 0000186E 4989C6                      mov r14, rax
  2696                                  
  2697 00001871 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2698                                  
  2699                                  .find_block_loop:
  2700 00001874 4D39F4                      cmp r12, r14
  2701 00001877 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2702                                  
  2703                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2704 0000187D 4C89E0                      mov rax, r12
  2705 00001880 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2706 00001884 4C01E8                      add rax, r13
  2707 00001887 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2708                                  
  2709                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2710 0000188A 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2710 0000188F [37150000]         
  2711 00001893 4885DB                      test rbx, rbx
  2712 00001896 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2713                                  
  2714                                      ; Obtener coordenadas
  2715 0000189C 418A17                      mov dl, [r15]         ; x
  2716 0000189F 418A4F01                    mov cl, [r15 + 1]     ; y
  2717                                  
  2718                                      ; Calcular posición en el board
  2719 000018A3 488D3D(000A0000)            lea rdi, [board]
  2720 000018AA 4831C0                      xor rax, rax
  2721 000018AD B84E000000                  mov rax, column_cells
  2722 000018B2 4883C002                    add rax, 2
  2723 000018B6 480FB6C9                    movzx rcx, cl         ; y
  2724 000018BA 480FAFC1                    imul rax, rcx
  2725 000018BE 4801C7                      add rdi, rax
  2726 000018C1 480FB6C2                    movzx rax, dl         ; x
  2727 000018C5 4801C7                      add rdi, rax
  2728                                  
  2729                                      ; Guardar la posición base del bloque
  2730 000018C8 57                          push rdi
  2731                                  
  2732                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2733 000018C9 4939FA                      cmp r10, rdi
  2734 000018CC 7274                        jb .skip_collision
  2735 000018CE 488D5F06                    lea rbx, [rdi + block_length]
  2736 000018D2 4939DA                      cmp r10, rbx
  2737 000018D5 736B                        jae .skip_collision
  2738                                  
  2739                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2740 000018D7 41FE8C24[37150000]          dec byte [block_states + r12]
  2741                                      ; Volver a cargar durabilidad
  2742 000018DF 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2742 000018E4 [37150000]         
  2743 000018E8 4885DB                      test rbx, rbx
  2744 000018EB 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2745                                  
  2746                                      ; >>> Llegó a 0 => Bloque destruido
  2747 000018ED 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2748 000018EE B906000000                  mov rcx, block_length
  2749                                  .clear_loop:
  2750 000018F3 C60720                      mov byte [rdi], ' '
  2751 000018F6 48FFC7                      inc rdi
  2752 000018F9 E2F8                        loop .clear_loop
  2753                                  
  2754                                      ; Dibujar letra del bloque destruido
  2755 000018FB 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2756 000018FF 4883EF06                    sub rdi, block_length
  2757 00001903 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2758                                      ; Después de escribir la letra en el tablero
  2759 00001905 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2760 00001909 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2761 0000190D 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2762 00001912 E852EBFFFF                  call register_letter
  2763                                      ; Actualizar contadores globales
  2764 00001917 FE0D(FA140000)              dec byte [blocks_remaining]
  2765 0000191D FE05(A3150000)              inc byte [destroyed_blocks]
  2766                                  
  2767                                      ; Sumar puntos según el tipo
  2768 00001923 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2769 00001928 486BC00A                    imul rax, 10
  2770 0000192C 480105(9B150000)            add [current_score], rax
  2771                                  
  2772 00001933 B801000000                  mov rax, 1  ; colisión con destrucción
  2773 00001938 EB14                        jmp .end_pop
  2774                                  
  2775                                  .update_display:
  2776                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2777 0000193A B801000000                  mov rax, 1  ; colisión con "rebote"  
  2778 0000193F 5F                          pop rdi     ; pop que quedó pendiente
  2779 00001940 EB0C                        jmp .end_pop
  2780                                  
  2781                                  .skip_collision:
  2782 00001942 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2783                                  .next_block:
  2784 00001943 49FFC4                      inc r12
  2785 00001946 E929FFFFFF                  jmp .find_block_loop
  2786                                  
  2787                                  .no_block_found:
  2788 0000194B 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2789                                  
  2790                                  .end_pop:
  2791 0000194E 415F                        pop r15
  2792 00001950 415E                        pop r14
  2793 00001952 415D                        pop r13
  2794 00001954 415C                        pop r12
  2795 00001956 5E                          pop rsi
  2796 00001957 5F                          pop rdi
  2797 00001958 5B                          pop rbx
  2798 00001959 5D                          pop rbp
  2799 0000195A C3                          ret
  2800                                  
  2801                                  
  2802                                  
  2803                                  init_enemies:
  2804 0000195B 55                          push rbp
  2805 0000195C 4889E5                      mov rbp, rsp
  2806                                      ; Reiniciar contadores de movimiento
  2807 0000195F C605(E6150000)00            mov byte [enemy_move_total], 0
  2808 00001966 C605(E7150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2809                                      ; Limpiar estado previo de enemigos
  2810 0000196D B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2811 00001972 488D3D(BD150000)            lea rdi, [enemies]
  2812 00001979 30C0                        xor al, al
  2813 0000197B F3AA                        rep stosb ; Limpiar datos de enemigos
  2814                                      
  2815                                      ; Marcar todos los enemigos como inactivos
  2816 0000197D 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2817 00001984 30C0                        xor al, al
  2818 00001986 B90A000000                  mov rcx, 10
  2819 0000198B F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2820                                  
  2821 0000198D 5D                          pop rbp
  2822 0000198E C3                          ret
  2823                                  
  2824                                  
  2825                                  ; Función para mover enemigos
  2826                                  move_enemies:
  2827 0000198F 55                          push rbp
  2828 00001990 4889E5                      mov rbp, rsp
  2829                                      
  2830                                      ; Incrementar contador de movimiento
  2831 00001993 FE05(E4150000)              inc byte [enemy_move_counter]
  2832 00001999 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2833 000019A1 3A05(E5150000)              cmp al, [enemy_move_delay]
  2834 000019A7 0F85AA010000                jne .end
  2835                                      
  2836                                      ; Resetear contador
  2837 000019AD C605(E4150000)00            mov byte [enemy_move_counter], 0
  2838                                      
  2839 000019B4 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2840                                      
  2841                                      .enemy_loop:
  2842 000019B7 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2843 000019BB 0F8D96010000                    jge .end
  2844                                          
  2845                                          ; Calcular offset del enemigo actual
  2846 000019C1 4C89E0                          mov rax, r12
  2847 000019C4 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2848 000019C8 488DB0[BD150000]                lea rsi, [enemies + rax]
  2849                                          
  2850                                          ; Verificar si el enemigo está activo
  2851 000019CF 807E0201                        cmp byte [rsi + 2], 1
  2852 000019D3 0F8576010000                    jne .next_enemy
  2853                                          
  2854                                          ; Obtener posición actual
  2855 000019D9 4C0FB606                        movzx r8, byte [rsi]            ; X
  2856 000019DD 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2857                                          
  2858                                          ; Limpiar posición actual antes de mover
  2859 000019E2 4150                            push r8
  2860 000019E4 4151                            push r9
  2861 000019E6 B84E000000                      mov rax, column_cells
  2862 000019EB 4883C002                        add rax, 2
  2863 000019EF 49F7E1                          mul r9
  2864 000019F2 4C01C0                          add rax, r8
  2865 000019F5 488DB8[000A0000]                lea rdi, [board + rax]
  2866 000019FC C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2867 000019FF 4159                            pop r9
  2868 00001A01 4158                            pop r8
  2869                                  
  2870                                          ; Determinar comportamiento basado en índice
  2871 00001A03 4C89E0                          mov rax, r12
  2872 00001A06 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2873 00001A0A 4885C0                          test rax, rax
  2874 00001A0D 7402                            jz .chase_ball
  2875 00001A0F EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2876                                          
  2877                                          ; Perseguir bola (comportamiento original)
  2878                                      .chase_ball:
  2879 00001A11 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2880 00001A18 4D39D0                          cmp r8, r10
  2881 00001A1B 0F8F96000000                    jg .move_left
  2882 00001A21 0F8C95000000                    jl .move_right
  2883                                          
  2884 00001A27 4C8B15(67140000)                mov r10, [ball_y_pos]
  2885 00001A2E 4D39D1                          cmp r9, r10
  2886 00001A31 0F8F8A000000                    jg .move_up
  2887 00001A37 0F8C89000000                    jl .move_down
  2888 00001A3D E9A5000000                      jmp .check_collision
  2889                                          
  2890                                      .chase_paddle:
  2891                                          ; Obtener la posición X actual de la paleta
  2892 00001A42 4C8B15(3F140000)                mov r10, [pallet_position]
  2893 00001A49 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2894                                          
  2895                                          ; Calcular la posición X real de la paleta
  2896 00001A50 4C89D0                          mov rax, r10
  2897 00001A53 BB4E000000                      mov rbx, column_cells
  2898 00001A58 4883C302                        add rbx, 2                  ; Añadir newline chars
  2899 00001A5C 4831D2                          xor rdx, rdx
  2900 00001A5F 48F7F3                          div rbx                     ; rax = y, rdx = x
  2901                                          
  2902                                          ; rdx ahora contiene la posición X de la paleta
  2903                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2904 00001A62 488B0D(47140000)                mov rcx, [pallet_size]
  2905 00001A69 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2906 00001A6C 4801CA                          add rdx, rcx
  2907                                          
  2908                                          ; Comparar con posición X del enemigo y mover gradualmente
  2909 00001A6F 4939D0                          cmp r8, rdx
  2910 00001A72 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2911 00001A74 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2912 00001A76 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2913                                  
  2914                                      .check_y_paddle:
  2915                                          ; La Y de la paleta siempre es row_cells - 2
  2916 00001A78 41BA20000000                    mov r10, row_cells
  2917 00001A7E 4983EA02                        sub r10, 2
  2918                                          
  2919                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2920 00001A82 4D39D1                          cmp r9, r10
  2921 00001A85 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2922 00001A87 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2923 00001A89 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2924                                          
  2925                                      .no_movement:
  2926 00001A8B EB5A                            jmp .check_collision
  2927                                  
  2928                                      ; También agregar una nueva sección para el movimiento suave
  2929                                      .smooth_transition:
  2930                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2931 00001A8D 8A05(E7150000)                  mov al, [enemy_target]
  2932 00001A93 84C0                            test al, al
  2933 00001A95 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2934                                          
  2935                                          ; Verificar distancia en X
  2936 00001A97 4989D2                          mov r10, rdx              ; Posición X objetivo
  2937 00001A9A 4D29C2                          sub r10, r8               ; Calcular diferencia
  2938 00001A9D 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2939 00001AA1 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2940 00001AA3 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2941 00001AA7 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2942 00001AA9 EB3C                            jmp .check_collision
  2943                                          
  2944                                      .limit_right_movement:
  2945 00001AAB 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2946 00001AAF EB36                            jmp .check_collision
  2947                                          
  2948                                      .limit_left_movement:
  2949 00001AB1 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2950 00001AB5 EB30                            jmp .check_collision
  2951                                      .move_left:
  2952 00001AB7 49FFC8                          dec r8
  2953 00001ABA EB0F                            jmp .check_vertical
  2954                                          
  2955                                      .move_right:
  2956 00001ABC 49FFC0                          inc r8
  2957 00001ABF EB0A                            jmp .check_vertical
  2958                                          
  2959                                      .move_up:
  2960 00001AC1 49FFC9                          dec r9
  2961 00001AC4 EB21                            jmp .check_collision
  2962                                          
  2963                                      .move_down:
  2964 00001AC6 49FFC1                          inc r9
  2965 00001AC9 EB1C                            jmp .check_collision
  2966                                          
  2967                                      .check_vertical:
  2968 00001ACB 8A05(E7150000)                  mov al, [enemy_target]
  2969 00001AD1 84C0                            test al, al
  2970 00001AD3 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2971 00001AD9 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2972 00001AE0 4D39D1                          cmp r9, r10
  2973 00001AE3 7FDC                            jg .move_up
  2974 00001AE5 7CDF                            jl .move_down
  2975                                          
  2976                                      .check_collision:
  2977                                          ; Verificar colisión con bordes
  2978 00001AE7 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2979 00001AEB 7E62                            jle .next_enemy
  2980 00001AED 4983F84E                        cmp r8, column_cells
  2981 00001AF1 7D5C                            jge .next_enemy
  2982 00001AF3 4983F901                        cmp r9, 1                       ; Borde superior
  2983 00001AF7 7E56                            jle .next_enemy
  2984 00001AF9 4983F920                        cmp r9, row_cells
  2985 00001AFD 7D50                            jge .next_enemy
  2986                                          
  2987                                          ; Verificar colisión con bloques antes de moverse
  2988 00001AFF 4150                            push r8
  2989 00001B01 4151                            push r9
  2990 00001B03 4152                            push r10
  2991                                          
  2992                                          ; Calcular posición en el tablero para verificar
  2993 00001B05 B84E000000                      mov rax, column_cells
  2994 00001B0A 4883C002                        add rax, 2
  2995 00001B0E 49F7E1                          mul r9
  2996 00001B11 4C01C0                          add rax, r8
  2997 00001B14 4C8D90[000A0000]                lea r10, [board + rax]
  2998                                          
  2999                                          ; Verificar si hay un bloque en la nueva posición
  3000 00001B1B 418A02                          mov al, [r10]
  3001 00001B1E 3C55                            cmp al, 'U'
  3002 00001B20 7427                            je .invalid_move
  3003 00001B22 3C4F                            cmp al, 'O'
  3004 00001B24 7423                            je .invalid_move
  3005 00001B26 3C44                            cmp al, 'D'
  3006 00001B28 741F                            je .invalid_move
  3007 00001B2A 3C4C                            cmp al, 'L'
  3008 00001B2C 741B                            je .invalid_move
  3009 00001B2E 3C56                            cmp al, 'V'
  3010 00001B30 7417                            je .invalid_move
  3011 00001B32 3C38                            cmp al, '8'
  3012 00001B34 7413                            je .invalid_move
  3013 00001B36 3C58                            cmp al, 'X'
  3014 00001B38 740F                            je .invalid_move
  3015                                          
  3016 00001B3A 415A                            pop r10
  3017 00001B3C 4159                            pop r9
  3018 00001B3E 4158                            pop r8
  3019                                          
  3020                                          ; Guardar nueva posición si es válida
  3021 00001B40 448806                          mov [rsi], r8b
  3022 00001B43 44884E01                        mov [rsi + 1], r9b
  3023 00001B47 EB06                            jmp .next_enemy
  3024                                          
  3025                                      .invalid_move:
  3026 00001B49 415A                            pop r10
  3027 00001B4B 4159                            pop r9
  3028 00001B4D 4158                            pop r8
  3029                                          
  3030                                      .next_enemy:
  3031 00001B4F 49FFC4                          inc r12
  3032 00001B52 E960FEFFFF                      jmp .enemy_loop
  3033                                          
  3034                                      .end:
  3035 00001B57 5D                              pop rbp
  3036 00001B58 C3                              ret
  3037                                  
  3038                                  get_current_spawn_points:
  3039 00001B59 55                          push rbp
  3040 00001B5A 4889E5                      mov rbp, rsp
  3041                                      
  3042 00001B5D 480FB605(F9140000)          movzx rax, byte [current_level]
  3043 00001B65 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3044 00001B68 488B04C5[1B160000]          mov rax, [spawn_points_table + rax * 8]
  3045                                      
  3046 00001B70 5D                          pop rbp
  3047 00001B71 C3                          ret
  3048                                  
  3049                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3050                                  check_enemy_spawn:
  3051 00001B72 55                          push rbp
  3052 00001B73 4889E5                      mov rbp, rsp
  3053                                      
  3054                                      ; Obtener spawn points del nivel actual
  3055 00001B76 E8DEFFFFFF                  call get_current_spawn_points
  3056 00001B7B 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3057                                      
  3058                                      ; Obtener cantidad de bloques destruidos
  3059 00001B7E 4C0FB62D(A3150000)          movzx r13, byte [destroyed_blocks]
  3060                                      
  3061                                      ; Verificar cada punto de spawn
  3062 00001B86 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3063                                      
  3064                                      .check_loop:
  3065 00001B89 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3066 00001B8D 7D4B                            jge .end
  3067                                          
  3068                                          ; Verificar si este spawn point ya fue usado
  3069 00001B8F 80B9[46160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3070 00001B96 743D                            je .next_enemy
  3071                                          
  3072                                          ; Verificar si este enemigo ya está activo
  3073 00001B98 4889C8                          mov rax, rcx
  3074 00001B9B 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3075 00001B9F 488DB0[BD150000]                lea rsi, [enemies + rax]
  3076 00001BA6 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3077 00001BAA 7429                            je .next_enemy
  3078                                          
  3079                                          ; Verificar si debemos spawnear este enemigo
  3080 00001BAC 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3081 00001BB1 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3082 00001BB4 751F                            jne .next_enemy
  3083                                          
  3084                                          ; Marcar este spawn point como usado
  3085 00001BB6 C681[46160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3086                                          
  3087                                          ; Spawner nuevo enemigo
  3088 00001BBD C60628                          mov byte [rsi], 40             ; X inicial
  3089 00001BC0 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  3090 00001BC4 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  3091                                          
  3092                                          ; Inicializar comportamiento
  3093 00001BC8 4889C8                          mov rax, rcx
  3094 00001BCB 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3095 00001BCF 8805(45160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3096                                          
  3097                                      .next_enemy:
  3098 00001BD5 48FFC1                          inc rcx
  3099 00001BD8 EBAF                            jmp .check_loop
  3100                                          
  3101                                      .end:
  3102 00001BDA 5D                              pop rbp
  3103 00001BDB C3                              ret
  3104                                  
  3105                                  
  3106                                  ; Función para dibujar enemigos
  3107                                  print_enemies:
  3108 00001BDC 55                          push rbp
  3109 00001BDD 4889E5                      mov rbp, rsp
  3110                                      
  3111 00001BE0 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3112                                      
  3113                                      .print_loop:
  3114 00001BE3 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3115 00001BE7 7D4B                            jge .end
  3116                                          
  3117                                          ; Calcular offset del enemigo actual
  3118 00001BE9 4C89E0                          mov rax, r12
  3119 00001BEC 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3120 00001BF0 488DB0[BD150000]                lea rsi, [enemies + rax]
  3121                                          
  3122                                          ; Verificar si el enemigo está activo
  3123 00001BF7 807E0201                        cmp byte [rsi + 2], 1
  3124 00001BFB 7532                            jne .next_enemy
  3125                                          
  3126                                          ; Calcular posición en el tablero
  3127 00001BFD 4C0FB606                        movzx r8, byte [rsi]            ; X
  3128 00001C01 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3129                                          
  3130                                          ; Calcular offset en el tablero
  3131 00001C06 B84E000000                      mov rax, column_cells
  3132 00001C0B 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3133 00001C0F 49F7E1                          mul r9
  3134 00001C12 4C01C0                          add rax, r8
  3135 00001C15 488DB8[000A0000]                lea rdi, [board + rax]
  3136                                          
  3137                                          ; Obtener carácter del enemigo según el nivel
  3138 00001C1C 480FB605(F9140000)              movzx rax, byte [current_level]
  3139 00001C24 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3140 00001C27 8A80[B8150000]                  mov al, [enemy_chars + rax]
  3141                                          
  3142                                          ; Dibujar enemigo
  3143 00001C2D 8807                            mov [rdi], al
  3144                                          
  3145                                      .next_enemy:
  3146 00001C2F 49FFC4                          inc r12
  3147 00001C32 EBAF                            jmp .print_loop
  3148                                          
  3149                                      .end:
  3150 00001C34 5D                              pop rbp
  3151 00001C35 C3                              ret
  3152                                  
  3153                                  ; Función para verificar colisión con enemigos
  3154                                  ; Función para verificar colisión con enemigos
  3155                                  check_enemy_collision:
  3156 00001C36 55                          push rbp
  3157 00001C37 4889E5                      mov rbp, rsp
  3158                                      
  3159 00001C3A 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3160 00001C3D 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3161                                      
  3162                                      .check_loop:
  3163 00001C40 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3164 00001C44 0F8DE9000000                    jge .end
  3165                                          
  3166                                          ; Calcular offset del enemigo actual
  3167 00001C4A 4C89E1                          mov rcx, r12
  3168 00001C4D 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3169 00001C51 488DB1[BD150000]                lea rsi, [enemies + rcx]
  3170                                          
  3171                                          ; Verificar si el enemigo está activo
  3172 00001C58 807E0201                        cmp byte [rsi + 2], 1
  3173 00001C5C 0F85C9000000                    jne .next_enemy
  3174                                          
  3175                                          ; Verificar colisión con la bola
  3176 00001C62 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3177 00001C66 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3178                                          
  3179                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3180 00001C6B 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3181 00001C72 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3182                                          
  3183                                          ; Comprobar colisión vertical (misma columna)
  3184 00001C79 4D39C2                          cmp r10, r8
  3185 00001C7C 7525                            jne .check_horizontal
  3186 00001C7E 4D29CB                          sub r11, r9
  3187 00001C81 4983FB01                        cmp r11, 1
  3188 00001C85 7F1C                            jg .check_horizontal
  3189 00001C87 4983FBFF                        cmp r11, -1
  3190 00001C8B 7C16                            jl .check_horizontal
  3191                                          
  3192                                          ; Colisión vertical detectada
  3193 00001C8D E8A3000000                      call destroy_enemy
  3194 00001C92 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3195 00001C99 B801000000                      mov rax, 1
  3196 00001C9E E990000000                      jmp .end
  3197                                          
  3198                                      .check_horizontal:
  3199                                          ; Comprobar colisión horizontal (misma fila)
  3200 00001CA3 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3201 00001CAA 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3202 00001CB1 4D39CB                          cmp r11, r9
  3203 00001CB4 7522                            jne .check_paddle
  3204 00001CB6 4D29C2                          sub r10, r8
  3205 00001CB9 4983FA01                        cmp r10, 1
  3206 00001CBD 7F19                            jg .check_paddle
  3207 00001CBF 4983FAFF                        cmp r10, -1
  3208 00001CC3 7C13                            jl .check_paddle
  3209                                          
  3210                                          ; Colisión horizontal detectada
  3211 00001CC5 E86B000000                      call destroy_enemy
  3212 00001CCA 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3213 00001CD1 B801000000                      mov rax, 1
  3214 00001CD6 EB5B                            jmp .end
  3215                                          
  3216                                      .check_paddle:
  3217                                          ; Verificar colisión con la paleta
  3218 00001CD8 4C8B15(3F140000)                mov r10, [pallet_position]
  3219 00001CDF 4981EA[000A0000]                sub r10, board
  3220 00001CE6 4C89D0                          mov rax, r10
  3221 00001CE9 41BB4E000000                    mov r11, column_cells
  3222 00001CEF 4983C302                        add r11, 2
  3223 00001CF3 4831D2                          xor rdx, rdx
  3224 00001CF6 49F7F3                          div r11                     ; División para obtener la posición Y
  3225 00001CF9 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3226                                          
  3227 00001CFC 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3228                                          
  3229                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3230 00001D03 41BD20000000                    mov r13, row_cells
  3231 00001D09 4983ED02                        sub r13, 2                 ; Y de la paleta
  3232 00001D0D 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3233 00001D10 7519                            jne .next_enemy
  3234                                          
  3235                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3236 00001D12 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3237 00001D15 7C14                            jl .next_enemy
  3238                                          
  3239 00001D17 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3240 00001D1A 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3241 00001D1D 7F0C                            jg .next_enemy
  3242                                          
  3243                                          ; Si llegamos aquí, hay colisión con la paleta
  3244 00001D1F E811000000                      call destroy_enemy        ; Destruir el enemigo
  3245 00001D24 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3246 00001D29 EB08                            jmp .end
  3247                                          
  3248                                      .next_enemy:
  3249 00001D2B 49FFC4                          inc r12
  3250 00001D2E E90DFFFFFF                      jmp .check_loop
  3251                                          
  3252                                      .end:
  3253 00001D33 5D                              pop rbp
  3254 00001D34 C3                              ret
  3255                                  
  3256                                  ; Función para destruir un enemigo
  3257                                  destroy_enemy:
  3258                                      ; Desactivar enemigo
  3259 00001D35 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3260                                  
  3261                                      ; Sumar puntos por destruir enemigo
  3262 00001D39 488B05(DC150000)            mov rax, [enemy_points]
  3263 00001D40 480105(9B150000)            add [current_score], rax
  3264                                  
  3265                                      ; No tocar bloques destruidos aquí
  3266 00001D47 C3                          ret
  3267                                  
  3268                                  
  3269                                  _start:
  3270 00001D48 E8DEE3FFFF              	call canonical_off
  3271 00001D4D E853010000              	call start_screen
  3272 00001D52 E8ADF5FFFF                  call init_level
  3273 00001D57 E8FFFBFFFF                  call init_enemies
  3274 00001D5C EB00                    	jmp .main_loop
  3275                                  	
  3276                                  
  3277                                      .main_loop:
  3278 00001D5E E8B6F9FFFF                      call print_labels
  3279 00001D63 E8E5F8FFFF                      call print_blocks
  3280 00001D68 E8CDE7FFFF                      call move_letters
  3281 00001D6D E862EAFFFF                      call update_lasers
  3282 00001D72 E838E7FFFF                      call print_letters
  3283 00001D77 E803EEFFFF                      call print_pallet
  3284                                          
  3285                                          ; Mover bola principal solo si está activa
  3286 00001D7C 803D(80140000)01                cmp byte [ball_active], 1
  3287 00001D83 7505                            jne .skip_ball1
  3288 00001D85 E80DEFFFFF                          call move_ball
  3289                                          .skip_ball1:
  3290                                  
  3291                                          ; Mover bola 2 si está activa
  3292 00001D8A 803D(A2140000)01                cmp byte [ball2_active], 1
  3293 00001D91 7505                            jne .skip_ball2
  3294 00001D93 E8D2F0FFFF                          call move_ball_2
  3295                                          .skip_ball2:
  3296                                  
  3297                                          ; Mover bola 3 si está activa
  3298 00001D98 803D(C4140000)01                cmp byte [ball3_active], 1
  3299 00001D9F 7505                            jne .skip_ball3
  3300 00001DA1 E897F2FFFF                          call move_ball_3
  3301                                          .skip_ball3:
  3302                                  
  3303 00001DA6 E84BE5FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3304 00001DAB E82DE4FFFF                      call print_lives
  3305                                  
  3306                                          ; Imprimir solo las bolas activas
  3307 00001DB0 803D(80140000)01                cmp byte [ball_active], 1
  3308 00001DB7 7505                            jne .no_pb1
  3309 00001DB9 E849EDFFFF                          call print_ball
  3310                                          .no_pb1:
  3311                                  
  3312 00001DBE 803D(A2140000)01                cmp byte [ball2_active], 1
  3313 00001DC5 7505                            jne .no_pb2
  3314 00001DC7 E863EDFFFF                          call print_ball_2
  3315                                          .no_pb2:
  3316                                  
  3317 00001DCC 803D(C4140000)01                cmp byte [ball3_active], 1
  3318 00001DD3 7505                            jne .no_pb3
  3319 00001DD5 E87DEDFFFF                          call print_ball_3
  3320                                          .no_pb3:
  3321                                  
  3322 00001DDA E8D0F6FFFF                      call check_level_complete
  3323 00001DDF E88EFDFFFF                      call check_enemy_spawn
  3324 00001DE4 E8A6FBFFFF                      call move_enemies
  3325 00001DE9 E848FEFFFF                      call check_enemy_collision
  3326 00001DEE E8E9FDFFFF                      call print_enemies
  3327                                  		print board, board_size				
    82 00001DF3 B801000000          <1>  mov eax, sys_write
    83 00001DF8 BF01000000          <1>  mov edi, 1
    84 00001DFD 48BE-               <1>  mov rsi, %1
    84 00001DFF [000A000000000000]  <1>
    85 00001E07 BA000A0000          <1>  mov edx, %2
    86 00001E0C 0F05                <1>  syscall
  3328                                  		;setnonblocking	
  3329                                  	.read_more:	
  3330                                  	    getchar	
    90 00001E0E B800000000          <1>  mov rax, sys_read
    91 00001E13 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001E18 48BE-               <1>  mov rsi, input_char
    92 00001E1A [0000000000000000]  <1>
    93 00001E22 BA01000000          <1>  mov rdx, 1
    94 00001E27 0F05                <1>  syscall
  3331 00001E29 4883F801                	    cmp rax, 1
  3332 00001E2D 7543                    	    jne .done
  3333                                  	
  3334 00001E2F 8A05(00000000)          	    mov al, [input_char]
  3335 00001E35 8805(62180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3336                                  	
  3337 00001E3B 3C61                    	    cmp al, 'a'
  3338 00001E3D 750E                    	    jne .not_left
  3339 00001E3F 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3340 00001E46 E869EDFFFF              	    call move_pallet
  3341 00001E4B EB25                    	    jmp .done
  3342                                  	
  3343                                      .not_left:
  3344 00001E4D 3C64                    	    cmp al, 'd'
  3345 00001E4F 750C                    	    jne .not_right
  3346 00001E51 BF01000000              	    mov rdi, right_direction
  3347 00001E56 E859EDFFFF              	    call move_pallet
  3348 00001E5B EB15                    	    jmp .done
  3349                                  	
  3350                                      .not_right:
  3351 00001E5D 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3352 00001E5F 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3353                                  	
  3354 00001E61 3C71                    	    cmp al, 'q' 
  3355 00001E63 0F84AF000000            	    je exit
  3356 00001E69 EBA3                    	    jmp .read_more
  3357                                  	
  3358                                      .release_ball:
  3359 00001E6B E8A0F3FFFF              	    call process_catch_release
  3360 00001E70 EB00                    	    jmp .done
  3361                                  	
  3362                                      .done:
  3363                                  	    sleeptime
    98 00001E72 B823000000          <1>  mov eax, sys_nanosleep
    99 00001E77 48BF-               <1>  mov rdi, timespec
    99 00001E79 [0000000000000000]  <1>
   100 00001E81 31F6                <1>  xor esi, esi
   101 00001E83 0F05                <1>  syscall
  3364                                  	    print clear, clear_length
    82 00001E85 B801000000          <1>  mov eax, sys_write
    83 00001E8A BF01000000          <1>  mov edi, 1
    84 00001E8F 48BE-               <1>  mov rsi, %1
    84 00001E91 [1000000000000000]  <1>
    85 00001E99 BA07000000          <1>  mov edx, %2
    86 00001E9E 0F05                <1>  syscall
  3365 00001EA0 E9B9FEFFFF              	    jmp .main_loop
  3366                                  
  3367                                  
  3368                                  
  3369                                  
  3370                                  start_screen:
  3371                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001EA5 B801000000          <1>  mov eax, sys_write
    83 00001EAA BF01000000          <1>  mov edi, 1
    84 00001EAF 48BE-               <1>  mov rsi, %1
    84 00001EB1 [1000000000000000]  <1>
    85 00001EB9 BA07000000          <1>  mov edx, %2
    86 00001EBE 0F05                <1>  syscall
  3372                                      print msg1, msg1_length
    82 00001EC0 B801000000          <1>  mov eax, sys_write
    83 00001EC5 BF01000000          <1>  mov edi, 1
    84 00001ECA 48BE-               <1>  mov rsi, %1
    84 00001ECC [1700000000000000]  <1>
    85 00001ED4 BA14010000          <1>  mov edx, %2
    86 00001ED9 0F05                <1>  syscall
  3373                                      
  3374                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3375                                          getchar                 ; Esperamos una tecla
    90 00001EDB B800000000          <1>  mov rax, sys_read
    91 00001EE0 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001EE5 48BE-               <1>  mov rsi, input_char
    92 00001EE7 [0000000000000000]  <1>
    93 00001EEF BA01000000          <1>  mov rdx, 1
    94 00001EF4 0F05                <1>  syscall
  3376 00001EF6 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3377 00001EFA 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3378                                          
  3379                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001EFC B801000000          <1>  mov eax, sys_write
    83 00001F01 BF01000000          <1>  mov edi, 1
    84 00001F06 48BE-               <1>  mov rsi, %1
    84 00001F08 [1000000000000000]  <1>
    85 00001F10 BA07000000          <1>  mov edx, %2
    86 00001F15 0F05                <1>  syscall
  3380 00001F17 C3                          ret
  3381                                  
  3382                                  exit: 
  3383 00001F18 E850E2FFFF              	call canonical_on
  3384 00001F1D B83C000000              	mov    rax, 60
  3385 00001F22 BF00000000                  mov    rdi, 0
  3386 00001F27 0F05                        syscall
  3387                                  
