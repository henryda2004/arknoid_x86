     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 38070301                        db 56, 7, 3, 1    ; Bloque 7
   288 000014AA 14070301                        db 20, 7, 3, 1    ; Bloque 7
   289 000014AE 1E070301                        db 30, 7, 3, 1    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B2 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014B6 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BA 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014BE 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 00001526 0000000000000000            current_score dq 0          ; Score actual
   319 0000152E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 0000152F 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 00001543 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 00001548 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 00001566 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 00001567 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 0000156F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001570 01                          enemy_move_delay db 1           ; Mover enemigos cada N ciclos
   333 00001571 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001572 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 00001573 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 00001574 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 0000157D 12                 
   339 0000157E 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 00001587 13                 
   340 00001588 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001591 1B                 
   341 00001592 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 0000159B 1C                 
   342 0000159C 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015A5 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015A6 [7415000000000000]              dq level1_spawn_points
   346 000015AE [7E15000000000000]              dq level2_spawn_points
   347 000015B6 [8815000000000000]              dq level3_spawn_points
   348 000015BE [9215000000000000]              dq level4_spawn_points
   349 000015C6 [9C15000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015CE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015CF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D0 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D1 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015DB 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015E4 5B2020202020202020-
   357 000015ED 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F2 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 000015FB 657374727569646F73-
   359 00001604 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365                                      
   366                                      ; Definición de las vidas (x, y, estado)
   367                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   368                                      lives_data: 
   369 0000160D 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   370 00001610 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   371 00001613 061E00                          db 6, 30, 0     ; Vida 3 (inactiva)
   372 00001616 081E00                          db 8, 30, 0     ; Vida 4 (inactiva)
   373 00001619 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   374 0000161C 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   375 0000161F 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   376                                      lives_count equ 7    ; Total de vidas
   377 00001622 5E                          life_char db "^"    
   378                                  
   379                                  section .text
   380                                  
   381                                  ;	Function: print_ball
   382                                  ; This function displays the position of the ball
   383                                  ; Arguments: none
   384                                  ;
   385                                  ; Return:
   386                                  ;	Void
   387                                  
   388                                  ; Función para imprimir las vidas
   389                                  print_lives:
   390 000001DD 55                          push rbp
   391 000001DE 4889E5                      mov rbp, rsp
   392                                      
   393 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   394                                      
   395                                      .print_loop:
   396 000001E4 4983FC07                        cmp r12, lives_count
   397 000001E8 7D40                            jge .end
   398                                          
   399                                          ; Calcular offset de la vida actual
   400 000001EA 4C89E0                          mov rax, r12
   401 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   402 000001F1 488DB0[0D160000]                lea rsi, [lives_data + rax]
   403                                          
   404                                          ; Verificar si la vida está activa
   405 000001F8 807E0201                        cmp byte [rsi + 2], 1
   406 000001FC 7527                            jne .next_life
   407                                          
   408                                          ; Calcular posición en el tablero
   409 000001FE 4C0FB606                        movzx r8, byte [rsi]            ; X
   410 00000202 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   411                                          
   412                                          ; Calcular offset en el tablero
   413 00000207 B84E000000                      mov rax, column_cells
   414 0000020C 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   415 00000210 49F7E1                          mul r9
   416 00000213 4C01C0                          add rax, r8
   417 00000216 488DB8[000A0000]                lea rdi, [board + rax]
   418                                          
   419                                          ; Dibujar vida
   420 0000021D 8A05(22160000)                  mov al, [life_char]
   421 00000223 8807                            mov [rdi], al
   422                                          
   423                                      .next_life:
   424 00000225 49FFC4                          inc r12
   425 00000228 EBBA                            jmp .print_loop
   426                                          
   427                                      .end:
   428 0000022A 5D                              pop rbp
   429 0000022B C3                              ret
   430                                  
   431                                  
   432                                  print_ball:
   433 0000022C 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   434 00000233 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   435 0000023A 4981C0[000A0000]        	add r8, board
   436                                  
   437 00000241 4C89C9                  	mov rcx, r9
   438 00000244 B850000000              	mov rax, column_cells + 2
   439 00000249 48F7E9                  	imul rcx
   440                                  	
   441 0000024C 4901C0                  	add r8, rax
   442 0000024F 41C6004F                	mov byte [r8], char_O
   443 00000253 C3                      	ret
   444                                  
   445                                  	
   446                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   447                                  	
   448                                  
   449                                  
   450                                  
   451                                  ;	Function: print_pallet
   452                                  ; This function moves the pallet in the game
   453                                  ; Arguments: none
   454                                  ;
   455                                  ; Return;
   456                                  ;	void
   457                                  print_pallet:
   458 00000254 4C8B05(3F140000)        	mov r8, [pallet_position]
   459 0000025B 488B0D(47140000)        	mov rcx, [pallet_size]
   460                                  	.write_pallet:
   461 00000262 41C6003D                		mov byte [r8], char_equal
   462 00000266 49FFC0                  		inc r8
   463 00000269 48FFC9                  		dec rcx
   464 0000026C 75F4                    		jnz .write_pallet
   465                                  
   466 0000026E C3                      	ret
   467                                  	
   468                                  ;	Function: move_pallet
   469                                  ; This function is in charge of moving the pallet in a given direction
   470                                  ; Arguments:
   471                                  ;	rdi: left direction or right direction
   472                                  ;
   473                                  ; Return:
   474                                  ;	void
   475                                  move_pallet:
   476                                      
   477 0000026F 803D(6F140000)00            cmp byte [ball_moving], 0
   478 00000276 7507                        jne .continue_movement
   479 00000278 C605(6F140000)01            mov byte [ball_moving], 1
   480                                  
   481                                      .continue_movement:
   482 0000027F 4883FFFF                        cmp rdi, left_direction
   483 00000283 7531                            jne .move_right
   484                                  
   485                                          .move_left:
   486                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   487 00000285 4C8B05(3F140000)                    mov r8, [pallet_position]
   488 0000028C 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   489 0000028F 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   490 00000292 3C58                                cmp al, 'X'        ; Comparar si es una X
   491 00000294 744D                                je .end            ; Si es X, no mover
   492                                              
   493 00000296 4C8B05(3F140000)                    mov r8, [pallet_position]
   494 0000029D 4C8B0D(47140000)                    mov r9, [pallet_size]
   495 000002A4 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   496 000002AA 49FFC8                              dec r8
   497 000002AD 4C8905(3F140000)                    mov [pallet_position], r8
   498 000002B4 EB2D                                jmp .end
   499                                              
   500                                          .move_right:
   501                                              ; Verificar si la siguiente posición después de la paleta sería una X
   502 000002B6 4C8B05(3F140000)                    mov r8, [pallet_position]
   503 000002BD 4C8B0D(47140000)                    mov r9, [pallet_size]
   504 000002C4 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   505 000002C7 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   506 000002CA 3C58                                cmp al, 'X'        ; Comparar si es una X
   507 000002CC 7415                                je .end            ; Si es X, no mover
   508                                              
   509 000002CE 4C8B05(3F140000)                    mov r8, [pallet_position]
   510 000002D5 41C60020                            mov byte [r8], char_space
   511 000002D9 49FFC0                              inc r8
   512 000002DC 4C8905(3F140000)                    mov [pallet_position], r8
   513                                          .end:
   514 000002E3 C3                                  ret
   515                                  
   516                                  move_ball:
   517                                      ; Si la bola no está en movimiento, no hacer nada
   518 000002E4 803D(6F140000)00            cmp byte [ball_moving], 0
   519 000002EB 0F8406010000                je .end
   520                                  
   521                                      ; Borrar la posición actual de la bola
   522 000002F1 4C8B05(4F140000)            mov r8, [ball_x_pos]
   523 000002F8 4C8B0D(57140000)            mov r9, [ball_y_pos]
   524 000002FF 4981C0[000A0000]            add r8, board
   525 00000306 4C89C9                      mov rcx, r9
   526 00000309 B850000000                  mov rax, column_cells + 2
   527 0000030E 48F7E9                      imul rcx
   528 00000311 4901C0                      add r8, rax
   529 00000314 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   530                                  
   531                                      ; Calcular siguiente posición X
   532 00000318 4C8B05(4F140000)            mov r8, [ball_x_pos]
   533 0000031F 4C8B0D(57140000)            mov r9, [ball_y_pos]
   534 00000326 488B05(5F140000)            mov rax, [ball_direction_x]
   535 0000032D 4901C0                      add r8, rax                  ; Nueva posición X
   536                                  
   537                                      ; Calcular la dirección de memoria para la siguiente posición
   538 00000330 4D89C2                      mov r10, r8
   539 00000333 4981C2[000A0000]            add r10, board
   540 0000033A 4C89C9                      mov rcx, r9
   541 0000033D B850000000                  mov rax, column_cells + 2
   542 00000342 48F7E9                      imul rcx
   543 00000345 4901C2                      add r10, rax
   544                                  
   545                                      ; Verificar si hay una X en la siguiente posición X
   546 00000348 418A02                      mov al, [r10]
   547 0000034B 3C58                        cmp al, 'X'
   548 0000034D 750C                        jne .check_block_x
   549 0000034F 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   550 00000356 E99C000000                  jmp .end
   551                                  
   552                                      .check_block_x:
   553                                          ; Verificar colisión con bloques en X
   554 0000035B 4150                            push r8     ; Guardar registros que usa check_block_collision
   555 0000035D 4151                            push r9
   556 0000035F 4152                            push r10
   557 00000361 E80D060000                      call check_block_collision
   558 00000366 415A                            pop r10
   559 00000368 4159                            pop r9
   560 0000036A 4158                            pop r8
   561 0000036C 4885C0                          test rax, rax
   562 0000036F 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   563 00000371 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   564 00000378 EB7D                            jmp .end
   565                                  
   566                                      .check_paddle_x:
   567                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   568 0000037A 41803A3D                        cmp byte [r10], char_equal
   569 0000037E 7509                            jne .check_y_movement
   570 00000380 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   571 00000387 EB6E                            jmp .end
   572                                  
   573                                      .check_y_movement:
   574                                          ; Calcular siguiente posición Y
   575 00000389 488B05(67140000)                mov rax, [ball_direction_y]
   576 00000390 4901C1                          add r9, rax                  ; Nueva posición Y
   577                                  
   578                                          ; Calcular la dirección de memoria para la siguiente posición Y
   579 00000393 4D89C2                          mov r10, r8
   580 00000396 4981C2[000A0000]                add r10, board
   581 0000039D 4C89C9                          mov rcx, r9
   582 000003A0 B850000000                      mov rax, column_cells + 2
   583 000003A5 48F7E9                          imul rcx
   584 000003A8 4901C2                          add r10, rax
   585                                  
   586                                          ; Verificar si hay una X en la siguiente posición Y
   587 000003AB 418A02                          mov al, [r10]
   588 000003AE 3C58                            cmp al, 'X'
   589 000003B0 7509                            jne .check_block_y
   590 000003B2 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   591 000003B9 EB3C                            jmp .end
   592                                  
   593                                      .check_block_y:
   594                                          ; Verificar colisión con bloques en Y
   595 000003BB 4150                            push r8     ; Guardar registros que usa check_block_collision
   596 000003BD 4151                            push r9
   597 000003BF 4152                            push r10
   598 000003C1 E8AD050000                      call check_block_collision
   599 000003C6 415A                            pop r10
   600 000003C8 4159                            pop r9
   601 000003CA 4158                            pop r8
   602 000003CC 4885C0                          test rax, rax
   603 000003CF 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   604 000003D1 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   605 000003D8 EB1D                            jmp .end
   606                                  
   607                                      .check_paddle_y:
   608                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   609 000003DA 41803A3D                    cmp byte [r10], char_equal
   610 000003DE 7509                        jne .update_position
   611 000003E0 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   612 000003E7 EB0E                        jmp .end
   613                                  
   614                                  
   615                                      .update_position:
   616 000003E9 4C8905(4F140000)                mov [ball_x_pos], r8
   617 000003F0 4C890D(57140000)                mov [ball_y_pos], r9
   618                                  
   619                                      .end:
   620 000003F7 C3                              ret
   621                                  
   622                                  ; Función para inicializar el nivel
   623                                  ; Función para inicializar el nivel
   624                                  ; Función para mostrar el número de nivel
   625                                  display_level_number:
   626 000003F8 55                          push rbp
   627 000003F9 4889E5                      mov rbp, rsp
   628                                      
   629                                      ; Limpiar la pantalla primero
   630                                      print clear, clear_length
    82 000003FC B801000000          <1>  mov eax, sys_write
    83 00000401 BF01000000          <1>  mov edi, 1
    84 00000406 48BE-               <1>  mov rsi, %1
    84 00000408 [1000000000000000]  <1>
    85 00000410 BA07000000          <1>  mov edx, %2
    86 00000415 0F05                <1>  syscall
   631                                      
   632                                      ; Calcular la posición central para el mensaje
   633                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   634 00000417 B84E000000                  mov rax, column_cells
   635 0000041C 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   636 00000420 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   637                                      
   638                                      ; Calcular la fila central
   639 00000423 BB20000000                  mov rbx, row_cells
   640 00000428 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   641                                      
   642                                      ; Calcular el offset en el buffer
   643 0000042B B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   644 00000430 48F7E3                      mul rbx                     ; multiplicar por la fila central
   645 00000433 4801D8                      add rax, rbx                ; añadir el offset horizontal
   646                                      
   647                                      ; Escribir "NIVEL " en la posición calculada
   648 00000436 488DB8[000A0000]            lea rdi, [board + rax]
   649 0000043D 48BE-                       mov rsi, level_msg
   649 0000043F [2414000000000000] 
   650 00000447 B906000000                  mov rcx, level_msg_len
   651 0000044C F3A4                        rep movsb
   652                                      
   653                                      ; Escribir el número del nivel
   654 0000044E 8A05(A4140000)              mov al, [current_level]
   655 00000454 0430                        add al, '0'                 ; convertir a ASCII
   656 00000456 8807                        mov [rdi], al
   657                                      
   658                                      ; Mostrar el board con el mensaje
   659                                      print board, board_size
    82 00000458 B801000000          <1>  mov eax, sys_write
    83 0000045D BF01000000          <1>  mov edi, 1
    84 00000462 48BE-               <1>  mov rsi, %1
    84 00000464 [000A000000000000]  <1>
    85 0000046C BA000A0000          <1>  mov edx, %2
    86 00000471 0F05                <1>  syscall
   660                                      
   661                                      ; Esperar un segundo
   662 00000473 B823000000                  mov rax, sys_nanosleep
   663 00000478 48BF-                       mov rdi, level_display_time
   663 0000047A [2F14000000000000] 
   664 00000482 4831F6                      xor rsi, rsi
   665 00000485 0F05                        syscall
   666                                      
   667 00000487 5D                          pop rbp
   668 00000488 C3                          ret
   669                                  
   670                                  ; Función para inicializar un tablero vacío
   671                                  init_empty_board:
   672 00000489 56                          push rsi
   673 0000048A 57                          push rdi
   674 0000048B 51                          push rcx
   675 0000048C 50                          push rax
   676                                  
   677 0000048D 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   678 00000494 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   679 0000049B B9000A0000                  mov rcx, board_template_size
   680 000004A0 F3A4                        rep movsb                   ; Copiar el tablero
   681                                  
   682 000004A2 58                          pop rax
   683 000004A3 59                          pop rcx
   684 000004A4 5F                          pop rdi
   685 000004A5 5E                          pop rsi
   686 000004A6 C3                          ret
   687                                  
   688                                  
   689                                  init_level:
   690                                      ; 1) Copiamos board_template en board para que quede "virgen"
   691 000004A7 C605(2E150000)00            mov byte [destroyed_blocks], 0 
   692 000004AE E8D6FFFFFF                  call init_empty_board
   693 000004B3 E840FFFFFF                  call display_level_number
   694 000004B8 E8B5050000                  call init_enemies
   695                                      
   696 000004BD 56                          push rsi
   697 000004BE 57                          push rdi
   698 000004BF 51                          push rcx
   699 000004C0 50                          push rax
   700                                  
   701 000004C1 488D35(00000000)            lea rsi, [board_template]
   702 000004C8 488D3D(000A0000)            lea rdi, [board]
   703 000004CF B9000A0000                  mov rcx, board_template_size
   704 000004D4 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   705                                  
   706 000004D6 58                          pop rax
   707 000004D7 59                          pop rcx
   708 000004D8 5F                          pop rdi
   709 000004D9 5E                          pop rsi
   710                                  
   711 000004DA B90A000000                  mov rcx, 10
   712 000004DF 4831C0                      xor rax, rax
   713 000004E2 488D3D(D1150000)            lea rdi, [enemy_spawns_triggered]
   714 000004E9 F3AA                        rep stosb      
   715                                  
   716                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   717 000004EB 803D(A4140000)01            cmp byte [current_level], 1
   718 000004F2 7431                        je .level1
   719 000004F4 803D(A4140000)02            cmp byte [current_level], 2
   720 000004FB 7454                        je .level2
   721 000004FD 803D(A4140000)03            cmp byte [current_level], 3
   722 00000504 7477                        je .level3
   723 00000506 803D(A4140000)04            cmp byte [current_level], 4
   724 0000050D 0F8492000000                je .level4
   725 00000513 803D(A4140000)05            cmp byte [current_level], 5
   726 0000051A 0F84AD000000                je .level5
   727 00000520 E9D0000000                  jmp .done
   728                                  
   729                                  
   730                                  
   731                                      .level1:
   732 00000525 C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
   733 0000052C 4831C9                          xor rcx, rcx             
   734                                          .init_loop1:
   735 0000052F 4883F903                            cmp rcx, level1_blocks_count
   736 00000533 0F8DBC000000                        jge .done
   737 00000539 4889C8                              mov rax, rcx         
   738 0000053C 48C1E002                            shl rax, 2          
   739 00000540 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   740 00000546 8891[C2140000]                      mov byte [block_states + rcx], dl
   741 0000054C 48FFC1                              inc rcx
   742 0000054F EBDE                                jmp .init_loop1
   743                                  
   744                                      .level2:
   745 00000551 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   746 00000558 4831C9                          xor rcx, rcx             
   747                                          .init_loop2:
   748 0000055B 4883F901                            cmp rcx, level2_blocks_count
   749 0000055F 0F8D90000000                        jge .done
   750 00000565 4889C8                              mov rax, rcx         
   751 00000568 48C1E002                            shl rax, 2          
   752 0000056C 8A90[B5140000]                      mov dl, byte [level2_blocks + rax + 3]  
   753 00000572 8891[C2140000]                      mov byte [block_states + rcx], dl
   754 00000578 48FFC1                              inc rcx
   755 0000057B EBDE                                jmp .init_loop2
   756                                      .level3:
   757 0000057D C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   758 00000584 4831C9                          xor rcx, rcx             
   759                                          .init_loop3:
   760 00000587 4883F901                            cmp rcx, level3_blocks_count
   761 0000058B 7D68                                jge .done
   762 0000058D 4889C8                              mov rax, rcx         
   763 00000590 48C1E002                            shl rax, 2          
   764 00000594 8A90[B9140000]                      mov dl, byte [level3_blocks + rax + 3]  
   765 0000059A 8891[C2140000]                      mov byte [block_states + rcx], dl
   766 000005A0 48FFC1                              inc rcx
   767 000005A3 EBE2                                jmp .init_loop3
   768                                  
   769                                      .level4:
   770 000005A5 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   771 000005AC 4831C9                          xor rcx, rcx             
   772                                          .init_loop4:
   773 000005AF 4883F901                            cmp rcx, level4_blocks_count
   774 000005B3 7D40                                jge .done
   775 000005B5 4889C8                              mov rax, rcx         
   776 000005B8 48C1E002                            shl rax, 2          
   777 000005BC 8A90[BD140000]                      mov dl, byte [level4_blocks + rax + 3]  
   778 000005C2 8891[C2140000]                      mov byte [block_states + rcx], dl
   779 000005C8 48FFC1                              inc rcx
   780 000005CB EBE2                                jmp .init_loop4
   781                                  
   782                                      .level5:
   783 000005CD C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   784 000005D4 4831C9                          xor rcx, rcx             
   785                                          .init_loop5:
   786 000005D7 4883F901                            cmp rcx, level5_blocks_count
   787 000005DB 7D18                                jge .done
   788 000005DD 4889C8                              mov rax, rcx         
   789 000005E0 48C1E002                            shl rax, 2          
   790 000005E4 8A90[C1140000]                      mov dl, byte [level5_blocks + rax + 3]  
   791 000005EA 8891[C2140000]                      mov byte [block_states + rcx], dl
   792 000005F0 48FFC1                              inc rcx
   793 000005F3 EBE2                                jmp .init_loop5
   794                                      .done:
   795 000005F5 C3                              ret
   796                                  
   797                                  
   798                                  ; Función para verificar y manejar la transición de nivel
   799                                  check_level_complete:
   800                                      ; Verificar si quedan bloques
   801 000005F6 803D(A5140000)00            cmp byte [blocks_remaining], 0
   802 000005FD 753C                        jne .not_complete
   803                                      
   804                                      ; Incrementar el nivel
   805 000005FF FE05(A4140000)              inc byte [current_level]
   806                                      
   807                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   808 00000605 803D(A4140000)06            cmp byte [current_level], 6
   809 0000060C 742E                        je game_win
   810                                      
   811                                      ; Reinicializar el juego para el siguiente nivel
   812 0000060E E894FEFFFF                  call init_level
   813                                      
   814                                      ; Reinicializar la posición de la bola y la paleta
   815 00000613 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   815 0000061B 000000             
   816 0000061E 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   816 00000626 000000             
   817 00000629 C605(6F140000)00            mov byte [ball_moving], 0
   818 00000630 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   818 00000637 [38130000]         
   819                                      
   820                                      .not_complete:
   821 0000063B C3                              ret
   822                                  
   823                                      ; Nueva función para manejar la victoria del juego
   824                                  game_win:
   825                                      ; Limpiar la pantalla primero
   826                                      print clear, clear_length
    82 0000063C B801000000          <1>  mov eax, sys_write
    83 00000641 BF01000000          <1>  mov edi, 1
    84 00000646 48BE-               <1>  mov rsi, %1
    84 00000648 [1000000000000000]  <1>
    85 00000650 BA07000000          <1>  mov edx, %2
    86 00000655 0F05                <1>  syscall
   827                                      
   828                                      ; Mensaje de victoria
   829 00000657 488B05(26150000)            mov rax, [current_score]    ; Obtener el puntaje final
   830 0000065E 48BF-                       mov rdi, number_buffer      ; Convertir a string
   830 00000660 [2F15000000000000] 
   831 00000668 E8AE010000                  call number_to_string
   832                                      
   833                                      ; Definir mensaje de victoria
   834                                      section .data
   835 00001623 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   835 0000162C 616465732120C2A148-
   835 00001635 61732067616E61646F-
   835 0000163E 210A0D             
   836                                          win_msg_len: equ $ - win_msg
   837 00001641 50756E74616A652066-             score_msg: db "Puntaje final: "
   837 0000164A 696E616C3A20       
   838                                          score_msg_len: equ $ - score_msg
   839                                      section .text
   840                                      
   841                                      ; Imprimir mensajes
   842                                      print win_msg, win_msg_len
    82 0000066D B801000000          <1>  mov eax, sys_write
    83 00000672 BF01000000          <1>  mov edi, 1
    84 00000677 48BE-               <1>  mov rsi, %1
    84 00000679 [2316000000000000]  <1>
    85 00000681 BA1E000000          <1>  mov edx, %2
    86 00000686 0F05                <1>  syscall
   843                                      print score_msg, score_msg_len
    82 00000688 B801000000          <1>  mov eax, sys_write
    83 0000068D BF01000000          <1>  mov edi, 1
    84 00000692 48BE-               <1>  mov rsi, %1
    84 00000694 [4116000000000000]  <1>
    85 0000069C BA0F000000          <1>  mov edx, %2
    86 000006A1 0F05                <1>  syscall
   844                                      print number_buffer, 20
    82 000006A3 B801000000          <1>  mov eax, sys_write
    83 000006A8 BF01000000          <1>  mov edi, 1
    84 000006AD 48BE-               <1>  mov rsi, %1
    84 000006AF [2F15000000000000]  <1>
    85 000006B7 BA14000000          <1>  mov edx, %2
    86 000006BC 0F05                <1>  syscall
   845                                      
   846                                      ; Esperar un momento antes de salir
   847 000006BE 48C70537F9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   847 000006C7 0000               
   848 000006C9 48C70534F9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   848 000006D2 0000               
   849                                      sleeptime
    98 000006D4 B823000000          <1>  mov eax, sys_nanosleep
    99 000006D9 48BF-               <1>  mov rdi, timespec
    99 000006DB [0000000000000000]  <1>
   100 000006E3 31F6                <1>  xor esi, esi
   101 000006E5 0F05                <1>  syscall
   850                                      
   851 000006E7 E9D4080000                  jmp exit
   852                                  
   853                                  ; Función para imprimir los bloques
   854                                  ; Función modificada para imprimir bloques
   855                                  
   856                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   857                                  get_current_level_blocks:
   858 000006EC 803D(A4140000)01            cmp byte [current_level], 1
   859 000006F3 7428                        je .level1
   860 000006F5 803D(A4140000)02            cmp byte [current_level], 2
   861 000006FC 7427                        je .level2
   862 000006FE 803D(A4140000)03            cmp byte [current_level], 3
   863 00000705 7426                        je .level3
   864 00000707 803D(A4140000)04            cmp byte [current_level], 4
   865 0000070E 7425                        je .level4
   866 00000710 803D(A4140000)05            cmp byte [current_level], 5
   867 00000717 7424                        je .level5
   868                                      ; Si llegamos aquí, hay un error en el nivel
   869 00000719 4831C0                      xor rax, rax
   870 0000071C C3                          ret
   871                                  
   872                                      .level1:
   873 0000071D 488D05(A6140000)                lea rax, [level1_blocks]
   874 00000724 C3                              ret
   875                                      .level2:
   876 00000725 488D05(B2140000)                lea rax, [level2_blocks]
   877 0000072C C3                              ret
   878                                      .level3:
   879 0000072D 488D05(B6140000)                lea rax, [level3_blocks]
   880 00000734 C3                              ret
   881                                      .level4:
   882 00000735 488D05(BA140000)                lea rax, [level4_blocks]
   883 0000073C C3                              ret
   884                                      .level5:
   885 0000073D 488D05(BE140000)                lea rax, [level5_blocks]
   886 00000744 C3                              ret
   887                                  ; Función para obtener la cantidad de bloques del nivel actual
   888                                  get_current_level_count:
   889 00000745 803D(A4140000)01            cmp byte [current_level], 1
   890 0000074C 7428                        je .level1
   891 0000074E 803D(A4140000)02            cmp byte [current_level], 2
   892 00000755 7425                        je .level2
   893 00000757 803D(A4140000)03            cmp byte [current_level], 3
   894 0000075E 7422                        je .level3
   895 00000760 803D(A4140000)04            cmp byte [current_level], 4
   896 00000767 741F                        je .level4
   897 00000769 803D(A4140000)05            cmp byte [current_level], 5
   898 00000770 741C                        je .level5
   899                                      ; Si llegamos aquí, hay un error en el nivel
   900 00000772 4831C0                      xor rax, rax
   901 00000775 C3                          ret
   902                                  
   903                                      .level1:
   904 00000776 B803000000                      mov rax, level1_blocks_count
   905 0000077B C3                              ret
   906                                      .level2:
   907 0000077C B801000000                      mov rax, level2_blocks_count
   908 00000781 C3                              ret
   909                                      .level3:
   910 00000782 B801000000                      mov rax, level3_blocks_count
   911 00000787 C3                              ret
   912                                      .level4:
   913 00000788 B801000000                      mov rax, level4_blocks_count
   914 0000078D C3                              ret
   915                                      .level5:
   916 0000078E B801000000                      mov rax, level5_blocks_count
   917 00000793 C3                              ret
   918                                  
   919                                  
   920                                  print_blocks:
   921 00000794 55                          push rbp
   922 00000795 4889E5                      mov rbp, rsp
   923                                      
   924                                      ; Obtener puntero a los bloques del nivel actual
   925 00000798 E84FFFFFFF                  call get_current_level_blocks
   926 0000079D 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   927                                      
   928                                      ; Obtener cantidad de bloques del nivel actual
   929 000007A0 E8A0FFFFFF                  call get_current_level_count
   930 000007A5 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   931                                      
   932 000007A8 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   933                                      
   934                                      .print_loop:
   935 000007AB 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   936 000007AE 7D69                            jge .end
   937                                          
   938                                          ; Verificar si el bloque está activo
   939 000007B0 490FB68424-                     movzx rax, byte [block_states + r12]
   939 000007B5 [C2140000]         
   940 000007B9 4885C0                          test rax, rax
   941 000007BC 7456                            jz .next_block
   942                                          
   943                                          ; Obtener posición y tipo del bloque usando r13
   944 000007BE 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   945 000007C3 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   946 000007C8 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   947                                          
   948                                          ; El resto de la lógica de impresión permanece igual
   949 000007CD 4D0FB6C0                        movzx r8, r8b
   950 000007D1 4D0FB6C9                        movzx r9, r9b
   951 000007D5 4981C0[000A0000]                add r8, board
   952 000007DC B850000000                      mov rax, column_cells + 2
   953 000007E1 49F7E1                          mul r9
   954 000007E4 4901C0                          add r8, rax
   955                                          
   956 000007E7 B906000000                      mov rcx, block_length
   957 000007EC 48BE-                           mov rsi, block_type_1
   957 000007EE [8014000000000000] 
   958 000007F6 490FB6C2                        movzx rax, r10b
   959 000007FA 48FFC8                          dec rax
   960 000007FD 486BC006                        imul rax, block_length
   961 00000801 4801C6                          add rsi, rax
   962                                          
   963                                      .print_block_chars:
   964 00000804 8A06                            mov al, [rsi]
   965 00000806 418800                          mov [r8], al
   966 00000809 48FFC6                          inc rsi
   967 0000080C 49FFC0                          inc r8
   968 0000080F 48FFC9                          dec rcx
   969 00000812 75F0                            jnz .print_block_chars
   970                                          
   971                                      .next_block:
   972 00000814 49FFC4                          inc r12
   973 00000817 EB92                            jmp .print_loop
   974                                          
   975                                      .end:
   976 00000819 5D                              pop rbp
   977 0000081A C3                              ret
   978                                  
   979                                  ; Función para convertir número a string
   980                                  ; Input: RAX = número a convertir
   981                                  ; RDI = buffer donde escribir el string
   982                                  number_to_string:
   983 0000081B 53                          push rbx
   984 0000081C 52                          push rdx
   985 0000081D 56                          push rsi
   986 0000081E BB0A000000                  mov rbx, 10          ; Divisor
   987 00000823 B900000000                  mov rcx, 0          ; Contador de dígitos
   988                                      
   989                                      ; Si el número es 0, manejarlo especialmente
   990 00000828 4885C0                      test rax, rax
   991 0000082B 7509                        jnz .convert_loop
   992 0000082D C60730                      mov byte [rdi], '0'
   993 00000830 C6470100                    mov byte [rdi + 1], 0
   994 00000834 EB20                        jmp .end
   995                                      
   996                                      .convert_loop:
   997 00000836 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   998 00000839 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   999 0000083C 80C230                          add dl, '0'     ; Convertir a ASCII
  1000 0000083F 52                              push rdx        ; Guardar el dígito
  1001 00000840 48FFC1                          inc rcx         ; Incrementar contador
  1002 00000843 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1003 00000846 75EE                            jnz .convert_loop
  1004                                          
  1005                                      .write_loop:
  1006 00000848 5A                              pop rdx         ; Obtener dígito
  1007 00000849 8817                            mov [rdi], dl   ; Escribir al buffer
  1008 0000084B 48FFC7                          inc rdi         ; Siguiente posición
  1009 0000084E 48FFC9                          dec rcx         ; Decrementar contador
  1010 00000851 75F5                            jnz .write_loop
  1011                                          
  1012 00000853 C60700                      mov byte [rdi], 0   ; Null terminator
  1013                                      
  1014                                      .end:
  1015 00000856 5E                          pop rsi
  1016 00000857 5A                          pop rdx
  1017 00000858 5B                          pop rbx
  1018 00000859 C3                          ret
  1019                                  
  1020                                  ; Función para imprimir los labels
  1021                                  print_labels:
  1022 0000085A 55                          push rbp
  1023 0000085B 4889E5                      mov rbp, rsp
  1024                                  
  1025                                      ; Crear buffer temporal
  1026 0000085E 4883EC20                    sub rsp, 32
  1027                                  
  1028                                      ; Copiar labels a buffer temporal
  1029 00000862 4889E7                      mov rdi, rsp
  1030 00000865 488D35(DB150000)            lea rsi, [score_label]
  1031 0000086C B917000000                  mov rcx, score_label_len
  1032 00000871 F3A4                        rep movsb
  1033                                  
  1034                                      ; Convertir score a string
  1035 00000873 488B05(26150000)            mov rax, [current_score]
  1036 0000087A 48BF-                       mov rdi, number_buffer
  1036 0000087C [2F15000000000000] 
  1037 00000884 E892FFFFFF                  call number_to_string
  1038                                  
  1039                                      ; Calcular longitud del número
  1040 00000889 B900000000                  mov rcx, 0
  1041 0000088E 48BF-                       mov rdi, number_buffer
  1041 00000890 [2F15000000000000] 
  1042                                      .count_loop:
  1043 00000898 803C0F00                        cmp byte [rdi + rcx], 0
  1044 0000089C 7405                            je .count_done
  1045 0000089E 48FFC1                          inc rcx
  1046 000008A1 EBF5                            jmp .count_loop
  1047                                      .count_done:
  1048                                  
  1049                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1050 000008A3 4889E7                      mov rdi, rsp
  1051 000008A6 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1052 000008AA BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1053 000008AF 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1054                                      .pad_loop:
  1055 000008B2 4885F6                          test rsi, rsi
  1056 000008B5 740B                            jz .pad_done
  1057 000008B7 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1058 000008BA 48FFC7                          inc rdi
  1059 000008BD 48FFCE                          dec rsi
  1060 000008C0 EBF0                            jmp .pad_loop
  1061                                      .pad_done:
  1062                                  
  1063                                      ; Copiar el número
  1064 000008C2 48BE-                       mov rsi, number_buffer
  1064 000008C4 [2F15000000000000] 
  1065 000008CC F3A4                        rep movsb
  1066                                  
  1067                                      ; Imprimir el buffer completo
  1068                                      print rsp, score_label_len
    82 000008CE B801000000          <1>  mov eax, sys_write
    83 000008D3 BF01000000          <1>  mov edi, 1
    84 000008D8 4889E6              <1>  mov rsi, %1
    85 000008DB BA17000000          <1>  mov edx, %2
    86 000008E0 0F05                <1>  syscall
  1069                                  
  1070                                      ; Repetir proceso para bloques destruidos
  1071 000008E2 4889E7                      mov rdi, rsp
  1072 000008E5 488D35(F2150000)            lea rsi, [blocks_label]
  1073 000008EC B91B000000                  mov rcx, blocks_label_len
  1074 000008F1 F3A4                        rep movsb
  1075                                  
  1076                                      ; Verificar que el `[` esté en su posición correcta
  1077 000008F3 4889E7                      mov rdi, rsp
  1078 000008F6 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1079 000008FA C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1080                                  
  1081                                      ; Convertir bloques destruidos a string
  1082 000008FD 480FB605(2E150000)          movzx rax, byte [destroyed_blocks]
  1083 00000905 48BF-                       mov rdi, number_buffer
  1083 00000907 [2F15000000000000] 
  1084 0000090F E807FFFFFF                  call number_to_string
  1085                                  
  1086                                      ; Calcular longitud del número
  1087 00000914 B900000000                  mov rcx, 0
  1088 00000919 48BF-                       mov rdi, number_buffer
  1088 0000091B [2F15000000000000] 
  1089                                      .count_loop2:
  1090 00000923 803C0F00                        cmp byte [rdi + rcx], 0
  1091 00000927 7405                            je .count_done2
  1092 00000929 48FFC1                          inc rcx
  1093 0000092C EBF5                            jmp .count_loop2
  1094                                      .count_done2:
  1095                                  
  1096                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1097 0000092E 4889E7                      mov rdi, rsp
  1098 00000931 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1099 00000935 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1100 0000093A 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1101                                      .pad_loop2:
  1102 0000093D 4885F6                          test rsi, rsi
  1103 00000940 740B                            jz .pad_done2
  1104 00000942 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1105 00000945 48FFC7                          inc rdi
  1106 00000948 48FFCE                          dec rsi
  1107 0000094B EBF0                            jmp .pad_loop2
  1108                                      .pad_done2:
  1109                                  
  1110                                      ; Copiar el número
  1111 0000094D 48BE-                       mov rsi, number_buffer
  1111 0000094F [2F15000000000000] 
  1112 00000957 F3A4                        rep movsb
  1113                                  
  1114                                      ; Imprimir el buffer completo
  1115                                      print rsp, blocks_label_len
    82 00000959 B801000000          <1>  mov eax, sys_write
    83 0000095E BF01000000          <1>  mov edi, 1
    84 00000963 4889E6              <1>  mov rsi, %1
    85 00000966 BA1B000000          <1>  mov edx, %2
    86 0000096B 0F05                <1>  syscall
  1116                                  
  1117                                      ; Restaurar stack
  1118 0000096D 4883C420                    add rsp, 32
  1119 00000971 5D                          pop rbp
  1120 00000972 C3                          ret
  1121                                  
  1122                                  
  1123                                  ; Función modificada para detectar colisión
  1124                                  ; Función mejorada para detectar colisión y manejar la física
  1125                                  ; Función corregida para manejar colisiones con bloques completos
  1126                                  ;---------------------------------------------------------
  1127                                  ; check_block_collision:
  1128                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1129                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1130                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1131                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1132                                  ;   retorna 0.
  1133                                  ;---------------------------------------------------------
  1134                                  ;--------------------------------------
  1135                                  ; check_block_collision
  1136                                  ;--------------------------------------
  1137                                  ; Actualizar check_block_collision para usar el nivel actual
  1138                                  check_block_collision:
  1139 00000973 55                          push rbp
  1140 00000974 4889E5                      mov rbp, rsp
  1141                                  
  1142 00000977 418A02                      mov al, [r10]
  1143                                  
  1144                                      ; Verificación de caracteres igual que antes...
  1145 0000097A 3C55                        cmp al, 'U'  
  1146 0000097C 7419                        je .possible
  1147 0000097E 3C4F                        cmp al, 'O'  
  1148 00000980 7415                        je .possible
  1149 00000982 3C44                        cmp al, 'D'  
  1150 00000984 7411                        je .possible
  1151 00000986 3C4C                        cmp al, 'L'  
  1152 00000988 740D                        je .possible
  1153 0000098A 3C56                        cmp al, 'V'  
  1154 0000098C 7409                        je .possible
  1155 0000098E 3C38                        cmp al, '8'  
  1156 00000990 7405                        je .possible
  1157                                  
  1158 00000992 4831C0                      xor rax, rax
  1159 00000995 5D                          pop rbp
  1160 00000996 C3                          ret
  1161                                  
  1162                                      .possible:
  1163 00000997 53                              push rbx
  1164 00000998 57                              push rdi
  1165 00000999 56                              push rsi
  1166 0000099A 4154                            push r12
  1167                                  
  1168                                          ; Obtener puntero a los bloques del nivel actual
  1169 0000099C E84BFDFFFF                      call get_current_level_blocks
  1170 000009A1 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
  1171                                          
  1172                                          ; Obtener cantidad de bloques del nivel actual
  1173 000009A4 E89CFDFFFF                      call get_current_level_count
  1174 000009A9 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
  1175                                  
  1176 000009AC 4D31E4                          xor r12, r12
  1177                                      .find_block_loop:
  1178 000009AF 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1179 000009B2 0F8DB0000000                    jge .no_block_found
  1180                                  
  1181                                          ; El resto de la lógica de verificación de colisiones...
  1182 000009B8 418A9C24[C2140000]              mov bl, [block_states + r12]
  1183 000009C0 84DB                            test bl, bl
  1184 000009C2 0F8498000000                    jz .next_block
  1185                                  
  1186                                          ; Usar r13 para acceder a los bloques del nivel actual
  1187 000009C8 4C89E8                          mov rax, r13
  1188 000009CB 4D6BE404                        imul r12, 4
  1189 000009CF 4C01E0                          add rax, r12
  1190 000009D2 8A10                            mov dl, [rax]       ; x
  1191 000009D4 8A4801                          mov cl, [rax+1]     ; y
  1192                                  
  1193                                          ; Revertir r12
  1194 000009D7 4D89E4                          mov r12, r12
  1195 000009DA 49C1EC02                        shr r12, 2
  1196                                  
  1197                                          ; La misma lógica de detección de colisiones...
  1198 000009DE 488D3D(000A0000)                lea rdi, [board]
  1199 000009E5 4831C0                          xor rax, rax
  1200 000009E8 B850000000                      mov rax, column_cells + 2
  1201 000009ED 480FB6C9                        movzx rcx, cl
  1202 000009F1 480FAFC1                        imul rax, rcx
  1203 000009F5 4801C7                          add rdi, rax
  1204 000009F8 480FB6C2                        movzx rax, dl
  1205 000009FC 4801C7                          add rdi, rax
  1206                                  
  1207 000009FF 4939FA                          cmp r10, rdi
  1208 00000A02 725C                            jb .next_block
  1209 00000A04 488D5F06                        lea rbx, [rdi + 6]
  1210 00000A08 4939DA                          cmp r10, rbx
  1211 00000A0B 7353                            jae .next_block
  1212                                  
  1213                                          ; Manejo de colisión igual que antes...
  1214 00000A0D 41FE8C24[C2140000]              dec byte [block_states + r12]
  1215 00000A15 418A9C24[C2140000]              mov bl, [block_states + r12]
  1216 00000A1D 84DB                            test bl, bl
  1217 00000A1F 7533                            jnz .still_alive
  1218                                  
  1219 00000A21 B906000000                      mov rcx, block_length
  1220                                      .erase_block_chars:
  1221 00000A26 C60720                          mov byte [rdi], char_space
  1222 00000A29 48FFC7                          inc rdi
  1223 00000A2C E2F8                            loop .erase_block_chars
  1224                                  
  1225 00000A2E FE0D(A5140000)                  dec byte [blocks_remaining]
  1226 00000A34 FE05(2E150000)                  inc byte [destroyed_blocks]     ; Incrementar contador de bloques destruidos
  1227                                      
  1228                                          ; Calcular puntos basado en la durabilidad original del bloque
  1229 00000A3A 4C89E0                          mov rax, r12                    ; Índice del bloque
  1230 00000A3D 486BC004                        imul rax, 4                     ; Multiplicar por 4 (tamaño de cada entrada)
  1231 00000A41 4C01E8                          add rax, r13                    ; Agregar base de los bloques
  1232 00000A44 480FB64002                      movzx rax, byte [rax + 2]       ; Obtener tipo de bloque (durabilidad original)
  1233 00000A49 486BC00A                        imul rax, 10                    ; Multiplicar por 10
  1234 00000A4D 480105(26150000)                add [current_score], rax        ; Agregar al score total
  1235                                  
  1236                                      .still_alive:
  1237 00000A54 B801000000                      mov rax, 1
  1238 00000A59 415C                            pop r12
  1239 00000A5B 5E                              pop rsi
  1240 00000A5C 5F                              pop rdi
  1241 00000A5D 5B                              pop rbx
  1242 00000A5E 5D                              pop rbp
  1243 00000A5F C3                              ret
  1244                                  
  1245                                      .next_block:
  1246 00000A60 49FFC4                          inc r12
  1247 00000A63 E947FFFFFF                      jmp .find_block_loop
  1248                                  
  1249                                      .no_block_found:
  1250 00000A68 4831C0                          xor rax, rax
  1251 00000A6B 415C                            pop r12
  1252 00000A6D 5E                              pop rsi
  1253 00000A6E 5F                              pop rdi
  1254 00000A6F 5B                              pop rbx
  1255 00000A70 5D                              pop rbp
  1256 00000A71 C3                              ret
  1257                                  
  1258                                  init_enemies:
  1259 00000A72 55                          push rbp
  1260 00000A73 4889E5                      mov rbp, rsp
  1261                                      ; Reiniciar contadores de movimiento
  1262 00000A76 C605(71150000)00            mov byte [enemy_move_total], 0
  1263 00000A7D C605(72150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1264                                      ; Limpiar estado previo de enemigos
  1265 00000A84 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1266 00000A89 488D3D(48150000)            lea rdi, [enemies]
  1267 00000A90 30C0                        xor al, al
  1268 00000A92 F3AA                        rep stosb ; Limpiar datos de enemigos
  1269                                      
  1270                                      ; Marcar todos los enemigos como inactivos
  1271 00000A94 488D3D(D1150000)            lea rdi, [enemy_spawns_triggered]
  1272 00000A9B 30C0                        xor al, al
  1273 00000A9D B90A000000                  mov rcx, 10
  1274 00000AA2 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1275                                  
  1276 00000AA4 5D                          pop rbp
  1277 00000AA5 C3                          ret
  1278                                  
  1279                                  
  1280                                  ; Función para mover enemigos
  1281                                  move_enemies:
  1282 00000AA6 55                          push rbp
  1283 00000AA7 4889E5                      mov rbp, rsp
  1284                                      
  1285                                      ; Incrementar contador de movimiento
  1286 00000AAA FE05(6F150000)              inc byte [enemy_move_counter]
  1287 00000AB0 480FB605(6F150000)          movzx rax, byte [enemy_move_counter]
  1288 00000AB8 3A05(70150000)              cmp al, [enemy_move_delay]
  1289 00000ABE 0F85AA010000                jne .end
  1290                                      
  1291                                      ; Resetear contador
  1292 00000AC4 C605(6F150000)00            mov byte [enemy_move_counter], 0
  1293                                      
  1294 00000ACB 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1295                                      
  1296                                      .enemy_loop:
  1297 00000ACE 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1298 00000AD2 0F8D96010000                    jge .end
  1299                                          
  1300                                          ; Calcular offset del enemigo actual
  1301 00000AD8 4C89E0                          mov rax, r12
  1302 00000ADB 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1303 00000ADF 488DB0[48150000]                lea rsi, [enemies + rax]
  1304                                          
  1305                                          ; Verificar si el enemigo está activo
  1306 00000AE6 807E0201                        cmp byte [rsi + 2], 1
  1307 00000AEA 0F8576010000                    jne .next_enemy
  1308                                          
  1309                                          ; Obtener posición actual
  1310 00000AF0 4C0FB606                        movzx r8, byte [rsi]            ; X
  1311 00000AF4 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1312                                          
  1313                                          ; Limpiar posición actual antes de mover
  1314 00000AF9 4150                            push r8
  1315 00000AFB 4151                            push r9
  1316 00000AFD B84E000000                      mov rax, column_cells
  1317 00000B02 4883C002                        add rax, 2
  1318 00000B06 49F7E1                          mul r9
  1319 00000B09 4C01C0                          add rax, r8
  1320 00000B0C 488DB8[000A0000]                lea rdi, [board + rax]
  1321 00000B13 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1322 00000B16 4159                            pop r9
  1323 00000B18 4158                            pop r8
  1324                                  
  1325                                          ; Determinar comportamiento basado en índice
  1326 00000B1A 4C89E0                          mov rax, r12
  1327 00000B1D 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1328 00000B21 4885C0                          test rax, rax
  1329 00000B24 7402                            jz .chase_ball
  1330 00000B26 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1331                                          
  1332                                          ; Perseguir bola (comportamiento original)
  1333                                      .chase_ball:
  1334 00000B28 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1335 00000B2F 4D39D0                          cmp r8, r10
  1336 00000B32 0F8F96000000                    jg .move_left
  1337 00000B38 0F8C95000000                    jl .move_right
  1338                                          
  1339 00000B3E 4C8B15(57140000)                mov r10, [ball_y_pos]
  1340 00000B45 4D39D1                          cmp r9, r10
  1341 00000B48 0F8F8A000000                    jg .move_up
  1342 00000B4E 0F8C89000000                    jl .move_down
  1343 00000B54 E9A5000000                      jmp .check_collision
  1344                                          
  1345                                      .chase_paddle:
  1346                                          ; Obtener la posición X actual de la paleta
  1347 00000B59 4C8B15(3F140000)                mov r10, [pallet_position]
  1348 00000B60 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1349                                          
  1350                                          ; Calcular la posición X real de la paleta
  1351 00000B67 4C89D0                          mov rax, r10
  1352 00000B6A BB4E000000                      mov rbx, column_cells
  1353 00000B6F 4883C302                        add rbx, 2                  ; Añadir newline chars
  1354 00000B73 4831D2                          xor rdx, rdx
  1355 00000B76 48F7F3                          div rbx                     ; rax = y, rdx = x
  1356                                          
  1357                                          ; rdx ahora contiene la posición X de la paleta
  1358                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1359 00000B79 488B0D(47140000)                mov rcx, [pallet_size]
  1360 00000B80 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1361 00000B83 4801CA                          add rdx, rcx
  1362                                          
  1363                                          ; Comparar con posición X del enemigo y mover gradualmente
  1364 00000B86 4939D0                          cmp r8, rdx
  1365 00000B89 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1366 00000B8B 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1367 00000B8D 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1368                                  
  1369                                      .check_y_paddle:
  1370                                          ; La Y de la paleta siempre es row_cells - 2
  1371 00000B8F 41BA20000000                    mov r10, row_cells
  1372 00000B95 4983EA02                        sub r10, 2
  1373                                          
  1374                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1375 00000B99 4D39D1                          cmp r9, r10
  1376 00000B9C 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1377 00000B9E 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1378 00000BA0 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1379                                          
  1380                                      .no_movement:
  1381 00000BA2 EB5A                            jmp .check_collision
  1382                                  
  1383                                      ; También agregar una nueva sección para el movimiento suave
  1384                                      .smooth_transition:
  1385                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1386 00000BA4 8A05(72150000)                  mov al, [enemy_target]
  1387 00000BAA 84C0                            test al, al
  1388 00000BAC 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1389                                          
  1390                                          ; Verificar distancia en X
  1391 00000BAE 4989D2                          mov r10, rdx              ; Posición X objetivo
  1392 00000BB1 4D29C2                          sub r10, r8               ; Calcular diferencia
  1393 00000BB4 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1394 00000BB8 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1395 00000BBA 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1396 00000BBE 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1397 00000BC0 EB3C                            jmp .check_collision
  1398                                          
  1399                                      .limit_right_movement:
  1400 00000BC2 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1401 00000BC6 EB36                            jmp .check_collision
  1402                                          
  1403                                      .limit_left_movement:
  1404 00000BC8 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1405 00000BCC EB30                            jmp .check_collision
  1406                                      .move_left:
  1407 00000BCE 49FFC8                          dec r8
  1408 00000BD1 EB0F                            jmp .check_vertical
  1409                                          
  1410                                      .move_right:
  1411 00000BD3 49FFC0                          inc r8
  1412 00000BD6 EB0A                            jmp .check_vertical
  1413                                          
  1414                                      .move_up:
  1415 00000BD8 49FFC9                          dec r9
  1416 00000BDB EB21                            jmp .check_collision
  1417                                          
  1418                                      .move_down:
  1419 00000BDD 49FFC1                          inc r9
  1420 00000BE0 EB1C                            jmp .check_collision
  1421                                          
  1422                                      .check_vertical:
  1423 00000BE2 8A05(72150000)                  mov al, [enemy_target]
  1424 00000BE8 84C0                            test al, al
  1425 00000BEA 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1426 00000BF0 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1427 00000BF7 4D39D1                          cmp r9, r10
  1428 00000BFA 7FDC                            jg .move_up
  1429 00000BFC 7CDF                            jl .move_down
  1430                                          
  1431                                      .check_collision:
  1432                                          ; Verificar colisión con bordes
  1433 00000BFE 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1434 00000C02 7E62                            jle .next_enemy
  1435 00000C04 4983F84E                        cmp r8, column_cells
  1436 00000C08 7D5C                            jge .next_enemy
  1437 00000C0A 4983F901                        cmp r9, 1                       ; Borde superior
  1438 00000C0E 7E56                            jle .next_enemy
  1439 00000C10 4983F920                        cmp r9, row_cells
  1440 00000C14 7D50                            jge .next_enemy
  1441                                          
  1442                                          ; Verificar colisión con bloques antes de moverse
  1443 00000C16 4150                            push r8
  1444 00000C18 4151                            push r9
  1445 00000C1A 4152                            push r10
  1446                                          
  1447                                          ; Calcular posición en el tablero para verificar
  1448 00000C1C B84E000000                      mov rax, column_cells
  1449 00000C21 4883C002                        add rax, 2
  1450 00000C25 49F7E1                          mul r9
  1451 00000C28 4C01C0                          add rax, r8
  1452 00000C2B 4C8D90[000A0000]                lea r10, [board + rax]
  1453                                          
  1454                                          ; Verificar si hay un bloque en la nueva posición
  1455 00000C32 418A02                          mov al, [r10]
  1456 00000C35 3C55                            cmp al, 'U'
  1457 00000C37 7427                            je .invalid_move
  1458 00000C39 3C4F                            cmp al, 'O'
  1459 00000C3B 7423                            je .invalid_move
  1460 00000C3D 3C44                            cmp al, 'D'
  1461 00000C3F 741F                            je .invalid_move
  1462 00000C41 3C4C                            cmp al, 'L'
  1463 00000C43 741B                            je .invalid_move
  1464 00000C45 3C56                            cmp al, 'V'
  1465 00000C47 7417                            je .invalid_move
  1466 00000C49 3C38                            cmp al, '8'
  1467 00000C4B 7413                            je .invalid_move
  1468 00000C4D 3C58                            cmp al, 'X'
  1469 00000C4F 740F                            je .invalid_move
  1470                                          
  1471 00000C51 415A                            pop r10
  1472 00000C53 4159                            pop r9
  1473 00000C55 4158                            pop r8
  1474                                          
  1475                                          ; Guardar nueva posición si es válida
  1476 00000C57 448806                          mov [rsi], r8b
  1477 00000C5A 44884E01                        mov [rsi + 1], r9b
  1478 00000C5E EB06                            jmp .next_enemy
  1479                                          
  1480                                      .invalid_move:
  1481 00000C60 415A                            pop r10
  1482 00000C62 4159                            pop r9
  1483 00000C64 4158                            pop r8
  1484                                          
  1485                                      .next_enemy:
  1486 00000C66 49FFC4                          inc r12
  1487 00000C69 E960FEFFFF                      jmp .enemy_loop
  1488                                          
  1489                                      .end:
  1490 00000C6E 5D                              pop rbp
  1491 00000C6F C3                              ret
  1492                                  
  1493                                  get_current_spawn_points:
  1494 00000C70 55                          push rbp
  1495 00000C71 4889E5                      mov rbp, rsp
  1496                                      
  1497 00000C74 480FB605(A4140000)          movzx rax, byte [current_level]
  1498 00000C7C 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1499 00000C7F 488B04C5[A6150000]          mov rax, [spawn_points_table + rax * 8]
  1500                                      
  1501 00000C87 5D                          pop rbp
  1502 00000C88 C3                          ret
  1503                                  
  1504                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1505                                  check_enemy_spawn:
  1506 00000C89 55                          push rbp
  1507 00000C8A 4889E5                      mov rbp, rsp
  1508                                      
  1509                                      ; Obtener spawn points del nivel actual
  1510 00000C8D E8DEFFFFFF                  call get_current_spawn_points
  1511 00000C92 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1512                                      
  1513                                      ; Obtener cantidad de bloques destruidos
  1514 00000C95 4C0FB62D(2E150000)          movzx r13, byte [destroyed_blocks]
  1515                                      
  1516                                      ; Verificar cada punto de spawn
  1517 00000C9D 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1518                                      
  1519                                      .check_loop:
  1520 00000CA0 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1521 00000CA4 7D4B                            jge .end
  1522                                          
  1523                                          ; Verificar si este spawn point ya fue usado
  1524 00000CA6 80B9[D1150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1525 00000CAD 743D                            je .next_enemy
  1526                                          
  1527                                          ; Verificar si este enemigo ya está activo
  1528 00000CAF 4889C8                          mov rax, rcx
  1529 00000CB2 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1530 00000CB6 488DB0[48150000]                lea rsi, [enemies + rax]
  1531 00000CBD 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1532 00000CC1 7429                            je .next_enemy
  1533                                          
  1534                                          ; Verificar si debemos spawnear este enemigo
  1535 00000CC3 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1536 00000CC8 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1537 00000CCB 751F                            jne .next_enemy
  1538                                          
  1539                                          ; Marcar este spawn point como usado
  1540 00000CCD C681[D1150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1541                                          
  1542                                          ; Spawner nuevo enemigo
  1543 00000CD4 C60628                          mov byte [rsi], 40             ; X inicial
  1544 00000CD7 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1545 00000CDB C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1546                                          
  1547                                          ; Inicializar comportamiento
  1548 00000CDF 4889C8                          mov rax, rcx
  1549 00000CE2 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1550 00000CE6 8805(D0150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1551                                          
  1552                                      .next_enemy:
  1553 00000CEC 48FFC1                          inc rcx
  1554 00000CEF EBAF                            jmp .check_loop
  1555                                          
  1556                                      .end:
  1557 00000CF1 5D                              pop rbp
  1558 00000CF2 C3                              ret
  1559                                  
  1560                                  
  1561                                  ; Función para dibujar enemigos
  1562                                  print_enemies:
  1563 00000CF3 55                          push rbp
  1564 00000CF4 4889E5                      mov rbp, rsp
  1565                                      
  1566 00000CF7 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1567                                      
  1568                                      .print_loop:
  1569 00000CFA 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1570 00000CFE 7D4B                            jge .end
  1571                                          
  1572                                          ; Calcular offset del enemigo actual
  1573 00000D00 4C89E0                          mov rax, r12
  1574 00000D03 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1575 00000D07 488DB0[48150000]                lea rsi, [enemies + rax]
  1576                                          
  1577                                          ; Verificar si el enemigo está activo
  1578 00000D0E 807E0201                        cmp byte [rsi + 2], 1
  1579 00000D12 7532                            jne .next_enemy
  1580                                          
  1581                                          ; Calcular posición en el tablero
  1582 00000D14 4C0FB606                        movzx r8, byte [rsi]            ; X
  1583 00000D18 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1584                                          
  1585                                          ; Calcular offset en el tablero
  1586 00000D1D B84E000000                      mov rax, column_cells
  1587 00000D22 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1588 00000D26 49F7E1                          mul r9
  1589 00000D29 4C01C0                          add rax, r8
  1590 00000D2C 488DB8[000A0000]                lea rdi, [board + rax]
  1591                                          
  1592                                          ; Obtener carácter del enemigo según el nivel
  1593 00000D33 480FB605(A4140000)              movzx rax, byte [current_level]
  1594 00000D3B 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1595 00000D3E 8A80[43150000]                  mov al, [enemy_chars + rax]
  1596                                          
  1597                                          ; Dibujar enemigo
  1598 00000D44 8807                            mov [rdi], al
  1599                                          
  1600                                      .next_enemy:
  1601 00000D46 49FFC4                          inc r12
  1602 00000D49 EBAF                            jmp .print_loop
  1603                                          
  1604                                      .end:
  1605 00000D4B 5D                              pop rbp
  1606 00000D4C C3                              ret
  1607                                  
  1608                                  ; Función para verificar colisión con enemigos
  1609                                  ; Función para verificar colisión con enemigos
  1610                                  check_enemy_collision:
  1611 00000D4D 55                          push rbp
  1612 00000D4E 4889E5                      mov rbp, rsp
  1613                                      
  1614 00000D51 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1615 00000D54 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1616                                      
  1617                                      .check_loop:
  1618 00000D57 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1619 00000D5B 0F8DE9000000                    jge .end
  1620                                          
  1621                                          ; Calcular offset del enemigo actual
  1622 00000D61 4C89E1                          mov rcx, r12
  1623 00000D64 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1624 00000D68 488DB1[48150000]                lea rsi, [enemies + rcx]
  1625                                          
  1626                                          ; Verificar si el enemigo está activo
  1627 00000D6F 807E0201                        cmp byte [rsi + 2], 1
  1628 00000D73 0F85C9000000                    jne .next_enemy
  1629                                          
  1630                                          ; Verificar colisión con la bola
  1631 00000D79 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1632 00000D7D 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1633                                          
  1634                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1635 00000D82 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1636 00000D89 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1637                                          
  1638                                          ; Comprobar colisión vertical (misma columna)
  1639 00000D90 4D39C2                          cmp r10, r8
  1640 00000D93 7525                            jne .check_horizontal
  1641 00000D95 4D29CB                          sub r11, r9
  1642 00000D98 4983FB01                        cmp r11, 1
  1643 00000D9C 7F1C                            jg .check_horizontal
  1644 00000D9E 4983FBFF                        cmp r11, -1
  1645 00000DA2 7C16                            jl .check_horizontal
  1646                                          
  1647                                          ; Colisión vertical detectada
  1648 00000DA4 E8A3000000                      call destroy_enemy
  1649 00000DA9 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1650 00000DB0 B801000000                      mov rax, 1
  1651 00000DB5 E990000000                      jmp .end
  1652                                          
  1653                                      .check_horizontal:
  1654                                          ; Comprobar colisión horizontal (misma fila)
  1655 00000DBA 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1656 00000DC1 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1657 00000DC8 4D39CB                          cmp r11, r9
  1658 00000DCB 7522                            jne .check_paddle
  1659 00000DCD 4D29C2                          sub r10, r8
  1660 00000DD0 4983FA01                        cmp r10, 1
  1661 00000DD4 7F19                            jg .check_paddle
  1662 00000DD6 4983FAFF                        cmp r10, -1
  1663 00000DDA 7C13                            jl .check_paddle
  1664                                          
  1665                                          ; Colisión horizontal detectada
  1666 00000DDC E86B000000                      call destroy_enemy
  1667 00000DE1 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1668 00000DE8 B801000000                      mov rax, 1
  1669 00000DED EB5B                            jmp .end
  1670                                          
  1671                                      .check_paddle:
  1672                                          ; Verificar colisión con la paleta
  1673 00000DEF 4C8B15(3F140000)                mov r10, [pallet_position]
  1674 00000DF6 4981EA[000A0000]                sub r10, board
  1675 00000DFD 4C89D0                          mov rax, r10
  1676 00000E00 41BB4E000000                    mov r11, column_cells
  1677 00000E06 4983C302                        add r11, 2
  1678 00000E0A 4831D2                          xor rdx, rdx
  1679 00000E0D 49F7F3                          div r11                     ; División para obtener la posición Y
  1680 00000E10 4989D3                          mov r11, rdx               ; X de la paleta en r11
  1681                                          
  1682 00000E13 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  1683                                          
  1684                                          ; Verificar si el enemigo está en la misma fila que la paleta
  1685 00000E1A 41BD20000000                    mov r13, row_cells
  1686 00000E20 4983ED02                        sub r13, 2                 ; Y de la paleta
  1687 00000E24 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  1688 00000E27 7519                            jne .next_enemy
  1689                                          
  1690                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  1691 00000E29 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  1692 00000E2C 7C14                            jl .next_enemy
  1693                                          
  1694 00000E2E 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  1695 00000E31 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  1696 00000E34 7F0C                            jg .next_enemy
  1697                                          
  1698                                          ; Si llegamos aquí, hay colisión con la paleta
  1699 00000E36 E811000000                      call destroy_enemy        ; Destruir el enemigo
  1700 00000E3B B801000000                      mov rax, 1                ; Indicar que hubo colisión
  1701 00000E40 EB08                            jmp .end
  1702                                          
  1703                                      .next_enemy:
  1704 00000E42 49FFC4                          inc r12
  1705 00000E45 E90DFFFFFF                      jmp .check_loop
  1706                                          
  1707                                      .end:
  1708 00000E4A 5D                              pop rbp
  1709 00000E4B C3                              ret
  1710                                  
  1711                                  ; Función para destruir un enemigo
  1712                                  destroy_enemy:
  1713                                      ; Desactivar enemigo
  1714 00000E4C C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  1715                                  
  1716                                      ; Sumar puntos por destruir enemigo
  1717 00000E50 488B05(67150000)            mov rax, [enemy_points]
  1718 00000E57 480105(26150000)            add [current_score], rax
  1719                                  
  1720                                      ; No tocar bloques destruidos aquí
  1721 00000E5E C3                          ret
  1722                                  
  1723                                  
  1724                                  _start:
  1725 00000E5F E8C7F2FFFF              	call canonical_off
  1726 00000E64 E8E4000000              	call start_screen
  1727 00000E69 E839F6FFFF                  call init_level
  1728 00000E6E E8FFFBFFFF                  call init_enemies
  1729 00000E73 EB00                    	jmp .main_loop
  1730                                  	
  1731                                  
  1732                                  	.main_loop:
  1733 00000E75 E8E0F9FFFF                      call print_labels
  1734 00000E7A E8D5F3FFFF              		call print_pallet
  1735 00000E7F E860F4FFFF                      call move_ball
  1736 00000E84 E80BF9FFFF                      call print_blocks
  1737 00000E89 E84FF3FFFF                      call print_lives
  1738 00000E8E E863F7FFFF                      call check_level_complete
  1739 00000E93 E8F1FDFFFF                      call check_enemy_spawn
  1740 00000E98 E809FCFFFF                      call move_enemies
  1741 00000E9D E8ABFEFFFF                      call check_enemy_collision
  1742 00000EA2 E84CFEFFFF                      call print_enemies
  1743 00000EA7 E880F3FFFF              		call print_ball
  1744                                  		print board, board_size				
    82 00000EAC B801000000          <1>  mov eax, sys_write
    83 00000EB1 BF01000000          <1>  mov edi, 1
    84 00000EB6 48BE-               <1>  mov rsi, %1
    84 00000EB8 [000A000000000000]  <1>
    85 00000EC0 BA000A0000          <1>  mov edx, %2
    86 00000EC5 0F05                <1>  syscall
  1745                                  		;setnonblocking	
  1746                                  	.read_more:	
  1747                                  		getchar	
    90 00000EC7 B800000000          <1>  mov rax, sys_read
    91 00000ECC BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000ED1 48BE-               <1>  mov rsi, input_char
    92 00000ED3 [0000000000000000]  <1>
    93 00000EDB BA01000000          <1>  mov rdx, 1
    94 00000EE0 0F05                <1>  syscall
  1748                                  		
  1749 00000EE2 4883F801                		cmp rax, 1
  1750 00000EE6 7532                        	jne .done
  1751                                  		
  1752 00000EE8 8A05(00000000)          		mov al,[input_char]
  1753                                  
  1754 00000EEE 3C61                    		cmp al, 'a'
  1755 00000EF0 750E                    	    jne .not_left
  1756 00000EF2 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1757 00000EF9 E871F3FFFF              		call move_pallet
  1758 00000EFE EB1A                    	    jmp .done
  1759                                  		
  1760                                  		.not_left:
  1761 00000F00 3C64                    		 	cmp al, 'd'
  1762 00000F02 750C                    	    	jne .not_right
  1763 00000F04 BF01000000              			mov rdi, right_direction
  1764 00000F09 E861F3FFFF              	    	call move_pallet
  1765 00000F0E EB0A                        		jmp .done		
  1766                                  
  1767                                  		.not_right:
  1768                                  
  1769 00000F10 3C71                        		cmp al, 'q'
  1770 00000F12 0F84A8000000                		je exit
  1771                                  
  1772 00000F18 EBAD                    			jmp .read_more
  1773                                  		
  1774                                  		.done:	
  1775                                  			;unsetnonblocking		
  1776                                  			sleeptime	
    98 00000F1A B823000000          <1>  mov eax, sys_nanosleep
    99 00000F1F 48BF-               <1>  mov rdi, timespec
    99 00000F21 [0000000000000000]  <1>
   100 00000F29 31F6                <1>  xor esi, esi
   101 00000F2B 0F05                <1>  syscall
  1777                                  			print clear, clear_length
    82 00000F2D B801000000          <1>  mov eax, sys_write
    83 00000F32 BF01000000          <1>  mov edi, 1
    84 00000F37 48BE-               <1>  mov rsi, %1
    84 00000F39 [1000000000000000]  <1>
    85 00000F41 BA07000000          <1>  mov edx, %2
    86 00000F46 0F05                <1>  syscall
  1778 00000F48 E928FFFFFF                  		jmp .main_loop
  1779                                  
  1780                                  
  1781                                  
  1782                                  start_screen:
  1783                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000F4D B801000000          <1>  mov eax, sys_write
    83 00000F52 BF01000000          <1>  mov edi, 1
    84 00000F57 48BE-               <1>  mov rsi, %1
    84 00000F59 [1000000000000000]  <1>
    85 00000F61 BA07000000          <1>  mov edx, %2
    86 00000F66 0F05                <1>  syscall
  1784                                      print msg1, msg1_length
    82 00000F68 B801000000          <1>  mov eax, sys_write
    83 00000F6D BF01000000          <1>  mov edi, 1
    84 00000F72 48BE-               <1>  mov rsi, %1
    84 00000F74 [1700000000000000]  <1>
    85 00000F7C BA14010000          <1>  mov edx, %2
    86 00000F81 0F05                <1>  syscall
  1785                                      
  1786                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1787                                          getchar                 ; Esperamos una tecla
    90 00000F83 B800000000          <1>  mov rax, sys_read
    91 00000F88 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000F8D 48BE-               <1>  mov rsi, input_char
    92 00000F8F [0000000000000000]  <1>
    93 00000F97 BA01000000          <1>  mov rdx, 1
    94 00000F9C 0F05                <1>  syscall
  1788 00000F9E 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1789 00000FA2 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1790                                          
  1791                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000FA4 B801000000          <1>  mov eax, sys_write
    83 00000FA9 BF01000000          <1>  mov edi, 1
    84 00000FAE 48BE-               <1>  mov rsi, %1
    84 00000FB0 [1000000000000000]  <1>
    85 00000FB8 BA07000000          <1>  mov edx, %2
    86 00000FBD 0F05                <1>  syscall
  1792 00000FBF C3                          ret
  1793                                  
  1794                                  exit: 
  1795 00000FC0 E8A8F1FFFF              	call canonical_on
  1796 00000FC5 B83C000000              	mov    rax, 60
  1797 00000FCA BF00000000                  mov    rdi, 0
  1798 00000FCF 0F05                        syscall
  1799                                  
