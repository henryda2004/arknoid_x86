     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                          level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 38070301                        db 56, 7, 3, 1    ; Bloque 7
   288                                      level1_blocks_count equ 1   ; Cantidad total de bloques
   289                                  
   290                                      ; Nivel 2: Bloques de prueba
   291                                      level2_blocks:
   292 000014AA 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   293                                      level2_blocks_count equ 1
   294                                  
   295                                      ; Nivel 3
   296                                      level3_blocks:
   297 000014AE 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   298                                  
   299                                      level3_blocks_count equ 1
   300                                  
   301                                      ; Nivel 4
   302                                      level4_blocks:
   303 000014B2 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   304                                      level4_blocks_count equ 1
   305                                  
   306                                      ; Nivel 5
   307                                      level5_blocks:
   308 000014B6 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   309                                      level5_blocks_count equ 1
   310                                  
   311                                      ; Array para mantener el estado de los bloques
   312 000014BA 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   313                                  
   314 0000151E 50756E74616A653A20          score_label db "Puntaje: "
   315                                      score_label_len equ $ - score_label
   316 00001527 426C6F717565732064-         blocks_label db "Bloques destruidos: "
   316 00001530 657374727569646F73-
   316 00001539 3A20               
   317                                      blocks_label_len equ $ - blocks_label
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153B 0000000000000000            current_score dq 0          ; Score actual
   321 00001543 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001544 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 00001558 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155D 00<rep Fh>                  enemies: times 5 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000156C 02                          enemies_count db 2            ; Cantidad de enemigos activos
   331                                      
   332 0000156D 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001575 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001576 03                          enemy_move_delay db 3           ; Mover enemigos cada N ciclos
   335                                  
   336                                  section .text
   337                                  
   338                                  ;	Function: print_ball
   339                                  ; This function displays the position of the ball
   340                                  ; Arguments: none
   341                                  ;
   342                                  ; Return:
   343                                  ;	Void
   344                                  print_ball:
   345 000001DD 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   346 000001E4 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   347 000001EB 4981C0[000A0000]        	add r8, board
   348                                  
   349 000001F2 4C89C9                  	mov rcx, r9
   350 000001F5 B850000000              	mov rax, column_cells + 2
   351 000001FA 48F7E9                  	imul rcx
   352                                  	
   353 000001FD 4901C0                  	add r8, rax
   354 00000200 41C6004F                	mov byte [r8], char_O
   355 00000204 C3                      	ret
   356                                  
   357                                  	
   358                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   359                                  	
   360                                  
   361                                  
   362                                  
   363                                  ;	Function: print_pallet
   364                                  ; This function moves the pallet in the game
   365                                  ; Arguments: none
   366                                  ;
   367                                  ; Return;
   368                                  ;	void
   369                                  print_pallet:
   370 00000205 4C8B05(3F140000)        	mov r8, [pallet_position]
   371 0000020C 488B0D(47140000)        	mov rcx, [pallet_size]
   372                                  	.write_pallet:
   373 00000213 41C6003D                		mov byte [r8], char_equal
   374 00000217 49FFC0                  		inc r8
   375 0000021A 48FFC9                  		dec rcx
   376 0000021D 75F4                    		jnz .write_pallet
   377                                  
   378 0000021F C3                      	ret
   379                                  	
   380                                  ;	Function: move_pallet
   381                                  ; This function is in charge of moving the pallet in a given direction
   382                                  ; Arguments:
   383                                  ;	rdi: left direction or right direction
   384                                  ;
   385                                  ; Return:
   386                                  ;	void
   387                                  move_pallet:
   388                                      
   389 00000220 803D(6F140000)00            cmp byte [ball_moving], 0
   390 00000227 7507                        jne .continue_movement
   391 00000229 C605(6F140000)01            mov byte [ball_moving], 1
   392                                  
   393                                      .continue_movement:
   394 00000230 4883FFFF                        cmp rdi, left_direction
   395 00000234 7531                            jne .move_right
   396                                  
   397                                          .move_left:
   398                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   399 00000236 4C8B05(3F140000)                    mov r8, [pallet_position]
   400 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   401 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   402 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   403 00000245 744D                                je .end            ; Si es X, no mover
   404                                              
   405 00000247 4C8B05(3F140000)                    mov r8, [pallet_position]
   406 0000024E 4C8B0D(47140000)                    mov r9, [pallet_size]
   407 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   408 0000025B 49FFC8                              dec r8
   409 0000025E 4C8905(3F140000)                    mov [pallet_position], r8
   410 00000265 EB2D                                jmp .end
   411                                              
   412                                          .move_right:
   413                                              ; Verificar si la siguiente posición después de la paleta sería una X
   414 00000267 4C8B05(3F140000)                    mov r8, [pallet_position]
   415 0000026E 4C8B0D(47140000)                    mov r9, [pallet_size]
   416 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   417 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   418 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   419 0000027D 7415                                je .end            ; Si es X, no mover
   420                                              
   421 0000027F 4C8B05(3F140000)                    mov r8, [pallet_position]
   422 00000286 41C60020                            mov byte [r8], char_space
   423 0000028A 49FFC0                              inc r8
   424 0000028D 4C8905(3F140000)                    mov [pallet_position], r8
   425                                          .end:
   426 00000294 C3                                  ret
   427                                  
   428                                  move_ball:
   429                                      ; Si la bola no está en movimiento, no hacer nada
   430 00000295 803D(6F140000)00            cmp byte [ball_moving], 0
   431 0000029C 0F8406010000                je .end
   432                                  
   433                                      ; Borrar la posición actual de la bola
   434 000002A2 4C8B05(4F140000)            mov r8, [ball_x_pos]
   435 000002A9 4C8B0D(57140000)            mov r9, [ball_y_pos]
   436 000002B0 4981C0[000A0000]            add r8, board
   437 000002B7 4C89C9                      mov rcx, r9
   438 000002BA B850000000                  mov rax, column_cells + 2
   439 000002BF 48F7E9                      imul rcx
   440 000002C2 4901C0                      add r8, rax
   441 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   442                                  
   443                                      ; Calcular siguiente posición X
   444 000002C9 4C8B05(4F140000)            mov r8, [ball_x_pos]
   445 000002D0 4C8B0D(57140000)            mov r9, [ball_y_pos]
   446 000002D7 488B05(5F140000)            mov rax, [ball_direction_x]
   447 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   448                                  
   449                                      ; Calcular la dirección de memoria para la siguiente posición
   450 000002E1 4D89C2                      mov r10, r8
   451 000002E4 4981C2[000A0000]            add r10, board
   452 000002EB 4C89C9                      mov rcx, r9
   453 000002EE B850000000                  mov rax, column_cells + 2
   454 000002F3 48F7E9                      imul rcx
   455 000002F6 4901C2                      add r10, rax
   456                                  
   457                                      ; Verificar si hay una X en la siguiente posición X
   458 000002F9 418A02                      mov al, [r10]
   459 000002FC 3C58                        cmp al, 'X'
   460 000002FE 750C                        jne .check_block_x
   461 00000300 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   462 00000307 E99C000000                  jmp .end
   463                                  
   464                                      .check_block_x:
   465                                          ; Verificar colisión con bloques en X
   466 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   467 0000030E 4151                            push r9
   468 00000310 4152                            push r10
   469 00000312 E8D4050000                      call check_block_collision
   470 00000317 415A                            pop r10
   471 00000319 4159                            pop r9
   472 0000031B 4158                            pop r8
   473 0000031D 4885C0                          test rax, rax
   474 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   475 00000322 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   476 00000329 EB7D                            jmp .end
   477                                  
   478                                      .check_paddle_x:
   479                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   480 0000032B 41803A3D                        cmp byte [r10], char_equal
   481 0000032F 7509                            jne .check_y_movement
   482 00000331 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   483 00000338 EB6E                            jmp .end
   484                                  
   485                                      .check_y_movement:
   486                                          ; Calcular siguiente posición Y
   487 0000033A 488B05(67140000)                mov rax, [ball_direction_y]
   488 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   489                                  
   490                                          ; Calcular la dirección de memoria para la siguiente posición Y
   491 00000344 4D89C2                          mov r10, r8
   492 00000347 4981C2[000A0000]                add r10, board
   493 0000034E 4C89C9                          mov rcx, r9
   494 00000351 B850000000                      mov rax, column_cells + 2
   495 00000356 48F7E9                          imul rcx
   496 00000359 4901C2                          add r10, rax
   497                                  
   498                                          ; Verificar si hay una X en la siguiente posición Y
   499 0000035C 418A02                          mov al, [r10]
   500 0000035F 3C58                            cmp al, 'X'
   501 00000361 7509                            jne .check_block_y
   502 00000363 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   503 0000036A EB3C                            jmp .end
   504                                  
   505                                      .check_block_y:
   506                                          ; Verificar colisión con bloques en Y
   507 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   508 0000036E 4151                            push r9
   509 00000370 4152                            push r10
   510 00000372 E874050000                      call check_block_collision
   511 00000377 415A                            pop r10
   512 00000379 4159                            pop r9
   513 0000037B 4158                            pop r8
   514 0000037D 4885C0                          test rax, rax
   515 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   516 00000382 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   517 00000389 EB1D                            jmp .end
   518                                  
   519                                      .check_paddle_y:
   520                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   521 0000038B 41803A3D                    cmp byte [r10], char_equal
   522 0000038F 7509                        jne .update_position
   523 00000391 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   524 00000398 EB0E                        jmp .end
   525                                  
   526                                  
   527                                      .update_position:
   528 0000039A 4C8905(4F140000)                mov [ball_x_pos], r8
   529 000003A1 4C890D(57140000)                mov [ball_y_pos], r9
   530                                  
   531                                      .end:
   532 000003A8 C3                              ret
   533                                  
   534                                  ; Función para inicializar el nivel
   535                                  ; Función para inicializar el nivel
   536                                  ; Función para mostrar el número de nivel
   537                                  display_level_number:
   538 000003A9 55                          push rbp
   539 000003AA 4889E5                      mov rbp, rsp
   540                                      
   541                                      ; Limpiar la pantalla primero
   542                                      print clear, clear_length
    82 000003AD B801000000          <1>  mov eax, sys_write
    83 000003B2 BF01000000          <1>  mov edi, 1
    84 000003B7 48BE-               <1>  mov rsi, %1
    84 000003B9 [1000000000000000]  <1>
    85 000003C1 BA07000000          <1>  mov edx, %2
    86 000003C6 0F05                <1>  syscall
   543                                      
   544                                      ; Calcular la posición central para el mensaje
   545                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   546 000003C8 B84E000000                  mov rax, column_cells
   547 000003CD 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   548 000003D1 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   549                                      
   550                                      ; Calcular la fila central
   551 000003D4 BB20000000                  mov rbx, row_cells
   552 000003D9 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   553                                      
   554                                      ; Calcular el offset en el buffer
   555 000003DC B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   556 000003E1 48F7E3                      mul rbx                     ; multiplicar por la fila central
   557 000003E4 4801D8                      add rax, rbx                ; añadir el offset horizontal
   558                                      
   559                                      ; Escribir "NIVEL " en la posición calculada
   560 000003E7 488DB8[000A0000]            lea rdi, [board + rax]
   561 000003EE 48BE-                       mov rsi, level_msg
   561 000003F0 [2414000000000000] 
   562 000003F8 B906000000                  mov rcx, level_msg_len
   563 000003FD F3A4                        rep movsb
   564                                      
   565                                      ; Escribir el número del nivel
   566 000003FF 8A05(A4140000)              mov al, [current_level]
   567 00000405 0430                        add al, '0'                 ; convertir a ASCII
   568 00000407 8807                        mov [rdi], al
   569                                      
   570                                      ; Mostrar el board con el mensaje
   571                                      print board, board_size
    82 00000409 B801000000          <1>  mov eax, sys_write
    83 0000040E BF01000000          <1>  mov edi, 1
    84 00000413 48BE-               <1>  mov rsi, %1
    84 00000415 [000A000000000000]  <1>
    85 0000041D BA000A0000          <1>  mov edx, %2
    86 00000422 0F05                <1>  syscall
   572                                      
   573                                      ; Esperar un segundo
   574 00000424 B823000000                  mov rax, sys_nanosleep
   575 00000429 48BF-                       mov rdi, level_display_time
   575 0000042B [2F14000000000000] 
   576 00000433 4831F6                      xor rsi, rsi
   577 00000436 0F05                        syscall
   578                                      
   579 00000438 5D                          pop rbp
   580 00000439 C3                          ret
   581                                  
   582                                  ; Función para inicializar un tablero vacío
   583                                  init_empty_board:
   584 0000043A 56                          push rsi
   585 0000043B 57                          push rdi
   586 0000043C 51                          push rcx
   587 0000043D 50                          push rax
   588                                  
   589 0000043E 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   590 00000445 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   591 0000044C B9000A0000                  mov rcx, board_template_size
   592 00000451 F3A4                        rep movsb                   ; Copiar el tablero
   593                                  
   594 00000453 58                          pop rax
   595 00000454 59                          pop rcx
   596 00000455 5F                          pop rdi
   597 00000456 5E                          pop rsi
   598 00000457 C3                          ret
   599                                  
   600                                  
   601                                  init_level:
   602                                      ; 1) Copiamos board_template en board para que quede "virgen"
   603 00000458 C605(43150000)00            mov byte [destroyed_blocks], 0 
   604 0000045F E8D6FFFFFF                  call init_empty_board
   605 00000464 E840FFFFFF                  call display_level_number
   606 00000469 E87C050000                  call init_enemies
   607                                      
   608 0000046E 56                          push rsi
   609 0000046F 57                          push rdi
   610 00000470 51                          push rcx
   611 00000471 50                          push rax
   612                                  
   613 00000472 488D35(00000000)            lea rsi, [board_template]
   614 00000479 488D3D(000A0000)            lea rdi, [board]
   615 00000480 B9000A0000                  mov rcx, board_template_size
   616 00000485 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   617                                  
   618 00000487 58                          pop rax
   619 00000488 59                          pop rcx
   620 00000489 5F                          pop rdi
   621 0000048A 5E                          pop rsi
   622                                  
   623                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   624 0000048B 803D(A4140000)01            cmp byte [current_level], 1
   625 00000492 7431                        je .level1
   626 00000494 803D(A4140000)02            cmp byte [current_level], 2
   627 0000049B 7454                        je .level2
   628 0000049D 803D(A4140000)03            cmp byte [current_level], 3
   629 000004A4 7477                        je .level3
   630 000004A6 803D(A4140000)04            cmp byte [current_level], 4
   631 000004AD 0F8492000000                je .level4
   632 000004B3 803D(A4140000)05            cmp byte [current_level], 5
   633 000004BA 0F84AD000000                je .level5
   634 000004C0 E9D0000000                  jmp .done
   635                                  
   636                                      .level1:
   637 000004C5 C605(A5140000)01                mov byte [blocks_remaining], level1_blocks_count
   638 000004CC 4831C9                          xor rcx, rcx             
   639                                          .init_loop1:
   640 000004CF 4883F901                            cmp rcx, level1_blocks_count
   641 000004D3 0F8DBC000000                        jge .done
   642 000004D9 4889C8                              mov rax, rcx         
   643 000004DC 48C1E002                            shl rax, 2          
   644 000004E0 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   645 000004E6 8891[BA140000]                      mov byte [block_states + rcx], dl
   646 000004EC 48FFC1                              inc rcx
   647 000004EF EBDE                                jmp .init_loop1
   648                                  
   649                                      .level2:
   650 000004F1 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   651 000004F8 4831C9                          xor rcx, rcx             
   652                                          .init_loop2:
   653 000004FB 4883F901                            cmp rcx, level2_blocks_count
   654 000004FF 0F8D90000000                        jge .done
   655 00000505 4889C8                              mov rax, rcx         
   656 00000508 48C1E002                            shl rax, 2          
   657 0000050C 8A90[AD140000]                      mov dl, byte [level2_blocks + rax + 3]  
   658 00000512 8891[BA140000]                      mov byte [block_states + rcx], dl
   659 00000518 48FFC1                              inc rcx
   660 0000051B EBDE                                jmp .init_loop2
   661                                      .level3:
   662 0000051D C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   663 00000524 4831C9                          xor rcx, rcx             
   664                                          .init_loop3:
   665 00000527 4883F901                            cmp rcx, level3_blocks_count
   666 0000052B 7D68                                jge .done
   667 0000052D 4889C8                              mov rax, rcx         
   668 00000530 48C1E002                            shl rax, 2          
   669 00000534 8A90[B1140000]                      mov dl, byte [level3_blocks + rax + 3]  
   670 0000053A 8891[BA140000]                      mov byte [block_states + rcx], dl
   671 00000540 48FFC1                              inc rcx
   672 00000543 EBE2                                jmp .init_loop3
   673                                  
   674                                      .level4:
   675 00000545 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   676 0000054C 4831C9                          xor rcx, rcx             
   677                                          .init_loop4:
   678 0000054F 4883F901                            cmp rcx, level4_blocks_count
   679 00000553 7D40                                jge .done
   680 00000555 4889C8                              mov rax, rcx         
   681 00000558 48C1E002                            shl rax, 2          
   682 0000055C 8A90[B5140000]                      mov dl, byte [level4_blocks + rax + 3]  
   683 00000562 8891[BA140000]                      mov byte [block_states + rcx], dl
   684 00000568 48FFC1                              inc rcx
   685 0000056B EBE2                                jmp .init_loop4
   686                                  
   687                                      .level5:
   688 0000056D C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   689 00000574 4831C9                          xor rcx, rcx             
   690                                          .init_loop5:
   691 00000577 4883F901                            cmp rcx, level5_blocks_count
   692 0000057B 7D18                                jge .done
   693 0000057D 4889C8                              mov rax, rcx         
   694 00000580 48C1E002                            shl rax, 2          
   695 00000584 8A90[B9140000]                      mov dl, byte [level5_blocks + rax + 3]  
   696 0000058A 8891[BA140000]                      mov byte [block_states + rcx], dl
   697 00000590 48FFC1                              inc rcx
   698 00000593 EBE2                                jmp .init_loop5
   699                                      .done:
   700 00000595 C3                              ret
   701                                  
   702                                  
   703                                  ; Función para verificar y manejar la transición de nivel
   704                                  check_level_complete:
   705                                      ; Verificar si quedan bloques
   706 00000596 803D(A5140000)00            cmp byte [blocks_remaining], 0
   707 0000059D 753C                        jne .not_complete
   708                                      
   709                                      ; Incrementar el nivel
   710 0000059F FE05(A4140000)              inc byte [current_level]
   711                                      
   712                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   713 000005A5 803D(A4140000)06            cmp byte [current_level], 6
   714 000005AC 742E                        je game_win
   715                                      
   716                                      ; Reinicializar el juego para el siguiente nivel
   717 000005AE E8A5FEFFFF                  call init_level
   718                                      
   719                                      ; Reinicializar la posición de la bola y la paleta
   720 000005B3 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   720 000005BB 000000             
   721 000005BE 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   721 000005C6 000000             
   722 000005C9 C605(6F140000)00            mov byte [ball_moving], 0
   723 000005D0 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   723 000005D7 [38130000]         
   724                                      
   725                                      .not_complete:
   726 000005DB C3                              ret
   727                                  
   728                                      ; Nueva función para manejar la victoria del juego
   729                                  game_win:
   730                                      ; Limpiar la pantalla primero
   731                                      print clear, clear_length
    82 000005DC B801000000          <1>  mov eax, sys_write
    83 000005E1 BF01000000          <1>  mov edi, 1
    84 000005E6 48BE-               <1>  mov rsi, %1
    84 000005E8 [1000000000000000]  <1>
    85 000005F0 BA07000000          <1>  mov edx, %2
    86 000005F5 0F05                <1>  syscall
   732                                      
   733                                      ; Mensaje de victoria
   734 000005F7 488B05(3B150000)            mov rax, [current_score]    ; Obtener el puntaje final
   735 000005FE 48BF-                       mov rdi, number_buffer      ; Convertir a string
   735 00000600 [4415000000000000] 
   736 00000608 E8AE010000                  call number_to_string
   737                                      
   738                                      ; Definir mensaje de victoria
   739                                      section .data
   740 00001577 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   740 00001580 616465732120C2A148-
   740 00001589 61732067616E61646F-
   740 00001592 210A0D             
   741                                          win_msg_len: equ $ - win_msg
   742 00001595 50756E74616A652066-             score_msg: db "Puntaje final: "
   742 0000159E 696E616C3A20       
   743                                          score_msg_len: equ $ - score_msg
   744                                      section .text
   745                                      
   746                                      ; Imprimir mensajes
   747                                      print win_msg, win_msg_len
    82 0000060D B801000000          <1>  mov eax, sys_write
    83 00000612 BF01000000          <1>  mov edi, 1
    84 00000617 48BE-               <1>  mov rsi, %1
    84 00000619 [7715000000000000]  <1>
    85 00000621 BA1E000000          <1>  mov edx, %2
    86 00000626 0F05                <1>  syscall
   748                                      print score_msg, score_msg_len
    82 00000628 B801000000          <1>  mov eax, sys_write
    83 0000062D BF01000000          <1>  mov edi, 1
    84 00000632 48BE-               <1>  mov rsi, %1
    84 00000634 [9515000000000000]  <1>
    85 0000063C BA0F000000          <1>  mov edx, %2
    86 00000641 0F05                <1>  syscall
   749                                      print number_buffer, 20
    82 00000643 B801000000          <1>  mov eax, sys_write
    83 00000648 BF01000000          <1>  mov edi, 1
    84 0000064D 48BE-               <1>  mov rsi, %1
    84 0000064F [4415000000000000]  <1>
    85 00000657 BA14000000          <1>  mov edx, %2
    86 0000065C 0F05                <1>  syscall
   750                                      
   751                                      ; Esperar un momento antes de salir
   752 0000065E 48C70597F9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   752 00000667 0000               
   753 00000669 48C70594F9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   753 00000672 0000               
   754                                      sleeptime
    98 00000674 B823000000          <1>  mov eax, sys_nanosleep
    99 00000679 48BF-               <1>  mov rdi, timespec
    99 0000067B [0000000000000000]  <1>
   100 00000683 31F6                <1>  xor esi, esi
   101 00000685 0F05                <1>  syscall
   755                                      
   756 00000687 E975070000                  jmp exit
   757                                  
   758                                  ; Función para imprimir los bloques
   759                                  ; Función modificada para imprimir bloques
   760                                  
   761                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   762                                  get_current_level_blocks:
   763 0000068C 803D(A4140000)01            cmp byte [current_level], 1
   764 00000693 7428                        je .level1
   765 00000695 803D(A4140000)02            cmp byte [current_level], 2
   766 0000069C 7427                        je .level2
   767 0000069E 803D(A4140000)03            cmp byte [current_level], 3
   768 000006A5 7426                        je .level3
   769 000006A7 803D(A4140000)04            cmp byte [current_level], 4
   770 000006AE 7425                        je .level4
   771 000006B0 803D(A4140000)05            cmp byte [current_level], 5
   772 000006B7 7424                        je .level5
   773                                      ; Si llegamos aquí, hay un error en el nivel
   774 000006B9 4831C0                      xor rax, rax
   775 000006BC C3                          ret
   776                                  
   777                                      .level1:
   778 000006BD 488D05(A6140000)                lea rax, [level1_blocks]
   779 000006C4 C3                              ret
   780                                      .level2:
   781 000006C5 488D05(AA140000)                lea rax, [level2_blocks]
   782 000006CC C3                              ret
   783                                      .level3:
   784 000006CD 488D05(AE140000)                lea rax, [level3_blocks]
   785 000006D4 C3                              ret
   786                                      .level4:
   787 000006D5 488D05(B2140000)                lea rax, [level4_blocks]
   788 000006DC C3                              ret
   789                                      .level5:
   790 000006DD 488D05(B6140000)                lea rax, [level5_blocks]
   791 000006E4 C3                              ret
   792                                  ; Función para obtener la cantidad de bloques del nivel actual
   793                                  get_current_level_count:
   794 000006E5 803D(A4140000)01            cmp byte [current_level], 1
   795 000006EC 7428                        je .level1
   796 000006EE 803D(A4140000)02            cmp byte [current_level], 2
   797 000006F5 7425                        je .level2
   798 000006F7 803D(A4140000)03            cmp byte [current_level], 3
   799 000006FE 7422                        je .level3
   800 00000700 803D(A4140000)04            cmp byte [current_level], 4
   801 00000707 741F                        je .level4
   802 00000709 803D(A4140000)05            cmp byte [current_level], 5
   803 00000710 741C                        je .level5
   804                                      ; Si llegamos aquí, hay un error en el nivel
   805 00000712 4831C0                      xor rax, rax
   806 00000715 C3                          ret
   807                                  
   808                                      .level1:
   809 00000716 B801000000                      mov rax, level1_blocks_count
   810 0000071B C3                              ret
   811                                      .level2:
   812 0000071C B801000000                      mov rax, level2_blocks_count
   813 00000721 C3                              ret
   814                                      .level3:
   815 00000722 B801000000                      mov rax, level3_blocks_count
   816 00000727 C3                              ret
   817                                      .level4:
   818 00000728 B801000000                      mov rax, level4_blocks_count
   819 0000072D C3                              ret
   820                                      .level5:
   821 0000072E B801000000                      mov rax, level5_blocks_count
   822 00000733 C3                              ret
   823                                  
   824                                  
   825                                  print_blocks:
   826 00000734 55                          push rbp
   827 00000735 4889E5                      mov rbp, rsp
   828                                      
   829                                      ; Obtener puntero a los bloques del nivel actual
   830 00000738 E84FFFFFFF                  call get_current_level_blocks
   831 0000073D 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   832                                      
   833                                      ; Obtener cantidad de bloques del nivel actual
   834 00000740 E8A0FFFFFF                  call get_current_level_count
   835 00000745 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   836                                      
   837 00000748 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   838                                      
   839                                      .print_loop:
   840 0000074B 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   841 0000074E 7D69                            jge .end
   842                                          
   843                                          ; Verificar si el bloque está activo
   844 00000750 490FB68424-                     movzx rax, byte [block_states + r12]
   844 00000755 [BA140000]         
   845 00000759 4885C0                          test rax, rax
   846 0000075C 7456                            jz .next_block
   847                                          
   848                                          ; Obtener posición y tipo del bloque usando r13
   849 0000075E 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   850 00000763 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   851 00000768 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   852                                          
   853                                          ; El resto de la lógica de impresión permanece igual
   854 0000076D 4D0FB6C0                        movzx r8, r8b
   855 00000771 4D0FB6C9                        movzx r9, r9b
   856 00000775 4981C0[000A0000]                add r8, board
   857 0000077C B850000000                      mov rax, column_cells + 2
   858 00000781 49F7E1                          mul r9
   859 00000784 4901C0                          add r8, rax
   860                                          
   861 00000787 B906000000                      mov rcx, block_length
   862 0000078C 48BE-                           mov rsi, block_type_1
   862 0000078E [8014000000000000] 
   863 00000796 490FB6C2                        movzx rax, r10b
   864 0000079A 48FFC8                          dec rax
   865 0000079D 486BC006                        imul rax, block_length
   866 000007A1 4801C6                          add rsi, rax
   867                                          
   868                                      .print_block_chars:
   869 000007A4 8A06                            mov al, [rsi]
   870 000007A6 418800                          mov [r8], al
   871 000007A9 48FFC6                          inc rsi
   872 000007AC 49FFC0                          inc r8
   873 000007AF 48FFC9                          dec rcx
   874 000007B2 75F0                            jnz .print_block_chars
   875                                          
   876                                      .next_block:
   877 000007B4 49FFC4                          inc r12
   878 000007B7 EB92                            jmp .print_loop
   879                                          
   880                                      .end:
   881 000007B9 5D                              pop rbp
   882 000007BA C3                              ret
   883                                  
   884                                  ; Función para convertir número a string
   885                                  ; Input: RAX = número a convertir
   886                                  ; RDI = buffer donde escribir el string
   887                                  number_to_string:
   888 000007BB 53                          push rbx
   889 000007BC 52                          push rdx
   890 000007BD 56                          push rsi
   891 000007BE BB0A000000                  mov rbx, 10          ; Divisor
   892 000007C3 B900000000                  mov rcx, 0          ; Contador de dígitos
   893                                      
   894                                      ; Si el número es 0, manejarlo especialmente
   895 000007C8 4885C0                      test rax, rax
   896 000007CB 7509                        jnz .convert_loop
   897 000007CD C60730                      mov byte [rdi], '0'
   898 000007D0 C6470100                    mov byte [rdi + 1], 0
   899 000007D4 EB20                        jmp .end
   900                                      
   901                                      .convert_loop:
   902 000007D6 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   903 000007D9 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   904 000007DC 80C230                          add dl, '0'     ; Convertir a ASCII
   905 000007DF 52                              push rdx        ; Guardar el dígito
   906 000007E0 48FFC1                          inc rcx         ; Incrementar contador
   907 000007E3 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
   908 000007E6 75EE                            jnz .convert_loop
   909                                          
   910                                      .write_loop:
   911 000007E8 5A                              pop rdx         ; Obtener dígito
   912 000007E9 8817                            mov [rdi], dl   ; Escribir al buffer
   913 000007EB 48FFC7                          inc rdi         ; Siguiente posición
   914 000007EE 48FFC9                          dec rcx         ; Decrementar contador
   915 000007F1 75F5                            jnz .write_loop
   916                                          
   917 000007F3 C60700                      mov byte [rdi], 0   ; Null terminator
   918                                      
   919                                      .end:
   920 000007F6 5E                          pop rsi
   921 000007F7 5A                          pop rdx
   922 000007F8 5B                          pop rbx
   923 000007F9 C3                          ret
   924                                  
   925                                  ; Función para imprimir los labels
   926                                  print_labels:
   927 000007FA 55                          push rbp
   928 000007FB 4889E5                      mov rbp, rsp
   929                                      
   930                                      ; Guardar el score en string
   931 000007FE 488B05(3B150000)            mov rax, [current_score]
   932 00000805 48BF-                       mov rdi, number_buffer
   932 00000807 [4415000000000000] 
   933 0000080F E8A7FFFFFF                  call number_to_string
   934                                      
   935                                      ; Imprimir score label
   936                                      print score_label, score_label_len
    82 00000814 B801000000          <1>  mov eax, sys_write
    83 00000819 BF01000000          <1>  mov edi, 1
    84 0000081E 48BE-               <1>  mov rsi, %1
    84 00000820 [1E15000000000000]  <1>
    85 00000828 BA09000000          <1>  mov edx, %2
    86 0000082D 0F05                <1>  syscall
   937                                      print number_buffer, 20
    82 0000082F B801000000          <1>  mov eax, sys_write
    83 00000834 BF01000000          <1>  mov edi, 1
    84 00000839 48BE-               <1>  mov rsi, %1
    84 0000083B [4415000000000000]  <1>
    85 00000843 BA14000000          <1>  mov edx, %2
    86 00000848 0F05                <1>  syscall
   938                                      
   939                                      ; Nueva línea
   940 0000084A C605(44150000)0A            mov byte [number_buffer], 0xA
   941 00000851 C605(45150000)0D            mov byte [number_buffer + 1], 0xD
   942                                      print number_buffer, 2
    82 00000858 B801000000          <1>  mov eax, sys_write
    83 0000085D BF01000000          <1>  mov edi, 1
    84 00000862 48BE-               <1>  mov rsi, %1
    84 00000864 [4415000000000000]  <1>
    85 0000086C BA02000000          <1>  mov edx, %2
    86 00000871 0F05                <1>  syscall
   943                                      
   944                                      ; Convertir bloques destruidos a string
   945 00000873 480FB605(43150000)          movzx rax, byte [destroyed_blocks]
   946 0000087B 48BF-                       mov rdi, number_buffer
   946 0000087D [4415000000000000] 
   947 00000885 E831FFFFFF                  call number_to_string
   948                                      
   949                                      ; Imprimir label de bloques destruidos
   950                                      print blocks_label, blocks_label_len
    82 0000088A B801000000          <1>  mov eax, sys_write
    83 0000088F BF01000000          <1>  mov edi, 1
    84 00000894 48BE-               <1>  mov rsi, %1
    84 00000896 [2715000000000000]  <1>
    85 0000089E BA14000000          <1>  mov edx, %2
    86 000008A3 0F05                <1>  syscall
   951                                      print number_buffer, 20
    82 000008A5 B801000000          <1>  mov eax, sys_write
    83 000008AA BF01000000          <1>  mov edi, 1
    84 000008AF 48BE-               <1>  mov rsi, %1
    84 000008B1 [4415000000000000]  <1>
    85 000008B9 BA14000000          <1>  mov edx, %2
    86 000008BE 0F05                <1>  syscall
   952                                      
   953                                      ; Nueva línea
   954 000008C0 C605(44150000)0A            mov byte [number_buffer], 0xA
   955 000008C7 C605(45150000)0D            mov byte [number_buffer + 1], 0xD
   956                                      print number_buffer, 2
    82 000008CE B801000000          <1>  mov eax, sys_write
    83 000008D3 BF01000000          <1>  mov edi, 1
    84 000008D8 48BE-               <1>  mov rsi, %1
    84 000008DA [4415000000000000]  <1>
    85 000008E2 BA02000000          <1>  mov edx, %2
    86 000008E7 0F05                <1>  syscall
   957                                      
   958 000008E9 5D                          pop rbp
   959 000008EA C3                          ret
   960                                  
   961                                  ; Función modificada para detectar colisión
   962                                  ; Función mejorada para detectar colisión y manejar la física
   963                                  ; Función corregida para manejar colisiones con bloques completos
   964                                  ;---------------------------------------------------------
   965                                  ; check_block_collision:
   966                                  ;   Detecta si en la posición r10 (que apunta a board[])
   967                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
   968                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
   969                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
   970                                  ;   retorna 0.
   971                                  ;---------------------------------------------------------
   972                                  ;--------------------------------------
   973                                  ; check_block_collision
   974                                  ;--------------------------------------
   975                                  ; Actualizar check_block_collision para usar el nivel actual
   976                                  check_block_collision:
   977 000008EB 55                          push rbp
   978 000008EC 4889E5                      mov rbp, rsp
   979                                  
   980 000008EF 418A02                      mov al, [r10]
   981                                  
   982                                      ; Verificación de caracteres igual que antes...
   983 000008F2 3C55                        cmp al, 'U'  
   984 000008F4 7419                        je .possible
   985 000008F6 3C4F                        cmp al, 'O'  
   986 000008F8 7415                        je .possible
   987 000008FA 3C44                        cmp al, 'D'  
   988 000008FC 7411                        je .possible
   989 000008FE 3C4C                        cmp al, 'L'  
   990 00000900 740D                        je .possible
   991 00000902 3C56                        cmp al, 'V'  
   992 00000904 7409                        je .possible
   993 00000906 3C38                        cmp al, '8'  
   994 00000908 7405                        je .possible
   995                                  
   996 0000090A 4831C0                      xor rax, rax
   997 0000090D 5D                          pop rbp
   998 0000090E C3                          ret
   999                                  
  1000                                      .possible:
  1001 0000090F 53                              push rbx
  1002 00000910 57                              push rdi
  1003 00000911 56                              push rsi
  1004 00000912 4154                            push r12
  1005                                  
  1006                                          ; Obtener puntero a los bloques del nivel actual
  1007 00000914 E873FDFFFF                      call get_current_level_blocks
  1008 00000919 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
  1009                                          
  1010                                          ; Obtener cantidad de bloques del nivel actual
  1011 0000091C E8C4FDFFFF                      call get_current_level_count
  1012 00000921 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
  1013                                  
  1014 00000924 4D31E4                          xor r12, r12
  1015                                      .find_block_loop:
  1016 00000927 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1017 0000092A 0F8DB0000000                    jge .no_block_found
  1018                                  
  1019                                          ; El resto de la lógica de verificación de colisiones...
  1020 00000930 418A9C24[BA140000]              mov bl, [block_states + r12]
  1021 00000938 84DB                            test bl, bl
  1022 0000093A 0F8498000000                    jz .next_block
  1023                                  
  1024                                          ; Usar r13 para acceder a los bloques del nivel actual
  1025 00000940 4C89E8                          mov rax, r13
  1026 00000943 4D6BE404                        imul r12, 4
  1027 00000947 4C01E0                          add rax, r12
  1028 0000094A 8A10                            mov dl, [rax]       ; x
  1029 0000094C 8A4801                          mov cl, [rax+1]     ; y
  1030                                  
  1031                                          ; Revertir r12
  1032 0000094F 4D89E4                          mov r12, r12
  1033 00000952 49C1EC02                        shr r12, 2
  1034                                  
  1035                                          ; La misma lógica de detección de colisiones...
  1036 00000956 488D3D(000A0000)                lea rdi, [board]
  1037 0000095D 4831C0                          xor rax, rax
  1038 00000960 B850000000                      mov rax, column_cells + 2
  1039 00000965 480FB6C9                        movzx rcx, cl
  1040 00000969 480FAFC1                        imul rax, rcx
  1041 0000096D 4801C7                          add rdi, rax
  1042 00000970 480FB6C2                        movzx rax, dl
  1043 00000974 4801C7                          add rdi, rax
  1044                                  
  1045 00000977 4939FA                          cmp r10, rdi
  1046 0000097A 725C                            jb .next_block
  1047 0000097C 488D5F06                        lea rbx, [rdi + 6]
  1048 00000980 4939DA                          cmp r10, rbx
  1049 00000983 7353                            jae .next_block
  1050                                  
  1051                                          ; Manejo de colisión igual que antes...
  1052 00000985 41FE8C24[BA140000]              dec byte [block_states + r12]
  1053 0000098D 418A9C24[BA140000]              mov bl, [block_states + r12]
  1054 00000995 84DB                            test bl, bl
  1055 00000997 7533                            jnz .still_alive
  1056                                  
  1057 00000999 B906000000                      mov rcx, block_length
  1058                                      .erase_block_chars:
  1059 0000099E C60720                          mov byte [rdi], char_space
  1060 000009A1 48FFC7                          inc rdi
  1061 000009A4 E2F8                            loop .erase_block_chars
  1062                                  
  1063 000009A6 FE0D(A5140000)                  dec byte [blocks_remaining]
  1064 000009AC FE05(43150000)                  inc byte [destroyed_blocks]     ; Incrementar contador de bloques destruidos
  1065                                      
  1066                                          ; Calcular puntos basado en la durabilidad original del bloque
  1067 000009B2 4C89E0                          mov rax, r12                    ; Índice del bloque
  1068 000009B5 486BC004                        imul rax, 4                     ; Multiplicar por 4 (tamaño de cada entrada)
  1069 000009B9 4C01E8                          add rax, r13                    ; Agregar base de los bloques
  1070 000009BC 480FB64002                      movzx rax, byte [rax + 2]       ; Obtener tipo de bloque (durabilidad original)
  1071 000009C1 486BC00A                        imul rax, 10                    ; Multiplicar por 10
  1072 000009C5 480105(3B150000)                add [current_score], rax        ; Agregar al score total
  1073                                  
  1074                                      .still_alive:
  1075 000009CC B801000000                      mov rax, 1
  1076 000009D1 415C                            pop r12
  1077 000009D3 5E                              pop rsi
  1078 000009D4 5F                              pop rdi
  1079 000009D5 5B                              pop rbx
  1080 000009D6 5D                              pop rbp
  1081 000009D7 C3                              ret
  1082                                  
  1083                                      .next_block:
  1084 000009D8 49FFC4                          inc r12
  1085 000009DB E947FFFFFF                      jmp .find_block_loop
  1086                                  
  1087                                      .no_block_found:
  1088 000009E0 4831C0                          xor rax, rax
  1089 000009E3 415C                            pop r12
  1090 000009E5 5E                              pop rsi
  1091 000009E6 5F                              pop rdi
  1092 000009E7 5B                              pop rbx
  1093 000009E8 5D                              pop rbp
  1094 000009E9 C3                              ret
  1095                                  
  1096                                  init_enemies:
  1097 000009EA 55                          push rbp
  1098 000009EB 4889E5                      mov rbp, rsp
  1099                                      
  1100                                      ; Limpiar estado previo de enemigos
  1101 000009EE B90F000000                  mov rcx, 15                     ; 5 enemigos * 3 bytes
  1102 000009F3 488D3D(5D150000)            lea rdi, [enemies]
  1103 000009FA 30C0                        xor al, al
  1104 000009FC F3AA                        rep stosb
  1105                                      
  1106                                      ; Configurar enemigo según el nivel actual
  1107 000009FE 480FB60D(A4140000)          movzx rcx, byte [current_level]
  1108 00000A06 48FFC9                      dec rcx                         ; Ajustar para índice base 0
  1109                                      
  1110                                      ; Activar un enemigo
  1111 00000A09 488D3D(5D150000)            lea rdi, [enemies]
  1112                                      
  1113                                      ; Posición X inicial (centro de la pantalla)
  1114 00000A10 C60728                      mov byte [rdi], 40
  1115                                      
  1116                                      ; Posición Y inicial (cerca de la parte superior)
  1117 00000A13 C6470105                    mov byte [rdi + 1], 5
  1118                                      
  1119                                      ; Marcar como activo
  1120 00000A17 C6470201                    mov byte [rdi + 2], 1
  1121                                      
  1122                                      ; Establecer cantidad de enemigos activos
  1123 00000A1B C605(6C150000)01            mov byte [enemies_count], 1
  1124                                      
  1125 00000A22 5D                          pop rbp
  1126 00000A23 C3                          ret
  1127                                  
  1128                                  ; Función para mover enemigos
  1129                                  move_enemies:
  1130 00000A24 55                          push rbp
  1131 00000A25 4889E5                      mov rbp, rsp
  1132                                      
  1133                                      ; Control de velocidad de movimiento
  1134 00000A28 FE05(75150000)              inc byte [enemy_move_counter]
  1135 00000A2E 8A05(75150000)              mov al, [enemy_move_counter]
  1136 00000A34 3A05(76150000)              cmp al, [enemy_move_delay]
  1137 00000A3A 0F8C06010000                jl .end
  1138                                      
  1139                                      ; Resetear contador
  1140 00000A40 C605(75150000)00            mov byte [enemy_move_counter], 0
  1141                                      
  1142                                      ; Iterar sobre enemigos
  1143 00000A47 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1144                                      
  1145                                      .enemy_loop:
  1146 00000A4A 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1147 00000A4E 0F8DF2000000                    jge .end
  1148                                          
  1149                                          ; Calcular offset del enemigo actual
  1150 00000A54 4C89E0                          mov rax, r12
  1151 00000A57 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1152 00000A5B 488DB0[5D150000]                lea rsi, [enemies + rax]
  1153                                          
  1154                                          ; Verificar si el enemigo está activo
  1155 00000A62 807E0201                        cmp byte [rsi + 2], 1
  1156 00000A66 0F85D2000000                    jne .next_enemy
  1157                                          
  1158                                          ; Obtener posición actual del enemigo
  1159 00000A6C 4C0FB606                        movzx r8, byte [rsi]            ; X
  1160 00000A70 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1161                                          
  1162                                          ; Borrar posición actual del enemigo en el tablero
  1163 00000A75 4150                            push r8                         ; Guardar coordenadas actuales
  1164 00000A77 4151                            push r9
  1165                                          
  1166                                          ; Calcular offset en el tablero para borrar
  1167 00000A79 B84E000000                      mov rax, column_cells
  1168 00000A7E 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1169 00000A82 49F7E1                          mul r9
  1170 00000A85 4C01C0                          add rax, r8
  1171 00000A88 488DB8[000A0000]                lea rdi, [board + rax]
  1172 00000A8F C60720                          mov byte [rdi], ' '             ; Borrar posición actual
  1173                                          
  1174 00000A92 4159                            pop r9                          ; Restaurar coordenadas
  1175 00000A94 4158                            pop r8
  1176                                          
  1177                                          ; Calcular dirección hacia la bola
  1178 00000A96 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1179 00000A9D 4D39D0                          cmp r8, r10
  1180 00000AA0 7F12                            jg .move_left
  1181 00000AA2 7C15                            jl .move_right
  1182                                          
  1183                                          ; Movimiento vertical
  1184 00000AA4 4C8B15(57140000)                mov r10, [ball_y_pos]
  1185 00000AAB 4D39D1                          cmp r9, r10
  1186 00000AAE 7F0E                            jg .move_up
  1187 00000AB0 7C11                            jl .move_down
  1188 00000AB2 EB22                            jmp .check_collision
  1189                                          
  1190                                      .move_left:
  1191 00000AB4 49FFC8                          dec r8
  1192 00000AB7 EB0F                            jmp .check_vertical
  1193                                          
  1194                                      .move_right:
  1195 00000AB9 49FFC0                          inc r8
  1196 00000ABC EB0A                            jmp .check_vertical
  1197                                          
  1198                                      .move_up:
  1199 00000ABE 49FFC9                          dec r9
  1200 00000AC1 EB13                            jmp .check_collision
  1201                                          
  1202                                      .move_down:
  1203 00000AC3 49FFC1                          inc r9
  1204 00000AC6 EB0E                            jmp .check_collision
  1205                                          
  1206                                      .check_vertical:
  1207 00000AC8 4C8B15(57140000)                mov r10, [ball_y_pos]
  1208 00000ACF 4D39D1                          cmp r9, r10
  1209 00000AD2 7FEA                            jg .move_up
  1210 00000AD4 7CED                            jl .move_down
  1211                                          
  1212                                      .check_collision:
  1213                                          ; Verificar colisión con bordes
  1214 00000AD6 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1215 00000ADA 7E62                            jle .next_enemy
  1216 00000ADC 4983F84E                        cmp r8, column_cells
  1217 00000AE0 7D5C                            jge .next_enemy
  1218 00000AE2 4983F901                        cmp r9, 1                       ; Borde superior
  1219 00000AE6 7E56                            jle .next_enemy
  1220 00000AE8 4983F920                        cmp r9, row_cells
  1221 00000AEC 7D50                            jge .next_enemy
  1222                                          
  1223                                          ; Verificar colisión con bloques antes de moverse
  1224 00000AEE 4150                            push r8
  1225 00000AF0 4151                            push r9
  1226 00000AF2 4152                            push r10
  1227                                          
  1228                                          ; Calcular posición en el tablero para verificar
  1229 00000AF4 B84E000000                      mov rax, column_cells
  1230 00000AF9 4883C002                        add rax, 2
  1231 00000AFD 49F7E1                          mul r9
  1232 00000B00 4C01C0                          add rax, r8
  1233 00000B03 4C8D90[000A0000]                lea r10, [board + rax]
  1234                                          
  1235                                          ; Verificar si hay un bloque en la nueva posición
  1236 00000B0A 418A02                          mov al, [r10]
  1237 00000B0D 3C55                            cmp al, 'U'
  1238 00000B0F 7427                            je .invalid_move
  1239 00000B11 3C4F                            cmp al, 'O'
  1240 00000B13 7423                            je .invalid_move
  1241 00000B15 3C44                            cmp al, 'D'
  1242 00000B17 741F                            je .invalid_move
  1243 00000B19 3C4C                            cmp al, 'L'
  1244 00000B1B 741B                            je .invalid_move
  1245 00000B1D 3C56                            cmp al, 'V'
  1246 00000B1F 7417                            je .invalid_move
  1247 00000B21 3C38                            cmp al, '8'
  1248 00000B23 7413                            je .invalid_move
  1249 00000B25 3C58                            cmp al, 'X'
  1250 00000B27 740F                            je .invalid_move
  1251                                          
  1252 00000B29 415A                            pop r10
  1253 00000B2B 4159                            pop r9
  1254 00000B2D 4158                            pop r8
  1255                                          
  1256                                          ; Guardar nueva posición si es válida
  1257 00000B2F 448806                          mov [rsi], r8b
  1258 00000B32 44884E01                        mov [rsi + 1], r9b
  1259 00000B36 EB06                            jmp .next_enemy
  1260                                          
  1261                                      .invalid_move:
  1262 00000B38 415A                            pop r10
  1263 00000B3A 4159                            pop r9
  1264 00000B3C 4158                            pop r8
  1265                                          
  1266                                      .next_enemy:
  1267 00000B3E 49FFC4                          inc r12
  1268 00000B41 E904FFFFFF                      jmp .enemy_loop
  1269                                          
  1270                                      .end:
  1271 00000B46 5D                              pop rbp
  1272 00000B47 C3                              ret
  1273                                  
  1274                                  ; Función para dibujar enemigos
  1275                                  print_enemies:
  1276 00000B48 55                          push rbp
  1277 00000B49 4889E5                      mov rbp, rsp
  1278                                      
  1279 00000B4C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1280                                      
  1281                                      .print_loop:
  1282 00000B4F 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1283 00000B53 7D4B                            jge .end
  1284                                          
  1285                                          ; Calcular offset del enemigo actual
  1286 00000B55 4C89E0                          mov rax, r12
  1287 00000B58 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1288 00000B5C 488DB0[5D150000]                lea rsi, [enemies + rax]
  1289                                          
  1290                                          ; Verificar si el enemigo está activo
  1291 00000B63 807E0201                        cmp byte [rsi + 2], 1
  1292 00000B67 7532                            jne .next_enemy
  1293                                          
  1294                                          ; Calcular posición en el tablero
  1295 00000B69 4C0FB606                        movzx r8, byte [rsi]            ; X
  1296 00000B6D 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1297                                          
  1298                                          ; Calcular offset en el tablero
  1299 00000B72 B84E000000                      mov rax, column_cells
  1300 00000B77 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1301 00000B7B 49F7E1                          mul r9
  1302 00000B7E 4C01C0                          add rax, r8
  1303 00000B81 488DB8[000A0000]                lea rdi, [board + rax]
  1304                                          
  1305                                          ; Obtener carácter del enemigo según el nivel
  1306 00000B88 480FB605(A4140000)              movzx rax, byte [current_level]
  1307 00000B90 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1308 00000B93 8A80[58150000]                  mov al, [enemy_chars + rax]
  1309                                          
  1310                                          ; Dibujar enemigo
  1311 00000B99 8807                            mov [rdi], al
  1312                                          
  1313                                      .next_enemy:
  1314 00000B9B 49FFC4                          inc r12
  1315 00000B9E EBAF                            jmp .print_loop
  1316                                          
  1317                                      .end:
  1318 00000BA0 5D                              pop rbp
  1319 00000BA1 C3                              ret
  1320                                  
  1321                                  ; Función para verificar colisión con enemigos
  1322                                  ; Función para verificar colisión con enemigos
  1323                                  check_enemy_collision:
  1324 00000BA2 55                          push rbp
  1325 00000BA3 4889E5                      mov rbp, rsp
  1326                                      
  1327 00000BA6 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1328 00000BA9 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1329                                      
  1330                                      .check_loop:
  1331 00000BAC 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1332 00000BB0 0F8DDF000000                    jge .end
  1333                                          
  1334                                          ; Calcular offset del enemigo actual
  1335 00000BB6 4C89E1                          mov rcx, r12
  1336 00000BB9 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1337 00000BBD 488DB1[5D150000]                lea rsi, [enemies + rcx]
  1338                                          
  1339                                          ; Verificar si el enemigo está activo
  1340 00000BC4 807E0201                        cmp byte [rsi + 2], 1
  1341 00000BC8 0F85BF000000                    jne .next_enemy
  1342                                          
  1343                                          ; Verificar colisión con la bola
  1344 00000BCE 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1345 00000BD2 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1346                                          
  1347                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1348 00000BD7 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1349 00000BDE 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1350                                          
  1351                                          ; Comprobar colisión vertical (misma columna)
  1352 00000BE5 4D39C2                          cmp r10, r8
  1353 00000BE8 7525                            jne .check_horizontal
  1354 00000BEA 4D29CB                          sub r11, r9
  1355 00000BED 4983FB01                        cmp r11, 1
  1356 00000BF1 7F1C                            jg .check_horizontal
  1357 00000BF3 4983FBFF                        cmp r11, -1
  1358 00000BF7 7C16                            jl .check_horizontal
  1359                                          
  1360                                          ; Colisión vertical detectada
  1361 00000BF9 E899000000                      call destroy_enemy
  1362 00000BFE 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1363 00000C05 B801000000                      mov rax, 1
  1364 00000C0A E986000000                      jmp .end
  1365                                          
  1366                                          .check_horizontal:
  1367                                              ; Comprobar colisión horizontal (misma fila)
  1368 00000C0F 4C8B15(4F140000)                    mov r10, [ball_x_pos]
  1369 00000C16 4C8B1D(57140000)                    mov r11, [ball_y_pos]
  1370 00000C1D 4D39CB                              cmp r11, r9
  1371 00000C20 7522                                jne .check_paddle
  1372 00000C22 4D29C2                              sub r10, r8
  1373 00000C25 4983FA01                            cmp r10, 1
  1374 00000C29 7F19                                jg .check_paddle
  1375 00000C2B 4983FAFF                            cmp r10, -1
  1376 00000C2F 7C13                                jl .check_paddle
  1377                                              
  1378                                              ; Colisión horizontal detectada
  1379 00000C31 E861000000                          call destroy_enemy
  1380 00000C36 48F71D(5F140000)                    neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1381 00000C3D B801000000                          mov rax, 1
  1382 00000C42 EB51                                jmp .end
  1383                                          
  1384                                      .check_paddle:
  1385                                          ; Verificar colisión con la paleta
  1386 00000C44 4C8B15(3F140000)                mov r10, [pallet_position]
  1387 00000C4B 4981EA[000A0000]                sub r10, board
  1388 00000C52 41BB4E000000                    mov r11, column_cells
  1389 00000C58 4983C302                        add r11, 2
  1390 00000C5C 4831D2                          xor rdx, rdx
  1391 00000C5F 49F7F3                          div r11
  1392 00000C62 4989D3                          mov r11, rdx                    ; X de la paleta
  1393                                          
  1394 00000C65 4D39D8                          cmp r8, r11
  1395 00000C68 7C23                            jl .next_enemy
  1396                                          
  1397 00000C6A 488B0D(47140000)                mov rcx, [pallet_size]
  1398 00000C71 4901CB                          add r11, rcx
  1399 00000C74 4D39D8                          cmp r8, r11
  1400 00000C77 7F14                            jg .next_enemy
  1401                                          
  1402 00000C79 41BB20000000                    mov r11, row_cells
  1403 00000C7F 4983EB02                        sub r11, 2                      ; Y de la paleta
  1404 00000C83 4D39D9                          cmp r9, r11
  1405 00000C86 7505                            jne .next_enemy
  1406                                          
  1407                                          ; Colisión con la paleta detectada
  1408 00000C88 E80A000000                      call destroy_enemy
  1409                                          
  1410                                      .next_enemy:
  1411 00000C8D 49FFC4                          inc r12
  1412 00000C90 E917FFFFFF                      jmp .check_loop
  1413                                          
  1414                                      .end:
  1415 00000C95 5D                              pop rbp
  1416 00000C96 C3                              ret
  1417                                  
  1418                                  ; Función para destruir un enemigo
  1419                                  destroy_enemy:
  1420                                      ; Desactivar enemigo
  1421 00000C97 C6460200                    mov byte [rsi + 2], 0
  1422                                      
  1423                                      ; Sumar puntos
  1424 00000C9B 488B05(6D150000)            mov rax, [enemy_points]
  1425 00000CA2 480105(3B150000)            add [current_score], rax
  1426                                      
  1427 00000CA9 C3                          ret
  1428                                  
  1429                                  _start:
  1430 00000CAA E87CF4FFFF              	call canonical_off
  1431 00000CAF E8DA000000              	call start_screen
  1432 00000CB4 E89FF7FFFF                  call init_level
  1433 00000CB9 E82CFDFFFF                  call init_enemies
  1434 00000CBE EB00                    	jmp .main_loop
  1435                                  	
  1436                                  
  1437                                  	.main_loop:
  1438 00000CC0 E835FBFFFF                      call print_labels
  1439 00000CC5 E83BF5FFFF              		call print_pallet
  1440 00000CCA E8C6F5FFFF                      call move_ball
  1441 00000CCF E860FAFFFF                      call print_blocks
  1442 00000CD4 E8BDF8FFFF                      call check_level_complete
  1443 00000CD9 E846FDFFFF                      call move_enemies
  1444 00000CDE E8BFFEFFFF                      call check_enemy_collision
  1445 00000CE3 E860FEFFFF                      call print_enemies
  1446 00000CE8 E8F0F4FFFF              		call print_ball
  1447                                  		print board, board_size				
    82 00000CED B801000000          <1>  mov eax, sys_write
    83 00000CF2 BF01000000          <1>  mov edi, 1
    84 00000CF7 48BE-               <1>  mov rsi, %1
    84 00000CF9 [000A000000000000]  <1>
    85 00000D01 BA000A0000          <1>  mov edx, %2
    86 00000D06 0F05                <1>  syscall
  1448                                  		;setnonblocking	
  1449                                  	.read_more:	
  1450                                  		getchar	
    90 00000D08 B800000000          <1>  mov rax, sys_read
    91 00000D0D BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000D12 48BE-               <1>  mov rsi, input_char
    92 00000D14 [0000000000000000]  <1>
    93 00000D1C BA01000000          <1>  mov rdx, 1
    94 00000D21 0F05                <1>  syscall
  1451                                  		
  1452 00000D23 4883F801                		cmp rax, 1
  1453 00000D27 7532                        	jne .done
  1454                                  		
  1455 00000D29 8A05(00000000)          		mov al,[input_char]
  1456                                  
  1457 00000D2F 3C61                    		cmp al, 'a'
  1458 00000D31 750E                    	    jne .not_left
  1459 00000D33 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1460 00000D3A E8E1F4FFFF              		call move_pallet
  1461 00000D3F EB1A                    	    jmp .done
  1462                                  		
  1463                                  		.not_left:
  1464 00000D41 3C64                    		 	cmp al, 'd'
  1465 00000D43 750C                    	    	jne .not_right
  1466 00000D45 BF01000000              			mov rdi, right_direction
  1467 00000D4A E8D1F4FFFF              	    	call move_pallet
  1468 00000D4F EB0A                        		jmp .done		
  1469                                  
  1470                                  		.not_right:
  1471                                  
  1472 00000D51 3C71                        		cmp al, 'q'
  1473 00000D53 0F84A8000000                		je exit
  1474                                  
  1475 00000D59 EBAD                    			jmp .read_more
  1476                                  		
  1477                                  		.done:	
  1478                                  			;unsetnonblocking		
  1479                                  			sleeptime	
    98 00000D5B B823000000          <1>  mov eax, sys_nanosleep
    99 00000D60 48BF-               <1>  mov rdi, timespec
    99 00000D62 [0000000000000000]  <1>
   100 00000D6A 31F6                <1>  xor esi, esi
   101 00000D6C 0F05                <1>  syscall
  1480                                  			print clear, clear_length
    82 00000D6E B801000000          <1>  mov eax, sys_write
    83 00000D73 BF01000000          <1>  mov edi, 1
    84 00000D78 48BE-               <1>  mov rsi, %1
    84 00000D7A [1000000000000000]  <1>
    85 00000D82 BA07000000          <1>  mov edx, %2
    86 00000D87 0F05                <1>  syscall
  1481 00000D89 E932FFFFFF                  		jmp .main_loop
  1482                                  
  1483                                  
  1484                                  
  1485                                  start_screen:
  1486                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000D8E B801000000          <1>  mov eax, sys_write
    83 00000D93 BF01000000          <1>  mov edi, 1
    84 00000D98 48BE-               <1>  mov rsi, %1
    84 00000D9A [1000000000000000]  <1>
    85 00000DA2 BA07000000          <1>  mov edx, %2
    86 00000DA7 0F05                <1>  syscall
  1487                                      print msg1, msg1_length
    82 00000DA9 B801000000          <1>  mov eax, sys_write
    83 00000DAE BF01000000          <1>  mov edi, 1
    84 00000DB3 48BE-               <1>  mov rsi, %1
    84 00000DB5 [1700000000000000]  <1>
    85 00000DBD BA14010000          <1>  mov edx, %2
    86 00000DC2 0F05                <1>  syscall
  1488                                      
  1489                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1490                                          getchar                 ; Esperamos una tecla
    90 00000DC4 B800000000          <1>  mov rax, sys_read
    91 00000DC9 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000DCE 48BE-               <1>  mov rsi, input_char
    92 00000DD0 [0000000000000000]  <1>
    93 00000DD8 BA01000000          <1>  mov rdx, 1
    94 00000DDD 0F05                <1>  syscall
  1491 00000DDF 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1492 00000DE3 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1493                                          
  1494                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000DE5 B801000000          <1>  mov eax, sys_write
    83 00000DEA BF01000000          <1>  mov edi, 1
    84 00000DEF 48BE-               <1>  mov rsi, %1
    84 00000DF1 [1000000000000000]  <1>
    85 00000DF9 BA07000000          <1>  mov edx, %2
    86 00000DFE 0F05                <1>  syscall
  1495 00000E00 C3                          ret
  1496                                  
  1497                                  exit: 
  1498 00000E01 E867F3FFFF              	call canonical_on
  1499 00000E06 B83C000000              	mov    rax, 60
  1500 00000E0B BF00000000                  mov    rdi, 0
  1501 00000E10 0F05                        syscall
  1502                                  
