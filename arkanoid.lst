     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 3807030253                      db 56, 7, 3, 2, 'S'    ; Bloque 7
   288 000014AB 3D09030153                      db 61, 9, 3, 1, 'S'    ; Bloque 7
   289 000014B0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014BA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014C4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 0000152D 0000000000000000            current_score dq 0          ; Score actual
   319 00001535 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 00001536 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 0000154A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 0000154F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 0000156D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 0000156E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 00001576 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001577 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   333 00001578 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001579 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 0000157A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 0000157B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 00001584 12                 
   339 00001585 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 0000158E 13                 
   340 0000158F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001598 1B                 
   341 00001599 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 000015A2 1C                 
   342 000015A3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015AC 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015AD [7B15000000000000]              dq level1_spawn_points
   346 000015B5 [8515000000000000]              dq level2_spawn_points
   347 000015BD [8F15000000000000]              dq level3_spawn_points
   348 000015C5 [9915000000000000]              dq level4_spawn_points
   349 000015CD [A315000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015D5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015D6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015E2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015EB 5B2020202020202020-
   357 000015F4 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F9 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 00001602 657374727569646F73-
   359 0000160B 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365                                      
   366                                      ; Definición de las vidas (x, y, estado)
   367                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   368                                      lives_data: 
   369 00001614 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   370 00001617 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   371 0000161A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   372 0000161D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   373 00001620 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   374 00001623 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   375 00001626 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   376                                      lives_count equ 7    ; Total de vidas
   377 00001629 5E                          life_char db "^"    
   378 0000162A 07                          current_lives db 7   ; Contador de vidas activas actual
   379                                  
   380                                  ; Estructura para almacenar las letras y sus posiciones
   381                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   382 0000162B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   383 000017BB 00                          letters_count db 0   
   384                                  
   385                                  section .text
   386                                  
   387                                  ;	Function: print_ball
   388                                  ; This function displays the position of the ball
   389                                  ; Arguments: none
   390                                  ;
   391                                  ; Return:
   392                                  ;	Void
   393                                  
   394                                  ; Función para imprimir las vidas
   395                                  ; Función modificada para imprimir las vidas
   396                                  print_lives:
   397 000001DD 55                          push rbp
   398 000001DE 4889E5                      mov rbp, rsp
   399                                      
   400 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   401                                      
   402                                      .print_loop:
   403 000001E4 4983FC07                        cmp r12, lives_count
   404 000001E8 7D45                            jge .end
   405                                          
   406                                          ; Calcular offset de la vida actual
   407 000001EA 4C89E0                          mov rax, r12
   408 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   409 000001F1 488DB0[14160000]                lea rsi, [lives_data + rax]
   410                                          
   411                                          ; Calcular posición en el tablero
   412 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   413 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   414                                          
   415                                          ; Calcular offset en el tablero
   416 00000201 B84E000000                      mov rax, column_cells
   417 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   418 0000020A 49F7E1                          mul r9
   419 0000020D 4C01C0                          add rax, r8
   420 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   421                                          
   422                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   423 00000217 807E0201                        cmp byte [rsi + 2], 1
   424 0000021B 7405                            je .draw_active
   425                                          
   426                                          ; Si está inactiva, dibujar espacio
   427 0000021D C60720                          mov byte [rdi], ' '
   428 00000220 EB08                            jmp .next_life
   429                                          
   430                                      .draw_active:
   431                                          ; Si está activa, dibujar el símbolo de vida
   432 00000222 8A05(29160000)                  mov al, [life_char]
   433 00000228 8807                            mov [rdi], al
   434                                          
   435                                      .next_life:
   436 0000022A 49FFC4                          inc r12
   437 0000022D EBB5                            jmp .print_loop
   438                                          
   439                                      .end:
   440 0000022F 5D                              pop rbp
   441 00000230 C3                              ret
   442                                  
   443                                  ; Función para desactivar una vida
   444                                  ; Función modificada para perder una vida
   445                                  lose_life:
   446 00000231 55                          push rbp
   447 00000232 4889E5                      mov rbp, rsp
   448                                      
   449                                      ; Verificar si aún quedan vidas
   450 00000235 803D(2A160000)00            cmp byte [current_lives], 0
   451 0000023C 0F8493000000                je .game_lost
   452                                      
   453                                      ; Encontrar la última vida activa
   454 00000242 B907000000                  mov rcx, lives_count
   455 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   456                                      
   457                                      .find_active_life:
   458 0000024A 4889C8                          mov rax, rcx
   459 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   460 00000251 488DB0[14160000]                lea rsi, [lives_data + rax]
   461 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   462 0000025C 7407                            je .deactivate_life
   463 0000025E 48FFC9                          dec rcx
   464 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   465 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   466                                          
   467                                      .deactivate_life:
   468                                          ; Calcular posición correcta en el tablero para borrar la vida
   469 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   470 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   471                                          
   472                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   473 0000026E B84E000000                      mov rax, column_cells
   474 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   475 00000277 49F7E1                          mul r9
   476 0000027A 4C01C0                          add rax, r8
   477 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   478                                          
   479                                          ; Borrar visualmente la vida
   480 00000284 C60720                          mov byte [rdi], ' '             
   481                                          
   482                                          ; Desactivar la vida en los datos
   483 00000287 C6460200                        mov byte [rsi + 2], 0          
   484 0000028B FE0D(2A160000)                  dec byte [current_lives]
   485                                          
   486                                          ; Borrar visualmente la paleta anterior
   487 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   488 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   489                                          .erase_pallet_loop:
   490 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   491 000002A3 49FFC0                              inc r8
   492 000002A6 48FFC9                              dec rcx
   493 000002A9 75F4                                jnz .erase_pallet_loop
   494                                          
   495                                  
   496                                          ; Reiniciar posición de la bola y la paleta
   497 000002AB 48C705(4F140000)28-             mov qword [ball_x_pos], 40
   497 000002B3 000000             
   498 000002B6 48C705(57140000)1C-             mov qword [ball_y_pos], 28
   498 000002BE 000000             
   499 000002C1 C605(6F140000)00                mov byte [ball_moving], 0
   500 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   500 000002CF [36130000]         
   501                                          
   502 000002D3 EB07                            jmp .end
   503                                          
   504                                      .game_lost:
   505 000002D5 E81C000000                      call game_lost
   506 000002DA EB00                            jmp .end
   507                                          
   508                                      .end:
   509 000002DC 5D                              pop rbp
   510 000002DD C3                              ret
   511                                  ; Función modificada para verificar colisión con el borde inferior
   512                                  check_bottom_collision:
   513 000002DE 55                          push rbp
   514 000002DF 4889E5                      mov rbp, rsp
   515                                      
   516                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   517 000002E2 488B05(57140000)            mov rax, [ball_y_pos]
   518 000002E9 4883F81E                    cmp rax, row_cells - 2
   519 000002ED 7505                        jne .no_collision
   520                                      
   521                                      ; Si hay colisión, perder una vida
   522 000002EF E83DFFFFFF                  call lose_life
   523                                      
   524                                      .no_collision:
   525 000002F4 5D                              pop rbp
   526 000002F5 C3                              ret
   527                                  
   528                                  ; Nueva función para game over
   529                                  game_lost:
   530                                      ; Limpiar la pantalla
   531                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   532                                      
   533                                      ; Mostrar mensaje de derrota
   534                                      section .data
   535 000017BC C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   535 000017C5 6469646F210A0D     
   536                                          lost_msg_len: equ $ - lost_msg
   537                                      section .text
   538                                      
   539                                      ; Imprimir mensaje de derrota
   540                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [BC17000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   541                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [EA17000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   542                                      
   543                                      ; Mostrar puntaje final
   544 00000347 488B05(2D150000)            mov rax, [current_score]
   545 0000034E 48BF-                       mov rdi, number_buffer
   545 00000350 [3615000000000000] 
   546 00000358 E890070000                  call number_to_string
   547                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [3615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   548                                      
   549                                      ; Esperar un momento antes de salir
   550 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   550 00000381 0000               
   551 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   551 0000038C 0000               
   552                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   553                                      
   554 000003A1 E9250F0000                  jmp exit
   555                                  
   556                                  
   557                                  ; Función para registrar una nueva letra en el mapa
   558                                  ; Entrada:
   559                                  ;   al - letra a registrar
   560                                  ;   r8b - posición x
   561                                  ;   r9b - posición y
   562                                  register_letter:
   563 000003A6 55                          push rbp
   564 000003A7 4889E5                      mov rbp, rsp
   565 000003AA 53                          push rbx
   566 000003AB 51                          push rcx
   567                                      
   568                                      ; Encontrar un espacio libre en el mapa
   569 000003AC 4831C9                      xor rcx, rcx
   570 000003AF 480FB615(BB170000)          movzx rdx, byte [letters_count]
   571                                      
   572                                      .find_slot:
   573 000003B7 4883F964                        cmp rcx, 100              ; Máximo de letras
   574 000003BB 7D27                            jge .end                  ; Si no hay espacio, salir
   575                                          
   576 000003BD 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   577 000003C5 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   578 000003C9 7405                            je .found_slot
   579                                          
   580 000003CB 48FFC1                          inc rcx
   581 000003CE EBE7                            jmp .find_slot
   582                                          
   583                                      .found_slot:
   584                                          ; Guardar la información de la letra
   585 000003D0 448803                          mov [rbx], r8b           ; x
   586 000003D3 44884B01                        mov [rbx + 1], r9b       ; y
   587 000003D7 884302                          mov [rbx + 2], al        ; letra
   588 000003DA C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   589                                          
   590 000003DE FE05(BB170000)                  inc byte [letters_count]
   591                                          
   592                                      .end:
   593 000003E4 59                              pop rcx
   594 000003E5 5B                              pop rbx
   595 000003E6 5D                              pop rbp
   596 000003E7 C3                              ret
   597                                  
   598                                  ; Función para imprimir todas las letras registradas
   599                                  print_letters:
   600 000003E8 55                          push rbp
   601 000003E9 4889E5                      mov rbp, rsp
   602 000003EC 53                          push rbx
   603 000003ED 51                          push rcx
   604                                      
   605 000003EE 4831C9                      xor rcx, rcx
   606                                      
   607                                      .print_loop:
   608 000003F1 4883F964                        cmp rcx, 100              ; Máximo de letras
   609 000003F5 7D37                            jge .end
   610                                          
   611                                          ; Obtener puntero a la letra actual
   612 000003F7 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   613                                          
   614                                          ; Verificar si está activa
   615 000003FF 807B0300                        cmp byte [rbx + 3], 0
   616 00000403 7424                            je .next_letter
   617                                          
   618                                          ; Calcular posición en el tablero
   619 00000405 4C0FB603                        movzx r8, byte [rbx]      ; x
   620 00000409 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   621                                          
   622                                          ; Calcular offset en el tablero
   623 0000040E B84E000000                      mov rax, column_cells
   624 00000413 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   625 00000417 49F7E1                          mul r9
   626 0000041A 4C01C0                          add rax, r8
   627 0000041D 488DB8[000A0000]                lea rdi, [board + rax]
   628                                          
   629                                          ; Imprimir la letra
   630 00000424 8A4302                          mov al, [rbx + 2]
   631 00000427 8807                            mov [rdi], al
   632                                          
   633                                      .next_letter:
   634 00000429 48FFC1                          inc rcx
   635 0000042C EBC3                            jmp .print_loop
   636                                          
   637                                      .end:
   638 0000042E 59                              pop rcx
   639 0000042F 5B                              pop rbx
   640 00000430 5D                              pop rbp
   641 00000431 C3                              ret
   642                                  
   643                                  ; Función para borrar una letra específica
   644                                  ; Entrada:
   645                                  ;   r8b - posición x
   646                                  ;   r9b - posición y
   647                                  remove_letter:
   648 00000432 55                          push rbp
   649 00000433 4889E5                      mov rbp, rsp
   650 00000436 53                          push rbx
   651 00000437 51                          push rcx
   652                                      
   653 00000438 4831C9                      xor rcx, rcx
   654                                      
   655                                      .find_loop:
   656 0000043B 4883F964                        cmp rcx, 100              ; Máximo de letras
   657 0000043F 7D2E                            jge .end
   658                                          
   659 00000441 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   660                                          
   661                                          ; Verificar si está activa y coincide la posición
   662 00000449 807B0300                        cmp byte [rbx + 3], 0
   663 0000044D 741B                            je .next_letter
   664                                          
   665 0000044F 8A03                            mov al, [rbx]
   666 00000451 4438C0                          cmp al, r8b
   667 00000454 7514                            jne .next_letter
   668                                          
   669 00000456 8A4301                          mov al, [rbx + 1]
   670 00000459 4438C8                          cmp al, r9b
   671 0000045C 750C                            jne .next_letter
   672                                          
   673                                          ; Encontrada la letra, desactivarla
   674 0000045E C6430300                        mov byte [rbx + 3], 0
   675 00000462 FE0D(BB170000)                  dec byte [letters_count]
   676 00000468 EB05                            jmp .end
   677                                          
   678                                      .next_letter:
   679 0000046A 48FFC1                          inc rcx
   680 0000046D EBCC                            jmp .find_loop
   681                                          
   682                                      .end:
   683 0000046F 59                              pop rcx
   684 00000470 5B                              pop rbx
   685 00000471 5D                              pop rbp
   686 00000472 C3                              ret
   687                                  ; Función para mover las letras hacia abajo
   688                                  move_letters:
   689 00000473 55                          push rbp
   690 00000474 4889E5                      mov rbp, rsp
   691 00000477 53                          push rbx
   692 00000478 57                          push rdi
   693 00000479 56                          push rsi
   694                                  
   695 0000047A 4831C9                      xor rcx, rcx                    ; Índice de la letra actual
   696                                  
   697                                      .move_loop:
   698 0000047D 4883F964                        cmp rcx, 100                ; Máximo 100 letras
   699 00000481 7D70                            jge .end                    ; Salir si todas las letras fueron procesadas
   700                                  
   701                                          ; Obtener puntero a la letra actual
   702 00000483 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   703                                  
   704                                          ; Verificar si la letra está activa
   705 0000048B 807B0300                        cmp byte [rbx + 3], 0
   706 0000048F 745D                            je .next_letter
   707                                  
   708                                          ; Obtener la posición actual de la letra
   709 00000491 4C0FB603                        movzx r8, byte [rbx]        ; X
   710 00000495 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; Y
   711                                  
   712                                          ; Calcular la posición en el tablero para borrar la letra anterior
   713 0000049A B84E000000                      mov rax, column_cells
   714 0000049F 4883C002                        add rax, 2                  ; Incluye caracteres de nueva línea
   715 000004A3 49F7E1                          mul r9
   716 000004A6 4C01C0                          add rax, r8
   717 000004A9 488DB8[000A0000]                lea rdi, [board + rax]
   718 000004B0 C60720                          mov byte [rdi], ' '         ; Borra la letra en la posición anterior
   719                                  
   720                                          ; Incrementar la posición Y de la letra
   721 000004B3 FE4301                          inc byte [rbx + 1]
   722 000004B6 4C0FB64B01                      movzx r9, byte [rbx + 1]
   723                                  
   724                                          ; Verificar si la letra alcanzó el final del tablero
   725 000004BB 4983F91F                        cmp r9, row_cells - 1
   726 000004BF 7C06                            jl .check_pallet_collision
   727                                  
   728                                          ; Desactivar la letra si llega al final
   729 000004C1 C6430300                        mov byte [rbx + 3], 0
   730 000004C5 EB27                            jmp .next_letter
   731                                  
   732                                          .check_pallet_collision:
   733                                              ; Calcular la nueva posición en el tablero
   734 000004C7 B84E000000                          mov rax, column_cells
   735 000004CC 4883C002                            add rax, 2
   736 000004D0 49F7E1                              mul r9
   737 000004D3 4C01C0                              add rax, r8
   738 000004D6 488DB8[000A0000]                    lea rdi, [board + rax]
   739                                  
   740                                              ; Verificar si hay colisión con la paleta (símbolo =)
   741 000004DD 8A07                                mov al, [rdi]
   742 000004DF 3C3D                                cmp al, char_equal
   743 000004E1 7407                                je .destroy_letter
   744                                  
   745                                              ; Si no hay colisión, dibujar la letra
   746 000004E3 8A4302                              mov al, [rbx + 2]
   747 000004E6 8807                                mov [rdi], al
   748 000004E8 EB04                                jmp .next_letter
   749                                  
   750                                          .destroy_letter:
   751                                              ; Desactivar la letra si toca la paleta
   752 000004EA C6430300                            mov byte [rbx + 3], 0
   753                                  
   754                                          .next_letter:
   755 000004EE 48FFC1                              inc rcx
   756 000004F1 EB8A                                jmp .move_loop
   757                                  
   758                                      .end:
   759 000004F3 5E                              pop rsi
   760 000004F4 5F                              pop rdi
   761 000004F5 5B                              pop rbx
   762 000004F6 5D                              pop rbp
   763 000004F7 C3                              ret
   764                                  
   765                                  print_ball:
   766 000004F8 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   767 000004FF 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   768 00000506 4981C0[000A0000]        	add r8, board
   769                                  
   770 0000050D 4C89C9                  	mov rcx, r9
   771 00000510 B850000000              	mov rax, column_cells + 2
   772 00000515 48F7E9                  	imul rcx
   773                                  	
   774 00000518 4901C0                  	add r8, rax
   775 0000051B 41C6004F                	mov byte [r8], char_O
   776 0000051F C3                      	ret
   777                                  
   778                                  	
   779                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   780                                  	
   781                                  
   782                                  
   783                                  
   784                                  ;	Function: print_pallet
   785                                  ; This function moves the pallet in the game
   786                                  ; Arguments: none
   787                                  ;
   788                                  ; Return;
   789                                  ;	void
   790                                  print_pallet:
   791 00000520 4C8B05(3F140000)        	mov r8, [pallet_position]
   792 00000527 488B0D(47140000)        	mov rcx, [pallet_size]
   793                                  	.write_pallet:
   794 0000052E 41C6003D                		mov byte [r8], char_equal
   795 00000532 49FFC0                  		inc r8
   796 00000535 48FFC9                  		dec rcx
   797 00000538 75F4                    		jnz .write_pallet
   798                                  
   799 0000053A C3                      	ret
   800                                  	
   801                                  ;	Function: move_pallet
   802                                  ; This function is in charge of moving the pallet in a given direction
   803                                  ; Arguments:
   804                                  ;	rdi: left direction or right direction
   805                                  ;
   806                                  ; Return:
   807                                  ;	void
   808                                  move_pallet:
   809                                      
   810 0000053B 803D(6F140000)00            cmp byte [ball_moving], 0
   811 00000542 7507                        jne .continue_movement
   812 00000544 C605(6F140000)01            mov byte [ball_moving], 1
   813                                  
   814                                      .continue_movement:
   815 0000054B 4883FFFF                        cmp rdi, left_direction
   816 0000054F 7531                            jne .move_right
   817                                  
   818                                          .move_left:
   819                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   820 00000551 4C8B05(3F140000)                    mov r8, [pallet_position]
   821 00000558 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   822 0000055B 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   823 0000055E 3C58                                cmp al, 'X'        ; Comparar si es una X
   824 00000560 744D                                je .end            ; Si es X, no mover
   825                                              
   826 00000562 4C8B05(3F140000)                    mov r8, [pallet_position]
   827 00000569 4C8B0D(47140000)                    mov r9, [pallet_size]
   828 00000570 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   829 00000576 49FFC8                              dec r8
   830 00000579 4C8905(3F140000)                    mov [pallet_position], r8
   831 00000580 EB2D                                jmp .end
   832                                              
   833                                          .move_right:
   834                                              ; Verificar si la siguiente posición después de la paleta sería una X
   835 00000582 4C8B05(3F140000)                    mov r8, [pallet_position]
   836 00000589 4C8B0D(47140000)                    mov r9, [pallet_size]
   837 00000590 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   838 00000593 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   839 00000596 3C58                                cmp al, 'X'        ; Comparar si es una X
   840 00000598 7415                                je .end            ; Si es X, no mover
   841                                              
   842 0000059A 4C8B05(3F140000)                    mov r8, [pallet_position]
   843 000005A1 41C60020                            mov byte [r8], char_space
   844 000005A5 49FFC0                              inc r8
   845 000005A8 4C8905(3F140000)                    mov [pallet_position], r8
   846                                          .end:
   847 000005AF C3                                  ret
   848                                  
   849                                  move_ball:
   850                                      ; Si la bola no está en movimiento, no hacer nada
   851 000005B0 803D(6F140000)00            cmp byte [ball_moving], 0
   852 000005B7 0F8406010000                je .end
   853                                  
   854                                      ; Borrar la posición actual de la bola
   855 000005BD 4C8B05(4F140000)            mov r8, [ball_x_pos]
   856 000005C4 4C8B0D(57140000)            mov r9, [ball_y_pos]
   857 000005CB 4981C0[000A0000]            add r8, board
   858 000005D2 4C89C9                      mov rcx, r9
   859 000005D5 B850000000                  mov rax, column_cells + 2
   860 000005DA 48F7E9                      imul rcx
   861 000005DD 4901C0                      add r8, rax
   862 000005E0 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   863                                  
   864                                      ; Calcular siguiente posición X
   865 000005E4 4C8B05(4F140000)            mov r8, [ball_x_pos]
   866 000005EB 4C8B0D(57140000)            mov r9, [ball_y_pos]
   867 000005F2 488B05(5F140000)            mov rax, [ball_direction_x]
   868 000005F9 4901C0                      add r8, rax                  ; Nueva posición X
   869                                  
   870                                      ; Calcular la dirección de memoria para la siguiente posición
   871 000005FC 4D89C2                      mov r10, r8
   872 000005FF 4981C2[000A0000]            add r10, board
   873 00000606 4C89C9                      mov rcx, r9
   874 00000609 B850000000                  mov rax, column_cells + 2
   875 0000060E 48F7E9                      imul rcx
   876 00000611 4901C2                      add r10, rax
   877                                  
   878                                      ; Verificar si hay una X en la siguiente posición X
   879 00000614 418A02                      mov al, [r10]
   880 00000617 3C58                        cmp al, 'X'
   881 00000619 750C                        jne .check_block_x
   882 0000061B 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   883 00000622 E99C000000                  jmp .end
   884                                  
   885                                      .check_block_x:
   886                                          ; Verificar colisión con bloques en X
   887 00000627 4150                            push r8     ; Guardar registros que usa check_block_collision
   888 00000629 4151                            push r9
   889 0000062B 4152                            push r10
   890 0000062D E813060000                      call check_block_collision
   891 00000632 415A                            pop r10
   892 00000634 4159                            pop r9
   893 00000636 4158                            pop r8
   894 00000638 4885C0                          test rax, rax
   895 0000063B 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   896 0000063D 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   897 00000644 EB7D                            jmp .end
   898                                  
   899                                      .check_paddle_x:
   900                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   901 00000646 41803A3D                        cmp byte [r10], char_equal
   902 0000064A 7509                            jne .check_y_movement
   903 0000064C 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   904 00000653 EB6E                            jmp .end
   905                                  
   906                                      .check_y_movement:
   907                                          ; Calcular siguiente posición Y
   908 00000655 488B05(67140000)                mov rax, [ball_direction_y]
   909 0000065C 4901C1                          add r9, rax                  ; Nueva posición Y
   910                                  
   911                                          ; Calcular la dirección de memoria para la siguiente posición Y
   912 0000065F 4D89C2                          mov r10, r8
   913 00000662 4981C2[000A0000]                add r10, board
   914 00000669 4C89C9                          mov rcx, r9
   915 0000066C B850000000                      mov rax, column_cells + 2
   916 00000671 48F7E9                          imul rcx
   917 00000674 4901C2                          add r10, rax
   918                                  
   919                                          ; Verificar si hay una X en la siguiente posición Y
   920 00000677 418A02                          mov al, [r10]
   921 0000067A 3C58                            cmp al, 'X'
   922 0000067C 7509                            jne .check_block_y
   923 0000067E 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   924 00000685 EB3C                            jmp .end
   925                                  
   926                                      .check_block_y:
   927                                          ; Verificar colisión con bloques en Y
   928 00000687 4150                            push r8     ; Guardar registros que usa check_block_collision
   929 00000689 4151                            push r9
   930 0000068B 4152                            push r10
   931 0000068D E8B3050000                      call check_block_collision
   932 00000692 415A                            pop r10
   933 00000694 4159                            pop r9
   934 00000696 4158                            pop r8
   935 00000698 4885C0                          test rax, rax
   936 0000069B 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   937 0000069D 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   938 000006A4 EB1D                            jmp .end
   939                                  
   940                                      .check_paddle_y:
   941                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   942 000006A6 41803A3D                    cmp byte [r10], char_equal
   943 000006AA 7509                        jne .update_position
   944 000006AC 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   945 000006B3 EB0E                        jmp .end
   946                                  
   947                                  
   948                                      .update_position:
   949 000006B5 4C8905(4F140000)                mov [ball_x_pos], r8
   950 000006BC 4C890D(57140000)                mov [ball_y_pos], r9
   951                                  
   952                                      .end:
   953 000006C3 C3                              ret
   954                                  
   955                                  ; Función para inicializar el nivel
   956                                  ; Función para inicializar el nivel
   957                                  ; Función para mostrar el número de nivel
   958                                  display_level_number:
   959 000006C4 55                          push rbp
   960 000006C5 4889E5                      mov rbp, rsp
   961                                      
   962                                      ; Limpiar la pantalla primero
   963                                      print clear, clear_length
    82 000006C8 B801000000          <1>  mov eax, sys_write
    83 000006CD BF01000000          <1>  mov edi, 1
    84 000006D2 48BE-               <1>  mov rsi, %1
    84 000006D4 [1000000000000000]  <1>
    85 000006DC BA07000000          <1>  mov edx, %2
    86 000006E1 0F05                <1>  syscall
   964                                      
   965                                      ; Calcular la posición central para el mensaje
   966                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   967 000006E3 B84E000000                  mov rax, column_cells
   968 000006E8 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   969 000006EC 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   970                                      
   971                                      ; Calcular la fila central
   972 000006EF BB20000000                  mov rbx, row_cells
   973 000006F4 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   974                                      
   975                                      ; Calcular el offset en el buffer
   976 000006F7 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   977 000006FC 48F7E3                      mul rbx                     ; multiplicar por la fila central
   978 000006FF 4801D8                      add rax, rbx                ; añadir el offset horizontal
   979                                      
   980                                      ; Escribir "NIVEL " en la posición calculada
   981 00000702 488DB8[000A0000]            lea rdi, [board + rax]
   982 00000709 48BE-                       mov rsi, level_msg
   982 0000070B [2414000000000000] 
   983 00000713 B906000000                  mov rcx, level_msg_len
   984 00000718 F3A4                        rep movsb
   985                                      
   986                                      ; Escribir el número del nivel
   987 0000071A 8A05(A4140000)              mov al, [current_level]
   988 00000720 0430                        add al, '0'                 ; convertir a ASCII
   989 00000722 8807                        mov [rdi], al
   990                                      
   991                                      ; Mostrar el board con el mensaje
   992                                      print board, board_size
    82 00000724 B801000000          <1>  mov eax, sys_write
    83 00000729 BF01000000          <1>  mov edi, 1
    84 0000072E 48BE-               <1>  mov rsi, %1
    84 00000730 [000A000000000000]  <1>
    85 00000738 BA000A0000          <1>  mov edx, %2
    86 0000073D 0F05                <1>  syscall
   993                                      
   994                                      ; Esperar un segundo
   995 0000073F B823000000                  mov rax, sys_nanosleep
   996 00000744 48BF-                       mov rdi, level_display_time
   996 00000746 [2F14000000000000] 
   997 0000074E 4831F6                      xor rsi, rsi
   998 00000751 0F05                        syscall
   999                                      
  1000 00000753 5D                          pop rbp
  1001 00000754 C3                          ret
  1002                                  
  1003                                  ; Función para inicializar un tablero vacío
  1004                                  init_empty_board:
  1005 00000755 56                          push rsi
  1006 00000756 57                          push rdi
  1007 00000757 51                          push rcx
  1008 00000758 50                          push rax
  1009                                  
  1010 00000759 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1011 00000760 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1012 00000767 B9000A0000                  mov rcx, board_template_size
  1013 0000076C F3A4                        rep movsb                   ; Copiar el tablero
  1014                                  
  1015 0000076E 58                          pop rax
  1016 0000076F 59                          pop rcx
  1017 00000770 5F                          pop rdi
  1018 00000771 5E                          pop rsi
  1019 00000772 C3                          ret
  1020                                  
  1021                                  
  1022                                  init_level:
  1023                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1024 00000773 C605(35150000)00            mov byte [destroyed_blocks], 0 
  1025 0000077A E8D6FFFFFF                  call init_empty_board
  1026 0000077F E840FFFFFF                  call display_level_number
  1027 00000784 E8E5050000                  call init_enemies
  1028                                      
  1029 00000789 56                          push rsi
  1030 0000078A 57                          push rdi
  1031 0000078B 51                          push rcx
  1032 0000078C 50                          push rax
  1033                                  
  1034 0000078D 488D35(00000000)            lea rsi, [board_template]
  1035 00000794 488D3D(000A0000)            lea rdi, [board]
  1036 0000079B B9000A0000                  mov rcx, board_template_size
  1037 000007A0 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1038                                  
  1039 000007A2 58                          pop rax
  1040 000007A3 59                          pop rcx
  1041 000007A4 5F                          pop rdi
  1042 000007A5 5E                          pop rsi
  1043                                  
  1044 000007A6 B90A000000                  mov rcx, 10
  1045 000007AB 4831C0                      xor rax, rax
  1046 000007AE 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1047 000007B5 F3AA                        rep stosb      
  1048                                  
  1049                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1050 000007B7 803D(A4140000)01            cmp byte [current_level], 1
  1051 000007BE 7431                        je .level1
  1052 000007C0 803D(A4140000)02            cmp byte [current_level], 2
  1053 000007C7 7454                        je .level2
  1054 000007C9 803D(A4140000)03            cmp byte [current_level], 3
  1055 000007D0 7477                        je .level3
  1056 000007D2 803D(A4140000)04            cmp byte [current_level], 4
  1057 000007D9 0F8492000000                je .level4
  1058 000007DF 803D(A4140000)05            cmp byte [current_level], 5
  1059 000007E6 0F84AD000000                je .level5
  1060 000007EC E9D0000000                  jmp .done
  1061                                  
  1062                                  
  1063                                  
  1064                                      .level1:
  1065 000007F1 C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1066 000007F8 4831C9                          xor rcx, rcx             
  1067                                          .init_loop1:
  1068 000007FB 4883F903                            cmp rcx, level1_blocks_count
  1069 000007FF 0F8DBC000000                        jge .done
  1070 00000805 4889C8                              mov rax, rcx         
  1071 00000808 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1072 0000080C 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1073 00000812 8891[C9140000]                      mov byte [block_states + rcx], dl
  1074 00000818 48FFC1                              inc rcx
  1075 0000081B EBDE                                jmp .init_loop1
  1076                                  
  1077                                      .level2:
  1078 0000081D C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1079 00000824 4831C9                          xor rcx, rcx             
  1080                                          .init_loop2:
  1081 00000827 4883F901                            cmp rcx, level2_blocks_count
  1082 0000082B 0F8D90000000                        jge .done
  1083 00000831 4889C8                              mov rax, rcx         
  1084 00000834 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1085 00000838 8A90[B8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1086 0000083E 8891[C9140000]                      mov byte [block_states + rcx], dl
  1087 00000844 48FFC1                              inc rcx
  1088 00000847 EBDE                                jmp .init_loop2
  1089                                      .level3:
  1090 00000849 C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1091 00000850 4831C9                          xor rcx, rcx             
  1092                                          .init_loop3:
  1093 00000853 4883F901                            cmp rcx, level3_blocks_count
  1094 00000857 7D68                                jge .done
  1095 00000859 4889C8                              mov rax, rcx         
  1096 0000085C 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1097 00000860 8A90[BD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1098 00000866 8891[C9140000]                      mov byte [block_states + rcx], dl
  1099 0000086C 48FFC1                              inc rcx
  1100 0000086F EBE2                                jmp .init_loop3
  1101                                  
  1102                                      .level4:
  1103 00000871 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1104 00000878 4831C9                          xor rcx, rcx             
  1105                                          .init_loop4:
  1106 0000087B 4883F901                            cmp rcx, level4_blocks_count
  1107 0000087F 7D40                                jge .done
  1108 00000881 4889C8                              mov rax, rcx         
  1109 00000884 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1110 00000888 8A90[C2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1111 0000088E 8891[C9140000]                      mov byte [block_states + rcx], dl
  1112 00000894 48FFC1                              inc rcx
  1113 00000897 EBE2                                jmp .init_loop4
  1114                                  
  1115                                      .level5:
  1116 00000899 C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1117 000008A0 4831C9                          xor rcx, rcx             
  1118                                          .init_loop5:
  1119 000008A3 4883F901                            cmp rcx, level5_blocks_count
  1120 000008A7 7D18                                jge .done
  1121 000008A9 4889C8                              mov rax, rcx         
  1122 000008AC 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1123 000008B0 8A90[C7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1124 000008B6 8891[C9140000]                      mov byte [block_states + rcx], dl
  1125 000008BC 48FFC1                              inc rcx
  1126 000008BF EBE2                                jmp .init_loop5
  1127                                      .done:
  1128 000008C1 C3                              ret
  1129                                  
  1130                                  
  1131                                  ; Función para verificar y manejar la transición de nivel
  1132                                  check_level_complete:
  1133                                      ; Verificar si quedan bloques
  1134 000008C2 803D(A5140000)00            cmp byte [blocks_remaining], 0
  1135 000008C9 753C                        jne .not_complete
  1136                                      
  1137                                      ; Incrementar el nivel
  1138 000008CB FE05(A4140000)              inc byte [current_level]
  1139                                      
  1140                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1141 000008D1 803D(A4140000)06            cmp byte [current_level], 6
  1142 000008D8 742E                        je game_win
  1143                                      
  1144                                      ; Reinicializar el juego para el siguiente nivel
  1145 000008DA E894FEFFFF                  call init_level
  1146                                      
  1147                                      ; Reinicializar la posición de la bola y la paleta
  1148 000008DF 48C705(4F140000)28-         mov qword [ball_x_pos], 40
  1148 000008E7 000000             
  1149 000008EA 48C705(57140000)1C-         mov qword [ball_y_pos], 28
  1149 000008F2 000000             
  1150 000008F5 C605(6F140000)00            mov byte [ball_moving], 0
  1151 000008FC 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
  1151 00000903 [38130000]         
  1152                                      
  1153                                      .not_complete:
  1154 00000907 C3                              ret
  1155                                  
  1156                                      ; Nueva función para manejar la victoria del juego
  1157                                  game_win:
  1158                                      ; Limpiar la pantalla primero
  1159                                      print clear, clear_length
    82 00000908 B801000000          <1>  mov eax, sys_write
    83 0000090D BF01000000          <1>  mov edi, 1
    84 00000912 48BE-               <1>  mov rsi, %1
    84 00000914 [1000000000000000]  <1>
    85 0000091C BA07000000          <1>  mov edx, %2
    86 00000921 0F05                <1>  syscall
  1160                                      
  1161                                      ; Mensaje de victoria
  1162 00000923 488B05(2D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1163 0000092A 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1163 0000092C [3615000000000000] 
  1164 00000934 E8B4010000                  call number_to_string
  1165                                      
  1166                                      ; Definir mensaje de victoria
  1167                                      section .data
  1168 000017CC C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1168 000017D5 616465732120C2A148-
  1168 000017DE 61732067616E61646F-
  1168 000017E7 210A0D             
  1169                                          win_msg_len: equ $ - win_msg
  1170 000017EA 50756E74616A652066-             score_msg: db "Puntaje final: "
  1170 000017F3 696E616C3A20       
  1171                                          score_msg_len: equ $ - score_msg
  1172                                      section .text
  1173                                      
  1174                                      ; Imprimir mensajes
  1175                                      print win_msg, win_msg_len
    82 00000939 B801000000          <1>  mov eax, sys_write
    83 0000093E BF01000000          <1>  mov edi, 1
    84 00000943 48BE-               <1>  mov rsi, %1
    84 00000945 [CC17000000000000]  <1>
    85 0000094D BA1E000000          <1>  mov edx, %2
    86 00000952 0F05                <1>  syscall
  1176                                      print score_msg, score_msg_len
    82 00000954 B801000000          <1>  mov eax, sys_write
    83 00000959 BF01000000          <1>  mov edi, 1
    84 0000095E 48BE-               <1>  mov rsi, %1
    84 00000960 [EA17000000000000]  <1>
    85 00000968 BA0F000000          <1>  mov edx, %2
    86 0000096D 0F05                <1>  syscall
  1177                                      print number_buffer, 20
    82 0000096F B801000000          <1>  mov eax, sys_write
    83 00000974 BF01000000          <1>  mov edi, 1
    84 00000979 48BE-               <1>  mov rsi, %1
    84 0000097B [3615000000000000]  <1>
    85 00000983 BA14000000          <1>  mov edx, %2
    86 00000988 0F05                <1>  syscall
  1178                                      
  1179                                      ; Esperar un momento antes de salir
  1180 0000098A 48C7056BF6FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1180 00000993 0000               
  1181 00000995 48C70568F6FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1181 0000099E 0000               
  1182                                      sleeptime
    98 000009A0 B823000000          <1>  mov eax, sys_nanosleep
    99 000009A5 48BF-               <1>  mov rdi, timespec
    99 000009A7 [0000000000000000]  <1>
   100 000009AF 31F6                <1>  xor esi, esi
   101 000009B1 0F05                <1>  syscall
  1183                                      
  1184 000009B3 E913090000                  jmp exit
  1185                                  
  1186                                  ; Función para imprimir los bloques
  1187                                  ; Función modificada para imprimir bloques
  1188                                  
  1189                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1190                                  get_current_level_blocks:
  1191 000009B8 803D(A4140000)01            cmp byte [current_level], 1
  1192 000009BF 7428                        je .level1
  1193 000009C1 803D(A4140000)02            cmp byte [current_level], 2
  1194 000009C8 7427                        je .level2
  1195 000009CA 803D(A4140000)03            cmp byte [current_level], 3
  1196 000009D1 7426                        je .level3
  1197 000009D3 803D(A4140000)04            cmp byte [current_level], 4
  1198 000009DA 7425                        je .level4
  1199 000009DC 803D(A4140000)05            cmp byte [current_level], 5
  1200 000009E3 7424                        je .level5
  1201                                      ; Si llegamos aquí, hay un error en el nivel
  1202 000009E5 4831C0                      xor rax, rax
  1203 000009E8 C3                          ret
  1204                                  
  1205                                      .level1:
  1206 000009E9 488D05(A6140000)                lea rax, [level1_blocks]
  1207 000009F0 C3                              ret
  1208                                      .level2:
  1209 000009F1 488D05(B5140000)                lea rax, [level2_blocks]
  1210 000009F8 C3                              ret
  1211                                      .level3:
  1212 000009F9 488D05(BA140000)                lea rax, [level3_blocks]
  1213 00000A00 C3                              ret
  1214                                      .level4:
  1215 00000A01 488D05(BF140000)                lea rax, [level4_blocks]
  1216 00000A08 C3                              ret
  1217                                      .level5:
  1218 00000A09 488D05(C4140000)                lea rax, [level5_blocks]
  1219 00000A10 C3                              ret
  1220                                  ; Función para obtener la cantidad de bloques del nivel actual
  1221                                  get_current_level_count:
  1222 00000A11 803D(A4140000)01            cmp byte [current_level], 1
  1223 00000A18 7428                        je .level1
  1224 00000A1A 803D(A4140000)02            cmp byte [current_level], 2
  1225 00000A21 7425                        je .level2
  1226 00000A23 803D(A4140000)03            cmp byte [current_level], 3
  1227 00000A2A 7422                        je .level3
  1228 00000A2C 803D(A4140000)04            cmp byte [current_level], 4
  1229 00000A33 741F                        je .level4
  1230 00000A35 803D(A4140000)05            cmp byte [current_level], 5
  1231 00000A3C 741C                        je .level5
  1232                                      ; Si llegamos aquí, hay un error en el nivel
  1233 00000A3E 4831C0                      xor rax, rax
  1234 00000A41 C3                          ret
  1235                                  
  1236                                      .level1:
  1237 00000A42 B803000000                      mov rax, level1_blocks_count
  1238 00000A47 C3                              ret
  1239                                      .level2:
  1240 00000A48 B801000000                      mov rax, level2_blocks_count
  1241 00000A4D C3                              ret
  1242                                      .level3:
  1243 00000A4E B801000000                      mov rax, level3_blocks_count
  1244 00000A53 C3                              ret
  1245                                      .level4:
  1246 00000A54 B801000000                      mov rax, level4_blocks_count
  1247 00000A59 C3                              ret
  1248                                      .level5:
  1249 00000A5A B801000000                      mov rax, level5_blocks_count
  1250 00000A5F C3                              ret
  1251                                  
  1252                                  
  1253                                  print_blocks:
  1254 00000A60 55                          push rbp
  1255 00000A61 4889E5                      mov rbp, rsp
  1256                                      
  1257                                      ; Obtener puntero a los bloques del nivel actual
  1258 00000A64 E84FFFFFFF                  call get_current_level_blocks
  1259 00000A69 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1260                                      
  1261                                      ; Obtener cantidad de bloques del nivel actual
  1262 00000A6C E8A0FFFFFF                  call get_current_level_count
  1263 00000A71 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1264                                      
  1265 00000A74 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1266                                      
  1267                                      .print_loop:
  1268 00000A77 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1269 00000A7A 7D6F                            jge .end
  1270                                          
  1271                                          ; Verificar si el bloque está activo
  1272 00000A7C 490FB68424-                     movzx rax, byte [block_states + r12]
  1272 00000A81 [C9140000]         
  1273 00000A85 4885C0                          test rax, rax
  1274 00000A88 745C                            jz .next_block
  1275                                          
  1276                                          ; Obtener posición y tipo del bloque usando r13
  1277 00000A8A 4C89E0                          mov rax, r12
  1278 00000A8D 486BC005                        imul rax, 5
  1279 00000A91 4C01E8                          add rax, r13
  1280 00000A94 448A00                          mov r8b, [rax]        ; X position
  1281 00000A97 448A4801                        mov r9b, [rax + 1]    ; Y position
  1282 00000A9B 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1283                                  
  1284                                          ; El resto de la lógica de impresión permanece igual
  1285 00000A9F 4D0FB6C0                        movzx r8, r8b
  1286 00000AA3 4D0FB6C9                        movzx r9, r9b
  1287 00000AA7 4981C0[000A0000]                add r8, board
  1288 00000AAE B850000000                      mov rax, column_cells + 2
  1289 00000AB3 49F7E1                          mul r9
  1290 00000AB6 4901C0                          add r8, rax
  1291                                          
  1292 00000AB9 B906000000                      mov rcx, block_length
  1293 00000ABE 48BE-                           mov rsi, block_type_1
  1293 00000AC0 [8014000000000000] 
  1294 00000AC8 490FB6C2                        movzx rax, r10b
  1295 00000ACC 48FFC8                          dec rax
  1296 00000ACF 486BC006                        imul rax, block_length
  1297 00000AD3 4801C6                          add rsi, rax
  1298                                          
  1299                                      .print_block_chars:
  1300 00000AD6 8A06                            mov al, [rsi]
  1301 00000AD8 418800                          mov [r8], al
  1302 00000ADB 48FFC6                          inc rsi
  1303 00000ADE 49FFC0                          inc r8
  1304 00000AE1 48FFC9                          dec rcx
  1305 00000AE4 75F0                            jnz .print_block_chars
  1306                                          
  1307                                      .next_block:
  1308 00000AE6 49FFC4                          inc r12
  1309 00000AE9 EB8C                            jmp .print_loop
  1310                                          
  1311                                      .end:
  1312 00000AEB 5D                              pop rbp
  1313 00000AEC C3                              ret
  1314                                  
  1315                                  ; Función para convertir número a string
  1316                                  ; Input: RAX = número a convertir
  1317                                  ; RDI = buffer donde escribir el string
  1318                                  number_to_string:
  1319 00000AED 53                          push rbx
  1320 00000AEE 52                          push rdx
  1321 00000AEF 56                          push rsi
  1322 00000AF0 BB0A000000                  mov rbx, 10          ; Divisor
  1323 00000AF5 B900000000                  mov rcx, 0          ; Contador de dígitos
  1324                                      
  1325                                      ; Si el número es 0, manejarlo especialmente
  1326 00000AFA 4885C0                      test rax, rax
  1327 00000AFD 7509                        jnz .convert_loop
  1328 00000AFF C60730                      mov byte [rdi], '0'
  1329 00000B02 C6470100                    mov byte [rdi + 1], 0
  1330 00000B06 EB20                        jmp .end
  1331                                      
  1332                                      .convert_loop:
  1333 00000B08 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1334 00000B0B 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1335 00000B0E 80C230                          add dl, '0'     ; Convertir a ASCII
  1336 00000B11 52                              push rdx        ; Guardar el dígito
  1337 00000B12 48FFC1                          inc rcx         ; Incrementar contador
  1338 00000B15 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1339 00000B18 75EE                            jnz .convert_loop
  1340                                          
  1341                                      .write_loop:
  1342 00000B1A 5A                              pop rdx         ; Obtener dígito
  1343 00000B1B 8817                            mov [rdi], dl   ; Escribir al buffer
  1344 00000B1D 48FFC7                          inc rdi         ; Siguiente posición
  1345 00000B20 48FFC9                          dec rcx         ; Decrementar contador
  1346 00000B23 75F5                            jnz .write_loop
  1347                                          
  1348 00000B25 C60700                      mov byte [rdi], 0   ; Null terminator
  1349                                      
  1350                                      .end:
  1351 00000B28 5E                          pop rsi
  1352 00000B29 5A                          pop rdx
  1353 00000B2A 5B                          pop rbx
  1354 00000B2B C3                          ret
  1355                                  
  1356                                  ; Función para imprimir los labels
  1357                                  print_labels:
  1358 00000B2C 55                          push rbp
  1359 00000B2D 4889E5                      mov rbp, rsp
  1360                                  
  1361                                      ; Crear buffer temporal
  1362 00000B30 4883EC20                    sub rsp, 32
  1363                                  
  1364                                      ; Copiar labels a buffer temporal
  1365 00000B34 4889E7                      mov rdi, rsp
  1366 00000B37 488D35(E2150000)            lea rsi, [score_label]
  1367 00000B3E B917000000                  mov rcx, score_label_len
  1368 00000B43 F3A4                        rep movsb
  1369                                  
  1370                                      ; Convertir score a string
  1371 00000B45 488B05(2D150000)            mov rax, [current_score]
  1372 00000B4C 48BF-                       mov rdi, number_buffer
  1372 00000B4E [3615000000000000] 
  1373 00000B56 E892FFFFFF                  call number_to_string
  1374                                  
  1375                                      ; Calcular longitud del número
  1376 00000B5B B900000000                  mov rcx, 0
  1377 00000B60 48BF-                       mov rdi, number_buffer
  1377 00000B62 [3615000000000000] 
  1378                                      .count_loop:
  1379 00000B6A 803C0F00                        cmp byte [rdi + rcx], 0
  1380 00000B6E 7405                            je .count_done
  1381 00000B70 48FFC1                          inc rcx
  1382 00000B73 EBF5                            jmp .count_loop
  1383                                      .count_done:
  1384                                  
  1385                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1386 00000B75 4889E7                      mov rdi, rsp
  1387 00000B78 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1388 00000B7C BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1389 00000B81 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1390                                      .pad_loop:
  1391 00000B84 4885F6                          test rsi, rsi
  1392 00000B87 740B                            jz .pad_done
  1393 00000B89 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1394 00000B8C 48FFC7                          inc rdi
  1395 00000B8F 48FFCE                          dec rsi
  1396 00000B92 EBF0                            jmp .pad_loop
  1397                                      .pad_done:
  1398                                  
  1399                                      ; Copiar el número
  1400 00000B94 48BE-                       mov rsi, number_buffer
  1400 00000B96 [3615000000000000] 
  1401 00000B9E F3A4                        rep movsb
  1402                                  
  1403                                      ; Imprimir el buffer completo
  1404                                      print rsp, score_label_len
    82 00000BA0 B801000000          <1>  mov eax, sys_write
    83 00000BA5 BF01000000          <1>  mov edi, 1
    84 00000BAA 4889E6              <1>  mov rsi, %1
    85 00000BAD BA17000000          <1>  mov edx, %2
    86 00000BB2 0F05                <1>  syscall
  1405                                  
  1406                                      ; Repetir proceso para bloques destruidos
  1407 00000BB4 4889E7                      mov rdi, rsp
  1408 00000BB7 488D35(F9150000)            lea rsi, [blocks_label]
  1409 00000BBE B91B000000                  mov rcx, blocks_label_len
  1410 00000BC3 F3A4                        rep movsb
  1411                                  
  1412                                      ; Verificar que el `[` esté en su posición correcta
  1413 00000BC5 4889E7                      mov rdi, rsp
  1414 00000BC8 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1415 00000BCC C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1416                                  
  1417                                      ; Convertir bloques destruidos a string
  1418 00000BCF 480FB605(35150000)          movzx rax, byte [destroyed_blocks]
  1419 00000BD7 48BF-                       mov rdi, number_buffer
  1419 00000BD9 [3615000000000000] 
  1420 00000BE1 E807FFFFFF                  call number_to_string
  1421                                  
  1422                                      ; Calcular longitud del número
  1423 00000BE6 B900000000                  mov rcx, 0
  1424 00000BEB 48BF-                       mov rdi, number_buffer
  1424 00000BED [3615000000000000] 
  1425                                      .count_loop2:
  1426 00000BF5 803C0F00                        cmp byte [rdi + rcx], 0
  1427 00000BF9 7405                            je .count_done2
  1428 00000BFB 48FFC1                          inc rcx
  1429 00000BFE EBF5                            jmp .count_loop2
  1430                                      .count_done2:
  1431                                  
  1432                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1433 00000C00 4889E7                      mov rdi, rsp
  1434 00000C03 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1435 00000C07 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1436 00000C0C 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1437                                      .pad_loop2:
  1438 00000C0F 4885F6                          test rsi, rsi
  1439 00000C12 740B                            jz .pad_done2
  1440 00000C14 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1441 00000C17 48FFC7                          inc rdi
  1442 00000C1A 48FFCE                          dec rsi
  1443 00000C1D EBF0                            jmp .pad_loop2
  1444                                      .pad_done2:
  1445                                  
  1446                                      ; Copiar el número
  1447 00000C1F 48BE-                       mov rsi, number_buffer
  1447 00000C21 [3615000000000000] 
  1448 00000C29 F3A4                        rep movsb
  1449                                  
  1450                                      ; Imprimir el buffer completo
  1451                                      print rsp, blocks_label_len
    82 00000C2B B801000000          <1>  mov eax, sys_write
    83 00000C30 BF01000000          <1>  mov edi, 1
    84 00000C35 4889E6              <1>  mov rsi, %1
    85 00000C38 BA1B000000          <1>  mov edx, %2
    86 00000C3D 0F05                <1>  syscall
  1452                                  
  1453                                      ; Restaurar stack
  1454 00000C3F 4883C420                    add rsp, 32
  1455 00000C43 5D                          pop rbp
  1456 00000C44 C3                          ret
  1457                                  
  1458                                  
  1459                                  ; Función modificada para detectar colisión
  1460                                  ; Función mejorada para detectar colisión y manejar la física
  1461                                  ; Función corregida para manejar colisiones con bloques completos
  1462                                  ;---------------------------------------------------------
  1463                                  ; check_block_collision:
  1464                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1465                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1466                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1467                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1468                                  ;   retorna 0.
  1469                                  ;---------------------------------------------------------
  1470                                  ;--------------------------------------
  1471                                  ; check_block_collision
  1472                                  ;--------------------------------------
  1473                                  ; Actualizar check_block_collision para usar el nivel actual
  1474                                  check_block_collision:
  1475 00000C45 55                          push rbp
  1476 00000C46 4889E5                      mov rbp, rsp
  1477                                  
  1478                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1479 00000C49 418A02                      mov al, [r10]
  1480                                  
  1481                                      ; Verificar si el carácter es un bloque
  1482 00000C4C 3C55                        cmp al, 'U'  
  1483 00000C4E 7419                        je .possible
  1484 00000C50 3C4F                        cmp al, 'O'  
  1485 00000C52 7415                        je .possible
  1486 00000C54 3C44                        cmp al, 'D'  
  1487 00000C56 7411                        je .possible
  1488 00000C58 3C4C                        cmp al, 'L'  
  1489 00000C5A 740D                        je .possible
  1490 00000C5C 3C56                        cmp al, 'V'  
  1491 00000C5E 7409                        je .possible
  1492 00000C60 3C38                        cmp al, '8'  
  1493 00000C62 7405                        je .possible
  1494                                  
  1495                                      ; No es bloque, salir
  1496 00000C64 4831C0                      xor rax, rax
  1497 00000C67 5D                          pop rbp
  1498 00000C68 C3                          ret
  1499                                  
  1500                                  .possible:
  1501 00000C69 53                          push rbx
  1502 00000C6A 57                          push rdi
  1503 00000C6B 56                          push rsi
  1504 00000C6C 4154                        push r12
  1505 00000C6E 4155                        push r13
  1506 00000C70 4156                        push r14
  1507 00000C72 4157                        push r15
  1508                                  
  1509                                      ; 1) Obtener base de los bloques del nivel actual
  1510 00000C74 E83FFDFFFF                  call get_current_level_blocks
  1511 00000C79 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1512                                  
  1513                                      ; 2) Obtener la cantidad de bloques
  1514 00000C7C E890FDFFFF                  call get_current_level_count
  1515 00000C81 4989C6                      mov r14, rax
  1516                                  
  1517 00000C84 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1518                                  
  1519                                  .find_block_loop:
  1520 00000C87 4D39F4                      cmp r12, r14
  1521 00000C8A 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1522                                  
  1523                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1524 00000C90 4C89E0                      mov rax, r12
  1525 00000C93 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1526 00000C97 4C01E8                      add rax, r13
  1527 00000C9A 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1528                                  
  1529                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1530 00000C9D 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1530 00000CA2 [C9140000]         
  1531 00000CA6 4885DB                      test rbx, rbx
  1532 00000CA9 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1533                                  
  1534                                      ; Obtener coordenadas
  1535 00000CAF 418A17                      mov dl, [r15]         ; x
  1536 00000CB2 418A4F01                    mov cl, [r15 + 1]     ; y
  1537                                  
  1538                                      ; Calcular posición en el board
  1539 00000CB6 488D3D(000A0000)            lea rdi, [board]
  1540 00000CBD 4831C0                      xor rax, rax
  1541 00000CC0 B84E000000                  mov rax, column_cells
  1542 00000CC5 4883C002                    add rax, 2
  1543 00000CC9 480FB6C9                    movzx rcx, cl         ; y
  1544 00000CCD 480FAFC1                    imul rax, rcx
  1545 00000CD1 4801C7                      add rdi, rax
  1546 00000CD4 480FB6C2                    movzx rax, dl         ; x
  1547 00000CD8 4801C7                      add rdi, rax
  1548                                  
  1549                                      ; Guardar la posición base del bloque
  1550 00000CDB 57                          push rdi
  1551                                  
  1552                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1553 00000CDC 4939FA                      cmp r10, rdi
  1554 00000CDF 7274                        jb .skip_collision
  1555 00000CE1 488D5F06                    lea rbx, [rdi + block_length]
  1556 00000CE5 4939DA                      cmp r10, rbx
  1557 00000CE8 736B                        jae .skip_collision
  1558                                  
  1559                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1560 00000CEA 41FE8C24[C9140000]          dec byte [block_states + r12]
  1561                                      ; Volver a cargar durabilidad
  1562 00000CF2 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1562 00000CF7 [C9140000]         
  1563 00000CFB 4885DB                      test rbx, rbx
  1564 00000CFE 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1565                                  
  1566                                      ; >>> Llegó a 0 => Bloque destruido
  1567 00000D00 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1568 00000D01 B906000000                  mov rcx, block_length
  1569                                  .clear_loop:
  1570 00000D06 C60720                      mov byte [rdi], ' '
  1571 00000D09 48FFC7                      inc rdi
  1572 00000D0C E2F8                        loop .clear_loop
  1573                                  
  1574                                      ; Dibujar letra del bloque destruido
  1575 00000D0E 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1576 00000D12 4883EF06                    sub rdi, block_length
  1577 00000D16 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1578                                      ; Después de escribir la letra en el tablero
  1579 00000D18 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1580 00000D1C 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1581 00000D20 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1582 00000D25 E87CF6FFFF                  call register_letter
  1583                                      ; Actualizar contadores globales
  1584 00000D2A FE0D(A5140000)              dec byte [blocks_remaining]
  1585 00000D30 FE05(35150000)              inc byte [destroyed_blocks]
  1586                                  
  1587                                      ; Sumar puntos según el tipo
  1588 00000D36 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1589 00000D3B 486BC00A                    imul rax, 10
  1590 00000D3F 480105(2D150000)            add [current_score], rax
  1591                                  
  1592 00000D46 B801000000                  mov rax, 1  ; colisión con destrucción
  1593 00000D4B EB14                        jmp .end_pop
  1594                                  
  1595                                  .update_display:
  1596                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1597 00000D4D B801000000                  mov rax, 1  ; colisión con "rebote"  
  1598 00000D52 5F                          pop rdi     ; pop que quedó pendiente
  1599 00000D53 EB0C                        jmp .end_pop
  1600                                  
  1601                                  .skip_collision:
  1602 00000D55 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1603                                  .next_block:
  1604 00000D56 49FFC4                      inc r12
  1605 00000D59 E929FFFFFF                  jmp .find_block_loop
  1606                                  
  1607                                  .no_block_found:
  1608 00000D5E 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1609                                  
  1610                                  .end_pop:
  1611 00000D61 415F                        pop r15
  1612 00000D63 415E                        pop r14
  1613 00000D65 415D                        pop r13
  1614 00000D67 415C                        pop r12
  1615 00000D69 5E                          pop rsi
  1616 00000D6A 5F                          pop rdi
  1617 00000D6B 5B                          pop rbx
  1618 00000D6C 5D                          pop rbp
  1619 00000D6D C3                          ret
  1620                                  
  1621                                  
  1622                                  
  1623                                  init_enemies:
  1624 00000D6E 55                          push rbp
  1625 00000D6F 4889E5                      mov rbp, rsp
  1626                                      ; Reiniciar contadores de movimiento
  1627 00000D72 C605(78150000)00            mov byte [enemy_move_total], 0
  1628 00000D79 C605(79150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1629                                      ; Limpiar estado previo de enemigos
  1630 00000D80 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1631 00000D85 488D3D(4F150000)            lea rdi, [enemies]
  1632 00000D8C 30C0                        xor al, al
  1633 00000D8E F3AA                        rep stosb ; Limpiar datos de enemigos
  1634                                      
  1635                                      ; Marcar todos los enemigos como inactivos
  1636 00000D90 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1637 00000D97 30C0                        xor al, al
  1638 00000D99 B90A000000                  mov rcx, 10
  1639 00000D9E F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1640                                  
  1641 00000DA0 5D                          pop rbp
  1642 00000DA1 C3                          ret
  1643                                  
  1644                                  
  1645                                  ; Función para mover enemigos
  1646                                  move_enemies:
  1647 00000DA2 55                          push rbp
  1648 00000DA3 4889E5                      mov rbp, rsp
  1649                                      
  1650                                      ; Incrementar contador de movimiento
  1651 00000DA6 FE05(76150000)              inc byte [enemy_move_counter]
  1652 00000DAC 480FB605(76150000)          movzx rax, byte [enemy_move_counter]
  1653 00000DB4 3A05(77150000)              cmp al, [enemy_move_delay]
  1654 00000DBA 0F85AA010000                jne .end
  1655                                      
  1656                                      ; Resetear contador
  1657 00000DC0 C605(76150000)00            mov byte [enemy_move_counter], 0
  1658                                      
  1659 00000DC7 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1660                                      
  1661                                      .enemy_loop:
  1662 00000DCA 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1663 00000DCE 0F8D96010000                    jge .end
  1664                                          
  1665                                          ; Calcular offset del enemigo actual
  1666 00000DD4 4C89E0                          mov rax, r12
  1667 00000DD7 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1668 00000DDB 488DB0[4F150000]                lea rsi, [enemies + rax]
  1669                                          
  1670                                          ; Verificar si el enemigo está activo
  1671 00000DE2 807E0201                        cmp byte [rsi + 2], 1
  1672 00000DE6 0F8576010000                    jne .next_enemy
  1673                                          
  1674                                          ; Obtener posición actual
  1675 00000DEC 4C0FB606                        movzx r8, byte [rsi]            ; X
  1676 00000DF0 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1677                                          
  1678                                          ; Limpiar posición actual antes de mover
  1679 00000DF5 4150                            push r8
  1680 00000DF7 4151                            push r9
  1681 00000DF9 B84E000000                      mov rax, column_cells
  1682 00000DFE 4883C002                        add rax, 2
  1683 00000E02 49F7E1                          mul r9
  1684 00000E05 4C01C0                          add rax, r8
  1685 00000E08 488DB8[000A0000]                lea rdi, [board + rax]
  1686 00000E0F C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1687 00000E12 4159                            pop r9
  1688 00000E14 4158                            pop r8
  1689                                  
  1690                                          ; Determinar comportamiento basado en índice
  1691 00000E16 4C89E0                          mov rax, r12
  1692 00000E19 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1693 00000E1D 4885C0                          test rax, rax
  1694 00000E20 7402                            jz .chase_ball
  1695 00000E22 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1696                                          
  1697                                          ; Perseguir bola (comportamiento original)
  1698                                      .chase_ball:
  1699 00000E24 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1700 00000E2B 4D39D0                          cmp r8, r10
  1701 00000E2E 0F8F96000000                    jg .move_left
  1702 00000E34 0F8C95000000                    jl .move_right
  1703                                          
  1704 00000E3A 4C8B15(57140000)                mov r10, [ball_y_pos]
  1705 00000E41 4D39D1                          cmp r9, r10
  1706 00000E44 0F8F8A000000                    jg .move_up
  1707 00000E4A 0F8C89000000                    jl .move_down
  1708 00000E50 E9A5000000                      jmp .check_collision
  1709                                          
  1710                                      .chase_paddle:
  1711                                          ; Obtener la posición X actual de la paleta
  1712 00000E55 4C8B15(3F140000)                mov r10, [pallet_position]
  1713 00000E5C 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1714                                          
  1715                                          ; Calcular la posición X real de la paleta
  1716 00000E63 4C89D0                          mov rax, r10
  1717 00000E66 BB4E000000                      mov rbx, column_cells
  1718 00000E6B 4883C302                        add rbx, 2                  ; Añadir newline chars
  1719 00000E6F 4831D2                          xor rdx, rdx
  1720 00000E72 48F7F3                          div rbx                     ; rax = y, rdx = x
  1721                                          
  1722                                          ; rdx ahora contiene la posición X de la paleta
  1723                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1724 00000E75 488B0D(47140000)                mov rcx, [pallet_size]
  1725 00000E7C 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1726 00000E7F 4801CA                          add rdx, rcx
  1727                                          
  1728                                          ; Comparar con posición X del enemigo y mover gradualmente
  1729 00000E82 4939D0                          cmp r8, rdx
  1730 00000E85 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1731 00000E87 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1732 00000E89 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1733                                  
  1734                                      .check_y_paddle:
  1735                                          ; La Y de la paleta siempre es row_cells - 2
  1736 00000E8B 41BA20000000                    mov r10, row_cells
  1737 00000E91 4983EA02                        sub r10, 2
  1738                                          
  1739                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1740 00000E95 4D39D1                          cmp r9, r10
  1741 00000E98 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1742 00000E9A 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1743 00000E9C 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1744                                          
  1745                                      .no_movement:
  1746 00000E9E EB5A                            jmp .check_collision
  1747                                  
  1748                                      ; También agregar una nueva sección para el movimiento suave
  1749                                      .smooth_transition:
  1750                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1751 00000EA0 8A05(79150000)                  mov al, [enemy_target]
  1752 00000EA6 84C0                            test al, al
  1753 00000EA8 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1754                                          
  1755                                          ; Verificar distancia en X
  1756 00000EAA 4989D2                          mov r10, rdx              ; Posición X objetivo
  1757 00000EAD 4D29C2                          sub r10, r8               ; Calcular diferencia
  1758 00000EB0 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1759 00000EB4 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1760 00000EB6 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1761 00000EBA 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1762 00000EBC EB3C                            jmp .check_collision
  1763                                          
  1764                                      .limit_right_movement:
  1765 00000EBE 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1766 00000EC2 EB36                            jmp .check_collision
  1767                                          
  1768                                      .limit_left_movement:
  1769 00000EC4 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1770 00000EC8 EB30                            jmp .check_collision
  1771                                      .move_left:
  1772 00000ECA 49FFC8                          dec r8
  1773 00000ECD EB0F                            jmp .check_vertical
  1774                                          
  1775                                      .move_right:
  1776 00000ECF 49FFC0                          inc r8
  1777 00000ED2 EB0A                            jmp .check_vertical
  1778                                          
  1779                                      .move_up:
  1780 00000ED4 49FFC9                          dec r9
  1781 00000ED7 EB21                            jmp .check_collision
  1782                                          
  1783                                      .move_down:
  1784 00000ED9 49FFC1                          inc r9
  1785 00000EDC EB1C                            jmp .check_collision
  1786                                          
  1787                                      .check_vertical:
  1788 00000EDE 8A05(79150000)                  mov al, [enemy_target]
  1789 00000EE4 84C0                            test al, al
  1790 00000EE6 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1791 00000EEC 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1792 00000EF3 4D39D1                          cmp r9, r10
  1793 00000EF6 7FDC                            jg .move_up
  1794 00000EF8 7CDF                            jl .move_down
  1795                                          
  1796                                      .check_collision:
  1797                                          ; Verificar colisión con bordes
  1798 00000EFA 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1799 00000EFE 7E62                            jle .next_enemy
  1800 00000F00 4983F84E                        cmp r8, column_cells
  1801 00000F04 7D5C                            jge .next_enemy
  1802 00000F06 4983F901                        cmp r9, 1                       ; Borde superior
  1803 00000F0A 7E56                            jle .next_enemy
  1804 00000F0C 4983F920                        cmp r9, row_cells
  1805 00000F10 7D50                            jge .next_enemy
  1806                                          
  1807                                          ; Verificar colisión con bloques antes de moverse
  1808 00000F12 4150                            push r8
  1809 00000F14 4151                            push r9
  1810 00000F16 4152                            push r10
  1811                                          
  1812                                          ; Calcular posición en el tablero para verificar
  1813 00000F18 B84E000000                      mov rax, column_cells
  1814 00000F1D 4883C002                        add rax, 2
  1815 00000F21 49F7E1                          mul r9
  1816 00000F24 4C01C0                          add rax, r8
  1817 00000F27 4C8D90[000A0000]                lea r10, [board + rax]
  1818                                          
  1819                                          ; Verificar si hay un bloque en la nueva posición
  1820 00000F2E 418A02                          mov al, [r10]
  1821 00000F31 3C55                            cmp al, 'U'
  1822 00000F33 7427                            je .invalid_move
  1823 00000F35 3C4F                            cmp al, 'O'
  1824 00000F37 7423                            je .invalid_move
  1825 00000F39 3C44                            cmp al, 'D'
  1826 00000F3B 741F                            je .invalid_move
  1827 00000F3D 3C4C                            cmp al, 'L'
  1828 00000F3F 741B                            je .invalid_move
  1829 00000F41 3C56                            cmp al, 'V'
  1830 00000F43 7417                            je .invalid_move
  1831 00000F45 3C38                            cmp al, '8'
  1832 00000F47 7413                            je .invalid_move
  1833 00000F49 3C58                            cmp al, 'X'
  1834 00000F4B 740F                            je .invalid_move
  1835                                          
  1836 00000F4D 415A                            pop r10
  1837 00000F4F 4159                            pop r9
  1838 00000F51 4158                            pop r8
  1839                                          
  1840                                          ; Guardar nueva posición si es válida
  1841 00000F53 448806                          mov [rsi], r8b
  1842 00000F56 44884E01                        mov [rsi + 1], r9b
  1843 00000F5A EB06                            jmp .next_enemy
  1844                                          
  1845                                      .invalid_move:
  1846 00000F5C 415A                            pop r10
  1847 00000F5E 4159                            pop r9
  1848 00000F60 4158                            pop r8
  1849                                          
  1850                                      .next_enemy:
  1851 00000F62 49FFC4                          inc r12
  1852 00000F65 E960FEFFFF                      jmp .enemy_loop
  1853                                          
  1854                                      .end:
  1855 00000F6A 5D                              pop rbp
  1856 00000F6B C3                              ret
  1857                                  
  1858                                  get_current_spawn_points:
  1859 00000F6C 55                          push rbp
  1860 00000F6D 4889E5                      mov rbp, rsp
  1861                                      
  1862 00000F70 480FB605(A4140000)          movzx rax, byte [current_level]
  1863 00000F78 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1864 00000F7B 488B04C5[AD150000]          mov rax, [spawn_points_table + rax * 8]
  1865                                      
  1866 00000F83 5D                          pop rbp
  1867 00000F84 C3                          ret
  1868                                  
  1869                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1870                                  check_enemy_spawn:
  1871 00000F85 55                          push rbp
  1872 00000F86 4889E5                      mov rbp, rsp
  1873                                      
  1874                                      ; Obtener spawn points del nivel actual
  1875 00000F89 E8DEFFFFFF                  call get_current_spawn_points
  1876 00000F8E 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1877                                      
  1878                                      ; Obtener cantidad de bloques destruidos
  1879 00000F91 4C0FB62D(35150000)          movzx r13, byte [destroyed_blocks]
  1880                                      
  1881                                      ; Verificar cada punto de spawn
  1882 00000F99 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1883                                      
  1884                                      .check_loop:
  1885 00000F9C 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1886 00000FA0 7D4B                            jge .end
  1887                                          
  1888                                          ; Verificar si este spawn point ya fue usado
  1889 00000FA2 80B9[D8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1890 00000FA9 743D                            je .next_enemy
  1891                                          
  1892                                          ; Verificar si este enemigo ya está activo
  1893 00000FAB 4889C8                          mov rax, rcx
  1894 00000FAE 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1895 00000FB2 488DB0[4F150000]                lea rsi, [enemies + rax]
  1896 00000FB9 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1897 00000FBD 7429                            je .next_enemy
  1898                                          
  1899                                          ; Verificar si debemos spawnear este enemigo
  1900 00000FBF 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1901 00000FC4 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1902 00000FC7 751F                            jne .next_enemy
  1903                                          
  1904                                          ; Marcar este spawn point como usado
  1905 00000FC9 C681[D8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1906                                          
  1907                                          ; Spawner nuevo enemigo
  1908 00000FD0 C60628                          mov byte [rsi], 40             ; X inicial
  1909 00000FD3 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1910 00000FD7 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1911                                          
  1912                                          ; Inicializar comportamiento
  1913 00000FDB 4889C8                          mov rax, rcx
  1914 00000FDE 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1915 00000FE2 8805(D7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1916                                          
  1917                                      .next_enemy:
  1918 00000FE8 48FFC1                          inc rcx
  1919 00000FEB EBAF                            jmp .check_loop
  1920                                          
  1921                                      .end:
  1922 00000FED 5D                              pop rbp
  1923 00000FEE C3                              ret
  1924                                  
  1925                                  
  1926                                  ; Función para dibujar enemigos
  1927                                  print_enemies:
  1928 00000FEF 55                          push rbp
  1929 00000FF0 4889E5                      mov rbp, rsp
  1930                                      
  1931 00000FF3 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1932                                      
  1933                                      .print_loop:
  1934 00000FF6 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1935 00000FFA 7D4B                            jge .end
  1936                                          
  1937                                          ; Calcular offset del enemigo actual
  1938 00000FFC 4C89E0                          mov rax, r12
  1939 00000FFF 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1940 00001003 488DB0[4F150000]                lea rsi, [enemies + rax]
  1941                                          
  1942                                          ; Verificar si el enemigo está activo
  1943 0000100A 807E0201                        cmp byte [rsi + 2], 1
  1944 0000100E 7532                            jne .next_enemy
  1945                                          
  1946                                          ; Calcular posición en el tablero
  1947 00001010 4C0FB606                        movzx r8, byte [rsi]            ; X
  1948 00001014 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1949                                          
  1950                                          ; Calcular offset en el tablero
  1951 00001019 B84E000000                      mov rax, column_cells
  1952 0000101E 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1953 00001022 49F7E1                          mul r9
  1954 00001025 4C01C0                          add rax, r8
  1955 00001028 488DB8[000A0000]                lea rdi, [board + rax]
  1956                                          
  1957                                          ; Obtener carácter del enemigo según el nivel
  1958 0000102F 480FB605(A4140000)              movzx rax, byte [current_level]
  1959 00001037 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1960 0000103A 8A80[4A150000]                  mov al, [enemy_chars + rax]
  1961                                          
  1962                                          ; Dibujar enemigo
  1963 00001040 8807                            mov [rdi], al
  1964                                          
  1965                                      .next_enemy:
  1966 00001042 49FFC4                          inc r12
  1967 00001045 EBAF                            jmp .print_loop
  1968                                          
  1969                                      .end:
  1970 00001047 5D                              pop rbp
  1971 00001048 C3                              ret
  1972                                  
  1973                                  ; Función para verificar colisión con enemigos
  1974                                  ; Función para verificar colisión con enemigos
  1975                                  check_enemy_collision:
  1976 00001049 55                          push rbp
  1977 0000104A 4889E5                      mov rbp, rsp
  1978                                      
  1979 0000104D 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1980 00001050 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1981                                      
  1982                                      .check_loop:
  1983 00001053 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1984 00001057 0F8DE9000000                    jge .end
  1985                                          
  1986                                          ; Calcular offset del enemigo actual
  1987 0000105D 4C89E1                          mov rcx, r12
  1988 00001060 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1989 00001064 488DB1[4F150000]                lea rsi, [enemies + rcx]
  1990                                          
  1991                                          ; Verificar si el enemigo está activo
  1992 0000106B 807E0201                        cmp byte [rsi + 2], 1
  1993 0000106F 0F85C9000000                    jne .next_enemy
  1994                                          
  1995                                          ; Verificar colisión con la bola
  1996 00001075 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1997 00001079 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1998                                          
  1999                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2000 0000107E 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2001 00001085 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2002                                          
  2003                                          ; Comprobar colisión vertical (misma columna)
  2004 0000108C 4D39C2                          cmp r10, r8
  2005 0000108F 7525                            jne .check_horizontal
  2006 00001091 4D29CB                          sub r11, r9
  2007 00001094 4983FB01                        cmp r11, 1
  2008 00001098 7F1C                            jg .check_horizontal
  2009 0000109A 4983FBFF                        cmp r11, -1
  2010 0000109E 7C16                            jl .check_horizontal
  2011                                          
  2012                                          ; Colisión vertical detectada
  2013 000010A0 E8A3000000                      call destroy_enemy
  2014 000010A5 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2015 000010AC B801000000                      mov rax, 1
  2016 000010B1 E990000000                      jmp .end
  2017                                          
  2018                                      .check_horizontal:
  2019                                          ; Comprobar colisión horizontal (misma fila)
  2020 000010B6 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2021 000010BD 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2022 000010C4 4D39CB                          cmp r11, r9
  2023 000010C7 7522                            jne .check_paddle
  2024 000010C9 4D29C2                          sub r10, r8
  2025 000010CC 4983FA01                        cmp r10, 1
  2026 000010D0 7F19                            jg .check_paddle
  2027 000010D2 4983FAFF                        cmp r10, -1
  2028 000010D6 7C13                            jl .check_paddle
  2029                                          
  2030                                          ; Colisión horizontal detectada
  2031 000010D8 E86B000000                      call destroy_enemy
  2032 000010DD 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2033 000010E4 B801000000                      mov rax, 1
  2034 000010E9 EB5B                            jmp .end
  2035                                          
  2036                                      .check_paddle:
  2037                                          ; Verificar colisión con la paleta
  2038 000010EB 4C8B15(3F140000)                mov r10, [pallet_position]
  2039 000010F2 4981EA[000A0000]                sub r10, board
  2040 000010F9 4C89D0                          mov rax, r10
  2041 000010FC 41BB4E000000                    mov r11, column_cells
  2042 00001102 4983C302                        add r11, 2
  2043 00001106 4831D2                          xor rdx, rdx
  2044 00001109 49F7F3                          div r11                     ; División para obtener la posición Y
  2045 0000110C 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2046                                          
  2047 0000110F 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2048                                          
  2049                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2050 00001116 41BD20000000                    mov r13, row_cells
  2051 0000111C 4983ED02                        sub r13, 2                 ; Y de la paleta
  2052 00001120 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2053 00001123 7519                            jne .next_enemy
  2054                                          
  2055                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2056 00001125 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2057 00001128 7C14                            jl .next_enemy
  2058                                          
  2059 0000112A 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2060 0000112D 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2061 00001130 7F0C                            jg .next_enemy
  2062                                          
  2063                                          ; Si llegamos aquí, hay colisión con la paleta
  2064 00001132 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2065 00001137 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2066 0000113C EB08                            jmp .end
  2067                                          
  2068                                      .next_enemy:
  2069 0000113E 49FFC4                          inc r12
  2070 00001141 E90DFFFFFF                      jmp .check_loop
  2071                                          
  2072                                      .end:
  2073 00001146 5D                              pop rbp
  2074 00001147 C3                              ret
  2075                                  
  2076                                  ; Función para destruir un enemigo
  2077                                  destroy_enemy:
  2078                                      ; Desactivar enemigo
  2079 00001148 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2080                                  
  2081                                      ; Sumar puntos por destruir enemigo
  2082 0000114C 488B05(6E150000)            mov rax, [enemy_points]
  2083 00001153 480105(2D150000)            add [current_score], rax
  2084                                  
  2085                                      ; No tocar bloques destruidos aquí
  2086 0000115A C3                          ret
  2087                                  
  2088                                  
  2089                                  _start:
  2090 0000115B E8CBEFFFFF              	call canonical_off
  2091 00001160 E8F3000000              	call start_screen
  2092 00001165 E809F6FFFF                  call init_level
  2093 0000116A E8FFFBFFFF                  call init_enemies
  2094 0000116F EB00                    	jmp .main_loop
  2095                                  	
  2096                                  
  2097                                  	.main_loop:
  2098 00001171 E8B6F9FFFF                      call print_labels
  2099 00001176 E8E5F8FFFF                      call print_blocks
  2100 0000117B E8F3F2FFFF                      call move_letters
  2101 00001180 E863F2FFFF                      call print_letters
  2102 00001185 E896F3FFFF              		call print_pallet
  2103 0000118A E821F4FFFF                      call move_ball
  2104 0000118F E84AF1FFFF                      call check_bottom_collision
  2105 00001194 E844F0FFFF                      call print_lives
  2106 00001199 E824F7FFFF                      call check_level_complete
  2107 0000119E E8E2FDFFFF                      call check_enemy_spawn
  2108 000011A3 E8FAFBFFFF                      call move_enemies
  2109 000011A8 E89CFEFFFF                      call check_enemy_collision
  2110 000011AD E83DFEFFFF                      call print_enemies
  2111 000011B2 E841F3FFFF              		call print_ball
  2112                                  		print board, board_size				
    82 000011B7 B801000000          <1>  mov eax, sys_write
    83 000011BC BF01000000          <1>  mov edi, 1
    84 000011C1 48BE-               <1>  mov rsi, %1
    84 000011C3 [000A000000000000]  <1>
    85 000011CB BA000A0000          <1>  mov edx, %2
    86 000011D0 0F05                <1>  syscall
  2113                                  		;setnonblocking	
  2114                                  	.read_more:	
  2115                                  		getchar	
    90 000011D2 B800000000          <1>  mov rax, sys_read
    91 000011D7 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000011DC 48BE-               <1>  mov rsi, input_char
    92 000011DE [0000000000000000]  <1>
    93 000011E6 BA01000000          <1>  mov rdx, 1
    94 000011EB 0F05                <1>  syscall
  2116                                  		
  2117 000011ED 4883F801                		cmp rax, 1
  2118 000011F1 7532                        	jne .done
  2119                                  		
  2120 000011F3 8A05(00000000)          		mov al,[input_char]
  2121                                  
  2122 000011F9 3C61                    		cmp al, 'a'
  2123 000011FB 750E                    	    jne .not_left
  2124 000011FD 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2125 00001204 E832F3FFFF              		call move_pallet
  2126 00001209 EB1A                    	    jmp .done
  2127                                  		
  2128                                  		.not_left:
  2129 0000120B 3C64                    		 	cmp al, 'd'
  2130 0000120D 750C                    	    	jne .not_right
  2131 0000120F BF01000000              			mov rdi, right_direction
  2132 00001214 E822F3FFFF              	    	call move_pallet
  2133 00001219 EB0A                        		jmp .done		
  2134                                  
  2135                                  		.not_right:
  2136                                  
  2137 0000121B 3C71                        		cmp al, 'q'
  2138 0000121D 0F84A8000000                		je exit
  2139                                  
  2140 00001223 EBAD                    			jmp .read_more
  2141                                  		
  2142                                  		.done:	
  2143                                  			;unsetnonblocking		
  2144                                  			sleeptime	
    98 00001225 B823000000          <1>  mov eax, sys_nanosleep
    99 0000122A 48BF-               <1>  mov rdi, timespec
    99 0000122C [0000000000000000]  <1>
   100 00001234 31F6                <1>  xor esi, esi
   101 00001236 0F05                <1>  syscall
  2145                                  			print clear, clear_length
    82 00001238 B801000000          <1>  mov eax, sys_write
    83 0000123D BF01000000          <1>  mov edi, 1
    84 00001242 48BE-               <1>  mov rsi, %1
    84 00001244 [1000000000000000]  <1>
    85 0000124C BA07000000          <1>  mov edx, %2
    86 00001251 0F05                <1>  syscall
  2146 00001253 E919FFFFFF                  		jmp .main_loop
  2147                                  
  2148                                  
  2149                                  
  2150                                  start_screen:
  2151                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001258 B801000000          <1>  mov eax, sys_write
    83 0000125D BF01000000          <1>  mov edi, 1
    84 00001262 48BE-               <1>  mov rsi, %1
    84 00001264 [1000000000000000]  <1>
    85 0000126C BA07000000          <1>  mov edx, %2
    86 00001271 0F05                <1>  syscall
  2152                                      print msg1, msg1_length
    82 00001273 B801000000          <1>  mov eax, sys_write
    83 00001278 BF01000000          <1>  mov edi, 1
    84 0000127D 48BE-               <1>  mov rsi, %1
    84 0000127F [1700000000000000]  <1>
    85 00001287 BA14010000          <1>  mov edx, %2
    86 0000128C 0F05                <1>  syscall
  2153                                      
  2154                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2155                                          getchar                 ; Esperamos una tecla
    90 0000128E B800000000          <1>  mov rax, sys_read
    91 00001293 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001298 48BE-               <1>  mov rsi, input_char
    92 0000129A [0000000000000000]  <1>
    93 000012A2 BA01000000          <1>  mov rdx, 1
    94 000012A7 0F05                <1>  syscall
  2156 000012A9 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2157 000012AD 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2158                                          
  2159                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000012AF B801000000          <1>  mov eax, sys_write
    83 000012B4 BF01000000          <1>  mov edi, 1
    84 000012B9 48BE-               <1>  mov rsi, %1
    84 000012BB [1000000000000000]  <1>
    85 000012C3 BA07000000          <1>  mov edx, %2
    86 000012C8 0F05                <1>  syscall
  2160 000012CA C3                          ret
  2161                                  
  2162                                  exit: 
  2163 000012CB E89DEEFFFF              	call canonical_on
  2164 000012D0 B83C000000              	mov    rax, 60
  2165 000012D5 BF00000000                  mov    rdi, 0
  2166 000012DA 0F05                        syscall
  2167                                  
