     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 50h>         <1>  times column_cells db "X"
    71 00000050 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000052 58                  <2>  db "X"
    76 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A4 58                  <2>  db "X"
    76 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F6 58                  <2>  db "X"
    76 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000148 58                  <2>  db "X"
    76 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000019A 58                  <2>  db "X"
    76 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001EC 58                  <2>  db "X"
    76 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000023E 58                  <2>  db "X"
    76 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000290 58                  <2>  db "X"
    76 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002E2 58                  <2>  db "X"
    76 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000334 58                  <2>  db "X"
    76 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000386 58                  <2>  db "X"
    76 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003D8 58                  <2>  db "X"
    76 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000042A 58                  <2>  db "X"
    76 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000047C 58                  <2>  db "X"
    76 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004CE 58                  <2>  db "X"
    76 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000520 58                  <2>  db "X"
    76 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000572 58                  <2>  db "X"
    76 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005C4 58                  <2>  db "X"
    76 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000616 58                  <2>  db "X"
    76 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000668 58                  <2>  db "X"
    76 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006BA 58                  <2>  db "X"
    76 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000070C 58                  <2>  db "X"
    76 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000075E 58                  <2>  db "X"
    76 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007B0 58                  <2>  db "X"
    76 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000802 58                  <2>  db "X"
    76 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000854 58                  <2>  db "X"
    76 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008A6 58                  <2>  db "X"
    76 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008F8 58                  <2>  db "X"
    76 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000094A 58                  <2>  db "X"
    76 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000099C 58                  <2>  db "X"
    76 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    71 00000A3E 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A40 00<rep A40h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001480 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(8C140000)                  and [termios+12], eax
   146 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(8C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[80140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[80140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 000014A4 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 000014AA 31                          level_1_char: db "1"
   236 000014AB 32                          level_2_char: db "2"
   237 000014AC 33                          level_3_char: db "3"
   238 000014AD 34                          level_4_char: db "4"
   239 000014AE 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 000014B7 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 000014C7 0500000000000000            pallet_size dq 5
   249 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 000014DF 2800000000000000        	ball_x_pos: dq 40
   253 000014E7 1C00000000000000        	ball_y_pos: dq 28
   254 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001500 00                          ball_active db 0
   258                                  
   259 00001501 0000000000000000            ball2_x_pos:        dq 0
   260 00001509 0000000000000000            ball2_y_pos:        dq 0
   261 00001511 0000000000000000            ball2_direction_x:  dq 0
   262 00001519 0000000000000000            ball2_direction_y:  dq 0
   263 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 00001523 0000000000000000            ball3_x_pos:        dq 0
   268 0000152B 0000000000000000            ball3_y_pos:        dq 0
   269 00001533 0000000000000000            ball3_direction_x:  dq 0
   270 0000153B 0000000000000000            ball3_direction_y:  dq 0
   271 00001543 00                          ball3_moving:       db 0
   272 00001544 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 00001579 01                          current_level db 1
   300 0000157A 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 0000157B 0105050120                      db 1, 5, 5, 1, ' '   
   307 00001580 0705050120                      db 7, 5, 5, 1, ' '    
   308 00001585 0D05050120                      db 13, 5, 5, 1, ' '   
   309 0000158A 1305050120                      db 19, 5, 5, 1, ' '   
   310 0000158F 1905050120                      db 25, 5, 5, 1, ' '   
   311 00001594 1F05050120                      db 31, 5, 5, 1, ' '   
   312 00001599 2505050120                      db 37, 5, 5, 1, ' '   
   313 0000159E 2B05050120                      db 43, 5, 5, 1, ' '   
   314 000015A3 3105050120                      db 49, 5, 5, 1, ' '   
   315 000015A8 3705050120                      db 55, 5, 5, 1, ' '   
   316 000015AD 3D05050120                      db 61, 5, 5, 1, ' '  
   317 000015B2 4305050120                      db 67, 5, 5, 1, ' '   
   318 000015B7 4905050120                      db 73, 5, 5, 1, ' '   
   319                                  
   320 000015BC 0106040120                      db 1, 6, 4, 1, ' '   
   321 000015C1 0706020120                      db 7, 6, 2, 1, ' '    
   322 000015C6 0D06040120                      db 13, 6, 4, 1, ' '   
   323 000015CB 1306020120                      db 19, 6, 2, 1, ' '   
   324 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   325 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   326 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   327 000015DF 2B06020120                      db 43, 6, 2, 1, ' '   
   328 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   329 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   330 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   331 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   332 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   333                                  
   334 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   335 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   336 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   337 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   338 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   339 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   340 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   341 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   342 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   343 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   344 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   345 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   346 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   347                                  
   348 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   349 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   350 00001648 0D08040120                      db 13, 8, 4, 1, ' '   
   351 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   352 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   353 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   354 0000165C 2508040120                      db 37, 8, 4, 1, ' '   
   355 00001661 2B08020120                      db 43, 8, 2, 1, ' '   
   356 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   357 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   358 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   359 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   360 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   361                                  
   362 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   363 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   364 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   365 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   366 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   367 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   368 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   369 000016A2 2B09030120                      db 43, 9, 3, 1, ' '   
   370 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   371 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   372 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   373 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   374 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   375                                  
   376 000016C0 010A040120                      db 1, 10, 4, 1, ' '   
   377 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   378 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   379 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   380 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   381 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   382 000016DE 250A040120                      db 37, 10, 4, 1, ' '   
   383 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   384 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   385 000016ED 370A020120                      db 55, 10, 2, 1, ' '   
   386 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   387 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   388 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   389                                  
   390                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   391                                  
   392                                      ; Nivel 2: Bloques de prueba
   393                                      level2_blocks:
   394 00001701 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   395                                      level2_blocks_count equ 1
   396                                  
   397                                      ; Nivel 3
   398                                      level3_blocks:
   399 00001706 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   400                                  
   401                                      level3_blocks_count equ 1
   402                                  
   403                                      ; Nivel 4
   404                                      level4_blocks:
   405 0000170B 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   406                                      level4_blocks_count equ 1
   407                                  
   408                                      ; Nivel 5
   409                                      level5_blocks:
   410 00001710 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   411                                      level5_blocks_count equ 1
   412                                  
   413                                      ; Array para mantener el estado de los bloques
   414 00001715 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   415                                  
   416                                      
   417                                      ; Variables para almacenar los valores
   418 00001779 0000000000000000            current_score dq 0          ; Score actual
   419 00001781 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   420                                      
   421                                      ; Buffer para convertir números a string
   422 00001782 00<rep 14h>                 number_buffer: times 20 db 0
   423                                  
   424 00001796 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   425                                      
   426                                      ; Estructura para los enemigos (x, y, activo)
   427 0000179B 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   428 000017B9 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   429                                      
   430 000017BA 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   431 000017C2 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   432 000017C3 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   433 000017C4 00                          enemy_move_total db 0      ; Contador total de movimientos
   434 000017C5 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   435 000017C6 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   436                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   437                                      ; Añade esto en la sección .dataa
   438 000017C7 00000006080A0C0E10-         level1_spawn_points: db 0, 0, 0, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   438 000017D0 12                 
   439 000017D1 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   439 000017DA 13                 
   440 000017DB 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   440 000017E4 1B                 
   441 000017E5 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   441 000017EE 1C                 
   442 000017EF 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   442 000017F8 2D                 
   443                                          ; Arreglo de punteros a los spawn points de cada nivel
   444                                      spawn_points_table:
   445 000017F9 [C717000000000000]              dq level1_spawn_points
   446 00001801 [D117000000000000]              dq level2_spawn_points
   447 00001809 [DB17000000000000]              dq level3_spawn_points
   448 00001811 [E517000000000000]              dq level4_spawn_points
   449 00001819 [EF17000000000000]              dq level5_spawn_points
   450                                  
   451                                      ; Variables para el comportamiento de enemigos
   452 00001821 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   453 00001822 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   454 00001823 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   455 00001824 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   456                                  
   457 0000182E 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   457 00001837 5B2020202020202020-
   457 00001840 20205D0A0D         
   458                                      score_label_len: equ $ - score_label
   459 00001845 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   459 0000184E 657374727569646F73-
   459 00001857 3A205B2020205D0A0D 
   460                                      blocks_label_len: equ $ - blocks_label
   461                                      
   462                                      ; Posición donde insertar los números en los labels
   463                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   464                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   465                                      
   466                                      ; Definición de las vidas (x, y, estado)
   467                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   468                                      lives_data: 
   469 00001860 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   470 00001863 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   471 00001866 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   472 00001869 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   473 0000186C 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   474 0000186F 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   475 00001872 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   476                                      lives_count equ 7    ; Total de vidas
   477 00001875 5E                          life_char db "^"    
   478 00001876 04                          current_lives db 4   ; Contador de vidas activas actual
   479                                  
   480                                  ; Estructura para almacenar las letras y sus posiciones
   481                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   482 00001877 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   483 00001A07 00                          letters_count db 0   
   484 00001A08 20                          last_letter db ' '    ; Variable para almacenar la última letra
   485 00001A09 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   485 00001A12 75616C3A205B205D0A-
   485 00001A1B 0D                 
   486                                      last_letter_msg_len equ $ - last_letter_msg
   487 00001A1C 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   488 00001A1D 07                          max_lives db 7              ; Máximo número de vidas permitidas
   489 00001A1E 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   490 00001A26 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   491 00001A2E 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   492                                  
   493 00001A36 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   494 00001A37 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   495 00001A38 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
   496 00001A39 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
   497                                  
   498 00001A3A 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   499 00001A42 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   500                                  
   501 00001A43 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   502 00001A44 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   503 00001A45 00                          laser_count: db 0                ; Contador de láseres activos
   504 00001A46 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   505 00001B0E 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   506                                  
   507                                      balls_data:     ; Array para almacenar hasta 3 bolas
   508                                          ; Bola 1 (principal)
   509 00001B16 0000000000000000                dq 0        ; x_pos
   510 00001B1E 0000000000000000                dq 0        ; y_pos
   511 00001B26 0100000000000000                dq 1        ; direction_x
   512 00001B2E FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   513 00001B36 01                              db 1        ; active
   514                                          ; Bola 2
   515 00001B37 0000000000000000                dq 0        ; x_pos
   516 00001B3F 0000000000000000                dq 0        ; y_pos
   517 00001B47 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   518 00001B4F FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   519 00001B57 00                              db 0        ; active
   520                                          ; Bola 3
   521 00001B58 0000000000000000                dq 0        ; x_pos
   522 00001B60 0000000000000000                dq 0        ; y_pos
   523 00001B68 0000000000000000                dq 0        ; direction_x
   524 00001B70 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   525 00001B78 00                              db 0        ; active
   526                                      
   527 00001B79 01                          balls_count db 1     ; Contador de bolas activas
   528                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   529 00001B7A 00<rep Ah>                  enemy_last_x:       times 10 db 0
   530 00001B84 00<rep Ah>                  enemy_last_y:       times 10 db 0
   531 00001B8E 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
   532                                  
   533                                  section .text
   534                                  
   535                                  
   536                                  print_lives:
   537 000001DD 55                          push rbp
   538 000001DE 4889E5                      mov rbp, rsp
   539                                      
   540 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   541                                      
   542                                      .print_loop:
   543 000001E4 4983FC07                        cmp r12, lives_count
   544 000001E8 7D45                            jge .end
   545                                          
   546                                          ; Calcular offset de la vida actual
   547 000001EA 4C89E0                          mov rax, r12
   548 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   549 000001F1 488DB0[60180000]                lea rsi, [lives_data + rax]
   550                                          
   551                                          ; Calcular posición en el tablero
   552 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   553 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   554                                          
   555                                          ; Calcular offset en el tablero
   556 00000201 B850000000                      mov rax, column_cells
   557 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   558 0000020A 49F7E1                          mul r9
   559 0000020D 4C01C0                          add rax, r8
   560 00000210 488DB8[400A0000]                lea rdi, [board + rax]
   561                                          
   562                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   563 00000217 807E0201                        cmp byte [rsi + 2], 1
   564 0000021B 7405                            je .draw_active
   565                                          
   566                                          ; Si está inactiva, dibujar espacio
   567 0000021D C60720                          mov byte [rdi], ' '
   568 00000220 EB08                            jmp .next_life
   569                                          
   570                                      .draw_active:
   571                                          ; Si está activa, dibujar el símbolo de vida
   572 00000222 8A05(75180000)                  mov al, [life_char]
   573 00000228 8807                            mov [rdi], al
   574                                          
   575                                      .next_life:
   576 0000022A 49FFC4                          inc r12
   577 0000022D EBB5                            jmp .print_loop
   578                                          
   579                                      .end:
   580 0000022F 5D                              pop rbp
   581 00000230 C3                              ret
   582                                  
   583                                  ; Función para desactivar una vida
   584                                  ; Función modificada para perder una vida
   585                                  ; Modificar lose_life para reiniciar solo la bola principal
   586                                  lose_life:
   587 00000231 55                          push rbp
   588 00000232 4889E5                      mov rbp, rsp
   589                                      
   590                                      ; Verificar si aún quedan vidas
   591 00000235 803D(76180000)00            cmp byte [current_lives], 0
   592 0000023C 0F84AB000000                je .game_lost
   593                                      
   594                                      ; Encontrar la última vida activa
   595 00000242 B907000000                  mov rcx, lives_count
   596 00000247 48FFC9                      dec rcx
   597                                      
   598                                      .find_active_life:
   599 0000024A 4889C8                          mov rax, rcx
   600 0000024D 486BC003                        imul rax, 3
   601 00000251 488DB0[60180000]                lea rsi, [lives_data + rax]
   602 00000258 807E0201                        cmp byte [rsi + 2], 1
   603 0000025C 740A                            je .deactivate_life
   604 0000025E 48FFC9                          dec rcx
   605 00000261 79E7                            jns .find_active_life
   606 00000263 E985000000                      jmp .game_lost
   607                                          
   608                                      .deactivate_life:
   609                                          ; Borrar vida visualmente y en datos
   610 00000268 4C0FB606                        movzx r8, byte [rsi]
   611 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   612 00000271 B850000000                      mov rax, column_cells
   613 00000276 4883C002                        add rax, 2
   614 0000027A 49F7E1                          mul r9
   615 0000027D 4C01C0                          add rax, r8
   616 00000280 488DB8[400A0000]                lea rdi, [board + rax]
   617 00000287 C60720                          mov byte [rdi], ' '
   618 0000028A C6460200                        mov byte [rsi + 2], 0
   619 0000028E FE0D(76180000)                  dec byte [current_lives]
   620                                          
   621                                          ; Borrar paleta anterior
   622 00000294 4C8B05(BF140000)                mov r8, [pallet_position]
   623 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]
   624                                          .erase_pallet_loop:
   625 000002A2 41C60020                            mov byte [r8], ' '
   626 000002A6 49FFC0                              inc r8
   627 000002A9 48FFC9                              dec rcx
   628 000002AC 75F4                                jnz .erase_pallet_loop
   629                                          
   630                                          ; Reiniciar solo la bola principal
   631 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40
   631 000002B6 000000             
   632 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28
   632 000002C1 000000             
   633 000002C4 C605(FF140000)00                mov byte [ball_moving], 0
   634 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
   635 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   635 000002D9 [B0130000]         
   636                                          
   637                                          ; Asegurarse que las otras bolas están desactivadas
   638 000002DD C605(22150000)00                mov byte [ball2_active], 0
   639 000002E4 C605(44150000)00                mov byte [ball3_active], 0
   640                                          
   641 000002EB EB07                            jmp .end
   642                                          
   643                                      .game_lost:
   644 000002ED E8C7000000                      call game_lost
   645 000002F2 EB00                            jmp .end
   646                                          
   647                                      .end:
   648 000002F4 5D                              pop rbp
   649 000002F5 C3                              ret
   650                                  ; Función modificada para verificar colisión con el borde inferior
   651                                  check_bottom_collision:
   652 000002F6 55                          push rbp
   653 000002F7 4889E5                      mov rbp, rsp
   654                                      
   655                                      ; Verificar bola principal
   656 000002FA 803D(00150000)01            cmp byte [ball_active], 1
   657 00000301 7542                        jne .check_ball2
   658 00000303 488B05(E7140000)            mov rax, [ball_y_pos]
   659 0000030A 4883F81E                    cmp rax, row_cells - 2
   660 0000030E 7535                        jne .check_ball2
   661                                      
   662                                      ; Borrar visualmente la bola principal
   663 00000310 4C8B05(DF140000)            mov r8, [ball_x_pos]
   664 00000317 4C8B0D(E7140000)            mov r9, [ball_y_pos]
   665 0000031E 4981C0[400A0000]            add r8, board
   666 00000325 4C89C9                      mov rcx, r9
   667 00000328 B852000000                  mov rax, column_cells + 2
   668 0000032D 48F7E9                      imul rcx
   669 00000330 4901C0                      add r8, rax
   670 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   671                                      
   672 00000337 C605(00150000)00            mov byte [ball_active], 0
   673 0000033E C605(FF140000)00            mov byte [ball_moving], 0
   674                                  
   675                                  .check_ball2:
   676 00000345 803D(22150000)01            cmp byte [ball2_active], 1
   677 0000034C 751B                        jne .check_ball3
   678 0000034E 488B05(09150000)            mov rax, [ball2_y_pos]
   679 00000355 4883F81E                    cmp rax, row_cells - 2
   680 00000359 750E                        jne .check_ball3
   681 0000035B C605(22150000)00            mov byte [ball2_active], 0
   682 00000362 C605(21150000)00            mov byte [ball2_moving], 0
   683                                  
   684                                  .check_ball3:
   685 00000369 803D(44150000)01            cmp byte [ball3_active], 1
   686 00000370 751B                        jne .check_active_balls
   687 00000372 488B05(2B150000)            mov rax, [ball3_y_pos]
   688 00000379 4883F81E                    cmp rax, row_cells - 2
   689 0000037D 750E                        jne .check_active_balls
   690 0000037F C605(44150000)00            mov byte [ball3_active], 0
   691 00000386 C605(43150000)00            mov byte [ball3_moving], 0
   692                                  
   693                                  .check_active_balls:
   694                                      ; Verificar si quedan bolas activas
   695 0000038D 4831C9                      xor rcx, rcx
   696 00000390 803D(00150000)01            cmp byte [ball_active], 1
   697 00000397 741E                        je .balls_remain
   698 00000399 803D(22150000)01            cmp byte [ball2_active], 1
   699 000003A0 7415                        je .balls_remain
   700 000003A2 803D(44150000)01            cmp byte [ball3_active], 1
   701 000003A9 740C                        je .balls_remain
   702                                      
   703                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   704 000003AB E881FEFFFF                  call lose_life
   705 000003B0 C605(00150000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   706                                      
   707                                  .balls_remain:
   708 000003B7 5D                          pop rbp
   709 000003B8 C3                          ret
   710                                  
   711                                  
   712                                  
   713                                  ; Nueva función para game over
   714                                  game_lost:
   715                                      ; Limpiar la pantalla
   716                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   717                                      
   718                                      ; Mostrar mensaje de derrota
   719                                      section .data
   720 00001B98 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   720 00001BA1 6469646F210A0D     
   721                                          lost_msg_len: equ $ - lost_msg
   722                                      section .text
   723                                      
   724                                      ; Imprimir mensaje de derrota
   725                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [981B000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   726                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [C61B000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   727                                      
   728                                      ; Mostrar puntaje final
   729 0000040A 488B05(79170000)            mov rax, [current_score]
   730 00000411 48BF-                       mov rdi, number_buffer
   730 00000413 [8217000000000000] 
   731 0000041B E846130000                  call number_to_string
   732                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [8217000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   733                                      
   734                                      ; Esperar un momento antes de salir
   735 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   735 00000444 0000               
   736 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   736 0000044F 0000               
   737                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   738                                      
   739 00000464 E9111D0000                  jmp exit
   740                                  
   741                                  
   742                                  ; Función para registrar una nueva letra en el mapa
   743                                  ; Entrada:
   744                                  ;   al - letra a registrar
   745                                  ;   r8b - posición x
   746                                  ;   r9b - posición y
   747                                  register_letter:
   748 00000469 55                          push rbp
   749 0000046A 4889E5                      mov rbp, rsp
   750 0000046D 53                          push rbx
   751 0000046E 51                          push rcx
   752                                      
   753 0000046F 3C20                        cmp al, ' '
   754 00000471 7438                        je .end
   755                                  
   756                                      ; Encontrar un espacio libre en el mapa
   757 00000473 4831C9                      xor rcx, rcx
   758 00000476 480FB615(071A0000)          movzx rdx, byte [letters_count]
   759                                      
   760                                      .find_slot:
   761 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   762 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   763                                          
   764 00000484 488D1C8D[77180000]              lea rbx, [letters_map + rcx * 4]
   765 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   766 00000490 7405                            je .found_slot
   767                                          
   768 00000492 48FFC1                          inc rcx
   769 00000495 EBE7                            jmp .find_slot
   770                                          
   771                                      .found_slot:
   772                                          ; Guardar la información de la letra
   773 00000497 448803                          mov [rbx], r8b           ; x
   774 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   775 0000049E 884302                          mov [rbx + 2], al        ; letra
   776 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   777                                          
   778 000004A5 FE05(071A0000)                  inc byte [letters_count]
   779                                          
   780                                      .end:
   781 000004AB 59                              pop rcx
   782 000004AC 5B                              pop rbx
   783 000004AD 5D                              pop rbp
   784 000004AE C3                              ret
   785                                  
   786                                  ; Función para imprimir todas las letras registradas
   787                                  print_letters:
   788 000004AF 55                          push rbp
   789 000004B0 4889E5                      mov rbp, rsp
   790 000004B3 53                          push rbx
   791 000004B4 51                          push rcx
   792                                      
   793 000004B5 4831C9                      xor rcx, rcx
   794                                      
   795                                      .print_loop:
   796 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   797 000004BC 7D37                            jge .end
   798                                          
   799                                          ; Obtener puntero a la letra actual
   800 000004BE 488D1C8D[77180000]              lea rbx, [letters_map + rcx * 4]
   801                                          
   802                                          ; Verificar si está activa
   803 000004C6 807B0300                        cmp byte [rbx + 3], 0
   804 000004CA 7424                            je .next_letter
   805                                          
   806                                          ; Calcular posición en el tablero
   807 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   808 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   809                                          
   810                                          ; Calcular offset en el tablero
   811 000004D5 B850000000                      mov rax, column_cells
   812 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   813 000004DE 49F7E1                          mul r9
   814 000004E1 4C01C0                          add rax, r8
   815 000004E4 488DB8[400A0000]                lea rdi, [board + rax]
   816                                          
   817                                          ; Imprimir la letra
   818 000004EB 8A4302                          mov al, [rbx + 2]
   819 000004EE 8807                            mov [rdi], al
   820                                          
   821                                      .next_letter:
   822 000004F0 48FFC1                          inc rcx
   823 000004F3 EBC3                            jmp .print_loop
   824                                          
   825                                      .end:
   826 000004F5 59                              pop rcx
   827 000004F6 5B                              pop rbx
   828 000004F7 5D                              pop rbp
   829 000004F8 C3                              ret
   830                                  
   831                                  ; Función para borrar una letra específica
   832                                  ; Entrada:
   833                                  ;   r8b - posición x
   834                                  ;   r9b - posición y
   835                                  remove_letter:
   836 000004F9 55                          push rbp
   837 000004FA 4889E5                      mov rbp, rsp
   838 000004FD 53                          push rbx
   839 000004FE 51                          push rcx
   840                                      
   841 000004FF 4831C9                      xor rcx, rcx
   842                                      
   843                                      .find_loop:
   844 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   845 00000506 7D2E                            jge .end
   846                                          
   847 00000508 488D1C8D[77180000]              lea rbx, [letters_map + rcx * 4]
   848                                          
   849                                          ; Verificar si está activa y coincide la posición
   850 00000510 807B0300                        cmp byte [rbx + 3], 0
   851 00000514 741B                            je .next_letter
   852                                          
   853 00000516 8A03                            mov al, [rbx]
   854 00000518 4438C0                          cmp al, r8b
   855 0000051B 7514                            jne .next_letter
   856                                          
   857 0000051D 8A4301                          mov al, [rbx + 1]
   858 00000520 4438C8                          cmp al, r9b
   859 00000523 750C                            jne .next_letter
   860                                          
   861                                          ; Encontrada la letra, desactivarla
   862 00000525 C6430300                        mov byte [rbx + 3], 0
   863 00000529 FE0D(071A0000)                  dec byte [letters_count]
   864 0000052F EB05                            jmp .end
   865                                          
   866                                      .next_letter:
   867 00000531 48FFC1                          inc rcx
   868 00000534 EBCC                            jmp .find_loop
   869                                          
   870                                      .end:
   871 00000536 59                              pop rcx
   872 00000537 5B                              pop rbx
   873 00000538 5D                              pop rbp
   874 00000539 C3                              ret
   875                                  ; Función para mover las letras hacia abajo
   876                                  move_letters:
   877 0000053A 55                          push rbp
   878 0000053B 4889E5                      mov rbp, rsp
   879 0000053E 53                          push rbx
   880 0000053F 57                          push rdi
   881 00000540 56                          push rsi
   882 00000541 4150                        push r8
   883 00000543 4151                        push r9
   884 00000545 4152                        push r10
   885 00000547 4153                        push r11
   886                                  
   887 00000549 4831C9                      xor rcx, rcx
   888                                  
   889                                      .move_loop:
   890 0000054C 4883F964                        cmp rcx, 100
   891 00000550 0F8D0D020000                    jge .print_last_letter
   892                                          
   893 00000556 488D1C8D[77180000]              lea rbx, [letters_map + rcx * 4]
   894 0000055E 807B0300                        cmp byte [rbx + 3], 0
   895 00000562 0F84F3010000                    je .next_letter
   896                                  
   897 00000568 4C0FB603                        movzx r8, byte [rbx]
   898 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
   899                                  
   900 00000571 B850000000                      mov rax, column_cells
   901 00000576 4883C002                        add rax, 2
   902 0000057A 49F7E1                          mul r9
   903 0000057D 4C01C0                          add rax, r8
   904 00000580 488DB8[400A0000]                lea rdi, [board + rax]
   905 00000587 C60720                          mov byte [rdi], ' '
   906                                  
   907 0000058A FE4301                          inc byte [rbx + 1]
   908 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
   909                                  
   910 00000592 4983F91F                        cmp r9, row_cells - 1
   911 00000596 7C09                            jl .check_pallet_collision
   912                                  
   913 00000598 C6430300                        mov byte [rbx + 3], 0
   914 0000059C E9BA010000                      jmp .next_letter
   915                                  
   916                                          .check_pallet_collision:
   917 000005A1 B850000000                          mov rax, column_cells
   918 000005A6 4883C002                            add rax, 2
   919 000005AA 49F7E1                              mul r9
   920 000005AD 4C01C0                              add rax, r8
   921 000005B0 488DB8[400A0000]                    lea rdi, [board + rax]
   922                                  
   923 000005B7 8A07                                mov al, [rdi]
   924 000005B9 3C20                                cmp al, ' '
   925 000005BB 0F849A010000                        je .next_letter
   926 000005C1 3C3D                                cmp al, char_equal
   927 000005C3 740A                                je .capture_letter
   928                                  
   929 000005C5 8A4302                              mov al, [rbx + 2]
   930 000005C8 8807                                mov [rdi], al
   931 000005CA E98C010000                          jmp .next_letter
   932                                  
   933                                          .capture_letter:
   934                                              ; Obtener la nueva letra
   935 000005CF 8A4302                              mov al, [rbx + 2]
   936                                              
   937                                              ; Comparar con la última letra
   938 000005D2 3A05(081A0000)                      cmp al, [last_letter]
   939 000005D8 7407                                je .same_letter
   940                                              
   941                                              ; Es una letra diferente, resetear el procesamiento
   942 000005DA C605(1C1A0000)00                    mov byte [current_power_processed], 0
   943                                              
   944                                              .same_letter:
   945                                              ; Guardar la nueva letra
   946 000005E1 8805(081A0000)                      mov [last_letter], al
   947                                              
   948                                              ; Verificar si es 'E' para extender la paleta
   949 000005E7 3C45                                cmp al, 'E'
   950 000005E9 7450                                je .extend_pallet
   951                                              
   952                                              ; Verificar si es 'P' para añadir vida
   953 000005EB 3C50                                cmp al, 'P'
   954 000005ED 7478                                je .check_add_life
   955                                  
   956 000005EF 3C53                                cmp al, 'S'
   957 000005F1 0F84B4000000                        je .slow_ball
   958                                  
   959 000005F7 3C43                                cmp al, 'C'
   960 000005F9 0F84D8000000                        je .activate_catch
   961                                              
   962 000005FF 3C4C                                cmp al, 'L'
   963 00000601 0F84F9000000                        je .activate_laser
   964                                  
   965 00000607 3C44                                cmp al, 'D'
   966 00000609 0F841A010000                        je .activate_split
   967                                  
   968                                              ; Si no es ningún power-up, restaurar tamaño normal
   969 0000060F 488B05(CF140000)                    mov rax, [default_pallet_size]
   970 00000616 488905(C7140000)                    mov [pallet_size], rax
   971 0000061D 48C705(1E1A0000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   971 00000625 000000             
   972 00000628 C605(361A0000)00                    mov byte [catch_power_active], 0
   973 0000062F C605(431A0000)00                    mov byte [laser_power_active], 0
   974 00000636 E91C010000                          jmp .finish_capture
   975                                  
   976                                              .extend_pallet:
   977 0000063B C605(431A0000)00                        mov byte [laser_power_active], 0
   978 00000642 C605(361A0000)00                        mov byte [catch_power_active], 0
   979 00000649 48C705(1E1A0000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   979 00000651 000000             
   980 00000654 488B05(D7140000)                        mov rax, [extended_pallet_size]
   981 0000065B 488905(C7140000)                        mov [pallet_size], rax
   982 00000662 E9F0000000                              jmp .finish_capture
   983                                  
   984                                              .check_add_life:
   985 00000667 C605(431A0000)00                        mov byte [laser_power_active], 0
   986 0000066E C605(361A0000)00                        mov byte [catch_power_active], 0
   987 00000675 488B05(CF140000)                        mov rax, [default_pallet_size]
   988 0000067C 488905(C7140000)                        mov [pallet_size], rax
   989 00000683 48C705(1E1A0000)01-                     mov qword [ball_speed], 1 
   989 0000068B 000000             
   990                                                  ; Verificar si ya procesamos este power-up
   991 0000068E 803D(1C1A0000)00                        cmp byte [current_power_processed], 0
   992 00000695 0F85BC000000                            jne .finish_capture
   993                                                  
   994                                                  ; Preservar registros importantes
   995 0000069B 51                                      push rcx
   996 0000069C 53                                      push rbx
   997                                                  
   998                                                  ; Marcar como procesado
   999 0000069D C605(1C1A0000)01                        mov byte [current_power_processed], 1
  1000                                                  
  1001                                                  ; Añadir una vida
  1002 000006A4 E838040000                              call add_life
  1003                                                  
  1004                                                  ; Restaurar registros
  1005 000006A9 5B                                      pop rbx
  1006 000006AA 59                                      pop rcx
  1007                                                  
  1008                                              .slow_ball:
  1009 000006AB C605(431A0000)00                        mov byte [laser_power_active], 0
  1010 000006B2 C605(361A0000)00                        mov byte [catch_power_active], 0                
  1011 000006B9 488B05(CF140000)                        mov rax, [default_pallet_size]
  1012 000006C0 488905(C7140000)                        mov [pallet_size], rax
  1013 000006C7 48C705(1E1A0000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
  1013 000006CF 000000             
  1014 000006D2 E980000000                              jmp .finish_capture
  1015                                  
  1016                                              .activate_catch:
  1017 000006D7 C605(431A0000)00                        mov byte [laser_power_active], 0
  1018 000006DE 488B05(CF140000)                        mov rax, [default_pallet_size]
  1019 000006E5 488905(C7140000)                        mov [pallet_size], rax
  1020 000006EC 48C705(1E1A0000)01-                     mov qword [ball_speed], 1
  1020 000006F4 000000             
  1021 000006F7 C605(361A0000)01                        mov byte [catch_power_active], 1
  1022 000006FE EB57                                    jmp .finish_capture
  1023                                  
  1024                                              .activate_laser:
  1025 00000700 C605(361A0000)00                        mov byte [catch_power_active], 0
  1026 00000707 488B05(CF140000)                        mov rax, [default_pallet_size]
  1027 0000070E 488905(C7140000)                        mov [pallet_size], rax
  1028 00000715 48C705(1E1A0000)01-                     mov qword [ball_speed], 1
  1028 0000071D 000000             
  1029 00000720 C605(431A0000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1030 00000727 EB2E                                    jmp .finish_capture
  1031                                  
  1032                                              .activate_split:
  1033 00000729 C605(431A0000)00                        mov byte [laser_power_active], 0
  1034 00000730 C605(361A0000)00                        mov byte [catch_power_active], 0
  1035 00000737 488B05(CF140000)                        mov rax, [default_pallet_size]
  1036 0000073E 488905(C7140000)                        mov [pallet_size], rax
  1037 00000745 48C705(1E1A0000)01-                     mov qword [ball_speed], 1 
  1037 0000074D 000000             
  1038 00000750 E8D2000000                              call activate_split_power
  1039 00000755 EB00                                    jmp .finish_capture
  1040                                  
  1041                                              .finish_capture:
  1042 00000757 C6430300                                mov byte [rbx + 3], 0
  1043                                  
  1044                                          .next_letter:
  1045 0000075B 48FFC1                              inc rcx
  1046 0000075E E9E9FDFFFF                          jmp .move_loop
  1047                                  
  1048                                      .print_last_letter:
  1049                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000763 B801000000          <1>  mov eax, sys_write
    83 00000768 BF01000000          <1>  mov edi, 1
    84 0000076D 48BE-               <1>  mov rsi, %1
    84 0000076F [091A000000000000]  <1>
    85 00000777 BA10000000          <1>  mov edx, %2
    86 0000077C 0F05                <1>  syscall
  1050 0000077E 8A05(081A0000)                  mov al, [last_letter]
  1051 00000784 8805(181A0000)                  mov [last_letter_msg + 15], al
  1052                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000078A B801000000          <1>  mov eax, sys_write
    83 0000078F BF01000000          <1>  mov edi, 1
    84 00000794 48BE-               <1>  mov rsi, %1
    84 00000796 [191A000000000000]  <1>
    85 0000079E BA03000000          <1>  mov edx, %2
    86 000007A3 0F05                <1>  syscall
  1053                                  
  1054                                      .end:
  1055 000007A5 415B                            pop r11
  1056 000007A7 415A                            pop r10
  1057 000007A9 4159                            pop r9
  1058 000007AB 4158                            pop r8
  1059 000007AD 5E                              pop rsi
  1060 000007AE 5F                              pop rdi
  1061 000007AF 5B                              pop rbx
  1062 000007B0 5D                              pop rbp
  1063 000007B1 C3                              ret
  1064                                  
  1065                                  
  1066                                  clear_lasers:
  1067 000007B2 55                          push rbp
  1068 000007B3 4889E5                      mov  rbp, rsp
  1069                                  
  1070                                      ; Recorrer el array de láseres
  1071 000007B6 4831C9                      xor rcx, rcx                ; Índice del láser
  1072 000007B9 480FB61D(451A0000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1073                                  
  1074                                      .clear_loop:
  1075 000007C1 4839D9                          cmp rcx, rbx
  1076 000007C4 7D2F                            jge .done                ; Salir si no quedan láseres
  1077                                  
  1078                                          ; Obtener posición del láser actual
  1079 000007C6 488DB409[461A0000]              lea rsi, [lasers + rcx * 2]
  1080 000007CE 4C0FB606                        movzx r8, byte [rsi]     ; X
  1081 000007D2 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1082                                  
  1083                                          ; Calcular posición en el tablero
  1084 000007D7 B850000000                      mov rax, column_cells
  1085 000007DC 4883C002                        add rax, 2
  1086 000007E0 49F7E1                          mul r9
  1087 000007E3 4C01C0                          add rax, r8
  1088 000007E6 488DB8[400A0000]                lea rdi, [board + rax]
  1089                                  
  1090                                          ; Borrar el láser visualmente
  1091 000007ED C60720                          mov byte [rdi], ' '
  1092                                  
  1093                                          ; Pasar al siguiente láser
  1094 000007F0 48FFC1                          inc rcx
  1095 000007F3 EBCC                            jmp .clear_loop
  1096                                  
  1097                                      .done:
  1098                                          ; Resetear contador de láseres
  1099 000007F5 C605(451A0000)00                mov byte [laser_count], 0
  1100                                  
  1101 000007FC 5D                              pop rbp
  1102 000007FD C3                              ret
  1103                                  
  1104                                  
  1105                                  ; Nueva función para actualizar los láseres
  1106                                  update_lasers:
  1107 000007FE 55                          push rbp
  1108 000007FF 4889E5                      mov rbp, rsp
  1109                                      
  1110                                      ; Verificar si el poder láser está activo
  1111 00000802 803D(431A0000)00            cmp byte [laser_power_active], 0
  1112 00000809 741A                        je .end
  1113                                      
  1114                                      ; Verificar si se presionó la tecla de espacio
  1115 0000080B 803D(421A0000)20            cmp byte [last_key], ' '
  1116 00000812 750C                        jne .skip_shooting
  1117                                      
  1118                                      ; Disparar nuevos láseres
  1119 00000814 E89A000000                  call shoot_lasers
  1120 00000819 C605(421A0000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1121                                      
  1122                                      .skip_shooting:
  1123                                      ; Mover los láseres existentes
  1124 00000820 E828010000                  call move_lasers
  1125                                      
  1126                                      .end:
  1127 00000825 5D                              pop rbp
  1128 00000826 C3                              ret
  1129                                  
  1130                                  activate_split_power:
  1131 00000827 55                          push rbp
  1132 00000828 4889E5                      mov rbp, rsp
  1133                                      
  1134                                      ; Verificar si la bola2 y bola3 ya están activas
  1135 0000082B 803D(22150000)01            cmp byte [ball2_active], 1
  1136 00000832 750B                        jne .enable_balls
  1137 00000834 803D(44150000)01            cmp byte [ball3_active], 1
  1138 0000083B 7502                        jne .enable_balls
  1139                                      
  1140                                      ; Si ambas ya están activas, no hacemos nada.
  1141 0000083D EB72                        jmp .end
  1142                                  
  1143                                  .enable_balls:
  1144                                      ; Copiamos la posición de la bola principal
  1145 0000083F 488B05(DF140000)            mov rax, [ball_x_pos]
  1146 00000846 488905(01150000)            mov [ball2_x_pos], rax
  1147 0000084D 488905(23150000)            mov [ball3_x_pos], rax
  1148                                  
  1149 00000854 488B05(E7140000)            mov rax, [ball_y_pos]
  1150 0000085B 488905(09150000)            mov [ball2_y_pos], rax
  1151 00000862 488905(2B150000)            mov [ball3_y_pos], rax
  1152                                  
  1153                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1154                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1155 00000869 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  1155 00000871 FFFFFF             
  1156 00000874 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  1156 0000087C FFFFFF             
  1157 0000087F C605(21150000)01            mov byte [ball2_moving], 1
  1158 00000886 C605(22150000)01            mov byte [ball2_active], 1
  1159                                  
  1160 0000088D 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  1160 00000895 000000             
  1161 00000898 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  1161 000008A0 FFFFFF             
  1162 000008A3 C605(43150000)01            mov byte [ball3_moving], 1
  1163 000008AA C605(44150000)01            mov byte [ball3_active], 1
  1164                                  
  1165                                  .end:
  1166 000008B1 5D                          pop rbp
  1167 000008B2 C3                          ret
  1168                                  
  1169                                  
  1170                                  shoot_lasers:
  1171 000008B3 55                          push rbp
  1172 000008B4 4889E5                      mov rbp, rsp
  1173 000008B7 53                          push rbx
  1174                                      
  1175                                      ; Verificar si hay espacio para más láseres
  1176 000008B8 480FB605(451A0000)          movzx rax, byte [laser_count]
  1177 000008C0 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1178 000008C4 0F8D80000000                jge .end
  1179                                      
  1180                                      ; Obtener posición de la paleta
  1181 000008CA 4C8B05(BF140000)            mov r8, [pallet_position]
  1182 000008D1 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1183                                      
  1184                                      ; Calcular coordenadas x,y
  1185 000008D8 4C89C0                      mov rax, r8
  1186 000008DB 41B950000000                mov r9, column_cells
  1187 000008E1 4983C102                    add r9, 2                     ; Ancho total de línea
  1188 000008E5 4831D2                      xor rdx, rdx
  1189 000008E8 49F7F1                      div r9                        ; rax = y, rdx = x
  1190                                      
  1191                                      ; Guardar coordenadas
  1192 000008EB 4989C2                      mov r10, rax                  ; Y en r10
  1193 000008EE 4989D3                      mov r11, rdx                  ; X en r11
  1194                                      
  1195                                      ; Validar coordenadas
  1196 000008F1 4983FA00                    cmp r10, 0
  1197 000008F5 7C53                        jl .end
  1198 000008F7 4983FA20                    cmp r10, row_cells
  1199 000008FB 7D4D                        jge .end
  1200 000008FD 4983FB00                    cmp r11, 0
  1201 00000901 7C47                        jl .end
  1202 00000903 4983FB50                    cmp r11, column_cells
  1203 00000907 7D41                        jge .end
  1204                                      
  1205                                      ; Calcular índice para el primer láser
  1206 00000909 480FB61D(451A0000)          movzx rbx, byte [laser_count]
  1207 00000911 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1208                                      
  1209                                      ; Primer láser (izquierda)
  1210 00000915 488DBB[461A0000]            lea rdi, [lasers + rbx]
  1211 0000091C 44881F                      mov [rdi], r11b              ; X
  1212 0000091F 4488D0                      mov al, r10b
  1213 00000922 FEC8                        dec al                       ; Y - 1
  1214 00000924 884701                      mov [rdi + 1], al           ; Y
  1215                                      
  1216                                      ; Segundo láser (derecha)
  1217 00000927 4488D8                      mov al, r11b
  1218 0000092A 0205(C7140000)              add al, byte [pallet_size]
  1219 00000930 FEC8                        dec al                       ; Ajustar para el último carácter
  1220 00000932 488DBB[481A0000]            lea rdi, [lasers + rbx + 2]
  1221 00000939 8807                        mov [rdi], al               ; X
  1222 0000093B 4488D0                      mov al, r10b
  1223 0000093E FEC8                        dec al                      ; Y - 1
  1224 00000940 884701                      mov [rdi + 1], al          ; Y
  1225                                      
  1226                                      ; Incrementar contador de láseres
  1227 00000943 8005(451A0000)02            add byte [laser_count], 2
  1228                                      
  1229                                      
  1230                                      .end:
  1231 0000094A 5B                              pop rbx
  1232 0000094B 5D                              pop rbp
  1233 0000094C C3                              ret
  1234                                  
  1235                                  ; Función corregida para mover láseres
  1236                                  ; Función corregida para mover láseres
  1237                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1238                                  
  1239                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1240                                  ; ============================================================
  1241                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1242                                  ; ============================================================
  1243                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1244                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1245                                  ; ============================================================
  1246                                  move_lasers:
  1247 0000094D 55                          push rbp
  1248 0000094E 4889E5                      mov  rbp, rsp
  1249 00000951 53                          push rbx
  1250 00000952 57                          push rdi
  1251 00000953 56                          push rsi
  1252 00000954 4154                        push r12
  1253 00000956 4155                        push r13
  1254 00000958 4156                        push r14
  1255 0000095A 4157                        push r15
  1256                                  
  1257                                      ; 1) Tomamos la cantidad de láseres
  1258 0000095C 480FB60D(451A0000)          movzx rcx, byte [laser_count]
  1259 00000964 4885C9                      test rcx, rcx
  1260 00000967 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1261                                  
  1262                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1263 0000096D 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1264                                  
  1265                                  .loop_lasers:
  1266                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1267 00000970 488DB409[461A0000]          lea rsi, [lasers + rcx*2]
  1268                                  
  1269                                      ; 2) Cargar x,y actuales del láser
  1270 00000978 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1271 0000097C 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1272                                  
  1273                                      ; 3) Borrar el láser de su posición actual en pantalla
  1274                                      ;    (por si en el ciclo anterior se había dibujado)
  1275 00000981 B850000000                  mov rax, column_cells
  1276 00000986 4883C002                    add rax, 2
  1277 0000098A 49F7E1                      mul r9
  1278 0000098D 4C01C0                      add rax, r8
  1279 00000990 488DB8[400A0000]            lea rdi, [board + rax]
  1280 00000997 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1281                                  
  1282                                      ; 4) Mover el láser hacia arriba (y - 1)
  1283 0000099A 49FFC9                      dec r9
  1284                                  
  1285                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1286 0000099D 4983F901                    cmp r9, 1
  1287 000009A1 7C57                        jl .delete_laser
  1288                                  
  1289                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1290 000009A3 44884E01                    mov byte [rsi + 1], r9b
  1291                                  
  1292                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1293                                      ;    - Primero colisión con bloques
  1294                                      ; ---------------------------------------------------------
  1295                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1296 000009A7 B850000000                  mov rax, column_cells
  1297 000009AC 4883C002                    add rax, 2
  1298 000009B0 49F7E1                      mul r9
  1299 000009B3 4C01C0                      add rax, r8
  1300 000009B6 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1301                                  
  1302                                      ; Revisar si hay bloque
  1303 000009BD 51                          push rcx
  1304 000009BE 56                          push rsi
  1305 000009BF 57                          push rdi
  1306 000009C0 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1307 000009C3 E8F60E0000                  call check_block_collision
  1308 000009C8 5F                          pop rdi
  1309 000009C9 5E                          pop rsi
  1310 000009CA 59                          pop rcx
  1311                                  
  1312 000009CB 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1313 000009CE 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1314                                  
  1315                                      ;    - Luego colisión con enemigos
  1316                                      ; ---------------------------------------------------------
  1317 000009D0 51                          push rcx
  1318 000009D1 56                          push rsi
  1319 000009D2 57                          push rdi
  1320                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1321                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1322                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1323                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1324                                      ;
  1325                                      ; Hacemos algo como:
  1326 000009D3 4989FA                      mov r10, rdi
  1327 000009D6 E85A000000                  call check_laser_enemy_collision
  1328 000009DB 5F                          pop rdi
  1329 000009DC 5E                          pop rsi
  1330 000009DD 59                          pop rcx
  1331                                  
  1332 000009DE 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1333 000009E1 7517                        jnz .delete_laser
  1334                                  
  1335                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1336 000009E3 8A05(441A0000)              mov al, [laser_symbol]
  1337 000009E9 8807                        mov [rdi], al
  1338                                  
  1339                                  .next_laser:
  1340                                      ; Pasamos al láser anterior en el array
  1341 000009EB 48FFC9                      dec rcx
  1342 000009EE 4883F9FF                    cmp rcx, -1
  1343 000009F2 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1344 000009F8 EB2E                        jmp .fin
  1345                                  
  1346                                  ; -----------------------------------------------------------------
  1347                                  ; Subrutina interna: .delete_laser
  1348                                  ; -----------------------------------------------------------------
  1349                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1350                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1351                                  .delete_laser:
  1352 000009FA 4C0FB625(451A0000)          movzx r12, byte [laser_count]
  1353 00000A02 49FFCC                      dec r12                    ; r12 = índice del último láser
  1354 00000A05 4939CC                      cmp r12, rcx
  1355 00000A08 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1356                                  
  1357                                      ; Copiamos el último láser a la posición actual
  1358 00000A0A 488DBC09[461A0000]          lea rdi, [lasers + rcx*2]
  1359 00000A12 4B8DB424[461A0000]          lea rsi, [lasers + r12*2]
  1360 00000A1A 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1361 00000A1D 668907                      mov [rdi], ax             ; copiamos X,Y
  1362                                  
  1363                                  .just_decrement:
  1364 00000A20 FE0D(451A0000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1365 00000A26 EBC3                        jmp .next_laser
  1366                                  
  1367                                  .fin:
  1368 00000A28 415F                        pop r15
  1369 00000A2A 415E                        pop r14
  1370 00000A2C 415D                        pop r13
  1371 00000A2E 415C                        pop r12
  1372 00000A30 5E                          pop rsi
  1373 00000A31 5F                          pop rdi
  1374 00000A32 5B                          pop rbx
  1375 00000A33 5D                          pop rbp
  1376 00000A34 C3                          ret
  1377                                  
  1378                                  
  1379                                  ; Nueva función para verificar colisión entre láser y enemigos
  1380                                  ; ==========================================================
  1381                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1382                                  ; ==========================================================
  1383                                  check_laser_enemy_collision:
  1384 00000A35 55                          push rbp
  1385 00000A36 4889E5                      mov  rbp, rsp
  1386                                      
  1387 00000A39 4D31ED                      xor r13, r13            ; Índice del enemigo
  1388 00000A3C 4831C0                      xor rax, rax            ; 0 = no colisión
  1389                                  
  1390                                  .loop_enemies:
  1391 00000A3F 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1392 00000A43 7D64                        jge .end
  1393                                  
  1394                                      ; r13 * 3 => offset del enemigo i
  1395 00000A45 4C89E9                      mov rcx, r13
  1396 00000A48 486BC903                    imul rcx, 3
  1397 00000A4C 488DB1[9B170000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1398                                  
  1399                                      ; Verificar si está activo
  1400 00000A53 807E0201                    cmp byte [rsi+2], 1
  1401 00000A57 754B                        jne .next_enemy
  1402                                  
  1403                                      ; Cargar posición X/Y del enemigo
  1404 00000A59 4C0FB636                    movzx r14, byte [rsi]      ; X
  1405 00000A5D 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1406                                  
  1407                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1408 00000A62 4D39F0                      cmp r8, r14
  1409 00000A65 753D                        jne .next_enemy
  1410 00000A67 4D39F9                      cmp r9, r15
  1411 00000A6A 7538                        jne .next_enemy
  1412                                  
  1413                                      ; ==== Colisión detectada con láser ====
  1414                                  
  1415                                      ; 1) Desactivar enemigo
  1416 00000A6C C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1417                                  
  1418                                      ; 2) Sumar puntos
  1419 00000A70 488B05(BA170000)            mov rax, [enemy_points]
  1420 00000A77 480105(79170000)            add [current_score], rax
  1421                                  
  1422                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1423                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1424 00000A7E 4983FF1E                    cmp r15, row_cells - 2
  1425 00000A82 7419                        je .skip_erase
  1426                                  
  1427                                      ; Borrar visualmente del board
  1428 00000A84 B850000000                  mov rax, column_cells
  1429 00000A89 4883C002                    add rax, 2
  1430 00000A8D 49F7E7                      mul r15
  1431 00000A90 4C01F0                      add rax, r14
  1432 00000A93 488DB8[400A0000]            lea rdi, [board + rax]
  1433 00000A9A C60720                      mov byte [rdi], ' '
  1434                                  
  1435                                  .skip_erase:
  1436                                  
  1437                                      ; 4) Devolver rax=1 => colisión con enemigo
  1438 00000A9D B801000000                  mov rax, 1
  1439 00000AA2 EB05                        jmp .end
  1440                                  
  1441                                  .next_enemy:
  1442 00000AA4 49FFC5                      inc r13
  1443 00000AA7 EB96                        jmp .loop_enemies
  1444                                  
  1445                                  .end:
  1446 00000AA9 5D                          pop rbp
  1447 00000AAA C3                          ret
  1448                                  
  1449                                  
  1450                                  ; Función auxiliar para eliminar un láser específico
  1451                                  remove_laser:
  1452 00000AAB 55                          push rbp
  1453 00000AAC 4889E5                      mov rbp, rsp
  1454                                  
  1455                                      ; Borrar el láser del tablero
  1456 00000AAF 41C60220                    mov byte [r10], ' '
  1457                                  
  1458                                      ; Mover el último láser a esta posición si no es el último
  1459 00000AB3 480FB605(451A0000)          movzx rax, byte [laser_count]
  1460 00000ABB 48FFC8                      dec rax                    ; Índice del último láser
  1461 00000ABE 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1462 00000AC1 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1463                                  
  1464                                      ; Copiar último láser a la posición actual
  1465 00000AC3 4B8DBC24[461A0000]          lea rdi, [lasers + r12*2]
  1466 00000ACB 488DB400[461A0000]          lea rsi, [lasers + rax*2]
  1467 00000AD3 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1468 00000AD6 668917                      mov [rdi], dx
  1469                                  
  1470                                  .just_decrease:
  1471 00000AD9 FE0D(451A0000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1472                                  
  1473 00000ADF 5D                          pop rbp
  1474 00000AE0 C3                          ret
  1475                                  
  1476                                  add_life:
  1477 00000AE1 55                          push rbp
  1478 00000AE2 4889E5                      mov rbp, rsp
  1479 00000AE5 53                          push rbx
  1480 00000AE6 51                          push rcx
  1481 00000AE7 57                          push rdi
  1482 00000AE8 56                          push rsi
  1483 00000AE9 4150                        push r8
  1484 00000AEB 4151                        push r9
  1485                                      
  1486                                      ; Verificar si ya tenemos el máximo de vidas
  1487 00000AED 480FB605(76180000)          movzx rax, byte [current_lives]
  1488 00000AF5 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1489 00000AF9 7D2C                        jge .end
  1490                                      
  1491                                      ; Incrementar el contador de vidas
  1492 00000AFB FE05(76180000)              inc byte [current_lives]
  1493                                      
  1494                                      ; Encontrar la siguiente vida inactiva
  1495 00000B01 4831C9                      xor rcx, rcx
  1496                                      
  1497                                      .find_inactive:
  1498 00000B04 4883F907                        cmp rcx, lives_count
  1499 00000B08 7D1D                            jge .end
  1500                                          
  1501                                          ; Calcular offset de la vida actual
  1502 00000B0A 4889C8                          mov rax, rcx
  1503 00000B0D 486BC003                        imul rax, 3
  1504 00000B11 488DB0[60180000]                lea rsi, [lives_data + rax]
  1505                                          
  1506                                          ; Verificar si está inactiva
  1507 00000B18 807E0200                        cmp byte [rsi + 2], 0
  1508 00000B1C 7405                            je .activate_life
  1509                                          
  1510 00000B1E 48FFC1                          inc rcx
  1511 00000B21 EBE1                            jmp .find_inactive
  1512                                          
  1513                                      .activate_life:
  1514                                          ; Activar la vida
  1515 00000B23 C6460201                        mov byte [rsi + 2], 1
  1516                                          
  1517                                      .end:
  1518 00000B27 4159                            pop r9
  1519 00000B29 4158                            pop r8
  1520 00000B2B 5E                              pop rsi
  1521 00000B2C 5F                              pop rdi
  1522 00000B2D 59                              pop rcx
  1523 00000B2E 5B                              pop rbx
  1524 00000B2F 5D                              pop rbp
  1525 00000B30 C3                              ret
  1526                                  
  1527                                  
  1528                                  print_ball:
  1529 00000B31 4C8B05(DF140000)        	mov r8, [ball_x_pos]
  1530 00000B38 4C8B0D(E7140000)        	mov r9, [ball_y_pos]
  1531 00000B3F 4981C0[400A0000]        	add r8, board
  1532                                  
  1533 00000B46 4C89C9                  	mov rcx, r9
  1534 00000B49 B852000000              	mov rax, column_cells + 2
  1535 00000B4E 48F7E9                  	imul rcx
  1536                                  	
  1537 00000B51 4901C0                  	add r8, rax
  1538 00000B54 41C6004F                	mov byte [r8], char_O
  1539 00000B58 C3                      	ret
  1540                                  
  1541                                  print_ball_2:
  1542 00000B59 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1543 00000B60 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1544 00000B67 4981C0[400A0000]            add r8, board
  1545 00000B6E 4C89C9                      mov rcx, r9
  1546 00000B71 B852000000                  mov rax, column_cells + 2
  1547 00000B76 48F7E9                      imul rcx
  1548 00000B79 4901C0                      add r8, rax
  1549 00000B7C 41C6004F                    mov byte [r8], char_O
  1550 00000B80 C3                          ret
  1551                                  
  1552                                  print_ball_3:
  1553 00000B81 4C8B05(23150000)            mov r8, [ball3_x_pos]
  1554 00000B88 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  1555 00000B8F 4981C0[400A0000]            add r8, board
  1556 00000B96 4C89C9                      mov rcx, r9
  1557 00000B99 B852000000                  mov rax, column_cells + 2
  1558 00000B9E 48F7E9                      imul rcx
  1559 00000BA1 4901C0                      add r8, rax
  1560 00000BA4 41C6004F                    mov byte [r8], char_O
  1561 00000BA8 C3                          ret
  1562                                  
  1563                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1564                                  	
  1565                                  print_pallet:
  1566                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1567 00000BA9 4C8B05(BF140000)            mov r8, [pallet_position]
  1568 00000BB0 488B0D(D7140000)            mov rcx, [extended_pallet_size]
  1569                                      .clear_pallet:
  1570 00000BB7 41C60020                        mov byte [r8], char_space
  1571 00000BBB 49FFC0                          inc r8
  1572 00000BBE 48FFC9                          dec rcx
  1573 00000BC1 75F4                            jnz .clear_pallet
  1574                                  
  1575                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1576 00000BC3 4C8B05(BF140000)            mov r8, [pallet_position]
  1577 00000BCA 488B0D(C7140000)            mov rcx, [pallet_size]
  1578                                      .write_pallet:
  1579 00000BD1 41C6003D                        mov byte [r8], char_equal
  1580 00000BD5 49FFC0                          inc r8
  1581 00000BD8 48FFC9                          dec rcx
  1582 00000BDB 75F4                            jnz .write_pallet
  1583                                  
  1584 00000BDD C3                          ret
  1585                                  
  1586                                  move_pallet:
  1587                                      
  1588 00000BDE 803D(FF140000)00            cmp byte [ball_moving], 0
  1589 00000BE5 7507                        jne .continue_movement
  1590 00000BE7 C605(FF140000)01            mov byte [ball_moving], 1
  1591                                  
  1592                                      .continue_movement:
  1593 00000BEE 4883FFFF                        cmp rdi, left_direction
  1594 00000BF2 7531                            jne .move_right
  1595                                  
  1596                                          .move_left:
  1597                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1598 00000BF4 4C8B05(BF140000)                    mov r8, [pallet_position]
  1599 00000BFB 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1600 00000BFE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1601 00000C01 3C58                                cmp al, 'X'        ; Comparar si es una X
  1602 00000C03 744E                                je .end            ; Si es X, no mover
  1603                                              
  1604 00000C05 4C8B05(BF140000)                    mov r8, [pallet_position]
  1605 00000C0C 4C8B0D(C7140000)                    mov r9, [pallet_size]
  1606 00000C13 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1607 00000C19 49FFC8                              dec r8
  1608 00000C1C 4C8905(BF140000)                    mov [pallet_position], r8
  1609 00000C23 EB2E                                jmp .end
  1610                                              
  1611                                          .move_right:
  1612                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1613 00000C25 4C8B05(BF140000)                    mov r8, [pallet_position]
  1614 00000C2C 4C8B0D(C7140000)                    mov r9, [pallet_size]
  1615 00000C33 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1616 00000C36 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1617 00000C3A 3C58                                cmp al, 'X'        ; Comparar si es una X
  1618 00000C3C 7415                                je .end            ; Si es X, no mover
  1619                                              
  1620 00000C3E 4C8B05(BF140000)                    mov r8, [pallet_position]
  1621 00000C45 41C60020                            mov byte [r8], char_space
  1622 00000C49 49FFC0                              inc r8
  1623 00000C4C 4C8905(BF140000)                    mov [pallet_position], r8
  1624                                          .end:
  1625 00000C53 C3                                  ret
  1626                                  
  1627                                  
  1628                                  
  1629                                              
  1630                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1631                                  update_caught_ball_position:
  1632 00000C54 55                          push rbp
  1633 00000C55 4889E5                      mov rbp, rsp
  1634                                      
  1635                                      ; Calcular la nueva posición de la bola basada en la paleta
  1636 00000C58 4C8B05(BF140000)            mov r8, [pallet_position]
  1637 00000C5F 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  1638 00000C66 B852000000                  mov rax, column_cells + 2
  1639 00000C6B 4831D2                      xor rdx, rdx
  1640 00000C6E 48F7F0                      div rax                ; División para obtener X,Y
  1641                                      
  1642                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1643 00000C71 4989C1                      mov r9, rax            ; Y de la paleta
  1644 00000C74 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1645                                      
  1646                                      ; Añadir el offset guardado a la posición X
  1647 00000C77 4889D0                      mov rax, rdx
  1648 00000C7A 480305(3A1A0000)            add rax, [ball_catch_offset]
  1649 00000C81 488905(DF140000)            mov [ball_x_pos], rax
  1650 00000C88 4C890D(E7140000)            mov [ball_y_pos], r9
  1651                                      
  1652 00000C8F 5D                          pop rbp
  1653 00000C90 C3                          ret
  1654                                  
  1655                                  
  1656                                  move_all_balls:
  1657 00000C91 55                          push rbp
  1658 00000C92 4889E5                      mov rbp, rsp
  1659 00000C95 53                          push rbx
  1660                                      
  1661                                      ; Inicializar contador de bolas
  1662 00000C96 4831DB                      xor rbx, rbx
  1663                                      
  1664                                  .loop_balls:
  1665                                      ; Verificar si hemos procesado todas las bolas
  1666 00000C99 3A1D(791B0000)              cmp bl, byte [balls_count]
  1667 00000C9F 7D1D                        jge .end
  1668                                      
  1669                                      ; Calcular offset de la bola actual
  1670 00000CA1 B821000000                  mov rax, BALL_STRUCT_SIZE
  1671 00000CA6 48F7E3                      mul rbx
  1672                                      
  1673                                      ; Verificar si la bola está activa
  1674 00000CA9 80B8[361B0000]01            cmp byte [balls_data + rax + 32], 1
  1675 00000CB0 7507                        jne .next_ball
  1676                                      
  1677                                      ; Guardar offset en la pila
  1678 00000CB2 50                          push rax
  1679                                      
  1680                                      ; Llamar a move_ball con los parámetros de esta bola
  1681 00000CB3 E809000000                  call move_ball
  1682                                      
  1683                                      ; Restaurar offset
  1684 00000CB8 58                          pop rax
  1685                                      
  1686                                  .next_ball:
  1687 00000CB9 48FFC3                      inc rbx
  1688 00000CBC EBDB                        jmp .loop_balls
  1689                                      
  1690                                  .end:
  1691 00000CBE 5B                          pop rbx
  1692 00000CBF 5D                          pop rbp
  1693 00000CC0 C3                          ret
  1694                                  
  1695                                  move_ball:
  1696                                  
  1697 00000CC1 803D(371A0000)01            cmp byte [ball_caught], 1
  1698 00000CC8 0F849D000000                je .move_with_pallet
  1699                                  
  1700 00000CCE 803D(FF140000)00            cmp byte [ball_moving], 0
  1701 00000CD5 0F84B8010000                je .end
  1702                                  
  1703                                      ; Incrementar contador de velocidad
  1704 00000CDB 48FF05(2E1A0000)            inc qword [speed_counter]
  1705                                      
  1706                                      ; Verificar si debemos mover la bola en este ciclo
  1707 00000CE2 488B05(2E1A0000)            mov rax, [speed_counter]
  1708 00000CE9 483B05(1E1A0000)            cmp rax, [ball_speed]
  1709 00000CF0 0F8C9D010000                jl .end
  1710                                      
  1711                                      ; Resetear contador de velocidad
  1712 00000CF6 48C705(2E1A0000)00-         mov qword [speed_counter], 0
  1712 00000CFE 000000             
  1713                                  
  1714                                      ; Borrar la posición actual de la bola
  1715 00000D01 4C8B05(DF140000)            mov r8, [ball_x_pos]
  1716 00000D08 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  1717 00000D0F 4981C0[400A0000]            add r8, board
  1718 00000D16 4C89C9                      mov rcx, r9
  1719 00000D19 B852000000                  mov rax, column_cells + 2
  1720 00000D1E 48F7E9                      imul rcx
  1721 00000D21 4901C0                      add r8, rax
  1722 00000D24 41C60020                    mov byte [r8], char_space
  1723                                  
  1724                                      ; Calcular siguiente posición X
  1725 00000D28 4C8B05(DF140000)            mov r8, [ball_x_pos]
  1726 00000D2F 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  1727 00000D36 488B05(EF140000)            mov rax, [ball_direction_x]
  1728 00000D3D 4901C0                      add r8, rax               ; Nueva posición X
  1729                                  
  1730                                      ; Calcular la dirección de memoria para la siguiente posición
  1731 00000D40 4D89C2                      mov r10, r8
  1732 00000D43 4981C2[400A0000]            add r10, board
  1733 00000D4A 4C89C9                      mov rcx, r9
  1734 00000D4D B852000000                  mov rax, column_cells + 2
  1735 00000D52 48F7E9                      imul rcx
  1736 00000D55 4901C2                      add r10, rax
  1737                                  
  1738                                      ; Verificar si hay una X en la siguiente posición X
  1739 00000D58 418A02                      mov al, [r10]
  1740 00000D5B 3C58                        cmp al, 'X'
  1741 00000D5D 7565                        jne .check_block_x
  1742 00000D5F 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1743 00000D66 E928010000                  jmp .end
  1744                                  
  1745                                      .move_with_pallet:
  1746                                          ; Borrar la posición actual de la bola
  1747 00000D6B 4C8B05(DF140000)                mov r8, [ball_x_pos]
  1748 00000D72 4C8B0D(E7140000)                mov r9, [ball_y_pos]
  1749 00000D79 4D89C2                          mov r10, r8
  1750 00000D7C 4981C2[400A0000]                add r10, board
  1751 00000D83 4C89C9                          mov rcx, r9
  1752 00000D86 B852000000                      mov rax, column_cells + 2
  1753 00000D8B 48F7E9                          imul rcx
  1754 00000D8E 4901C2                          add r10, rax
  1755 00000D91 41C60220                        mov byte [r10], char_space
  1756                                  
  1757                                          ; Actualizar posición X basada en la paleta
  1758 00000D95 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1759 00000D9C 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1760 00000DA3 4C0305(3A1A0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1761 00000DAA 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1762                                  
  1763                                          ; Mantener la bola una posición arriba de la paleta
  1764 00000DB1 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1765 00000DB8 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1766                                  
  1767 00000DBF E9CF000000                      jmp .end
  1768                                  
  1769                                  
  1770                                      .check_block_x:
  1771                                          ; Verificar colisión con bloques en X
  1772 00000DC4 4150                            push r8     ; Guardar registros que usa check_block_collision
  1773 00000DC6 4151                            push r9
  1774 00000DC8 4152                            push r10
  1775 00000DCA E8EF0A0000                      call check_block_collision
  1776 00000DCF 415A                            pop r10
  1777 00000DD1 4159                            pop r9
  1778 00000DD3 4158                            pop r8
  1779 00000DD5 4885C0                          test rax, rax
  1780 00000DD8 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1781 00000DDA 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1782 00000DE1 E9AD000000                      jmp .end
  1783                                  
  1784                                      .check_paddle_x:
  1785                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1786 00000DE6 41803A3D                        cmp byte [r10], char_equal
  1787 00000DEA 750C                            jne .check_y_movement
  1788 00000DEC 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1789 00000DF3 E99B000000                      jmp .end
  1790                                  
  1791                                      .check_y_movement:
  1792                                          ; Calcular siguiente posición Y
  1793 00000DF8 488B05(F7140000)                mov rax, [ball_direction_y]
  1794 00000DFF 4901C1                          add r9, rax                  ; Nueva posición Y
  1795                                  
  1796                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1797 00000E02 4D89C2                          mov r10, r8
  1798 00000E05 4981C2[400A0000]                add r10, board
  1799 00000E0C 4C89C9                          mov rcx, r9
  1800 00000E0F B852000000                      mov rax, column_cells + 2
  1801 00000E14 48F7E9                          imul rcx
  1802 00000E17 4901C2                          add r10, rax
  1803                                  
  1804                                          ; Verificar si hay una X en la siguiente posición Y
  1805 00000E1A 418A02                          mov al, [r10]
  1806 00000E1D 3C58                            cmp al, 'X'
  1807 00000E1F 7509                            jne .check_block_y
  1808 00000E21 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1809 00000E28 EB69                            jmp .end
  1810                                  
  1811                                      .check_block_y:
  1812                                          ; Verificar colisión con bloques en Y
  1813 00000E2A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1814 00000E2C 4151                            push r9
  1815 00000E2E 4152                            push r10
  1816 00000E30 E8890A0000                      call check_block_collision
  1817 00000E35 415A                            pop r10
  1818 00000E37 4159                            pop r9
  1819 00000E39 4158                            pop r8
  1820 00000E3B 4885C0                          test rax, rax
  1821 00000E3E 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1822 00000E40 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1823 00000E47 EB4A                            jmp .end
  1824                                  
  1825                                      .check_paddle_y:
  1826                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1827 00000E49 41803A3D                        cmp byte [r10], char_equal
  1828 00000E4D 7536                            jne .update_position
  1829                                  
  1830                                          ; Verificar si el poder catch está activo
  1831 00000E4F 803D(361A0000)01                cmp byte [catch_power_active], 1
  1832 00000E56 7524                            jne .normal_bounce
  1833                                  
  1834                                          ; Activar el modo "atrapado"
  1835 00000E58 C605(371A0000)01                mov byte [ball_caught], 1
  1836                                          
  1837                                          ; Guardar la posición X actual de la bola como offset
  1838 00000E5F 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1839 00000E66 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1840 00000E6D 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1841 00000E73 488905(3A1A0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1842                                          
  1843 00000E7A EB17                            jmp .end
  1844                                  
  1845                                      .normal_bounce:
  1846 00000E7C 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1847 00000E83 EB0E                            jmp .end
  1848                                  
  1849                                  
  1850                                      .update_position:
  1851 00000E85 4C8905(DF140000)                mov [ball_x_pos], r8
  1852 00000E8C 4C890D(E7140000)                mov [ball_y_pos], r9
  1853                                  
  1854                                      .end:
  1855 00000E93 C3                              ret
  1856                                  
  1857                                  
  1858                                  move_ball_2:
  1859                                  
  1860 00000E94 803D(381A0000)01            cmp byte [ball_caught_2], 1
  1861 00000E9B 0F849D000000                je .move_with_pallet
  1862                                  
  1863 00000EA1 803D(21150000)00            cmp byte [ball2_moving], 0
  1864 00000EA8 0F84B8010000                je .end
  1865                                  
  1866                                      ; Incrementar contador de velocidad
  1867 00000EAE 48FF05(2E1A0000)            inc qword [speed_counter]
  1868                                      
  1869                                      ; Verificar si debemos mover la bola en este ciclo
  1870 00000EB5 488B05(2E1A0000)            mov rax, [speed_counter]
  1871 00000EBC 483B05(1E1A0000)            cmp rax, [ball_speed]
  1872 00000EC3 0F8C9D010000                jl .end
  1873                                      
  1874                                      ; Resetear contador de velocidad
  1875 00000EC9 48C705(2E1A0000)00-         mov qword [speed_counter], 0
  1875 00000ED1 000000             
  1876                                  
  1877                                      ; Borrar la posición actual de la bola
  1878 00000ED4 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1879 00000EDB 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1880 00000EE2 4981C0[400A0000]            add r8, board
  1881 00000EE9 4C89C9                      mov rcx, r9
  1882 00000EEC B852000000                  mov rax, column_cells + 2
  1883 00000EF1 48F7E9                      imul rcx
  1884 00000EF4 4901C0                      add r8, rax
  1885 00000EF7 41C60020                    mov byte [r8], char_space
  1886                                  
  1887                                      ; Calcular siguiente posición X
  1888 00000EFB 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1889 00000F02 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1890 00000F09 488B05(11150000)            mov rax, [ball2_direction_x]
  1891 00000F10 4901C0                      add r8, rax               ; Nueva posición X
  1892                                  
  1893                                      ; Calcular la dirección de memoria para la siguiente posición
  1894 00000F13 4D89C2                      mov r10, r8
  1895 00000F16 4981C2[400A0000]            add r10, board
  1896 00000F1D 4C89C9                      mov rcx, r9
  1897 00000F20 B852000000                  mov rax, column_cells + 2
  1898 00000F25 48F7E9                      imul rcx
  1899 00000F28 4901C2                      add r10, rax
  1900                                  
  1901                                      ; Verificar si hay una X en la siguiente posición X
  1902 00000F2B 418A02                      mov al, [r10]
  1903 00000F2E 3C58                        cmp al, 'X'
  1904 00000F30 7565                        jne .check_block_x
  1905 00000F32 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1906 00000F39 E928010000                  jmp .end
  1907                                  
  1908                                      .move_with_pallet:
  1909                                          ; Borrar la posición actual de la bola
  1910 00000F3E 4C8B05(01150000)                mov r8, [ball2_x_pos]
  1911 00000F45 4C8B0D(09150000)                mov r9, [ball2_y_pos]
  1912 00000F4C 4D89C2                          mov r10, r8
  1913 00000F4F 4981C2[400A0000]                add r10, board
  1914 00000F56 4C89C9                          mov rcx, r9
  1915 00000F59 B852000000                      mov rax, column_cells + 2
  1916 00000F5E 48F7E9                          imul rcx
  1917 00000F61 4901C2                          add r10, rax
  1918 00000F64 41C60220                        mov byte [r10], char_space
  1919                                  
  1920                                          ; Actualizar posición X basada en la paleta
  1921 00000F68 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1922 00000F6F 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1923 00000F76 4C0305(3A1A0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1924 00000F7D 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1925                                  
  1926                                          ; Mantener la bola una posición arriba de la paleta
  1927 00000F84 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1928 00000F8B 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1929                                  
  1930 00000F92 E9CF000000                      jmp .end
  1931                                  
  1932                                  
  1933                                      .check_block_x:
  1934                                          ; Verificar colisión con bloques en X
  1935 00000F97 4150                            push r8     ; Guardar registros que usa check_block_collision
  1936 00000F99 4151                            push r9
  1937 00000F9B 4152                            push r10
  1938 00000F9D E81C090000                      call check_block_collision
  1939 00000FA2 415A                            pop r10
  1940 00000FA4 4159                            pop r9
  1941 00000FA6 4158                            pop r8
  1942 00000FA8 4885C0                          test rax, rax
  1943 00000FAB 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1944 00000FAD 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1945 00000FB4 E9AD000000                      jmp .end
  1946                                  
  1947                                      .check_paddle_x:
  1948                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1949 00000FB9 41803A3D                        cmp byte [r10], char_equal
  1950 00000FBD 750C                            jne .check_y_movement
  1951 00000FBF 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1952 00000FC6 E99B000000                      jmp .end
  1953                                  
  1954                                      .check_y_movement:
  1955                                          ; Calcular siguiente posición Y
  1956 00000FCB 488B05(19150000)                mov rax, [ball2_direction_y]
  1957 00000FD2 4901C1                          add r9, rax                  ; Nueva posición Y
  1958                                  
  1959                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1960 00000FD5 4D89C2                          mov r10, r8
  1961 00000FD8 4981C2[400A0000]                add r10, board
  1962 00000FDF 4C89C9                          mov rcx, r9
  1963 00000FE2 B852000000                      mov rax, column_cells + 2
  1964 00000FE7 48F7E9                          imul rcx
  1965 00000FEA 4901C2                          add r10, rax
  1966                                  
  1967                                          ; Verificar si hay una X en la siguiente posición Y
  1968 00000FED 418A02                          mov al, [r10]
  1969 00000FF0 3C58                            cmp al, 'X'
  1970 00000FF2 7509                            jne .check_block_y
  1971 00000FF4 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1972 00000FFB EB69                            jmp .end
  1973                                  
  1974                                      .check_block_y:
  1975                                          ; Verificar colisión con bloques en Y
  1976 00000FFD 4150                            push r8     ; Guardar registros que usa check_block_collision
  1977 00000FFF 4151                            push r9
  1978 00001001 4152                            push r10
  1979 00001003 E8B6080000                      call check_block_collision
  1980 00001008 415A                            pop r10
  1981 0000100A 4159                            pop r9
  1982 0000100C 4158                            pop r8
  1983 0000100E 4885C0                          test rax, rax
  1984 00001011 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1985 00001013 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1986 0000101A EB4A                            jmp .end
  1987                                  
  1988                                      .check_paddle_y:
  1989                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1990 0000101C 41803A3D                        cmp byte [r10], char_equal
  1991 00001020 7536                            jne .update_position
  1992                                  
  1993                                          ; Verificar si el poder catch está activo
  1994 00001022 803D(361A0000)01                cmp byte [catch_power_active], 1
  1995 00001029 7524                            jne .normal_bounce
  1996                                  
  1997                                          ; Activar el modo "atrapado"
  1998 0000102B C605(381A0000)01                mov byte [ball_caught_2], 1
  1999                                          
  2000                                          ; Guardar la posición X actual de la bola como offset
  2001 00001032 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2002 00001039 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2003 00001040 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2004 00001046 488905(3A1A0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2005                                          
  2006 0000104D EB17                            jmp .end
  2007                                  
  2008                                      .normal_bounce:
  2009 0000104F 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2010 00001056 EB0E                            jmp .end
  2011                                  
  2012                                  
  2013                                      .update_position:
  2014 00001058 4C8905(01150000)                mov [ball2_x_pos], r8
  2015 0000105F 4C890D(09150000)                mov [ball2_y_pos], r9
  2016                                  
  2017                                      .end:
  2018 00001066 C3                              ret
  2019                                  
  2020                                  move_ball_3:
  2021                                  
  2022 00001067 803D(391A0000)01            cmp byte [ball_caught_3], 1
  2023 0000106E 0F849D000000                je .move_with_pallet
  2024                                  
  2025 00001074 803D(43150000)00            cmp byte [ball3_moving], 0
  2026 0000107B 0F84B8010000                je .end
  2027                                  
  2028                                      ; Incrementar contador de velocidad
  2029 00001081 48FF05(2E1A0000)            inc qword [speed_counter]
  2030                                      
  2031                                      ; Verificar si debemos mover la bola en este ciclo
  2032 00001088 488B05(2E1A0000)            mov rax, [speed_counter]
  2033 0000108F 483B05(1E1A0000)            cmp rax, [ball_speed]
  2034 00001096 0F8C9D010000                jl .end
  2035                                      
  2036                                      ; Resetear contador de velocidad
  2037 0000109C 48C705(2E1A0000)00-         mov qword [speed_counter], 0
  2037 000010A4 000000             
  2038                                  
  2039                                      ; Borrar la posición actual de la bola
  2040 000010A7 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2041 000010AE 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2042 000010B5 4981C0[400A0000]            add r8, board
  2043 000010BC 4C89C9                      mov rcx, r9
  2044 000010BF B852000000                  mov rax, column_cells + 2
  2045 000010C4 48F7E9                      imul rcx
  2046 000010C7 4901C0                      add r8, rax
  2047 000010CA 41C60020                    mov byte [r8], char_space
  2048                                  
  2049                                      ; Calcular siguiente posición X
  2050 000010CE 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2051 000010D5 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2052 000010DC 488B05(33150000)            mov rax, [ball3_direction_x]
  2053 000010E3 4901C0                      add r8, rax               ; Nueva posición X
  2054                                  
  2055                                      ; Calcular la dirección de memoria para la siguiente posición
  2056 000010E6 4D89C2                      mov r10, r8
  2057 000010E9 4981C2[400A0000]            add r10, board
  2058 000010F0 4C89C9                      mov rcx, r9
  2059 000010F3 B852000000                  mov rax, column_cells + 2
  2060 000010F8 48F7E9                      imul rcx
  2061 000010FB 4901C2                      add r10, rax
  2062                                  
  2063                                      ; Verificar si hay una X en la siguiente posición X
  2064 000010FE 418A02                      mov al, [r10]
  2065 00001101 3C58                        cmp al, 'X'
  2066 00001103 7565                        jne .check_block_x
  2067 00001105 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2068 0000110C E928010000                  jmp .end
  2069                                  
  2070                                      .move_with_pallet:
  2071                                          ; Borrar la posición actual de la bola
  2072 00001111 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2073 00001118 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2074 0000111F 4D89C2                          mov r10, r8
  2075 00001122 4981C2[400A0000]                add r10, board
  2076 00001129 4C89C9                          mov rcx, r9
  2077 0000112C B852000000                      mov rax, column_cells + 2
  2078 00001131 48F7E9                          imul rcx
  2079 00001134 4901C2                          add r10, rax
  2080 00001137 41C60220                        mov byte [r10], char_space
  2081                                  
  2082                                          ; Actualizar posición X basada en la paleta
  2083 0000113B 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2084 00001142 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2085 00001149 4C0305(3A1A0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2086 00001150 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2087                                  
  2088                                          ; Mantener la bola una posición arriba de la paleta
  2089 00001157 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2090 0000115E 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2091                                  
  2092 00001165 E9CF000000                      jmp .end
  2093                                  
  2094                                  
  2095                                      .check_block_x:
  2096                                          ; Verificar colisión con bloques en X
  2097 0000116A 4150                            push r8     ; Guardar registros que usa check_block_collision
  2098 0000116C 4151                            push r9
  2099 0000116E 4152                            push r10
  2100 00001170 E849070000                      call check_block_collision
  2101 00001175 415A                            pop r10
  2102 00001177 4159                            pop r9
  2103 00001179 4158                            pop r8
  2104 0000117B 4885C0                          test rax, rax
  2105 0000117E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2106 00001180 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2107 00001187 E9AD000000                      jmp .end
  2108                                  
  2109                                      .check_paddle_x:
  2110                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2111 0000118C 41803A3D                        cmp byte [r10], char_equal
  2112 00001190 750C                            jne .check_y_movement
  2113 00001192 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2114 00001199 E99B000000                      jmp .end
  2115                                  
  2116                                      .check_y_movement:
  2117                                          ; Calcular siguiente posición Y
  2118 0000119E 488B05(3B150000)                mov rax, [ball3_direction_y]
  2119 000011A5 4901C1                          add r9, rax                  ; Nueva posición Y
  2120                                  
  2121                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2122 000011A8 4D89C2                          mov r10, r8
  2123 000011AB 4981C2[400A0000]                add r10, board
  2124 000011B2 4C89C9                          mov rcx, r9
  2125 000011B5 B852000000                      mov rax, column_cells + 2
  2126 000011BA 48F7E9                          imul rcx
  2127 000011BD 4901C2                          add r10, rax
  2128                                  
  2129                                          ; Verificar si hay una X en la siguiente posición Y
  2130 000011C0 418A02                          mov al, [r10]
  2131 000011C3 3C58                            cmp al, 'X'
  2132 000011C5 7509                            jne .check_block_y
  2133 000011C7 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2134 000011CE EB69                            jmp .end
  2135                                  
  2136                                      .check_block_y:
  2137                                          ; Verificar colisión con bloques en Y
  2138 000011D0 4150                            push r8     ; Guardar registros que usa check_block_collision
  2139 000011D2 4151                            push r9
  2140 000011D4 4152                            push r10
  2141 000011D6 E8E3060000                      call check_block_collision
  2142 000011DB 415A                            pop r10
  2143 000011DD 4159                            pop r9
  2144 000011DF 4158                            pop r8
  2145 000011E1 4885C0                          test rax, rax
  2146 000011E4 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2147 000011E6 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2148 000011ED EB4A                            jmp .end
  2149                                  
  2150                                      .check_paddle_y:
  2151                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2152 000011EF 41803A3D                        cmp byte [r10], char_equal
  2153 000011F3 7536                            jne .update_position
  2154                                  
  2155                                          ; Verificar si el poder catch está activo
  2156 000011F5 803D(361A0000)01                cmp byte [catch_power_active], 1
  2157 000011FC 7524                            jne .normal_bounce
  2158                                  
  2159                                          ; Activar el modo "atrapado"
  2160 000011FE C605(391A0000)01                mov byte [ball_caught_3], 1
  2161                                          
  2162                                          ; Guardar la posición X actual de la bola como offset
  2163 00001205 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2164 0000120C 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2165 00001213 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2166 00001219 488905(3A1A0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2167                                          
  2168 00001220 EB17                            jmp .end
  2169                                  
  2170                                      .normal_bounce:
  2171 00001222 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2172 00001229 EB0E                            jmp .end
  2173                                  
  2174                                  
  2175                                      .update_position:
  2176 0000122B 4C8905(23150000)                mov [ball3_x_pos], r8
  2177 00001232 4C890D(2B150000)                mov [ball3_y_pos], r9
  2178                                  
  2179                                      .end:
  2180 00001239 C3                              ret
  2181                                  
  2182                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2183                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2184                                  process_catch_release:
  2185 0000123A 55                          push rbp
  2186 0000123B 4889E5                      mov  rbp, rsp
  2187                                  
  2188                                      ; Verificar si el poder está activo
  2189 0000123E 803D(361A0000)01            cmp byte [catch_power_active], 1
  2190 00001245 0F8586000000                jne .no_catch_power
  2191                                  
  2192                                      ; Verificar si se presionó 'c'
  2193 0000124B 803D(421A0000)63            cmp byte [last_key], 'c'
  2194 00001252 757D                        jne .no_catch_power
  2195                                  
  2196                                      ; Ahora revisamos bola 1
  2197 00001254 803D(371A0000)01            cmp byte [ball_caught], 1
  2198 0000125B 751F                        jne .check_ball2
  2199                                      ; Suelta la bola 1
  2200 0000125D C605(371A0000)00            mov byte [ball_caught], 0
  2201 00001264 48C705(EF140000)01-         mov qword [ball_direction_x], 1
  2201 0000126C 000000             
  2202 0000126F 48C705(F7140000)FF-         mov qword [ball_direction_y], -1
  2202 00001277 FFFFFF             
  2203 0000127A EB4E                        jmp .finish
  2204                                  
  2205                                  .check_ball2:
  2206 0000127C 803D(381A0000)01            cmp byte [ball_caught_2], 1
  2207 00001283 751F                        jne .check_ball3
  2208                                      ; Suelta la bola 2
  2209 00001285 C605(381A0000)00            mov byte [ball_caught_2], 0
  2210 0000128C 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2210 00001294 000000             
  2211 00001297 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2211 0000129F FFFFFF             
  2212 000012A2 EB26                        jmp .finish
  2213                                  
  2214                                  .check_ball3:
  2215 000012A4 803D(391A0000)01            cmp byte [ball_caught_3], 1
  2216 000012AB 751D                        jne .finish
  2217                                      ; Suelta la bola 3
  2218 000012AD C605(391A0000)00            mov byte [ball_caught_3], 0
  2219 000012B4 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2219 000012BC 000000             
  2220 000012BF 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2220 000012C7 FFFFFF             
  2221                                  
  2222                                  .finish:
  2223                                      ; Limpiar la tecla
  2224 000012CA C605(421A0000)00            mov byte [last_key], 0
  2225                                  
  2226                                  .no_catch_power:
  2227 000012D1 5D                          pop rbp
  2228 000012D2 C3                          ret
  2229                                  
  2230                                  
  2231                                  
  2232                                  display_level_number:
  2233 000012D3 55                          push rbp
  2234 000012D4 4889E5                      mov rbp, rsp
  2235                                      
  2236                                      ; Limpiar la pantalla primero
  2237                                      print clear, clear_length
    82 000012D7 B801000000          <1>  mov eax, sys_write
    83 000012DC BF01000000          <1>  mov edi, 1
    84 000012E1 48BE-               <1>  mov rsi, %1
    84 000012E3 [1000000000000000]  <1>
    85 000012EB BA07000000          <1>  mov edx, %2
    86 000012F0 0F05                <1>  syscall
  2238                                      
  2239                                      ; Calcular la posición central para el mensaje
  2240                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2241 000012F2 B850000000                  mov rax, column_cells
  2242 000012F7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2243 000012FB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2244                                      
  2245                                      ; Calcular la fila central
  2246 000012FE BB20000000                  mov rbx, row_cells
  2247 00001303 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2248                                      
  2249                                      ; Calcular el offset en el buffer
  2250 00001306 B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2251 0000130B 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2252 0000130E 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2253                                      
  2254                                      ; Escribir "NIVEL " en la posición calculada
  2255 00001311 488DB8[400A0000]            lea rdi, [board + rax]
  2256 00001318 48BE-                       mov rsi, level_msg
  2256 0000131A [A414000000000000] 
  2257 00001322 B906000000                  mov rcx, level_msg_len
  2258 00001327 F3A4                        rep movsb
  2259                                      
  2260                                      ; Escribir el número del nivel
  2261 00001329 8A05(79150000)              mov al, [current_level]
  2262 0000132F 0430                        add al, '0'                 ; convertir a ASCII
  2263 00001331 8807                        mov [rdi], al
  2264                                      
  2265                                      ; Mostrar el board con el mensaje
  2266                                      print board, board_size
    82 00001333 B801000000          <1>  mov eax, sys_write
    83 00001338 BF01000000          <1>  mov edi, 1
    84 0000133D 48BE-               <1>  mov rsi, %1
    84 0000133F [400A000000000000]  <1>
    85 00001347 BA400A0000          <1>  mov edx, %2
    86 0000134C 0F05                <1>  syscall
  2267                                      
  2268                                      ; Esperar un segundo
  2269 0000134E B823000000                  mov rax, sys_nanosleep
  2270 00001353 48BF-                       mov rdi, level_display_time
  2270 00001355 [AF14000000000000] 
  2271 0000135D 4831F6                      xor rsi, rsi
  2272 00001360 0F05                        syscall
  2273                                      
  2274 00001362 5D                          pop rbp
  2275 00001363 C3                          ret
  2276                                  
  2277                                  ; Función para inicializar un tablero vacío
  2278                                  init_empty_board:
  2279 00001364 56                          push rsi
  2280 00001365 57                          push rdi
  2281 00001366 51                          push rcx
  2282 00001367 50                          push rax
  2283                                  
  2284 00001368 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2285 0000136F 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2286 00001376 B9400A0000                  mov rcx, board_template_size
  2287 0000137B F3A4                        rep movsb                   ; Copiar el tablero
  2288                                  
  2289 0000137D 58                          pop rax
  2290 0000137E 59                          pop rcx
  2291 0000137F 5F                          pop rdi
  2292 00001380 5E                          pop rsi
  2293 00001381 C3                          ret
  2294                                  
  2295                                  
  2296                                  init_level:
  2297                                            ; Asegurarse que las otras bolas están desactivadas
  2298 00001382 C605(22150000)00            mov byte [ball2_active], 0
  2299 00001389 C605(44150000)00            mov byte [ball3_active], 0
  2300 00001390 C605(431A0000)00            mov byte [laser_power_active], 0
  2301 00001397 E816F4FFFF                  call clear_lasers
  2302 0000139C 488B05(CF140000)            mov rax, [default_pallet_size]
  2303 000013A3 488905(C7140000)            mov [pallet_size], rax
  2304 000013AA 48C705(1E1A0000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2304 000013B2 000000             
  2305                                  
  2306                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2307                                          ; Reiniciar letras activas
  2308 000013B5 488D3D(77180000)            lea rdi, [letters_map]
  2309 000013BC B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2310 000013C1 4831C0                      xor rax, rax
  2311 000013C4 F3AA                        rep stosb                    ; Llenar con ceros
  2312                                      
  2313                                      ; Inicializar dirección de la bola (derecha y arriba)
  2314 000013C6 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2314 000013CE 000000             
  2315 000013D1 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2315 000013D9 FFFFFF             
  2316                                  
  2317                                  
  2318                                      ; Reiniciar contador de letras activas
  2319 000013DC 4831C0                      xor rax, rax
  2320 000013DF 8805(071A0000)              mov [letters_count], al
  2321                                  
  2322                                      ; Reiniciar última letra capturada
  2323 000013E5 C605(081A0000)20            mov byte [last_letter], ' '
  2324 000013EC C605(81170000)00            mov byte [destroyed_blocks], 0 
  2325 000013F3 E86CFFFFFF                  call init_empty_board
  2326 000013F8 E8D6FEFFFF                  call display_level_number
  2327 000013FD E8E5050000                  call init_enemies
  2328                                      
  2329 00001402 56                          push rsi
  2330 00001403 57                          push rdi
  2331 00001404 51                          push rcx
  2332 00001405 50                          push rax
  2333                                  
  2334 00001406 488D35(00000000)            lea rsi, [board_template]
  2335 0000140D 488D3D(400A0000)            lea rdi, [board]
  2336 00001414 B9400A0000                  mov rcx, board_template_size
  2337 00001419 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2338                                  
  2339 0000141B 58                          pop rax
  2340 0000141C 59                          pop rcx
  2341 0000141D 5F                          pop rdi
  2342 0000141E 5E                          pop rsi
  2343                                  
  2344 0000141F B90A000000                  mov rcx, 10
  2345 00001424 4831C0                      xor rax, rax
  2346 00001427 488D3D(24180000)            lea rdi, [enemy_spawns_triggered]
  2347 0000142E F3AA                        rep stosb      
  2348                                  
  2349                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2350 00001430 803D(79150000)01            cmp byte [current_level], 1
  2351 00001437 7431                        je .level1
  2352 00001439 803D(79150000)02            cmp byte [current_level], 2
  2353 00001440 7454                        je .level2
  2354 00001442 803D(79150000)03            cmp byte [current_level], 3
  2355 00001449 7477                        je .level3
  2356 0000144B 803D(79150000)04            cmp byte [current_level], 4
  2357 00001452 0F8492000000                je .level4
  2358 00001458 803D(79150000)05            cmp byte [current_level], 5
  2359 0000145F 0F84AD000000                je .level5
  2360 00001465 E9D0000000                  jmp .done
  2361                                  
  2362                                  
  2363                                  
  2364                                      .level1:
  2365 0000146A C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  2366 00001471 4831C9                          xor rcx, rcx             
  2367                                          .init_loop1:
  2368 00001474 4883F94E                            cmp rcx, level1_blocks_count
  2369 00001478 0F8DBC000000                        jge .done
  2370 0000147E 4889C8                              mov rax, rcx         
  2371 00001481 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2372 00001485 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]  
  2373 0000148B 8891[15170000]                      mov byte [block_states + rcx], dl
  2374 00001491 48FFC1                              inc rcx
  2375 00001494 EBDE                                jmp .init_loop1
  2376                                  
  2377                                      .level2:
  2378 00001496 C605(7A150000)01                mov byte [blocks_remaining], level2_blocks_count
  2379 0000149D 4831C9                          xor rcx, rcx             
  2380                                          .init_loop2:
  2381 000014A0 4883F901                            cmp rcx, level2_blocks_count
  2382 000014A4 0F8D90000000                        jge .done
  2383 000014AA 4889C8                              mov rax, rcx         
  2384 000014AD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2385 000014B1 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  2386 000014B7 8891[15170000]                      mov byte [block_states + rcx], dl
  2387 000014BD 48FFC1                              inc rcx
  2388 000014C0 EBDE                                jmp .init_loop2
  2389                                      .level3:
  2390 000014C2 C605(7A150000)01                mov byte [blocks_remaining], level3_blocks_count
  2391 000014C9 4831C9                          xor rcx, rcx             
  2392                                          .init_loop3:
  2393 000014CC 4883F901                            cmp rcx, level3_blocks_count
  2394 000014D0 7D68                                jge .done
  2395 000014D2 4889C8                              mov rax, rcx         
  2396 000014D5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2397 000014D9 8A90[09170000]                      mov dl, byte [level3_blocks + rax + 3]  
  2398 000014DF 8891[15170000]                      mov byte [block_states + rcx], dl
  2399 000014E5 48FFC1                              inc rcx
  2400 000014E8 EBE2                                jmp .init_loop3
  2401                                  
  2402                                      .level4:
  2403 000014EA C605(7A150000)01                mov byte [blocks_remaining], level4_blocks_count
  2404 000014F1 4831C9                          xor rcx, rcx             
  2405                                          .init_loop4:
  2406 000014F4 4883F901                            cmp rcx, level4_blocks_count
  2407 000014F8 7D40                                jge .done
  2408 000014FA 4889C8                              mov rax, rcx         
  2409 000014FD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2410 00001501 8A90[0E170000]                      mov dl, byte [level4_blocks + rax + 3]  
  2411 00001507 8891[15170000]                      mov byte [block_states + rcx], dl
  2412 0000150D 48FFC1                              inc rcx
  2413 00001510 EBE2                                jmp .init_loop4
  2414                                  
  2415                                      .level5:
  2416 00001512 C605(7A150000)01                mov byte [blocks_remaining], level5_blocks_count
  2417 00001519 4831C9                          xor rcx, rcx             
  2418                                          .init_loop5:
  2419 0000151C 4883F901                            cmp rcx, level5_blocks_count
  2420 00001520 7D18                                jge .done
  2421 00001522 4889C8                              mov rax, rcx         
  2422 00001525 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2423 00001529 8A90[13170000]                      mov dl, byte [level5_blocks + rax + 3]  
  2424 0000152F 8891[15170000]                      mov byte [block_states + rcx], dl
  2425 00001535 48FFC1                              inc rcx
  2426 00001538 EBE2                                jmp .init_loop5
  2427                                      .done:
  2428 0000153A C3                              ret
  2429                                  
  2430                                  
  2431                                  ; Función para verificar y manejar la transición de nivel
  2432                                  check_level_complete:
  2433                                      ; Verificar si quedan bloques
  2434 0000153B 803D(7A150000)00            cmp byte [blocks_remaining], 0
  2435 00001542 753C                        jne .not_complete
  2436                                      
  2437                                      ; Incrementar el nivel
  2438 00001544 FE05(79150000)              inc byte [current_level]
  2439                                      
  2440                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2441 0000154A 803D(79150000)06            cmp byte [current_level], 6
  2442 00001551 742E                        je game_win
  2443                                      
  2444                                      ; Reinicializar el juego para el siguiente nivel
  2445 00001553 E82AFEFFFF                  call init_level
  2446                                      
  2447                                      ; Reinicializar la posición de la bola y la paleta
  2448 00001558 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  2448 00001560 000000             
  2449 00001563 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  2449 0000156B 000000             
  2450 0000156E C605(FF140000)00            mov byte [ball_moving], 0
  2451 00001575 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2451 0000157C [B0130000]         
  2452                                      
  2453                                      .not_complete:
  2454 00001580 C3                              ret
  2455                                  
  2456                                      ; Nueva función para manejar la victoria del juego
  2457                                  game_win:
  2458                                      ; Limpiar la pantalla primero
  2459                                      print clear, clear_length
    82 00001581 B801000000          <1>  mov eax, sys_write
    83 00001586 BF01000000          <1>  mov edi, 1
    84 0000158B 48BE-               <1>  mov rsi, %1
    84 0000158D [1000000000000000]  <1>
    85 00001595 BA07000000          <1>  mov edx, %2
    86 0000159A 0F05                <1>  syscall
  2460                                      
  2461                                      ; Mensaje de victoria
  2462 0000159C 488B05(79170000)            mov rax, [current_score]    ; Obtener el puntaje final
  2463 000015A3 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2463 000015A5 [8217000000000000] 
  2464 000015AD E8B4010000                  call number_to_string
  2465                                      
  2466                                      ; Definir mensaje de victoria
  2467                                      section .data
  2468 00001BA8 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2468 00001BB1 616465732120C2A148-
  2468 00001BBA 61732067616E61646F-
  2468 00001BC3 210A0D             
  2469                                          win_msg_len: equ $ - win_msg
  2470 00001BC6 50756E74616A652066-             score_msg: db "Puntaje final: "
  2470 00001BCF 696E616C3A20       
  2471                                          score_msg_len: equ $ - score_msg
  2472                                      section .text
  2473                                      
  2474                                      ; Imprimir mensajes
  2475                                      print win_msg, win_msg_len
    82 000015B2 B801000000          <1>  mov eax, sys_write
    83 000015B7 BF01000000          <1>  mov edi, 1
    84 000015BC 48BE-               <1>  mov rsi, %1
    84 000015BE [A81B000000000000]  <1>
    85 000015C6 BA1E000000          <1>  mov edx, %2
    86 000015CB 0F05                <1>  syscall
  2476                                      print score_msg, score_msg_len
    82 000015CD B801000000          <1>  mov eax, sys_write
    83 000015D2 BF01000000          <1>  mov edi, 1
    84 000015D7 48BE-               <1>  mov rsi, %1
    84 000015D9 [C61B000000000000]  <1>
    85 000015E1 BA0F000000          <1>  mov edx, %2
    86 000015E6 0F05                <1>  syscall
  2477                                      print number_buffer, 20
    82 000015E8 B801000000          <1>  mov eax, sys_write
    83 000015ED BF01000000          <1>  mov edi, 1
    84 000015F2 48BE-               <1>  mov rsi, %1
    84 000015F4 [8217000000000000]  <1>
    85 000015FC BA14000000          <1>  mov edx, %2
    86 00001601 0F05                <1>  syscall
  2478                                      
  2479                                      ; Esperar un momento antes de salir
  2480 00001603 48C705F2E9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2480 0000160C 0000               
  2481 0000160E 48C705EFE9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2481 00001617 0000               
  2482                                      sleeptime
    98 00001619 B823000000          <1>  mov eax, sys_nanosleep
    99 0000161E 48BF-               <1>  mov rdi, timespec
    99 00001620 [0000000000000000]  <1>
   100 00001628 31F6                <1>  xor esi, esi
   101 0000162A 0F05                <1>  syscall
  2483                                      
  2484 0000162C E9490B0000                  jmp exit
  2485                                  
  2486                                  ; Función para imprimir los bloques
  2487                                  ; Función modificada para imprimir bloques
  2488                                  
  2489                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2490                                  get_current_level_blocks:
  2491 00001631 803D(79150000)01            cmp byte [current_level], 1
  2492 00001638 7428                        je .level1
  2493 0000163A 803D(79150000)02            cmp byte [current_level], 2
  2494 00001641 7427                        je .level2
  2495 00001643 803D(79150000)03            cmp byte [current_level], 3
  2496 0000164A 7426                        je .level3
  2497 0000164C 803D(79150000)04            cmp byte [current_level], 4
  2498 00001653 7425                        je .level4
  2499 00001655 803D(79150000)05            cmp byte [current_level], 5
  2500 0000165C 7424                        je .level5
  2501                                      ; Si llegamos aquí, hay un error en el nivel
  2502 0000165E 4831C0                      xor rax, rax
  2503 00001661 C3                          ret
  2504                                  
  2505                                      .level1:
  2506 00001662 488D05(7B150000)                lea rax, [level1_blocks]
  2507 00001669 C3                              ret
  2508                                      .level2:
  2509 0000166A 488D05(01170000)                lea rax, [level2_blocks]
  2510 00001671 C3                              ret
  2511                                      .level3:
  2512 00001672 488D05(06170000)                lea rax, [level3_blocks]
  2513 00001679 C3                              ret
  2514                                      .level4:
  2515 0000167A 488D05(0B170000)                lea rax, [level4_blocks]
  2516 00001681 C3                              ret
  2517                                      .level5:
  2518 00001682 488D05(10170000)                lea rax, [level5_blocks]
  2519 00001689 C3                              ret
  2520                                  ; Función para obtener la cantidad de bloques del nivel actual
  2521                                  get_current_level_count:
  2522 0000168A 803D(79150000)01            cmp byte [current_level], 1
  2523 00001691 7428                        je .level1
  2524 00001693 803D(79150000)02            cmp byte [current_level], 2
  2525 0000169A 7425                        je .level2
  2526 0000169C 803D(79150000)03            cmp byte [current_level], 3
  2527 000016A3 7422                        je .level3
  2528 000016A5 803D(79150000)04            cmp byte [current_level], 4
  2529 000016AC 741F                        je .level4
  2530 000016AE 803D(79150000)05            cmp byte [current_level], 5
  2531 000016B5 741C                        je .level5
  2532                                      ; Si llegamos aquí, hay un error en el nivel
  2533 000016B7 4831C0                      xor rax, rax
  2534 000016BA C3                          ret
  2535                                  
  2536                                      .level1:
  2537 000016BB B84E000000                      mov rax, level1_blocks_count
  2538 000016C0 C3                              ret
  2539                                      .level2:
  2540 000016C1 B801000000                      mov rax, level2_blocks_count
  2541 000016C6 C3                              ret
  2542                                      .level3:
  2543 000016C7 B801000000                      mov rax, level3_blocks_count
  2544 000016CC C3                              ret
  2545                                      .level4:
  2546 000016CD B801000000                      mov rax, level4_blocks_count
  2547 000016D2 C3                              ret
  2548                                      .level5:
  2549 000016D3 B801000000                      mov rax, level5_blocks_count
  2550 000016D8 C3                              ret
  2551                                  
  2552                                  
  2553                                  print_blocks:
  2554 000016D9 55                          push rbp
  2555 000016DA 4889E5                      mov rbp, rsp
  2556                                      
  2557                                      ; Obtener puntero a los bloques del nivel actual
  2558 000016DD E84FFFFFFF                  call get_current_level_blocks
  2559 000016E2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2560                                      
  2561                                      ; Obtener cantidad de bloques del nivel actual
  2562 000016E5 E8A0FFFFFF                  call get_current_level_count
  2563 000016EA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2564                                      
  2565 000016ED 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2566                                      
  2567                                      .print_loop:
  2568 000016F0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2569 000016F3 7D6F                            jge .end
  2570                                          
  2571                                          ; Verificar si el bloque está activo
  2572 000016F5 490FB68424-                     movzx rax, byte [block_states + r12]
  2572 000016FA [15170000]         
  2573 000016FE 4885C0                          test rax, rax
  2574 00001701 745C                            jz .next_block
  2575                                          
  2576                                          ; Obtener posición y tipo del bloque usando r13
  2577 00001703 4C89E0                          mov rax, r12
  2578 00001706 486BC005                        imul rax, 5
  2579 0000170A 4C01E8                          add rax, r13
  2580 0000170D 448A00                          mov r8b, [rax]        ; X position
  2581 00001710 448A4801                        mov r9b, [rax + 1]    ; Y position
  2582 00001714 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2583                                  
  2584                                          ; El resto de la lógica de impresión permanece igual
  2585 00001718 4D0FB6C0                        movzx r8, r8b
  2586 0000171C 4D0FB6C9                        movzx r9, r9b
  2587 00001720 4981C0[400A0000]                add r8, board
  2588 00001727 B852000000                      mov rax, column_cells + 2
  2589 0000172C 49F7E1                          mul r9
  2590 0000172F 4901C0                          add r8, rax
  2591                                          
  2592 00001732 B906000000                      mov rcx, block_length
  2593 00001737 48BE-                           mov rsi, block_type_1
  2593 00001739 [5515000000000000] 
  2594 00001741 490FB6C2                        movzx rax, r10b
  2595 00001745 48FFC8                          dec rax
  2596 00001748 486BC006                        imul rax, block_length
  2597 0000174C 4801C6                          add rsi, rax
  2598                                          
  2599                                      .print_block_chars:
  2600 0000174F 8A06                            mov al, [rsi]
  2601 00001751 418800                          mov [r8], al
  2602 00001754 48FFC6                          inc rsi
  2603 00001757 49FFC0                          inc r8
  2604 0000175A 48FFC9                          dec rcx
  2605 0000175D 75F0                            jnz .print_block_chars
  2606                                          
  2607                                      .next_block:
  2608 0000175F 49FFC4                          inc r12
  2609 00001762 EB8C                            jmp .print_loop
  2610                                          
  2611                                      .end:
  2612 00001764 5D                              pop rbp
  2613 00001765 C3                              ret
  2614                                  
  2615                                  ; Función para convertir número a string
  2616                                  ; Input: RAX = número a convertir
  2617                                  ; RDI = buffer donde escribir el string
  2618                                  number_to_string:
  2619 00001766 53                          push rbx
  2620 00001767 52                          push rdx
  2621 00001768 56                          push rsi
  2622 00001769 BB0A000000                  mov rbx, 10          ; Divisor
  2623 0000176E B900000000                  mov rcx, 0          ; Contador de dígitos
  2624                                      
  2625                                      ; Si el número es 0, manejarlo especialmente
  2626 00001773 4885C0                      test rax, rax
  2627 00001776 7509                        jnz .convert_loop
  2628 00001778 C60730                      mov byte [rdi], '0'
  2629 0000177B C6470100                    mov byte [rdi + 1], 0
  2630 0000177F EB20                        jmp .end
  2631                                      
  2632                                      .convert_loop:
  2633 00001781 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2634 00001784 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2635 00001787 80C230                          add dl, '0'     ; Convertir a ASCII
  2636 0000178A 52                              push rdx        ; Guardar el dígito
  2637 0000178B 48FFC1                          inc rcx         ; Incrementar contador
  2638 0000178E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2639 00001791 75EE                            jnz .convert_loop
  2640                                          
  2641                                      .write_loop:
  2642 00001793 5A                              pop rdx         ; Obtener dígito
  2643 00001794 8817                            mov [rdi], dl   ; Escribir al buffer
  2644 00001796 48FFC7                          inc rdi         ; Siguiente posición
  2645 00001799 48FFC9                          dec rcx         ; Decrementar contador
  2646 0000179C 75F5                            jnz .write_loop
  2647                                          
  2648 0000179E C60700                      mov byte [rdi], 0   ; Null terminator
  2649                                      
  2650                                      .end:
  2651 000017A1 5E                          pop rsi
  2652 000017A2 5A                          pop rdx
  2653 000017A3 5B                          pop rbx
  2654 000017A4 C3                          ret
  2655                                  
  2656                                  ; Función para imprimir los labels
  2657                                  print_labels:
  2658 000017A5 55                          push rbp
  2659 000017A6 4889E5                      mov rbp, rsp
  2660                                  
  2661                                      ; Crear buffer temporal
  2662 000017A9 4883EC20                    sub rsp, 32
  2663                                  
  2664                                      ; Copiar labels a buffer temporal
  2665 000017AD 4889E7                      mov rdi, rsp
  2666 000017B0 488D35(2E180000)            lea rsi, [score_label]
  2667 000017B7 B917000000                  mov rcx, score_label_len
  2668 000017BC F3A4                        rep movsb
  2669                                  
  2670                                      ; Convertir score a string
  2671 000017BE 488B05(79170000)            mov rax, [current_score]
  2672 000017C5 48BF-                       mov rdi, number_buffer
  2672 000017C7 [8217000000000000] 
  2673 000017CF E892FFFFFF                  call number_to_string
  2674                                  
  2675                                      ; Calcular longitud del número
  2676 000017D4 B900000000                  mov rcx, 0
  2677 000017D9 48BF-                       mov rdi, number_buffer
  2677 000017DB [8217000000000000] 
  2678                                      .count_loop:
  2679 000017E3 803C0F00                        cmp byte [rdi + rcx], 0
  2680 000017E7 7405                            je .count_done
  2681 000017E9 48FFC1                          inc rcx
  2682 000017EC EBF5                            jmp .count_loop
  2683                                      .count_done:
  2684                                  
  2685                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2686 000017EE 4889E7                      mov rdi, rsp
  2687 000017F1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2688 000017F5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2689 000017FA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2690                                      .pad_loop:
  2691 000017FD 4885F6                          test rsi, rsi
  2692 00001800 740B                            jz .pad_done
  2693 00001802 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2694 00001805 48FFC7                          inc rdi
  2695 00001808 48FFCE                          dec rsi
  2696 0000180B EBF0                            jmp .pad_loop
  2697                                      .pad_done:
  2698                                  
  2699                                      ; Copiar el número
  2700 0000180D 48BE-                       mov rsi, number_buffer
  2700 0000180F [8217000000000000] 
  2701 00001817 F3A4                        rep movsb
  2702                                  
  2703                                      ; Imprimir el buffer completo
  2704                                      print rsp, score_label_len
    82 00001819 B801000000          <1>  mov eax, sys_write
    83 0000181E BF01000000          <1>  mov edi, 1
    84 00001823 4889E6              <1>  mov rsi, %1
    85 00001826 BA17000000          <1>  mov edx, %2
    86 0000182B 0F05                <1>  syscall
  2705                                  
  2706                                      ; Repetir proceso para bloques destruidos
  2707 0000182D 4889E7                      mov rdi, rsp
  2708 00001830 488D35(45180000)            lea rsi, [blocks_label]
  2709 00001837 B91B000000                  mov rcx, blocks_label_len
  2710 0000183C F3A4                        rep movsb
  2711                                  
  2712                                      ; Verificar que el `[` esté en su posición correcta
  2713 0000183E 4889E7                      mov rdi, rsp
  2714 00001841 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2715 00001845 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2716                                  
  2717                                      ; Convertir bloques destruidos a string
  2718 00001848 480FB605(81170000)          movzx rax, byte [destroyed_blocks]
  2719 00001850 48BF-                       mov rdi, number_buffer
  2719 00001852 [8217000000000000] 
  2720 0000185A E807FFFFFF                  call number_to_string
  2721                                  
  2722                                      ; Calcular longitud del número
  2723 0000185F B900000000                  mov rcx, 0
  2724 00001864 48BF-                       mov rdi, number_buffer
  2724 00001866 [8217000000000000] 
  2725                                      .count_loop2:
  2726 0000186E 803C0F00                        cmp byte [rdi + rcx], 0
  2727 00001872 7405                            je .count_done2
  2728 00001874 48FFC1                          inc rcx
  2729 00001877 EBF5                            jmp .count_loop2
  2730                                      .count_done2:
  2731                                  
  2732                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2733 00001879 4889E7                      mov rdi, rsp
  2734 0000187C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2735 00001880 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2736 00001885 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2737                                      .pad_loop2:
  2738 00001888 4885F6                          test rsi, rsi
  2739 0000188B 740B                            jz .pad_done2
  2740 0000188D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2741 00001890 48FFC7                          inc rdi
  2742 00001893 48FFCE                          dec rsi
  2743 00001896 EBF0                            jmp .pad_loop2
  2744                                      .pad_done2:
  2745                                  
  2746                                      ; Copiar el número
  2747 00001898 48BE-                       mov rsi, number_buffer
  2747 0000189A [8217000000000000] 
  2748 000018A2 F3A4                        rep movsb
  2749                                  
  2750                                      ; Imprimir el buffer completo
  2751                                      print rsp, blocks_label_len
    82 000018A4 B801000000          <1>  mov eax, sys_write
    83 000018A9 BF01000000          <1>  mov edi, 1
    84 000018AE 4889E6              <1>  mov rsi, %1
    85 000018B1 BA1B000000          <1>  mov edx, %2
    86 000018B6 0F05                <1>  syscall
  2752                                  
  2753                                      ; Restaurar stack
  2754 000018B8 4883C420                    add rsp, 32
  2755 000018BC 5D                          pop rbp
  2756 000018BD C3                          ret
  2757                                  
  2758                                  
  2759                                  
  2760                                  check_block_collision:
  2761 000018BE 55                          push rbp
  2762 000018BF 4889E5                      mov rbp, rsp
  2763                                  
  2764                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2765 000018C2 418A02                      mov al, [r10]
  2766                                  
  2767                                      ; Verificar si el carácter es un bloque
  2768 000018C5 3C55                        cmp al, 'U'  
  2769 000018C7 7419                        je .possible
  2770 000018C9 3C4F                        cmp al, 'O'  
  2771 000018CB 7415                        je .possible
  2772 000018CD 3C44                        cmp al, 'D'  
  2773 000018CF 7411                        je .possible
  2774 000018D1 3C4C                        cmp al, 'L'  
  2775 000018D3 740D                        je .possible
  2776 000018D5 3C56                        cmp al, 'V'  
  2777 000018D7 7409                        je .possible
  2778 000018D9 3C38                        cmp al, '8'  
  2779 000018DB 7405                        je .possible
  2780                                  
  2781                                      ; No es bloque, salir
  2782 000018DD 4831C0                      xor rax, rax
  2783 000018E0 5D                          pop rbp
  2784 000018E1 C3                          ret
  2785                                  
  2786                                  .possible:
  2787 000018E2 53                          push rbx
  2788 000018E3 57                          push rdi
  2789 000018E4 56                          push rsi
  2790 000018E5 4154                        push r12
  2791 000018E7 4155                        push r13
  2792 000018E9 4156                        push r14
  2793 000018EB 4157                        push r15
  2794                                  
  2795                                      ; 1) Obtener base de los bloques del nivel actual
  2796 000018ED E83FFDFFFF                  call get_current_level_blocks
  2797 000018F2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2798                                  
  2799                                      ; 2) Obtener la cantidad de bloques
  2800 000018F5 E890FDFFFF                  call get_current_level_count
  2801 000018FA 4989C6                      mov r14, rax
  2802                                  
  2803 000018FD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2804                                  
  2805                                  .find_block_loop:
  2806 00001900 4D39F4                      cmp r12, r14
  2807 00001903 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2808                                  
  2809                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2810 00001909 4C89E0                      mov rax, r12
  2811 0000190C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2812 00001910 4C01E8                      add rax, r13
  2813 00001913 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2814                                  
  2815                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2816 00001916 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2816 0000191B [15170000]         
  2817 0000191F 4885DB                      test rbx, rbx
  2818 00001922 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2819                                  
  2820                                      ; Obtener coordenadas
  2821 00001928 418A17                      mov dl, [r15]         ; x
  2822 0000192B 418A4F01                    mov cl, [r15 + 1]     ; y
  2823                                  
  2824                                      ; Calcular posición en el board
  2825 0000192F 488D3D(400A0000)            lea rdi, [board]
  2826 00001936 4831C0                      xor rax, rax
  2827 00001939 B850000000                  mov rax, column_cells
  2828 0000193E 4883C002                    add rax, 2
  2829 00001942 480FB6C9                    movzx rcx, cl         ; y
  2830 00001946 480FAFC1                    imul rax, rcx
  2831 0000194A 4801C7                      add rdi, rax
  2832 0000194D 480FB6C2                    movzx rax, dl         ; x
  2833 00001951 4801C7                      add rdi, rax
  2834                                  
  2835                                      ; Guardar la posición base del bloque
  2836 00001954 57                          push rdi
  2837                                  
  2838                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2839 00001955 4939FA                      cmp r10, rdi
  2840 00001958 7274                        jb .skip_collision
  2841 0000195A 488D5F06                    lea rbx, [rdi + block_length]
  2842 0000195E 4939DA                      cmp r10, rbx
  2843 00001961 736B                        jae .skip_collision
  2844                                  
  2845                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2846 00001963 41FE8C24[15170000]          dec byte [block_states + r12]
  2847                                      ; Volver a cargar durabilidad
  2848 0000196B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2848 00001970 [15170000]         
  2849 00001974 4885DB                      test rbx, rbx
  2850 00001977 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2851                                  
  2852                                      ; >>> Llegó a 0 => Bloque destruido
  2853 00001979 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2854 0000197A B906000000                  mov rcx, block_length
  2855                                  .clear_loop:
  2856 0000197F C60720                      mov byte [rdi], ' '
  2857 00001982 48FFC7                      inc rdi
  2858 00001985 E2F8                        loop .clear_loop
  2859                                  
  2860                                      ; Dibujar letra del bloque destruido
  2861 00001987 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2862 0000198B 4883EF06                    sub rdi, block_length
  2863 0000198F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2864                                      ; Después de escribir la letra en el tablero
  2865 00001991 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2866 00001995 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2867 00001999 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2868 0000199E E8C6EAFFFF                  call register_letter
  2869                                      ; Actualizar contadores globales
  2870 000019A3 FE0D(7A150000)              dec byte [blocks_remaining]
  2871 000019A9 FE05(81170000)              inc byte [destroyed_blocks]
  2872                                  
  2873                                      ; Sumar puntos según el tipo
  2874 000019AF 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2875 000019B4 486BC00A                    imul rax, 10
  2876 000019B8 480105(79170000)            add [current_score], rax
  2877                                  
  2878 000019BF B801000000                  mov rax, 1  ; colisión con destrucción
  2879 000019C4 EB14                        jmp .end_pop
  2880                                  
  2881                                  .update_display:
  2882                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2883 000019C6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2884 000019CB 5F                          pop rdi     ; pop que quedó pendiente
  2885 000019CC EB0C                        jmp .end_pop
  2886                                  
  2887                                  .skip_collision:
  2888 000019CE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2889                                  .next_block:
  2890 000019CF 49FFC4                      inc r12
  2891 000019D2 E929FFFFFF                  jmp .find_block_loop
  2892                                  
  2893                                  .no_block_found:
  2894 000019D7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2895                                  
  2896                                  .end_pop:
  2897 000019DA 415F                        pop r15
  2898 000019DC 415E                        pop r14
  2899 000019DE 415D                        pop r13
  2900 000019E0 415C                        pop r12
  2901 000019E2 5E                          pop rsi
  2902 000019E3 5F                          pop rdi
  2903 000019E4 5B                          pop rbx
  2904 000019E5 5D                          pop rbp
  2905 000019E6 C3                          ret
  2906                                  
  2907                                  
  2908                                  
  2909                                  init_enemies:
  2910 000019E7 55                          push rbp
  2911 000019E8 4889E5                      mov rbp, rsp
  2912                                      ; Reiniciar contadores de movimiento
  2913 000019EB C605(C4170000)00            mov byte [enemy_move_total], 0
  2914 000019F2 C605(C5170000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2915                                      ; Limpiar estado previo de enemigos
  2916 000019F9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2917 000019FE 488D3D(9B170000)            lea rdi, [enemies]
  2918 00001A05 30C0                        xor al, al
  2919 00001A07 F3AA                        rep stosb ; Limpiar datos de enemigos
  2920                                      
  2921                                      ; Marcar todos los enemigos como inactivos
  2922 00001A09 488D3D(24180000)            lea rdi, [enemy_spawns_triggered]
  2923 00001A10 30C0                        xor al, al
  2924 00001A12 B90A000000                  mov rcx, 10
  2925 00001A17 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2926                                  
  2927 00001A19 5D                          pop rbp
  2928 00001A1A C3                          ret
  2929                                  
  2930                                  
  2931                                  random_move_enemy:
  2932 00001A1B 55                          push rbp
  2933 00001A1C 4889E5                      mov  rbp, rsp
  2934 00001A1F 53                          push rbx
  2935 00001A20 52                          push rdx
  2936 00001A21 57                          push rdi
  2937                                  
  2938                                      ; r12 = índice del enemigo
  2939                                      ; 1) obtener puntero al enemigo i
  2940 00001A22 4C89E0                      mov rax, r12
  2941 00001A25 486BC003                    imul rax, 3
  2942 00001A29 488D98[9B170000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  2943                                  
  2944                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  2945 00001A30 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  2946 00001A34 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  2947                                  
  2948                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  2949 00001A39 480FB605(C2170000)          movzx rax, byte [enemy_move_counter]
  2950 00001A41 4883E003                    and rax, 3
  2951                                  
  2952 00001A45 4883F800                    cmp rax, 0
  2953 00001A49 741B                        je .try_left
  2954 00001A4B 4883F801                    cmp rax, 1
  2955 00001A4F 7410                        je .try_right
  2956 00001A51 4883F802                    cmp rax, 2
  2957 00001A55 7405                        je .try_up
  2958                                      ; si es 3 => mover abajo
  2959                                  .try_down:
  2960 00001A57 49FFC1                      inc r9
  2961 00001A5A EB0D                        jmp .check_valid
  2962                                  
  2963                                  .try_up:
  2964 00001A5C 49FFC9                      dec r9
  2965 00001A5F EB08                        jmp .check_valid
  2966                                  
  2967                                  .try_right:
  2968 00001A61 49FFC0                      inc r8
  2969 00001A64 EB03                        jmp .check_valid
  2970                                  
  2971                                  .try_left:
  2972 00001A66 49FFC8                      dec r8
  2973                                  
  2974                                  .check_valid:
  2975                                      ; 4) Verificar límites
  2976 00001A69 4983F801                    cmp r8, 1                    
  2977 00001A6D 0F8EA4000000                jle .invalid_move
  2978 00001A73 4983F850                    cmp r8, column_cells        
  2979 00001A77 0F8D9A000000                jge .invalid_move
  2980 00001A7D 4983F901                    cmp r9, 1                    
  2981 00001A81 0F8E90000000                jle .invalid_move
  2982 00001A87 4983F920                    cmp r9, row_cells          
  2983 00001A8B 0F8D86000000                jge .invalid_move
  2984                                  
  2985                                      ; 5) Verificar colisión con bloques/enemigos
  2986 00001A91 4150                        push r8
  2987 00001A93 4151                        push r9
  2988 00001A95 B850000000                  mov rax, column_cells
  2989 00001A9A 4883C002                    add rax, 2
  2990 00001A9E 49F7E1                      mul r9
  2991 00001AA1 4C01C0                      add rax, r8
  2992 00001AA4 488DB8[400A0000]            lea rdi, [board + rax]
  2993 00001AAB 8A07                        mov al, [rdi]
  2994                                  
  2995                                      ; Revisa si es bloque o borde
  2996 00001AAD 3C55                        cmp al, 'U'
  2997 00001AAF 7462                        je .pop_and_invalid
  2998 00001AB1 3C4F                        cmp al, 'O'
  2999 00001AB3 745E                        je .pop_and_invalid
  3000 00001AB5 3C44                        cmp al, 'D'
  3001 00001AB7 745A                        je .pop_and_invalid
  3002 00001AB9 3C4C                        cmp al, 'L'
  3003 00001ABB 7456                        je .pop_and_invalid
  3004 00001ABD 3C56                        cmp al, 'V'
  3005 00001ABF 7452                        je .pop_and_invalid
  3006 00001AC1 3C38                        cmp al, '8'
  3007 00001AC3 744E                        je .pop_and_invalid
  3008 00001AC5 3C58                        cmp al, 'X'
  3009 00001AC7 744A                        je .pop_and_invalid
  3010                                  
  3011                                      ; Revisa si hay enemigo
  3012 00001AC9 3C40                        cmp al, '@'
  3013 00001ACB 7446                        je .pop_and_invalid
  3014 00001ACD 3C23                        cmp al, '#'
  3015 00001ACF 7442                        je .pop_and_invalid
  3016 00001AD1 3C24                        cmp al, '$'
  3017 00001AD3 743E                        je .pop_and_invalid
  3018 00001AD5 3C26                        cmp al, '&'
  3019 00001AD7 743A                        je .pop_and_invalid
  3020                                  
  3021 00001AD9 E8A0020000                  call check_enemy_at_position
  3022 00001ADE 4883F801                    cmp rax, 1
  3023 00001AE2 742F                        je .pop_and_invalid
  3024                                  
  3025                                      ; ------------------------------
  3026                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3027                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3028                                      ; ------------------------------
  3029 00001AE4 4159                        pop r9
  3030 00001AE6 4158                        pop r8
  3031                                  
  3032                                      ; (A) Borrar la posición antigua en el board
  3033                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3034 00001AE8 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3035 00001AEC 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3036 00001AF1 B850000000                  mov rax, column_cells
  3037 00001AF6 4883C002                    add rax, 2
  3038 00001AFA 49F7E3                      mul r11
  3039 00001AFD 4C01D0                      add rax, r10
  3040 00001B00 488DB8[400A0000]            lea rdi, [board + rax]
  3041 00001B07 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3042                                  
  3043                                      ; (B) Guardar la nueva X,Y en la estructura
  3044 00001B0A 448803                      mov byte [rbx], r8b
  3045 00001B0D 44884B01                    mov byte [rbx + 1], r9b
  3046                                  
  3047 00001B11 EB0D                        jmp .done
  3048                                  
  3049                                  .pop_and_invalid:
  3050 00001B13 4159                        pop r9
  3051 00001B15 4158                        pop r8
  3052                                  
  3053                                  .invalid_move:
  3054                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3055 00001B17 4C0FB603                    movzx r8, byte [rbx]
  3056 00001B1B 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3057                                      ; Se queda donde estaba
  3058                                  .done:
  3059 00001B20 5F                          pop rdi
  3060 00001B21 5A                          pop rdx
  3061 00001B22 5B                          pop rbx
  3062 00001B23 5D                          pop rbp
  3063 00001B24 C3                          ret
  3064                                  
  3065                                  
  3066                                  ; Función para mover enemigos
  3067                                  move_enemies:
  3068 00001B25 55                          push rbp
  3069 00001B26 4889E5                      mov rbp, rsp
  3070                                      
  3071                                      ; Incrementar contador de movimiento
  3072 00001B29 FE05(C2170000)              inc byte [enemy_move_counter]
  3073 00001B2F 480FB605(C2170000)          movzx rax, byte [enemy_move_counter]
  3074 00001B37 3A05(C3170000)              cmp al, [enemy_move_delay]
  3075 00001B3D 0F8539020000                jne .end
  3076                                      
  3077                                      ; Resetear contador
  3078 00001B43 C605(C2170000)00            mov byte [enemy_move_counter], 0
  3079                                      
  3080 00001B4A 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3081                                      
  3082                                      .enemy_loop:
  3083 00001B4D 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3084 00001B51 0F8D25020000                    jge .end
  3085                                          
  3086                                          ; Calcular offset del enemigo actual
  3087 00001B57 4C89E0                          mov rax, r12
  3088 00001B5A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3089 00001B5E 488DB0[9B170000]                lea rsi, [enemies + rax]
  3090                                          
  3091                                          ; Verificar si el enemigo está activo
  3092 00001B65 807E0201                        cmp byte [rsi + 2], 1
  3093 00001B69 0F8505020000                    jne .next_enemy
  3094                                          
  3095                                          ; Obtener posición actual
  3096 00001B6F 4C0FB606                        movzx r8, byte [rsi]            ; X
  3097 00001B73 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3098                                          
  3099 00001B78 488D3D(7A1B0000)                lea rdi, [enemy_last_x]
  3100 00001B7F 4C01E7                          add rdi, r12
  3101 00001B82 8A07                            mov al, [rdi]             ; al = last_x
  3102                                  
  3103 00001B84 488D15(841B0000)                lea rdx, [enemy_last_y]
  3104 00001B8B 4C01E2                          add rdx, r12
  3105 00001B8E 8A22                            mov ah, [rdx]             ; ah = last_y
  3106                                  
  3107                                          ; r8 = X actual del enemigo
  3108                                          ; r9 = Y actual del enemigo
  3109                                  
  3110                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3111 00001B90 88E2                            mov dl, ah      ; dl = old_Y
  3112 00001B92 4488CB                          mov bl, r9b     ; bl = new_Y
  3113 00001B95 38DA                            cmp dl, bl
  3114 00001B97 752C                            jne .not_stuck
  3115                                  
  3116                                          ; => SI son iguales => pasa al siguiente check
  3117 00001B99 88C2                            mov dl, al      ; dl = old_X
  3118 00001B9B 4488C3                          mov bl, r8b     ; bl = new_X
  3119 00001B9E 38DA                            cmp dl, bl
  3120 00001BA0 7523                            jne .not_stuck
  3121                                  
  3122                                          ; => MISMA POSICIÓN (STUCK)
  3123 00001BA2 488D1D(8E1B0000)                lea rbx, [enemy_stuck_count]
  3124 00001BA9 4C01E3                          add rbx, r12
  3125 00001BAC FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3126                                  
  3127                                          ; Verificar si supera umbral, digamos 3
  3128 00001BAE 480FB60B                        movzx rcx, byte [rbx]
  3129 00001BB2 4883F902                        cmp rcx, 2
  3130 00001BB6 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3131                                  
  3132                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3133                                          ;  1) resetear el stuck_count
  3134 00001BB8 C60300                          mov byte [rbx], 0
  3135                                  
  3136                                          ;  2) cambiar random
  3137 00001BBB E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3138 00001BC0 E9AF010000                      jmp .next_enemy
  3139                                  
  3140                                      .not_stuck:
  3141                                          ; => Se movió
  3142 00001BC5 488D1D(8E1B0000)                lea rbx, [enemy_stuck_count]
  3143 00001BCC 4C01E3                          add rbx, r12
  3144 00001BCF C60300                          mov byte [rbx], 0            ; Resetear
  3145                                  
  3146                                          ; Guardar su nueva posición en “last_x, last_y”
  3147 00001BD2 488D3D(7A1B0000)                lea rdi, [enemy_last_x]
  3148 00001BD9 4C01E7                          add rdi, r12
  3149 00001BDC 448807                          mov [rdi], r8b
  3150                                          
  3151 00001BDF 488D3D(841B0000)                lea rdi, [enemy_last_y]
  3152 00001BE6 4C01E7                          add rdi, r12
  3153 00001BE9 44880F                          mov [rdi], r9b
  3154                                  
  3155                                          ; Limpiar posición actual antes de mover
  3156                                      .check_normal_move:
  3157 00001BEC 4150                            push r8
  3158 00001BEE 4151                            push r9
  3159 00001BF0 B850000000                      mov rax, column_cells
  3160 00001BF5 4883C002                        add rax, 2
  3161 00001BF9 49F7E1                          mul r9
  3162 00001BFC 4C01C0                          add rax, r8
  3163 00001BFF 488DB8[400A0000]                lea rdi, [board + rax]
  3164 00001C06 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3165 00001C09 4159                            pop r9
  3166 00001C0B 4158                            pop r8
  3167                                  
  3168                                          ; Determinar comportamiento basado en índice
  3169 00001C0D 4C89E0                          mov rax, r12
  3170 00001C10 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3171 00001C14 4885C0                          test rax, rax
  3172 00001C17 7402                            jz .chase_ball
  3173 00001C19 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  3174                                          
  3175                                          ; Perseguir bola (comportamiento original)
  3176                                      .chase_ball:
  3177 00001C1B 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3178 00001C22 4D39D0                          cmp r8, r10
  3179 00001C25 0F8F96000000                    jg .move_left
  3180 00001C2B 0F8C95000000                    jl .move_right
  3181                                          
  3182 00001C31 4C8B15(E7140000)                mov r10, [ball_y_pos]
  3183 00001C38 4D39D1                          cmp r9, r10
  3184 00001C3B 0F8F8A000000                    jg .move_up
  3185 00001C41 0F8C89000000                    jl .move_down
  3186 00001C47 E9A5000000                      jmp .check_collision
  3187                                          
  3188                                      .chase_paddle:
  3189                                          ; Obtener la posición X actual de la paleta
  3190 00001C4C 4C8B15(BF140000)                mov r10, [pallet_position]
  3191 00001C53 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  3192                                          
  3193                                          ; Calcular la posición X real de la paleta
  3194 00001C5A 4C89D0                          mov rax, r10
  3195 00001C5D BB50000000                      mov rbx, column_cells
  3196 00001C62 4883C302                        add rbx, 2                  ; Añadir newline chars
  3197 00001C66 4831D2                          xor rdx, rdx
  3198 00001C69 48F7F3                          div rbx                     ; rax = y, rdx = x
  3199                                          
  3200                                          ; rdx ahora contiene la posición X de la paleta
  3201                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  3202 00001C6C 488B0D(C7140000)                mov rcx, [pallet_size]
  3203 00001C73 48D1E9                          shr rcx, 1                  ; Dividir por 2
  3204 00001C76 4801CA                          add rdx, rcx
  3205                                          
  3206                                          ; Comparar con posición X del enemigo y mover gradualmente
  3207 00001C79 4939D0                          cmp r8, rdx
  3208 00001C7C 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  3209 00001C7E 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  3210 00001C80 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  3211                                  
  3212                                      .check_y_paddle:
  3213                                          ; La Y de la paleta siempre es row_cells - 2
  3214 00001C82 41BA20000000                    mov r10, row_cells
  3215 00001C88 4983EA02                        sub r10, 2
  3216                                          
  3217                                          ; Comparar con posición Y del enemigo y mover gradualmente
  3218 00001C8C 4D39D1                          cmp r9, r10
  3219 00001C8F 7404                            je .no_movement            ; Si está en la misma Y, no mover
  3220 00001C91 7F38                            jg .move_up               ; Si está abajo, mover arriba
  3221 00001C93 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  3222                                          
  3223                                      .no_movement:
  3224 00001C95 EB5A                            jmp .check_collision
  3225                                  
  3226                                      ; También agregar una nueva sección para el movimiento suave
  3227                                      .smooth_transition:
  3228                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  3229 00001C97 8A05(C5170000)                  mov al, [enemy_target]
  3230 00001C9D 84C0                            test al, al
  3231 00001C9F 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  3232                                          
  3233                                          ; Verificar distancia en X
  3234 00001CA1 4989D2                          mov r10, rdx              ; Posición X objetivo
  3235 00001CA4 4D29C2                          sub r10, r8               ; Calcular diferencia
  3236 00001CA7 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  3237 00001CAB 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  3238 00001CAD 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  3239 00001CB1 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  3240 00001CB3 EB3C                            jmp .check_collision
  3241                                          
  3242                                      .limit_right_movement:
  3243 00001CB5 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  3244 00001CB9 EB36                            jmp .check_collision
  3245                                          
  3246                                      .limit_left_movement:
  3247 00001CBB 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  3248 00001CBF EB30                            jmp .check_collision
  3249                                      .move_left:
  3250 00001CC1 49FFC8                          dec r8
  3251 00001CC4 EB0F                            jmp .check_vertical
  3252                                          
  3253                                      .move_right:
  3254 00001CC6 49FFC0                          inc r8
  3255 00001CC9 EB0A                            jmp .check_vertical
  3256                                          
  3257                                      .move_up:
  3258 00001CCB 49FFC9                          dec r9
  3259 00001CCE EB21                            jmp .check_collision
  3260                                          
  3261                                      .move_down:
  3262 00001CD0 49FFC1                          inc r9
  3263 00001CD3 EB1C                            jmp .check_collision
  3264                                          
  3265                                      .check_vertical:
  3266 00001CD5 8A05(C5170000)                  mov al, [enemy_target]
  3267 00001CDB 84C0                            test al, al
  3268 00001CDD 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  3269 00001CE3 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  3270 00001CEA 4D39D1                          cmp r9, r10
  3271 00001CED 7FDC                            jg .move_up
  3272 00001CEF 7CDF                            jl .move_down
  3273                                          
  3274                                      .check_collision:
  3275                                          ; Verificar colisión con bordes
  3276 00001CF1 4983F801                        cmp r8, 1                       ; Borde izquierdo
  3277 00001CF5 7E7D                            jle .next_enemy
  3278 00001CF7 4983F850                        cmp r8, column_cells
  3279 00001CFB 7D77                            jge .next_enemy
  3280 00001CFD 4983F901                        cmp r9, 1                       ; Borde superior
  3281 00001D01 7E71                            jle .next_enemy
  3282 00001D03 4983F920                        cmp r9, row_cells
  3283 00001D07 7D6B                            jge .next_enemy
  3284                                          
  3285                                          ; Verificar colisión con bloques antes de moverse
  3286 00001D09 4150                            push r8
  3287 00001D0B 4151                            push r9
  3288 00001D0D 4152                            push r10
  3289                                          
  3290                                          ; Calcular posición en el tablero para verificar
  3291 00001D0F B850000000                      mov rax, column_cells
  3292 00001D14 4883C002                        add rax, 2
  3293 00001D18 49F7E1                          mul r9
  3294 00001D1B 4C01C0                          add rax, r8
  3295 00001D1E 4C8D90[400A0000]                lea r10, [board + rax]
  3296                                          
  3297                                          ; Verificar si hay un bloque en la nueva posición
  3298 00001D25 418A02                          mov al, [r10]
  3299 00001D28 3C55                            cmp al, 'U'
  3300 00001D2A 7442                            je .invalid_move
  3301 00001D2C 3C4F                            cmp al, 'O'
  3302 00001D2E 743E                            je .invalid_move
  3303 00001D30 3C44                            cmp al, 'D'
  3304 00001D32 743A                            je .invalid_move
  3305 00001D34 3C4C                            cmp al, 'L'
  3306 00001D36 7436                            je .invalid_move
  3307 00001D38 3C56                            cmp al, 'V'
  3308 00001D3A 7432                            je .invalid_move
  3309 00001D3C 3C38                            cmp al, '8'
  3310 00001D3E 742E                            je .invalid_move
  3311 00001D40 3C58                            cmp al, 'X'
  3312 00001D42 742A                            je .invalid_move
  3313 00001D44 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  3314 00001D46 7426                            je .invalid_move
  3315 00001D48 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  3316 00001D4A 7422                            je .invalid_move
  3317 00001D4C 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  3318 00001D4E 741E                            je .invalid_move
  3319 00001D50 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  3320 00001D52 741A                            je .invalid_move
  3321                                          
  3322 00001D54 E825000000                      call check_enemy_at_position
  3323 00001D59 4883F801                        cmp rax, 1
  3324 00001D5D 740F                            je .invalid_move
  3325 00001D5F 415A                            pop r10
  3326 00001D61 4159                            pop r9
  3327 00001D63 4158                            pop r8
  3328                                          
  3329                                          ; Guardar nueva posición si es válida
  3330 00001D65 448806                          mov [rsi], r8b
  3331 00001D68 44884E01                        mov [rsi + 1], r9b
  3332 00001D6C EB06                            jmp .next_enemy
  3333                                          
  3334                                      .invalid_move:
  3335 00001D6E 415A                            pop r10
  3336 00001D70 4159                            pop r9
  3337 00001D72 4158                            pop r8
  3338                                          
  3339                                      .next_enemy:
  3340 00001D74 49FFC4                          inc r12
  3341 00001D77 E9D1FDFFFF                      jmp .enemy_loop
  3342                                          
  3343                                      .end:
  3344 00001D7C 5D                              pop rbp
  3345 00001D7D C3                              ret
  3346                                  
  3347                                  check_enemy_at_position:
  3348 00001D7E 55                          push rbp
  3349 00001D7F 4889E5                      mov rbp, rsp
  3350                                      
  3351                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  3352 00001D82 B850000000                  mov rax, column_cells
  3353 00001D87 4883C002                    add rax, 2
  3354 00001D8B 49F7E1                      mul r9
  3355 00001D8E 4C01C0                      add rax, r8
  3356 00001D91 488DB8[400A0000]            lea rdi, [board + rax]
  3357 00001D98 480FB607                    movzx rax, byte [rdi]
  3358                                      
  3359                                      ; Verificar todos los caracteres de enemigos
  3360 00001D9C 3C40                        cmp al, '@'
  3361 00001D9E 7411                        je .enemy_found
  3362 00001DA0 3C23                        cmp al, '#'
  3363 00001DA2 740D                        je .enemy_found
  3364 00001DA4 3C24                        cmp al, '$'
  3365 00001DA6 7409                        je .enemy_found
  3366 00001DA8 3C26                        cmp al, '&'
  3367 00001DAA 7405                        je .enemy_found
  3368                                      
  3369 00001DAC 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  3370 00001DAF EB05                        jmp .end
  3371                                      
  3372                                  .enemy_found:
  3373 00001DB1 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  3374                                      
  3375                                  .end:
  3376 00001DB6 5D                          pop rbp
  3377 00001DB7 C3                          ret
  3378                                  
  3379                                  get_current_spawn_points:
  3380 00001DB8 55                          push rbp
  3381 00001DB9 4889E5                      mov rbp, rsp
  3382                                      
  3383 00001DBC 480FB605(79150000)          movzx rax, byte [current_level]
  3384 00001DC4 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3385 00001DC7 488B04C5[F9170000]          mov rax, [spawn_points_table + rax * 8]
  3386                                      
  3387 00001DCF 5D                          pop rbp
  3388 00001DD0 C3                          ret
  3389                                  
  3390                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3391                                  check_enemy_spawn:
  3392 00001DD1 55                          push rbp
  3393 00001DD2 4889E5                      mov rbp, rsp
  3394                                      
  3395                                      ; Obtener spawn points del nivel actual
  3396 00001DD5 E8DEFFFFFF                  call get_current_spawn_points
  3397 00001DDA 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3398                                      
  3399                                      ; Obtener cantidad de bloques destruidos
  3400 00001DDD 4C0FB62D(81170000)          movzx r13, byte [destroyed_blocks]
  3401                                      
  3402                                      ; Verificar cada punto de spawn
  3403 00001DE5 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3404                                      
  3405                                      .check_loop:
  3406 00001DE8 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3407 00001DEC 7D4E                            jge .end
  3408                                          
  3409                                          ; Verificar si este spawn point ya fue usado
  3410 00001DEE 80B9[24180000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3411 00001DF5 7440                            je .next_enemy
  3412                                          
  3413                                          ; Verificar si este enemigo ya está activo
  3414 00001DF7 4889C8                          mov rax, rcx
  3415 00001DFA 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3416 00001DFE 488DB0[9B170000]                lea rsi, [enemies + rax]
  3417 00001E05 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3418 00001E09 742C                            je .next_enemy
  3419                                          
  3420                                          ; Verificar si debemos spawnear este enemigo
  3421 00001E0B 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3422 00001E10 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3423 00001E13 7522                            jne .next_enemy
  3424                                          
  3425                                          ; Marcar este spawn point como usado
  3426 00001E15 C681[24180000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3427                                          
  3428                                          ; Spawner nuevo enemigo
  3429 00001E1C B004                            mov al, 4
  3430 00001E1E 00C8                            add al, cl       ; con 'rcx' como índice
  3431 00001E20 8806                            mov [rsi], al
  3432 00001E22 C6460102                        mov byte [rsi+1], 2
  3433 00001E26 C6460201                        mov byte [rsi+2], 1
  3434                                  
  3435                                          ; Inicializar comportamiento
  3436 00001E2A 4889C8                          mov rax, rcx
  3437 00001E2D 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3438 00001E31 8805(23180000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3439                                          
  3440                                      .next_enemy:
  3441 00001E37 48FFC1                          inc rcx
  3442 00001E3A EBAC                            jmp .check_loop
  3443                                          
  3444                                      .end:
  3445 00001E3C 5D                              pop rbp
  3446 00001E3D C3                              ret
  3447                                  
  3448                                  
  3449                                  ; Función para dibujar enemigos
  3450                                  print_enemies:
  3451 00001E3E 55                          push rbp
  3452 00001E3F 4889E5                      mov rbp, rsp
  3453                                      
  3454 00001E42 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3455                                      
  3456                                      .print_loop:
  3457 00001E45 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3458 00001E49 7D4B                            jge .end
  3459                                          
  3460                                          ; Calcular offset del enemigo actual
  3461 00001E4B 4C89E0                          mov rax, r12
  3462 00001E4E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3463 00001E52 488DB0[9B170000]                lea rsi, [enemies + rax]
  3464                                          
  3465                                          ; Verificar si el enemigo está activo
  3466 00001E59 807E0201                        cmp byte [rsi + 2], 1
  3467 00001E5D 7532                            jne .next_enemy
  3468                                          
  3469                                          ; Calcular posición en el tablero
  3470 00001E5F 4C0FB606                        movzx r8, byte [rsi]            ; X
  3471 00001E63 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3472                                          
  3473                                          ; Calcular offset en el tablero
  3474 00001E68 B850000000                      mov rax, column_cells
  3475 00001E6D 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3476 00001E71 49F7E1                          mul r9
  3477 00001E74 4C01C0                          add rax, r8
  3478 00001E77 488DB8[400A0000]                lea rdi, [board + rax]
  3479                                          
  3480                                          ; Obtener carácter del enemigo según el nivel
  3481 00001E7E 480FB605(79150000)              movzx rax, byte [current_level]
  3482 00001E86 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3483 00001E89 8A80[96170000]                  mov al, [enemy_chars + rax]
  3484                                          
  3485                                          ; Dibujar enemigo
  3486 00001E8F 8807                            mov [rdi], al
  3487                                          
  3488                                      .next_enemy:
  3489 00001E91 49FFC4                          inc r12
  3490 00001E94 EBAF                            jmp .print_loop
  3491                                          
  3492                                      .end:
  3493 00001E96 5D                              pop rbp
  3494 00001E97 C3                              ret
  3495                                  
  3496                                  ; Función para verificar colisión con enemigos
  3497                                  ; Función para verificar colisión con enemigos
  3498                                  check_enemy_collision:
  3499 00001E98 55                          push rbp
  3500 00001E99 4889E5                      mov rbp, rsp
  3501                                      
  3502 00001E9C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3503 00001E9F 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3504                                      
  3505                                      .check_loop:
  3506 00001EA2 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3507 00001EA6 0F8DE9000000                    jge .end
  3508                                          
  3509                                          ; Calcular offset del enemigo actual
  3510 00001EAC 4C89E1                          mov rcx, r12
  3511 00001EAF 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3512 00001EB3 488DB1[9B170000]                lea rsi, [enemies + rcx]
  3513                                          
  3514                                          ; Verificar si el enemigo está activo
  3515 00001EBA 807E0201                        cmp byte [rsi + 2], 1
  3516 00001EBE 0F85C9000000                    jne .next_enemy
  3517                                          
  3518                                          ; Verificar colisión con la bola
  3519 00001EC4 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3520 00001EC8 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3521                                          
  3522                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3523 00001ECD 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3524 00001ED4 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  3525                                          
  3526                                          ; Comprobar colisión vertical (misma columna)
  3527 00001EDB 4D39C2                          cmp r10, r8
  3528 00001EDE 7525                            jne .check_horizontal
  3529 00001EE0 4D29CB                          sub r11, r9
  3530 00001EE3 4983FB01                        cmp r11, 1
  3531 00001EE7 7F1C                            jg .check_horizontal
  3532 00001EE9 4983FBFF                        cmp r11, -1
  3533 00001EED 7C16                            jl .check_horizontal
  3534                                          
  3535                                          ; Colisión vertical detectada
  3536 00001EEF E8A3000000                      call destroy_enemy
  3537 00001EF4 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3538 00001EFB B801000000                      mov rax, 1
  3539 00001F00 E990000000                      jmp .end
  3540                                          
  3541                                      .check_horizontal:
  3542                                          ; Comprobar colisión horizontal (misma fila)
  3543 00001F05 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3544 00001F0C 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  3545 00001F13 4D39CB                          cmp r11, r9
  3546 00001F16 7522                            jne .check_paddle
  3547 00001F18 4D29C2                          sub r10, r8
  3548 00001F1B 4983FA01                        cmp r10, 1
  3549 00001F1F 7F19                            jg .check_paddle
  3550 00001F21 4983FAFF                        cmp r10, -1
  3551 00001F25 7C13                            jl .check_paddle
  3552                                          
  3553                                          ; Colisión horizontal detectada
  3554 00001F27 E86B000000                      call destroy_enemy
  3555 00001F2C 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3556 00001F33 B801000000                      mov rax, 1
  3557 00001F38 EB5B                            jmp .end
  3558                                          
  3559                                      .check_paddle:
  3560                                          ; Verificar colisión con la paleta
  3561 00001F3A 4C8B15(BF140000)                mov r10, [pallet_position]
  3562 00001F41 4981EA[400A0000]                sub r10, board
  3563 00001F48 4C89D0                          mov rax, r10
  3564 00001F4B 41BB50000000                    mov r11, column_cells
  3565 00001F51 4983C302                        add r11, 2
  3566 00001F55 4831D2                          xor rdx, rdx
  3567 00001F58 49F7F3                          div r11                     ; División para obtener la posición Y
  3568 00001F5B 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3569                                          
  3570 00001F5E 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3571                                          
  3572                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3573 00001F65 41BD20000000                    mov r13, row_cells
  3574 00001F6B 4983ED02                        sub r13, 2                 ; Y de la paleta
  3575 00001F6F 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3576 00001F72 7519                            jne .next_enemy
  3577                                          
  3578                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3579 00001F74 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3580 00001F77 7C14                            jl .next_enemy
  3581                                          
  3582 00001F79 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3583 00001F7C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3584 00001F7F 7F0C                            jg .next_enemy
  3585                                          
  3586                                          ; Si llegamos aquí, hay colisión con la paleta
  3587 00001F81 E811000000                      call destroy_enemy        ; Destruir el enemigo
  3588 00001F86 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3589 00001F8B EB08                            jmp .end
  3590                                          
  3591                                      .next_enemy:
  3592 00001F8D 49FFC4                          inc r12
  3593 00001F90 E90DFFFFFF                      jmp .check_loop
  3594                                          
  3595                                      .end:
  3596 00001F95 5D                              pop rbp
  3597 00001F96 C3                              ret
  3598                                  
  3599                                  ; Función para destruir un enemigo
  3600                                  destroy_enemy:
  3601                                      ; Desactivar enemigo
  3602 00001F97 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3603                                  
  3604                                      ; Sumar puntos por destruir enemigo
  3605 00001F9B 488B05(BA170000)            mov rax, [enemy_points]
  3606 00001FA2 480105(79170000)            add [current_score], rax
  3607                                  
  3608                                      ; No tocar bloques destruidos aquí
  3609 00001FA9 C3                          ret
  3610                                  
  3611                                  
  3612                                  _start:
  3613 00001FAA E87CE1FFFF              	call canonical_off
  3614 00001FAF E853010000              	call start_screen
  3615 00001FB4 E8C9F3FFFF                  call init_level
  3616 00001FB9 E829FAFFFF                  call init_enemies
  3617 00001FBE EB00                    	jmp .main_loop
  3618                                  	
  3619                                  
  3620                                      .main_loop:
  3621 00001FC0 E8E0F7FFFF                      call print_labels
  3622 00001FC5 E80FF7FFFF                      call print_blocks
  3623 00001FCA E86BE5FFFF                      call move_letters
  3624 00001FCF E82AE8FFFF                      call update_lasers
  3625 00001FD4 E8D6E4FFFF                      call print_letters
  3626 00001FD9 E8CBEBFFFF                      call print_pallet
  3627                                          
  3628                                          ; Mover bola principal solo si está activa
  3629 00001FDE 803D(00150000)01                cmp byte [ball_active], 1
  3630 00001FE5 7505                            jne .skip_ball1
  3631 00001FE7 E8D5ECFFFF                          call move_ball
  3632                                          .skip_ball1:
  3633                                  
  3634                                          ; Mover bola 2 si está activa
  3635 00001FEC 803D(22150000)01                cmp byte [ball2_active], 1
  3636 00001FF3 7505                            jne .skip_ball2
  3637 00001FF5 E89AEEFFFF                          call move_ball_2
  3638                                          .skip_ball2:
  3639                                  
  3640                                          ; Mover bola 3 si está activa
  3641 00001FFA 803D(44150000)01                cmp byte [ball3_active], 1
  3642 00002001 7505                            jne .skip_ball3
  3643 00002003 E85FF0FFFF                          call move_ball_3
  3644                                          .skip_ball3:
  3645                                  
  3646 00002008 E8E9E2FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3647 0000200D E8CBE1FFFF                      call print_lives
  3648                                  
  3649                                          ; Imprimir solo las bolas activas
  3650 00002012 803D(00150000)01                cmp byte [ball_active], 1
  3651 00002019 7505                            jne .no_pb1
  3652 0000201B E811EBFFFF                          call print_ball
  3653                                          .no_pb1:
  3654                                  
  3655 00002020 803D(22150000)01                cmp byte [ball2_active], 1
  3656 00002027 7505                            jne .no_pb2
  3657 00002029 E82BEBFFFF                          call print_ball_2
  3658                                          .no_pb2:
  3659                                  
  3660 0000202E 803D(44150000)01                cmp byte [ball3_active], 1
  3661 00002035 7505                            jne .no_pb3
  3662 00002037 E845EBFFFF                          call print_ball_3
  3663                                          .no_pb3:
  3664                                  
  3665 0000203C E8FAF4FFFF                      call check_level_complete
  3666 00002041 E88BFDFFFF                      call check_enemy_spawn
  3667 00002046 E8DAFAFFFF                      call move_enemies
  3668 0000204B E848FEFFFF                      call check_enemy_collision
  3669 00002050 E8E9FDFFFF                      call print_enemies
  3670                                  		print board, board_size				
    82 00002055 B801000000          <1>  mov eax, sys_write
    83 0000205A BF01000000          <1>  mov edi, 1
    84 0000205F 48BE-               <1>  mov rsi, %1
    84 00002061 [400A000000000000]  <1>
    85 00002069 BA400A0000          <1>  mov edx, %2
    86 0000206E 0F05                <1>  syscall
  3671                                  		;setnonblocking	
  3672                                  	.read_more:	
  3673                                  	    getchar	
    90 00002070 B800000000          <1>  mov rax, sys_read
    91 00002075 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000207A 48BE-               <1>  mov rsi, input_char
    92 0000207C [0000000000000000]  <1>
    93 00002084 BA01000000          <1>  mov rdx, 1
    94 00002089 0F05                <1>  syscall
  3674 0000208B 4883F801                	    cmp rax, 1
  3675 0000208F 7543                    	    jne .done
  3676                                  	
  3677 00002091 8A05(00000000)          	    mov al, [input_char]
  3678 00002097 8805(421A0000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3679                                  	
  3680 0000209D 3C61                    	    cmp al, 'a'
  3681 0000209F 750E                    	    jne .not_left
  3682 000020A1 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3683 000020A8 E831EBFFFF              	    call move_pallet
  3684 000020AD EB25                    	    jmp .done
  3685                                  	
  3686                                      .not_left:
  3687 000020AF 3C64                    	    cmp al, 'd'
  3688 000020B1 750C                    	    jne .not_right
  3689 000020B3 BF01000000              	    mov rdi, right_direction
  3690 000020B8 E821EBFFFF              	    call move_pallet
  3691 000020BD EB15                    	    jmp .done
  3692                                  	
  3693                                      .not_right:
  3694 000020BF 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3695 000020C1 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3696                                  	
  3697 000020C3 3C71                    	    cmp al, 'q' 
  3698 000020C5 0F84AF000000            	    je exit
  3699 000020CB EBA3                    	    jmp .read_more
  3700                                  	
  3701                                      .release_ball:
  3702 000020CD E868F1FFFF              	    call process_catch_release
  3703 000020D2 EB00                    	    jmp .done
  3704                                  	
  3705                                      .done:
  3706                                  	    sleeptime
    98 000020D4 B823000000          <1>  mov eax, sys_nanosleep
    99 000020D9 48BF-               <1>  mov rdi, timespec
    99 000020DB [0000000000000000]  <1>
   100 000020E3 31F6                <1>  xor esi, esi
   101 000020E5 0F05                <1>  syscall
  3707                                  	    print clear, clear_length
    82 000020E7 B801000000          <1>  mov eax, sys_write
    83 000020EC BF01000000          <1>  mov edi, 1
    84 000020F1 48BE-               <1>  mov rsi, %1
    84 000020F3 [1000000000000000]  <1>
    85 000020FB BA07000000          <1>  mov edx, %2
    86 00002100 0F05                <1>  syscall
  3708 00002102 E9B9FEFFFF              	    jmp .main_loop
  3709                                  
  3710                                  
  3711                                  
  3712                                  
  3713                                  start_screen:
  3714                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00002107 B801000000          <1>  mov eax, sys_write
    83 0000210C BF01000000          <1>  mov edi, 1
    84 00002111 48BE-               <1>  mov rsi, %1
    84 00002113 [1000000000000000]  <1>
    85 0000211B BA07000000          <1>  mov edx, %2
    86 00002120 0F05                <1>  syscall
  3715                                      print msg1, msg1_length
    82 00002122 B801000000          <1>  mov eax, sys_write
    83 00002127 BF01000000          <1>  mov edi, 1
    84 0000212C 48BE-               <1>  mov rsi, %1
    84 0000212E [1700000000000000]  <1>
    85 00002136 BA14010000          <1>  mov edx, %2
    86 0000213B 0F05                <1>  syscall
  3716                                      
  3717                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3718                                          getchar                 ; Esperamos una tecla
    90 0000213D B800000000          <1>  mov rax, sys_read
    91 00002142 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00002147 48BE-               <1>  mov rsi, input_char
    92 00002149 [0000000000000000]  <1>
    93 00002151 BA01000000          <1>  mov rdx, 1
    94 00002156 0F05                <1>  syscall
  3719 00002158 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3720 0000215C 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3721                                          
  3722                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000215E B801000000          <1>  mov eax, sys_write
    83 00002163 BF01000000          <1>  mov edi, 1
    84 00002168 48BE-               <1>  mov rsi, %1
    84 0000216A [1000000000000000]  <1>
    85 00002172 BA07000000          <1>  mov edx, %2
    86 00002177 0F05                <1>  syscall
  3723 00002179 C3                          ret
  3724                                  
  3725                                  exit: 
  3726 0000217A E8EEDFFFFF              	call canonical_on
  3727 0000217F B83C000000              	mov    rax, 60
  3728 00002184 BF00000000                  mov    rdi, 0
  3729 00002189 0F05                        syscall
  3730                                  
