     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293                                      level1_blocks_count equ 4   ; Cantidad total de bloques
   294                                  
   295                                      ; Nivel 2: Bloques de prueba
   296                                      level2_blocks:
   297 000014CA 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   298                                      level2_blocks_count equ 1
   299                                  
   300                                      ; Nivel 3
   301                                      level3_blocks:
   302 000014CF 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   303                                  
   304                                      level3_blocks_count equ 1
   305                                  
   306                                      ; Nivel 4
   307                                      level4_blocks:
   308 000014D4 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   309                                      level4_blocks_count equ 1
   310                                  
   311                                      ; Nivel 5
   312                                      level5_blocks:
   313 000014D9 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   314                                      level5_blocks_count equ 1
   315                                  
   316                                      ; Array para mantener el estado de los bloques
   317 000014DE 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   318                                  
   319                                      
   320                                      ; Variables para almacenar los valores
   321 00001542 0000000000000000            current_score dq 0          ; Score actual
   322 0000154A 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   323                                      
   324                                      ; Buffer para convertir números a string
   325 0000154B 00<rep 14h>                 number_buffer: times 20 db 0
   326                                  
   327 0000155F 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   328                                      
   329                                      ; Estructura para los enemigos (x, y, activo)
   330 00001564 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   331 00001582 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   332                                      
   333 00001583 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   334 0000158B 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   335 0000158C 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   336 0000158D 00                          enemy_move_total db 0      ; Contador total de movimientos
   337 0000158E 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   338 0000158F 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   339                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   340                                      ; Añade esto en la sección .dataa
   341 00001590 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   341 00001599 12                 
   342 0000159A 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   342 000015A3 13                 
   343 000015A4 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   343 000015AD 1B                 
   344 000015AE 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   344 000015B7 1C                 
   345 000015B8 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   345 000015C1 2D                 
   346                                          ; Arreglo de punteros a los spawn points de cada nivel
   347                                      spawn_points_table:
   348 000015C2 [9015000000000000]              dq level1_spawn_points
   349 000015CA [9A15000000000000]              dq level2_spawn_points
   350 000015D2 [A415000000000000]              dq level3_spawn_points
   351 000015DA [AE15000000000000]              dq level4_spawn_points
   352 000015E2 [B815000000000000]              dq level5_spawn_points
   353                                  
   354                                      ; Variables para el comportamiento de enemigos
   355 000015EA 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   356 000015EB 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   357 000015EC 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   358 000015ED 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   359                                  
   360 000015F7 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   360 00001600 5B2020202020202020-
   360 00001609 20205D0A0D         
   361                                      score_label_len: equ $ - score_label
   362 0000160E 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   362 00001617 657374727569646F73-
   362 00001620 3A205B2020205D0A0D 
   363                                      blocks_label_len: equ $ - blocks_label
   364                                      
   365                                      ; Posición donde insertar los números en los labels
   366                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   367                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   368                                      
   369                                      ; Definición de las vidas (x, y, estado)
   370                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   371                                      lives_data: 
   372 00001629 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   373 0000162C 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   374 0000162F 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   375 00001632 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   376 00001635 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   377 00001638 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   378 0000163B 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   379                                      lives_count equ 7    ; Total de vidas
   380 0000163E 5E                          life_char db "^"    
   381 0000163F 04                          current_lives db 4   ; Contador de vidas activas actual
   382                                  
   383                                  ; Estructura para almacenar las letras y sus posiciones
   384                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   385 00001640 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   386 000017D0 00                          letters_count db 0   
   387 000017D1 20                          last_letter db ' '    ; Variable para almacenar la última letra
   388 000017D2 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   388 000017DB 75616C3A205B205D0A-
   388 000017E4 0D                 
   389                                      last_letter_msg_len equ $ - last_letter_msg
   390 000017E5 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   391 000017E6 07                          max_lives db 7              ; Máximo número de vidas permitidas
   392 000017E7 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   393 000017EF 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   394 000017F7 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   395                                  
   396 000017FF 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   397 00001800 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   398 00001801 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   399 00001809 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   400                                  
   401 0000180A 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   402 0000180B 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   403 0000180C 00                          laser_count: db 0                ; Contador de láseres activos
   404 0000180D 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   405 000018D5 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   406                                  
   407                                  section .text
   408                                  
   409                                  
   410                                  print_lives:
   411 000001DD 55                          push rbp
   412 000001DE 4889E5                      mov rbp, rsp
   413                                      
   414 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   415                                      
   416                                      .print_loop:
   417 000001E4 4983FC07                        cmp r12, lives_count
   418 000001E8 7D45                            jge .end
   419                                          
   420                                          ; Calcular offset de la vida actual
   421 000001EA 4C89E0                          mov rax, r12
   422 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   423 000001F1 488DB0[29160000]                lea rsi, [lives_data + rax]
   424                                          
   425                                          ; Calcular posición en el tablero
   426 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   427 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   428                                          
   429                                          ; Calcular offset en el tablero
   430 00000201 B84E000000                      mov rax, column_cells
   431 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   432 0000020A 49F7E1                          mul r9
   433 0000020D 4C01C0                          add rax, r8
   434 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   435                                          
   436                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   437 00000217 807E0201                        cmp byte [rsi + 2], 1
   438 0000021B 7405                            je .draw_active
   439                                          
   440                                          ; Si está inactiva, dibujar espacio
   441 0000021D C60720                          mov byte [rdi], ' '
   442 00000220 EB08                            jmp .next_life
   443                                          
   444                                      .draw_active:
   445                                          ; Si está activa, dibujar el símbolo de vida
   446 00000222 8A05(3E160000)                  mov al, [life_char]
   447 00000228 8807                            mov [rdi], al
   448                                          
   449                                      .next_life:
   450 0000022A 49FFC4                          inc r12
   451 0000022D EBB5                            jmp .print_loop
   452                                          
   453                                      .end:
   454 0000022F 5D                              pop rbp
   455 00000230 C3                              ret
   456                                  
   457                                  ; Función para desactivar una vida
   458                                  ; Función modificada para perder una vida
   459                                  lose_life:
   460 00000231 55                          push rbp
   461 00000232 4889E5                      mov rbp, rsp
   462                                      
   463                                      ; Verificar si aún quedan vidas
   464 00000235 803D(3F160000)00            cmp byte [current_lives], 0
   465 0000023C 0F8493000000                je .game_lost
   466                                      
   467                                      ; Encontrar la última vida activa
   468 00000242 B907000000                  mov rcx, lives_count
   469 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   470                                      
   471                                      .find_active_life:
   472 0000024A 4889C8                          mov rax, rcx
   473 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   474 00000251 488DB0[29160000]                lea rsi, [lives_data + rax]
   475 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   476 0000025C 7407                            je .deactivate_life
   477 0000025E 48FFC9                          dec rcx
   478 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   479 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   480                                          
   481                                      .deactivate_life:
   482                                          ; Calcular posición correcta en el tablero para borrar la vida
   483 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   484 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   485                                          
   486                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   487 0000026E B84E000000                      mov rax, column_cells
   488 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   489 00000277 49F7E1                          mul r9
   490 0000027A 4C01C0                          add rax, r8
   491 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   492                                          
   493                                          ; Borrar visualmente la vida
   494 00000284 C60720                          mov byte [rdi], ' '             
   495                                          
   496                                          ; Desactivar la vida en los datos
   497 00000287 C6460200                        mov byte [rsi + 2], 0          
   498 0000028B FE0D(3F160000)                  dec byte [current_lives]
   499                                          
   500                                          ; Borrar visualmente la paleta anterior
   501 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   502 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   503                                          .erase_pallet_loop:
   504 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   505 000002A3 49FFC0                              inc r8
   506 000002A6 48FFC9                              dec rcx
   507 000002A9 75F4                                jnz .erase_pallet_loop
   508                                          
   509                                  
   510                                          ; Reiniciar posición de la bola y la paleta
   511 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   511 000002B3 000000             
   512 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   512 000002BE 000000             
   513 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   514 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   514 000002CF [36130000]         
   515                                          
   516 000002D3 EB07                            jmp .end
   517                                          
   518                                      .game_lost:
   519 000002D5 E81C000000                      call game_lost
   520 000002DA EB00                            jmp .end
   521                                          
   522                                      .end:
   523 000002DC 5D                              pop rbp
   524 000002DD C3                              ret
   525                                  ; Función modificada para verificar colisión con el borde inferior
   526                                  check_bottom_collision:
   527 000002DE 55                          push rbp
   528 000002DF 4889E5                      mov rbp, rsp
   529                                      
   530                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   531 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   532 000002E9 4883F81E                    cmp rax, row_cells - 2
   533 000002ED 7505                        jne .no_collision
   534                                      
   535                                      ; Si hay colisión, perder una vida
   536 000002EF E83DFFFFFF                  call lose_life
   537                                      
   538                                      .no_collision:
   539 000002F4 5D                              pop rbp
   540 000002F5 C3                              ret
   541                                  
   542                                  ; Nueva función para game over
   543                                  game_lost:
   544                                      ; Limpiar la pantalla
   545                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   546                                      
   547                                      ; Mostrar mensaje de derrota
   548                                      section .data
   549 000018DD C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   549 000018E6 6469646F210A0D     
   550                                          lost_msg_len: equ $ - lost_msg
   551                                      section .text
   552                                      
   553                                      ; Imprimir mensaje de derrota
   554                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [DD18000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   555                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [0B19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   556                                      
   557                                      ; Mostrar puntaje final
   558 00000347 488B05(42150000)            mov rax, [current_score]
   559 0000034E 48BF-                       mov rdi, number_buffer
   559 00000350 [4B15000000000000] 
   560 00000358 E8A40C0000                  call number_to_string
   561                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4B15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   562                                      
   563                                      ; Esperar un momento antes de salir
   564 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   564 00000381 0000               
   565 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   565 0000038C 0000               
   566                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   567                                      
   568 000003A1 E94F140000                  jmp exit
   569                                  
   570                                  
   571                                  ; Función para registrar una nueva letra en el mapa
   572                                  ; Entrada:
   573                                  ;   al - letra a registrar
   574                                  ;   r8b - posición x
   575                                  ;   r9b - posición y
   576                                  register_letter:
   577 000003A6 55                          push rbp
   578 000003A7 4889E5                      mov rbp, rsp
   579 000003AA 53                          push rbx
   580 000003AB 51                          push rcx
   581                                      
   582 000003AC 3C20                        cmp al, ' '
   583 000003AE 7438                        je .end
   584                                  
   585                                      ; Encontrar un espacio libre en el mapa
   586 000003B0 4831C9                      xor rcx, rcx
   587 000003B3 480FB615(D0170000)          movzx rdx, byte [letters_count]
   588                                      
   589                                      .find_slot:
   590 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   591 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   592                                          
   593 000003C1 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   594 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   595 000003CD 7405                            je .found_slot
   596                                          
   597 000003CF 48FFC1                          inc rcx
   598 000003D2 EBE7                            jmp .find_slot
   599                                          
   600                                      .found_slot:
   601                                          ; Guardar la información de la letra
   602 000003D4 448803                          mov [rbx], r8b           ; x
   603 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   604 000003DB 884302                          mov [rbx + 2], al        ; letra
   605 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   606                                          
   607 000003E2 FE05(D0170000)                  inc byte [letters_count]
   608                                          
   609                                      .end:
   610 000003E8 59                              pop rcx
   611 000003E9 5B                              pop rbx
   612 000003EA 5D                              pop rbp
   613 000003EB C3                              ret
   614                                  
   615                                  ; Función para imprimir todas las letras registradas
   616                                  print_letters:
   617 000003EC 55                          push rbp
   618 000003ED 4889E5                      mov rbp, rsp
   619 000003F0 53                          push rbx
   620 000003F1 51                          push rcx
   621                                      
   622 000003F2 4831C9                      xor rcx, rcx
   623                                      
   624                                      .print_loop:
   625 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   626 000003F9 7D37                            jge .end
   627                                          
   628                                          ; Obtener puntero a la letra actual
   629 000003FB 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   630                                          
   631                                          ; Verificar si está activa
   632 00000403 807B0300                        cmp byte [rbx + 3], 0
   633 00000407 7424                            je .next_letter
   634                                          
   635                                          ; Calcular posición en el tablero
   636 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   637 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   638                                          
   639                                          ; Calcular offset en el tablero
   640 00000412 B84E000000                      mov rax, column_cells
   641 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   642 0000041B 49F7E1                          mul r9
   643 0000041E 4C01C0                          add rax, r8
   644 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   645                                          
   646                                          ; Imprimir la letra
   647 00000428 8A4302                          mov al, [rbx + 2]
   648 0000042B 8807                            mov [rdi], al
   649                                          
   650                                      .next_letter:
   651 0000042D 48FFC1                          inc rcx
   652 00000430 EBC3                            jmp .print_loop
   653                                          
   654                                      .end:
   655 00000432 59                              pop rcx
   656 00000433 5B                              pop rbx
   657 00000434 5D                              pop rbp
   658 00000435 C3                              ret
   659                                  
   660                                  ; Función para borrar una letra específica
   661                                  ; Entrada:
   662                                  ;   r8b - posición x
   663                                  ;   r9b - posición y
   664                                  remove_letter:
   665 00000436 55                          push rbp
   666 00000437 4889E5                      mov rbp, rsp
   667 0000043A 53                          push rbx
   668 0000043B 51                          push rcx
   669                                      
   670 0000043C 4831C9                      xor rcx, rcx
   671                                      
   672                                      .find_loop:
   673 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   674 00000443 7D2E                            jge .end
   675                                          
   676 00000445 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   677                                          
   678                                          ; Verificar si está activa y coincide la posición
   679 0000044D 807B0300                        cmp byte [rbx + 3], 0
   680 00000451 741B                            je .next_letter
   681                                          
   682 00000453 8A03                            mov al, [rbx]
   683 00000455 4438C0                          cmp al, r8b
   684 00000458 7514                            jne .next_letter
   685                                          
   686 0000045A 8A4301                          mov al, [rbx + 1]
   687 0000045D 4438C8                          cmp al, r9b
   688 00000460 750C                            jne .next_letter
   689                                          
   690                                          ; Encontrada la letra, desactivarla
   691 00000462 C6430300                        mov byte [rbx + 3], 0
   692 00000466 FE0D(D0170000)                  dec byte [letters_count]
   693 0000046C EB05                            jmp .end
   694                                          
   695                                      .next_letter:
   696 0000046E 48FFC1                          inc rcx
   697 00000471 EBCC                            jmp .find_loop
   698                                          
   699                                      .end:
   700 00000473 59                              pop rcx
   701 00000474 5B                              pop rbx
   702 00000475 5D                              pop rbp
   703 00000476 C3                              ret
   704                                  ; Función para mover las letras hacia abajo
   705                                  move_letters:
   706 00000477 55                          push rbp
   707 00000478 4889E5                      mov rbp, rsp
   708 0000047B 53                          push rbx
   709 0000047C 57                          push rdi
   710 0000047D 56                          push rsi
   711 0000047E 4150                        push r8
   712 00000480 4151                        push r9
   713 00000482 4152                        push r10
   714 00000484 4153                        push r11
   715                                  
   716 00000486 4831C9                      xor rcx, rcx
   717                                  
   718                                      .move_loop:
   719 00000489 4883F964                        cmp rcx, 100
   720 0000048D 0F8DAD010000                    jge .print_last_letter
   721                                          
   722 00000493 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   723 0000049B 807B0300                        cmp byte [rbx + 3], 0
   724 0000049F 0F8493010000                    je .next_letter
   725                                  
   726 000004A5 4C0FB603                        movzx r8, byte [rbx]
   727 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   728                                  
   729 000004AE B84E000000                      mov rax, column_cells
   730 000004B3 4883C002                        add rax, 2
   731 000004B7 49F7E1                          mul r9
   732 000004BA 4C01C0                          add rax, r8
   733 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   734 000004C4 C60720                          mov byte [rdi], ' '
   735                                  
   736 000004C7 FE4301                          inc byte [rbx + 1]
   737 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   738                                  
   739 000004CF 4983F91F                        cmp r9, row_cells - 1
   740 000004D3 7C09                            jl .check_pallet_collision
   741                                  
   742 000004D5 C6430300                        mov byte [rbx + 3], 0
   743 000004D9 E95A010000                      jmp .next_letter
   744                                  
   745                                          .check_pallet_collision:
   746 000004DE B84E000000                          mov rax, column_cells
   747 000004E3 4883C002                            add rax, 2
   748 000004E7 49F7E1                              mul r9
   749 000004EA 4C01C0                              add rax, r8
   750 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   751                                  
   752 000004F4 8A07                                mov al, [rdi]
   753 000004F6 3C20                                cmp al, ' '
   754 000004F8 0F843A010000                        je .next_letter
   755 000004FE 3C3D                                cmp al, char_equal
   756 00000500 740A                                je .capture_letter
   757                                  
   758 00000502 8A4302                              mov al, [rbx + 2]
   759 00000505 8807                                mov [rdi], al
   760 00000507 E92C010000                          jmp .next_letter
   761                                  
   762                                          .capture_letter:
   763                                              ; Obtener la nueva letra
   764 0000050C 8A4302                              mov al, [rbx + 2]
   765                                              
   766                                              ; Comparar con la última letra
   767 0000050F 3A05(D1170000)                      cmp al, [last_letter]
   768 00000515 7407                                je .same_letter
   769                                              
   770                                              ; Es una letra diferente, resetear el procesamiento
   771 00000517 C605(E5170000)00                    mov byte [current_power_processed], 0
   772                                              
   773                                              .same_letter:
   774                                              ; Guardar la nueva letra
   775 0000051E 8805(D1170000)                      mov [last_letter], al
   776                                              
   777                                              ; Verificar si es 'E' para extender la paleta
   778 00000524 3C45                                cmp al, 'E'
   779 00000526 7441                                je .extend_pallet
   780                                              
   781                                              ; Verificar si es 'P' para añadir vida
   782 00000528 3C50                                cmp al, 'P'
   783 0000052A 7462                                je .check_add_life
   784                                  
   785 0000052C 3C53                                cmp al, 'S'
   786 0000052E 0F8493000000                        je .slow_ball
   787                                  
   788 00000534 3C43                                cmp al, 'C'
   789 00000536 0F84AD000000                        je .activate_catch
   790                                              
   791 0000053C 3C4C                                cmp al, 'L'
   792 0000053E 0F84C7000000                        je .activate_laser
   793                                  
   794                                              ; Si no es ningún power-up, restaurar tamaño normal
   795 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   796 0000054B 488905(47140000)                    mov [pallet_size], rax
   797 00000552 48C705(E7170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   797 0000055A 000000             
   798 0000055D C605(FF170000)00                    mov byte [catch_power_active], 0
   799 00000564 E9CB000000                          jmp .finish_capture
   800                                  
   801                                              .extend_pallet:
   802 00000569 C605(FF170000)00                        mov byte [catch_power_active], 0
   803 00000570 48C705(E7170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 00000578 000000             
   804 0000057B 488B05(57140000)                        mov rax, [extended_pallet_size]
   805 00000582 488905(47140000)                        mov [pallet_size], rax
   806 00000589 E9A6000000                              jmp .finish_capture
   807                                  
   808                                              .check_add_life:
   809 0000058E C605(FF170000)00                        mov byte [catch_power_active], 0
   810 00000595 488B05(4F140000)                        mov rax, [default_pallet_size]
   811 0000059C 488905(47140000)                        mov [pallet_size], rax
   812 000005A3 48C705(E7170000)01-                     mov qword [ball_speed], 1 
   812 000005AB 000000             
   813                                                  ; Verificar si ya procesamos este power-up
   814 000005AE 803D(E5170000)00                        cmp byte [current_power_processed], 0
   815 000005B5 757D                                    jne .finish_capture
   816                                                  
   817                                                  ; Preservar registros importantes
   818 000005B7 51                                      push rcx
   819 000005B8 53                                      push rbx
   820                                                  
   821                                                  ; Marcar como procesado
   822 000005B9 C605(E5170000)01                        mov byte [current_power_processed], 1
   823                                                  
   824                                                  ; Añadir una vida
   825 000005C0 E84B020000                              call add_life
   826                                                  
   827                                                  ; Restaurar registros
   828 000005C5 5B                                      pop rbx
   829 000005C6 59                                      pop rcx
   830                                                  
   831                                              .slow_ball:
   832 000005C7 C605(FF170000)00                        mov byte [catch_power_active], 0                
   833 000005CE 488B05(4F140000)                        mov rax, [default_pallet_size]
   834 000005D5 488905(47140000)                        mov [pallet_size], rax
   835 000005DC 48C705(E7170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   835 000005E4 000000             
   836 000005E7 EB4B                                    jmp .finish_capture
   837                                  
   838                                              .activate_catch:
   839 000005E9 488B05(4F140000)                        mov rax, [default_pallet_size]
   840 000005F0 488905(47140000)                        mov [pallet_size], rax
   841 000005F7 48C705(E7170000)01-                     mov qword [ball_speed], 1
   841 000005FF 000000             
   842 00000602 C605(FF170000)01                        mov byte [catch_power_active], 1
   843 00000609 EB29                                    jmp .finish_capture
   844                                  
   845                                              .activate_laser:
   846 0000060B C605(FF170000)00                        mov byte [catch_power_active], 0
   847 00000612 488B05(4F140000)                        mov rax, [default_pallet_size]
   848 00000619 488905(47140000)                        mov [pallet_size], rax
   849 00000620 48C705(E7170000)01-                     mov qword [ball_speed], 1
   849 00000628 000000             
   850 0000062B C605(0A180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   851 00000632 EB00                                    jmp .finish_capture
   852                                  
   853                                              .finish_capture:
   854 00000634 C6430300                                mov byte [rbx + 3], 0
   855                                  
   856                                          .next_letter:
   857 00000638 48FFC1                              inc rcx
   858 0000063B E949FEFFFF                          jmp .move_loop
   859                                  
   860                                      .print_last_letter:
   861                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000640 B801000000          <1>  mov eax, sys_write
    83 00000645 BF01000000          <1>  mov edi, 1
    84 0000064A 48BE-               <1>  mov rsi, %1
    84 0000064C [D217000000000000]  <1>
    85 00000654 BA10000000          <1>  mov edx, %2
    86 00000659 0F05                <1>  syscall
   862 0000065B 8A05(D1170000)                  mov al, [last_letter]
   863 00000661 8805(E1170000)                  mov [last_letter_msg + 15], al
   864                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [E217000000000000]  <1>
    85 0000067B BA03000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   865                                  
   866                                      .end:
   867 00000682 415B                            pop r11
   868 00000684 415A                            pop r10
   869 00000686 4159                            pop r9
   870 00000688 4158                            pop r8
   871 0000068A 5E                              pop rsi
   872 0000068B 5F                              pop rdi
   873 0000068C 5B                              pop rbx
   874 0000068D 5D                              pop rbp
   875 0000068E C3                              ret
   876                                  
   877                                  
   878                                  
   879                                  ; Nueva función para actualizar los láseres
   880                                  update_lasers:
   881 0000068F 55                          push rbp
   882 00000690 4889E5                      mov rbp, rsp
   883                                      
   884                                      ; Verificar si el poder láser está activo
   885 00000693 803D(0A180000)00            cmp byte [laser_power_active], 0
   886 0000069A 741A                        je .end
   887                                      
   888                                      ; Verificar si se presionó la tecla de espacio
   889 0000069C 803D(09180000)20            cmp byte [last_key], ' '
   890 000006A3 750C                        jne .skip_shooting
   891                                      
   892                                      ; Disparar nuevos láseres
   893 000006A5 E80E000000                  call shoot_lasers
   894 000006AA C605(09180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   895                                      
   896                                      .skip_shooting:
   897                                      ; Mover los láseres existentes
   898 000006B1 E89C000000                  call move_lasers
   899                                      
   900                                      .end:
   901 000006B6 5D                              pop rbp
   902 000006B7 C3                              ret
   903                                  
   904                                  shoot_lasers:
   905 000006B8 55                          push rbp
   906 000006B9 4889E5                      mov rbp, rsp
   907 000006BC 53                          push rbx
   908                                      
   909                                      ; Verificar si hay espacio para más láseres
   910 000006BD 480FB605(0C180000)          movzx rax, byte [laser_count]
   911 000006C5 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   912 000006C9 0F8D80000000                jge .end
   913                                      
   914                                      ; Obtener posición de la paleta
   915 000006CF 4C8B05(3F140000)            mov r8, [pallet_position]
   916 000006D6 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   917                                      
   918                                      ; Calcular coordenadas x,y
   919 000006DD 4C89C0                      mov rax, r8
   920 000006E0 41B94E000000                mov r9, column_cells
   921 000006E6 4983C102                    add r9, 2                     ; Ancho total de línea
   922 000006EA 4831D2                      xor rdx, rdx
   923 000006ED 49F7F1                      div r9                        ; rax = y, rdx = x
   924                                      
   925                                      ; Guardar coordenadas
   926 000006F0 4989C2                      mov r10, rax                  ; Y en r10
   927 000006F3 4989D3                      mov r11, rdx                  ; X en r11
   928                                      
   929                                      ; Validar coordenadas
   930 000006F6 4983FA00                    cmp r10, 0
   931 000006FA 7C53                        jl .end
   932 000006FC 4983FA20                    cmp r10, row_cells
   933 00000700 7D4D                        jge .end
   934 00000702 4983FB00                    cmp r11, 0
   935 00000706 7C47                        jl .end
   936 00000708 4983FB4E                    cmp r11, column_cells
   937 0000070C 7D41                        jge .end
   938                                      
   939                                      ; Calcular índice para el primer láser
   940 0000070E 480FB61D(0C180000)          movzx rbx, byte [laser_count]
   941 00000716 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   942                                      
   943                                      ; Primer láser (izquierda)
   944 0000071A 488DBB[0D180000]            lea rdi, [lasers + rbx]
   945 00000721 44881F                      mov [rdi], r11b              ; X
   946 00000724 4488D0                      mov al, r10b
   947 00000727 FEC8                        dec al                       ; Y - 1
   948 00000729 884701                      mov [rdi + 1], al           ; Y
   949                                      
   950                                      ; Segundo láser (derecha)
   951 0000072C 4488D8                      mov al, r11b
   952 0000072F 0205(47140000)              add al, byte [pallet_size]
   953 00000735 FEC8                        dec al                       ; Ajustar para el último carácter
   954 00000737 488DBB[0F180000]            lea rdi, [lasers + rbx + 2]
   955 0000073E 8807                        mov [rdi], al               ; X
   956 00000740 4488D0                      mov al, r10b
   957 00000743 FEC8                        dec al                      ; Y - 1
   958 00000745 884701                      mov [rdi + 1], al          ; Y
   959                                      
   960                                      ; Incrementar contador de láseres
   961 00000748 8005(0C180000)02            add byte [laser_count], 2
   962                                      
   963                                      
   964                                      .end:
   965 0000074F 5B                              pop rbx
   966 00000750 5D                              pop rbp
   967 00000751 C3                              ret
   968                                  
   969                                  ; Función corregida para mover láseres
   970                                  ; Función corregida para mover láseres
   971                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
   972                                  
   973                                  move_lasers:
   974 00000752 55                          push rbp
   975 00000753 4889E5                      mov  rbp, rsp
   976 00000756 53                          push rbx
   977 00000757 57                          push rdi
   978 00000758 56                          push rsi
   979 00000759 4154                        push r12
   980 0000075B 4155                        push r13
   981 0000075D 4156                        push r14
   982 0000075F 4157                        push r15
   983                                  
   984                                      ; 1) Tomamos la cantidad de láseres
   985 00000761 480FB60D(0C180000)          movzx rcx, byte [laser_count]
   986 00000769 4885C9                      test rcx, rcx
   987 0000076C 0F8491000000                jz .fin              ; Si es cero, no hay láseres => salir
   988                                  
   989                                      ; Ajustamos para que RCX sea el último índice de láser
   990 00000772 48FFC9                      dec rcx              ; Último índice es (laser_count - 1)
   991                                  
   992                                  .loop_lasers:
   993                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
   994 00000775 488DB409[0D180000]          lea rsi, [lasers + rcx*2]
   995                                  
   996                                      ; 2) Cargar x,y actuales
   997 0000077D 4C0FB606                    movzx r8,  byte [rsi]      ; x
   998 00000781 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; y
   999                                  
  1000                                      ; 3) Borrar el láser de su posición actual en pantalla
  1001 00000786 B84E000000                  mov rax, column_cells
  1002 0000078B 4883C002                    add rax, 2
  1003 0000078F 49F7E1                      mul r9
  1004 00000792 4C01C0                      add rax, r8
  1005 00000795 488DB8[000A0000]            lea rdi, [board + rax]
  1006 0000079C C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1007                                  
  1008                                      ; 4) Mover el láser hacia arriba (y - 1)
  1009 0000079F 49FFC9                      dec r9
  1010                                  
  1011                                      ; Verificar si ya salió de la pantalla (o si y < 1)
  1012 000007A2 4983F901                    cmp r9, 1
  1013 000007A6 7C2D                        jl .delete_laser           ; Si y < 1 => eliminarlo
  1014                                  
  1015                                      ; 5) Si sigue en pantalla => guardar su nueva posición
  1016 000007A8 44884E01                    mov byte [rsi + 1], r9b
  1017                                  
  1018                                      ; 6) Dibujar láser en la nueva posición
  1019 000007AC B84E000000                  mov rax, column_cells
  1020 000007B1 4883C002                    add rax, 2
  1021 000007B5 49F7E1                      mul r9
  1022 000007B8 4C01C0                      add rax, r8
  1023 000007BB 488DB8[000A0000]            lea rdi, [board + rax]
  1024 000007C2 8A05(0B180000)              mov al, [laser_symbol]
  1025 000007C8 8807                        mov [rdi], al
  1026                                  
  1027                                  .next_laser:
  1028                                      ; 7) Pasamos al láser anterior
  1029 000007CA 48FFC9                      dec rcx
  1030 000007CD 4883F9FF                    cmp rcx, -1
  1031 000007D1 7FA2                        jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1032                                  
  1033 000007D3 EB2E                        jmp .fin
  1034                                  
  1035                                  .delete_laser:
  1036                                      ; 8) Borrar el láser actual del array
  1037 000007D5 4C0FB625(0C180000)          movzx r12, byte [laser_count]
  1038 000007DD 49FFCC                      dec r12                    ; r12 = último índice
  1039 000007E0 4939CC                      cmp r12, rcx
  1040 000007E3 7616                        jbe .just_decrement        ; Si rcx ya apunta al último
  1041                                  
  1042                                      ; Si NO es el último láser => copiamos el último en la posición actual
  1043 000007E5 488DBC09[0D180000]          lea rdi, [lasers + rcx*2]
  1044 000007ED 4B8DB424[0D180000]          lea rsi, [lasers + r12*2]
  1045 000007F5 668B06                      mov ax, [rsi]             ; lee 2 bytes (x,y) del último
  1046 000007F8 668907                      mov [rdi], ax             ; copy
  1047                                  
  1048                                  .just_decrement:
  1049 000007FB FE0D(0C180000)              dec byte [laser_count]     ; Decrementar el contador total
  1050 00000801 EBC7                        jmp .next_laser
  1051                                  
  1052                                  .fin:
  1053 00000803 415F                        pop r15
  1054 00000805 415E                        pop r14
  1055 00000807 415D                        pop r13
  1056 00000809 415C                        pop r12
  1057 0000080B 5E                          pop rsi
  1058 0000080C 5F                          pop rdi
  1059 0000080D 5B                          pop rbx
  1060 0000080E 5D                          pop rbp
  1061 0000080F C3                          ret
  1062                                  
  1063                                  
  1064                                  add_life:
  1065 00000810 55                          push rbp
  1066 00000811 4889E5                      mov rbp, rsp
  1067 00000814 53                          push rbx
  1068 00000815 51                          push rcx
  1069 00000816 57                          push rdi
  1070 00000817 56                          push rsi
  1071 00000818 4150                        push r8
  1072 0000081A 4151                        push r9
  1073                                      
  1074                                      ; Verificar si ya tenemos el máximo de vidas
  1075 0000081C 480FB605(3F160000)          movzx rax, byte [current_lives]
  1076 00000824 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1077 00000828 7D2C                        jge .end
  1078                                      
  1079                                      ; Incrementar el contador de vidas
  1080 0000082A FE05(3F160000)              inc byte [current_lives]
  1081                                      
  1082                                      ; Encontrar la siguiente vida inactiva
  1083 00000830 4831C9                      xor rcx, rcx
  1084                                      
  1085                                      .find_inactive:
  1086 00000833 4883F907                        cmp rcx, lives_count
  1087 00000837 7D1D                            jge .end
  1088                                          
  1089                                          ; Calcular offset de la vida actual
  1090 00000839 4889C8                          mov rax, rcx
  1091 0000083C 486BC003                        imul rax, 3
  1092 00000840 488DB0[29160000]                lea rsi, [lives_data + rax]
  1093                                          
  1094                                          ; Verificar si está inactiva
  1095 00000847 807E0200                        cmp byte [rsi + 2], 0
  1096 0000084B 7405                            je .activate_life
  1097                                          
  1098 0000084D 48FFC1                          inc rcx
  1099 00000850 EBE1                            jmp .find_inactive
  1100                                          
  1101                                      .activate_life:
  1102                                          ; Activar la vida
  1103 00000852 C6460201                        mov byte [rsi + 2], 1
  1104                                          
  1105                                      .end:
  1106 00000856 4159                            pop r9
  1107 00000858 4158                            pop r8
  1108 0000085A 5E                              pop rsi
  1109 0000085B 5F                              pop rdi
  1110 0000085C 59                              pop rcx
  1111 0000085D 5B                              pop rbx
  1112 0000085E 5D                              pop rbp
  1113 0000085F C3                              ret
  1114                                  
  1115                                  
  1116                                  print_ball:
  1117 00000860 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1118 00000867 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1119 0000086E 4981C0[000A0000]        	add r8, board
  1120                                  
  1121 00000875 4C89C9                  	mov rcx, r9
  1122 00000878 B850000000              	mov rax, column_cells + 2
  1123 0000087D 48F7E9                  	imul rcx
  1124                                  	
  1125 00000880 4901C0                  	add r8, rax
  1126 00000883 41C6004F                	mov byte [r8], char_O
  1127 00000887 C3                      	ret
  1128                                  
  1129                                  	
  1130                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1131                                  	
  1132                                  print_pallet:
  1133                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1134 00000888 4C8B05(3F140000)            mov r8, [pallet_position]
  1135 0000088F 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1136                                      .clear_pallet:
  1137 00000896 41C60020                        mov byte [r8], char_space
  1138 0000089A 49FFC0                          inc r8
  1139 0000089D 48FFC9                          dec rcx
  1140 000008A0 75F4                            jnz .clear_pallet
  1141                                  
  1142                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1143 000008A2 4C8B05(3F140000)            mov r8, [pallet_position]
  1144 000008A9 488B0D(47140000)            mov rcx, [pallet_size]
  1145                                      .write_pallet:
  1146 000008B0 41C6003D                        mov byte [r8], char_equal
  1147 000008B4 49FFC0                          inc r8
  1148 000008B7 48FFC9                          dec rcx
  1149 000008BA 75F4                            jnz .write_pallet
  1150                                  
  1151 000008BC C3                          ret
  1152                                  
  1153                                  move_pallet:
  1154                                      
  1155 000008BD 803D(7F140000)00            cmp byte [ball_moving], 0
  1156 000008C4 7507                        jne .continue_movement
  1157 000008C6 C605(7F140000)01            mov byte [ball_moving], 1
  1158                                  
  1159                                      .continue_movement:
  1160 000008CD 4883FFFF                        cmp rdi, left_direction
  1161 000008D1 7531                            jne .move_right
  1162                                  
  1163                                          .move_left:
  1164                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1165 000008D3 4C8B05(3F140000)                    mov r8, [pallet_position]
  1166 000008DA 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1167 000008DD 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1168 000008E0 3C58                                cmp al, 'X'        ; Comparar si es una X
  1169 000008E2 744E                                je .end            ; Si es X, no mover
  1170                                              
  1171 000008E4 4C8B05(3F140000)                    mov r8, [pallet_position]
  1172 000008EB 4C8B0D(47140000)                    mov r9, [pallet_size]
  1173 000008F2 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1174 000008F8 49FFC8                              dec r8
  1175 000008FB 4C8905(3F140000)                    mov [pallet_position], r8
  1176 00000902 EB2E                                jmp .end
  1177                                              
  1178                                          .move_right:
  1179                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1180 00000904 4C8B05(3F140000)                    mov r8, [pallet_position]
  1181 0000090B 4C8B0D(47140000)                    mov r9, [pallet_size]
  1182 00000912 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1183 00000915 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1184 00000919 3C58                                cmp al, 'X'        ; Comparar si es una X
  1185 0000091B 7415                                je .end            ; Si es X, no mover
  1186                                              
  1187 0000091D 4C8B05(3F140000)                    mov r8, [pallet_position]
  1188 00000924 41C60020                            mov byte [r8], char_space
  1189 00000928 49FFC0                              inc r8
  1190 0000092B 4C8905(3F140000)                    mov [pallet_position], r8
  1191                                          .end:
  1192 00000932 C3                                  ret
  1193                                  
  1194                                  
  1195                                  
  1196                                              
  1197                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1198                                  update_caught_ball_position:
  1199 00000933 55                          push rbp
  1200 00000934 4889E5                      mov rbp, rsp
  1201                                      
  1202                                      ; Calcular la nueva posición de la bola basada en la paleta
  1203 00000937 4C8B05(3F140000)            mov r8, [pallet_position]
  1204 0000093E 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1205 00000945 B850000000                  mov rax, column_cells + 2
  1206 0000094A 4831D2                      xor rdx, rdx
  1207 0000094D 48F7F0                      div rax                ; División para obtener X,Y
  1208                                      
  1209                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1210 00000950 4989C1                      mov r9, rax            ; Y de la paleta
  1211 00000953 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1212                                      
  1213                                      ; Añadir el offset guardado a la posición X
  1214 00000956 4889D0                      mov rax, rdx
  1215 00000959 480305(01180000)            add rax, [ball_catch_offset]
  1216 00000960 488905(5F140000)            mov [ball_x_pos], rax
  1217 00000967 4C890D(67140000)            mov [ball_y_pos], r9
  1218                                      
  1219 0000096E 5D                          pop rbp
  1220 0000096F C3                          ret
  1221                                  move_ball:
  1222                                  
  1223 00000970 803D(00180000)01            cmp byte [ball_caught], 1
  1224 00000977 0F849D000000                je .move_with_pallet
  1225                                  
  1226 0000097D 803D(7F140000)00            cmp byte [ball_moving], 0
  1227 00000984 0F84B8010000                je .end
  1228                                  
  1229                                      ; Incrementar contador de velocidad
  1230 0000098A 48FF05(F7170000)            inc qword [speed_counter]
  1231                                      
  1232                                      ; Verificar si debemos mover la bola en este ciclo
  1233 00000991 488B05(F7170000)            mov rax, [speed_counter]
  1234 00000998 483B05(E7170000)            cmp rax, [ball_speed]
  1235 0000099F 0F8C9D010000                jl .end
  1236                                      
  1237                                      ; Resetear contador de velocidad
  1238 000009A5 48C705(F7170000)00-         mov qword [speed_counter], 0
  1238 000009AD 000000             
  1239                                  
  1240                                      ; Borrar la posición actual de la bola
  1241 000009B0 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1242 000009B7 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1243 000009BE 4981C0[000A0000]            add r8, board
  1244 000009C5 4C89C9                      mov rcx, r9
  1245 000009C8 B850000000                  mov rax, column_cells + 2
  1246 000009CD 48F7E9                      imul rcx
  1247 000009D0 4901C0                      add r8, rax
  1248 000009D3 41C60020                    mov byte [r8], char_space
  1249                                  
  1250                                      ; Calcular siguiente posición X
  1251 000009D7 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1252 000009DE 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1253 000009E5 488B05(6F140000)            mov rax, [ball_direction_x]
  1254 000009EC 4901C0                      add r8, rax               ; Nueva posición X
  1255                                  
  1256                                      ; Calcular la dirección de memoria para la siguiente posición
  1257 000009EF 4D89C2                      mov r10, r8
  1258 000009F2 4981C2[000A0000]            add r10, board
  1259 000009F9 4C89C9                      mov rcx, r9
  1260 000009FC B850000000                  mov rax, column_cells + 2
  1261 00000A01 48F7E9                      imul rcx
  1262 00000A04 4901C2                      add r10, rax
  1263                                  
  1264                                      ; Verificar si hay una X en la siguiente posición X
  1265 00000A07 418A02                      mov al, [r10]
  1266 00000A0A 3C58                        cmp al, 'X'
  1267 00000A0C 7565                        jne .check_block_x
  1268 00000A0E 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1269 00000A15 E928010000                  jmp .end
  1270                                  
  1271                                      .move_with_pallet:
  1272                                          ; Borrar la posición actual de la bola
  1273 00000A1A 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1274 00000A21 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1275 00000A28 4D89C2                          mov r10, r8
  1276 00000A2B 4981C2[000A0000]                add r10, board
  1277 00000A32 4C89C9                          mov rcx, r9
  1278 00000A35 B850000000                      mov rax, column_cells + 2
  1279 00000A3A 48F7E9                          imul rcx
  1280 00000A3D 4901C2                          add r10, rax
  1281 00000A40 41C60220                        mov byte [r10], char_space
  1282                                  
  1283                                          ; Actualizar posición X basada en la paleta
  1284 00000A44 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1285 00000A4B 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1286 00000A52 4C0305(01180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1287 00000A59 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1288                                  
  1289                                          ; Mantener la bola una posición arriba de la paleta
  1290 00000A60 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1291 00000A67 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1292                                  
  1293 00000A6E E9CF000000                      jmp .end
  1294                                  
  1295                                  
  1296                                      .check_block_x:
  1297                                          ; Verificar colisión con bloques en X
  1298 00000A73 4150                            push r8     ; Guardar registros que usa check_block_collision
  1299 00000A75 4151                            push r9
  1300 00000A77 4152                            push r10
  1301 00000A79 E8DB060000                      call check_block_collision
  1302 00000A7E 415A                            pop r10
  1303 00000A80 4159                            pop r9
  1304 00000A82 4158                            pop r8
  1305 00000A84 4885C0                          test rax, rax
  1306 00000A87 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1307 00000A89 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1308 00000A90 E9AD000000                      jmp .end
  1309                                  
  1310                                      .check_paddle_x:
  1311                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1312 00000A95 41803A3D                        cmp byte [r10], char_equal
  1313 00000A99 750C                            jne .check_y_movement
  1314 00000A9B 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1315 00000AA2 E99B000000                      jmp .end
  1316                                  
  1317                                      .check_y_movement:
  1318                                          ; Calcular siguiente posición Y
  1319 00000AA7 488B05(77140000)                mov rax, [ball_direction_y]
  1320 00000AAE 4901C1                          add r9, rax                  ; Nueva posición Y
  1321                                  
  1322                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1323 00000AB1 4D89C2                          mov r10, r8
  1324 00000AB4 4981C2[000A0000]                add r10, board
  1325 00000ABB 4C89C9                          mov rcx, r9
  1326 00000ABE B850000000                      mov rax, column_cells + 2
  1327 00000AC3 48F7E9                          imul rcx
  1328 00000AC6 4901C2                          add r10, rax
  1329                                  
  1330                                          ; Verificar si hay una X en la siguiente posición Y
  1331 00000AC9 418A02                          mov al, [r10]
  1332 00000ACC 3C58                            cmp al, 'X'
  1333 00000ACE 7509                            jne .check_block_y
  1334 00000AD0 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1335 00000AD7 EB69                            jmp .end
  1336                                  
  1337                                      .check_block_y:
  1338                                          ; Verificar colisión con bloques en Y
  1339 00000AD9 4150                            push r8     ; Guardar registros que usa check_block_collision
  1340 00000ADB 4151                            push r9
  1341 00000ADD 4152                            push r10
  1342 00000ADF E875060000                      call check_block_collision
  1343 00000AE4 415A                            pop r10
  1344 00000AE6 4159                            pop r9
  1345 00000AE8 4158                            pop r8
  1346 00000AEA 4885C0                          test rax, rax
  1347 00000AED 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1348 00000AEF 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1349 00000AF6 EB4A                            jmp .end
  1350                                  
  1351                                      .check_paddle_y:
  1352                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1353 00000AF8 41803A3D                        cmp byte [r10], char_equal
  1354 00000AFC 7536                            jne .update_position
  1355                                  
  1356                                          ; Verificar si el poder catch está activo
  1357 00000AFE 803D(FF170000)01                cmp byte [catch_power_active], 1
  1358 00000B05 7524                            jne .normal_bounce
  1359                                  
  1360                                          ; Activar el modo "atrapado"
  1361 00000B07 C605(00180000)01                mov byte [ball_caught], 1
  1362                                          
  1363                                          ; Guardar la posición X actual de la bola como offset
  1364 00000B0E 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1365 00000B15 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1366 00000B1C 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1367 00000B22 488905(01180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1368                                          
  1369 00000B29 EB17                            jmp .end
  1370                                  
  1371                                      .normal_bounce:
  1372 00000B2B 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1373 00000B32 EB0E                            jmp .end
  1374                                  
  1375                                  
  1376                                      .update_position:
  1377 00000B34 4C8905(5F140000)                mov [ball_x_pos], r8
  1378 00000B3B 4C890D(67140000)                mov [ball_y_pos], r9
  1379                                  
  1380                                      .end:
  1381 00000B42 C3                              ret
  1382                                  
  1383                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1384                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1385                                  process_catch_release:
  1386 00000B43 55                          push rbp
  1387 00000B44 4889E5                      mov rbp, rsp
  1388                                  
  1389                                      ; Verificar si la bola está atrapada
  1390 00000B47 803D(00180000)00            cmp byte [ball_caught], 0
  1391 00000B4E 7436                        je .end
  1392                                  
  1393                                      ; Verificar si el poder catch está activo
  1394 00000B50 803D(FF170000)01            cmp byte [catch_power_active], 1
  1395 00000B57 752D                        jne .end
  1396                                  
  1397                                      ; Verificar si se presionó la tecla 'c'
  1398 00000B59 803D(09180000)63            cmp byte [last_key], 'c'
  1399 00000B60 7524                        jne .end
  1400                                  
  1401                                      ; Liberar la bola y asignar dirección inicial
  1402 00000B62 C605(00180000)00            mov byte [ball_caught], 0
  1403 00000B69 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1403 00000B71 000000             
  1404 00000B74 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1404 00000B7C FFFFFF             
  1405                                  
  1406                                      ; Limpiar la tecla procesada
  1407 00000B7F C605(09180000)00            mov byte [last_key], 0
  1408                                  
  1409                                      .end:
  1410 00000B86 5D                              pop rbp
  1411 00000B87 C3                              ret
  1412                                  
  1413                                  
  1414                                  display_level_number:
  1415 00000B88 55                          push rbp
  1416 00000B89 4889E5                      mov rbp, rsp
  1417                                      
  1418                                      ; Limpiar la pantalla primero
  1419                                      print clear, clear_length
    82 00000B8C B801000000          <1>  mov eax, sys_write
    83 00000B91 BF01000000          <1>  mov edi, 1
    84 00000B96 48BE-               <1>  mov rsi, %1
    84 00000B98 [1000000000000000]  <1>
    85 00000BA0 BA07000000          <1>  mov edx, %2
    86 00000BA5 0F05                <1>  syscall
  1420                                      
  1421                                      ; Calcular la posición central para el mensaje
  1422                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1423 00000BA7 B84E000000                  mov rax, column_cells
  1424 00000BAC 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1425 00000BB0 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1426                                      
  1427                                      ; Calcular la fila central
  1428 00000BB3 BB20000000                  mov rbx, row_cells
  1429 00000BB8 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1430                                      
  1431                                      ; Calcular el offset en el buffer
  1432 00000BBB B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1433 00000BC0 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1434 00000BC3 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1435                                      
  1436                                      ; Escribir "NIVEL " en la posición calculada
  1437 00000BC6 488DB8[000A0000]            lea rdi, [board + rax]
  1438 00000BCD 48BE-                       mov rsi, level_msg
  1438 00000BCF [2414000000000000] 
  1439 00000BD7 B906000000                  mov rcx, level_msg_len
  1440 00000BDC F3A4                        rep movsb
  1441                                      
  1442                                      ; Escribir el número del nivel
  1443 00000BDE 8A05(B4140000)              mov al, [current_level]
  1444 00000BE4 0430                        add al, '0'                 ; convertir a ASCII
  1445 00000BE6 8807                        mov [rdi], al
  1446                                      
  1447                                      ; Mostrar el board con el mensaje
  1448                                      print board, board_size
    82 00000BE8 B801000000          <1>  mov eax, sys_write
    83 00000BED BF01000000          <1>  mov edi, 1
    84 00000BF2 48BE-               <1>  mov rsi, %1
    84 00000BF4 [000A000000000000]  <1>
    85 00000BFC BA000A0000          <1>  mov edx, %2
    86 00000C01 0F05                <1>  syscall
  1449                                      
  1450                                      ; Esperar un segundo
  1451 00000C03 B823000000                  mov rax, sys_nanosleep
  1452 00000C08 48BF-                       mov rdi, level_display_time
  1452 00000C0A [2F14000000000000] 
  1453 00000C12 4831F6                      xor rsi, rsi
  1454 00000C15 0F05                        syscall
  1455                                      
  1456 00000C17 5D                          pop rbp
  1457 00000C18 C3                          ret
  1458                                  
  1459                                  ; Función para inicializar un tablero vacío
  1460                                  init_empty_board:
  1461 00000C19 56                          push rsi
  1462 00000C1A 57                          push rdi
  1463 00000C1B 51                          push rcx
  1464 00000C1C 50                          push rax
  1465                                  
  1466 00000C1D 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1467 00000C24 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1468 00000C2B B9000A0000                  mov rcx, board_template_size
  1469 00000C30 F3A4                        rep movsb                   ; Copiar el tablero
  1470                                  
  1471 00000C32 58                          pop rax
  1472 00000C33 59                          pop rcx
  1473 00000C34 5F                          pop rdi
  1474 00000C35 5E                          pop rsi
  1475 00000C36 C3                          ret
  1476                                  
  1477                                  
  1478                                  init_level:
  1479                                  
  1480 00000C37 488B05(4F140000)            mov rax, [default_pallet_size]
  1481 00000C3E 488905(47140000)            mov [pallet_size], rax
  1482 00000C45 48C705(E7170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1482 00000C4D 000000             
  1483                                  
  1484                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1485                                          ; Reiniciar letras activas
  1486 00000C50 488D3D(40160000)            lea rdi, [letters_map]
  1487 00000C57 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1488 00000C5C 4831C0                      xor rax, rax
  1489 00000C5F F3AA                        rep stosb                    ; Llenar con ceros
  1490                                      
  1491                                      ; Inicializar dirección de la bola (derecha y arriba)
  1492 00000C61 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1492 00000C69 000000             
  1493 00000C6C 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1493 00000C74 FFFFFF             
  1494                                  
  1495                                  
  1496                                      ; Reiniciar contador de letras activas
  1497 00000C77 4831C0                      xor rax, rax
  1498 00000C7A 8805(D0170000)              mov [letters_count], al
  1499                                  
  1500                                      ; Reiniciar última letra capturada
  1501 00000C80 C605(D1170000)20            mov byte [last_letter], ' '
  1502 00000C87 C605(4A150000)00            mov byte [destroyed_blocks], 0 
  1503 00000C8E E886FFFFFF                  call init_empty_board
  1504 00000C93 E8F0FEFFFF                  call display_level_number
  1505 00000C98 E8E5050000                  call init_enemies
  1506                                      
  1507 00000C9D 56                          push rsi
  1508 00000C9E 57                          push rdi
  1509 00000C9F 51                          push rcx
  1510 00000CA0 50                          push rax
  1511                                  
  1512 00000CA1 488D35(00000000)            lea rsi, [board_template]
  1513 00000CA8 488D3D(000A0000)            lea rdi, [board]
  1514 00000CAF B9000A0000                  mov rcx, board_template_size
  1515 00000CB4 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1516                                  
  1517 00000CB6 58                          pop rax
  1518 00000CB7 59                          pop rcx
  1519 00000CB8 5F                          pop rdi
  1520 00000CB9 5E                          pop rsi
  1521                                  
  1522 00000CBA B90A000000                  mov rcx, 10
  1523 00000CBF 4831C0                      xor rax, rax
  1524 00000CC2 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  1525 00000CC9 F3AA                        rep stosb      
  1526                                  
  1527                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1528 00000CCB 803D(B4140000)01            cmp byte [current_level], 1
  1529 00000CD2 7431                        je .level1
  1530 00000CD4 803D(B4140000)02            cmp byte [current_level], 2
  1531 00000CDB 7454                        je .level2
  1532 00000CDD 803D(B4140000)03            cmp byte [current_level], 3
  1533 00000CE4 7477                        je .level3
  1534 00000CE6 803D(B4140000)04            cmp byte [current_level], 4
  1535 00000CED 0F8492000000                je .level4
  1536 00000CF3 803D(B4140000)05            cmp byte [current_level], 5
  1537 00000CFA 0F84AD000000                je .level5
  1538 00000D00 E9D0000000                  jmp .done
  1539                                  
  1540                                  
  1541                                  
  1542                                      .level1:
  1543 00000D05 C605(B5140000)04                mov byte [blocks_remaining], level1_blocks_count
  1544 00000D0C 4831C9                          xor rcx, rcx             
  1545                                          .init_loop1:
  1546 00000D0F 4883F904                            cmp rcx, level1_blocks_count
  1547 00000D13 0F8DBC000000                        jge .done
  1548 00000D19 4889C8                              mov rax, rcx         
  1549 00000D1C 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1550 00000D20 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1551 00000D26 8891[DE140000]                      mov byte [block_states + rcx], dl
  1552 00000D2C 48FFC1                              inc rcx
  1553 00000D2F EBDE                                jmp .init_loop1
  1554                                  
  1555                                      .level2:
  1556 00000D31 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1557 00000D38 4831C9                          xor rcx, rcx             
  1558                                          .init_loop2:
  1559 00000D3B 4883F901                            cmp rcx, level2_blocks_count
  1560 00000D3F 0F8D90000000                        jge .done
  1561 00000D45 4889C8                              mov rax, rcx         
  1562 00000D48 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1563 00000D4C 8A90[CD140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1564 00000D52 8891[DE140000]                      mov byte [block_states + rcx], dl
  1565 00000D58 48FFC1                              inc rcx
  1566 00000D5B EBDE                                jmp .init_loop2
  1567                                      .level3:
  1568 00000D5D C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1569 00000D64 4831C9                          xor rcx, rcx             
  1570                                          .init_loop3:
  1571 00000D67 4883F901                            cmp rcx, level3_blocks_count
  1572 00000D6B 7D68                                jge .done
  1573 00000D6D 4889C8                              mov rax, rcx         
  1574 00000D70 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1575 00000D74 8A90[D2140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1576 00000D7A 8891[DE140000]                      mov byte [block_states + rcx], dl
  1577 00000D80 48FFC1                              inc rcx
  1578 00000D83 EBE2                                jmp .init_loop3
  1579                                  
  1580                                      .level4:
  1581 00000D85 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1582 00000D8C 4831C9                          xor rcx, rcx             
  1583                                          .init_loop4:
  1584 00000D8F 4883F901                            cmp rcx, level4_blocks_count
  1585 00000D93 7D40                                jge .done
  1586 00000D95 4889C8                              mov rax, rcx         
  1587 00000D98 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1588 00000D9C 8A90[D7140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1589 00000DA2 8891[DE140000]                      mov byte [block_states + rcx], dl
  1590 00000DA8 48FFC1                              inc rcx
  1591 00000DAB EBE2                                jmp .init_loop4
  1592                                  
  1593                                      .level5:
  1594 00000DAD C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1595 00000DB4 4831C9                          xor rcx, rcx             
  1596                                          .init_loop5:
  1597 00000DB7 4883F901                            cmp rcx, level5_blocks_count
  1598 00000DBB 7D18                                jge .done
  1599 00000DBD 4889C8                              mov rax, rcx         
  1600 00000DC0 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1601 00000DC4 8A90[DC140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1602 00000DCA 8891[DE140000]                      mov byte [block_states + rcx], dl
  1603 00000DD0 48FFC1                              inc rcx
  1604 00000DD3 EBE2                                jmp .init_loop5
  1605                                      .done:
  1606 00000DD5 C3                              ret
  1607                                  
  1608                                  
  1609                                  ; Función para verificar y manejar la transición de nivel
  1610                                  check_level_complete:
  1611                                      ; Verificar si quedan bloques
  1612 00000DD6 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1613 00000DDD 753C                        jne .not_complete
  1614                                      
  1615                                      ; Incrementar el nivel
  1616 00000DDF FE05(B4140000)              inc byte [current_level]
  1617                                      
  1618                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1619 00000DE5 803D(B4140000)06            cmp byte [current_level], 6
  1620 00000DEC 742E                        je game_win
  1621                                      
  1622                                      ; Reinicializar el juego para el siguiente nivel
  1623 00000DEE E844FEFFFF                  call init_level
  1624                                      
  1625                                      ; Reinicializar la posición de la bola y la paleta
  1626 00000DF3 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1626 00000DFB 000000             
  1627 00000DFE 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1627 00000E06 000000             
  1628 00000E09 C605(7F140000)00            mov byte [ball_moving], 0
  1629 00000E10 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1629 00000E17 [36130000]         
  1630                                      
  1631                                      .not_complete:
  1632 00000E1B C3                              ret
  1633                                  
  1634                                      ; Nueva función para manejar la victoria del juego
  1635                                  game_win:
  1636                                      ; Limpiar la pantalla primero
  1637                                      print clear, clear_length
    82 00000E1C B801000000          <1>  mov eax, sys_write
    83 00000E21 BF01000000          <1>  mov edi, 1
    84 00000E26 48BE-               <1>  mov rsi, %1
    84 00000E28 [1000000000000000]  <1>
    85 00000E30 BA07000000          <1>  mov edx, %2
    86 00000E35 0F05                <1>  syscall
  1638                                      
  1639                                      ; Mensaje de victoria
  1640 00000E37 488B05(42150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1641 00000E3E 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1641 00000E40 [4B15000000000000] 
  1642 00000E48 E8B4010000                  call number_to_string
  1643                                      
  1644                                      ; Definir mensaje de victoria
  1645                                      section .data
  1646 000018ED C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1646 000018F6 616465732120C2A148-
  1646 000018FF 61732067616E61646F-
  1646 00001908 210A0D             
  1647                                          win_msg_len: equ $ - win_msg
  1648 0000190B 50756E74616A652066-             score_msg: db "Puntaje final: "
  1648 00001914 696E616C3A20       
  1649                                          score_msg_len: equ $ - score_msg
  1650                                      section .text
  1651                                      
  1652                                      ; Imprimir mensajes
  1653                                      print win_msg, win_msg_len
    82 00000E4D B801000000          <1>  mov eax, sys_write
    83 00000E52 BF01000000          <1>  mov edi, 1
    84 00000E57 48BE-               <1>  mov rsi, %1
    84 00000E59 [ED18000000000000]  <1>
    85 00000E61 BA1E000000          <1>  mov edx, %2
    86 00000E66 0F05                <1>  syscall
  1654                                      print score_msg, score_msg_len
    82 00000E68 B801000000          <1>  mov eax, sys_write
    83 00000E6D BF01000000          <1>  mov edi, 1
    84 00000E72 48BE-               <1>  mov rsi, %1
    84 00000E74 [0B19000000000000]  <1>
    85 00000E7C BA0F000000          <1>  mov edx, %2
    86 00000E81 0F05                <1>  syscall
  1655                                      print number_buffer, 20
    82 00000E83 B801000000          <1>  mov eax, sys_write
    83 00000E88 BF01000000          <1>  mov edi, 1
    84 00000E8D 48BE-               <1>  mov rsi, %1
    84 00000E8F [4B15000000000000]  <1>
    85 00000E97 BA14000000          <1>  mov edx, %2
    86 00000E9C 0F05                <1>  syscall
  1656                                      
  1657                                      ; Esperar un momento antes de salir
  1658 00000E9E 48C70557F1FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1658 00000EA7 0000               
  1659 00000EA9 48C70554F1FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1659 00000EB2 0000               
  1660                                      sleeptime
    98 00000EB4 B823000000          <1>  mov eax, sys_nanosleep
    99 00000EB9 48BF-               <1>  mov rdi, timespec
    99 00000EBB [0000000000000000]  <1>
   100 00000EC3 31F6                <1>  xor esi, esi
   101 00000EC5 0F05                <1>  syscall
  1661                                      
  1662 00000EC7 E929090000                  jmp exit
  1663                                  
  1664                                  ; Función para imprimir los bloques
  1665                                  ; Función modificada para imprimir bloques
  1666                                  
  1667                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1668                                  get_current_level_blocks:
  1669 00000ECC 803D(B4140000)01            cmp byte [current_level], 1
  1670 00000ED3 7428                        je .level1
  1671 00000ED5 803D(B4140000)02            cmp byte [current_level], 2
  1672 00000EDC 7427                        je .level2
  1673 00000EDE 803D(B4140000)03            cmp byte [current_level], 3
  1674 00000EE5 7426                        je .level3
  1675 00000EE7 803D(B4140000)04            cmp byte [current_level], 4
  1676 00000EEE 7425                        je .level4
  1677 00000EF0 803D(B4140000)05            cmp byte [current_level], 5
  1678 00000EF7 7424                        je .level5
  1679                                      ; Si llegamos aquí, hay un error en el nivel
  1680 00000EF9 4831C0                      xor rax, rax
  1681 00000EFC C3                          ret
  1682                                  
  1683                                      .level1:
  1684 00000EFD 488D05(B6140000)                lea rax, [level1_blocks]
  1685 00000F04 C3                              ret
  1686                                      .level2:
  1687 00000F05 488D05(CA140000)                lea rax, [level2_blocks]
  1688 00000F0C C3                              ret
  1689                                      .level3:
  1690 00000F0D 488D05(CF140000)                lea rax, [level3_blocks]
  1691 00000F14 C3                              ret
  1692                                      .level4:
  1693 00000F15 488D05(D4140000)                lea rax, [level4_blocks]
  1694 00000F1C C3                              ret
  1695                                      .level5:
  1696 00000F1D 488D05(D9140000)                lea rax, [level5_blocks]
  1697 00000F24 C3                              ret
  1698                                  ; Función para obtener la cantidad de bloques del nivel actual
  1699                                  get_current_level_count:
  1700 00000F25 803D(B4140000)01            cmp byte [current_level], 1
  1701 00000F2C 7428                        je .level1
  1702 00000F2E 803D(B4140000)02            cmp byte [current_level], 2
  1703 00000F35 7425                        je .level2
  1704 00000F37 803D(B4140000)03            cmp byte [current_level], 3
  1705 00000F3E 7422                        je .level3
  1706 00000F40 803D(B4140000)04            cmp byte [current_level], 4
  1707 00000F47 741F                        je .level4
  1708 00000F49 803D(B4140000)05            cmp byte [current_level], 5
  1709 00000F50 741C                        je .level5
  1710                                      ; Si llegamos aquí, hay un error en el nivel
  1711 00000F52 4831C0                      xor rax, rax
  1712 00000F55 C3                          ret
  1713                                  
  1714                                      .level1:
  1715 00000F56 B804000000                      mov rax, level1_blocks_count
  1716 00000F5B C3                              ret
  1717                                      .level2:
  1718 00000F5C B801000000                      mov rax, level2_blocks_count
  1719 00000F61 C3                              ret
  1720                                      .level3:
  1721 00000F62 B801000000                      mov rax, level3_blocks_count
  1722 00000F67 C3                              ret
  1723                                      .level4:
  1724 00000F68 B801000000                      mov rax, level4_blocks_count
  1725 00000F6D C3                              ret
  1726                                      .level5:
  1727 00000F6E B801000000                      mov rax, level5_blocks_count
  1728 00000F73 C3                              ret
  1729                                  
  1730                                  
  1731                                  print_blocks:
  1732 00000F74 55                          push rbp
  1733 00000F75 4889E5                      mov rbp, rsp
  1734                                      
  1735                                      ; Obtener puntero a los bloques del nivel actual
  1736 00000F78 E84FFFFFFF                  call get_current_level_blocks
  1737 00000F7D 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1738                                      
  1739                                      ; Obtener cantidad de bloques del nivel actual
  1740 00000F80 E8A0FFFFFF                  call get_current_level_count
  1741 00000F85 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1742                                      
  1743 00000F88 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1744                                      
  1745                                      .print_loop:
  1746 00000F8B 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1747 00000F8E 7D6F                            jge .end
  1748                                          
  1749                                          ; Verificar si el bloque está activo
  1750 00000F90 490FB68424-                     movzx rax, byte [block_states + r12]
  1750 00000F95 [DE140000]         
  1751 00000F99 4885C0                          test rax, rax
  1752 00000F9C 745C                            jz .next_block
  1753                                          
  1754                                          ; Obtener posición y tipo del bloque usando r13
  1755 00000F9E 4C89E0                          mov rax, r12
  1756 00000FA1 486BC005                        imul rax, 5
  1757 00000FA5 4C01E8                          add rax, r13
  1758 00000FA8 448A00                          mov r8b, [rax]        ; X position
  1759 00000FAB 448A4801                        mov r9b, [rax + 1]    ; Y position
  1760 00000FAF 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1761                                  
  1762                                          ; El resto de la lógica de impresión permanece igual
  1763 00000FB3 4D0FB6C0                        movzx r8, r8b
  1764 00000FB7 4D0FB6C9                        movzx r9, r9b
  1765 00000FBB 4981C0[000A0000]                add r8, board
  1766 00000FC2 B850000000                      mov rax, column_cells + 2
  1767 00000FC7 49F7E1                          mul r9
  1768 00000FCA 4901C0                          add r8, rax
  1769                                          
  1770 00000FCD B906000000                      mov rcx, block_length
  1771 00000FD2 48BE-                           mov rsi, block_type_1
  1771 00000FD4 [9014000000000000] 
  1772 00000FDC 490FB6C2                        movzx rax, r10b
  1773 00000FE0 48FFC8                          dec rax
  1774 00000FE3 486BC006                        imul rax, block_length
  1775 00000FE7 4801C6                          add rsi, rax
  1776                                          
  1777                                      .print_block_chars:
  1778 00000FEA 8A06                            mov al, [rsi]
  1779 00000FEC 418800                          mov [r8], al
  1780 00000FEF 48FFC6                          inc rsi
  1781 00000FF2 49FFC0                          inc r8
  1782 00000FF5 48FFC9                          dec rcx
  1783 00000FF8 75F0                            jnz .print_block_chars
  1784                                          
  1785                                      .next_block:
  1786 00000FFA 49FFC4                          inc r12
  1787 00000FFD EB8C                            jmp .print_loop
  1788                                          
  1789                                      .end:
  1790 00000FFF 5D                              pop rbp
  1791 00001000 C3                              ret
  1792                                  
  1793                                  ; Función para convertir número a string
  1794                                  ; Input: RAX = número a convertir
  1795                                  ; RDI = buffer donde escribir el string
  1796                                  number_to_string:
  1797 00001001 53                          push rbx
  1798 00001002 52                          push rdx
  1799 00001003 56                          push rsi
  1800 00001004 BB0A000000                  mov rbx, 10          ; Divisor
  1801 00001009 B900000000                  mov rcx, 0          ; Contador de dígitos
  1802                                      
  1803                                      ; Si el número es 0, manejarlo especialmente
  1804 0000100E 4885C0                      test rax, rax
  1805 00001011 7509                        jnz .convert_loop
  1806 00001013 C60730                      mov byte [rdi], '0'
  1807 00001016 C6470100                    mov byte [rdi + 1], 0
  1808 0000101A EB20                        jmp .end
  1809                                      
  1810                                      .convert_loop:
  1811 0000101C 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1812 0000101F 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1813 00001022 80C230                          add dl, '0'     ; Convertir a ASCII
  1814 00001025 52                              push rdx        ; Guardar el dígito
  1815 00001026 48FFC1                          inc rcx         ; Incrementar contador
  1816 00001029 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1817 0000102C 75EE                            jnz .convert_loop
  1818                                          
  1819                                      .write_loop:
  1820 0000102E 5A                              pop rdx         ; Obtener dígito
  1821 0000102F 8817                            mov [rdi], dl   ; Escribir al buffer
  1822 00001031 48FFC7                          inc rdi         ; Siguiente posición
  1823 00001034 48FFC9                          dec rcx         ; Decrementar contador
  1824 00001037 75F5                            jnz .write_loop
  1825                                          
  1826 00001039 C60700                      mov byte [rdi], 0   ; Null terminator
  1827                                      
  1828                                      .end:
  1829 0000103C 5E                          pop rsi
  1830 0000103D 5A                          pop rdx
  1831 0000103E 5B                          pop rbx
  1832 0000103F C3                          ret
  1833                                  
  1834                                  ; Función para imprimir los labels
  1835                                  print_labels:
  1836 00001040 55                          push rbp
  1837 00001041 4889E5                      mov rbp, rsp
  1838                                  
  1839                                      ; Crear buffer temporal
  1840 00001044 4883EC20                    sub rsp, 32
  1841                                  
  1842                                      ; Copiar labels a buffer temporal
  1843 00001048 4889E7                      mov rdi, rsp
  1844 0000104B 488D35(F7150000)            lea rsi, [score_label]
  1845 00001052 B917000000                  mov rcx, score_label_len
  1846 00001057 F3A4                        rep movsb
  1847                                  
  1848                                      ; Convertir score a string
  1849 00001059 488B05(42150000)            mov rax, [current_score]
  1850 00001060 48BF-                       mov rdi, number_buffer
  1850 00001062 [4B15000000000000] 
  1851 0000106A E892FFFFFF                  call number_to_string
  1852                                  
  1853                                      ; Calcular longitud del número
  1854 0000106F B900000000                  mov rcx, 0
  1855 00001074 48BF-                       mov rdi, number_buffer
  1855 00001076 [4B15000000000000] 
  1856                                      .count_loop:
  1857 0000107E 803C0F00                        cmp byte [rdi + rcx], 0
  1858 00001082 7405                            je .count_done
  1859 00001084 48FFC1                          inc rcx
  1860 00001087 EBF5                            jmp .count_loop
  1861                                      .count_done:
  1862                                  
  1863                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1864 00001089 4889E7                      mov rdi, rsp
  1865 0000108C 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1866 00001090 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1867 00001095 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1868                                      .pad_loop:
  1869 00001098 4885F6                          test rsi, rsi
  1870 0000109B 740B                            jz .pad_done
  1871 0000109D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1872 000010A0 48FFC7                          inc rdi
  1873 000010A3 48FFCE                          dec rsi
  1874 000010A6 EBF0                            jmp .pad_loop
  1875                                      .pad_done:
  1876                                  
  1877                                      ; Copiar el número
  1878 000010A8 48BE-                       mov rsi, number_buffer
  1878 000010AA [4B15000000000000] 
  1879 000010B2 F3A4                        rep movsb
  1880                                  
  1881                                      ; Imprimir el buffer completo
  1882                                      print rsp, score_label_len
    82 000010B4 B801000000          <1>  mov eax, sys_write
    83 000010B9 BF01000000          <1>  mov edi, 1
    84 000010BE 4889E6              <1>  mov rsi, %1
    85 000010C1 BA17000000          <1>  mov edx, %2
    86 000010C6 0F05                <1>  syscall
  1883                                  
  1884                                      ; Repetir proceso para bloques destruidos
  1885 000010C8 4889E7                      mov rdi, rsp
  1886 000010CB 488D35(0E160000)            lea rsi, [blocks_label]
  1887 000010D2 B91B000000                  mov rcx, blocks_label_len
  1888 000010D7 F3A4                        rep movsb
  1889                                  
  1890                                      ; Verificar que el `[` esté en su posición correcta
  1891 000010D9 4889E7                      mov rdi, rsp
  1892 000010DC 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1893 000010E0 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1894                                  
  1895                                      ; Convertir bloques destruidos a string
  1896 000010E3 480FB605(4A150000)          movzx rax, byte [destroyed_blocks]
  1897 000010EB 48BF-                       mov rdi, number_buffer
  1897 000010ED [4B15000000000000] 
  1898 000010F5 E807FFFFFF                  call number_to_string
  1899                                  
  1900                                      ; Calcular longitud del número
  1901 000010FA B900000000                  mov rcx, 0
  1902 000010FF 48BF-                       mov rdi, number_buffer
  1902 00001101 [4B15000000000000] 
  1903                                      .count_loop2:
  1904 00001109 803C0F00                        cmp byte [rdi + rcx], 0
  1905 0000110D 7405                            je .count_done2
  1906 0000110F 48FFC1                          inc rcx
  1907 00001112 EBF5                            jmp .count_loop2
  1908                                      .count_done2:
  1909                                  
  1910                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1911 00001114 4889E7                      mov rdi, rsp
  1912 00001117 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1913 0000111B BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1914 00001120 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1915                                      .pad_loop2:
  1916 00001123 4885F6                          test rsi, rsi
  1917 00001126 740B                            jz .pad_done2
  1918 00001128 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1919 0000112B 48FFC7                          inc rdi
  1920 0000112E 48FFCE                          dec rsi
  1921 00001131 EBF0                            jmp .pad_loop2
  1922                                      .pad_done2:
  1923                                  
  1924                                      ; Copiar el número
  1925 00001133 48BE-                       mov rsi, number_buffer
  1925 00001135 [4B15000000000000] 
  1926 0000113D F3A4                        rep movsb
  1927                                  
  1928                                      ; Imprimir el buffer completo
  1929                                      print rsp, blocks_label_len
    82 0000113F B801000000          <1>  mov eax, sys_write
    83 00001144 BF01000000          <1>  mov edi, 1
    84 00001149 4889E6              <1>  mov rsi, %1
    85 0000114C BA1B000000          <1>  mov edx, %2
    86 00001151 0F05                <1>  syscall
  1930                                  
  1931                                      ; Restaurar stack
  1932 00001153 4883C420                    add rsp, 32
  1933 00001157 5D                          pop rbp
  1934 00001158 C3                          ret
  1935                                  
  1936                                  
  1937                                  
  1938                                  check_block_collision:
  1939 00001159 55                          push rbp
  1940 0000115A 4889E5                      mov rbp, rsp
  1941                                  
  1942                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1943 0000115D 418A02                      mov al, [r10]
  1944                                  
  1945                                      ; Verificar si el carácter es un bloque
  1946 00001160 3C55                        cmp al, 'U'  
  1947 00001162 7419                        je .possible
  1948 00001164 3C4F                        cmp al, 'O'  
  1949 00001166 7415                        je .possible
  1950 00001168 3C44                        cmp al, 'D'  
  1951 0000116A 7411                        je .possible
  1952 0000116C 3C4C                        cmp al, 'L'  
  1953 0000116E 740D                        je .possible
  1954 00001170 3C56                        cmp al, 'V'  
  1955 00001172 7409                        je .possible
  1956 00001174 3C38                        cmp al, '8'  
  1957 00001176 7405                        je .possible
  1958                                  
  1959                                      ; No es bloque, salir
  1960 00001178 4831C0                      xor rax, rax
  1961 0000117B 5D                          pop rbp
  1962 0000117C C3                          ret
  1963                                  
  1964                                  .possible:
  1965 0000117D 53                          push rbx
  1966 0000117E 57                          push rdi
  1967 0000117F 56                          push rsi
  1968 00001180 4154                        push r12
  1969 00001182 4155                        push r13
  1970 00001184 4156                        push r14
  1971 00001186 4157                        push r15
  1972                                  
  1973                                      ; 1) Obtener base de los bloques del nivel actual
  1974 00001188 E83FFDFFFF                  call get_current_level_blocks
  1975 0000118D 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1976                                  
  1977                                      ; 2) Obtener la cantidad de bloques
  1978 00001190 E890FDFFFF                  call get_current_level_count
  1979 00001195 4989C6                      mov r14, rax
  1980                                  
  1981 00001198 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1982                                  
  1983                                  .find_block_loop:
  1984 0000119B 4D39F4                      cmp r12, r14
  1985 0000119E 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1986                                  
  1987                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1988 000011A4 4C89E0                      mov rax, r12
  1989 000011A7 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1990 000011AB 4C01E8                      add rax, r13
  1991 000011AE 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1992                                  
  1993                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1994 000011B1 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1994 000011B6 [DE140000]         
  1995 000011BA 4885DB                      test rbx, rbx
  1996 000011BD 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1997                                  
  1998                                      ; Obtener coordenadas
  1999 000011C3 418A17                      mov dl, [r15]         ; x
  2000 000011C6 418A4F01                    mov cl, [r15 + 1]     ; y
  2001                                  
  2002                                      ; Calcular posición en el board
  2003 000011CA 488D3D(000A0000)            lea rdi, [board]
  2004 000011D1 4831C0                      xor rax, rax
  2005 000011D4 B84E000000                  mov rax, column_cells
  2006 000011D9 4883C002                    add rax, 2
  2007 000011DD 480FB6C9                    movzx rcx, cl         ; y
  2008 000011E1 480FAFC1                    imul rax, rcx
  2009 000011E5 4801C7                      add rdi, rax
  2010 000011E8 480FB6C2                    movzx rax, dl         ; x
  2011 000011EC 4801C7                      add rdi, rax
  2012                                  
  2013                                      ; Guardar la posición base del bloque
  2014 000011EF 57                          push rdi
  2015                                  
  2016                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2017 000011F0 4939FA                      cmp r10, rdi
  2018 000011F3 7274                        jb .skip_collision
  2019 000011F5 488D5F06                    lea rbx, [rdi + block_length]
  2020 000011F9 4939DA                      cmp r10, rbx
  2021 000011FC 736B                        jae .skip_collision
  2022                                  
  2023                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2024 000011FE 41FE8C24[DE140000]          dec byte [block_states + r12]
  2025                                      ; Volver a cargar durabilidad
  2026 00001206 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2026 0000120B [DE140000]         
  2027 0000120F 4885DB                      test rbx, rbx
  2028 00001212 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2029                                  
  2030                                      ; >>> Llegó a 0 => Bloque destruido
  2031 00001214 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2032 00001215 B906000000                  mov rcx, block_length
  2033                                  .clear_loop:
  2034 0000121A C60720                      mov byte [rdi], ' '
  2035 0000121D 48FFC7                      inc rdi
  2036 00001220 E2F8                        loop .clear_loop
  2037                                  
  2038                                      ; Dibujar letra del bloque destruido
  2039 00001222 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2040 00001226 4883EF06                    sub rdi, block_length
  2041 0000122A 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2042                                      ; Después de escribir la letra en el tablero
  2043 0000122C 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2044 00001230 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2045 00001234 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2046 00001239 E868F1FFFF                  call register_letter
  2047                                      ; Actualizar contadores globales
  2048 0000123E FE0D(B5140000)              dec byte [blocks_remaining]
  2049 00001244 FE05(4A150000)              inc byte [destroyed_blocks]
  2050                                  
  2051                                      ; Sumar puntos según el tipo
  2052 0000124A 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2053 0000124F 486BC00A                    imul rax, 10
  2054 00001253 480105(42150000)            add [current_score], rax
  2055                                  
  2056 0000125A B801000000                  mov rax, 1  ; colisión con destrucción
  2057 0000125F EB14                        jmp .end_pop
  2058                                  
  2059                                  .update_display:
  2060                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2061 00001261 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2062 00001266 5F                          pop rdi     ; pop que quedó pendiente
  2063 00001267 EB0C                        jmp .end_pop
  2064                                  
  2065                                  .skip_collision:
  2066 00001269 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2067                                  .next_block:
  2068 0000126A 49FFC4                      inc r12
  2069 0000126D E929FFFFFF                  jmp .find_block_loop
  2070                                  
  2071                                  .no_block_found:
  2072 00001272 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2073                                  
  2074                                  .end_pop:
  2075 00001275 415F                        pop r15
  2076 00001277 415E                        pop r14
  2077 00001279 415D                        pop r13
  2078 0000127B 415C                        pop r12
  2079 0000127D 5E                          pop rsi
  2080 0000127E 5F                          pop rdi
  2081 0000127F 5B                          pop rbx
  2082 00001280 5D                          pop rbp
  2083 00001281 C3                          ret
  2084                                  
  2085                                  
  2086                                  
  2087                                  init_enemies:
  2088 00001282 55                          push rbp
  2089 00001283 4889E5                      mov rbp, rsp
  2090                                      ; Reiniciar contadores de movimiento
  2091 00001286 C605(8D150000)00            mov byte [enemy_move_total], 0
  2092 0000128D C605(8E150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2093                                      ; Limpiar estado previo de enemigos
  2094 00001294 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2095 00001299 488D3D(64150000)            lea rdi, [enemies]
  2096 000012A0 30C0                        xor al, al
  2097 000012A2 F3AA                        rep stosb ; Limpiar datos de enemigos
  2098                                      
  2099                                      ; Marcar todos los enemigos como inactivos
  2100 000012A4 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  2101 000012AB 30C0                        xor al, al
  2102 000012AD B90A000000                  mov rcx, 10
  2103 000012B2 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2104                                  
  2105 000012B4 5D                          pop rbp
  2106 000012B5 C3                          ret
  2107                                  
  2108                                  
  2109                                  ; Función para mover enemigos
  2110                                  move_enemies:
  2111 000012B6 55                          push rbp
  2112 000012B7 4889E5                      mov rbp, rsp
  2113                                      
  2114                                      ; Incrementar contador de movimiento
  2115 000012BA FE05(8B150000)              inc byte [enemy_move_counter]
  2116 000012C0 480FB605(8B150000)          movzx rax, byte [enemy_move_counter]
  2117 000012C8 3A05(8C150000)              cmp al, [enemy_move_delay]
  2118 000012CE 0F85AA010000                jne .end
  2119                                      
  2120                                      ; Resetear contador
  2121 000012D4 C605(8B150000)00            mov byte [enemy_move_counter], 0
  2122                                      
  2123 000012DB 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2124                                      
  2125                                      .enemy_loop:
  2126 000012DE 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2127 000012E2 0F8D96010000                    jge .end
  2128                                          
  2129                                          ; Calcular offset del enemigo actual
  2130 000012E8 4C89E0                          mov rax, r12
  2131 000012EB 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2132 000012EF 488DB0[64150000]                lea rsi, [enemies + rax]
  2133                                          
  2134                                          ; Verificar si el enemigo está activo
  2135 000012F6 807E0201                        cmp byte [rsi + 2], 1
  2136 000012FA 0F8576010000                    jne .next_enemy
  2137                                          
  2138                                          ; Obtener posición actual
  2139 00001300 4C0FB606                        movzx r8, byte [rsi]            ; X
  2140 00001304 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2141                                          
  2142                                          ; Limpiar posición actual antes de mover
  2143 00001309 4150                            push r8
  2144 0000130B 4151                            push r9
  2145 0000130D B84E000000                      mov rax, column_cells
  2146 00001312 4883C002                        add rax, 2
  2147 00001316 49F7E1                          mul r9
  2148 00001319 4C01C0                          add rax, r8
  2149 0000131C 488DB8[000A0000]                lea rdi, [board + rax]
  2150 00001323 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2151 00001326 4159                            pop r9
  2152 00001328 4158                            pop r8
  2153                                  
  2154                                          ; Determinar comportamiento basado en índice
  2155 0000132A 4C89E0                          mov rax, r12
  2156 0000132D 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2157 00001331 4885C0                          test rax, rax
  2158 00001334 7402                            jz .chase_ball
  2159 00001336 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2160                                          
  2161                                          ; Perseguir bola (comportamiento original)
  2162                                      .chase_ball:
  2163 00001338 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2164 0000133F 4D39D0                          cmp r8, r10
  2165 00001342 0F8F96000000                    jg .move_left
  2166 00001348 0F8C95000000                    jl .move_right
  2167                                          
  2168 0000134E 4C8B15(67140000)                mov r10, [ball_y_pos]
  2169 00001355 4D39D1                          cmp r9, r10
  2170 00001358 0F8F8A000000                    jg .move_up
  2171 0000135E 0F8C89000000                    jl .move_down
  2172 00001364 E9A5000000                      jmp .check_collision
  2173                                          
  2174                                      .chase_paddle:
  2175                                          ; Obtener la posición X actual de la paleta
  2176 00001369 4C8B15(3F140000)                mov r10, [pallet_position]
  2177 00001370 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2178                                          
  2179                                          ; Calcular la posición X real de la paleta
  2180 00001377 4C89D0                          mov rax, r10
  2181 0000137A BB4E000000                      mov rbx, column_cells
  2182 0000137F 4883C302                        add rbx, 2                  ; Añadir newline chars
  2183 00001383 4831D2                          xor rdx, rdx
  2184 00001386 48F7F3                          div rbx                     ; rax = y, rdx = x
  2185                                          
  2186                                          ; rdx ahora contiene la posición X de la paleta
  2187                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2188 00001389 488B0D(47140000)                mov rcx, [pallet_size]
  2189 00001390 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2190 00001393 4801CA                          add rdx, rcx
  2191                                          
  2192                                          ; Comparar con posición X del enemigo y mover gradualmente
  2193 00001396 4939D0                          cmp r8, rdx
  2194 00001399 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2195 0000139B 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2196 0000139D 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2197                                  
  2198                                      .check_y_paddle:
  2199                                          ; La Y de la paleta siempre es row_cells - 2
  2200 0000139F 41BA20000000                    mov r10, row_cells
  2201 000013A5 4983EA02                        sub r10, 2
  2202                                          
  2203                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2204 000013A9 4D39D1                          cmp r9, r10
  2205 000013AC 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2206 000013AE 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2207 000013B0 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2208                                          
  2209                                      .no_movement:
  2210 000013B2 EB5A                            jmp .check_collision
  2211                                  
  2212                                      ; También agregar una nueva sección para el movimiento suave
  2213                                      .smooth_transition:
  2214                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2215 000013B4 8A05(8E150000)                  mov al, [enemy_target]
  2216 000013BA 84C0                            test al, al
  2217 000013BC 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2218                                          
  2219                                          ; Verificar distancia en X
  2220 000013BE 4989D2                          mov r10, rdx              ; Posición X objetivo
  2221 000013C1 4D29C2                          sub r10, r8               ; Calcular diferencia
  2222 000013C4 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2223 000013C8 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2224 000013CA 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2225 000013CE 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2226 000013D0 EB3C                            jmp .check_collision
  2227                                          
  2228                                      .limit_right_movement:
  2229 000013D2 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2230 000013D6 EB36                            jmp .check_collision
  2231                                          
  2232                                      .limit_left_movement:
  2233 000013D8 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2234 000013DC EB30                            jmp .check_collision
  2235                                      .move_left:
  2236 000013DE 49FFC8                          dec r8
  2237 000013E1 EB0F                            jmp .check_vertical
  2238                                          
  2239                                      .move_right:
  2240 000013E3 49FFC0                          inc r8
  2241 000013E6 EB0A                            jmp .check_vertical
  2242                                          
  2243                                      .move_up:
  2244 000013E8 49FFC9                          dec r9
  2245 000013EB EB21                            jmp .check_collision
  2246                                          
  2247                                      .move_down:
  2248 000013ED 49FFC1                          inc r9
  2249 000013F0 EB1C                            jmp .check_collision
  2250                                          
  2251                                      .check_vertical:
  2252 000013F2 8A05(8E150000)                  mov al, [enemy_target]
  2253 000013F8 84C0                            test al, al
  2254 000013FA 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2255 00001400 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2256 00001407 4D39D1                          cmp r9, r10
  2257 0000140A 7FDC                            jg .move_up
  2258 0000140C 7CDF                            jl .move_down
  2259                                          
  2260                                      .check_collision:
  2261                                          ; Verificar colisión con bordes
  2262 0000140E 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2263 00001412 7E62                            jle .next_enemy
  2264 00001414 4983F84E                        cmp r8, column_cells
  2265 00001418 7D5C                            jge .next_enemy
  2266 0000141A 4983F901                        cmp r9, 1                       ; Borde superior
  2267 0000141E 7E56                            jle .next_enemy
  2268 00001420 4983F920                        cmp r9, row_cells
  2269 00001424 7D50                            jge .next_enemy
  2270                                          
  2271                                          ; Verificar colisión con bloques antes de moverse
  2272 00001426 4150                            push r8
  2273 00001428 4151                            push r9
  2274 0000142A 4152                            push r10
  2275                                          
  2276                                          ; Calcular posición en el tablero para verificar
  2277 0000142C B84E000000                      mov rax, column_cells
  2278 00001431 4883C002                        add rax, 2
  2279 00001435 49F7E1                          mul r9
  2280 00001438 4C01C0                          add rax, r8
  2281 0000143B 4C8D90[000A0000]                lea r10, [board + rax]
  2282                                          
  2283                                          ; Verificar si hay un bloque en la nueva posición
  2284 00001442 418A02                          mov al, [r10]
  2285 00001445 3C55                            cmp al, 'U'
  2286 00001447 7427                            je .invalid_move
  2287 00001449 3C4F                            cmp al, 'O'
  2288 0000144B 7423                            je .invalid_move
  2289 0000144D 3C44                            cmp al, 'D'
  2290 0000144F 741F                            je .invalid_move
  2291 00001451 3C4C                            cmp al, 'L'
  2292 00001453 741B                            je .invalid_move
  2293 00001455 3C56                            cmp al, 'V'
  2294 00001457 7417                            je .invalid_move
  2295 00001459 3C38                            cmp al, '8'
  2296 0000145B 7413                            je .invalid_move
  2297 0000145D 3C58                            cmp al, 'X'
  2298 0000145F 740F                            je .invalid_move
  2299                                          
  2300 00001461 415A                            pop r10
  2301 00001463 4159                            pop r9
  2302 00001465 4158                            pop r8
  2303                                          
  2304                                          ; Guardar nueva posición si es válida
  2305 00001467 448806                          mov [rsi], r8b
  2306 0000146A 44884E01                        mov [rsi + 1], r9b
  2307 0000146E EB06                            jmp .next_enemy
  2308                                          
  2309                                      .invalid_move:
  2310 00001470 415A                            pop r10
  2311 00001472 4159                            pop r9
  2312 00001474 4158                            pop r8
  2313                                          
  2314                                      .next_enemy:
  2315 00001476 49FFC4                          inc r12
  2316 00001479 E960FEFFFF                      jmp .enemy_loop
  2317                                          
  2318                                      .end:
  2319 0000147E 5D                              pop rbp
  2320 0000147F C3                              ret
  2321                                  
  2322                                  get_current_spawn_points:
  2323 00001480 55                          push rbp
  2324 00001481 4889E5                      mov rbp, rsp
  2325                                      
  2326 00001484 480FB605(B4140000)          movzx rax, byte [current_level]
  2327 0000148C 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2328 0000148F 488B04C5[C2150000]          mov rax, [spawn_points_table + rax * 8]
  2329                                      
  2330 00001497 5D                          pop rbp
  2331 00001498 C3                          ret
  2332                                  
  2333                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2334                                  check_enemy_spawn:
  2335 00001499 55                          push rbp
  2336 0000149A 4889E5                      mov rbp, rsp
  2337                                      
  2338                                      ; Obtener spawn points del nivel actual
  2339 0000149D E8DEFFFFFF                  call get_current_spawn_points
  2340 000014A2 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2341                                      
  2342                                      ; Obtener cantidad de bloques destruidos
  2343 000014A5 4C0FB62D(4A150000)          movzx r13, byte [destroyed_blocks]
  2344                                      
  2345                                      ; Verificar cada punto de spawn
  2346 000014AD 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2347                                      
  2348                                      .check_loop:
  2349 000014B0 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2350 000014B4 7D4B                            jge .end
  2351                                          
  2352                                          ; Verificar si este spawn point ya fue usado
  2353 000014B6 80B9[ED150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2354 000014BD 743D                            je .next_enemy
  2355                                          
  2356                                          ; Verificar si este enemigo ya está activo
  2357 000014BF 4889C8                          mov rax, rcx
  2358 000014C2 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2359 000014C6 488DB0[64150000]                lea rsi, [enemies + rax]
  2360 000014CD 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2361 000014D1 7429                            je .next_enemy
  2362                                          
  2363                                          ; Verificar si debemos spawnear este enemigo
  2364 000014D3 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2365 000014D8 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2366 000014DB 751F                            jne .next_enemy
  2367                                          
  2368                                          ; Marcar este spawn point como usado
  2369 000014DD C681[ED150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2370                                          
  2371                                          ; Spawner nuevo enemigo
  2372 000014E4 C60628                          mov byte [rsi], 40             ; X inicial
  2373 000014E7 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2374 000014EB C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2375                                          
  2376                                          ; Inicializar comportamiento
  2377 000014EF 4889C8                          mov rax, rcx
  2378 000014F2 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2379 000014F6 8805(EC150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2380                                          
  2381                                      .next_enemy:
  2382 000014FC 48FFC1                          inc rcx
  2383 000014FF EBAF                            jmp .check_loop
  2384                                          
  2385                                      .end:
  2386 00001501 5D                              pop rbp
  2387 00001502 C3                              ret
  2388                                  
  2389                                  
  2390                                  ; Función para dibujar enemigos
  2391                                  print_enemies:
  2392 00001503 55                          push rbp
  2393 00001504 4889E5                      mov rbp, rsp
  2394                                      
  2395 00001507 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2396                                      
  2397                                      .print_loop:
  2398 0000150A 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2399 0000150E 7D4B                            jge .end
  2400                                          
  2401                                          ; Calcular offset del enemigo actual
  2402 00001510 4C89E0                          mov rax, r12
  2403 00001513 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2404 00001517 488DB0[64150000]                lea rsi, [enemies + rax]
  2405                                          
  2406                                          ; Verificar si el enemigo está activo
  2407 0000151E 807E0201                        cmp byte [rsi + 2], 1
  2408 00001522 7532                            jne .next_enemy
  2409                                          
  2410                                          ; Calcular posición en el tablero
  2411 00001524 4C0FB606                        movzx r8, byte [rsi]            ; X
  2412 00001528 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2413                                          
  2414                                          ; Calcular offset en el tablero
  2415 0000152D B84E000000                      mov rax, column_cells
  2416 00001532 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2417 00001536 49F7E1                          mul r9
  2418 00001539 4C01C0                          add rax, r8
  2419 0000153C 488DB8[000A0000]                lea rdi, [board + rax]
  2420                                          
  2421                                          ; Obtener carácter del enemigo según el nivel
  2422 00001543 480FB605(B4140000)              movzx rax, byte [current_level]
  2423 0000154B 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2424 0000154E 8A80[5F150000]                  mov al, [enemy_chars + rax]
  2425                                          
  2426                                          ; Dibujar enemigo
  2427 00001554 8807                            mov [rdi], al
  2428                                          
  2429                                      .next_enemy:
  2430 00001556 49FFC4                          inc r12
  2431 00001559 EBAF                            jmp .print_loop
  2432                                          
  2433                                      .end:
  2434 0000155B 5D                              pop rbp
  2435 0000155C C3                              ret
  2436                                  
  2437                                  ; Función para verificar colisión con enemigos
  2438                                  ; Función para verificar colisión con enemigos
  2439                                  check_enemy_collision:
  2440 0000155D 55                          push rbp
  2441 0000155E 4889E5                      mov rbp, rsp
  2442                                      
  2443 00001561 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2444 00001564 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2445                                      
  2446                                      .check_loop:
  2447 00001567 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2448 0000156B 0F8DE9000000                    jge .end
  2449                                          
  2450                                          ; Calcular offset del enemigo actual
  2451 00001571 4C89E1                          mov rcx, r12
  2452 00001574 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2453 00001578 488DB1[64150000]                lea rsi, [enemies + rcx]
  2454                                          
  2455                                          ; Verificar si el enemigo está activo
  2456 0000157F 807E0201                        cmp byte [rsi + 2], 1
  2457 00001583 0F85C9000000                    jne .next_enemy
  2458                                          
  2459                                          ; Verificar colisión con la bola
  2460 00001589 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2461 0000158D 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2462                                          
  2463                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2464 00001592 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2465 00001599 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2466                                          
  2467                                          ; Comprobar colisión vertical (misma columna)
  2468 000015A0 4D39C2                          cmp r10, r8
  2469 000015A3 7525                            jne .check_horizontal
  2470 000015A5 4D29CB                          sub r11, r9
  2471 000015A8 4983FB01                        cmp r11, 1
  2472 000015AC 7F1C                            jg .check_horizontal
  2473 000015AE 4983FBFF                        cmp r11, -1
  2474 000015B2 7C16                            jl .check_horizontal
  2475                                          
  2476                                          ; Colisión vertical detectada
  2477 000015B4 E8A3000000                      call destroy_enemy
  2478 000015B9 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2479 000015C0 B801000000                      mov rax, 1
  2480 000015C5 E990000000                      jmp .end
  2481                                          
  2482                                      .check_horizontal:
  2483                                          ; Comprobar colisión horizontal (misma fila)
  2484 000015CA 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2485 000015D1 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2486 000015D8 4D39CB                          cmp r11, r9
  2487 000015DB 7522                            jne .check_paddle
  2488 000015DD 4D29C2                          sub r10, r8
  2489 000015E0 4983FA01                        cmp r10, 1
  2490 000015E4 7F19                            jg .check_paddle
  2491 000015E6 4983FAFF                        cmp r10, -1
  2492 000015EA 7C13                            jl .check_paddle
  2493                                          
  2494                                          ; Colisión horizontal detectada
  2495 000015EC E86B000000                      call destroy_enemy
  2496 000015F1 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2497 000015F8 B801000000                      mov rax, 1
  2498 000015FD EB5B                            jmp .end
  2499                                          
  2500                                      .check_paddle:
  2501                                          ; Verificar colisión con la paleta
  2502 000015FF 4C8B15(3F140000)                mov r10, [pallet_position]
  2503 00001606 4981EA[000A0000]                sub r10, board
  2504 0000160D 4C89D0                          mov rax, r10
  2505 00001610 41BB4E000000                    mov r11, column_cells
  2506 00001616 4983C302                        add r11, 2
  2507 0000161A 4831D2                          xor rdx, rdx
  2508 0000161D 49F7F3                          div r11                     ; División para obtener la posición Y
  2509 00001620 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2510                                          
  2511 00001623 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2512                                          
  2513                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2514 0000162A 41BD20000000                    mov r13, row_cells
  2515 00001630 4983ED02                        sub r13, 2                 ; Y de la paleta
  2516 00001634 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2517 00001637 7519                            jne .next_enemy
  2518                                          
  2519                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2520 00001639 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2521 0000163C 7C14                            jl .next_enemy
  2522                                          
  2523 0000163E 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2524 00001641 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2525 00001644 7F0C                            jg .next_enemy
  2526                                          
  2527                                          ; Si llegamos aquí, hay colisión con la paleta
  2528 00001646 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2529 0000164B B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2530 00001650 EB08                            jmp .end
  2531                                          
  2532                                      .next_enemy:
  2533 00001652 49FFC4                          inc r12
  2534 00001655 E90DFFFFFF                      jmp .check_loop
  2535                                          
  2536                                      .end:
  2537 0000165A 5D                              pop rbp
  2538 0000165B C3                              ret
  2539                                  
  2540                                  ; Función para destruir un enemigo
  2541                                  destroy_enemy:
  2542                                      ; Desactivar enemigo
  2543 0000165C C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2544                                  
  2545                                      ; Sumar puntos por destruir enemigo
  2546 00001660 488B05(83150000)            mov rax, [enemy_points]
  2547 00001667 480105(42150000)            add [current_score], rax
  2548                                  
  2549                                      ; No tocar bloques destruidos aquí
  2550 0000166E C3                          ret
  2551                                  
  2552                                  
  2553                                  _start:
  2554 0000166F E8B7EAFFFF              	call canonical_off
  2555 00001674 E809010000              	call start_screen
  2556 00001679 E8B9F5FFFF                  call init_level
  2557 0000167E E8FFFBFFFF                  call init_enemies
  2558 00001683 EB00                    	jmp .main_loop
  2559                                  	
  2560                                  
  2561                                  	.main_loop:
  2562 00001685 E8B6F9FFFF                      call print_labels
  2563 0000168A E8E5F8FFFF                      call print_blocks
  2564 0000168F E8E3EDFFFF                      call move_letters
  2565 00001694 E8F6EFFFFF                      call update_lasers
  2566 00001699 E84EEDFFFF                      call print_letters
  2567 0000169E E8E5F1FFFF              		call print_pallet
  2568 000016A3 E8C8F2FFFF                      call move_ball
  2569 000016A8 E831ECFFFF                      call check_bottom_collision
  2570 000016AD E82BEBFFFF                      call print_lives
  2571 000016B2 E81FF7FFFF                      call check_level_complete
  2572 000016B7 E8DDFDFFFF                      call check_enemy_spawn
  2573 000016BC E8F5FBFFFF                      call move_enemies
  2574 000016C1 E897FEFFFF                      call check_enemy_collision
  2575 000016C6 E838FEFFFF                      call print_enemies
  2576 000016CB E890F1FFFF              		call print_ball
  2577                                  		print board, board_size				
    82 000016D0 B801000000          <1>  mov eax, sys_write
    83 000016D5 BF01000000          <1>  mov edi, 1
    84 000016DA 48BE-               <1>  mov rsi, %1
    84 000016DC [000A000000000000]  <1>
    85 000016E4 BA000A0000          <1>  mov edx, %2
    86 000016E9 0F05                <1>  syscall
  2578                                  		;setnonblocking	
  2579                                  	.read_more:	
  2580                                  	    getchar	
    90 000016EB B800000000          <1>  mov rax, sys_read
    91 000016F0 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000016F5 48BE-               <1>  mov rsi, input_char
    92 000016F7 [0000000000000000]  <1>
    93 000016FF BA01000000          <1>  mov rdx, 1
    94 00001704 0F05                <1>  syscall
  2581 00001706 4883F801                	    cmp rax, 1
  2582 0000170A 7543                    	    jne .done
  2583                                  	
  2584 0000170C 8A05(00000000)          	    mov al, [input_char]
  2585 00001712 8805(09180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2586                                  	
  2587 00001718 3C61                    	    cmp al, 'a'
  2588 0000171A 750E                    	    jne .not_left
  2589 0000171C 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2590 00001723 E895F1FFFF              	    call move_pallet
  2591 00001728 EB25                    	    jmp .done
  2592                                  	
  2593                                      .not_left:
  2594 0000172A 3C64                    	    cmp al, 'd'
  2595 0000172C 750C                    	    jne .not_right
  2596 0000172E BF01000000              	    mov rdi, right_direction
  2597 00001733 E885F1FFFF              	    call move_pallet
  2598 00001738 EB15                    	    jmp .done
  2599                                  	
  2600                                      .not_right:
  2601 0000173A 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2602 0000173C 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2603                                  	
  2604 0000173E 3C71                    	    cmp al, 'q' 
  2605 00001740 0F84AF000000            	    je exit
  2606 00001746 EBA3                    	    jmp .read_more
  2607                                  	
  2608                                      .release_ball:
  2609 00001748 E8F6F3FFFF              	    call process_catch_release
  2610 0000174D EB00                    	    jmp .done
  2611                                  	
  2612                                      .done:
  2613                                  	    sleeptime
    98 0000174F B823000000          <1>  mov eax, sys_nanosleep
    99 00001754 48BF-               <1>  mov rdi, timespec
    99 00001756 [0000000000000000]  <1>
   100 0000175E 31F6                <1>  xor esi, esi
   101 00001760 0F05                <1>  syscall
  2614                                  	    print clear, clear_length
    82 00001762 B801000000          <1>  mov eax, sys_write
    83 00001767 BF01000000          <1>  mov edi, 1
    84 0000176C 48BE-               <1>  mov rsi, %1
    84 0000176E [1000000000000000]  <1>
    85 00001776 BA07000000          <1>  mov edx, %2
    86 0000177B 0F05                <1>  syscall
  2615 0000177D E903FFFFFF              	    jmp .main_loop
  2616                                  
  2617                                  
  2618                                  
  2619                                  
  2620                                  start_screen:
  2621                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001782 B801000000          <1>  mov eax, sys_write
    83 00001787 BF01000000          <1>  mov edi, 1
    84 0000178C 48BE-               <1>  mov rsi, %1
    84 0000178E [1000000000000000]  <1>
    85 00001796 BA07000000          <1>  mov edx, %2
    86 0000179B 0F05                <1>  syscall
  2622                                      print msg1, msg1_length
    82 0000179D B801000000          <1>  mov eax, sys_write
    83 000017A2 BF01000000          <1>  mov edi, 1
    84 000017A7 48BE-               <1>  mov rsi, %1
    84 000017A9 [1700000000000000]  <1>
    85 000017B1 BA14010000          <1>  mov edx, %2
    86 000017B6 0F05                <1>  syscall
  2623                                      
  2624                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2625                                          getchar                 ; Esperamos una tecla
    90 000017B8 B800000000          <1>  mov rax, sys_read
    91 000017BD BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000017C2 48BE-               <1>  mov rsi, input_char
    92 000017C4 [0000000000000000]  <1>
    93 000017CC BA01000000          <1>  mov rdx, 1
    94 000017D1 0F05                <1>  syscall
  2626 000017D3 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2627 000017D7 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2628                                          
  2629                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000017D9 B801000000          <1>  mov eax, sys_write
    83 000017DE BF01000000          <1>  mov edi, 1
    84 000017E3 48BE-               <1>  mov rsi, %1
    84 000017E5 [1000000000000000]  <1>
    85 000017ED BA07000000          <1>  mov edx, %2
    86 000017F2 0F05                <1>  syscall
  2630 000017F4 C3                          ret
  2631                                  
  2632                                  exit: 
  2633 000017F5 E873E9FFFF              	call canonical_on
  2634 000017FA B83C000000              	mov    rax, 60
  2635 000017FF BF00000000                  mov    rdi, 0
  2636 00001804 0F05                        syscall
  2637                                  
