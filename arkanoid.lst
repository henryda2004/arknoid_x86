     1                                  bits 64;codigo destinado a arcquitectura de 64 bits
     2                                  default rel;configura el uso de direcciones relativas, que son mas flecibles
     3                                  
     4                                  
     5                                  ;RAX: Registro acumulador. Se utiliza generalmente para operaciones aritméticas y como valor de retorno de funciones.
     6                                  ;RBX: Registro base. Generalmente preservado entre llamadas a funciones.
     7                                  ;RCX: Contador. Usado en operaciones de repetición y bucles.
     8                                  ;RDX: Registro de datos. Se usa en operaciones aritméticas complejas y como argumento adicional en llamadas a funciones.
     9                                  ;RDI y RSI: Usados para pasar parámetros en las llamadas a funciones. RDI es el primer argumento, RSI el segundo.
    10                                  ;RBP: Registro base del marco de pila. Usado para rastrear la base del stack frame en funciones.
    11                                  ;RSP: Puntero de pila. Rastrea el tope de la pila.
    12                                  ;R8-R15: Registros adicionales introducidos en x86-64 para proporcionar más flexibilidad.
    13                                  
    14                                  
    15                                  
    16                                  ; definiciones de llamadas al sistema operativo
    17                                  sys_read: equ 0	;equ es como define y estos numeros se basan en la tabla se syscalls de x86
    18                                  sys_write:	equ 1
    19                                  sys_nanosleep:	equ 35
    20                                  sys_time:	equ 201
    21                                  sys_fcntl:	equ 72
    22                                  
    23                                  ;configurcaion de archivo descriptor
    24                                  STDIN_FILENO: equ 0
    25                                  
    26                                  F_SETFL:	equ 0x0004
    27                                  O_NONBLOCK: equ 0x0004
    28                                  
    29                                  ;screen clean definition
    30                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    31                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    32                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    33                                  
    34                                  ;intervalos de tiempo utilizados
    35                                  timespec:
    36 00000000 0000000000000000            tv_sec  dq 0
    37 00000008 002D310100000000            tv_nsec dq 20000000
    38                                  
    39                                  
    40                                  ;This is for cleaning up the screen
    41 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H";27 es el codigo de escape, [2J limpia la pantalla y [H mueve el cursor al inicio
    42                                  clear_length:	equ $-clear
    43                                  	
    44                                  	
    45                                  
    46                                  ; Start Message
    47 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD;salto de linea y retorno de carro
    47 00000020 45434E4F4C4F474943-
    47 00000029 4F20444520434F5354-
    47 00000032 412052494341202020-
    47 0000003B 20202020200A0D     
    48 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    48 0000004B 525155495445435455-
    48 00000054 524120444520434F4D-
    48 0000005D 50555441444F524153-
    48 00000066 204920202020202020-
    48 0000006F 200A0D             
    49 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    49 0000007B 5354554449414E5445-
    49 00000084 3A2048454E5259204E-
    49 0000008D 554E455A2050455245-
    49 00000096 5A2020202020202020-
    49 0000009F 0A0D               
    50 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    50 000000AA 524F4645534F523A20-
    50 000000B3 45524E4553544F2052-
    50 000000BC 495645524120414C56-
    50 000000C5 415241444F20202020-
    50 000000CE 202020200A0D       
    51 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    51 000000DD 524B414E4F49442052-
    51 000000E6 4554524F2020202020-
    51 000000EF 2020200A0D         
    52 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    52 000000FD 524553494F4E452043-
    52 00000106 55414C515549455220-
    52 0000010F 5445434C4120504152-
    52 00000118 4120494E4943494152-
    52 00000121 20202020202020200A-
    52 0000012A 0D                 
    53                                  msg1_length: equ $-msg1;calcula la longitud del mensaje
    54                                  msg2_length: equ $-msg2
    55                                  msg3_length: equ $-msg3
    56                                  msg4_length: equ $-msg4
    57                                  msg5_length: equ $-msg5
    58                                  msg6_length: equ $-msg6
    59                                  
    60                                  ; Usefull macros
    61                                  
    62                                  
    63                                  
    64                                  %macro setnonblocking 0;este macro se encarga de configurar el archivo descriptor para que no bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    65                                  	mov rax, sys_fcntl
    66                                      mov rdi, STDIN_FILENO
    67                                      mov rsi, F_SETFL
    68                                      mov rdx, O_NONBLOCK
    69                                      syscall
    70                                  %endmacro
    71                                  
    72                                  %macro unsetnonblocking 0;este macro se encarga de configurar el archivo descriptor para que bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    73                                  	mov rax, sys_fcntl
    74                                      mov rdi, STDIN_FILENO
    75                                      mov rsi, F_SETFL
    76                                      mov rdx, 0
    77                                      syscall
    78                                  %endmacro
    79                                  
    80                                  %macro full_line 0;este macro se encarga de dibujar una linea completa en la pantalla, se usa para dibujar el tablero
    81                                      times column_cells db "X"
    82                                      db 0x0a, 0xD
    83                                  %endmacro
    84                                  
    85                                  %macro hollow_line 0;este macro se encarga de dibujar una linea hueca en la pantalla, se usa para dibujar el tablero
    86                                      db "X"
    87                                      times column_cells-2 db " "
    88                                      db "X", 0x0a, 0xD
    89                                  %endmacro
    90                                  
    91                                  
    92                                  %macro print 2;este se usa para imprimir en pantalla, se encarga de escribir en pantalla
    93                                  	mov eax, sys_write
    94                                  	mov edi, 1 	; stdout
    95                                  	mov rsi, %1
    96                                  	mov edx, %2
    97                                  	syscall
    98                                  %endmacro
    99                                  
   100                                  %macro getchar 0;este se usa para leer una tecla presionada, se encarga de leer una tecla presionada
   101                                  	mov     rax, sys_read
   102                                      mov     rdi, STDIN_FILENO
   103                                      mov     rsi, input_char
   104                                      mov     rdx, 1 ; number of bytes
   105                                      syscall         ;read text input from keyboard
   106                                  %endmacro
   107                                  
   108                                  %macro sleeptime 0;este se usa para dormir el programa por un tiempo determinado, se encarga de dormir el programa por un tiempo determinado
   109                                  	mov eax, sys_nanosleep
   110                                  	mov rdi, timespec
   111                                  	xor esi, esi		; ignore remaining time in case of call interruption
   112                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   113                                  %endmacro
   114                                  
   115                                  
   116                                  
   117                                  global _start;se declara la etiqueta global _start, que es el punto de entrada del programa
   118                                  
   119                                  section .bss;seccion bss, se usa para declarar variables no inicializadas
   120                                  
   121 00000000 ??                      input_char: resb 1;reserva un byte para almacenar la tecla presionada
   122                                  
   123                                  section .data;seccion data, se usa para declarar variables inicializadas
   124                                  
   125                                  	; Guardamos la plantilla del tablero (32 filas)
   126                                      board_template:;se declara la plantilla del tablero, se hace asi porque se necesita dibujar el tablero en pantalla
   127                                          full_line
    81 00000000 58<rep 50h>         <1>  times column_cells db "X"
    82 00000050 0A0D                <1>  db 0x0a, 0xD
   128                                          %rep 30
   129                                          hollow_line
   130                                          %endrep
   129                              <1>  hollow_line
    86 00000052 58                  <2>  db "X"
    87 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000A4 58                  <2>  db "X"
    87 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000F6 58                  <2>  db "X"
    87 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000148 58                  <2>  db "X"
    87 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000019A 58                  <2>  db "X"
    87 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000001EC 58                  <2>  db "X"
    87 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000023E 58                  <2>  db "X"
    87 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000290 58                  <2>  db "X"
    87 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000002E2 58                  <2>  db "X"
    87 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000334 58                  <2>  db "X"
    87 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000386 58                  <2>  db "X"
    87 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000003D8 58                  <2>  db "X"
    87 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000042A 58                  <2>  db "X"
    87 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000047C 58                  <2>  db "X"
    87 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000004CE 58                  <2>  db "X"
    87 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000520 58                  <2>  db "X"
    87 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000572 58                  <2>  db "X"
    87 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000005C4 58                  <2>  db "X"
    87 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000616 58                  <2>  db "X"
    87 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000668 58                  <2>  db "X"
    87 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000006BA 58                  <2>  db "X"
    87 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000070C 58                  <2>  db "X"
    87 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000075E 58                  <2>  db "X"
    87 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000007B0 58                  <2>  db "X"
    87 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000802 58                  <2>  db "X"
    87 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000854 58                  <2>  db "X"
    87 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008A6 58                  <2>  db "X"
    87 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008F8 58                  <2>  db "X"
    87 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000094A 58                  <2>  db "X"
    87 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000099C 58                  <2>  db "X"
    87 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   131                                          full_line
    81 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    82 00000A3E 0A0D                <1>  db 0x0a, 0xD
   132                                      board_template_size: equ $ - board_template;esto calcula el tamaño de la plantilla del tablero
   133                                  
   134                                      ; Espacio real que se usará en la ejecución
   135 00000A40 00<rep A40h>                board: times board_template_size db 0;times sirve para repetir un valor, en este caso se repite el tamaño de la plantilla del tablero
   136                                      board_size: equ board_template_size
   137                                  
   138                                  	; Added for the terminal issue
   139 00001480 00<rep 24h>             	termios:        times 36 db 0;termios es una estructura que se usa para configurar el terminal, se inicializa en 0
   140                                  	stdin:          equ 0;stdin es el archivo descriptor del terminal, se inicializa en 0
   141                                  	ICANON:         equ 1<<1;ICANON es una bandera que se usa para configurar el terminal, se inicializa en 1<<1
   142                                  	ECHO:           equ 1<<3;ECHO es una bandera que se usa para configurar el terminal, se inicializa en 1<<3
   143                                  	VTIME: 			equ 5;VTIME es una bandera que se usa para configurar el terminal, se inicializa en 5
   144                                  	VMIN:			equ 6;VMIN es una bandera que se usa para configurar el terminal, se inicializa en 6
   145                                  	CC_C:			equ 18;CC_C es una bandera que se usa para configurar el terminal, se inicializa en 18
   146                                  
   147                                  section .text
   148                                  canonical_off:;esta funcion se encarga de apagar el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser borrado porque no se necesita
   149 0000012B E86F000000                      call read_stdin_termios
   150                                  
   151                                          ; aqui abajo que pasa es que se apaga el bit de canonical en los flags de modo local, eso significa que se apaga el modo canonico
   152 00000130 50                              push rax
   153 00000131 B802000000                      mov eax, ICANON
   154 00000136 F7D0                            not eax
   155 00000138 2105(8C140000)                  and [termios+12], eax
   156 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   157 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   158 0000014C 58                              pop rax
   159                                  
   160 0000014D E86C000000                      call write_stdin_termios
   161 00000152 C3                              ret
   162                                  
   163                                  echo_off:;esta funcion se encarga de apagar el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se apga porque no se necesita
   164 00000153 E847000000                      call read_stdin_termios
   165                                  
   166                                          ; abajo lo que pasa esque se apaga el bit de echo en los flags de modo local, eso significa que se apaga el eco
   167 00000158 50                              push rax
   168 00000159 B808000000                      mov eax, ECHO
   169 0000015E F7D0                            not eax
   170 00000160 2105(8C140000)                  and [termios+12], eax
   171 00000166 58                              pop rax
   172                                  
   173 00000167 E852000000                      call write_stdin_termios
   174 0000016C C3                              ret
   175                                  
   176                                  canonical_on:;esta funcion se encarga de encender el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser encendido porque se necesita
   177 0000016D E82D000000                      call read_stdin_termios
   178                                  
   179                                          ; esto lo que hace es que prende el bit de canonical en los flags de modo local, eso significa que se prende el modo canonico
   180 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   181 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   182 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   183 00000187 E832000000                      call write_stdin_termios
   184 0000018C C3                              ret
   185                                  
   186                                  echo_on:;esta funcion se encarga de encender el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se enciende porque se necesita
   187 0000018D E80D000000                      call read_stdin_termios
   188                                  
   189                                          ; set echo bit in local mode flags
   190 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   191                                  
   192 00000199 E820000000                      call write_stdin_termios
   193 0000019E C3                              ret
   194                                  
   195                                  read_stdin_termios:;esta funcion se encarga de leer la configuracion del terminal, lo hace mediante una llamada al sistema
   196 0000019F 50                              push rax
   197 000001A0 53                              push rbx
   198 000001A1 51                              push rcx
   199 000001A2 52                              push rdx
   200                                  
   201 000001A3 B836000000                      mov eax, 36h
   202 000001A8 BB00000000                      mov ebx, stdin
   203 000001AD B901540000                      mov ecx, 5401h
   204 000001B2 BA[80140000]                    mov edx, termios
   205 000001B7 CD80                            int 80h
   206                                  
   207 000001B9 5A                              pop rdx
   208 000001BA 59                              pop rcx
   209 000001BB 5B                              pop rbx
   210 000001BC 58                              pop rax
   211 000001BD C3                              ret
   212                                  
   213                                  write_stdin_termios:;esta funcion se encarga de escribir la configuracion del terminal, lo hace mediante una llamada al sistema
   214 000001BE 50                              push rax
   215 000001BF 53                              push rbx
   216 000001C0 51                              push rcx
   217 000001C1 52                              push rdx
   218                                  
   219 000001C2 B836000000                      mov eax, 36h
   220 000001C7 BB00000000                      mov ebx, stdin
   221 000001CC B902540000                      mov ecx, 5402h
   222 000001D1 BA[80140000]                    mov edx, termios
   223 000001D6 CD80                            int 80h
   224                                  
   225 000001D8 5A                              pop rdx
   226 000001D9 59                              pop rcx
   227 000001DA 5B                              pop rbx
   228 000001DB 58                              pop rax
   229 000001DC C3                              ret
   230                                  
   231                                  
   232                                  char_equal: equ 61;se inicializa el caracter "="
   233                                  char_space: equ 32;se inicializa el caracter " "
   234                                  char_O: equ 79;se inicializa el caracter "O"
   235                                  left_direction: equ -1;se inicializa la direccion izquierda
   236                                  right_direction: equ 1;se inicializa la direccion derecha
   237                                  
   238                                  
   239                                  section .data
   240                                  
   241                                  ; Mensajes para los niveles
   242 000014A4 4E4956454C20                level_msg: db "NIVEL "
   243                                      level_msg_len: equ $ - level_msg
   244 000014AA 31                          level_1_char: db "1"
   245 000014AB 32                          level_2_char: db "2"
   246 000014AC 33                          level_3_char: db "3"
   247 000014AD 34                          level_4_char: db "4"
   248 000014AE 35                          level_5_char: db "5"
   249                                      level_char_len: equ 1
   250                                  
   251                                      ; Timespec para la pausa del mensaje de nivel
   252                                      level_display_time:
   253 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   254 000014B7 0000000000000000                lvl_tv_nsec dq 0
   255                                          
   256 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   257 000014C7 0500000000000000            pallet_size dq 5
   258 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   259 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   260                                  
   261 000014DF 2800000000000000        	ball_x_pos: dq 40
   262 000014E7 1C00000000000000        	ball_y_pos: dq 28
   263 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   264 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   265 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   266 00001500 00                          ball_active db 0
   267                                  
   268 00001501 0000000000000000            ball2_x_pos:        dq 0
   269 00001509 0000000000000000            ball2_y_pos:        dq 0
   270 00001511 0000000000000000            ball2_direction_x:  dq 0
   271 00001519 0000000000000000            ball2_direction_y:  dq 0
   272 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   273 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   274                                  
   275                                      ; -- Pelota 3 --
   276 00001523 0000000000000000            ball3_x_pos:        dq 0
   277 0000152B 0000000000000000            ball3_y_pos:        dq 0
   278 00001533 0000000000000000            ball3_direction_x:  dq 0
   279 0000153B 0000000000000000            ball3_direction_y:  dq 0
   280 00001543 00                          ball3_moving:       db 0
   281 00001544 00                          ball3_active:       db 0
   282                                  
   283                                  
   284                                  ; Definir los límites de la pantalla o área de juego
   285                                      board_top_left_x equ 1
   286                                      board_top_left_y equ 1
   287                                      board_bottom_right_x equ column_cells - 1
   288                                      board_bottom_right_y equ row_cells
   289                                  
   290                                      ; Limites laterales
   291                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   292                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   293                                  
   294                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   295 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   296 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   297                                  
   298                                      ; Definición de tipos de bloques
   299 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   300 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   301 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   302 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   303 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   304 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   305                                      block_length: equ 6        ; Longitud de cada bloque
   306                                  
   307                                      ; Estructura para el nivel actual
   308 00001579 01                          current_level db 1
   309 0000157A 00                          blocks_remaining db 0
   310                                  
   311                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   312                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   313                                      level1_blocks:
   314                                          ; Tercera fila (tipo 3)
   315 0000157B 0105050220                      db 1, 5, 5, 2, ' '   
   316 00001580 0705050220                      db 7, 5, 5, 2, ' '    
   317 00001585 0D05050220                      db 13, 5, 5, 2, ' '   
   318 0000158A 1305050220                      db 19, 5, 5, 2, ' '   
   319 0000158F 1905050220                      db 25, 5, 5, 2, ' '   
   320 00001594 1F05050220                      db 31, 5, 5, 2, ' '   
   321 00001599 2505050220                      db 37, 5, 5, 2, ' '   
   322 0000159E 2B05050220                      db 43, 5, 5, 2, ' '   
   323 000015A3 3105050220                      db 49, 5, 5, 2, ' '   
   324 000015A8 3705050220                      db 55, 5, 5, 2, ' '   
   325 000015AD 3D05050220                      db 61, 5, 5, 2, ' '  
   326 000015B2 4305050220                      db 67, 5, 5, 2, ' '   
   327 000015B7 4905050220                      db 73, 5, 5, 2, ' '   
   328                                  
   329 000015BC 0106040145                      db 1, 6, 4, 1, 'E'   
   330 000015C1 0706020153                      db 7, 6, 2, 1, 'S'    
   331 000015C6 0D06040153                      db 13, 6, 4, 1, 'S'   
   332 000015CB 1306020153                      db 19, 6, 2, 1, 'S'   
   333 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   334 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   335 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   336 000015DF 2B06020143                      db 43, 6, 2, 1, 'C'   
   337 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   338 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   339 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   340 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   341 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   342                                  
   343 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   344 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   345 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   346 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   347 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   348 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   349 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   350 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   351 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   352 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   353 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   354 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   355 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   356                                  
   357 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   358 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   359 00001648 0D08040150                      db 13, 8, 4, 1, 'P'   
   360 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   361 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   362 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   363 0000165C 2508040145                      db 37, 8, 4, 1, 'E'   
   364 00001661 2B08020143                      db 43, 8, 2, 1, 'C'   
   365 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   366 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   367 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   368 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   369 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   370                                  
   371 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   372 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   373 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   374 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   375 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   376 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   377 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   378 000016A2 2B09030120                      db 43, 9, 3, 1, ' '     
   379 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   380 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   381 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   382 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   383 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   384                                  
   385 000016C0 010A040145                      db 1, 10, 4, 1, 'E'   
   386 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   387 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   388 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   389 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   390 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   391 000016DE 250A040143                      db 37, 10, 4, 1, 'C'   
   392 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   393 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   394 000016ED 370A02014C                      db 55, 10, 2, 1, 'L'   
   395 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   396 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   397 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   398                                  
   399                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   400                                  
   401                                      ; Nivel 2: Bloques de prueba
   402                                      level2_blocks:
   403 00001701 0103040120                      db 1, 3, 4, 1, ' '
   404                                  
   405 00001706 0104030120                      db 1, 4, 3, 1, ' '   
   406 0000170B 0704040120                      db 7, 4, 4, 1, ' '   
   407                                                  
   408 00001710 0105020120                      db 1, 5, 2, 1, ' '   
   409 00001715 0705030120                      db 7, 5, 3, 1, ' '
   410 0000171A 0D05040144                      db 13, 5, 4, 1, 'D'
   411                                  
   412 0000171F 0106010120                      db 1, 6, 1, 1, ' '   
   413 00001724 0706020120                      db 7, 6, 2, 1, ' '
   414 00001729 0D06030120                      db 13, 6, 3, 1, ' '
   415 0000172E 1306040120                      db 19, 6, 4, 1, ' '   
   416                                  
   417 00001733 0107040120                      db 1, 7, 4, 1, ' '   
   418 00001738 0707010120                      db 7, 7, 1, 1, ' '
   419 0000173D 0D07020120                      db 13, 7, 2, 1, ' '
   420 00001742 1307030120                      db 19, 7, 3, 1, ' '  
   421 00001747 1907040120                      db 25, 7, 4, 1, ' '   
   422                                  
   423 0000174C 0108030120                      db 1, 8, 3, 1, ' '   
   424 00001751 0708040120                      db 7, 8, 4, 1, ' '
   425 00001756 0D08010120                      db 13, 8, 1, 1, ' '
   426 0000175B 1308020120                      db 19, 8, 2, 1, ' '  
   427 00001760 1908030120                      db 25, 8, 3, 1, ' ' 
   428 00001765 1F08040120                      db 31, 8, 4, 1, ' '   
   429                                  
   430 0000176A 0109020120                      db 1, 9, 2, 1, ' '   
   431 0000176F 0709030120                      db 7, 9, 3, 1, ' '
   432 00001774 0D09040120                      db 13, 9, 4, 1, ' '
   433 00001779 1309010120                      db 19, 9, 1, 1, ' '  
   434 0000177E 1909020120                      db 25, 9, 2, 1, ' ' 
   435 00001783 1F09030143                      db 31, 9, 3, 1, 'C' 
   436 00001788 2509040120                      db 37, 9, 4, 1, ' '   
   437                                  
   438 0000178D 010A010120                      db 1, 10, 1, 1, ' '   
   439 00001792 070A020120                      db 7, 10, 2, 1, ' '
   440 00001797 0D0A030120                      db 13, 10, 3, 1, ' '
   441 0000179C 130A040120                      db 19, 10, 4, 1, ' '  
   442 000017A1 190A010120                      db 25, 10, 1, 1, ' ' 
   443 000017A6 1F0A020120                      db 31, 10, 2, 1, ' ' 
   444 000017AB 250A03014C                      db 37, 10, 3, 1, 'L'  
   445 000017B0 2B0A040120                      db 43, 10, 4, 1, ' '   
   446                                  
   447 000017B5 010B040120                      db 1, 11, 4, 1, ' '   
   448 000017BA 070B010120                      db 7, 11, 1, 1, ' '
   449 000017BF 0D0B020120                      db 13, 11, 2, 1, ' '
   450 000017C4 130B030144                      db 19, 11, 3, 1, 'D'  
   451 000017C9 190B040120                      db 25, 11, 4, 1, ' ' 
   452 000017CE 1F0B010120                      db 31, 11, 1, 1, ' ' 
   453 000017D3 250B020120                      db 37, 11, 2, 1, ' '  
   454 000017D8 2B0B030120                      db 43, 11, 3, 1, ' ' 
   455 000017DD 310B040120                      db 49, 11, 4, 1, ' '   
   456                                  
   457 000017E2 010C030120                      db 1, 12, 3, 1, ' '   
   458 000017E7 070C040120                      db 7, 12, 4, 1, ' '
   459 000017EC 0D0C010120                      db 13, 12, 1, 1, ' '
   460 000017F1 130C020120                      db 19, 12, 2, 1, ' '  
   461 000017F6 190C030120                      db 25, 12, 3, 1, ' ' 
   462 000017FB 1F0C040120                      db 31, 12, 4, 1, ' ' 
   463 00001800 250C010120                      db 37, 12, 1, 1, ' '  
   464 00001805 2B0C020120                      db 43, 12, 2, 1, ' ' 
   465 0000180A 310C030120                      db 49, 12, 3, 1, ' '
   466 0000180F 370C040120                      db 55, 12, 4, 1, ' '   
   467                                  
   468 00001814 010D020120                      db 1, 13, 2, 1, ' '   
   469 00001819 070D030120                      db 7, 13, 3, 1, ' '
   470 0000181E 0D0D040120                      db 13, 13, 4, 1, ' '
   471 00001823 130D010144                      db 19, 13, 1, 1, 'D'  
   472 00001828 190D020120                      db 25, 13, 2, 1, ' ' 
   473 0000182D 1F0D030120                      db 31, 13, 3, 1, ' ' 
   474 00001832 250D040120                      db 37, 13, 4, 1, ' '  
   475 00001837 2B0D010120                      db 43, 13, 1, 1, ' ' 
   476 0000183C 310D020120                      db 49, 13, 2, 1, ' '
   477 00001841 370D030120                      db 55, 13, 3, 1, ' ' 
   478 00001846 3D0D040120                      db 61, 13, 4, 1, ' '   
   479                                  
   480 0000184B 010E010120                      db 1, 14, 1, 1, ' '   
   481 00001850 070E020120                      db 7, 14, 2, 1, ' '
   482 00001855 0D0E030120                      db 13, 14, 3, 1, ' '
   483 0000185A 130E040120                      db 19, 14, 4, 1, ' '  
   484 0000185F 190E010120                      db 25, 14, 1, 1, ' ' 
   485 00001864 1F0E020120                      db 31, 14, 2, 1, ' ' 
   486 00001869 250E030120                      db 37, 14, 3, 1, ' '  
   487 0000186E 2B0E040120                      db 43, 14, 4, 1, ' ' 
   488 00001873 310E010120                      db 49, 14, 1, 1, ' '
   489 00001878 370E020120                      db 55, 14, 2, 1, ' ' 
   490 0000187D 3D0E030120                      db 61, 14, 3, 1, ' '  
   491 00001882 430E040120                      db 67, 14, 4, 1, ' '   
   492                                  
   493 00001887 010F050220                      db 1, 15, 5, 2, ' '   
   494 0000188C 070F050220                      db 7, 15, 5, 2, ' '
   495 00001891 0D0F050220                      db 13, 15, 5, 2, ' '
   496 00001896 130F050220                      db 19, 15, 5, 2, ' '  
   497 0000189B 190F050220                      db 25, 15, 5, 2, ' ' 
   498 000018A0 1F0F050220                      db 31, 15, 5, 2, ' ' 
   499 000018A5 250F050220                      db 37, 15, 5, 2, ' '  
   500 000018AA 2B0F050220                      db 43, 15, 5, 2, ' ' 
   501 000018AF 310F050220                      db 49, 15, 5, 2, ' '
   502 000018B4 370F050220                      db 55, 15, 5, 2, ' ' 
   503 000018B9 3D0F050220                      db 61, 15, 5, 2, ' '  
   504 000018BE 430F050220                      db 67, 15, 5, 2, ' '
   505 000018C3 490F040120                      db 73, 15, 4, 1, ' '   
   506                                         
   507                                  
   508                                      level2_blocks_count equ 91
   509                                  
   510                                      ; Nivel 3
   511                                      level3_blocks:
   512                                  
   513 000018C8 0102010120                      db 1, 2, 1, 1, ' '   
   514 000018CD 0702020120                      db 7, 2, 2, 1, ' '    
   515 000018D2 0D02010120                      db 13, 2, 1, 1, ' '   
   516 000018D7 1302020120                      db 19, 2, 2, 1, ' '   
   517 000018DC 1902010120                      db 25, 2, 1, 1, ' '   
   518 000018E1 1F02020120                      db 31, 2, 2, 1, ' '   
   519 000018E6 2502010120                      db 37, 2, 1, 1, ' '   
   520 000018EB 2B02020120                      db 43, 2, 2, 1, ' '   
   521 000018F0 3102010120                      db 49, 2, 1, 1, ' '   
   522 000018F5 3702020120                      db 55, 2, 2, 1, ' '   
   523 000018FA 3D02010120                      db 61, 2, 1, 1, ' '  
   524 000018FF 4302020120                      db 67, 2, 2, 1, ' '   
   525 00001904 4902010120                      db 73, 2, 1, 1, ' ' 
   526                                  
   527 00001909 0106040120                      db 1, 6, 4, 1, ' '   
   528 0000190E 0706040120                      db 7, 6, 4, 1, ' '    
   529 00001913 0D06040120                      db 13, 6, 4, 1, ' '   
   530 00001918 1306066320                      db 19, 6, 6, 99, ' '   
   531 0000191D 1906066320                      db 25, 6, 6, 99, ' '   
   532 00001922 1F06066320                      db 31, 6, 6, 99, ' '   
   533 00001927 2506066320                      db 37, 6, 6, 99, ' '   
   534 0000192C 2B06066320                      db 43, 6, 6, 99, ' '   
   535 00001931 3106066320                      db 49, 6, 6, 99, ' '   
   536 00001936 3706066320                      db 55, 6, 6, 99, ' '   
   537 0000193B 3D06066320                      db 61, 6, 6, 99, ' '  
   538 00001940 4306066320                      db 67, 6, 6, 99, ' '   
   539 00001945 4906066320                      db 73, 6, 6, 99, ' ' 
   540                                  
   541 0000194A 0108040120                      db 1, 8, 4, 1, ' '   
   542 0000194F 0708030120                      db 7, 8, 3, 1, ' '    
   543 00001954 0D08040120                      db 13, 8, 4, 1, ' '   
   544 00001959 1308030120                      db 19, 8, 3, 1, ' '   
   545 0000195E 1908040120                      db 25, 8, 4, 1, ' '   
   546 00001963 1F08030120                      db 31, 8, 3, 1, ' '   
   547 00001968 2508040120                      db 37, 8, 4, 1, ' '   
   548 0000196D 2B08030120                      db 43, 8, 3, 1, ' '   
   549 00001972 3108040120                      db 49, 8, 4, 1, ' '   
   550 00001977 3708030120                      db 55, 8, 3, 1, ' '   
   551 0000197C 3D08040120                      db 61, 8, 4, 1, ' '  
   552 00001981 4308030120                      db 67, 8, 3, 1, ' '   
   553 00001986 4908040120                      db 73, 8, 4, 1, ' ' 
   554                                  
   555 0000198B 010B066320                      db 1, 11, 6, 99, ' '   
   556 00001990 070B066320                      db 7, 11, 6, 99, ' '    
   557 00001995 0D0B066320                      db 13, 11, 6, 99, ' '   
   558 0000199A 130B066320                      db 19, 11, 6, 99, ' '   
   559 0000199F 190B066320                      db 25, 11, 6, 99, ' '   
   560 000019A4 1F0B066320                      db 31, 11, 6, 99, ' '   
   561 000019A9 250B066320                      db 37, 11, 6, 99, ' '   
   562 000019AE 2B0B066320                      db 43, 11, 6, 99, ' '   
   563 000019B3 310B066320                      db 49, 11, 6, 99, ' '   
   564 000019B8 370B066320                      db 55, 11, 6, 99, ' '   
   565 000019BD 3D0B030144                      db 61, 11, 3, 1, 'D'  
   566 000019C2 430B030120                      db 67, 11, 3, 1, ' '   
   567 000019C7 490B030120                      db 73, 11, 3, 1, ' ' 
   568                                  
   569 000019CC 010D010144                      db 1, 13, 1, 1, 'D'   
   570 000019D1 070D020150                      db 7, 13, 2, 1, 'P'    
   571 000019D6 0D0D010143                      db 13, 13, 1, 1, 'C'   
   572 000019DB 130D020120                      db 19, 13, 2, 1, ' '   
   573 000019E0 190D010120                      db 25, 13, 1, 1, ' '   
   574 000019E5 1F0D020120                      db 31, 13, 2, 1, ' '   
   575 000019EA 250D010120                      db 37, 13, 1, 1, ' '   
   576 000019EF 2B0D020120                      db 43, 13, 2, 1, ' '   
   577 000019F4 310D010120                      db 49, 13, 1, 1, ' '   
   578 000019F9 370D020120                      db 55, 13, 2, 1, ' '   
   579 000019FE 3D0D010120                      db 61, 13, 1, 1, ' '  
   580 00001A03 430D020120                      db 67, 13, 2, 1, ' '   
   581 00001A08 490D010120                      db 73, 13, 1, 1, ' ' 
   582                                  
   583 00001A0D 010F020120                      db 1, 15, 2, 1, ' '   
   584 00001A12 070F020120                      db 7, 15, 2, 1, ' '    
   585 00001A17 0D0F020120                      db 13, 15, 2, 1, ' '   
   586 00001A1C 130F066320                      db 19, 15, 6, 99, ' '   
   587 00001A21 190F066320                      db 25, 15, 6, 99, ' '   
   588 00001A26 1F0F066320                      db 31, 15, 6, 99, ' '   
   589 00001A2B 250F066320                      db 37, 15, 6, 99, ' '   
   590 00001A30 2B0F066320                      db 43, 15, 6, 99, ' '   
   591 00001A35 310F066320                      db 49, 15, 6, 99, ' '   
   592 00001A3A 370F066320                      db 55, 15, 6, 99, ' '   
   593 00001A3F 3D0F066320                      db 61, 15, 6, 99, ' '  
   594 00001A44 430F066320                      db 67, 15, 6, 99, ' '   
   595 00001A49 490F066320                      db 73, 15, 6, 99, ' ' 
   596                                  
   597 00001A4E 0112020120                      db 1, 18, 2, 1, ' '   
   598 00001A53 0712030120                      db 7, 18, 3, 1, ' '    
   599 00001A58 0D12020144                      db 13, 18, 2, 1, 'D'   
   600 00001A5D 1312030120                      db 19, 18, 3, 1, ' '   
   601 00001A62 1912020120                      db 25, 18, 2, 1, ' '   
   602 00001A67 1F12030120                      db 31, 18, 3, 1, ' '   
   603 00001A6C 2512020120                      db 37, 18, 2, 1, ' '   
   604 00001A71 2B12030120                      db 43, 18, 3, 1, ' '   
   605 00001A76 3112020120                      db 49, 18, 2, 1, ' '   
   606 00001A7B 3712030144                      db 55, 18, 3, 1, 'D'   
   607 00001A80 3D12020120                      db 61, 18, 2, 1, ' '  
   608 00001A85 4312030143                      db 67, 18, 3, 1, 'C'   
   609 00001A8A 4912020120                      db 73, 18, 2, 1, ' ' 
   610                                  
   611                                  
   612 00001A8F 0114066320                      db 1, 20, 6, 99, ' '   
   613 00001A94 0714066320                      db 7, 20, 6, 99, ' '    
   614 00001A99 0D14066320                      db 13, 20, 6, 99, ' '   
   615 00001A9E 1314066320                      db 19, 20, 6, 99, ' '   
   616 00001AA3 1914066320                      db 25, 20, 6, 99, ' '   
   617 00001AA8 1F14066320                      db 31, 20, 6, 99, ' '   
   618 00001AAD 2514066320                      db 37, 20, 6, 99, ' '   
   619 00001AB2 2B14066320                      db 43, 20, 6, 99, ' '   
   620 00001AB7 3114066320                      db 49, 20, 6, 99, ' '   
   621 00001ABC 3714066320                      db 55, 20, 6, 99, ' '   
   622 00001AC1 3D14010120                      db 61, 20, 1, 1, ' '  
   623 00001AC6 4314010153                      db 67, 20, 1, 1, 'S'   
   624 00001ACB 4914010143                      db 73, 20, 1, 1, 'C' 
   625                                  
   626                                      level3_blocks_count equ 104
   627                                  
   628                                      ; Nivel 4
   629                                      level4_blocks:
   630                                  
   631 00001AD0 0704010120                      db 7, 4, 1, 1, ' '    
   632 00001AD5 0D04020120                      db 13, 4, 2, 1, ' '   
   633 00001ADA 1304030120                      db 19, 4, 3, 1, ' '   
   634 00001ADF 1904050220                      db 25, 4, 5, 2, ' '   
   635 00001AE4 1F04020120                      db 31, 4, 2, 1, ' '
   636                                  
   637 00001AE9 2B04010120                      db 43, 4, 1, 1, ' '   
   638 00001AEE 3104020120                      db 49, 4, 2, 1, ' '   
   639 00001AF3 3704030144                      db 55, 4, 3, 1, 'D'   
   640 00001AF8 3D04040120                      db 61, 4, 4, 1, ' '  
   641 00001AFD 4304020120                      db 67, 4, 2, 1, ' ' 
   642                                  
   643 00001B02 0705020120                      db 7, 5, 2, 1, ' '    
   644 00001B07 0D05030120                      db 13, 5, 3, 1, ' '   
   645 00001B0C 1305050220                      db 19, 5, 5, 2, ' '   
   646 00001B11 1905020120                      db 25, 5, 2, 1, ' '   
   647 00001B16 1F05010120                      db 31, 5, 1, 1, ' '
   648                                  
   649 00001B1B 2B05020120                      db 43, 5, 2, 1, ' '   
   650 00001B20 3105030120                      db 49, 5, 3, 1, ' '   
   651 00001B25 3705040120                      db 55, 5, 4, 1, ' '   
   652 00001B2A 3D05020120                      db 61, 5, 2, 1, ' '  
   653 00001B2F 4305050220                      db 67, 5, 5, 2, ' '  
   654                                  
   655 00001B34 0706030120                      db 7, 6, 3, 1, ' '    
   656 00001B39 0D06050220                      db 13, 6, 5, 2, ' '   
   657 00001B3E 1306020120                      db 19, 6, 2, 1, ' '   
   658 00001B43 1906010120                      db 25, 6, 1, 1, ' '   
   659 00001B48 1F06020120                      db 31, 6, 2, 1, ' '
   660                                  
   661 00001B4D 2B06030120                      db 43, 6, 3, 1, ' '   
   662 00001B52 3106040120                      db 49, 6, 4, 1, ' '   
   663 00001B57 3706020120                      db 55, 6, 2, 1, ' '   
   664 00001B5C 3D06050220                      db 61, 6, 5, 2, ' '  
   665 00001B61 4306020120                      db 67, 6, 2, 1, ' '
   666                                  
   667 00001B66 0707050220                      db 7, 7, 5, 2, ' '    
   668 00001B6B 0D07020120                      db 13, 7, 2, 1, ' '   
   669 00001B70 1307010120                      db 19, 7, 1, 1, ' '   
   670 00001B75 1907020120                      db 25, 7, 2, 1, ' '   
   671 00001B7A 1F07030120                      db 31, 7, 3, 1, ' '
   672                                  
   673 00001B7F 2B07040120                      db 43, 7, 4, 1, ' '   
   674 00001B84 3107020120                      db 49, 7, 2, 1, ' '   
   675 00001B89 3707050220                      db 55, 7, 5, 2, ' '   
   676 00001B8E 3D07020120                      db 61, 7, 2, 1, ' '  
   677 00001B93 4307030120                      db 67, 7, 3, 1, ' '
   678                                  
   679 00001B98 0708020120                      db 7, 8, 2, 1, ' '    
   680 00001B9D 0D08010120                      db 13, 8, 1, 1, ' '   
   681 00001BA2 1308020120                      db 19, 8, 2, 1, ' '   
   682 00001BA7 1908030120                      db 25, 8, 3, 1, ' '   
   683 00001BAC 1F08040120                      db 31, 8, 4, 1, ' '
   684                                  
   685 00001BB1 2B08020120                      db 43, 8, 2, 1, ' '   
   686 00001BB6 3108050220                      db 49, 8, 5, 2, ' '   
   687 00001BBB 3708020120                      db 55, 8, 2, 1, ' '   
   688 00001BC0 3D08030120                      db 61, 8, 3, 1, ' '  
   689 00001BC5 4308040120                      db 67, 8, 4, 1, ' '
   690                                  
   691 00001BCA 0709010120                      db 7, 9, 1, 1, ' '    
   692 00001BCF 0D09020120                      db 13, 9, 2, 1, ' '   
   693 00001BD4 1309030120                      db 19, 9, 3, 1, ' '   
   694 00001BD9 1909040120                      db 25, 9, 4, 1, ' '   
   695 00001BDE 1F09020120                      db 31, 9, 2, 1, ' '
   696                                  
   697 00001BE3 2B09050220                      db 43, 9, 5, 2, ' '   
   698 00001BE8 3109020120                      db 49, 9, 2, 1, ' '   
   699 00001BED 3709030120                      db 55, 9, 3, 1, ' '   
   700 00001BF2 3D09040120                      db 61, 9, 4, 1, ' '  
   701 00001BF7 4309020120                      db 67, 9, 2, 1, ' '
   702                                  
   703 00001BFC 070A020120                      db 7, 10, 2, 1, ' '    
   704 00001C01 0D0A030120                      db 13, 10, 3, 1, ' '   
   705 00001C06 130A040120                      db 19, 10, 4, 1, ' '   
   706 00001C0B 190A020120                      db 25, 10, 2, 1, ' '   
   707 00001C10 1F0A010120                      db 31, 10, 1, 1, ' '
   708                                  
   709 00001C15 2B0A020120                      db 43, 10, 2, 1, ' '   
   710 00001C1A 310A030120                      db 49, 10, 3, 1, ' '   
   711 00001C1F 370A040120                      db 55, 10, 4, 1, ' '   
   712 00001C24 3D0A020120                      db 61, 10, 2, 1, ' '  
   713 00001C29 430A010120                      db 67, 10, 1, 1, ' '
   714                                  
   715 00001C2E 070B030120                      db 7, 11, 3, 1, ' '   
   716 00001C33 0D0B040120                      db 13, 11, 4, 1, ' '   
   717 00001C38 130B020120                      db 19, 11, 2, 1, ' '   
   718 00001C3D 190B010120                      db 25, 11, 1, 1, ' '  
   719 00001C42 1F0B050220                      db 31, 11, 5, 2, ' '
   720                                  
   721 00001C47 2B0B030120                      db 43, 11, 3, 1, ' '   
   722 00001C4C 310B040120                      db 49, 11, 4, 1, ' '   
   723 00001C51 370B020120                      db 55, 11, 2, 1, ' '   
   724 00001C56 3D0B010120                      db 61, 11, 1, 1, ' '  
   725 00001C5B 430B020120                      db 67, 11, 2, 1, ' '
   726                                  
   727 00001C60 070C040120                      db 7, 12, 4, 1, ' '   
   728 00001C65 0D0C020120                      db 13, 12, 2, 1, ' '   
   729 00001C6A 130C010120                      db 19, 12, 1, 1, ' '   
   730 00001C6F 190C050220                      db 25, 12, 5, 2, ' '  
   731 00001C74 1F0C030120                      db 31, 12, 3, 1, ' '
   732                                  
   733 00001C79 2B0C040120                      db 43, 12, 4, 1, ' '    
   734 00001C7E 310C020120                      db 49, 12, 2, 1, ' '   
   735 00001C83 370C010120                      db 55, 12, 1, 1, ' '   
   736 00001C88 3D0C020120                      db 61, 12, 2, 1, ' '   
   737 00001C8D 430C030120                      db 67, 12, 3, 1, ' '
   738                                  
   739 00001C92 070D020120                      db 7, 13, 2, 1, ' '   
   740 00001C97 0D0D010120                      db 13, 13, 1, 1, ' '   
   741 00001C9C 130D050220                      db 19, 13, 5, 2, ' '   
   742 00001CA1 190D030143                      db 25, 13, 3, 1, 'C'  
   743 00001CA6 1F0D040120                      db 31, 13, 4, 1, ' '
   744                                  
   745 00001CAB 2B0D020120                      db 43, 13, 2, 1, ' '    
   746 00001CB0 310D010120                      db 49, 13, 1, 1, ' '   
   747 00001CB5 370D020120                      db 55, 13, 2, 1, ' '   
   748 00001CBA 3D0D030120                      db 61, 13, 3, 1, ' '   
   749 00001CBF 430D050220                      db 67, 13, 5, 2, ' '
   750                                  
   751 00001CC4 070E010120                      db 7, 14, 1, 1, ' '   
   752 00001CC9 0D0E050220                      db 13, 14, 5, 2, ' '   
   753 00001CCE 130E030120                      db 19, 14, 3, 1, ' '   
   754 00001CD3 190E040120                      db 25, 14, 4, 1, ' '  
   755 00001CD8 1F0E020120                      db 31, 14, 2, 1, ' '
   756                                  
   757 00001CDD 2B0E010120                      db 43, 14, 1, 1, ' '    
   758 00001CE2 310E020120                      db 49, 14, 2, 1, ' '   
   759 00001CE7 370E030120                      db 55, 14, 3, 1, ' '   
   760 00001CEC 3D0E050220                      db 61, 14, 5, 2, ' '   
   761 00001CF1 430E020120                      db 67, 14, 2, 1, ' '
   762                                  
   763 00001CF6 070F050220                      db 7, 15, 5, 2, ' '   
   764 00001CFB 0D0F030120                      db 13, 15, 3, 1, ' '   
   765 00001D00 130F040120                      db 19, 15, 4, 1, ' '   
   766 00001D05 190F020120                      db 25, 15, 2, 1, ' '  
   767 00001D0A 1F0F010120                      db 31, 15, 1, 1, ' '
   768                                  
   769 00001D0F 2B0F020145                      db 43, 15, 2, 1, 'E'    
   770 00001D14 310F03014C                      db 49, 15, 3, 1, 'L'   
   771 00001D19 370F050220                      db 55, 15, 5, 2, ' '   
   772 00001D1E 3D0F020120                      db 61, 15, 2, 1, ' '   
   773 00001D23 430F010120                      db 67, 15, 1, 1, ' '
   774                                  
   775 00001D28 0710030120                      db 7, 16, 3, 1, ' '   
   776 00001D2D 0D10040120                      db 13, 16, 4, 1, ' '   
   777 00001D32 1310020120                      db 19, 16, 2, 1, ' '   
   778 00001D37 1910010120                      db 25, 16, 1, 1, ' '  
   779 00001D3C 1F10020120                      db 31, 16, 2, 1, ' '
   780                                  
   781 00001D41 2B10030120                      db 43, 16, 3, 1, ' '    
   782 00001D46 3110050220                      db 49, 16, 5, 2, ' '   
   783 00001D4B 3710020120                      db 55, 16, 2, 1, ' '   
   784 00001D50 3D10010120                      db 61, 16, 1, 1, ' '   
   785 00001D55 4310020120                      db 67, 16, 2, 1, ' '
   786                                  
   787 00001D5A 0711040120                      db 7, 17, 4, 1, ' '   
   788 00001D5F 0D11020120                      db 13, 17, 2, 1, ' '   
   789 00001D64 1311010120                      db 19, 17, 1, 1, ' '   
   790 00001D69 1911020120                      db 25, 17, 2, 1, ' '  
   791 00001D6E 1F11030120                      db 31, 17, 3, 1, ' '
   792                                  
   793 00001D73 2B11050220                      db 43, 17, 5, 2, ' '    
   794 00001D78 3111020120                      db 49, 17, 2, 1, ' '    
   795 00001D7D 3711010120                      db 55, 17, 1, 1, ' '   
   796 00001D82 3D11020120                      db 61, 17, 2, 1, ' '   
   797 00001D87 4311030120                      db 67, 17, 3, 1, ' '
   798                                  
   799                                      level4_blocks_count equ 140
   800                                  
   801                                      ; Nivel 5
   802                                      level5_blocks:
   803                                  
   804 00001D8C 1303020145                      db 19, 3, 2, 1, 'E'   
   805 00001D91 3703020120                      db 55, 3, 2, 1, ' '   
   806                                  
   807 00001D96 1304020120                      db 19, 4, 2, 1, ' '   
   808 00001D9B 370402014C                      db 55, 4, 2, 1, 'L' 
   809                                  
   810 00001DA0 1905020120                      db 25, 5, 2, 1, ' '   
   811 00001DA5 3105020153                      db 49, 5, 2, 1, 'S'   
   812                                  
   813 00001DAA 1906020120                      db 25, 6, 2, 1, ' '   
   814 00001DAF 3106020120                      db 49, 6, 2, 1, ' '   
   815                                  
   816 00001DB4 1307050220                      db 19, 7, 5, 2, ' '   
   817 00001DB9 1907050220                      db 25, 7, 5, 2, ' '  
   818 00001DBE 1F07050220                      db 31, 7, 5, 2, ' '
   819 00001DC3 2507050220                      db 37, 7, 5, 2, ' '
   820 00001DC8 2B07050220                      db 43, 7, 5, 2, ' '    
   821 00001DCD 3107050220                      db 49, 7, 5, 2, ' '    
   822 00001DD2 3707050220                      db 55, 7, 5, 2, ' '   
   823                                  
   824 00001DD7 1308050220                      db 19, 8, 5, 2, ' '   
   825 00001DDC 1908050220                      db 25, 8, 5, 2, ' '  
   826 00001DE1 1F08050220                      db 31, 8, 5, 2, ' '
   827 00001DE6 2508050220                      db 37, 8, 5, 2, ' '
   828 00001DEB 2B08050220                      db 43, 8, 5, 2, ' '    
   829 00001DF0 3108050220                      db 49, 8, 5, 2, ' '    
   830 00001DF5 3708050220                      db 55, 8, 5, 2, ' '   
   831                                  
   832 00001DFA 0D09050220                      db 13, 9, 5, 2, ' '   
   833 00001DFF 1309050220                      db 19, 9, 5, 2, ' '   
   834 00001E04 1909040143                      db 25, 9, 4, 1, 'C'  
   835 00001E09 1F09050220                      db 31, 9, 5, 2, ' '
   836 00001E0E 2509050220                      db 37, 9, 5, 2, ' '
   837 00001E13 2B09050220                      db 43, 9, 5, 2, ' '    
   838 00001E18 3109040144                      db 49, 9, 4, 1, 'D'    
   839 00001E1D 3709050220                      db 55, 9, 5, 2, ' '   
   840 00001E22 3D09050220                      db 61, 9, 5, 2, ' '  
   841                                  
   842 00001E27 0D0A050220                      db 13, 10, 5, 2, ' '   
   843 00001E2C 130A050220                      db 19, 10, 5, 2, ' '   
   844 00001E31 190A040120                      db 25, 10, 4, 1, ' '  
   845 00001E36 1F0A050220                      db 31, 10, 5, 2, ' '
   846 00001E3B 250A050220                      db 37, 10, 5, 2, ' '
   847 00001E40 2B0A050220                      db 43, 10, 5, 2, ' '    
   848 00001E45 310A040120                      db 49, 10, 4, 1, ' '    
   849 00001E4A 370A050220                      db 55, 10, 5, 2, ' '   
   850 00001E4F 3D0A050220                      db 61, 10, 5, 2, ' '   
   851                                          
   852 00001E54 070B050220                      db 7, 11, 5, 2, ' '   
   853 00001E59 0D0B050220                      db 13, 11, 5, 2, ' '   
   854 00001E5E 130B050220                      db 19, 11, 5, 2, ' '   
   855 00001E63 190B050220                      db 25, 11, 5, 2, ' '  
   856 00001E68 1F0B050220                      db 31, 11, 5, 2, ' '
   857 00001E6D 250B050220                      db 37, 11, 5, 2, ' '
   858 00001E72 2B0B050220                      db 43, 11, 5, 2, ' '    
   859 00001E77 310B050220                      db 49, 11, 5, 2, ' '    
   860 00001E7C 370B050220                      db 55, 11, 5, 2, ' '   
   861 00001E81 3D0B050220                      db 61, 11, 5, 2, ' '   
   862 00001E86 430B050220                      db 67, 11, 5, 2, ' '
   863                                  
   864 00001E8B 070C050220                      db 7, 12, 5, 2, ' '   
   865 00001E90 0D0C050220                      db 13, 12, 5, 2, ' '   
   866 00001E95 130C050220                      db 19, 12, 5, 2, ' '   
   867 00001E9A 190C050220                      db 25, 12, 5, 2, ' '  
   868 00001E9F 1F0C050220                      db 31, 12, 5, 2, ' '
   869 00001EA4 250C050220                      db 37, 12, 5, 2, ' '
   870 00001EA9 2B0C050220                      db 43, 12, 5, 2, ' '    
   871 00001EAE 310C050220                      db 49, 12, 5, 2, ' '    
   872 00001EB3 370C050220                      db 55, 12, 5, 2, ' '   
   873 00001EB8 3D0C050220                      db 61, 12, 5, 2, ' '   
   874 00001EBD 430C050220                      db 67, 12, 5, 2, ' '
   875                                  
   876 00001EC2 070D050220                      db 7, 13, 5, 2, ' '   
   877 00001EC7 0D0D050220                      db 13, 13, 5, 2, ' '   
   878 00001ECC 130D050220                      db 19, 13, 5, 2, ' '   
   879 00001ED1 190D050220                      db 25, 13, 5, 2, ' '  
   880 00001ED6 1F0D050220                      db 31, 13, 5, 2, ' '
   881 00001EDB 250D050220                      db 37, 13, 5, 2, ' '
   882 00001EE0 2B0D050220                      db 43, 13, 5, 2, ' '    
   883 00001EE5 310D050220                      db 49, 13, 5, 2, ' '    
   884 00001EEA 370D050220                      db 55, 13, 5, 2, ' '   
   885 00001EEF 3D0D050220                      db 61, 13, 5, 2, ' '   
   886 00001EF4 430D050220                      db 67, 13, 5, 2, ' '
   887                                  
   888                                          
   889 00001EF9 070E050220                      db 7, 14, 5, 2, ' '   
   890 00001EFE 130E050220                      db 19, 14, 5, 2, ' '   
   891 00001F03 190E050220                      db 25, 14, 5, 2, ' '  
   892 00001F08 1F0E050220                      db 31, 14, 5, 2, ' '
   893 00001F0D 250E050220                      db 37, 14, 5, 2, ' '
   894 00001F12 2B0E050220                      db 43, 14, 5, 2, ' '    
   895 00001F17 310E050220                      db 49, 14, 5, 2, ' '    
   896 00001F1C 370E050220                      db 55, 14, 5, 2, ' '   
   897 00001F21 430E050220                      db 67, 14, 5, 2, ' '
   898                                  
   899 00001F26 070F050220                      db 7, 15, 5, 2, ' '   
   900 00001F2B 130F050220                      db 19, 15, 5, 2, ' '      
   901 00001F30 370F050220                      db 55, 15, 5, 2, ' '   
   902 00001F35 430F050220                      db 67, 15, 5, 2, ' '
   903                                   
   904 00001F3A 0710050220                      db 7, 16, 5, 2, ' '   
   905 00001F3F 1310050220                      db 19, 16, 5, 2, ' '      
   906 00001F44 3710050220                      db 55, 16, 5, 2, ' '   
   907 00001F49 4310050220                      db 67, 16, 5, 2, ' '
   908                                  
   909                                  
   910 00001F4E 1911050220                      db 25, 17, 5, 2, ' '  
   911 00001F53 1F11050220                      db 31, 17, 5, 2, ' '
   912 00001F58 2B11050220                      db 43, 17, 5, 2, ' '    
   913 00001F5D 3111050220                      db 49, 17, 5, 2, ' ' 
   914                                  
   915 00001F62 1912050220                      db 25, 18, 5, 2, ' '  
   916 00001F67 1F12050220                      db 31, 18, 5, 2, ' '
   917 00001F6C 2B12050220                      db 43, 18, 5, 2, ' '    
   918 00001F71 3112050220                      db 49, 18, 5, 2, ' ' 
   919                                  
   920                                      level5_blocks_count equ 98
   921                                  
   922                                      ; Array para mantener el estado de los bloques
   923 00001F76 00<rep C8h>                 block_states: times 200 db 0  ; Durabilidad actual de cada bloque
   924                                  
   925                                      
   926                                      ; Variables para almacenar los valores
   927 0000203E 0000000000000000            current_score dq 0          ; Score actual
   928 00002046 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   929                                      
   930                                      ; Buffer para convertir números a string
   931 00002047 00<rep 14h>                 number_buffer: times 20 db 0
   932                                  
   933 0000205B 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   934                                      
   935                                      ; Estructura para los enemigos (x, y, activo)
   936 00002060 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   937 0000207E 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   938                                      
   939 0000207F 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   940 00002087 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   941 00002088 0A                          enemy_move_delay db 10           ; Mover enemigos cada N ciclos
   942 00002089 00                          enemy_move_total db 0      ; Contador total de movimientos
   943 0000208A 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   944 0000208B 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   945                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   946 0000208C 323C464BE4F8788CA0-         level1_spawn_points: db 50, 60, 70, 75, 740, 760, 120, 140, 160, 180    ; 10 enemigos
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946          ******************       warning: byte data exceeds bounds [-w+number-overflow]
   946 00002095 B4                 
   947 00002096 001E3246556E8296AA-         level2_spawn_points: db 0, 30, 50, 70, 85, 110, 130, 150, 170, 190    ; 10 enemigos
   947 0000209F BE                 
   948 000020A0 00000032373C646464-         level3_spawn_points: db 0, 0, 0, 50, 55, 60, 100, 100, 100, 100   ; 10 enemigos
   948 000020A9 64                 
   949 000020AA 00040F1E2832465A64-         level4_spawn_points: db 0, 4, 15, 30, 40, 50, 70, 90, 100, 120  ; 10 enemigos
   949 000020B3 78                 
   950 000020B4 00000A141E2328323C-         level5_spawn_points: db 0, 0, 10, 20, 30, 35, 40, 50, 60, 80 ; 10 enemigos
   950 000020BD 50                 
   951                                          ; Arreglo de punteros a los spawn points de cada nivel
   952                                      spawn_points_table:
   953 000020BE [8C20000000000000]              dq level1_spawn_points
   954 000020C6 [9620000000000000]              dq level2_spawn_points
   955 000020CE [A020000000000000]              dq level3_spawn_points
   956 000020D6 [AA20000000000000]              dq level4_spawn_points
   957 000020DE [B420000000000000]              dq level5_spawn_points
   958                                  
   959                                      ; Variables para el comportamiento de enemigos
   960 000020E6 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   961 000020E7 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   962 000020E8 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   963 000020E9 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   964                                  
   965 000020F3 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   965 000020FC 5B2020202020202020-
   965 00002105 20205D0A0D         
   966                                      score_label_len: equ $ - score_label
   967 0000210A 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   967 00002113 657374727569646F73-
   967 0000211C 3A205B2020205D0A0D 
   968                                      blocks_label_len: equ $ - blocks_label
   969                                      
   970                                      ; Posición donde insertar los números en los labels
   971                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   972                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   973                                      
   974                                      ; Definición de las vidas (x, y, estado)
   975                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   976                                      lives_data: 
   977 00002125 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   978 00002128 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   979 0000212B 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   980 0000212E 081E00                          db 8, 30, 0     ; Vida 4 (inactiva)
   981 00002131 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   982 00002134 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   983 00002137 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   984                                      lives_count equ 7    ; Total de vidas
   985 0000213A 5E                          life_char db "^"    
   986 0000213B 03                          current_lives db 3   ; Contador de vidas activas actual
   987                                  
   988                                  ; Estructura para almacenar las letras y sus posiciones
   989                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   990 0000213C 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   991 000022CC 00                          letters_count db 0   
   992 000022CD 20                          last_letter db ' '    ; Variable para almacenar la última letra
   993 000022CE 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   993 000022D7 75616C3A205B205D0A-
   993 000022E0 0D                 
   994                                      last_letter_msg_len equ $ - last_letter_msg
   995 000022E1 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   996 000022E2 07                          max_lives db 7              ; Máximo número de vidas permitidas
   997 000022E3 0700000000000000            ball_speed dq 7             ; Velocidad normal de la bola
   998 000022EB 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   999 000022F3 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
  1000                                     
  1001 000022FB 00                          initial_catch_active db 0   ; 0 = inactivo, 1 = activo
  1002                                  
  1003 000022FC 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
  1004 000022FD 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
  1005 000022FE 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
  1006 000022FF 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
  1007                                  
  1008 00002300 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
  1009 00002308 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
  1010                                  
  1011 00002309 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
  1012 0000230A 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
  1013 0000230B 00                          laser_count: db 0                ; Contador de láseres activos
  1014 0000230C 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
  1015 000023D4 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
  1016                                  
  1017                                      balls_data:     ; Array para almacenar hasta 3 bolas
  1018                                          ; Bola 1 (principal)
  1019 000023DC 0000000000000000                dq 0        ; x_pos
  1020 000023E4 0000000000000000                dq 0        ; y_pos
  1021 000023EC 0100000000000000                dq 1        ; direction_x
  1022 000023F4 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1023 000023FC 01                              db 1        ; active
  1024                                          ; Bola 2
  1025 000023FD 0000000000000000                dq 0        ; x_pos
  1026 00002405 0000000000000000                dq 0        ; y_pos
  1027 0000240D FFFFFFFFFFFFFFFF                dq -1       ; direction_x
  1028 00002415 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1029 0000241D 00                              db 0        ; active
  1030                                          ; Bola 3
  1031 0000241E 0000000000000000                dq 0        ; x_pos
  1032 00002426 0000000000000000                dq 0        ; y_pos
  1033 0000242E 0000000000000000                dq 0        ; direction_x
  1034 00002436 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1035 0000243E 00                              db 0        ; active
  1036                                      
  1037 0000243F 01                          balls_count db 1     ; Contador de bolas activas
  1038                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
  1039 00002440 00<rep Ah>                  enemy_last_x:       times 10 db 0
  1040 0000244A 00<rep Ah>                  enemy_last_y:       times 10 db 0
  1041 00002454 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
  1042 0000245E 00                          letter_move_counter db 0
  1043                                      initial_ball_offset_x equ 2    ; Offset desde el centro de la paleta
  1044                                      initial_ball_offset_y equ -1   ; Offset vertical desde la paleta
  1045                                  
  1046                                  section .text
  1047                                  
  1048                                  
  1049                                  print_lives:; Función para imprimir las vidas en la parte inferior
  1050 000001DD 55                          push rbp; Guardar el puntero de la base
  1051 000001DE 4889E5                      mov rbp, rsp; Establecer el puntero de la base
  1052                                      
  1053 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
  1054                                      
  1055                                      .print_loop:; Bucle para imprimir todas las vidas
  1056 000001E4 4983FC07                        cmp r12, lives_count; Verificar si se han impreso todas las vidas
  1057 000001E8 7D45                            jge .end; Si se han impreso todas las vidas, terminar
  1058                                          
  1059                                          ; Calcular offset de la vida actual
  1060 000001EA 4C89E0                          mov rax, r12    ; Calcular offset en el arreglo de vidas
  1061 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
  1062 000001F1 488DB0[25210000]                lea rsi, [lives_data + rax]    ; Cargar dirección de la vida actual
  1063                                          
  1064                                          ; Calcular posición en el tablero
  1065 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
  1066 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1067                                          
  1068                                          ; Calcular offset en el tablero
  1069 00000201 B850000000                      mov rax, column_cells        ; Ancho del tablero
  1070 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1071 0000020A 49F7E1                          mul r9                        ; Multiplicar por Y
  1072 0000020D 4C01C0                          add rax, r8                    ; Sumar X
  1073 00000210 488DB8[400A0000]                lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1074                                          
  1075                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
  1076 00000217 807E0201                        cmp byte [rsi + 2], 1     ; Verificar si la vida está activa
  1077 0000021B 7405                            je .draw_active           ; Si está activa, dibujar el carácter de vida 
  1078                                          
  1079                                          ; Si está inactiva, dibujar espacio
  1080 0000021D C60720                          mov byte [rdi], ' '
  1081 00000220 EB08                            jmp .next_life
  1082                                          
  1083                                      .draw_active:
  1084                                          ; Si está activa, dibujar el símbolo de vida
  1085 00000222 8A05(3A210000)                  mov al, [life_char]
  1086 00000228 8807                            mov [rdi], al
  1087                                          
  1088                                      .next_life:
  1089 0000022A 49FFC4                          inc r12
  1090 0000022D EBB5                            jmp .print_loop
  1091                                          
  1092                                      .end:
  1093 0000022F 5D                              pop rbp
  1094 00000230 C3                              ret
  1095                                  
  1096                                  ; Función para desactivar una vida
  1097                                  
  1098                                  lose_life:
  1099 00000231 55                          push rbp    ; Guardar el puntero de la base
  1100 00000232 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1101                                      
  1102                                      ; Verificar si aún quedan vidas
  1103 00000235 803D(3B210000)00            cmp byte [current_lives], 0   ; Verificar si quedan vidas
  1104 0000023C 0F84AB000000                je .game_lost             ; Si no quedan vidas, perder el juego
  1105                                      
  1106                                      ; Encontrar la última vida activa
  1107 00000242 B907000000                  mov rcx, lives_count    ; Cantidad total de vidas
  1108 00000247 48FFC9                      dec rcx               ; Índice de la última vida
  1109                                      
  1110                                      .find_active_life:  ; Bucle para encontrar la última vida activa
  1111 0000024A 4889C8                          mov rax, rcx    ; Calcular offset en el arreglo de vidas
  1112 0000024D 486BC003                        imul rax, 3    ; Cada vida ocupa 3 bytes (x, y, estado)
  1113 00000251 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Cargar dirección de la vida actual
  1114 00000258 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si la vida está activa
  1115 0000025C 740A                            je .deactivate_life   ; Si está activa, desactivarla
  1116 0000025E 48FFC9                          dec rcx   ; Si no está activa, probar con la siguiente vida
  1117 00000261 79E7                            jns .find_active_life   ; Si aún quedan vidas, continuar buscando
  1118 00000263 E985000000                      jmp .game_lost  ; Si no quedan vidas, perder el juego
  1119                                          
  1120                                      .deactivate_life:   ; Desactivar la vida encontrada
  1121                                          ; Borrar vida visualmente y en datos
  1122 00000268 4C0FB606                        movzx r8, byte [rsi]    ; X
  1123 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]    ; Y
  1124 00000271 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1125 00000276 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1126 0000027A 49F7E1                          mul r9  ; Multiplicar por Y
  1127 0000027D 4C01C0                          add rax, r8 ; Sumar X
  1128 00000280 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1129 00000287 C60720                          mov byte [rdi], ' ' ; Borrar visual
  1130 0000028A C6460200                        mov byte [rsi + 2], 0   ; Desactivar vida
  1131 0000028E FE0D(3B210000)                  dec byte [current_lives]    ; Decrementar contador de vidas
  1132                                          
  1133                                          ; Borrar paleta anterior
  1134 00000294 4C8B05(BF140000)                mov r8, [pallet_position]   ; Posición de la paleta
  1135 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]  ; Tamaño de la paleta
  1136                                          .erase_pallet_loop: ; Bucle para borrar la paleta
  1137 000002A2 41C60020                            mov byte [r8], ' '  ; Borrar visualmente
  1138 000002A6 49FFC0                              inc r8  ; Siguiente byte
  1139 000002A9 48FFC9                              dec rcx ; Decrementar contador
  1140 000002AC 75F4                                jnz .erase_pallet_loop  ; Si no se ha borrado toda la paleta, continuar
  1141                                          
  1142                                          ; Reiniciar solo la bola principal
  1143 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40      ; Posición inicial de la bola
  1143 000002B6 000000             
  1144 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28    ; Posición inicial de la bola
  1144 000002C1 000000             
  1145 000002C4 C605(FF140000)00                mov byte [ball_moving], 0   ; Detener la bola
  1146 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
  1147 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1147 000002D9 [B0130000]         
  1148                                          
  1149                                          ; Asegurarse que las otras bolas están desactivadas
  1150 000002DD C605(22150000)00                mov byte [ball2_active], 0  ; Desactivar bola 2
  1151 000002E4 C605(44150000)00                mov byte [ball3_active], 0      ; Desactivar bola 3
  1152                                          
  1153 000002EB EB07                            jmp .end    ; Salir
  1154                                          
  1155                                      .game_lost:
  1156 000002ED E8D5000000                      call game_lost  ; Perder el juego
  1157 000002F2 EB00                            jmp .end    ; Salir
  1158                                          
  1159                                      .end:
  1160 000002F4 5D                              pop rbp   ; Restaurar el puntero de la base
  1161 000002F5 C3                              ret  ; Retornar
  1162                                  ; Función modificada para verificar colisión con el borde inferior
  1163                                  check_bottom_collision:   ; Función para verificar colisión con el borde inferior
  1164 000002F6 55                          push rbp    ; Guardar el puntero de la base
  1165 000002F7 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1166                                      
  1167                                  
  1168                                      ; Verificar bola principal
  1169 000002FA 803D(00150000)01            cmp byte [ball_active], 1   ; Verificar si la bola principal está activa
  1170 00000301 7542                        jne .check_ball2        ; Si no está activa, verificar bola 2
  1171 00000303 488B05(E7140000)            mov rax, [ball_y_pos]   ; Obtener posición Y de la bola principal
  1172 0000030A 4883F81E                    cmp rax, row_cells - 2      ; Verificar si ha llegado al borde inferior
  1173 0000030E 7535                        jne .check_ball2    ; Si no ha llegado al borde, verificar bola 2
  1174                                      
  1175                                      ; Borrar visualmente la bola principal
  1176 00000310 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Obtener posición X de la bola principal
  1177 00000317 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Obtener posición Y de la bola principal
  1178 0000031E 4981C0[400A0000]            add r8, board        ; Calcular dirección en el tablero
  1179 00000325 4C89C9                      mov rcx, r9        ; Calcular offset en el tablero
  1180 00000328 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  1181 0000032D 48F7E9                      imul rcx    ; Multiplicar por Y
  1182 00000330 4901C0                      add r8, rax   ; Sumar X
  1183 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1184                                      
  1185 00000337 C605(00150000)00            mov byte [ball_active], 0   ; Desactivar bola principal
  1186 0000033E C605(FF140000)00            mov byte [ball_moving], 0   ; Detener la bola principal
  1187                                  
  1188                                  .check_ball2:   ; Verificar bola 2
  1189 00000345 803D(22150000)01            cmp byte [ball2_active], 1  ; Verificar si la bola 2 está activa
  1190 0000034C 751B                        jne .check_ball3    ; Si no está activa, verificar bola 3
  1191 0000034E 488B05(09150000)            mov rax, [ball2_y_pos]  ; Obtener
  1192 00000355 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1193 00000359 750E                        jne .check_ball3    ; Si no ha llegado al borde, verificar bola 3
  1194 0000035B C605(22150000)00            mov byte [ball2_active], 0      ; Desactivar bola 2
  1195 00000362 C605(21150000)00            mov byte [ball2_moving], 0    ; Detener bola 2
  1196                                  
  1197                                  .check_ball3:   ; Verificar bola 3
  1198 00000369 803D(44150000)01            cmp byte [ball3_active], 1  ; Verificar si la bola 3 está activa
  1199 00000370 751B                        jne .check_active_balls   ; Si no está activa, verificar bolas activas
  1200 00000372 488B05(2B150000)            mov rax, [ball3_y_pos]  ; Obtener posición Y de la bola 3
  1201 00000379 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1202 0000037D 750E                        jne .check_active_balls  ; Si no ha llegado al borde, verificar bolas activas
  1203 0000037F C605(44150000)00            mov byte [ball3_active], 0  ; Desactivar bola 3
  1204 00000386 C605(43150000)00            mov byte [ball3_moving], 0  ; Detener bola 3
  1205                                  
  1206                                  .check_active_balls:        
  1207                                      ; Verificar si quedan bolas activas
  1208 0000038D 4831C9                      xor rcx, rcx    ; Contar bolas activas
  1209                                      
  1210                                      ; Contar bolas activas
  1211 00000390 8A05(00150000)              mov al, byte [ball_active]  ; Verificar si la bola principal está activa
  1212 00000396 4801C1                      add rcx, rax    ; Sumar al contador
  1213 00000399 8A05(22150000)              mov al, byte [ball2_active] ; Verificar si la bola 2 está activa
  1214 0000039F 4801C1                      add rcx, rax    ; Sumar al contador
  1215 000003A2 8A05(44150000)              mov al, byte [ball3_active] ; Verificar si la bola 3 está activa
  1216 000003A8 4801C1                      add rcx, rax    ; Sumar al contador
  1217                                      
  1218                                      ; Si no hay bolas activas y quedan bloques, perder vida
  1219 000003AB 4885C9                      test rcx, rcx   ; Verificar si hay bolas activas
  1220 000003AE 7515                        jnz .balls_remain   ; Si hay bolas activas, salir
  1221                                      
  1222 000003B0 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Verificar si quedan bloques
  1223 000003B7 740C                        je .balls_remain               ; Si no quedan bloques, no perder vida
  1224                                      
  1225 000003B9 E873FEFFFF                  call lose_life
  1226 000003BE C605(00150000)01            mov byte [ball_active], 1      ; Reactivar bola principal
  1227                                      
  1228                                  .balls_remain:  ; Si quedan bolas, continuar
  1229 000003C5 5D                          pop rbp     ; Restaurar el puntero de la base
  1230 000003C6 C3                          ret    ; Retornar
  1231                                  
  1232                                  ; Nueva función para game over
  1233                                  game_lost:
  1234                                      ; Limpiar la pantalla
  1235                                      print clear, clear_length
    93 000003C7 B801000000          <1>  mov eax, sys_write
    94 000003CC BF01000000          <1>  mov edi, 1
    95 000003D1 48BE-               <1>  mov rsi, %1
    95 000003D3 [1000000000000000]  <1>
    96 000003DB BA07000000          <1>  mov edx, %2
    97 000003E0 0F05                <1>  syscall
  1236                                      
  1237                                      ; Mostrar mensaje de derrota
  1238                                      section .data   
  1239 0000245F C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
  1239 00002468 6469646F210A0D     
  1240                                          lost_msg_len: equ $ - lost_msg
  1241                                      section .text
  1242                                      
  1243                                      ; Imprimir mensaje de derrota
  1244                                      print lost_msg, lost_msg_len    ; Imprimir mensaje
    93 000003E2 B801000000          <1>  mov eax, sys_write
    94 000003E7 BF01000000          <1>  mov edi, 1
    95 000003EC 48BE-               <1>  mov rsi, %1
    95 000003EE [5F24000000000000]  <1>
    96 000003F6 BA10000000          <1>  mov edx, %2
    97 000003FB 0F05                <1>  syscall
  1245                                      print score_msg, score_msg_len  ; Imprimir puntaje
    93 000003FD B801000000          <1>  mov eax, sys_write
    94 00000402 BF01000000          <1>  mov edi, 1
    95 00000407 48BE-               <1>  mov rsi, %1
    95 00000409 [8D24000000000000]  <1>
    96 00000411 BA0F000000          <1>  mov edx, %2
    97 00000416 0F05                <1>  syscall
  1246                                      
  1247                                      ; Mostrar puntaje final
  1248 00000418 488B05(3E200000)            mov rax, [current_score]    ; Cargar puntaje
  1249 0000041F 48BF-                       mov rdi, number_buffer  ; Buffer para convertir a string
  1249 00000421 [4720000000000000] 
  1250 00000429 E838150000                  call number_to_string   ; Convertir a string
  1251                                      print number_buffer, 20 ; Imprimir puntaje
    93 0000042E B801000000          <1>  mov eax, sys_write
    94 00000433 BF01000000          <1>  mov edi, 1
    95 00000438 48BE-               <1>  mov rsi, %1
    95 0000043A [4720000000000000]  <1>
    96 00000442 BA14000000          <1>  mov edx, %2
    97 00000447 0F05                <1>  syscall
  1252                                      
  1253                                      ; Esperar un momento antes de salir
  1254 00000449 48C705ACFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1254 00000452 0000               
  1255 00000454 48C705A9FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1255 0000045D 0000               
  1256                                      sleeptime
   109 0000045F B823000000          <1>  mov eax, sys_nanosleep
   110 00000464 48BF-               <1>  mov rdi, timespec
   110 00000466 [0000000000000000]  <1>
   111 0000046E 31F6                <1>  xor esi, esi
   112 00000470 0F05                <1>  syscall
  1257                                      
  1258 00000472 E96D1F0000                  jmp exit
  1259                                  
  1260                                  
  1261                                  ; Función para registrar una nueva letra en el mapa
  1262                                  ; Entrada:
  1263                                  ;   al - letra a registrar
  1264                                  ;   r8b - posición x
  1265                                  ;   r9b - posición y
  1266                                  register_letter:        
  1267 00000477 55                          push rbp    ; Guardar el puntero de la base
  1268 00000478 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1269 0000047B 53                          push rbx    ; Guardar registros
  1270 0000047C 51                          push rcx    ; Guardar registros
  1271                                      
  1272 0000047D 3C20                        cmp al, ' '   ; Verificar si es un espacio
  1273 0000047F 7438                        je .end      ; Si es un espacio, salir
  1274                                  
  1275                                      ; Encontrar un espacio libre en el mapa
  1276 00000481 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1277 00000484 480FB615(CC220000)          movzx rdx, byte [letters_count] ; Cantidad de letras registradas
  1278                                      
  1279                                      .find_slot:
  1280 0000048C 4883F964                        cmp rcx, 100              ; Máximo de letras
  1281 00000490 7D27                            jge .end                  ; Si no hay espacio, salir
  1282                                          
  1283 00000492 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1284 0000049A 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
  1285 0000049E 7405                            je .found_slot
  1286                                          
  1287 000004A0 48FFC1                          inc rcx   ; Probar con la siguiente letra
  1288 000004A3 EBE7                            jmp .find_slot  ; Continuar buscando
  1289                                          
  1290                                      .found_slot:
  1291                                          ; Guardar la información de la letra
  1292 000004A5 448803                          mov [rbx], r8b           ; x
  1293 000004A8 44884B01                        mov [rbx + 1], r9b       ; y
  1294 000004AC 884302                          mov [rbx + 2], al        ; letra
  1295 000004AF C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
  1296                                          
  1297 000004B3 FE05(CC220000)                  inc byte [letters_count]
  1298                                          
  1299                                      .end:
  1300 000004B9 59                              pop rcx
  1301 000004BA 5B                              pop rbx
  1302 000004BB 5D                              pop rbp
  1303 000004BC C3                              ret
  1304                                  
  1305                                  ; Función para imprimir todas las letras registradas
  1306                                  print_letters:
  1307 000004BD 55                          push rbp        ; Guardar el puntero de la base
  1308 000004BE 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1309 000004C1 53                          push rbx    ; Guardar registros
  1310 000004C2 51                          push rcx    ; Guardar registros
  1311                                      
  1312 000004C3 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1313                                      
  1314                                      .print_loop:
  1315 000004C6 4883F964                        cmp rcx, 100              ; Máximo de letras
  1316 000004CA 7D37                            jge .end              ; Si no hay más letras, salir
  1317                                          
  1318                                          ; Obtener puntero a la letra actual
  1319 000004CC 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]
  1320                                          
  1321                                          ; Verificar si está activa
  1322 000004D4 807B0300                        cmp byte [rbx + 3], 0
  1323 000004D8 7424                            je .next_letter
  1324                                          
  1325                                          ; Calcular posición en el tablero
  1326 000004DA 4C0FB603                        movzx r8, byte [rbx]      ; x
  1327 000004DE 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
  1328                                          
  1329                                          ; Calcular offset en el tablero
  1330 000004E3 B850000000                      mov rax, column_cells
  1331 000004E8 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
  1332 000004EC 49F7E1                          mul r9
  1333 000004EF 4C01C0                          add rax, r8
  1334 000004F2 488DB8[400A0000]                lea rdi, [board + rax]  ; Dirección en el tablero
  1335                                          
  1336                                          ; Imprimir la letra
  1337 000004F9 8A4302                          mov al, [rbx + 2]   ; Obtener la letra
  1338 000004FC 8807                            mov [rdi], al    ; Imprimir la letra
  1339                                          
  1340                                      .next_letter:
  1341 000004FE 48FFC1                          inc rcx   ; Siguiente letra
  1342 00000501 EBC3                            jmp .print_loop ; Continuar imprimiendo
  1343                                          
  1344                                      .end:
  1345 00000503 59                              pop rcx   ; Restaurar registros
  1346 00000504 5B                              pop rbx  ; Restaurar registros
  1347 00000505 5D                              pop rbp ; Restaurar el puntero de la base
  1348 00000506 C3                              ret   ; Retornar
  1349                                  
  1350                                  ; Función para borrar una letra específica
  1351                                  ; Entrada:
  1352                                  ;   r8b - posición x
  1353                                  ;   r9b - posición y
  1354                                  remove_letter:
  1355 00000507 55                          push rbp
  1356 00000508 4889E5                      mov rbp, rsp
  1357 0000050B 53                          push rbx    ; Guardar registros
  1358 0000050C 51                          push rcx    ; Guardar registros
  1359                                      
  1360 0000050D 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1361                                      
  1362                                      .find_loop:     
  1363 00000510 4883F964                        cmp rcx, 100              ; Máximo de letras
  1364 00000514 7D2E                            jge .end
  1365                                          
  1366 00000516 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1367                                          
  1368                                          ; Verificar si está activa y coincide la posición
  1369 0000051E 807B0300                        cmp byte [rbx + 3], 0
  1370 00000522 741B                            je .next_letter   ; Si no está activa, probar con la siguiente letra
  1371                                          
  1372 00000524 8A03                            mov al, [rbx]   ; x
  1373 00000526 4438C0                          cmp al, r8b    ; Verificar si coincide la posición x
  1374 00000529 7514                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1375                                          
  1376 0000052B 8A4301                          mov al, [rbx + 1]   ; y
  1377 0000052E 4438C8                          cmp al, r9b   ; Verificar si coincide la posición y
  1378 00000531 750C                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1379                                          
  1380                                          ; Encontrada la letra, desactivarla 
  1381 00000533 C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1382 00000537 FE0D(CC220000)                  dec byte [letters_count]        ; Decrementar contador de letras
  1383 0000053D EB05                            jmp .end
  1384                                          
  1385                                      .next_letter:
  1386 0000053F 48FFC1                          inc rcx  ; Siguiente letra
  1387 00000542 EBCC                            jmp .find_loop  ; Continuar buscando
  1388                                          
  1389                                      .end:
  1390 00000544 59                              pop rcx
  1391 00000545 5B                              pop rbx
  1392 00000546 5D                              pop rbp
  1393 00000547 C3                              ret
  1394                                  ; Función para mover las letras hacia abajo
  1395                                  move_letters:
  1396 00000548 55                          push rbp    ; Guardar el puntero de la base
  1397 00000549 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1398 0000054C 53                          push rbx    ; Guardar registros
  1399 0000054D 57                          push rdi    ; Guardar registros
  1400 0000054E 56                          push rsi    ; Guardar registros
  1401 0000054F 4150                        push r8    ; Guardar registros
  1402 00000551 4151                        push r9   ; Guardar registros
  1403 00000553 4152                        push r10    ; Guardar registros
  1404 00000555 4153                        push r11    ; Guardar registros
  1405                                  
  1406 00000557 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1407                                  
  1408                                      ; Verificar si debemos mover la letra en este frame
  1409 0000055A FE05(5E240000)              inc byte [letter_move_counter]    ; Incrementar contador
  1410 00000560 803D(5E240000)0B            cmp byte [letter_move_counter], 11 ; Ajusta este número para cambiar velocidad
  1411 00000567 0F8C20020000                jl .skip_all                         ; Si no es momento de mover, terminar
  1412 0000056D C605(5E240000)00            mov byte [letter_move_counter], 0 ; Resetear contador
  1413                                  
  1414                                      .move_loop:
  1415 00000574 4883F964                        cmp rcx, 100          ; Máximo de letras, se hace esta verificacion porque se pueden borrar letras
  1416 00000578 0F8D0D020000                    jge .print_last_letter  ; Si no hay más letras, imprimir la última letra
  1417                                          
  1418 0000057E 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1419 00000586 807B0300                        cmp byte [rbx + 3], 0   ; Verificar si está activa
  1420 0000058A 0F84F3010000                    je .next_letter       ; Si no está activa, probar con la siguiente letra
  1421                                  
  1422 00000590 4C0FB603                        movzx r8, byte [rbx]    ; x
  1423 00000594 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1424                                  
  1425 00000599 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1426 0000059E 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1427 000005A2 49F7E1                          mul r9  ; Multiplicar por Y
  1428 000005A5 4C01C0                          add rax, r8 ; Sumar X
  1429 000005A8 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1430 000005AF C60720                          mov byte [rdi], ' ' ; Borrar visualmente la letra
  1431                                  
  1432 000005B2 FE4301                          inc byte [rbx + 1]  ; Mover la letra hacia abajo
  1433 000005B5 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1434                                  
  1435 000005BA 4983F91F                        cmp r9, row_cells - 1   ; Verificar si ha llegado al borde inferior
  1436 000005BE 7C09                            jl .check_pallet_collision  ; Si no ha llegado al borde, verificar colisión con la paleta
  1437                                  
  1438 000005C0 C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1439 000005C4 E9BA010000                      jmp .next_letter    ; Probar con la siguiente letra
  1440                                  
  1441                                          .check_pallet_collision:    ; Verificar colisión con la paleta
  1442 000005C9 B850000000                          mov rax, column_cells   ; Ancho del tablero
  1443 000005CE 4883C002                            add rax, 2  ; Incluir caracteres de nueva línea
  1444 000005D2 49F7E1                              mul r9  ; Multiplicar por Y
  1445 000005D5 4C01C0                              add rax, r8 ; Sumar X
  1446 000005D8 488DB8[400A0000]                    lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1447                                  
  1448 000005DF 8A07                                mov al, [rdi]   ; Obtener el carácter actual
  1449 000005E1 3C20                                cmp al, ' '  ; Verificar si es un espacio
  1450 000005E3 0F849A010000                        je .next_letter ; Si es un espacio, probar con la siguiente letra
  1451 000005E9 3C3D                                cmp al, char_equal  ; Verificar si es la paleta
  1452 000005EB 740A                                je .capture_letter  ; Si es la paleta, capturar la letra
  1453                                  
  1454 000005ED 8A4302                              mov al, [rbx + 2]   ; Obtener la letra
  1455 000005F0 8807                                mov [rdi], al   ; Imprimir la letra
  1456 000005F2 E98C010000                          jmp .next_letter    ; Probar con la siguiente letra
  1457                                  
  1458                                          .capture_letter:    ; Capturar la letra
  1459                                              ; Obtener la nueva letra
  1460 000005F7 8A4302                              mov al, [rbx + 2]
  1461                                              
  1462                                              ; Comparar con la última letra
  1463 000005FA 3A05(CD220000)                      cmp al, [last_letter]
  1464 00000600 7407                                je .same_letter
  1465                                              
  1466                                              ; Es una letra diferente, resetear el procesamiento
  1467 00000602 C605(E1220000)00                    mov byte [current_power_processed], 0
  1468                                              
  1469                                              .same_letter:
  1470                                              ; Guardar la nueva letra
  1471 00000609 8805(CD220000)                      mov [last_letter], al
  1472                                              
  1473                                              ; Verificar si es 'E' para extender la paleta
  1474 0000060F 3C45                                cmp al, 'E'
  1475 00000611 7450                                je .extend_pallet
  1476                                              
  1477                                              ; Verificar si es 'P' para añadir vida
  1478 00000613 3C50                                cmp al, 'P'
  1479 00000615 7478                                je .check_add_life
  1480                                  
  1481 00000617 3C53                                cmp al, 'S'
  1482 00000619 0F84B4000000                        je .slow_ball
  1483                                  
  1484 0000061F 3C43                                cmp al, 'C'
  1485 00000621 0F84D8000000                        je .activate_catch
  1486                                              
  1487 00000627 3C4C                                cmp al, 'L'
  1488 00000629 0F84F9000000                        je .activate_laser
  1489                                  
  1490 0000062F 3C44                                cmp al, 'D'
  1491 00000631 0F841A010000                        je .activate_split
  1492                                  
  1493                                              ; Si no es ningún power-up, restaurar tamaño normal
  1494 00000637 488B05(CF140000)                    mov rax, [default_pallet_size]
  1495 0000063E 488905(C7140000)                    mov [pallet_size], rax
  1496 00000645 48C705(E3220000)07-                 mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1496 0000064D 000000             
  1497 00000650 C605(FC220000)00                    mov byte [catch_power_active], 0
  1498 00000657 C605(09230000)00                    mov byte [laser_power_active], 0
  1499 0000065E E91C010000                          jmp .finish_capture
  1500                                  
  1501                                              .extend_pallet:
  1502 00000663 C605(09230000)00                        mov byte [laser_power_active], 0
  1503 0000066A C605(FC220000)00                        mov byte [catch_power_active], 0
  1504 00000671 48C705(E3220000)07-                     mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1504 00000679 000000             
  1505 0000067C 488B05(D7140000)                        mov rax, [extended_pallet_size]
  1506 00000683 488905(C7140000)                        mov [pallet_size], rax
  1507 0000068A E9F0000000                              jmp .finish_capture
  1508                                  
  1509                                              .check_add_life:
  1510 0000068F C605(09230000)00                        mov byte [laser_power_active], 0
  1511 00000696 C605(FC220000)00                        mov byte [catch_power_active], 0
  1512 0000069D 488B05(CF140000)                        mov rax, [default_pallet_size]
  1513 000006A4 488905(C7140000)                        mov [pallet_size], rax
  1514 000006AB 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1514 000006B3 000000             
  1515                                                  ; Verificar si ya procesamos este power-up
  1516 000006B6 803D(E1220000)00                        cmp byte [current_power_processed], 0
  1517 000006BD 0F85BC000000                            jne .finish_capture
  1518                                                  
  1519                                                  ; Preservar registros importantes
  1520 000006C3 51                                      push rcx
  1521 000006C4 53                                      push rbx
  1522                                                  
  1523                                                  ; Marcar como procesado
  1524 000006C5 C605(E1220000)01                        mov byte [current_power_processed], 1
  1525                                                  
  1526                                                  ; Añadir una vida
  1527 000006CC E8A8040000                              call add_life
  1528                                                  
  1529                                                  ; Restaurar registros
  1530 000006D1 5B                                      pop rbx
  1531 000006D2 59                                      pop rcx
  1532                                                  
  1533                                              .slow_ball:
  1534 000006D3 C605(09230000)00                        mov byte [laser_power_active], 0
  1535 000006DA C605(FC220000)00                        mov byte [catch_power_active], 0                
  1536 000006E1 488B05(CF140000)                        mov rax, [default_pallet_size]
  1537 000006E8 488905(C7140000)                        mov [pallet_size], rax
  1538 000006EF 48C705(E3220000)0A-                     mov qword [ball_speed], 10    ; Activar velocidad lenta
  1538 000006F7 000000             
  1539 000006FA E980000000                              jmp .finish_capture
  1540                                  
  1541                                              .activate_catch:
  1542 000006FF C605(09230000)00                        mov byte [laser_power_active], 0
  1543 00000706 488B05(CF140000)                        mov rax, [default_pallet_size]
  1544 0000070D 488905(C7140000)                        mov [pallet_size], rax
  1545 00000714 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1545 0000071C 000000             
  1546 0000071F C605(FC220000)01                        mov byte [catch_power_active], 1
  1547 00000726 EB57                                    jmp .finish_capture
  1548                                  
  1549                                              .activate_laser:
  1550 00000728 C605(FC220000)00                        mov byte [catch_power_active], 0
  1551 0000072F 488B05(CF140000)                        mov rax, [default_pallet_size]
  1552 00000736 488905(C7140000)                        mov [pallet_size], rax
  1553 0000073D 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1553 00000745 000000             
  1554 00000748 C605(09230000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1555 0000074F EB2E                                    jmp .finish_capture
  1556                                  
  1557                                              .activate_split:
  1558 00000751 C605(09230000)00                        mov byte [laser_power_active], 0
  1559 00000758 C605(FC220000)00                        mov byte [catch_power_active], 0
  1560 0000075F 488B05(CF140000)                        mov rax, [default_pallet_size]
  1561 00000766 488905(C7140000)                        mov [pallet_size], rax
  1562 0000076D 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1562 00000775 000000             
  1563 00000778 E8DF000000                              call activate_split_power
  1564 0000077D EB00                                    jmp .finish_capture
  1565                                  
  1566                                              .finish_capture:
  1567 0000077F C6430300                                mov byte [rbx + 3], 0
  1568                                  
  1569                                          .next_letter:
  1570 00000783 48FFC1                              inc rcx
  1571 00000786 E9E9FDFFFF                          jmp .move_loop
  1572                                  
  1573                                      .print_last_letter:
  1574                                          ; ;; en vez de imprimir, saltamos
  1575 0000078B EB0D                            jmp .end
  1576                                  
  1577                                  
  1578                                      .skip_all:                        ; Nueva etiqueta para saltar todo cuando no movemos
  1579 0000078D 415B                            pop r11                       ; Restaurar registros
  1580 0000078F 415A                            pop r10                      ; Restaurar registros
  1581 00000791 4159                            pop r9
  1582 00000793 4158                            pop r8
  1583 00000795 5E                              pop rsi
  1584 00000796 5F                              pop rdi
  1585 00000797 5B                              pop rbx
  1586 00000798 5D                              pop rbp
  1587 00000799 C3                              ret
  1588                                  
  1589                                      .end:
  1590 0000079A 415B                            pop r11
  1591 0000079C 415A                            pop r10
  1592 0000079E 4159                            pop r9
  1593 000007A0 4158                            pop r8
  1594 000007A2 5E                              pop rsi
  1595 000007A3 5F                              pop rdi
  1596 000007A4 5B                              pop rbx
  1597 000007A5 5D                              pop rbp
  1598 000007A6 C3                              ret
  1599                                  
  1600                                  print_power_label:  ; Función para imprimir el mensaje de poder actual
  1601 000007A7 55                          push rbp
  1602 000007A8 4889E5                      mov  rbp, rsp
  1603                                      
  1604                                      ; Crear buffer temporal
  1605 000007AB 4883EC20                    sub rsp, 32
  1606                                      
  1607                                      ; Copiar el mensaje base al buffer
  1608 000007AF 4889E7                      mov rdi, rsp
  1609 000007B2 48BE-                       mov rsi, last_letter_msg
  1609 000007B4 [CE22000000000000] 
  1610 000007BC B913000000                  mov rcx, last_letter_msg_len
  1611 000007C1 F3A4                        rep movsb
  1612                                      
  1613                                      ; Insertar la última letra capturada
  1614 000007C3 8A05(CD220000)              mov al, [last_letter]
  1615 000007C9 8844240F                    mov byte [rsp + 15], al    ; Asumiendo que 15 es la posición correcta
  1616                                      
  1617                                      ; Imprimir el buffer completo
  1618                                      print rsp, last_letter_msg_len
    93 000007CD B801000000          <1>  mov eax, sys_write
    94 000007D2 BF01000000          <1>  mov edi, 1
    95 000007D7 4889E6              <1>  mov rsi, %1
    96 000007DA BA13000000          <1>  mov edx, %2
    97 000007DF 0F05                <1>  syscall
  1619                                      
  1620                                      ; Restaurar stack
  1621 000007E1 4883C420                    add rsp, 32
  1622 000007E5 5D                          pop rbp
  1623 000007E6 C3                          ret
  1624                                  
  1625                                  clear_lasers:
  1626 000007E7 55                          push rbp
  1627 000007E8 4889E5                      mov  rbp, rsp
  1628                                  
  1629                                      ; Recorrer el array de láseres
  1630 000007EB 4831C9                      xor rcx, rcx                ; Índice del láser
  1631 000007EE 480FB61D(0B230000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1632                                  
  1633                                      .clear_loop:
  1634 000007F6 4839D9                          cmp rcx, rbx
  1635 000007F9 7D2F                            jge .done                ; Salir si no quedan láseres
  1636                                  
  1637                                          ; Obtener posición del láser actual
  1638 000007FB 488DB409[0C230000]              lea rsi, [lasers + rcx * 2]
  1639 00000803 4C0FB606                        movzx r8, byte [rsi]     ; X
  1640 00000807 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1641                                  
  1642                                          ; Calcular posición en el tablero
  1643 0000080C B850000000                      mov rax, column_cells
  1644 00000811 4883C002                        add rax, 2
  1645 00000815 49F7E1                          mul r9
  1646 00000818 4C01C0                          add rax, r8
  1647 0000081B 488DB8[400A0000]                lea rdi, [board + rax]
  1648                                  
  1649                                          ; Borrar el láser visualmente
  1650 00000822 C60720                          mov byte [rdi], ' '
  1651                                  
  1652                                          ; Pasar al siguiente láser
  1653 00000825 48FFC1                          inc rcx
  1654 00000828 EBCC                            jmp .clear_loop
  1655                                  
  1656                                      .done:
  1657                                          ; Resetear contador de láseres
  1658 0000082A C605(0B230000)00                mov byte [laser_count], 0
  1659                                  
  1660 00000831 5D                              pop rbp
  1661 00000832 C3                              ret
  1662                                  
  1663                                  
  1664                                  ; Nueva función para actualizar los láseres
  1665                                  update_lasers:
  1666 00000833 55                          push rbp
  1667 00000834 4889E5                      mov rbp, rsp
  1668                                      
  1669                                      ; Verificar si el poder láser está activo
  1670 00000837 803D(09230000)00            cmp byte [laser_power_active], 0
  1671 0000083E 741A                        je .end
  1672                                      
  1673                                      ; Verificar si se presionó la tecla de espacio
  1674 00000840 803D(08230000)20            cmp byte [last_key], ' '
  1675 00000847 750C                        jne .skip_shooting
  1676                                      
  1677                                      ; Disparar nuevos láseres
  1678 00000849 E8FD000000                  call shoot_lasers
  1679 0000084E C605(08230000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1680                                      
  1681                                      .skip_shooting:
  1682                                      ; Mover los láseres existentes
  1683 00000855 E88B010000                  call move_lasers
  1684                                      
  1685                                      .end:
  1686 0000085A 5D                              pop rbp
  1687 0000085B C3                              ret
  1688                                  
  1689                                  activate_split_power:; Función para activar el poder de división de bolas
  1690 0000085C 55                          push rbp    ; Guardar el puntero de la base
  1691 0000085D 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1692 00000860 50                          push rax    ; Guardar registros
  1693 00000861 53                          push rbx    
  1694 00000862 51                          push rcx
  1695 00000863 52                          push rdx
  1696                                      
  1697                                      ; Si ambas bolas extra ya están activas, salimos
  1698 00000864 8A0D(22150000)              mov cl, byte [ball2_active]
  1699 0000086A 220D(44150000)              and cl, byte [ball3_active]
  1700 00000870 80F901                      cmp cl, 1   ; Verificar si ambas bolas están activas
  1701 00000873 0F84CC000000                je .end   ; Si ambas bolas están activas, salir
  1702                                      
  1703                                  .find_active_ball:
  1704                                      ; Guardar posición de la bola activa
  1705 00000879 4831C0                      xor rax, rax    ; Limpiar rax
  1706 0000087C 4831DB                      xor rbx, rbx    ; Limpiar rbx
  1707                                      
  1708                                      ; Revisar ball1
  1709 0000087F 803D(00150000)01            cmp byte [ball_active], 1
  1710 00000886 7417                        je .use_ball1
  1711                                      
  1712                                      ; Revisar ball2
  1713 00000888 803D(22150000)01            cmp byte [ball2_active], 1
  1714 0000088F 741E                        je .use_ball2
  1715                                      
  1716                                      ; Revisar ball3
  1717 00000891 803D(44150000)01            cmp byte [ball3_active], 1
  1718 00000898 7425                        je .use_ball3
  1719                                      
  1720 0000089A E9A6000000                  jmp .end        ; Si no hay bolas activas, salimos
  1721                                  
  1722                                  .use_ball1:
  1723 0000089F 488B05(DF140000)            mov rax, qword [ball_x_pos]; Cargar posición de la bola principal
  1724 000008A6 488B1D(E7140000)            mov rbx, qword [ball_y_pos]     ; Cargar posición de la bola principal
  1725 000008AD EB20                        jmp .create_missing_balls
  1726                                  
  1727                                  .use_ball2:
  1728 000008AF 488B05(01150000)            mov rax, qword [ball2_x_pos]    ; Cargar posición de la bola 2
  1729 000008B6 488B1D(09150000)            mov rbx, qword [ball2_y_pos]    ; Cargar posición de la bola 2
  1730 000008BD EB10                        jmp .create_missing_balls
  1731                                  
  1732                                  .use_ball3:
  1733 000008BF 488B05(23150000)            mov rax, qword [ball3_x_pos]    ; Cargar posición de la bola 3
  1734 000008C6 488B1D(2B150000)            mov rbx, qword [ball3_y_pos]    ; Cargar posición de la bola 3
  1735 000008CD EB00                        jmp .create_missing_balls
  1736                                  
  1737                                  .create_missing_balls:
  1738                                      ; Intentar crear ball2 si no está activa    
  1739 000008CF 803D(22150000)01            cmp byte [ball2_active], 1
  1740 000008D6 7432                        je .create_ball3    ; Si ball2 ya está activa, intentar crear ball3
  1741                                      
  1742                                      ; Crear ball2
  1743 000008D8 488905(01150000)            mov qword [ball2_x_pos], rax    ; Copiar posición de la bola activa
  1744 000008DF 48891D(09150000)            mov qword [ball2_y_pos], rbx    ; Copiar posición de la bola activa
  1745 000008E6 48C705(11150000)FF-         mov qword [ball2_direction_x], -1   ; Dirección opuesta
  1745 000008EE FFFFFF             
  1746 000008F1 48C705(19150000)FF-         mov qword [ball2_direction_y], -1   ; Dirección opuesta
  1746 000008F9 FFFFFF             
  1747 000008FC C605(21150000)01            mov byte [ball2_moving], 1  ; Activar movimiento
  1748 00000903 C605(22150000)01            mov byte [ball2_active], 1  ; Activar bola2
  1749                                      
  1750                                  .create_ball3:
  1751                                      ; Intentar crear ball3 si no está activa
  1752 0000090A 803D(44150000)01            cmp byte [ball3_active], 1
  1753 00000911 7432                        je .end
  1754                                      
  1755                                      ; Crear ball3
  1756 00000913 488905(23150000)            mov qword [ball3_x_pos], rax    ; Copiar posición de la bola activa
  1757 0000091A 48891D(2B150000)            mov qword [ball3_y_pos], rbx    ; Copiar posición de la bola activa
  1758 00000921 48C705(33150000)01-         mov qword [ball3_direction_x], 1    ; Dirección opuesta
  1758 00000929 000000             
  1759 0000092C 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1       ; Dirección opuesta
  1759 00000934 FFFFFF             
  1760 00000937 C605(43150000)01            mov byte [ball3_moving], 1
  1761 0000093E C605(44150000)01            mov byte [ball3_active], 1  
  1762                                  
  1763                                  .end:
  1764 00000945 5A                          pop rdx   ; Restaurar registros
  1765 00000946 59                          pop rcx
  1766 00000947 5B                          pop rbx
  1767 00000948 58                          pop rax
  1768 00000949 5D                          pop rbp
  1769 0000094A C3                          ret
  1770                                  
  1771                                  
  1772                                  shoot_lasers:   ; Función para disparar láseres
  1773 0000094B 55                          push rbp    ; Guardar el puntero de la base
  1774 0000094C 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1775 0000094F 53                          push rbx
  1776                                      
  1777                                      ; Verificar si hay espacio para más láseres
  1778 00000950 480FB605(0B230000)          movzx rax, byte [laser_count]
  1779 00000958 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1780 0000095C 0F8D80000000                jge .end
  1781                                      
  1782                                      ; Obtener posición de la paleta
  1783 00000962 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición de la paleta
  1784 00000969 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1785                                      
  1786                                      ; Calcular coordenadas x,y
  1787 00000970 4C89C0                      mov rax, r8                 ; Posición de la paleta
  1788 00000973 41B950000000                mov r9, column_cells    ; Ancho del tablero
  1789 00000979 4983C102                    add r9, 2                     ; Ancho total de línea
  1790 0000097D 4831D2                      xor rdx, rdx             ; Limpiar rdx
  1791 00000980 49F7F1                      div r9                        ; rax = y, rdx = x
  1792                                      
  1793                                      ; Guardar coordenadas
  1794 00000983 4989C2                      mov r10, rax                  ; Y en r10
  1795 00000986 4989D3                      mov r11, rdx                  ; X en r11
  1796                                      
  1797                                      ; Validar coordenadas
  1798 00000989 4983FA00                    cmp r10, 0  ; Verificar si está en la primera fila
  1799 0000098D 7C53                        jl .end   ; Si está en la primera fila, salir
  1800 0000098F 4983FA20                    cmp r10, row_cells  ; Verificar si está en la última fila
  1801 00000993 7D4D                        jge .end    ; Si está en la última fila, salir
  1802 00000995 4983FB00                    cmp r11, 0  ; Verificar si está en la primera columna
  1803 00000999 7C47                        jl .end  ; Si está en la primera columna, salir
  1804 0000099B 4983FB50                    cmp r11, column_cells   ; Verificar si está en la última columna
  1805 0000099F 7D41                        jge .end    ; Si está en la última columna, salir
  1806                                      
  1807                                      ; Calcular índice para el primer láser
  1808 000009A1 480FB61D(0B230000)          movzx rbx, byte [laser_count]
  1809 000009A9 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1810                                      
  1811                                      ; Primer láser (izquierda)
  1812 000009AD 488DBB[0C230000]            lea rdi, [lasers + rbx]   ; Dirección del láser
  1813 000009B4 44881F                      mov [rdi], r11b              ; X
  1814 000009B7 4488D0                      mov al, r10b              ; Y - 1
  1815 000009BA FEC8                        dec al                       ; Y - 1
  1816 000009BC 884701                      mov [rdi + 1], al           ; Y
  1817                                      
  1818                                      ; Segundo láser (derecha)
  1819 000009BF 4488D8                      mov al, r11b
  1820 000009C2 0205(C7140000)              add al, byte [pallet_size]  ; X + tamaño de la paleta
  1821 000009C8 FEC8                        dec al                       ; Ajustar para el último carácter
  1822 000009CA 488DBB[0E230000]            lea rdi, [lasers + rbx + 2]
  1823 000009D1 8807                        mov [rdi], al               ; X
  1824 000009D3 4488D0                      mov al, r10b
  1825 000009D6 FEC8                        dec al                      ; Y - 1
  1826 000009D8 884701                      mov [rdi + 1], al          ; Y
  1827                                      
  1828                                      ; Incrementar contador de láseres
  1829 000009DB 8005(0B230000)02            add byte [laser_count], 2
  1830                                      
  1831                                      
  1832                                      .end:
  1833 000009E2 5B                              pop rbx
  1834 000009E3 5D                              pop rbp
  1835 000009E4 C3                              ret
  1836                                  
  1837                                  ; ============================================================
  1838                                  ; NUEVA FUNCIÓN move_lasers 
  1839                                  ; ============================================================
  1840                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1841                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1842                                  ; ============================================================
  1843                                  move_lasers:
  1844 000009E5 55                          push rbp
  1845 000009E6 4889E5                      mov  rbp, rsp
  1846 000009E9 53                          push rbx
  1847 000009EA 57                          push rdi
  1848 000009EB 56                          push rsi
  1849 000009EC 4154                        push r12
  1850 000009EE 4155                        push r13
  1851 000009F0 4156                        push r14
  1852 000009F2 4157                        push r15
  1853                                  
  1854                                      ; 1) Tomamos la cantidad de láseres
  1855 000009F4 480FB60D(0B230000)          movzx rcx, byte [laser_count]
  1856 000009FC 4885C9                      test rcx, rcx
  1857 000009FF 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1858                                  
  1859                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1860 00000A05 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1861                                  
  1862                                  .loop_lasers:
  1863                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1864 00000A08 488DB409[0C230000]          lea rsi, [lasers + rcx*2]
  1865                                  
  1866                                      ; 2) Cargar x,y actuales del láser
  1867 00000A10 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1868 00000A14 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1869                                  
  1870                                      ; 3) Borrar el láser de su posición actual en pantalla
  1871                                      ;    (por si en el ciclo anterior se había dibujado)
  1872 00000A19 B850000000                  mov rax, column_cells
  1873 00000A1E 4883C002                    add rax, 2
  1874 00000A22 49F7E1                      mul r9
  1875 00000A25 4C01C0                      add rax, r8
  1876 00000A28 488DB8[400A0000]            lea rdi, [board + rax]
  1877 00000A2F C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1878                                  
  1879                                      ; 4) Mover el láser hacia arriba (y - 1)
  1880 00000A32 49FFC9                      dec r9
  1881                                  
  1882                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1883 00000A35 4983F901                    cmp r9, 1
  1884 00000A39 7C57                        jl .delete_laser
  1885                                  
  1886                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1887 00000A3B 44884E01                    mov byte [rsi + 1], r9b
  1888                                  
  1889                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1890                                      ;    - Primero colisión con bloques
  1891                                      ; ---------------------------------------------------------
  1892                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1893 00000A3F B850000000                  mov rax, column_cells
  1894 00000A44 4883C002                    add rax, 2
  1895 00000A48 49F7E1                      mul r9
  1896 00000A4B 4C01C0                      add rax, r8
  1897 00000A4E 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1898                                  
  1899                                      ; Revisar si hay bloque
  1900 00000A55 51                          push rcx
  1901 00000A56 56                          push rsi
  1902 00000A57 57                          push rdi
  1903 00000A58 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1904 00000A5B E85E100000                  call check_block_collision
  1905 00000A60 5F                          pop rdi
  1906 00000A61 5E                          pop rsi
  1907 00000A62 59                          pop rcx
  1908                                  
  1909 00000A63 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1910 00000A66 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1911                                  
  1912                                      ;    - Luego colisión con enemigos
  1913                                      ; ---------------------------------------------------------
  1914 00000A68 51                          push rcx
  1915 00000A69 56                          push rsi
  1916 00000A6A 57                          push rdi
  1917                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1918                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1919                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1920                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1921                                      ;
  1922                                      ; Hacemos algo como:
  1923 00000A6B 4989FA                      mov r10, rdi
  1924 00000A6E E85A000000                  call check_laser_enemy_collision
  1925 00000A73 5F                          pop rdi
  1926 00000A74 5E                          pop rsi
  1927 00000A75 59                          pop rcx
  1928                                  
  1929 00000A76 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1930 00000A79 7517                        jnz .delete_laser
  1931                                  
  1932                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1933 00000A7B 8A05(0A230000)              mov al, [laser_symbol]
  1934 00000A81 8807                        mov [rdi], al
  1935                                  
  1936                                  .next_laser:
  1937                                      ; Pasamos al láser anterior en el array
  1938 00000A83 48FFC9                      dec rcx
  1939 00000A86 4883F9FF                    cmp rcx, -1
  1940 00000A8A 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1941 00000A90 EB2E                        jmp .fin
  1942                                  
  1943                                  ; -----------------------------------------------------------------
  1944                                  ; Subrutina interna: .delete_laser
  1945                                  ; -----------------------------------------------------------------
  1946                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1947                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1948                                  .delete_laser:
  1949 00000A92 4C0FB625(0B230000)          movzx r12, byte [laser_count]
  1950 00000A9A 49FFCC                      dec r12                    ; r12 = índice del último láser
  1951 00000A9D 4939CC                      cmp r12, rcx
  1952 00000AA0 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1953                                  
  1954                                      ; Copiamos el último láser a la posición actual
  1955 00000AA2 488DBC09[0C230000]          lea rdi, [lasers + rcx*2]
  1956 00000AAA 4B8DB424[0C230000]          lea rsi, [lasers + r12*2]
  1957 00000AB2 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1958 00000AB5 668907                      mov [rdi], ax             ; copiamos X,Y
  1959                                  
  1960                                  .just_decrement:
  1961 00000AB8 FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1962 00000ABE EBC3                        jmp .next_laser
  1963                                  
  1964                                  .fin:
  1965 00000AC0 415F                        pop r15
  1966 00000AC2 415E                        pop r14
  1967 00000AC4 415D                        pop r13
  1968 00000AC6 415C                        pop r12
  1969 00000AC8 5E                          pop rsi
  1970 00000AC9 5F                          pop rdi
  1971 00000ACA 5B                          pop rbx
  1972 00000ACB 5D                          pop rbp
  1973 00000ACC C3                          ret
  1974                                  
  1975                                  
  1976                                  ; Nueva función para verificar colisión entre láser y enemigos
  1977                                  ; ==========================================================
  1978                                  ; NUEVA check_laser_enemy_collision
  1979                                  ; ==========================================================
  1980                                  check_laser_enemy_collision:    ; Función para verificar colisión entre láser y enemigos
  1981 00000ACD 55                          push rbp        
  1982 00000ACE 4889E5                      mov  rbp, rsp
  1983                                      
  1984 00000AD1 4D31ED                      xor r13, r13            ; Índice del enemigo
  1985 00000AD4 4831C0                      xor rax, rax            ; 0 = no colisión
  1986                                  
  1987                                  .loop_enemies:      ; Iterar sobre los enemigos
  1988 00000AD7 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1989 00000ADB 7D64                        jge .end            ; Si no hay más enemigos, salir
  1990                                  
  1991                                      ; r13 * 3 => offset del enemigo i
  1992 00000ADD 4C89E9                      mov rcx, r13        ; r13 = i
  1993 00000AE0 486BC903                    imul rcx, 3        ; rcx = i * 3
  1994 00000AE4 488DB1[60200000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1995                                  
  1996                                      ; Verificar si está activo
  1997 00000AEB 807E0201                    cmp byte [rsi+2], 1 
  1998 00000AEF 754B                        jne .next_enemy       ; Si no está activo, probar con el siguiente enemigo
  1999                                  
  2000                                      ; Cargar posición X/Y del enemigo
  2001 00000AF1 4C0FB636                    movzx r14, byte [rsi]      ; X
  2002 00000AF5 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  2003                                  
  2004                                      ; Comparar con posición del láser (r8=X, r9=Y)
  2005 00000AFA 4D39F0                      cmp r8, r14
  2006 00000AFD 753D                        jne .next_enemy        ; Si no coincide X, probar con el siguiente enemigo
  2007 00000AFF 4D39F9                      cmp r9, r15
  2008 00000B02 7538                        jne .next_enemy     ; Si no coincide Y, probar con el siguiente enemigo
  2009                                  
  2010                                      ; ==== Colisión detectada con láser ====
  2011                                  
  2012                                      ; 1) Desactivar enemigo
  2013 00000B04 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  2014                                  
  2015                                      ; 2) Sumar puntos
  2016 00000B08 488B05(7F200000)            mov rax, [enemy_points]  ; Puntos por enemigo
  2017 00000B0F 480105(3E200000)            add [current_score], rax
  2018                                  
  2019                                      ; 3) Borrar del board, SOLO si no coincide con la paleta
  2020                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  2021 00000B16 4983FF1E                    cmp r15, row_cells - 2
  2022 00000B1A 7419                        je .skip_erase
  2023                                  
  2024                                      ; Borrar visualmente del board
  2025 00000B1C B850000000                  mov rax, column_cells   ; Ancho del tablero
  2026 00000B21 4883C002                    add rax, 2            ; Incluir caracteres de nueva línea
  2027 00000B25 49F7E7                      mul r15              ; Multiplicar por Y
  2028 00000B28 4C01F0                      add rax, r14     ; Sumar X
  2029 00000B2B 488DB8[400A0000]            lea rdi, [board + rax]      ; Dirección en el tablero
  2030 00000B32 C60720                      mov byte [rdi], ' '       ; Borrar enemigo visualmente
  2031                                  
  2032                                  .skip_erase:
  2033                                  
  2034                                      ; 4) Devolver rax=1 => colisión con enemigo
  2035 00000B35 B801000000                  mov rax, 1  
  2036 00000B3A EB05                        jmp .end
  2037                                  
  2038                                  .next_enemy:    ; Pasar al siguiente enemigo
  2039 00000B3C 49FFC5                      inc r13       ; Siguiente enemigo
  2040 00000B3F EB96                        jmp .loop_enemies   ; Iterar
  2041                                  
  2042                                  .end:
  2043 00000B41 5D                          pop rbp
  2044 00000B42 C3                          ret
  2045                                  
  2046                                  
  2047                                  ; Función auxiliar para eliminar un láser específico
  2048                                  remove_laser:
  2049 00000B43 55                          push rbp    
  2050 00000B44 4889E5                      mov rbp, rsp
  2051                                  
  2052                                      ; Borrar el láser del tablero
  2053 00000B47 41C60220                    mov byte [r10], ' '
  2054                                  
  2055                                      ; Mover el último láser a esta posición si no es el último
  2056 00000B4B 480FB605(0B230000)          movzx rax, byte [laser_count]
  2057 00000B53 48FFC8                      dec rax                    ; Índice del último láser
  2058 00000B56 4939C4                      cmp r12, rax              ; Comparar con láser actual
  2059 00000B59 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  2060                                  
  2061                                      ; Copiar último láser a la posición actual
  2062 00000B5B 4B8DBC24[0C230000]          lea rdi, [lasers + r12*2]   ; Dirección del último láser
  2063 00000B63 488DB400[0C230000]          lea rsi, [lasers + rax*2]   ; Dirección del láser actual
  2064 00000B6B 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  2065 00000B6E 668917                      mov [rdi], dx
  2066                                  
  2067                                  .just_decrease:
  2068 00000B71 FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2069                                  
  2070 00000B77 5D                          pop rbp
  2071 00000B78 C3                          ret
  2072                                  
  2073                                  add_life:   ; Función para añadir una vida
  2074 00000B79 55                          push rbp
  2075 00000B7A 4889E5                      mov rbp, rsp    
  2076 00000B7D 53                          push rbx
  2077 00000B7E 51                          push rcx
  2078 00000B7F 57                          push rdi
  2079 00000B80 56                          push rsi
  2080 00000B81 4150                        push r8
  2081 00000B83 4151                        push r9
  2082                                      
  2083                                      ; Verificar si ya tenemos el máximo de vidas
  2084 00000B85 480FB605(3B210000)          movzx rax, byte [current_lives]
  2085 00000B8D 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  2086 00000B91 7D2C                        jge .end
  2087                                      
  2088                                      ; Incrementar el contador de vidas
  2089 00000B93 FE05(3B210000)              inc byte [current_lives]
  2090                                      
  2091                                      ; Encontrar la siguiente vida inactiva
  2092 00000B99 4831C9                      xor rcx, rcx
  2093                                      
  2094                                      .find_inactive:     
  2095 00000B9C 4883F907                        cmp rcx, lives_count    ; Verificar si llegamos al final
  2096 00000BA0 7D1D                            jge .end    
  2097                                          
  2098                                          ; Calcular offset de la vida actual
  2099 00000BA2 4889C8                          mov rax, rcx    ; Índice de la vida
  2100 00000BA5 486BC003                        imul rax, 3    ; Cada vida usa 3 bytes
  2101 00000BA9 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Dirección de la vida actual
  2102                                          
  2103                                          ; Verificar si está inactiva
  2104 00000BB0 807E0200                        cmp byte [rsi + 2], 0
  2105 00000BB4 7405                            je .activate_life   ; Si está inactiva, activarla
  2106                                          
  2107 00000BB6 48FFC1                          inc rcx   ; Probar con la siguiente vida
  2108 00000BB9 EBE1                            jmp .find_inactive  ; Continuar buscando
  2109                                          
  2110                                      .activate_life:
  2111                                          ; Activar la vida
  2112 00000BBB C6460201                        mov byte [rsi + 2], 1
  2113                                          
  2114                                      .end:
  2115 00000BBF 4159                            pop r9
  2116 00000BC1 4158                            pop r8
  2117 00000BC3 5E                              pop rsi
  2118 00000BC4 5F                              pop rdi
  2119 00000BC5 59                              pop rcx
  2120 00000BC6 5B                              pop rbx
  2121 00000BC7 5D                              pop rbp
  2122 00000BC8 C3                              ret
  2123                                  
  2124                                  
  2125                                  print_ball:
  2126 00000BC9 4C8B05(DF140000)        	mov r8, [ball_x_pos]    ; Cargar posición X de la bola
  2127 00000BD0 4C8B0D(E7140000)        	mov r9, [ball_y_pos]    ; Cargar posición Y de la bola
  2128 00000BD7 4981C0[400A0000]        	add r8, board       ; Añadir offset del tablero
  2129                                  
  2130 00000BDE 4C89C9                  	mov rcx, r9        ; Y
  2131 00000BE1 B852000000              	mov rax, column_cells + 2   ; Ancho del tablero
  2132 00000BE6 48F7E9                  	imul rcx     ; Multiplicar por Y
  2133                                  	
  2134 00000BE9 4901C0                  	add r8, rax   ; Sumar X
  2135 00000BEC 41C6004F                	mov byte [r8], char_O       ; Dibujar la bola en el tablero
  2136 00000BF0 C3                      	ret
  2137                                  
  2138                                  print_ball_2:   ; Función para imprimir la segunda bola
  2139 00000BF1 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X de la segunda bola
  2140 00000BF8 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y de la segunda bola
  2141 00000BFF 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2142 00000C06 4C89C9                      mov rcx, r9     ; Y
  2143 00000C09 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2144 00000C0E 48F7E9                      imul rcx    ; Multiplicar por Y
  2145 00000C11 4901C0                      add r8, rax  ; Sumar X
  2146 00000C14 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2147 00000C18 C3                          ret     ; Retornar
  2148                                  
  2149                                  print_ball_3:   ; Función para imprimir la tercera bola
  2150 00000C19 4C8B05(23150000)            mov r8, [ball3_x_pos]   ; Cargar posición X de la tercera bola
  2151 00000C20 4C8B0D(2B150000)            mov r9, [ball3_y_pos]   ; Cargar posición Y de la tercera bola
  2152 00000C27 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2153 00000C2E 4C89C9                      mov rcx, r9   ; Y
  2154 00000C31 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2155 00000C36 48F7E9                      imul rcx    ; Multiplicar por Y
  2156 00000C39 4901C0                      add r8, rax  ; Sumar X
  2157 00000C3C 41C6004F                    mov byte [r8], char_O   ; Dibujar la bola en el tablero
  2158 00000C40 C3                          ret    ; Retornar
  2159                                  
  2160                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  2161                                  	
  2162                                  print_pallet:
  2163                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  2164 00000C41 4C8B05(BF140000)            mov r8, [pallet_position]   ; Posición actual de la paleta
  2165 00000C48 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño actual de la paleta
  2166                                      .clear_pallet:  ; Bucle para borrar la paleta
  2167 00000C4F 41C60020                        mov byte [r8], char_space   ; Borrar carácter actual
  2168 00000C53 49FFC0                          inc r8  ; Mover al siguiente carácter
  2169 00000C56 48FFC9                          dec rcx ; Decrementar contador
  2170 00000C59 75F4                            jnz .clear_pallet   ; Repetir si no hemos terminado
  2171                                  
  2172                                      ; Luego dibujar la nueva paleta con el tamaño actual
  2173 00000C5B 4C8B05(BF140000)            mov r8, [pallet_position]
  2174 00000C62 488B0D(C7140000)            mov rcx, [pallet_size]  ; Tamaño de la paleta
  2175                                      .write_pallet:  ; Bucle para escribir la paleta
  2176 00000C69 41C6003D                        mov byte [r8], char_equal   ; Dibujar carácter actual
  2177 00000C6D 49FFC0                          inc r8  ; Mover al siguiente carácter
  2178 00000C70 48FFC9                          dec rcx ; Decrementar contador
  2179 00000C73 75F4                            jnz .write_pallet   ; Repetir si no hemos terminado
  2180                                  
  2181 00000C75 C3                          ret
  2182                                  
  2183                                  move_pallet:    ; Función para mover la paleta
  2184                                      
  2185 00000C76 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2186 00000C7D 7507                        jne .continue_movement  ; Si la bola se está moviendo, continuar
  2187 00000C7F C605(FF140000)01            mov byte [ball_moving], 1   ; Marcar la bola como en movimiento
  2188                                  
  2189                                      .continue_movement:
  2190 00000C86 4883FFFF                        cmp rdi, left_direction  ; Verificar si la dirección es a la izquierda
  2191 00000C8A 7531                            jne .move_right  ; Si no es a la izquierda, mover a la derecha
  2192                                  
  2193                                          .move_left:         
  2194                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  2195 00000C8C 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2196 00000C93 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  2197 00000C96 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2198 00000C99 3C58                                cmp al, 'X'        ; Comparar si es una X
  2199 00000C9B 744D                                je .end            ; Si es X, no mover
  2200                                              
  2201 00000C9D 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2202 00000CA4 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2203 00000CAB 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  2204 00000CB1 49FFC8                              dec r8            ; Mover a la izquierda
  2205 00000CB4 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2206 00000CBB EB2D                                jmp .end    ; Salir
  2207                                              
  2208                                          .move_right:
  2209                                              ; Verificar si la siguiente posición después de la paleta sería una X
  2210 00000CBD 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2211 00000CC4 4C8B0D(C7140000)                    mov r9, [pallet_size]   ; Tamaño de la paleta
  2212 00000CCB 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  2213 00000CCE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2214 00000CD1 3C58                                cmp al, 'X'        ; Comparar si es una X
  2215 00000CD3 7415                                je .end            ; Si es X, no mover
  2216                                              
  2217 00000CD5 4C8B05(BF140000)                    mov r8, [pallet_position]   ; Posición actual de la paleta
  2218 00000CDC 41C60020                            mov byte [r8], char_space   ; Borrar primer carácter de la paleta
  2219 00000CE0 49FFC0                              inc r8          ; Mover a la derecha
  2220 00000CE3 4C8905(BF140000)                    mov [pallet_position], r8   ; Guardar nueva posición
  2221                                          .end:
  2222 00000CEA C3                                  ret
  2223                                  
  2224                                  
  2225                                  
  2226                                              
  2227                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  2228                                  update_caught_ball_position:    ; Función para actualizar la posición de la bola atrapada
  2229 00000CEB 55                          push rbp    ; Guardar el puntero de la base
  2230 00000CEC 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  2231                                      
  2232                                      ; Calcular la nueva posición de la bola basada en la paleta
  2233 00000CEF 4C8B05(BF140000)            mov r8, [pallet_position]   ; Obtener posición actual de la paleta
  2234 00000CF6 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  2235 00000CFD B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2236 00000D02 4831D2                      xor rdx, rdx      ; Limpiar rdx
  2237 00000D05 48F7F0                      div rax                ; División para obtener X,Y
  2238                                      
  2239                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  2240 00000D08 4989C1                      mov r9, rax            ; Y de la paleta
  2241 00000D0B 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  2242                                      
  2243                                      ; Añadir el offset guardado a la posición X
  2244 00000D0E 4889D0                      mov rax, rdx
  2245 00000D11 480305(00230000)            add rax, [ball_catch_offset]    ; Añadir el offset guardado
  2246 00000D18 488905(DF140000)            mov [ball_x_pos], rax   ; Guardar nueva posición X
  2247 00000D1F 4C890D(E7140000)            mov [ball_y_pos], r9    ; Guardar nueva posición Y
  2248                                      
  2249 00000D26 5D                          pop rbp
  2250 00000D27 C3                          ret
  2251                                  
  2252                                  
  2253                                  move_all_balls:
  2254 00000D28 55                          push rbp
  2255 00000D29 4889E5                      mov rbp, rsp
  2256 00000D2C 53                          push rbx
  2257                                      
  2258                                      ; Inicializar contador de bolas
  2259 00000D2D 4831DB                      xor rbx, rbx
  2260                                      
  2261                                  .loop_balls:
  2262                                      ; Verificar si hemos procesado todas las bolas
  2263 00000D30 3A1D(3F240000)              cmp bl, byte [balls_count]  ; Comparar con la cantidad de bolas
  2264 00000D36 7D1D                        jge .end    ; Si hemos procesado todas las bolas, salir
  2265                                      
  2266                                      ; Calcular offset de la bola actual
  2267 00000D38 B821000000                  mov rax, BALL_STRUCT_SIZE
  2268 00000D3D 48F7E3                      mul rbx   ; Multiplicar por el índice de la bola
  2269                                      
  2270                                      ; Verificar si la bola está activa
  2271 00000D40 80B8[FC230000]01            cmp byte [balls_data + rax + 32], 1
  2272 00000D47 7507                        jne .next_ball  ; Si la bola no está activa, pasar a la siguiente
  2273                                      
  2274                                      ; Guardar offset en la pila
  2275 00000D49 50                          push rax
  2276                                      
  2277                                      ; Llamar a move_ball con los parámetros de esta bola
  2278 00000D4A E809000000                  call move_ball
  2279                                      
  2280                                      ; Restaurar offset
  2281 00000D4F 58                          pop rax
  2282                                      
  2283                                  .next_ball:     ; Pasar a la siguiente bola
  2284 00000D50 48FFC3                      inc rbx  ; Incrementar contador de bolas
  2285 00000D53 EBDB                        jmp .loop_balls ; Repetir el ciclo
  2286                                      
  2287                                  .end:
  2288 00000D55 5B                          pop rbx
  2289 00000D56 5D                          pop rbp
  2290 00000D57 C3                          ret
  2291                                  
  2292                                  move_ball:  ; Función para mover una bola
  2293                                  
  2294 00000D58 803D(FD220000)01            cmp byte [ball_caught], 1   ; Verificar si la bola está atrapada
  2295 00000D5F 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2296                                  
  2297 00000D65 803D(FF140000)00            cmp byte [ball_moving], 0   ; Verificar si la bola está en movimiento
  2298 00000D6C 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2299                                  
  2300                                      ; Incrementar contador de velocidad
  2301 00000D72 48FF05(F3220000)            inc qword [speed_counter]
  2302                                      
  2303                                      ; Verificar si debemos mover la bola en este ciclo
  2304 00000D79 488B05(F3220000)            mov rax, [speed_counter]
  2305 00000D80 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2306 00000D87 0F8C9D010000                jl .end  ; Si no es tiempo de mover la bola, salir
  2307                                      
  2308                                      ; Resetear contador de velocidad
  2309 00000D8D 48C705(F3220000)00-         mov qword [speed_counter], 0    ; Resetear contador
  2309 00000D95 000000             
  2310                                  
  2311                                      ; Borrar la posición actual de la bola
  2312 00000D98 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2313 00000D9F 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2314 00000DA6 4981C0[400A0000]            add r8, board    ; Añadir offset del tablero
  2315 00000DAD 4C89C9                      mov rcx, r9   ; Y
  2316 00000DB0 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2317 00000DB5 48F7E9                      imul rcx    ; Multiplicar por Y
  2318 00000DB8 4901C0                      add r8, rax  ; Sumar X
  2319 00000DBB 41C60020                    mov byte [r8], char_space   ; Borrar la bola de la posición actual
  2320                                  
  2321                                      ; Calcular siguiente posición X
  2322 00000DBF 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2323 00000DC6 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2324 00000DCD 488B05(EF140000)            mov rax, [ball_direction_x]  ; Cargar dirección X de la bola
  2325 00000DD4 4901C0                      add r8, rax               ; Nueva posición X
  2326                                  
  2327                                      ; Calcular la dirección de memoria para la siguiente posición
  2328 00000DD7 4D89C2                      mov r10, r8
  2329 00000DDA 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2330 00000DE1 4C89C9                      mov rcx, r9   ; Y
  2331 00000DE4 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2332 00000DE9 48F7E9                      imul rcx    ; Multiplicar por Y
  2333 00000DEC 4901C2                      add r10, rax    ; Sumar X
  2334                                  
  2335                                      ; Verificar si hay una X en la siguiente posición X
  2336 00000DEF 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2337 00000DF2 3C58                        cmp al, 'X'     ; Comparar con X
  2338 00000DF4 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2339 00000DF6 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  2340 00000DFD E928010000                  jmp .end    ; Salir
  2341                                  
  2342                                      .move_with_pallet:  ; Mover la bola con la paleta
  2343                                          ; Borrar la posición actual de la bola
  2344 00000E02 4C8B05(DF140000)                mov r8, [ball_x_pos]    ; Cargar posición X actual de la bola
  2345 00000E09 4C8B0D(E7140000)                mov r9, [ball_y_pos]    ; Cargar posición Y actual de la bola
  2346 00000E10 4D89C2                          mov r10, r8   ; Guardar posición X actual
  2347 00000E13 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2348 00000E1A 4C89C9                          mov rcx, r9  ; Y
  2349 00000E1D B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2350 00000E22 48F7E9                          imul rcx    ; Multiplicar por Y
  2351 00000E25 4901C2                          add r10, rax    ; Sumar X
  2352 00000E28 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2353                                  
  2354                                          ; Actualizar posición X basada en la paleta
  2355 00000E2C 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2356 00000E33 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2357 00000E3A 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2358 00000E41 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  2359                                  
  2360                                          ; Mantener la bola una posición arriba de la paleta
  2361 00000E48 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  2362 00000E4F 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  2363                                  
  2364 00000E56 E9CF000000                      jmp .end
  2365                                  
  2366                                  
  2367                                      .check_block_x: 
  2368                                          ; Verificar colisión con bloques en X
  2369 00000E5B 4150                            push r8     ; Guardar registros que usa check_block_collision
  2370 00000E5D 4151                            push r9     ; Guardar registros que usa check_block_collision
  2371 00000E5F 4152                            push r10    ; Guardar registros que usa check_block_collision
  2372 00000E61 E8580C0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2373 00000E66 415A                            pop r10    ; Restaurar registros
  2374 00000E68 4159                            pop r9   ; Restaurar registros
  2375 00000E6A 4158                            pop r8  ; Restaurar registros
  2376 00000E6C 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2377 00000E6F 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2378 00000E71 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  2379 00000E78 E9AD000000                      jmp .end    ; Salir
  2380                                  
  2381                                      .check_paddle_x:
  2382                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2383 00000E7D 41803A3D                        cmp byte [r10], char_equal  ; Comparar con el carácter de la paleta
  2384 00000E81 750C                            jne .check_y_movement   ; Si no es la paleta, verificar movimiento en Y
  2385 00000E83 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  2386 00000E8A E99B000000                      jmp .end
  2387                                  
  2388                                      .check_y_movement:  ; Verificar movimiento en Y
  2389                                          ; Calcular siguiente posición Y
  2390 00000E8F 488B05(F7140000)                mov rax, [ball_direction_y] ; Cargar dirección Y de la bola
  2391 00000E96 4901C1                          add r9, rax                  ; Nueva posición Y
  2392                                  
  2393                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2394 00000E99 4D89C2                          mov r10, r8
  2395 00000E9C 4981C2[400A0000]                    add r10, board  ; Añadir offset del tablero
  2396 00000EA3 4C89C9                              mov rcx, r9  ; Y
  2397 00000EA6 B852000000                          mov rax, column_cells + 2   ; Ancho del tablero 
  2398 00000EAB 48F7E9                          imul rcx    ; Multiplicar por Y
  2399 00000EAE 4901C2                          add r10, rax    ; Sumar X
  2400                                  
  2401                                          ; Verificar si hay una X en la siguiente posición Y
  2402 00000EB1 418A02                          mov al, [r10]       ; Cargar el carácter en la siguiente posición
  2403 00000EB4 3C58                            cmp al, 'X'    ; Comparar con X
  2404 00000EB6 7509                            jne .check_block_y  ; Si no hay X, verificar colisión con bloques
  2405 00000EB8 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  2406 00000EBF EB69                            jmp .end    ; Salir
  2407                                  
  2408                                      .check_block_y:
  2409                                          ; Verificar colisión con bloques en Y
  2410 00000EC1 4150                            push r8     ; Guardar registros que usa check_block_collision
  2411 00000EC3 4151                            push r9    ; Guardar registros que usa check_block_collision
  2412 00000EC5 4152                            push r10    ; Guardar registros que usa check_block_collision
  2413 00000EC7 E8F20B0000                      call check_block_collision  ; Llamar a la función de colisión con bloques
  2414 00000ECC 415A                            pop r10   ; Restaurar registros
  2415 00000ECE 4159                            pop r9  ; Restaurar registros
  2416 00000ED0 4158                            pop r8  ; Restaurar registros
  2417 00000ED2 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2418 00000ED5 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2419 00000ED7 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  2420 00000EDE EB4A                            jmp .end
  2421                                  
  2422                                      .check_paddle_y:
  2423                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2424 00000EE0 41803A3D                        cmp byte [r10], char_equal
  2425 00000EE4 7536                            jne .update_position    ; Si no es la paleta, actualizar posición
  2426                                  
  2427                                          ; Verificar si el poder catch está activo
  2428 00000EE6 803D(FC220000)01                cmp byte [catch_power_active], 1
  2429 00000EED 7524                            jne .normal_bounce  ; Si no está activo, rebotar normalmente
  2430                                  
  2431                                          ; Activar el modo "atrapado"
  2432 00000EEF C605(FD220000)01                mov byte [ball_caught], 1   ; Marcar la bola como atrapada
  2433                                          
  2434                                          ; Guardar la posición X actual de la bola como offset
  2435 00000EF6 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  2436 00000EFD 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2437 00000F04 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2438 00000F0A 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2439                                          
  2440 00000F11 EB17                            jmp .end
  2441                                  
  2442                                      .normal_bounce:
  2443 00000F13 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  2444 00000F1A EB0E                            jmp .end
  2445                                  
  2446                                  
  2447                                      .update_position:   ; Actualizar la posición de la bola
  2448 00000F1C 4C8905(DF140000)                mov [ball_x_pos], r8    ; Guardar nueva posición X
  2449 00000F23 4C890D(E7140000)                mov [ball_y_pos], r9        ; Guardar nueva posición Y
  2450                                  
  2451                                      .end:
  2452 00000F2A C3                              ret
  2453                                  
  2454                                  
  2455                                  move_ball_2:
  2456                                  
  2457 00000F2B 803D(FE220000)01            cmp byte [ball_caught_2], 1  ; Verificar si la bola está atrapada
  2458 00000F32 0F849D000000                je .move_with_pallet    ; Si la bola está atrapada, mover con la paleta
  2459                                  
  2460 00000F38 803D(21150000)00            cmp byte [ball2_moving], 0  ; Verificar si la bola está en movimiento
  2461 00000F3F 0F84B8010000                je .end   ; Si la bola no está en movimiento, salir
  2462                                  
  2463                                      ; Incrementar contador de velocidad
  2464 00000F45 48FF05(F3220000)            inc qword [speed_counter]   ; Incrementar contador de velocidad
  2465                                      
  2466                                      ; Verificar si debemos mover la bola en este ciclo
  2467 00000F4C 488B05(F3220000)            mov rax, [speed_counter]
  2468 00000F53 483B05(E3220000)            cmp rax, [ball_speed]   ; Comparar con la velocidad de la bola
  2469 00000F5A 0F8C9D010000                jl .end
  2470                                      
  2471                                      ; Resetear contador de velocidad
  2472 00000F60 48C705(F3220000)00-         mov qword [speed_counter], 0
  2472 00000F68 000000             
  2473                                  
  2474                                      ; Borrar la posición actual de la bola
  2475 00000F6B 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2476 00000F72 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2477 00000F79 4981C0[400A0000]            add r8, board   ; Añadir offset del tablero
  2478 00000F80 4C89C9                      mov rcx, r9  ; Y
  2479 00000F83 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2480 00000F88 48F7E9                      imul rcx    ; Multiplicar por Y
  2481 00000F8B 4901C0                      add r8, rax     ; Sumar X
  2482 00000F8E 41C60020                    mov byte [r8], char_space       ; Borrar la bola de la posición actual
  2483                                  
  2484                                      ; Calcular siguiente posición X
  2485 00000F92 4C8B05(01150000)            mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2486 00000F99 4C8B0D(09150000)            mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2487 00000FA0 488B05(11150000)            mov rax, [ball2_direction_x]    ; Cargar dirección X de la bola
  2488 00000FA7 4901C0                      add r8, rax               ; Nueva posición X
  2489                                  
  2490                                      ; Calcular la dirección de memoria para la siguiente posición
  2491 00000FAA 4D89C2                      mov r10, r8  ; Guardar posición X actual
  2492 00000FAD 4981C2[400A0000]            add r10, board  ; Añadir offset del tablero
  2493 00000FB4 4C89C9                      mov rcx, r9 ; Y
  2494 00000FB7 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  2495 00000FBC 48F7E9                      imul rcx    ; Multiplicar por Y
  2496 00000FBF 4901C2                      add r10, rax    ; Sumar X
  2497                                  
  2498                                      ; Verificar si hay una X en la siguiente posición X
  2499 00000FC2 418A02                      mov al, [r10]   ; Cargar el carácter en la siguiente posición
  2500 00000FC5 3C58                        cmp al, 'X'    ; Comparar con X
  2501 00000FC7 7565                        jne .check_block_x  ; Si no hay X, verificar colisión con bloques
  2502 00000FC9 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  2503 00000FD0 E928010000                  jmp .end    ; Salir
  2504                                  
  2505                                      .move_with_pallet:
  2506                                          ; Borrar la posición actual de la bola
  2507 00000FD5 4C8B05(01150000)                mov r8, [ball2_x_pos]   ; Cargar posición X actual de la bola
  2508 00000FDC 4C8B0D(09150000)                mov r9, [ball2_y_pos]   ; Cargar posición Y actual de la bola
  2509 00000FE3 4D89C2                          mov r10, r8  ; Guardar posición X actual
  2510 00000FE6 4981C2[400A0000]                add r10, board  ; Añadir offset del tablero
  2511 00000FED 4C89C9                          mov rcx, r9 ; Y
  2512 00000FF0 B852000000                      mov rax, column_cells + 2   ; Ancho del tablero
  2513 00000FF5 48F7E9                          imul rcx    ; Multiplicar por Y
  2514 00000FF8 4901C2                          add r10, rax    ; Sumar X
  2515 00000FFB 41C60220                        mov byte [r10], char_space  ; Borrar la bola de la posición actual
  2516                                  
  2517                                          ; Actualizar posición X basada en la paleta
  2518 00000FFF 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2519 00001006 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2520 0000100D 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2521 00001014 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  2522                                  
  2523                                          ; Mantener la bola una posición arriba de la paleta
  2524 0000101B 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  2525 00001022 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  2526                                  
  2527 00001029 E9CF000000                      jmp .end
  2528                                  
  2529                                  
  2530                                      .check_block_x:
  2531                                          ; Verificar colisión con bloques en X
  2532 0000102E 4150                            push r8     ; Guardar registros que usa check_block_collision
  2533 00001030 4151                            push r9
  2534 00001032 4152                            push r10    ; Guardar registros que usa check_block_collision
  2535 00001034 E8850A0000                      call check_block_collision      
  2536 00001039 415A                            pop r10   ; Restaurar registros
  2537 0000103B 4159                            pop r9
  2538 0000103D 4158                            pop r8
  2539 0000103F 4885C0                          test rax, rax   ; Verificar si hubo colisión
  2540 00001042 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2541 00001044 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  2542 0000104B E9AD000000                      jmp .end
  2543                                  
  2544                                      .check_paddle_x:
  2545                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2546 00001050 41803A3D                        cmp byte [r10], char_equal  
  2547 00001054 750C                            jne .check_y_movement
  2548 00001056 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  2549 0000105D E99B000000                      jmp .end
  2550                                  
  2551                                      .check_y_movement:
  2552                                          ; Calcular siguiente posición Y
  2553 00001062 488B05(19150000)                mov rax, [ball2_direction_y]
  2554 00001069 4901C1                          add r9, rax                  ; Nueva posición Y
  2555                                  
  2556                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2557 0000106C 4D89C2                          mov r10, r8
  2558 0000106F 4981C2[400A0000]                add r10, board
  2559 00001076 4C89C9                          mov rcx, r9
  2560 00001079 B852000000                      mov rax, column_cells + 2
  2561 0000107E 48F7E9                          imul rcx
  2562 00001081 4901C2                          add r10, rax
  2563                                  
  2564                                          ; Verificar si hay una X en la siguiente posición Y
  2565 00001084 418A02                          mov al, [r10]
  2566 00001087 3C58                            cmp al, 'X'     ; Comparar con X
  2567 00001089 7509                            jne .check_block_y
  2568 0000108B 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  2569 00001092 EB69                            jmp .end
  2570                                  
  2571                                      .check_block_y:
  2572                                          ; Verificar colisión con bloques en Y
  2573 00001094 4150                            push r8     ; Guardar registros que usa check_block_collision
  2574 00001096 4151                            push r9
  2575 00001098 4152                            push r10
  2576 0000109A E81F0A0000                      call check_block_collision
  2577 0000109F 415A                            pop r10
  2578 000010A1 4159                            pop r9
  2579 000010A3 4158                            pop r8
  2580 000010A5 4885C0                          test rax, rax
  2581 000010A8 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2582 000010AA 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  2583 000010B1 EB4A                            jmp .end
  2584                                  
  2585                                      .check_paddle_y:
  2586                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2587 000010B3 41803A3D                        cmp byte [r10], char_equal
  2588 000010B7 7536                            jne .update_position
  2589                                  
  2590                                          ; Verificar si el poder catch está activo
  2591 000010B9 803D(FC220000)01                cmp byte [catch_power_active], 1
  2592 000010C0 7524                            jne .normal_bounce
  2593                                  
  2594                                          ; Activar el modo "atrapado"
  2595 000010C2 C605(FE220000)01                mov byte [ball_caught_2], 1
  2596                                          
  2597                                          ; Guardar la posición X actual de la bola como offset
  2598 000010C9 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2599 000010D0 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2600 000010D7 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2601 000010DD 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2602                                          
  2603 000010E4 EB17                            jmp .end
  2604                                  
  2605                                      .normal_bounce:
  2606 000010E6 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2607 000010ED EB0E                            jmp .end
  2608                                  
  2609                                  
  2610                                      .update_position:
  2611 000010EF 4C8905(01150000)                mov [ball2_x_pos], r8
  2612 000010F6 4C890D(09150000)                mov [ball2_y_pos], r9
  2613                                  
  2614                                      .end:
  2615 000010FD C3                              ret
  2616                                  
  2617                                  move_ball_3:    ; Función para mover la tercera bola
  2618                                  
  2619 000010FE 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2620 00001105 0F849D000000                je .move_with_pallet
  2621                                  
  2622 0000110B 803D(43150000)00            cmp byte [ball3_moving], 0
  2623 00001112 0F84B8010000                je .end
  2624                                  
  2625                                      ; Incrementar contador de velocidad
  2626 00001118 48FF05(F3220000)            inc qword [speed_counter]
  2627                                      
  2628                                      ; Verificar si debemos mover la bola en este ciclo
  2629 0000111F 488B05(F3220000)            mov rax, [speed_counter]
  2630 00001126 483B05(E3220000)            cmp rax, [ball_speed]
  2631 0000112D 0F8C9D010000                jl .end
  2632                                      
  2633                                      ; Resetear contador de velocidad
  2634 00001133 48C705(F3220000)00-         mov qword [speed_counter], 0
  2634 0000113B 000000             
  2635                                  
  2636                                      ; Borrar la posición actual de la bola
  2637 0000113E 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2638 00001145 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2639 0000114C 4981C0[400A0000]            add r8, board
  2640 00001153 4C89C9                      mov rcx, r9
  2641 00001156 B852000000                  mov rax, column_cells + 2
  2642 0000115B 48F7E9                      imul rcx
  2643 0000115E 4901C0                      add r8, rax
  2644 00001161 41C60020                    mov byte [r8], char_space
  2645                                  
  2646                                      ; Calcular siguiente posición X
  2647 00001165 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2648 0000116C 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2649 00001173 488B05(33150000)            mov rax, [ball3_direction_x]
  2650 0000117A 4901C0                      add r8, rax               ; Nueva posición X
  2651                                  
  2652                                      ; Calcular la dirección de memoria para la siguiente posición
  2653 0000117D 4D89C2                      mov r10, r8
  2654 00001180 4981C2[400A0000]            add r10, board
  2655 00001187 4C89C9                      mov rcx, r9
  2656 0000118A B852000000                  mov rax, column_cells + 2
  2657 0000118F 48F7E9                      imul rcx
  2658 00001192 4901C2                      add r10, rax
  2659                                  
  2660                                      ; Verificar si hay una X en la siguiente posición X
  2661 00001195 418A02                      mov al, [r10]
  2662 00001198 3C58                        cmp al, 'X'
  2663 0000119A 7565                        jne .check_block_x
  2664 0000119C 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2665 000011A3 E928010000                  jmp .end
  2666                                  
  2667                                      .move_with_pallet:
  2668                                          ; Borrar la posición actual de la bola
  2669 000011A8 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2670 000011AF 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2671 000011B6 4D89C2                          mov r10, r8
  2672 000011B9 4981C2[400A0000]                add r10, board
  2673 000011C0 4C89C9                          mov rcx, r9
  2674 000011C3 B852000000                      mov rax, column_cells + 2
  2675 000011C8 48F7E9                          imul rcx
  2676 000011CB 4901C2                          add r10, rax
  2677 000011CE 41C60220                        mov byte [r10], char_space
  2678                                  
  2679                                          ; Actualizar posición X basada en la paleta
  2680 000011D2 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2681 000011D9 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2682 000011E0 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2683 000011E7 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2684                                  
  2685                                          ; Mantener la bola una posición arriba de la paleta
  2686 000011EE 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2687 000011F5 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2688                                  
  2689 000011FC E9CF000000                      jmp .end
  2690                                  
  2691                                  
  2692                                      .check_block_x:
  2693                                          ; Verificar colisión con bloques en X
  2694 00001201 4150                            push r8     ; Guardar registros que usa check_block_collision
  2695 00001203 4151                            push r9
  2696 00001205 4152                            push r10
  2697 00001207 E8B2080000                      call check_block_collision
  2698 0000120C 415A                            pop r10
  2699 0000120E 4159                            pop r9
  2700 00001210 4158                            pop r8
  2701 00001212 4885C0                          test rax, rax
  2702 00001215 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2703 00001217 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2704 0000121E E9AD000000                      jmp .end
  2705                                  
  2706                                      .check_paddle_x:
  2707                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2708 00001223 41803A3D                        cmp byte [r10], char_equal
  2709 00001227 750C                            jne .check_y_movement
  2710 00001229 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2711 00001230 E99B000000                      jmp .end
  2712                                  
  2713                                      .check_y_movement:
  2714                                          ; Calcular siguiente posición Y
  2715 00001235 488B05(3B150000)                mov rax, [ball3_direction_y]
  2716 0000123C 4901C1                          add r9, rax                  ; Nueva posición Y
  2717                                  
  2718                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2719 0000123F 4D89C2                          mov r10, r8
  2720 00001242 4981C2[400A0000]                add r10, board
  2721 00001249 4C89C9                          mov rcx, r9
  2722 0000124C B852000000                      mov rax, column_cells + 2
  2723 00001251 48F7E9                          imul rcx
  2724 00001254 4901C2                          add r10, rax
  2725                                  
  2726                                          ; Verificar si hay una X en la siguiente posición Y
  2727 00001257 418A02                          mov al, [r10]
  2728 0000125A 3C58                            cmp al, 'X'
  2729 0000125C 7509                            jne .check_block_y
  2730 0000125E 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2731 00001265 EB69                            jmp .end
  2732                                  
  2733                                      .check_block_y:
  2734                                          ; Verificar colisión con bloques en Y
  2735 00001267 4150                            push r8     ; Guardar registros que usa check_block_collision
  2736 00001269 4151                            push r9
  2737 0000126B 4152                            push r10
  2738 0000126D E84C080000                      call check_block_collision
  2739 00001272 415A                            pop r10
  2740 00001274 4159                            pop r9
  2741 00001276 4158                            pop r8
  2742 00001278 4885C0                          test rax, rax
  2743 0000127B 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2744 0000127D 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2745 00001284 EB4A                            jmp .end
  2746                                  
  2747                                      .check_paddle_y:
  2748                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2749 00001286 41803A3D                        cmp byte [r10], char_equal
  2750 0000128A 7536                            jne .update_position
  2751                                  
  2752                                          ; Verificar si el poder catch está activo
  2753 0000128C 803D(FC220000)01                cmp byte [catch_power_active], 1
  2754 00001293 7524                            jne .normal_bounce
  2755                                  
  2756                                          ; Activar el modo "atrapado"
  2757 00001295 C605(FF220000)01                mov byte [ball_caught_3], 1
  2758                                          
  2759                                          ; Guardar la posición X actual de la bola como offset
  2760 0000129C 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2761 000012A3 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2762 000012AA 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2763 000012B0 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2764                                          
  2765 000012B7 EB17                            jmp .end
  2766                                  
  2767                                      .normal_bounce:
  2768 000012B9 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2769 000012C0 EB0E                            jmp .end
  2770                                  
  2771                                  
  2772                                      .update_position:
  2773 000012C2 4C8905(23150000)                mov [ball3_x_pos], r8
  2774 000012C9 4C890D(2B150000)                mov [ball3_y_pos], r9
  2775                                  
  2776                                      .end:
  2777 000012D0 C3                              ret
  2778                                  
  2779                                  ; función para procesar la tecla C cuando la bola está atrapada
  2780                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2781                                  process_catch_release:
  2782 000012D1 55                          push rbp
  2783 000012D2 4889E5                      mov  rbp, rsp
  2784                                  
  2785                                      ; Verificar si el poder de catch está activo
  2786 000012D5 803D(FC220000)01            cmp byte [catch_power_active], 1
  2787 000012DC 0F8531010000                jne .no_catch_power
  2788                                  
  2789                                      ; Verificar si se presionó 'c' (derecha y arriba)
  2790 000012E2 803D(08230000)63            cmp byte [last_key], 'c'
  2791 000012E9 7412                        je .release_right
  2792                                      
  2793                                      ; Verificar si se presionó 'x' (izquierda y arriba)
  2794 000012EB 803D(08230000)78            cmp byte [last_key], 'x'
  2795 000012F2 0F8487000000                je .release_left
  2796                                      
  2797 000012F8 E916010000                  jmp .no_catch_power
  2798                                  
  2799                                  .release_right:
  2800                                      ; Liberar la bola hacia la derecha
  2801 000012FD 803D(FD220000)01            cmp byte [ball_caught], 1
  2802 00001304 7522                        jne .check_ball2_right
  2803 00001306 C605(FD220000)00            mov byte [ball_caught], 0
  2804 0000130D 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Derecha
  2804 00001315 000000             
  2805 00001318 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2805 00001320 FFFFFF             
  2806 00001323 E9CD000000                  jmp .release_complete
  2807                                  
  2808                                  .check_ball2_right:
  2809 00001328 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2810 0000132F 7522                        jne .check_ball3_right
  2811 00001331 C605(FE220000)00            mov byte [ball_caught_2], 0
  2812 00001338 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2812 00001340 000000             
  2813 00001343 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2813 0000134B FFFFFF             
  2814 0000134E E9A2000000                  jmp .release_complete
  2815                                  
  2816                                  .check_ball3_right:
  2817 00001353 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2818 0000135A 0F8595000000                jne .release_complete
  2819 00001360 C605(FF220000)00            mov byte [ball_caught_3], 0
  2820 00001367 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2820 0000136F 000000             
  2821 00001372 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2821 0000137A FFFFFF             
  2822 0000137D EB76                        jmp .release_complete
  2823                                  
  2824                                  .release_left:
  2825                                      ; Liberar la bola hacia la izquierda
  2826 0000137F 803D(FD220000)01            cmp byte [ball_caught], 1
  2827 00001386 751F                        jne .check_ball2_left
  2828 00001388 C605(FD220000)00            mov byte [ball_caught], 0
  2829 0000138F 48C705(EF140000)FF-         mov qword [ball_direction_x], -1   ; Izquierda
  2829 00001397 FFFFFF             
  2830 0000139A 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2830 000013A2 FFFFFF             
  2831 000013A5 EB4E                        jmp .release_complete
  2832                                  
  2833                                  .check_ball2_left:
  2834 000013A7 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2835 000013AE 751F                        jne .check_ball3_left
  2836 000013B0 C605(FE220000)00            mov byte [ball_caught_2], 0
  2837 000013B7 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  2837 000013BF FFFFFF             
  2838 000013C2 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2838 000013CA FFFFFF             
  2839 000013CD EB26                        jmp .release_complete
  2840                                  
  2841                                  .check_ball3_left:
  2842 000013CF 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2843 000013D6 751D                        jne .release_complete
  2844 000013D8 C605(FF220000)00            mov byte [ball_caught_3], 0
  2845 000013DF 48C705(33150000)FF-         mov qword [ball3_direction_x], -1
  2845 000013E7 FFFFFF             
  2846 000013EA 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2846 000013F2 FFFFFF             
  2847                                  
  2848                                  .release_complete:
  2849                                      ; Si era el catch inicial, desactivarlo
  2850 000013F5 803D(FB220000)01            cmp byte [initial_catch_active], 1
  2851 000013FC 750E                        jne .finish
  2852 000013FE C605(FB220000)00            mov byte [initial_catch_active], 0
  2853 00001405 C605(FC220000)00            mov byte [catch_power_active], 0  ; Desactivar poder de catch después de la 1ra vez
  2854                                  
  2855                                  .finish:
  2856 0000140C C605(08230000)00            mov byte [last_key], 0  ; Limpiar la tecla
  2857                                  .no_catch_power:
  2858 00001413 5D                          pop rbp
  2859 00001414 C3                          ret
  2860                                  
  2861                                  
  2862                                  
  2863                                  display_level_number:   ; Función para mostrar el número del nivel
  2864 00001415 55                          push rbp
  2865 00001416 4889E5                      mov rbp, rsp
  2866                                      
  2867                                      ; Limpiar la pantalla primero
  2868                                      print clear, clear_length
    93 00001419 B801000000          <1>  mov eax, sys_write
    94 0000141E BF01000000          <1>  mov edi, 1
    95 00001423 48BE-               <1>  mov rsi, %1
    95 00001425 [1000000000000000]  <1>
    96 0000142D BA07000000          <1>  mov edx, %2
    97 00001432 0F05                <1>  syscall
  2869                                      
  2870                                      ; Calcular la posición central para el mensaje
  2871                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2872 00001434 B850000000                  mov rax, column_cells
  2873 00001439 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2874 0000143D 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2875                                      
  2876                                      ; Calcular la fila central
  2877 00001440 BB20000000                  mov rbx, row_cells
  2878 00001445 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2879                                      
  2880                                      ; Calcular el offset en el buffer
  2881 00001448 B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2882 0000144D 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2883 00001450 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2884                                      
  2885                                      ; Escribir "NIVEL " en la posición calculada
  2886 00001453 488DB8[400A0000]            lea rdi, [board + rax]
  2887 0000145A 48BE-                       mov rsi, level_msg       ; mensaje "NIVEL "
  2887 0000145C [A414000000000000] 
  2888 00001464 B906000000                  mov rcx, level_msg_len  ; longitud del mensaje
  2889 00001469 F3A4                        rep movsb
  2890                                      
  2891                                      ; Escribir el número del nivel
  2892 0000146B 8A05(79150000)              mov al, [current_level]
  2893 00001471 0430                        add al, '0'                 ; convertir a ASCII
  2894 00001473 8807                        mov [rdi], al
  2895                                      
  2896                                      ; Mostrar el board con el mensaje
  2897                                      print board, board_size
    93 00001475 B801000000          <1>  mov eax, sys_write
    94 0000147A BF01000000          <1>  mov edi, 1
    95 0000147F 48BE-               <1>  mov rsi, %1
    95 00001481 [400A000000000000]  <1>
    96 00001489 BA400A0000          <1>  mov edx, %2
    97 0000148E 0F05                <1>  syscall
  2898                                      
  2899                                      ; Esperar un segundo
  2900 00001490 B823000000                  mov rax, sys_nanosleep
  2901 00001495 48BF-                       mov rdi, level_display_time
  2901 00001497 [AF14000000000000] 
  2902 0000149F 4831F6                      xor rsi, rsi
  2903 000014A2 0F05                        syscall
  2904                                      
  2905 000014A4 5D                          pop rbp
  2906 000014A5 C3                          ret
  2907                                  
  2908                                  ; Función para inicializar un tablero vacío
  2909                                  init_empty_board:   ; Inicializar un tablero vacío
  2910 000014A6 56                          push rsi
  2911 000014A7 57                          push rdi
  2912 000014A8 51                          push rcx
  2913 000014A9 50                          push rax
  2914                                  
  2915 000014AA 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2916 000014B1 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2917 000014B8 B9400A0000                  mov rcx, board_template_size
  2918 000014BD F3A4                        rep movsb                   ; Copiar el tablero
  2919                                  
  2920 000014BF 58                          pop rax
  2921 000014C0 59                          pop rcx
  2922 000014C1 5F                          pop rdi
  2923 000014C2 5E                          pop rsi
  2924 000014C3 C3                          ret
  2925                                  
  2926                                  clear_enemies_from_board:   ; Función para limpiar los enemigos del tablero
  2927 000014C4 55                          push rbp
  2928 000014C5 4889E5                      mov rbp, rsp
  2929 000014C8 56                          push rsi
  2930 000014C9 57                          push rdi
  2931                                  
  2932                                      ; Primero limpiar board
  2933 000014CA B9400A0000                  mov rcx, board_size      
  2934 000014CF 488D35(400A0000)            lea rsi, [board]         
  2935                                  
  2936                                  .clear_loop:
  2937 000014D6 4883F900                    cmp rcx, 0              
  2938 000014DA 741F                        je .clear_template      ; En vez de terminar, vamos a limpiar template
  2939                                      
  2940 000014DC 8A06                        mov al, [rsi]           
  2941 000014DE 3C40                        cmp al, '@'             
  2942 000014E0 740E                        je .make_space
  2943 000014E2 3C23                        cmp al, '#'             
  2944 000014E4 740A                        je .make_space
  2945 000014E6 3C24                        cmp al, '$'             
  2946 000014E8 7406                        je .make_space
  2947 000014EA 3C26                        cmp al, '&'             
  2948 000014EC 7402                        je .make_space
  2949                                      
  2950 000014EE EB03                        jmp .next               
  2951                                  
  2952                                  .make_space:
  2953 000014F0 C60620                      mov byte [rsi], ' '         ; Reemplazar enemigo con espacio
  2954                                  
  2955                                  .next:
  2956 000014F3 48FFC6                      inc rsi                 
  2957 000014F6 48FFC9                      dec rcx                
  2958 000014F9 EBDB                        jmp .clear_loop        
  2959                                  
  2960                                  .clear_template:
  2961                                      ; Ahora limpiar board_template
  2962 000014FB B9400A0000                  mov rcx, board_template_size
  2963 00001500 488D35(00000000)            lea rsi, [board_template]   
  2964                                  
  2965                                  .template_loop: ; Bucle para limpiar la plantilla
  2966 00001507 4883F900                    cmp rcx, 0
  2967 0000150B 741F                        je .end
  2968                                      
  2969 0000150D 8A06                        mov al, [rsi]
  2970 0000150F 3C40                        cmp al, '@'
  2971 00001511 740E                        je .make_space_template
  2972 00001513 3C23                        cmp al, '#'
  2973 00001515 740A                        je .make_space_template
  2974 00001517 3C24                        cmp al, '$'
  2975 00001519 7406                        je .make_space_template
  2976 0000151B 3C26                        cmp al, '&'
  2977 0000151D 7402                        je .make_space_template
  2978                                      
  2979 0000151F EB03                        jmp .next_template
  2980                                  
  2981                                  .make_space_template:
  2982 00001521 C60620                      mov byte [rsi], ' '
  2983                                  
  2984                                  .next_template:
  2985 00001524 48FFC6                      inc rsi
  2986 00001527 48FFC9                      dec rcx
  2987 0000152A EBDB                        jmp .template_loop
  2988                                  
  2989                                  .end:
  2990 0000152C 5F                          pop rdi
  2991 0000152D 5E                          pop rsi
  2992 0000152E 5D                          pop rbp
  2993 0000152F C3                          ret
  2994                                  
  2995                                  
  2996                                  init_level:  ; Función para inicializar un nivel
  2997 00001530 E88FFFFFFF                  call clear_enemies_from_board
  2998 00001535 C605(22150000)00            mov byte [ball2_active], 0
  2999 0000153C C605(44150000)00            mov byte [ball3_active], 0
  3000 00001543 C605(09230000)00            mov byte [laser_power_active], 0
  3001 0000154A E898F2FFFF                  call clear_lasers
  3002 0000154F 488B05(CF140000)            mov rax, [default_pallet_size]
  3003 00001556 488905(C7140000)            mov [pallet_size], rax
  3004 0000155D 48C705(E3220000)07-         mov qword [ball_speed], 7    ; Restaurar velocidad normal
  3004 00001565 000000             
  3005                                  
  3006                                      ; 1) Copiamos board_template en board para que quede limpio
  3007                                          ; Reiniciar letras activas
  3008 00001568 488D3D(3C210000)            lea rdi, [letters_map]
  3009 0000156F B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  3010 00001574 4831C0                      xor rax, rax
  3011 00001577 F3AA                        rep stosb                    ; Llenar con ceros
  3012                                      
  3013                                      ; Inicializar dirección de la bola (derecha y arriba)
  3014 00001579 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  3014 00001581 000000             
  3015 00001584 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  3015 0000158C FFFFFF             
  3016                                  
  3017                                      ; En init_level, después de inicializar las direcciones
  3018 0000158F C605(FC220000)01            mov byte [catch_power_active], 1    ; Activar el poder catch
  3019 00001596 C605(FD220000)01            mov byte [ball_caught], 1           ; Marcar la bola como atrapada
  3020 0000159D C605(FB220000)01            mov byte [initial_catch_active], 1  ; Marcar que es el catch inicial
  3021                                  
  3022                                      ; Calcular y guardar el offset inicial de la bola respecto a la paleta
  3023 000015A4 488B05(DF140000)            mov rax, [ball_x_pos]              ; Posición X actual de la bola
  3024 000015AB 482B05(BF140000)            sub rax, [pallet_position]         ; Restar la posición de la paleta
  3025 000015B2 4805[400A0000]              add rax, board                     ; Ajustar por el offset del tablero
  3026 000015B8 488905(00230000)            mov [ball_catch_offset], rax       ; Guardar el offset
  3027                                  
  3028                                  
  3029                                  
  3030                                      ; Reiniciar contador de letras activas
  3031 000015BF 4831C0                      xor rax, rax
  3032 000015C2 8805(CC220000)              mov [letters_count], al
  3033                                  
  3034                                      ; Reiniciar última letra capturada
  3035 000015C8 C605(CD220000)20            mov byte [last_letter], ' '
  3036 000015CF C605(46200000)00            mov byte [destroyed_blocks], 0 
  3037 000015D6 E8CBFEFFFF                  call init_empty_board
  3038 000015DB E835FEFFFF                  call display_level_number
  3039                                  
  3040 000015E0 56                          push rsi
  3041 000015E1 57                          push rdi
  3042 000015E2 51                          push rcx
  3043 000015E3 50                          push rax
  3044                                  
  3045 000015E4 488D35(00000000)            lea rsi, [board_template]
  3046 000015EB 488D3D(400A0000)            lea rdi, [board]
  3047 000015F2 B9400A0000                  mov rcx, board_template_size
  3048 000015F7 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  3049                                  
  3050 000015F9 58                          pop rax
  3051 000015FA 59                          pop rcx
  3052 000015FB 5F                          pop rdi
  3053 000015FC 5E                          pop rsi
  3054                                  
  3055 000015FD B90A000000                  mov rcx, 10
  3056 00001602 4831C0                      xor rax, rax
  3057 00001605 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3058 0000160C F3AA                        rep stosb   
  3059 0000160E E8D4050000                  call init_enemies   
  3060                                  
  3061                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  3062 00001613 803D(79150000)01            cmp byte [current_level], 1
  3063 0000161A 7431                        je .level1
  3064 0000161C 803D(79150000)02            cmp byte [current_level], 2
  3065 00001623 7454                        je .level2
  3066 00001625 803D(79150000)03            cmp byte [current_level], 3
  3067 0000162C 7477                        je .level3
  3068 0000162E 803D(79150000)04            cmp byte [current_level], 4
  3069 00001635 0F8492000000                je .level4
  3070 0000163B 803D(79150000)05            cmp byte [current_level], 5
  3071 00001642 0F84B0000000                je .level5
  3072 00001648 E9D3000000                  jmp .done
  3073                                  
  3074                                  
  3075                                  
  3076                                      .level1:
  3077 0000164D C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  3078 00001654 4831C9                          xor rcx, rcx             
  3079                                          .init_loop1:    ; Bucle para inicializar los bloques del nivel 1
  3080 00001657 4883F94E                            cmp rcx, level1_blocks_count
  3081 0000165B 0F8DBF000000                        jge .done   ; Si ya inicializamos todos los bloques, terminar
  3082 00001661 4889C8                              mov rax, rcx              
  3083 00001664 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3084 00001668 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]       
  3085 0000166E 8891[761F0000]                      mov byte [block_states + rcx], dl
  3086 00001674 48FFC1                              inc rcx        ; Incrementar contador
  3087 00001677 EBDE                                jmp .init_loop1
  3088                                  
  3089                                      .level2:
  3090 00001679 C605(7A150000)5B                mov byte [blocks_remaining], level2_blocks_count    ; Inicializar el contador de bloques restantes
  3091 00001680 4831C9                          xor rcx, rcx             
  3092                                          .init_loop2:
  3093 00001683 4883F95B                            cmp rcx, level2_blocks_count
  3094 00001687 0F8D93000000                        jge .done
  3095 0000168D 4889C8                              mov rax, rcx         
  3096 00001690 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3097 00001694 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  3098 0000169A 8891[761F0000]                      mov byte [block_states + rcx], dl
  3099 000016A0 48FFC1                              inc rcx
  3100 000016A3 EBDE                                jmp .init_loop2
  3101                                      .level3:
  3102 000016A5 C605(7A150000)40                mov byte [blocks_remaining], 64
  3103 000016AC 4831C9                          xor rcx, rcx             
  3104                                          .init_loop3:
  3105 000016AF 4883F968                            cmp rcx, level3_blocks_count
  3106 000016B3 7D6B                                jge .done
  3107 000016B5 4889C8                              mov rax, rcx         
  3108 000016B8 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3109 000016BC 8A90[CB180000]                      mov dl, byte [level3_blocks + rax + 3]  
  3110 000016C2 8891[761F0000]                      mov byte [block_states + rcx], dl
  3111 000016C8 48FFC1                              inc rcx
  3112 000016CB EBE2                                jmp .init_loop3
  3113                                  
  3114                                      .level4:
  3115 000016CD C605(7A150000)8C                mov byte [blocks_remaining], level4_blocks_count
  3116 000016D4 4831C9                          xor rcx, rcx             
  3117                                          .init_loop4:
  3118 000016D7 4881F98C000000                      cmp rcx, level4_blocks_count
  3119 000016DE 7D40                                jge .done
  3120 000016E0 4889C8                              mov rax, rcx         
  3121 000016E3 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3122 000016E7 8A90[D31A0000]                      mov dl, byte [level4_blocks + rax + 3]  
  3123 000016ED 8891[761F0000]                      mov byte [block_states + rcx], dl
  3124 000016F3 48FFC1                              inc rcx
  3125 000016F6 EBDF                                jmp .init_loop4
  3126                                  
  3127                                      .level5:
  3128 000016F8 C605(7A150000)62                mov byte [blocks_remaining], level5_blocks_count
  3129 000016FF 4831C9                          xor rcx, rcx             
  3130                                          .init_loop5:
  3131 00001702 4883F962                            cmp rcx, level5_blocks_count
  3132 00001706 7D18                                jge .done
  3133 00001708 4889C8                              mov rax, rcx         
  3134 0000170B 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3135 0000170F 8A90[8F1D0000]                      mov dl, byte [level5_blocks + rax + 3]  
  3136 00001715 8891[761F0000]                      mov byte [block_states + rcx], dl
  3137 0000171B 48FFC1                              inc rcx
  3138 0000171E EBE2                                jmp .init_loop5
  3139                                      .done:
  3140 00001720 C3                              ret
  3141                                  
  3142                                  
  3143                                  ; Función para verificar y manejar la transición de nivel
  3144                                  check_level_complete:   ; Verificar si el nivel está completo
  3145                                      ; Verificar si quedan bloques
  3146 00001721 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Si no quedan bloques
  3147 00001728 7556                        jne .not_complete            ; No completado, continuar con el nivel actual
  3148                                      
  3149                                      ; Incrementar el nivel
  3150 0000172A FE05(79150000)              inc byte [current_level]    ; Incrementar el nivel
  3151                                      
  3152                                      ; Verificar si hemos completado todos los niveles
  3153 00001730 803D(79150000)06            cmp byte [current_level], 6 ; Si hemos completado todos los niveles
  3154 00001737 7448                        je game_win               ; Ganar el juego
  3155                                      
  3156                                  
  3157 00001739 E886FDFFFF                  call clear_enemies_from_board
  3158                                      ; Primero establecer las posiciones seguras
  3159 0000173E 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  3159 00001745 [B0130000]         
  3160 00001749 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  3160 00001751 000000             
  3161 00001754 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  3161 0000175C 000000             
  3162 0000175F C605(FF140000)00            mov byte [ball_moving], 0
  3163                                      
  3164                                      ; Asegurar que la bola esté en un estado seguro
  3165 00001766 C605(FC220000)01            mov byte [catch_power_active], 1
  3166 0000176D C605(FD220000)01            mov byte [ball_caught], 1
  3167 00001774 C605(FB220000)01            mov byte [initial_catch_active], 1
  3168                                      
  3169                                      ; Reinicializar el juego para el siguiente nivel
  3170 0000177B E8B0FDFFFF                  call init_level
  3171                                      
  3172                                  .not_complete:
  3173 00001780 C3                          ret
  3174                                  
  3175                                      ; Nueva función para manejar la victoria del juego
  3176                                  game_win:
  3177                                      ; Limpiar la pantalla primero
  3178                                      print clear, clear_length
    93 00001781 B801000000          <1>  mov eax, sys_write
    94 00001786 BF01000000          <1>  mov edi, 1
    95 0000178B 48BE-               <1>  mov rsi, %1
    95 0000178D [1000000000000000]  <1>
    96 00001795 BA07000000          <1>  mov edx, %2
    97 0000179A 0F05                <1>  syscall
  3179                                      
  3180                                      ; Mensaje de victoria
  3181 0000179C 488B05(3E200000)            mov rax, [current_score]    ; Obtener el puntaje final
  3182 000017A3 48BF-                       mov rdi, number_buffer      ; Convertir a string
  3182 000017A5 [4720000000000000] 
  3183 000017AD E8B4010000                  call number_to_string
  3184                                      
  3185                                      ; Definir mensaje de victoria
  3186                                      section .data
  3187 0000246F C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  3187 00002478 616465732120C2A148-
  3187 00002481 61732067616E61646F-
  3187 0000248A 210A0D             
  3188                                          win_msg_len: equ $ - win_msg
  3189 0000248D 50756E74616A652066-             score_msg: db "Puntaje final: "
  3189 00002496 696E616C3A20       
  3190                                          score_msg_len: equ $ - score_msg
  3191                                      section .text
  3192                                      
  3193                                      ; Imprimir mensajes
  3194                                      print win_msg, win_msg_len
    93 000017B2 B801000000          <1>  mov eax, sys_write
    94 000017B7 BF01000000          <1>  mov edi, 1
    95 000017BC 48BE-               <1>  mov rsi, %1
    95 000017BE [6F24000000000000]  <1>
    96 000017C6 BA1E000000          <1>  mov edx, %2
    97 000017CB 0F05                <1>  syscall
  3195                                      print score_msg, score_msg_len
    93 000017CD B801000000          <1>  mov eax, sys_write
    94 000017D2 BF01000000          <1>  mov edi, 1
    95 000017D7 48BE-               <1>  mov rsi, %1
    95 000017D9 [8D24000000000000]  <1>
    96 000017E1 BA0F000000          <1>  mov edx, %2
    97 000017E6 0F05                <1>  syscall
  3196                                      print number_buffer, 20
    93 000017E8 B801000000          <1>  mov eax, sys_write
    94 000017ED BF01000000          <1>  mov edi, 1
    95 000017F2 48BE-               <1>  mov rsi, %1
    95 000017F4 [4720000000000000]  <1>
    96 000017FC BA14000000          <1>  mov edx, %2
    97 00001801 0F05                <1>  syscall
  3197                                      
  3198                                      ; Esperar un momento antes de salir
  3199 00001803 48C705F2E7FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  3199 0000180C 0000               
  3200 0000180E 48C705EFE7FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  3200 00001817 0000               
  3201                                      sleeptime
   109 00001819 B823000000          <1>  mov eax, sys_nanosleep
   110 0000181E 48BF-               <1>  mov rdi, timespec
   110 00001820 [0000000000000000]  <1>
   111 00001828 31F6                <1>  xor esi, esi
   112 0000182A 0F05                <1>  syscall
  3202                                      
  3203 0000182C E9B30B0000                  jmp exit
  3204                                  
  3205                                  ; unción para obtener el puntero a los bloques del nivel actual
  3206                                  get_current_level_blocks:
  3207 00001831 803D(79150000)01            cmp byte [current_level], 1
  3208 00001838 7428                        je .level1
  3209 0000183A 803D(79150000)02            cmp byte [current_level], 2
  3210 00001841 7427                        je .level2
  3211 00001843 803D(79150000)03            cmp byte [current_level], 3
  3212 0000184A 7426                        je .level3
  3213 0000184C 803D(79150000)04            cmp byte [current_level], 4
  3214 00001853 7425                        je .level4
  3215 00001855 803D(79150000)05            cmp byte [current_level], 5
  3216 0000185C 7424                        je .level5
  3217                                      ; Si llegamos aquí, hay un error en el nivel
  3218 0000185E 4831C0                      xor rax, rax
  3219 00001861 C3                          ret
  3220                                  
  3221                                      .level1:
  3222 00001862 488D05(7B150000)                lea rax, [level1_blocks]
  3223 00001869 C3                              ret
  3224                                      .level2:
  3225 0000186A 488D05(01170000)                lea rax, [level2_blocks]
  3226 00001871 C3                              ret
  3227                                      .level3:
  3228 00001872 488D05(C8180000)                lea rax, [level3_blocks]
  3229 00001879 C3                              ret
  3230                                      .level4:
  3231 0000187A 488D05(D01A0000)                lea rax, [level4_blocks]
  3232 00001881 C3                              ret
  3233                                      .level5:
  3234 00001882 488D05(8C1D0000)                lea rax, [level5_blocks]
  3235 00001889 C3                              ret
  3236                                  ; Función para obtener la cantidad de bloques del nivel actual
  3237                                  get_current_level_count:
  3238 0000188A 803D(79150000)01            cmp byte [current_level], 1
  3239 00001891 7428                        je .level1
  3240 00001893 803D(79150000)02            cmp byte [current_level], 2
  3241 0000189A 7425                        je .level2
  3242 0000189C 803D(79150000)03            cmp byte [current_level], 3
  3243 000018A3 7422                        je .level3
  3244 000018A5 803D(79150000)04            cmp byte [current_level], 4
  3245 000018AC 741F                        je .level4
  3246 000018AE 803D(79150000)05            cmp byte [current_level], 5
  3247 000018B5 741C                        je .level5
  3248                                      ; Si llegamos aquí, hay un error en el nivel
  3249 000018B7 4831C0                      xor rax, rax
  3250 000018BA C3                          ret
  3251                                  
  3252                                      .level1:
  3253 000018BB B84E000000                      mov rax, level1_blocks_count
  3254 000018C0 C3                              ret
  3255                                      .level2:
  3256 000018C1 B85B000000                      mov rax, level2_blocks_count
  3257 000018C6 C3                              ret
  3258                                      .level3:
  3259 000018C7 B868000000                      mov rax, level3_blocks_count
  3260 000018CC C3                              ret
  3261                                      .level4:
  3262 000018CD B88C000000                      mov rax, level4_blocks_count
  3263 000018D2 C3                              ret
  3264                                      .level5:
  3265 000018D3 B862000000                      mov rax, level5_blocks_count
  3266 000018D8 C3                              ret
  3267                                  
  3268                                  ; Función para imprimir los bloques del nivel actual
  3269                                  print_blocks:   ; Imprimir los bloques del nivel actual
  3270 000018D9 55                          push rbp                  ; Guardar el puntero de la pila
  3271 000018DA 4889E5                      mov rbp, rsp          ; Establecer el puntero de la pila
  3272                                      
  3273                                      ; Obtener puntero a los bloques del nivel actual
  3274 000018DD E84FFFFFFF                  call get_current_level_blocks
  3275 000018E2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  3276                                      
  3277                                      ; Obtener cantidad de bloques del nivel actual
  3278 000018E5 E8A0FFFFFF                  call get_current_level_count
  3279 000018EA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  3280                                      
  3281 000018ED 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  3282                                      
  3283                                      .print_loop:              ; Bucle para imprimir los bloques
  3284 000018F0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  3285 000018F3 7D6F                            jge .end              ; Si ya imprimimos todos los bloques, terminar
  3286                                          
  3287                                          ; Verificar si el bloque está activo
  3288 000018F5 490FB68424-                     movzx rax, byte [block_states + r12]
  3288 000018FA [761F0000]         
  3289 000018FE 4885C0                          test rax, rax
  3290 00001901 745C                            jz .next_block
  3291                                          
  3292                                          ; Obtener posición y tipo del bloque usando r13
  3293 00001903 4C89E0                          mov rax, r12
  3294 00001906 486BC005                        imul rax, 5
  3295 0000190A 4C01E8                          add rax, r13
  3296 0000190D 448A00                          mov r8b, [rax]        ; X position
  3297 00001910 448A4801                        mov r9b, [rax + 1]    ; Y position
  3298 00001914 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  3299                                  
  3300                                          ; El resto de la lógica de impresión permanece igual
  3301 00001918 4D0FB6C0                        movzx r8, r8b
  3302 0000191C 4D0FB6C9                        movzx r9, r9b
  3303 00001920 4981C0[400A0000]                add r8, board
  3304 00001927 B852000000                      mov rax, column_cells + 2
  3305 0000192C 49F7E1                          mul r9
  3306 0000192F 4901C0                          add r8, rax
  3307                                          
  3308 00001932 B906000000                      mov rcx, block_length
  3309 00001937 48BE-                           mov rsi, block_type_1
  3309 00001939 [5515000000000000] 
  3310 00001941 490FB6C2                        movzx rax, r10b
  3311 00001945 48FFC8                          dec rax
  3312 00001948 486BC006                        imul rax, block_length
  3313 0000194C 4801C6                          add rsi, rax
  3314                                          
  3315                                      .print_block_chars:   ; Bucle para imprimir los caracteres del bloque
  3316 0000194F 8A06                            mov al, [rsi]   ; Obtener el carácter
  3317 00001951 418800                          mov [r8], al    ; Escribir en el tablero
  3318 00001954 48FFC6                          inc rsi        ; Siguiente carácter
  3319 00001957 49FFC0                          inc r8          ; Siguiente posición
  3320 0000195A 48FFC9                          dec rcx        ; Decrementar contador
  3321 0000195D 75F0                            jnz .print_block_chars  ; Repetir si no hemos terminado
  3322                                          
  3323                                      .next_block:      ; Continuar con el siguiente bloque
  3324 0000195F 49FFC4                          inc r12         ; Incrementar el índice del bloque
  3325 00001962 EB8C                            jmp .print_loop ; Repetir el bucle
  3326                                          
  3327                                      .end:
  3328 00001964 5D                              pop rbp
  3329 00001965 C3                              ret
  3330                                  
  3331                                  ; Función para convertir número a string
  3332                                  ; Input: RAX = número a convertir
  3333                                  ; RDI = buffer donde escribir el string
  3334                                  number_to_string:
  3335 00001966 53                          push rbx
  3336 00001967 52                          push rdx
  3337 00001968 56                          push rsi
  3338 00001969 BB0A000000                  mov rbx, 10          ; Divisor
  3339 0000196E B900000000                  mov rcx, 0          ; Contador de dígitos
  3340                                      
  3341                                      ; Si el número es 0, manejarlo especialmente
  3342 00001973 4885C0                      test rax, rax
  3343 00001976 7509                        jnz .convert_loop   ; Saltar si no es 0
  3344 00001978 C60730                      mov byte [rdi], '0'
  3345 0000197B C6470100                    mov byte [rdi + 1], 0   ; Null terminator
  3346 0000197F EB20                        jmp .end
  3347                                      
  3348                                      .convert_loop:
  3349 00001981 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  3350 00001984 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  3351 00001987 80C230                          add dl, '0'     ; Convertir a ASCII
  3352 0000198A 52                              push rdx        ; Guardar el dígito
  3353 0000198B 48FFC1                          inc rcx         ; Incrementar contador
  3354 0000198E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  3355 00001991 75EE                            jnz .convert_loop
  3356                                          
  3357                                      .write_loop:
  3358 00001993 5A                              pop rdx         ; Obtener dígito
  3359 00001994 8817                            mov [rdi], dl   ; Escribir al buffer
  3360 00001996 48FFC7                          inc rdi         ; Siguiente posición
  3361 00001999 48FFC9                          dec rcx         ; Decrementar contador
  3362 0000199C 75F5                            jnz .write_loop
  3363                                          
  3364 0000199E C60700                      mov byte [rdi], 0   ; Null terminator
  3365                                      
  3366                                      .end:
  3367 000019A1 5E                          pop rsi
  3368 000019A2 5A                          pop rdx
  3369 000019A3 5B                          pop rbx
  3370 000019A4 C3                          ret
  3371                                  
  3372                                  ; Función para imprimir los labels
  3373                                  print_labels:
  3374 000019A5 55                          push rbp
  3375 000019A6 4889E5                      mov rbp, rsp
  3376                                  
  3377                                      ; Crear buffer temporal
  3378 000019A9 4883EC20                    sub rsp, 32
  3379                                  
  3380                                      ; Copiar labels a buffer temporal
  3381 000019AD 4889E7                      mov rdi, rsp
  3382 000019B0 488D35(F3200000)            lea rsi, [score_label]
  3383 000019B7 B917000000                  mov rcx, score_label_len
  3384 000019BC F3A4                        rep movsb
  3385                                  
  3386                                      ; Convertir score a string
  3387 000019BE 488B05(3E200000)            mov rax, [current_score]
  3388 000019C5 48BF-                       mov rdi, number_buffer
  3388 000019C7 [4720000000000000] 
  3389 000019CF E892FFFFFF                  call number_to_string
  3390                                  
  3391                                      ; Calcular longitud del número
  3392 000019D4 B900000000                  mov rcx, 0
  3393 000019D9 48BF-                       mov rdi, number_buffer
  3393 000019DB [4720000000000000] 
  3394                                      .count_loop:        ; Bucle para contar la longitud del número
  3395 000019E3 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3396 000019E7 7405                            je .count_done       ; Si es así, terminar
  3397 000019E9 48FFC1                          inc rcx             ; Incrementar contador
  3398 000019EC EBF5                            jmp .count_loop    ; Repetir el bucle
  3399                                      .count_done:      ; Conteo terminado
  3400                                  
  3401                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3402 000019EE 4889E7                      mov rdi, rsp      ; Inicializar RDI al buffer temporal
  3403 000019F1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  3404 000019F5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  3405 000019FA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  3406                                      .pad_loop:                 ; Bucle para añadir padding
  3407 000019FD 4885F6                          test rsi, rsi       ; Verificar si terminamos
  3408 00001A00 740B                            jz .pad_done    ; Si es así, terminar
  3409 00001A02 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3410 00001A05 48FFC7                          inc rdi            ; Siguiente posición
  3411 00001A08 48FFCE                          dec rsi           ; Decrementar contador
  3412 00001A0B EBF0                            jmp .pad_loop   ; Repetir el bucle
  3413                                      .pad_done:    ; Padding añadido
  3414                                  
  3415                                      ; Copiar el número
  3416 00001A0D 48BE-                       mov rsi, number_buffer  ; Inicializar RSI al número
  3416 00001A0F [4720000000000000] 
  3417 00001A17 F3A4                        rep movsb            ; Copiar el número al buffer temporal
  3418                                  
  3419                                      ; Imprimir el buffer completo   
  3420                                      print rsp, score_label_len  ; Imprimir el buffer
    93 00001A19 B801000000          <1>  mov eax, sys_write
    94 00001A1E BF01000000          <1>  mov edi, 1
    95 00001A23 4889E6              <1>  mov rsi, %1
    96 00001A26 BA17000000          <1>  mov edx, %2
    97 00001A2B 0F05                <1>  syscall
  3421                                  
  3422                                      ; Repetir proceso para bloques destruidos   
  3423 00001A2D 4889E7                      mov rdi, rsp    ; Inicializar RDI al buffer temporal
  3424 00001A30 488D35(0A210000)            lea rsi, [blocks_label] ; Inicializar RSI al label de bloques
  3425 00001A37 B91B000000                  mov rcx, blocks_label_len   ; Longitud del label
  3426 00001A3C F3A4                        rep movsb   ; Copiar el label al buffer temporal
  3427                                  
  3428                                      ; Verificar que el `[` esté en su posición correcta
  3429 00001A3E 4889E7                      mov rdi, rsp
  3430 00001A41 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  3431 00001A45 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  3432                                  
  3433                                      ; Convertir bloques destruidos a string
  3434 00001A48 480FB605(46200000)          movzx rax, byte [destroyed_blocks]  ; Obtener el número de bloques destruidos
  3435 00001A50 48BF-                       mov rdi, number_buffer      ; Convertir a string
  3435 00001A52 [4720000000000000] 
  3436 00001A5A E807FFFFFF                  call number_to_string   ; Convertir a string
  3437                                  
  3438                                      ; Calcular longitud del número
  3439 00001A5F B900000000                  mov rcx, 0
  3440 00001A64 48BF-                       mov rdi, number_buffer  ; Inicializar RDI al número
  3440 00001A66 [4720000000000000] 
  3441                                      .count_loop2:     ; Bucle para contar la longitud del número
  3442 00001A6E 803C0F00                        cmp byte [rdi + rcx], 0 ; Verificar si llegamos al final
  3443 00001A72 7405                            je .count_done2   ; Si es así, terminar
  3444 00001A74 48FFC1                          inc rcx          ; Incrementar contador
  3445 00001A77 EBF5                            jmp .count_loop2    ; Repetir el bucle
  3446                                      .count_done2:   ; Conteo terminado
  3447                                  
  3448                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3449 00001A79 4889E7                      mov rdi, rsp
  3450 00001A7C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  3451 00001A80 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  3452 00001A85 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  3453                                      .pad_loop2:
  3454 00001A88 4885F6                          test rsi, rsi    ; Verificar si terminamos
  3455 00001A8B 740B                            jz .pad_done2   ; Si es así, terminar
  3456 00001A8D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3457 00001A90 48FFC7                          inc rdi
  3458 00001A93 48FFCE                          dec rsi
  3459 00001A96 EBF0                            jmp .pad_loop2  ; Repetir el bucle
  3460                                      .pad_done2:
  3461                                  
  3462                                      ; Copiar el número
  3463 00001A98 48BE-                       mov rsi, number_buffer
  3463 00001A9A [4720000000000000] 
  3464 00001AA2 F3A4                        rep movsb
  3465                                  
  3466                                      ; Imprimir el buffer completo
  3467                                      print rsp, blocks_label_len
    93 00001AA4 B801000000          <1>  mov eax, sys_write
    94 00001AA9 BF01000000          <1>  mov edi, 1
    95 00001AAE 4889E6              <1>  mov rsi, %1
    96 00001AB1 BA1B000000          <1>  mov edx, %2
    97 00001AB6 0F05                <1>  syscall
  3468                                  
  3469                                      ; Restaurar stack
  3470 00001AB8 4883C420                    add rsp, 32     
  3471 00001ABC 5D                          pop rbp
  3472 00001ABD C3                          ret
  3473                                  
  3474                                  
  3475                                  
  3476                                  check_block_collision:  ; Función para verificar colisión con bloques
  3477 00001ABE 55                          push rbp              ; Guardar el puntero de la pila
  3478 00001ABF 4889E5                      mov rbp, rsp      ; Establecer el puntero de la pila
  3479                                  
  3480                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  3481 00001AC2 418A02                      mov al, [r10]
  3482                                  
  3483                                      ; Verificar si el carácter es un bloque
  3484 00001AC5 3C55                        cmp al, 'U'  
  3485 00001AC7 7419                        je .possible
  3486 00001AC9 3C4F                        cmp al, 'O'  
  3487 00001ACB 7415                        je .possible
  3488 00001ACD 3C44                        cmp al, 'D'  
  3489 00001ACF 7411                        je .possible
  3490 00001AD1 3C4C                        cmp al, 'L'  
  3491 00001AD3 740D                        je .possible
  3492 00001AD5 3C56                        cmp al, 'V'  
  3493 00001AD7 7409                        je .possible
  3494 00001AD9 3C38                        cmp al, '8'  
  3495 00001ADB 7405                        je .possible
  3496                                  
  3497                                      ; No es bloque, salir
  3498 00001ADD 4831C0                      xor rax, rax
  3499 00001AE0 5D                          pop rbp
  3500 00001AE1 C3                          ret
  3501                                  
  3502                                  .possible:
  3503 00001AE2 53                          push rbx
  3504 00001AE3 57                          push rdi
  3505 00001AE4 56                          push rsi
  3506 00001AE5 4154                        push r12
  3507 00001AE7 4155                        push r13
  3508 00001AE9 4156                        push r14
  3509 00001AEB 4157                        push r15
  3510                                  
  3511                                      ; 1) Obtener base de los bloques del nivel actual
  3512 00001AED E83FFDFFFF                  call get_current_level_blocks
  3513 00001AF2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  3514                                  
  3515                                      ; 2) Obtener la cantidad de bloques
  3516 00001AF5 E890FDFFFF                  call get_current_level_count
  3517 00001AFA 4989C6                      mov r14, rax
  3518                                  
  3519 00001AFD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  3520                                  
  3521                                  .find_block_loop:
  3522 00001B00 4D39F4                      cmp r12, r14
  3523 00001B03 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  3524                                  
  3525                                      ; Calcular puntero base del bloque actual en levelX_blocks
  3526 00001B09 4C89E0                      mov rax, r12
  3527 00001B0C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  3528 00001B10 4C01E8                      add rax, r13
  3529 00001B13 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  3530                                  
  3531                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  3532 00001B16 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  3532 00001B1B [761F0000]         
  3533 00001B1F 4885DB                      test rbx, rbx
  3534 00001B22 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  3535                                  
  3536                                      ; Obtener coordenadas
  3537 00001B28 418A17                      mov dl, [r15]         ; x
  3538 00001B2B 418A4F01                    mov cl, [r15 + 1]     ; y
  3539                                  
  3540                                      ; Calcular posición en el board
  3541 00001B2F 488D3D(400A0000)            lea rdi, [board]
  3542 00001B36 4831C0                      xor rax, rax
  3543 00001B39 B850000000                  mov rax, column_cells
  3544 00001B3E 4883C002                    add rax, 2
  3545 00001B42 480FB6C9                    movzx rcx, cl         ; y
  3546 00001B46 480FAFC1                    imul rax, rcx
  3547 00001B4A 4801C7                      add rdi, rax
  3548 00001B4D 480FB6C2                    movzx rax, dl         ; x
  3549 00001B51 4801C7                      add rdi, rax
  3550                                  
  3551                                      ; Guardar la posición base del bloque
  3552 00001B54 57                          push rdi
  3553                                  
  3554                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  3555 00001B55 4939FA                      cmp r10, rdi
  3556 00001B58 7274                        jb .skip_collision
  3557 00001B5A 488D5F06                    lea rbx, [rdi + block_length]
  3558 00001B5E 4939DA                      cmp r10, rbx
  3559 00001B61 736B                        jae .skip_collision
  3560                                  
  3561                                      ; ------- Hay colisión, reducir durabilidad en block_states
  3562 00001B63 41FE8C24[761F0000]          dec byte [block_states + r12]
  3563                                      ; Volver a cargar durabilidad
  3564 00001B6B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  3564 00001B70 [761F0000]         
  3565 00001B74 4885DB                      test rbx, rbx
  3566 00001B77 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  3567                                  
  3568                                      ; >>> Llegó a 0 => Bloque destruido
  3569 00001B79 5F                          pop rdi  ; recuperar puntero base del bloque en board
  3570 00001B7A B906000000                  mov rcx, block_length
  3571                                  .clear_loop:
  3572 00001B7F C60720                      mov byte [rdi], ' '
  3573 00001B82 48FFC7                      inc rdi
  3574 00001B85 E2F8                        loop .clear_loop
  3575                                  
  3576                                      ; Dibujar letra del bloque destruido
  3577 00001B87 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  3578 00001B8B 4883EF06                    sub rdi, block_length
  3579 00001B8F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  3580                                      ; Después de escribir la letra en el tablero
  3581 00001B91 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  3582 00001B95 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  3583 00001B99 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  3584 00001B9E E8D4E8FFFF                  call register_letter
  3585                                      ; Actualizar contadores globales
  3586 00001BA3 FE0D(7A150000)              dec byte [blocks_remaining]
  3587 00001BA9 FE05(46200000)              inc byte [destroyed_blocks]
  3588                                  
  3589                                      ; Sumar puntos según el tipo
  3590 00001BAF 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  3591 00001BB4 486BC00A                    imul rax, 10
  3592 00001BB8 480105(3E200000)            add [current_score], rax
  3593                                  
  3594 00001BBF B801000000                  mov rax, 1  ; colisión con destrucción
  3595 00001BC4 EB14                        jmp .end_pop
  3596                                  
  3597                                  .update_display:
  3598                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  3599 00001BC6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  3600 00001BCB 5F                          pop rdi     ; pop que quedó pendiente
  3601 00001BCC EB0C                        jmp .end_pop
  3602                                  
  3603                                  .skip_collision:
  3604 00001BCE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  3605                                  .next_block:
  3606 00001BCF 49FFC4                      inc r12
  3607 00001BD2 E929FFFFFF                  jmp .find_block_loop
  3608                                  
  3609                                  .no_block_found:
  3610 00001BD7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  3611                                  
  3612                                  .end_pop:
  3613 00001BDA 415F                        pop r15
  3614 00001BDC 415E                        pop r14
  3615 00001BDE 415D                        pop r13
  3616 00001BE0 415C                        pop r12
  3617 00001BE2 5E                          pop rsi
  3618 00001BE3 5F                          pop rdi
  3619 00001BE4 5B                          pop rbx
  3620 00001BE5 5D                          pop rbp
  3621 00001BE6 C3                          ret
  3622                                  
  3623                                  
  3624                                  
  3625                                  init_enemies:   ; Función para inicializar los enemigos
  3626 00001BE7 55                          push rbp    
  3627 00001BE8 4889E5                      mov rbp, rsp
  3628                                      
  3629                                      ; Reiniciar contadores de movimiento
  3630 00001BEB C605(89200000)00            mov byte [enemy_move_total], 0
  3631 00001BF2 C605(8A200000)00            mov byte [enemy_target], 0
  3632                                      
  3633                                      ; Limpiar completamente el array de enemigos
  3634 00001BF9 B91E000000                  mov rcx, 30  ; 10 enemigos * 3 bytes cada uno
  3635 00001BFE 488D3D(60200000)            lea rdi, [enemies]
  3636 00001C05 30C0                        xor al, al
  3637 00001C07 F3AA                        rep stosb    ; Llenar todo con ceros
  3638                                      
  3639                                      ; Marcar todos los spawns como no activados
  3640 00001C09 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3641 00001C10 B90A000000                  mov rcx, 10 ; 10 spawns
  3642 00001C15 F3AA                        rep stosb   ; Llenar con ceros
  3643                                      
  3644 00001C17 5D                          pop rbp
  3645 00001C18 C3                          ret
  3646                                  
  3647                                  
  3648                                  random_move_enemy:  ; Función para mover un enemigo aleatoriamente
  3649 00001C19 55                          push rbp        ; Guardar el puntero de la pila
  3650 00001C1A 4889E5                      mov  rbp, rsp
  3651 00001C1D 53                          push rbx
  3652 00001C1E 52                          push rdx
  3653 00001C1F 57                          push rdi
  3654                                  
  3655                                      ; r12 = índice del enemigo
  3656                                      ; 1) obtener puntero al enemigo i
  3657 00001C20 4C89E0                      mov rax, r12
  3658 00001C23 486BC003                    imul rax, 3                ; Cada enemigo ocupa 3 bytes
  3659 00001C27 488D98[60200000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  3660                                  
  3661                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  3662 00001C2E 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  3663 00001C32 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  3664                                  
  3665                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  3666 00001C37 480FB605(87200000)          movzx rax, byte [enemy_move_counter]
  3667 00001C3F 4883E003                    and rax, 3  ; rax = [enemy_move_counter] & 3
  3668                                  
  3669 00001C43 4883F800                    cmp rax, 0  ; si es 0 => mover abajo
  3670 00001C47 741B                        je .try_left    ; si es 1 => mover izquierda
  3671 00001C49 4883F801                    cmp rax, 1  ; si es 1 => mover izquierda
  3672 00001C4D 7410                        je .try_right   ; si es 2 => mover derecha
  3673 00001C4F 4883F802                    cmp rax, 2  ; si es 2 => mover derecha
  3674 00001C53 7405                        je .try_up
  3675                                      ; si es 3 => mover abajo
  3676                                  .try_down:
  3677 00001C55 49FFC1                      inc r9  ; mover abajo
  3678 00001C58 EB0D                        jmp .check_valid    ; saltar a la verificación de validez
  3679                                  
  3680                                  .try_up:    ; mover arriba
  3681 00001C5A 49FFC9                      dec r9  ; mover arriba
  3682 00001C5D EB08                        jmp .check_valid    ; saltar a la verificación de validez
  3683                                  
  3684                                  .try_right:   ; mover derecha
  3685 00001C5F 49FFC0                      inc r8  ; mover derecha
  3686 00001C62 EB03                        jmp .check_valid
  3687                                  
  3688                                  .try_left:
  3689 00001C64 49FFC8                      dec r8
  3690                                  
  3691                                  .check_valid:
  3692                                      ; 4) Verificar límites
  3693 00001C67 4983F801                    cmp r8, 1                    
  3694 00001C6B 0F8EA4000000                jle .invalid_move
  3695 00001C71 4983F850                    cmp r8, column_cells        
  3696 00001C75 0F8D9A000000                jge .invalid_move
  3697 00001C7B 4983F901                    cmp r9, 1                    
  3698 00001C7F 0F8E90000000                jle .invalid_move
  3699 00001C85 4983F920                    cmp r9, row_cells          
  3700 00001C89 0F8D86000000                jge .invalid_move
  3701                                  
  3702                                      ; 5) Verificar colisión con bloques/enemigos
  3703 00001C8F 4150                        push r8
  3704 00001C91 4151                        push r9
  3705 00001C93 B850000000                  mov rax, column_cells       ; rax = column_cells
  3706 00001C98 4883C002                    add rax, 2                ; rax = column_cells + 2
  3707 00001C9C 49F7E1                      mul r9                  ; rax = (column_cells + 2) * r9
  3708 00001C9F 4C01C0                      add rax, r8             ; rax = (column_cells + 2) * r9 + r8
  3709 00001CA2 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * r9 + r8]
  3710 00001CA9 8A07                        mov al, [rdi]        ; al = board[(column_cells + 2) * r9 + r8]
  3711                                  
  3712                                      ; Revisa si es bloque o borde
  3713 00001CAB 3C55                        cmp al, 'U'
  3714 00001CAD 7462                        je .pop_and_invalid
  3715 00001CAF 3C4F                        cmp al, 'O'
  3716 00001CB1 745E                        je .pop_and_invalid
  3717 00001CB3 3C44                        cmp al, 'D'
  3718 00001CB5 745A                        je .pop_and_invalid
  3719 00001CB7 3C4C                        cmp al, 'L'
  3720 00001CB9 7456                        je .pop_and_invalid
  3721 00001CBB 3C56                        cmp al, 'V'
  3722 00001CBD 7452                        je .pop_and_invalid
  3723 00001CBF 3C38                        cmp al, '8'
  3724 00001CC1 744E                        je .pop_and_invalid
  3725 00001CC3 3C58                        cmp al, 'X'
  3726 00001CC5 744A                        je .pop_and_invalid
  3727                                  
  3728                                      ; Revisa si hay enemigo
  3729 00001CC7 3C40                        cmp al, '@'
  3730 00001CC9 7446                        je .pop_and_invalid
  3731 00001CCB 3C23                        cmp al, '#'
  3732 00001CCD 7442                        je .pop_and_invalid
  3733 00001CCF 3C24                        cmp al, '$'
  3734 00001CD1 743E                        je .pop_and_invalid
  3735 00001CD3 3C26                        cmp al, '&'
  3736 00001CD5 743A                        je .pop_and_invalid
  3737                                  
  3738 00001CD7 E808030000                  call check_enemy_at_position
  3739 00001CDC 4883F801                    cmp rax, 1
  3740 00001CE0 742F                        je .pop_and_invalid
  3741                                  
  3742                                      ; ------------------------------
  3743                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3744                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3745                                      ; ------------------------------
  3746 00001CE2 4159                        pop r9
  3747 00001CE4 4158                        pop r8
  3748                                  
  3749                                      ; (A) Borrar la posición antigua en el board
  3750                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3751 00001CE6 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3752 00001CEA 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3753 00001CEF B850000000                  mov rax, column_cells
  3754 00001CF4 4883C002                    add rax, 2              ; rax = column_cells + 2
  3755 00001CF8 49F7E3                      mul r11                ; rax = (column_cells + 2) * oldY
  3756 00001CFB 4C01D0                      add rax, r10
  3757 00001CFE 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * oldY + oldX]
  3758 00001D05 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3759                                  
  3760                                      ; (B) Guardar la nueva X,Y en la estructura
  3761 00001D08 448803                      mov byte [rbx], r8b
  3762 00001D0B 44884B01                    mov byte [rbx + 1], r9b
  3763                                  
  3764 00001D0F EB0D                        jmp .done
  3765                                  
  3766                                  .pop_and_invalid:
  3767 00001D11 4159                        pop r9
  3768 00001D13 4158                        pop r8
  3769                                  
  3770                                  .invalid_move:
  3771                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3772 00001D15 4C0FB603                    movzx r8, byte [rbx]
  3773 00001D19 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3774                                      ; Se queda donde estaba
  3775                                  .done:
  3776 00001D1E 5F                          pop rdi
  3777 00001D1F 5A                          pop rdx
  3778 00001D20 5B                          pop rbx
  3779 00001D21 5D                          pop rbp
  3780 00001D22 C3                          ret
  3781                                  
  3782                                  
  3783                                  ; Función para mover enemigos
  3784                                  move_enemies:   ; Mover enemigos
  3785 00001D23 55                          push rbp    ; Guardar el puntero de la pila
  3786 00001D24 4889E5                      mov rbp, rsp    ; Establecer el puntero de la pila
  3787                                      
  3788                                      ; Incrementar contador de movimiento
  3789 00001D27 FE05(87200000)              inc byte [enemy_move_counter]   ; Incrementar el contador de movimiento
  3790 00001D2D 480FB605(87200000)          movzx rax, byte [enemy_move_counter]    ; rax = enemy_move_counter
  3791 00001D35 3A05(88200000)              cmp al, [enemy_move_delay]  ; Verificar si es hora de mover
  3792 00001D3B 0F85A1020000                jne .end
  3793                                      
  3794                                      ; Resetear contador
  3795 00001D41 C605(87200000)00            mov byte [enemy_move_counter], 0
  3796                                      
  3797 00001D48 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3798                                      
  3799                                      .enemy_loop:
  3800 00001D4B 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3801 00001D4F 0F8D8D020000                    jge .end                    ; Si ya movimos todos los enemigos, terminar
  3802                                          
  3803                                          ; Calcular offset del enemigo actual
  3804 00001D55 4C89E0                          mov rax, r12                ; rax = r12
  3805 00001D58 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3806 00001D5C 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[r12]
  3807                                          
  3808                                          ; Verificar si el enemigo está activo
  3809 00001D63 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si el enemigo está activo
  3810 00001D67 0F856D020000                    jne .next_enemy        ; Si no está activo, pasar al siguiente enemigo
  3811                                          
  3812                                          ; Obtener posición actual
  3813 00001D6D 4C0FB606                        movzx r8, byte [rsi]            ; X
  3814 00001D71 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3815                                          
  3816 00001D76 488D3D(40240000)                lea rdi, [enemy_last_x]        ; rdi = &enemy_last_x
  3817 00001D7D 4C01E7                          add rdi, r12            ; rdi = &enemy_last_x[r12]
  3818 00001D80 8A07                            mov al, [rdi]             ; al = last_x
  3819                                  
  3820 00001D82 488D15(4A240000)                lea rdx, [enemy_last_y]       ; rdx = &enemy_last_y
  3821 00001D89 4C01E2                          add rdx, r12        ; rdx = &enemy_last_y[r12]
  3822 00001D8C 8A22                            mov ah, [rdx]             ; ah = last_y
  3823                                  
  3824                                          ; r8 = X actual del enemigo
  3825                                          ; r9 = Y actual del enemigo
  3826                                  
  3827                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3828 00001D8E 88E2                            mov dl, ah      ; dl = old_Y
  3829 00001D90 4488CB                          mov bl, r9b     ; bl = new_Y
  3830 00001D93 38DA                            cmp dl, bl    ; Comparar Y
  3831 00001D95 752C                            jne .not_stuck      ; Si son diferentes, no está pegado
  3832                                  
  3833                                          ; => SI son iguales => pasa al siguiente check
  3834 00001D97 88C2                            mov dl, al      ; dl = old_X
  3835 00001D99 4488C3                          mov bl, r8b     ; bl = new_X
  3836 00001D9C 38DA                            cmp dl, bl  ; Comparar X
  3837 00001D9E 7523                            jne .not_stuck    ; Si son diferentes, no está pegado
  3838                                  
  3839                                          ; => MISMA POSICIÓN (STUCK)
  3840 00001DA0 488D1D(54240000)                lea rbx, [enemy_stuck_count]    ; rbx = &enemy_stuck_count
  3841 00001DA7 4C01E3                          add rbx, r12        ; rbx = &enemy_stuck_count[r12]
  3842 00001DAA FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3843                                  
  3844                                          ; Verificar si supera umbral, digamos 3
  3845 00001DAC 480FB60B                        movzx rcx, byte [rbx]    ; rcx = stuck_count
  3846 00001DB0 4883F902                        cmp rcx, 2      ; Si llega a 3, forzar movimiento aleatorio
  3847 00001DB4 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3848                                  
  3849                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3850                                          ;  1) resetear el stuck_count
  3851 00001DB6 C60300                          mov byte [rbx], 0
  3852                                  
  3853                                          ;  2) cambiar random
  3854 00001DB9 E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3855 00001DBE E917020000                      jmp .next_enemy 
  3856                                  
  3857                                      .not_stuck:
  3858                                          ; => Se movió
  3859 00001DC3 488D1D(54240000)                lea rbx, [enemy_stuck_count]
  3860 00001DCA 4C01E3                          add rbx, r12    ; rbx = &enemy_stuck_count[r12]
  3861 00001DCD C60300                          mov byte [rbx], 0            ; Resetear
  3862                                  
  3863                                          ; Guardar su nueva posición en “last_x, last_y”
  3864 00001DD0 488D3D(40240000)                lea rdi, [enemy_last_x]
  3865 00001DD7 4C01E7                          add rdi, r12    ; rdi = &enemy_last_x[r12]
  3866 00001DDA 448807                          mov [rdi], r8b      ; Guardar X
  3867                                          
  3868 00001DDD 488D3D(4A240000)                lea rdi, [enemy_last_y]
  3869 00001DE4 4C01E7                          add rdi, r12
  3870 00001DE7 44880F                          mov [rdi], r9b
  3871                                  
  3872                                          ; Limpiar posición actual antes de mover
  3873                                      .check_normal_move:
  3874 00001DEA 4150                            push r8
  3875 00001DEC 4151                            push r9
  3876 00001DEE B850000000                      mov rax, column_cells    ; rax = column_cells
  3877 00001DF3 4883C002                        add rax, 2            ; rax = column_cells + 2
  3878 00001DF7 49F7E1                          mul r9            ; rax = (column_cells + 2) * Y
  3879 00001DFA 4C01C0                          add rax, r8       ; rax = (column_cells + 2) * Y + X
  3880 00001DFD 488DB8[400A0000]                lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  3881 00001E04 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3882 00001E07 4159                            pop r9          ; Recuperar Y
  3883 00001E09 4158                            pop r8      ; Restaurar X, Y
  3884                                  
  3885                                          ; Determinar comportamiento basado en índice
  3886 00001E0B 4C89E0                          mov rax, r12
  3887 00001E0E 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3888 00001E12 4885C0                          test rax, rax
  3889 00001E15 7405                            jz .chase_ball
  3890 00001E17 E996000000                      jmp .chase_paddle             ; Si es 1, perseguir paleta
  3891                                          
  3892                                          ; Perseguir bola (comportamiento original)
  3893                                      .chase_ball:
  3894                                          ; Primero intentar con la bola principal
  3895 00001E1C 803D(00150000)01                cmp byte [ball_active], 1
  3896 00001E23 7414                            je .use_ball1
  3897                                          
  3898                                          ; Si no está activa, probar con ball2
  3899 00001E25 803D(22150000)01                cmp byte [ball2_active], 1
  3900 00001E2C 7414                            je .use_ball2
  3901                                          
  3902                                          ; Si no está activa, probar con ball3
  3903 00001E2E 803D(44150000)01                cmp byte [ball3_active], 1
  3904 00001E35 7414                            je .use_ball3
  3905                                          
  3906                                          ; Si no hay bolas activas, perseguir la paleta
  3907 00001E37 EB79                            jmp .chase_paddle
  3908                                  
  3909                                      .use_ball1:
  3910 00001E39 4C8B15(DF140000)                mov r10, [ball_x_pos]   ; r10 = ball_x_pos
  3911 00001E40 EB12                            jmp .compare_positions
  3912                                  
  3913                                      .use_ball2:         
  3914 00001E42 4C8B15(01150000)                mov r10, [ball2_x_pos]
  3915 00001E49 EB09                            jmp .compare_positions
  3916                                  
  3917                                      .use_ball3:
  3918 00001E4B 4C8B15(23150000)                mov r10, [ball3_x_pos]
  3919 00001E52 EB00                            jmp .compare_positions
  3920                                  
  3921                                      .compare_positions:
  3922                                          ; Comparar X
  3923 00001E54 4D39D0                          cmp r8, r10
  3924 00001E57 0F8FCA000000                    jg .move_left
  3925 00001E5D 0F8CC9000000                    jl .move_right
  3926                                          
  3927                                          ; Si llegamos aquí, las X son iguales
  3928                                          ; Ahora comparar Y según qué bola estemos siguiendo
  3929 00001E63 803D(00150000)01                cmp byte [ball_active], 1
  3930 00001E6A 7417                            je .check_ball1_y
  3931 00001E6C 803D(22150000)01                cmp byte [ball2_active], 1
  3932 00001E73 7417                            je .check_ball2_y
  3933 00001E75 803D(44150000)01                cmp byte [ball3_active], 1
  3934 00001E7C 7417                            je .check_ball3_y
  3935 00001E7E E9D4000000                      jmp .check_collision
  3936                                  
  3937                                      .check_ball1_y:
  3938 00001E83 4C8B15(E7140000)                mov r10, [ball_y_pos]
  3939 00001E8A EB12                            jmp .compare_y
  3940                                  
  3941                                      .check_ball2_y:
  3942 00001E8C 4C8B15(09150000)                mov r10, [ball2_y_pos]
  3943 00001E93 EB09                            jmp .compare_y
  3944                                  
  3945                                      .check_ball3_y:
  3946 00001E95 4C8B15(2B150000)                mov r10, [ball3_y_pos]
  3947 00001E9C EB00                            jmp .compare_y
  3948                                  
  3949                                      .compare_y:
  3950 00001E9E 4D39D1                          cmp r9, r10
  3951 00001EA1 0F8F8A000000                    jg .move_up
  3952 00001EA7 0F8C89000000                    jl .move_down
  3953 00001EAD E9A5000000                      jmp .check_collision
  3954                                          
  3955                                      .chase_paddle:
  3956                                          ; Obtener la posición X actual de la paleta
  3957 00001EB2 4C8B15(BF140000)                mov r10, [pallet_position]
  3958 00001EB9 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  3959                                          
  3960                                          ; Calcular la posición X real de la paleta
  3961 00001EC0 4C89D0                          mov rax, r10
  3962 00001EC3 BB50000000                      mov rbx, column_cells
  3963 00001EC8 4883C302                        add rbx, 2                  ; Añadir newline chars
  3964 00001ECC 4831D2                          xor rdx, rdx
  3965 00001ECF 48F7F3                          div rbx                     ; rax = y, rdx = x
  3966                                          
  3967                                          ; rdx ahora contiene la posición X de la paleta
  3968                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  3969 00001ED2 488B0D(C7140000)                mov rcx, [pallet_size]
  3970 00001ED9 48D1E9                          shr rcx, 1                  ; Dividir por 2
  3971 00001EDC 4801CA                          add rdx, rcx
  3972                                          
  3973                                          ; Comparar con posición X del enemigo y mover gradualmente
  3974 00001EDF 4939D0                          cmp r8, rdx
  3975 00001EE2 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  3976 00001EE4 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  3977 00001EE6 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  3978                                  
  3979                                      .check_y_paddle:
  3980                                          ; La Y de la paleta siempre es row_cells - 2
  3981 00001EE8 41BA20000000                    mov r10, row_cells
  3982 00001EEE 4983EA02                        sub r10, 2
  3983                                          
  3984                                          ; Comparar con posición Y del enemigo y mover gradualmente
  3985 00001EF2 4D39D1                          cmp r9, r10
  3986 00001EF5 7404                            je .no_movement            ; Si está en la misma Y, no mover
  3987 00001EF7 7F38                            jg .move_up               ; Si está abajo, mover arriba
  3988 00001EF9 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  3989                                          
  3990                                      .no_movement:
  3991 00001EFB EB5A                            jmp .check_collision
  3992                                  
  3993                                      ; También agregar una nueva sección para el movimiento suave
  3994                                      .smooth_transition:
  3995                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  3996 00001EFD 8A05(8A200000)                  mov al, [enemy_target]
  3997 00001F03 84C0                            test al, al
  3998 00001F05 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  3999                                          
  4000                                          ; Verificar distancia en X
  4001 00001F07 4989D2                          mov r10, rdx              ; Posición X objetivo
  4002 00001F0A 4D29C2                          sub r10, r8               ; Calcular diferencia
  4003 00001F0D 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  4004 00001F11 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  4005 00001F13 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  4006 00001F17 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  4007 00001F19 EB3C                            jmp .check_collision
  4008                                          
  4009                                      .limit_right_movement:
  4010 00001F1B 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  4011 00001F1F EB36                            jmp .check_collision
  4012                                          
  4013                                      .limit_left_movement:
  4014 00001F21 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  4015 00001F25 EB30                            jmp .check_collision
  4016                                      .move_left:
  4017 00001F27 49FFC8                          dec r8
  4018 00001F2A EB0F                            jmp .check_vertical
  4019                                          
  4020                                      .move_right:
  4021 00001F2C 49FFC0                          inc r8
  4022 00001F2F EB0A                            jmp .check_vertical
  4023                                          
  4024                                      .move_up:
  4025 00001F31 49FFC9                          dec r9
  4026 00001F34 EB21                            jmp .check_collision
  4027                                          
  4028                                      .move_down:
  4029 00001F36 49FFC1                          inc r9
  4030 00001F39 EB1C                            jmp .check_collision
  4031                                          
  4032                                      .check_vertical:
  4033 00001F3B 8A05(8A200000)                  mov al, [enemy_target]
  4034 00001F41 84C0                            test al, al
  4035 00001F43 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  4036 00001F49 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  4037 00001F50 4D39D1                          cmp r9, r10
  4038 00001F53 7FDC                            jg .move_up
  4039 00001F55 7CDF                            jl .move_down
  4040                                          
  4041                                      .check_collision:
  4042                                          ; Verificar colisión con bordes
  4043 00001F57 4983F801                        cmp r8, 1                       ; Borde izquierdo
  4044 00001F5B 7E7D                            jle .next_enemy
  4045 00001F5D 4983F850                        cmp r8, column_cells
  4046 00001F61 7D77                            jge .next_enemy
  4047 00001F63 4983F901                        cmp r9, 1                       ; Borde superior
  4048 00001F67 7E71                            jle .next_enemy
  4049 00001F69 4983F920                        cmp r9, row_cells
  4050 00001F6D 7D6B                            jge .next_enemy
  4051                                          
  4052                                          ; Verificar colisión con bloques antes de moverse
  4053 00001F6F 4150                            push r8
  4054 00001F71 4151                            push r9
  4055 00001F73 4152                            push r10
  4056                                          
  4057                                          ; Calcular posición en el tablero para verificar
  4058 00001F75 B850000000                      mov rax, column_cells
  4059 00001F7A 4883C002                        add rax, 2
  4060 00001F7E 49F7E1                          mul r9
  4061 00001F81 4C01C0                          add rax, r8
  4062 00001F84 4C8D90[400A0000]                lea r10, [board + rax]
  4063                                          
  4064                                          ; Verificar si hay un bloque en la nueva posición
  4065 00001F8B 418A02                          mov al, [r10]
  4066 00001F8E 3C55                            cmp al, 'U'
  4067 00001F90 7442                            je .invalid_move
  4068 00001F92 3C4F                            cmp al, 'O'
  4069 00001F94 743E                            je .invalid_move
  4070 00001F96 3C44                            cmp al, 'D'
  4071 00001F98 743A                            je .invalid_move
  4072 00001F9A 3C4C                            cmp al, 'L'
  4073 00001F9C 7436                            je .invalid_move
  4074 00001F9E 3C56                            cmp al, 'V'
  4075 00001FA0 7432                            je .invalid_move
  4076 00001FA2 3C38                            cmp al, '8'
  4077 00001FA4 742E                            je .invalid_move
  4078 00001FA6 3C58                            cmp al, 'X'
  4079 00001FA8 742A                            je .invalid_move
  4080 00001FAA 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  4081 00001FAC 7426                            je .invalid_move
  4082 00001FAE 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  4083 00001FB0 7422                            je .invalid_move
  4084 00001FB2 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  4085 00001FB4 741E                            je .invalid_move
  4086 00001FB6 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  4087 00001FB8 741A                            je .invalid_move
  4088                                          
  4089 00001FBA E825000000                      call check_enemy_at_position
  4090 00001FBF 4883F801                        cmp rax, 1
  4091 00001FC3 740F                            je .invalid_move
  4092 00001FC5 415A                            pop r10
  4093 00001FC7 4159                            pop r9
  4094 00001FC9 4158                            pop r8
  4095                                          
  4096                                          ; Guardar nueva posición si es válida
  4097 00001FCB 448806                          mov [rsi], r8b
  4098 00001FCE 44884E01                        mov [rsi + 1], r9b
  4099 00001FD2 EB06                            jmp .next_enemy
  4100                                          
  4101                                      .invalid_move:
  4102 00001FD4 415A                            pop r10
  4103 00001FD6 4159                            pop r9
  4104 00001FD8 4158                            pop r8
  4105                                          
  4106                                      .next_enemy:
  4107 00001FDA 49FFC4                          inc r12
  4108 00001FDD E969FDFFFF                      jmp .enemy_loop
  4109                                          
  4110                                      .end:
  4111 00001FE2 5D                              pop rbp
  4112 00001FE3 C3                              ret
  4113                                  
  4114                                  check_enemy_at_position:    ; Función para verificar si hay un enemigo en una posición
  4115 00001FE4 55                          push rbp
  4116 00001FE5 4889E5                      mov rbp, rsp
  4117                                      
  4118                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  4119 00001FE8 B850000000                  mov rax, column_cells
  4120 00001FED 4883C002                    add rax, 2
  4121 00001FF1 49F7E1                      mul r9                ; rax = (column_cells + 2) * Y
  4122 00001FF4 4C01C0                      add rax, r8   ; rax = (column_cells + 2) * Y + X
  4123 00001FF7 488DB8[400A0000]            lea rdi, [board + rax]  ; rdi = &board[(column_cells + 2) * Y + X]
  4124 00001FFE 480FB607                    movzx rax, byte [rdi]   ; rax = board[(column_cells + 2) * Y + X]
  4125                                      
  4126                                      ; Verificar todos los caracteres de enemigos
  4127 00002002 3C40                        cmp al, '@'
  4128 00002004 7411                        je .enemy_found
  4129 00002006 3C23                        cmp al, '#'
  4130 00002008 740D                        je .enemy_found
  4131 0000200A 3C24                        cmp al, '$'
  4132 0000200C 7409                        je .enemy_found
  4133 0000200E 3C26                        cmp al, '&'
  4134 00002010 7405                        je .enemy_found
  4135                                      
  4136 00002012 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  4137 00002015 EB05                        jmp .end
  4138                                      
  4139                                  .enemy_found:
  4140 00002017 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  4141                                      
  4142                                  .end:
  4143 0000201C 5D                          pop rbp
  4144 0000201D C3                          ret
  4145                                  
  4146                                  get_current_spawn_points:   ; Función para obtener los puntos de spawn del nivel actual
  4147 0000201E 55                          push rbp
  4148 0000201F 4889E5                      mov rbp, rsp
  4149                                      
  4150 00002022 480FB605(79150000)          movzx rax, byte [current_level] ; Obtener nivel actual
  4151 0000202A 48FFC8                      dec rax                         ; Ajustar para índice base 0
  4152 0000202D 488B04C5[BE200000]          mov rax, [spawn_points_table + rax * 8] ; Obtener puntero a puntos de spawn
  4153                                      
  4154 00002035 5D                          pop rbp
  4155 00002036 C3                          ret
  4156                                  
  4157                                  ; Función para verificar si debe aparecer un nuevo enemigo
  4158                                  check_enemy_spawn:  ; Verificar si debe aparecer un nuevo enemigo
  4159 00002037 55                          push rbp                ; Guardar el puntero de la pila
  4160 00002038 4889E5                      mov rbp, rsp        ; Establecer el puntero de la pila
  4161                                      
  4162                                      ; Obtener spawn points del nivel actual
  4163 0000203B E8DEFFFFFF                  call get_current_spawn_points
  4164 00002040 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  4165                                      
  4166                                      ; Obtener cantidad de bloques destruidos
  4167 00002043 4C0FB62D(46200000)          movzx r13, byte [destroyed_blocks]
  4168                                      
  4169                                      ; Verificar cada punto de spawn
  4170 0000204B 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  4171                                      
  4172                                      .check_loop:
  4173 0000204E 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  4174 00002052 7D4E                            jge .end
  4175                                          
  4176                                          ; Verificar si este spawn point ya fue usado
  4177 00002054 80B9[E9200000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  4178 0000205B 7440                            je .next_enemy
  4179                                          
  4180                                          ; Verificar si este enemigo ya está activo
  4181 0000205D 4889C8                          mov rax, rcx
  4182 00002060 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4183 00002064 488DB0[60200000]                lea rsi, [enemies + rax]    ; rsi = &enemies[rcx]
  4184 0000206B 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  4185 0000206F 742C                            je .next_enemy
  4186                                          
  4187                                          ; Verificar si debemos spawnear este enemigo
  4188 00002071 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  4189 00002076 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  4190 00002079 7522                            jne .next_enemy               ; Si no coincide, pasar al siguiente
  4191                                          
  4192                                          ; Marcar este spawn point como usado
  4193 0000207B C681[E9200000]01                mov byte [enemy_spawns_triggered + rcx], 1  ; Marcar como usado
  4194                                  
  4195                                          ; Spawner nuevo enemigo
  4196 00002082 B004                            mov al, 4                   ; Nivel de X
  4197 00002084 00C8                            add al, cl       ; con 'rcx' como índice
  4198 00002086 8806                            mov [rsi], al            ; X
  4199 00002088 C6460101                        mov byte [rsi+1], 1    ; Y
  4200 0000208C C6460201                        mov byte [rsi+2], 1   ; Activar enemigo
  4201                                  
  4202                                          ; Inicializar comportamiento
  4203 00002090 4889C8                          mov rax, rcx            ; rax = rcx
  4204 00002093 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  4205 00002097 8805(E8200000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  4206                                          
  4207                                      .next_enemy:
  4208 0000209D 48FFC1                          inc rcx
  4209 000020A0 EBAC                            jmp .check_loop
  4210                                          
  4211                                      .end:
  4212 000020A2 5D                              pop rbp
  4213 000020A3 C3                              ret
  4214                                  
  4215                                  
  4216                                  ; Función para dibujar enemigos
  4217                                  print_enemies:
  4218 000020A4 55                          push rbp
  4219 000020A5 4889E5                      mov rbp, rsp
  4220                                      
  4221 000020A8 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4222                                      
  4223                                      .print_loop:
  4224 000020AB 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  4225 000020AF 7D4B                            jge .end
  4226                                          
  4227                                          ; Calcular offset del enemigo actual
  4228 000020B1 4C89E0                          mov rax, r12
  4229 000020B4 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4230 000020B8 488DB0[60200000]                lea rsi, [enemies + rax]
  4231                                          
  4232                                          ; Verificar si el enemigo está activo
  4233 000020BF 807E0201                        cmp byte [rsi + 2], 1
  4234 000020C3 7532                            jne .next_enemy
  4235                                          
  4236                                          ; Calcular posición en el tablero
  4237 000020C5 4C0FB606                        movzx r8, byte [rsi]            ; X
  4238 000020C9 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  4239                                          
  4240                                          ; Calcular offset en el tablero
  4241 000020CE B850000000                      mov rax, column_cells
  4242 000020D3 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  4243 000020D7 49F7E1                          mul r9                        ; rax = (column_cells + 2) * Y
  4244 000020DA 4C01C0                          add rax, r8                    ; rax = (column_cells + 2) * Y + X
  4245 000020DD 488DB8[400A0000]                lea rdi, [board + rax]
  4246                                          
  4247                                          ; Obtener carácter del enemigo según el nivel
  4248 000020E4 480FB605(79150000)              movzx rax, byte [current_level]
  4249 000020EC 48FFC8                          dec rax                         ; Ajustar para índice base 0
  4250 000020EF 8A80[5B200000]                  mov al, [enemy_chars + rax]
  4251                                          
  4252                                          ; Dibujar enemigo
  4253 000020F5 8807                            mov [rdi], al
  4254                                          
  4255                                      .next_enemy:
  4256 000020F7 49FFC4                          inc r12
  4257 000020FA EBAF                            jmp .print_loop
  4258                                          
  4259                                      .end:
  4260 000020FC 5D                              pop rbp
  4261 000020FD C3                              ret
  4262                                  
  4263                                  ; Función para verificar colisión con enemigos
  4264                                  check_enemy_collision:  ; Verificar colisión con enemigos
  4265 000020FE 55                          push rbp
  4266 000020FF 4889E5                      mov rbp, rsp
  4267                                      
  4268 00002102 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4269 00002105 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  4270                                      
  4271                                      .check_loop:
  4272 00002108 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  4273 0000210C 0F8DE9000000                    jge .end
  4274                                          
  4275                                          ; Calcular offset del enemigo actual
  4276 00002112 4C89E1                          mov rcx, r12
  4277 00002115 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  4278 00002119 488DB1[60200000]                lea rsi, [enemies + rcx]
  4279                                          
  4280                                          ; Verificar si el enemigo está activo
  4281 00002120 807E0201                        cmp byte [rsi + 2], 1
  4282 00002124 0F85C9000000                    jne .next_enemy
  4283                                          
  4284                                          ; Verificar colisión con la bola
  4285 0000212A 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  4286 0000212E 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  4287                                          
  4288                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  4289 00002133 4C8B15(DF140000)                mov r10, [ball_x_pos]
  4290 0000213A 4C8B1D(E7140000)                mov r11, [ball_y_pos]        ; Posición de la bola
  4291                                          
  4292                                          ; Comprobar colisión vertical (misma columna)
  4293 00002141 4D39C2                          cmp r10, r8
  4294 00002144 7525                            jne .check_horizontal     ; Si no está en la misma columna, verificar horizontal
  4295 00002146 4D29CB                          sub r11, r9         ; Calcular diferencia de Y
  4296 00002149 4983FB01                        cmp r11, 1              ; Si la bola está justo arriba del enemigo
  4297 0000214D 7F1C                            jg .check_horizontal    ; Si está más arriba, verificar horizontal
  4298 0000214F 4983FBFF                        cmp r11, -1
  4299 00002153 7C16                            jl .check_horizontal    ; Si está más abajo, verificar horizontal
  4300                                          
  4301                                          ; Colisión vertical detectada   
  4302 00002155 E8A3000000                      call destroy_enemy      ; Destruir el enemigo
  4303 0000215A 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  4304 00002161 B801000000                      mov rax, 1
  4305 00002166 E990000000                      jmp .end
  4306                                          
  4307                                      .check_horizontal:      
  4308                                          ; Comprobar colisión horizontal (misma fila)
  4309 0000216B 4C8B15(DF140000)                mov r10, [ball_x_pos]     ; Posición de la bola
  4310 00002172 4C8B1D(E7140000)                mov r11, [ball_y_pos]   ; Posición de la bola
  4311 00002179 4D39CB                          cmp r11, r9            ; Comparar Y de la bola con Y del enemigo
  4312 0000217C 7522                            jne .check_paddle   ; Si no están en la misma fila, verificar con la paleta
  4313 0000217E 4D29C2                          sub r10, r8        ; Calcular diferencia de X
  4314 00002181 4983FA01                        cmp r10, 1        ; Si la bola está justo a la izquierda del enemigo
  4315 00002185 7F19                            jg .check_paddle    ; Si está más a la izquierda, verificar con la paleta
  4316 00002187 4983FAFF                        cmp r10, -1      ; Si la bola está justo a la derecha del enemigo
  4317 0000218B 7C13                            jl .check_paddle    ; Si está más a la derecha, verificar con la paleta
  4318                                          
  4319                                          ; Colisión horizontal detectada
  4320 0000218D E86B000000                      call destroy_enemy    ; Destruir el enemigo
  4321 00002192 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  4322 00002199 B801000000                      mov rax, 1          ; Indicar que hubo colisión
  4323 0000219E EB5B                            jmp .end        ; Terminar
  4324                                  
  4325                                      .check_paddle:
  4326                                          ; Verificar colisión con la paleta
  4327 000021A0 4C8B15(BF140000)                mov r10, [pallet_position]  ; Posición de la paleta
  4328 000021A7 4981EA[400A0000]                sub r10, board            ; Convertir a offset relativo
  4329 000021AE 4C89D0                          mov rax, r10          ; rax = r10
  4330 000021B1 41BB50000000                    mov r11, column_cells   ; r11 = column_cells
  4331 000021B7 4983C302                        add r11, 2          ; r11 = column_cells + 2
  4332 000021BB 4831D2                          xor rdx, rdx    ; rdx = 0
  4333 000021BE 49F7F3                          div r11                     ; División para obtener la posición Y
  4334 000021C1 4989D3                          mov r11, rdx               ; X de la paleta en r11
  4335                                          
  4336 000021C4 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  4337                                          
  4338                                          ; Verificar si el enemigo está en la misma fila que la paleta
  4339 000021CB 41BD20000000                    mov r13, row_cells
  4340 000021D1 4983ED02                        sub r13, 2                 ; Y de la paleta
  4341 000021D5 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  4342 000021D8 7519                            jne .next_enemy
  4343                                          
  4344                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  4345 000021DA 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  4346 000021DD 7C14                            jl .next_enemy
  4347                                          
  4348 000021DF 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  4349 000021E2 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  4350 000021E5 7F0C                            jg .next_enemy
  4351                                          
  4352                                          ; Si llegamos aquí, hay colisión con la paleta
  4353 000021E7 E811000000                      call destroy_enemy        ; Destruir el enemigo
  4354 000021EC B801000000                      mov rax, 1                ; Indicar que hubo colisión
  4355 000021F1 EB08                            jmp .end
  4356                                          
  4357                                      .next_enemy:
  4358 000021F3 49FFC4                          inc r12
  4359 000021F6 E90DFFFFFF                      jmp .check_loop   ; Verificar el siguiente enemigo
  4360                                          
  4361                                      .end:
  4362 000021FB 5D                              pop rbp
  4363 000021FC C3                              ret
  4364                                  
  4365                                  ; Función para destruir un enemigo
  4366                                  destroy_enemy:
  4367                                      ; Desactivar enemigo
  4368 000021FD C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  4369                                  
  4370                                      ; Sumar puntos por destruir enemigo
  4371 00002201 488B05(7F200000)            mov rax, [enemy_points]
  4372 00002208 480105(3E200000)            add [current_score], rax
  4373                                  
  4374                                      ; No tocar bloques destruidos aquí
  4375 0000220F C3                          ret
  4376                                  
  4377                                  
  4378                                  _start:   
  4379 00002210 E816DFFFFF              	call canonical_off  ; Desactivar modo canónico
  4380 00002215 E857010000              	call start_screen   ; Mostrar pantalla de inicio
  4381 0000221A E811F3FFFF                  call init_level    ; Inicializar el nivel
  4382 0000221F EB00                    	jmp .main_loop    ; Saltar al bucle principal
  4383                                  	
  4384                                  
  4385                                      .main_loop:     ; Bucle principal
  4386 00002221 E87FF7FFFF                      call print_labels   ; Imprimir etiquetas
  4387 00002226 E8AEF6FFFF                      call print_blocks   ; Imprimir bloques
  4388 0000222B E818E3FFFF                      call move_letters   ; Mover letras
  4389 00002230 E8FEE5FFFF                      call update_lasers          ; Actualizar láseres
  4390 00002235 E883E2FFFF                      call print_letters  ; Imprimir letras
  4391 0000223A E802EAFFFF                      call print_pallet   ; Imprimir paleta
  4392                                          
  4393                                          ; Mover bola principal solo si está activa
  4394 0000223F 803D(00150000)01                cmp byte [ball_active], 1
  4395 00002246 7505                            jne .skip_ball1
  4396 00002248 E80BEBFFFF                          call move_ball
  4397                                          .skip_ball1:
  4398                                  
  4399                                          ; Mover bola 2 si está activa
  4400 0000224D 803D(22150000)01                cmp byte [ball2_active], 1
  4401 00002254 7505                            jne .skip_ball2
  4402 00002256 E8D0ECFFFF                          call move_ball_2
  4403                                          .skip_ball2:
  4404                                  
  4405                                          ; Mover bola 3 si está activa
  4406 0000225B 803D(44150000)01                cmp byte [ball3_active], 1
  4407 00002262 7505                            jne .skip_ball3
  4408 00002264 E895EEFFFF                          call move_ball_3
  4409                                          .skip_ball3:
  4410                                  
  4411 00002269 E888E0FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  4412 0000226E E86ADFFFFF                      call print_lives
  4413                                  
  4414                                          ; Imprimir solo las bolas activas
  4415 00002273 803D(00150000)01                cmp byte [ball_active], 1
  4416 0000227A 7505                            jne .no_pb1
  4417 0000227C E848E9FFFF                          call print_ball
  4418                                          .no_pb1:
  4419                                  
  4420 00002281 803D(22150000)01                cmp byte [ball2_active], 1
  4421 00002288 7505                            jne .no_pb2
  4422 0000228A E862E9FFFF                          call print_ball_2
  4423                                          .no_pb2:
  4424                                  
  4425 0000228F 803D(44150000)01                cmp byte [ball3_active], 1
  4426 00002296 7505                            jne .no_pb3
  4427 00002298 E87CE9FFFF                          call print_ball_3
  4428                                          .no_pb3:
  4429                                  
  4430 0000229D E87FF4FFFF                      call check_level_complete
  4431 000022A2 E890FDFFFF                      call check_enemy_spawn
  4432 000022A7 E877FAFFFF                      call move_enemies
  4433 000022AC E84DFEFFFF                      call check_enemy_collision
  4434 000022B1 E8EEFDFFFF                      call print_enemies
  4435 000022B6 E8ECE4FFFF                      call print_power_label
  4436                                  		print board, board_size				
    93 000022BB B801000000          <1>  mov eax, sys_write
    94 000022C0 BF01000000          <1>  mov edi, 1
    95 000022C5 48BE-               <1>  mov rsi, %1
    95 000022C7 [400A000000000000]  <1>
    96 000022CF BA400A0000          <1>  mov edx, %2
    97 000022D4 0F05                <1>  syscall
  4437                                  		;setnonblocking	
  4438                                  	.read_more:	    
  4439                                  	    getchar	    ; Leer una tecla
   101 000022D6 B800000000          <1>  mov rax, sys_read
   102 000022DB BF00000000          <1>  mov rdi, STDIN_FILENO
   103 000022E0 48BE-               <1>  mov rsi, input_char
   103 000022E2 [0000000000000000]  <1>
   104 000022EA BA01000000          <1>  mov rdx, 1
   105 000022EF 0F05                <1>  syscall
  4440 000022F1 4883F801                	    cmp rax, 1  ; Verificar si se presionó una tecla
  4441 000022F5 7547                    	    jne .done   ; Si no se presionó ninguna tecla, terminar
  4442                                  	
  4443 000022F7 8A05(00000000)          	    mov al, [input_char]
  4444 000022FD 8805(08230000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  4445                                  	
  4446 00002303 3C61                    	    cmp al, 'a'            ; Verificar si se presionó la tecla 'a'
  4447 00002305 750E                    	    jne .not_left       ; Si no se presionó, verificar si se presionó 'd'
  4448 00002307 48C7C7FFFFFFFF          	    mov rdi, left_direction    ; Si sí, mover la paleta a la izquierda
  4449 0000230E E863E9FFFF              	    call move_pallet    ; Mover la paleta
  4450 00002313 EB29                    	    jmp .done        ; Terminar
  4451                                  	
  4452                                      .not_left:  
  4453 00002315 3C64                    	    cmp al, 'd'           ; Verificar si se presionó la tecla 'd'
  4454 00002317 750C                    	    jne .not_right    ; Si no se presionó, verificar si se presionó 'c'
  4455 00002319 BF01000000              	    mov rdi, right_direction    ; Si sí, mover la paleta a la derecha
  4456 0000231E E853E9FFFF              	    call move_pallet    ; Mover la paleta
  4457 00002323 EB19                    	    jmp .done     ; Terminar
  4458                                  	
  4459                                      .not_right:
  4460 00002325 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  4461 00002327 740E                    	    je .release_ball        ; Si sí, liberar la bola
  4462                                  	
  4463 00002329 3C78                            cmp al, 'x'             ; Verificar si se presionó la tecla 'c'
  4464 0000232B 740A                    	    je .release_ball        ; Si sí, liberar la bola
  4465                                  	
  4466                                  
  4467 0000232D 3C71                    	    cmp al, 'q' 
  4468 0000232F 0F84AF000000            	    je exit
  4469 00002335 EB9F                    	    jmp .read_more
  4470                                  	
  4471                                      .release_ball:
  4472 00002337 E895EFFFFF              	    call process_catch_release
  4473 0000233C EB00                    	    jmp .done
  4474                                  	
  4475                                      .done:
  4476                                  	    sleeptime
   109 0000233E B823000000          <1>  mov eax, sys_nanosleep
   110 00002343 48BF-               <1>  mov rdi, timespec
   110 00002345 [0000000000000000]  <1>
   111 0000234D 31F6                <1>  xor esi, esi
   112 0000234F 0F05                <1>  syscall
  4477                                  	    print clear, clear_length
    93 00002351 B801000000          <1>  mov eax, sys_write
    94 00002356 BF01000000          <1>  mov edi, 1
    95 0000235B 48BE-               <1>  mov rsi, %1
    95 0000235D [1000000000000000]  <1>
    96 00002365 BA07000000          <1>  mov edx, %2
    97 0000236A 0F05                <1>  syscall
  4478 0000236C E9B0FEFFFF              	    jmp .main_loop
  4479                                  
  4480                                  
  4481                                  
  4482                                  
  4483                                  start_screen:
  4484                                      print clear, clear_length    ; Limpiamos la pantalla primero
    93 00002371 B801000000          <1>  mov eax, sys_write
    94 00002376 BF01000000          <1>  mov edi, 1
    95 0000237B 48BE-               <1>  mov rsi, %1
    95 0000237D [1000000000000000]  <1>
    96 00002385 BA07000000          <1>  mov edx, %2
    97 0000238A 0F05                <1>  syscall
  4485                                      print msg1, msg1_length
    93 0000238C B801000000          <1>  mov eax, sys_write
    94 00002391 BF01000000          <1>  mov edi, 1
    95 00002396 48BE-               <1>  mov rsi, %1
    95 00002398 [1700000000000000]  <1>
    96 000023A0 BA14010000          <1>  mov edx, %2
    97 000023A5 0F05                <1>  syscall
  4486                                      
  4487                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  4488                                          getchar                 ; Esperamos una tecla
   101 000023A7 B800000000          <1>  mov rax, sys_read
   102 000023AC BF00000000          <1>  mov rdi, STDIN_FILENO
   103 000023B1 48BE-               <1>  mov rsi, input_char
   103 000023B3 [0000000000000000]  <1>
   104 000023BB BA01000000          <1>  mov rdx, 1
   105 000023C0 0F05                <1>  syscall
  4489 000023C2 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  4490 000023C6 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  4491                                          
  4492                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    93 000023C8 B801000000          <1>  mov eax, sys_write
    94 000023CD BF01000000          <1>  mov edi, 1
    95 000023D2 48BE-               <1>  mov rsi, %1
    95 000023D4 [1000000000000000]  <1>
    96 000023DC BA07000000          <1>  mov edx, %2
    97 000023E1 0F05                <1>  syscall
  4493 000023E3 C3                          ret
  4494                                  
  4495                                  exit: 
  4496 000023E4 E884DDFFFF              	call canonical_on
  4497 000023E9 B83C000000              	mov    rax, 60
  4498 000023EE BF00000000                  mov    rdi, 0
  4499 000023F3 0F05                        syscall
  4500                                  
