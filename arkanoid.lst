     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 50h>         <1>  times column_cells db "X"
    71 00000050 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000052 58                  <2>  db "X"
    76 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A4 58                  <2>  db "X"
    76 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F6 58                  <2>  db "X"
    76 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000148 58                  <2>  db "X"
    76 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000019A 58                  <2>  db "X"
    76 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001EC 58                  <2>  db "X"
    76 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000023E 58                  <2>  db "X"
    76 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000290 58                  <2>  db "X"
    76 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002E2 58                  <2>  db "X"
    76 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000334 58                  <2>  db "X"
    76 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000386 58                  <2>  db "X"
    76 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003D8 58                  <2>  db "X"
    76 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000042A 58                  <2>  db "X"
    76 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000047C 58                  <2>  db "X"
    76 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004CE 58                  <2>  db "X"
    76 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000520 58                  <2>  db "X"
    76 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000572 58                  <2>  db "X"
    76 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005C4 58                  <2>  db "X"
    76 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000616 58                  <2>  db "X"
    76 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000668 58                  <2>  db "X"
    76 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006BA 58                  <2>  db "X"
    76 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000070C 58                  <2>  db "X"
    76 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000075E 58                  <2>  db "X"
    76 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007B0 58                  <2>  db "X"
    76 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000802 58                  <2>  db "X"
    76 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000854 58                  <2>  db "X"
    76 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008A6 58                  <2>  db "X"
    76 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008F8 58                  <2>  db "X"
    76 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000094A 58                  <2>  db "X"
    76 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000099C 58                  <2>  db "X"
    76 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    71 00000A3E 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A40 00<rep A40h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001480 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(8C140000)                  and [termios+12], eax
   146 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(8C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[80140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[80140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231 000014A4 [B213000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   232 000014AC 0300000000000000        	pallet_size dq 3
   233                                  
   234 000014B4 2800000000000000        	ball_x_pos: dq 40
   235 000014BC 1C00000000000000        	ball_y_pos: dq 28
   236 000014C4 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   237 000014CC FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   238 000014D4 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   239                                  
   240                                  ; Definir los límites de la pantalla o área de juego
   241                                      board_top_left_x equ 1
   242                                      board_top_left_y equ 1
   243                                      board_bottom_right_x equ column_cells - 1
   244                                      board_bottom_right_y equ row_cells
   245                                  
   246                                      ; Limites laterales
   247                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   248                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   249                                  
   250                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   251 000014D5 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   252 000014DD [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   253                                  
   254                                      ; Definición de tipos de bloques
   255 000014E5 55555555                    block_type_1: db "UUUU"    ; Durabilidad 1
   256 000014E9 4F4F4F4F                    block_type_2: db "OOOO"    ; Durabilidad 2
   257 000014ED 44444444                    block_type_3: db "DDDD"    ; Durabilidad 3
   258 000014F1 4C4C4C4C                    block_type_4: db "LLLL"    ; Durabilidad 4
   259 000014F5 56565656                    block_type_5: db "VVVV"    ; Durabilidad 5
   260 000014F9 38383838                    block_type_6: db "8888"    ; Durabilidad 6
   261                                      block_length: equ 4        ; Longitud de cada bloque
   262                                  
   263                                      ; Estructura para el nivel actual
   264 000014FD 01                          current_level db 1
   265 000014FE 00                          blocks_remaining db 0
   266                                  
   267                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)
   268                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   269                                          level1_blocks:
   270                                          ; Tercera fila (tipo 3)
   271 000014FF 3C070301                        db 60, 7, 3, 1    ; Bloque 7
   272                                      level1_blocks_count equ 1   ; Cantidad total de bloques
   273                                  
   274                                      ; Nivel 2: Bloques de prueba
   275                                      level2_blocks:
   276 00001503 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   277                                      level2_blocks_count equ 1
   278                                  
   279                                      ; Nivel 3
   280                                      level3_blocks:
   281 00001507 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   282                                  
   283                                      level3_blocks_count equ 1
   284                                  
   285                                      ; Nivel 4
   286                                      level4_blocks:
   287 0000150B 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   288                                      level4_blocks_count equ 1
   289                                  
   290                                      ; Nivel 5
   291                                      level5_blocks:
   292 0000150F 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   293                                      level5_blocks_count equ 1
   294                                  
   295                                      ; Array para mantener el estado de los bloques
   296 00001513 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   297                                  
   298                                  section .text
   299                                  
   300                                  ;	Function: print_ball
   301                                  ; This function displays the position of the ball
   302                                  ; Arguments: none
   303                                  ;
   304                                  ; Return:
   305                                  ;	Void
   306                                  print_ball:
   307 000001DD 4C8B05(B4140000)        	mov r8, [ball_x_pos]
   308 000001E4 4C8B0D(BC140000)        	mov r9, [ball_y_pos]
   309 000001EB 4981C0[400A0000]        	add r8, board
   310                                  
   311 000001F2 4C89C9                  	mov rcx, r9
   312 000001F5 B852000000              	mov rax, column_cells + 2
   313 000001FA 48F7E9                  	imul rcx
   314                                  	
   315 000001FD 4901C0                  	add r8, rax
   316 00000200 41C6004F                	mov byte [r8], char_O
   317 00000204 C3                      	ret
   318                                  
   319                                  	
   320                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   321                                  	
   322                                  
   323                                  
   324                                  
   325                                  ;	Function: print_pallet
   326                                  ; This function moves the pallet in the game
   327                                  ; Arguments: none
   328                                  ;
   329                                  ; Return;
   330                                  ;	void
   331                                  print_pallet:
   332 00000205 4C8B05(A4140000)        	mov r8, [pallet_position]
   333 0000020C 488B0D(AC140000)        	mov rcx, [pallet_size]
   334                                  	.write_pallet:
   335 00000213 41C6003D                		mov byte [r8], char_equal
   336 00000217 49FFC0                  		inc r8
   337 0000021A 48FFC9                  		dec rcx
   338 0000021D 75F4                    		jnz .write_pallet
   339                                  
   340 0000021F C3                      	ret
   341                                  	
   342                                  ;	Function: move_pallet
   343                                  ; This function is in charge of moving the pallet in a given direction
   344                                  ; Arguments:
   345                                  ;	rdi: left direction or right direction
   346                                  ;
   347                                  ; Return:
   348                                  ;	void
   349                                  move_pallet:
   350                                      
   351 00000220 803D(D4140000)00            cmp byte [ball_moving], 0
   352 00000227 7507                        jne .continue_movement
   353 00000229 C605(D4140000)01            mov byte [ball_moving], 1
   354                                  
   355                                      .continue_movement:
   356 00000230 4883FFFF                        cmp rdi, left_direction
   357 00000234 7531                            jne .move_right
   358                                  
   359                                          .move_left:
   360                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   361 00000236 4C8B05(A4140000)                    mov r8, [pallet_position]
   362 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   363 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   364 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   365 00000245 744D                                je .end            ; Si es X, no mover
   366                                              
   367 00000247 4C8B05(A4140000)                    mov r8, [pallet_position]
   368 0000024E 4C8B0D(AC140000)                    mov r9, [pallet_size]
   369 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   370 0000025B 49FFC8                              dec r8
   371 0000025E 4C8905(A4140000)                    mov [pallet_position], r8
   372 00000265 EB2D                                jmp .end
   373                                              
   374                                          .move_right:
   375                                              ; Verificar si la siguiente posición después de la paleta sería una X
   376 00000267 4C8B05(A4140000)                    mov r8, [pallet_position]
   377 0000026E 4C8B0D(AC140000)                    mov r9, [pallet_size]
   378 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   379 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   380 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   381 0000027D 7415                                je .end            ; Si es X, no mover
   382                                              
   383 0000027F 4C8B05(A4140000)                    mov r8, [pallet_position]
   384 00000286 41C60020                            mov byte [r8], char_space
   385 0000028A 49FFC0                              inc r8
   386 0000028D 4C8905(A4140000)                    mov [pallet_position], r8
   387                                          .end:
   388 00000294 C3                                  ret
   389                                  
   390                                  move_ball:
   391                                      ; Si la bola no está en movimiento, no hacer nada
   392 00000295 803D(D4140000)00            cmp byte [ball_moving], 0
   393 0000029C 0F8406010000                je .end
   394                                  
   395                                      ; Borrar la posición actual de la bola
   396 000002A2 4C8B05(B4140000)            mov r8, [ball_x_pos]
   397 000002A9 4C8B0D(BC140000)            mov r9, [ball_y_pos]
   398 000002B0 4981C0[400A0000]            add r8, board
   399 000002B7 4C89C9                      mov rcx, r9
   400 000002BA B852000000                  mov rax, column_cells + 2
   401 000002BF 48F7E9                      imul rcx
   402 000002C2 4901C0                      add r8, rax
   403 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   404                                  
   405                                      ; Calcular siguiente posición X
   406 000002C9 4C8B05(B4140000)            mov r8, [ball_x_pos]
   407 000002D0 4C8B0D(BC140000)            mov r9, [ball_y_pos]
   408 000002D7 488B05(C4140000)            mov rax, [ball_direction_x]
   409 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   410                                  
   411                                      ; Calcular la dirección de memoria para la siguiente posición
   412 000002E1 4D89C2                      mov r10, r8
   413 000002E4 4981C2[400A0000]            add r10, board
   414 000002EB 4C89C9                      mov rcx, r9
   415 000002EE B852000000                  mov rax, column_cells + 2
   416 000002F3 48F7E9                      imul rcx
   417 000002F6 4901C2                      add r10, rax
   418                                  
   419                                      ; Verificar si hay una X en la siguiente posición X
   420 000002F9 418A02                      mov al, [r10]
   421 000002FC 3C58                        cmp al, 'X'
   422 000002FE 750C                        jne .check_block_x
   423 00000300 48F71D(C4140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   424 00000307 E99C000000                  jmp .end
   425                                  
   426                                      .check_block_x:
   427                                          ; Verificar colisión con bloques en X
   428 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   429 0000030E 4151                            push r9
   430 00000310 4152                            push r10
   431 00000312 E834030000                      call check_block_collision
   432 00000317 415A                            pop r10
   433 00000319 4159                            pop r9
   434 0000031B 4158                            pop r8
   435 0000031D 4885C0                          test rax, rax
   436 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   437 00000322 48F71D(C4140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   438 00000329 EB7D                            jmp .end
   439                                  
   440                                      .check_paddle_x:
   441                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   442 0000032B 41803A3D                        cmp byte [r10], char_equal
   443 0000032F 7509                            jne .check_y_movement
   444 00000331 48F71D(C4140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   445 00000338 EB6E                            jmp .end
   446                                  
   447                                      .check_y_movement:
   448                                          ; Calcular siguiente posición Y
   449 0000033A 488B05(CC140000)                mov rax, [ball_direction_y]
   450 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   451                                  
   452                                          ; Calcular la dirección de memoria para la siguiente posición Y
   453 00000344 4D89C2                          mov r10, r8
   454 00000347 4981C2[400A0000]                add r10, board
   455 0000034E 4C89C9                          mov rcx, r9
   456 00000351 B852000000                      mov rax, column_cells + 2
   457 00000356 48F7E9                          imul rcx
   458 00000359 4901C2                          add r10, rax
   459                                  
   460                                          ; Verificar si hay una X en la siguiente posición Y
   461 0000035C 418A02                          mov al, [r10]
   462 0000035F 3C58                            cmp al, 'X'
   463 00000361 7509                            jne .check_block_y
   464 00000363 48F71D(CC140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   465 0000036A EB3C                            jmp .end
   466                                  
   467                                      .check_block_y:
   468                                          ; Verificar colisión con bloques en Y
   469 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   470 0000036E 4151                            push r9
   471 00000370 4152                            push r10
   472 00000372 E8D4020000                      call check_block_collision
   473 00000377 415A                            pop r10
   474 00000379 4159                            pop r9
   475 0000037B 4158                            pop r8
   476 0000037D 4885C0                          test rax, rax
   477 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   478 00000382 48F71D(CC140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   479 00000389 EB1D                            jmp .end
   480                                  
   481                                      .check_paddle_y:
   482                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   483 0000038B 41803A3D                    cmp byte [r10], char_equal
   484 0000038F 7509                        jne .update_position
   485 00000391 48F71D(CC140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   486 00000398 EB0E                        jmp .end
   487                                  
   488                                  
   489                                      .update_position:
   490 0000039A 4C8905(B4140000)                mov [ball_x_pos], r8
   491 000003A1 4C890D(BC140000)                mov [ball_y_pos], r9
   492                                  
   493                                      .end:
   494 000003A8 C3                              ret
   495                                  
   496                                  ; Función para inicializar el nivel
   497                                  ; Función para inicializar el nivel
   498                                  init_level:
   499                                      ; 1) Copiamos board_template en board para que quede "virgen"
   500 000003A9 56                          push rsi
   501 000003AA 57                          push rdi
   502 000003AB 51                          push rcx
   503 000003AC 50                          push rax
   504                                  
   505 000003AD 488D35(00000000)            lea rsi, [board_template]
   506 000003B4 488D3D(400A0000)            lea rdi, [board]
   507 000003BB B9400A0000                  mov rcx, board_template_size
   508 000003C0 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   509                                  
   510 000003C2 58                          pop rax
   511 000003C3 59                          pop rcx
   512 000003C4 5F                          pop rdi
   513 000003C5 5E                          pop rsi
   514                                  
   515                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   516 000003C6 803D(FD140000)01            cmp byte [current_level], 1
   517 000003CD 7431                        je .level1
   518 000003CF 803D(FD140000)02            cmp byte [current_level], 2
   519 000003D6 7454                        je .level2
   520 000003D8 803D(FD140000)03            cmp byte [current_level], 3
   521 000003DF 7477                        je .level3
   522 000003E1 803D(FD140000)04            cmp byte [current_level], 4
   523 000003E8 0F8492000000                je .level4
   524 000003EE 803D(FD140000)05            cmp byte [current_level], 5
   525 000003F5 0F84AD000000                je .level5
   526 000003FB E9D0000000                  jmp .done
   527                                  
   528                                      .level1:
   529 00000400 C605(FE140000)01                mov byte [blocks_remaining], level1_blocks_count
   530 00000407 4831C9                          xor rcx, rcx             
   531                                          .init_loop1:
   532 0000040A 4883F901                            cmp rcx, level1_blocks_count
   533 0000040E 0F8DBC000000                        jge .done
   534 00000414 4889C8                              mov rax, rcx         
   535 00000417 48C1E002                            shl rax, 2          
   536 0000041B 8A90[02150000]                      mov dl, byte [level1_blocks + rax + 3]  
   537 00000421 8891[13150000]                      mov byte [block_states + rcx], dl
   538 00000427 48FFC1                              inc rcx
   539 0000042A EBDE                                jmp .init_loop1
   540                                  
   541                                      .level2:
   542 0000042C C605(FE140000)01                mov byte [blocks_remaining], level2_blocks_count
   543 00000433 4831C9                          xor rcx, rcx             
   544                                          .init_loop2:
   545 00000436 4883F901                            cmp rcx, level2_blocks_count
   546 0000043A 0F8D90000000                        jge .done
   547 00000440 4889C8                              mov rax, rcx         
   548 00000443 48C1E002                            shl rax, 2          
   549 00000447 8A90[06150000]                      mov dl, byte [level2_blocks + rax + 3]  
   550 0000044D 8891[13150000]                      mov byte [block_states + rcx], dl
   551 00000453 48FFC1                              inc rcx
   552 00000456 EBDE                                jmp .init_loop2
   553                                      .level3:
   554 00000458 C605(FE140000)01                mov byte [blocks_remaining], level3_blocks_count
   555 0000045F 4831C9                          xor rcx, rcx             
   556                                          .init_loop3:
   557 00000462 4883F901                            cmp rcx, level3_blocks_count
   558 00000466 7D68                                jge .done
   559 00000468 4889C8                              mov rax, rcx         
   560 0000046B 48C1E002                            shl rax, 2          
   561 0000046F 8A90[0A150000]                      mov dl, byte [level3_blocks + rax + 3]  
   562 00000475 8891[13150000]                      mov byte [block_states + rcx], dl
   563 0000047B 48FFC1                              inc rcx
   564 0000047E EBE2                                jmp .init_loop3
   565                                  
   566                                      .level4:
   567 00000480 C605(FE140000)01                mov byte [blocks_remaining], level4_blocks_count
   568 00000487 4831C9                          xor rcx, rcx             
   569                                          .init_loop4:
   570 0000048A 4883F901                            cmp rcx, level4_blocks_count
   571 0000048E 7D40                                jge .done
   572 00000490 4889C8                              mov rax, rcx         
   573 00000493 48C1E002                            shl rax, 2          
   574 00000497 8A90[0E150000]                      mov dl, byte [level4_blocks + rax + 3]  
   575 0000049D 8891[13150000]                      mov byte [block_states + rcx], dl
   576 000004A3 48FFC1                              inc rcx
   577 000004A6 EBE2                                jmp .init_loop4
   578                                  
   579                                      .level5:
   580 000004A8 C605(FE140000)01                mov byte [blocks_remaining], level5_blocks_count
   581 000004AF 4831C9                          xor rcx, rcx             
   582                                          .init_loop5:
   583 000004B2 4883F901                            cmp rcx, level5_blocks_count
   584 000004B6 7D18                                jge .done
   585 000004B8 4889C8                              mov rax, rcx         
   586 000004BB 48C1E002                            shl rax, 2          
   587 000004BF 8A90[12150000]                      mov dl, byte [level5_blocks + rax + 3]  
   588 000004C5 8891[13150000]                      mov byte [block_states + rcx], dl
   589 000004CB 48FFC1                              inc rcx
   590 000004CE EBE2                                jmp .init_loop5
   591                                      .done:
   592 000004D0 C3                              ret
   593                                  
   594                                  
   595                                  ; Función para verificar y manejar la transición de nivel
   596                                  check_level_complete:
   597                                      ; Verificar si quedan bloques
   598 000004D1 803D(FE140000)00            cmp byte [blocks_remaining], 0
   599 000004D8 753C                        jne .not_complete
   600                                      
   601                                      ; Incrementar el nivel
   602 000004DA FE05(FD140000)              inc byte [current_level]
   603                                      
   604                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   605 000004E0 803D(FD140000)06            cmp byte [current_level], 6
   606 000004E7 742E                        je game_win
   607                                      
   608                                      ; Reinicializar el juego para el siguiente nivel
   609 000004E9 E8BBFEFFFF                  call init_level
   610                                      
   611                                      ; Reinicializar la posición de la bola y la paleta
   612 000004EE 48C705(B4140000)28-         mov qword [ball_x_pos], 40
   612 000004F6 000000             
   613 000004F9 48C705(BC140000)1C-         mov qword [ball_y_pos], 28
   613 00000501 000000             
   614 00000504 C605(D4140000)00            mov byte [ball_moving], 0
   615 0000050B 48C705(A4140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   615 00000512 [B2130000]         
   616                                      
   617                                      .not_complete:
   618 00000516 C3                              ret
   619                                  
   620                                      ; Nueva función para manejar la victoria del juego
   621                                      game_win:
   622                                          ; Aquí puedes agregar lógica para mostrar un mensaje de victoria
   623                                          ; y terminar el juego o reiniciarlo
   624 00000517 E948030000                      jmp exit
   625                                  
   626                                  ; Función para imprimir los bloques
   627                                  ; Función modificada para imprimir bloques
   628                                  
   629                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   630                                  get_current_level_blocks:
   631 0000051C 803D(FD140000)01            cmp byte [current_level], 1
   632 00000523 7428                        je .level1
   633 00000525 803D(FD140000)02            cmp byte [current_level], 2
   634 0000052C 7427                        je .level2
   635 0000052E 803D(FD140000)03            cmp byte [current_level], 3
   636 00000535 7426                        je .level3
   637 00000537 803D(FD140000)04            cmp byte [current_level], 4
   638 0000053E 7425                        je .level4
   639 00000540 803D(FD140000)05            cmp byte [current_level], 5
   640 00000547 7424                        je .level5
   641                                      ; Si llegamos aquí, hay un error en el nivel
   642 00000549 4831C0                      xor rax, rax
   643 0000054C C3                          ret
   644                                  
   645                                      .level1:
   646 0000054D 488D05(FF140000)                lea rax, [level1_blocks]
   647 00000554 C3                              ret
   648                                      .level2:
   649 00000555 488D05(03150000)                lea rax, [level2_blocks]
   650 0000055C C3                              ret
   651                                      .level3:
   652 0000055D 488D05(07150000)                lea rax, [level3_blocks]
   653 00000564 C3                              ret
   654                                      .level4:
   655 00000565 488D05(0B150000)                lea rax, [level4_blocks]
   656 0000056C C3                              ret
   657                                      .level5:
   658 0000056D 488D05(0F150000)                lea rax, [level5_blocks]
   659 00000574 C3                              ret
   660                                  ; Función para obtener la cantidad de bloques del nivel actual
   661                                  get_current_level_count:
   662 00000575 803D(FD140000)01            cmp byte [current_level], 1
   663 0000057C 7428                        je .level1
   664 0000057E 803D(FD140000)02            cmp byte [current_level], 2
   665 00000585 7425                        je .level2
   666 00000587 803D(FD140000)03            cmp byte [current_level], 3
   667 0000058E 7422                        je .level3
   668 00000590 803D(FD140000)04            cmp byte [current_level], 4
   669 00000597 741F                        je .level4
   670 00000599 803D(FD140000)05            cmp byte [current_level], 5
   671 000005A0 741C                        je .level5
   672                                      ; Si llegamos aquí, hay un error en el nivel
   673 000005A2 4831C0                      xor rax, rax
   674 000005A5 C3                          ret
   675                                  
   676                                      .level1:
   677 000005A6 B801000000                      mov rax, level1_blocks_count
   678 000005AB C3                              ret
   679                                      .level2:
   680 000005AC B801000000                      mov rax, level2_blocks_count
   681 000005B1 C3                              ret
   682                                      .level3:
   683 000005B2 B801000000                      mov rax, level3_blocks_count
   684 000005B7 C3                              ret
   685                                      .level4:
   686 000005B8 B801000000                      mov rax, level4_blocks_count
   687 000005BD C3                              ret
   688                                      .level5:
   689 000005BE B801000000                      mov rax, level5_blocks_count
   690 000005C3 C3                              ret
   691                                  
   692                                  
   693                                  print_blocks:
   694 000005C4 55                          push rbp
   695 000005C5 4889E5                      mov rbp, rsp
   696                                      
   697                                      ; Obtener puntero a los bloques del nivel actual
   698 000005C8 E84FFFFFFF                  call get_current_level_blocks
   699 000005CD 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   700                                      
   701                                      ; Obtener cantidad de bloques del nivel actual
   702 000005D0 E8A0FFFFFF                  call get_current_level_count
   703 000005D5 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   704                                      
   705 000005D8 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   706                                      
   707                                      .print_loop:
   708 000005DB 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   709 000005DE 7D69                            jge .end
   710                                          
   711                                          ; Verificar si el bloque está activo
   712 000005E0 490FB68424-                     movzx rax, byte [block_states + r12]
   712 000005E5 [13150000]         
   713 000005E9 4885C0                          test rax, rax
   714 000005EC 7456                            jz .next_block
   715                                          
   716                                          ; Obtener posición y tipo del bloque usando r13
   717 000005EE 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   718 000005F3 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   719 000005F8 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   720                                          
   721                                          ; El resto de la lógica de impresión permanece igual
   722 000005FD 4D0FB6C0                        movzx r8, r8b
   723 00000601 4D0FB6C9                        movzx r9, r9b
   724 00000605 4981C0[400A0000]                add r8, board
   725 0000060C B852000000                      mov rax, column_cells + 2
   726 00000611 49F7E1                          mul r9
   727 00000614 4901C0                          add r8, rax
   728                                          
   729 00000617 B904000000                      mov rcx, block_length
   730 0000061C 48BE-                           mov rsi, block_type_1
   730 0000061E [E514000000000000] 
   731 00000626 490FB6C2                        movzx rax, r10b
   732 0000062A 48FFC8                          dec rax
   733 0000062D 486BC004                        imul rax, block_length
   734 00000631 4801C6                          add rsi, rax
   735                                          
   736                                      .print_block_chars:
   737 00000634 8A06                            mov al, [rsi]
   738 00000636 418800                          mov [r8], al
   739 00000639 48FFC6                          inc rsi
   740 0000063C 49FFC0                          inc r8
   741 0000063F 48FFC9                          dec rcx
   742 00000642 75F0                            jnz .print_block_chars
   743                                          
   744                                      .next_block:
   745 00000644 49FFC4                          inc r12
   746 00000647 EB92                            jmp .print_loop
   747                                          
   748                                      .end:
   749 00000649 5D                              pop rbp
   750 0000064A C3                              ret
   751                                  
   752                                  
   753                                  ; Función modificada para detectar colisión
   754                                  ; Función mejorada para detectar colisión y manejar la física
   755                                  ; Función corregida para manejar colisiones con bloques completos
   756                                  ;---------------------------------------------------------
   757                                  ; check_block_collision:
   758                                  ;   Detecta si en la posición r10 (que apunta a board[])
   759                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
   760                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
   761                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
   762                                  ;   retorna 0.
   763                                  ;---------------------------------------------------------
   764                                  ;--------------------------------------
   765                                  ; check_block_collision
   766                                  ;--------------------------------------
   767                                  ; Actualizar check_block_collision para usar el nivel actual
   768                                  check_block_collision:
   769 0000064B 55                          push rbp
   770 0000064C 4889E5                      mov rbp, rsp
   771                                  
   772 0000064F 418A02                      mov al, [r10]
   773                                  
   774                                      ; Verificación de caracteres igual que antes...
   775 00000652 3C55                        cmp al, 'U'  
   776 00000654 7419                        je .possible
   777 00000656 3C4F                        cmp al, 'O'  
   778 00000658 7415                        je .possible
   779 0000065A 3C44                        cmp al, 'D'  
   780 0000065C 7411                        je .possible
   781 0000065E 3C4C                        cmp al, 'L'  
   782 00000660 740D                        je .possible
   783 00000662 3C56                        cmp al, 'V'  
   784 00000664 7409                        je .possible
   785 00000666 3C38                        cmp al, '8'  
   786 00000668 7405                        je .possible
   787                                  
   788 0000066A 4831C0                      xor rax, rax
   789 0000066D 5D                          pop rbp
   790 0000066E C3                          ret
   791                                  
   792                                      .possible:
   793 0000066F 53                              push rbx
   794 00000670 57                              push rdi
   795 00000671 56                              push rsi
   796 00000672 4154                            push r12
   797                                  
   798                                          ; Obtener puntero a los bloques del nivel actual
   799 00000674 E8A3FEFFFF                      call get_current_level_blocks
   800 00000679 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
   801                                          
   802                                          ; Obtener cantidad de bloques del nivel actual
   803 0000067C E8F4FEFFFF                      call get_current_level_count
   804 00000681 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
   805                                  
   806 00000684 4D31E4                          xor r12, r12
   807                                      .find_block_loop:
   808 00000687 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   809 0000068A 0F8D8C000000                    jge .no_block_found
   810                                  
   811                                          ; El resto de la lógica de verificación de colisiones...
   812 00000690 418A9C24[13150000]              mov bl, [block_states + r12]
   813 00000698 84DB                            test bl, bl
   814 0000069A 7478                            jz .next_block
   815                                  
   816                                          ; Usar r13 para acceder a los bloques del nivel actual
   817 0000069C 4C89E8                          mov rax, r13
   818 0000069F 4D6BE404                        imul r12, 4
   819 000006A3 4C01E0                          add rax, r12
   820 000006A6 8A10                            mov dl, [rax]       ; x
   821 000006A8 8A4801                          mov cl, [rax+1]     ; y
   822                                  
   823                                          ; Revertir r12
   824 000006AB 4D89E4                          mov r12, r12
   825 000006AE 49C1EC02                        shr r12, 2
   826                                  
   827                                          ; La misma lógica de detección de colisiones...
   828 000006B2 488D3D(400A0000)                lea rdi, [board]
   829 000006B9 4831C0                          xor rax, rax
   830 000006BC B852000000                      mov rax, column_cells + 2
   831 000006C1 480FB6C9                        movzx rcx, cl
   832 000006C5 480FAFC1                        imul rax, rcx
   833 000006C9 4801C7                          add rdi, rax
   834 000006CC 480FB6C2                        movzx rax, dl
   835 000006D0 4801C7                          add rdi, rax
   836                                  
   837 000006D3 4939FA                          cmp r10, rdi
   838 000006D6 723C                            jb .next_block
   839 000006D8 488D5F04                        lea rbx, [rdi + 4]
   840 000006DC 4939DA                          cmp r10, rbx
   841 000006DF 7333                            jae .next_block
   842                                  
   843                                          ; Manejo de colisión igual que antes...
   844 000006E1 41FE8C24[13150000]              dec byte [block_states + r12]
   845 000006E9 418A9C24[13150000]              mov bl, [block_states + r12]
   846 000006F1 84DB                            test bl, bl
   847 000006F3 7513                            jnz .still_alive
   848                                  
   849 000006F5 B904000000                      mov rcx, 4
   850                                      .erase_block_chars:
   851 000006FA C60720                          mov byte [rdi], char_space
   852 000006FD 48FFC7                          inc rdi
   853 00000700 E2F8                            loop .erase_block_chars
   854                                  
   855 00000702 FE0D(FE140000)                  dec byte [blocks_remaining]
   856                                  
   857                                      .still_alive:
   858 00000708 B801000000                      mov rax, 1
   859 0000070D 415C                            pop r12
   860 0000070F 5E                              pop rsi
   861 00000710 5F                              pop rdi
   862 00000711 5B                              pop rbx
   863 00000712 5D                              pop rbp
   864 00000713 C3                              ret
   865                                  
   866                                      .next_block:
   867 00000714 49FFC4                          inc r12
   868 00000717 E96BFFFFFF                      jmp .find_block_loop
   869                                  
   870                                      .no_block_found:
   871 0000071C 4831C0                          xor rax, rax
   872 0000071F 415C                            pop r12
   873 00000721 5E                              pop rsi
   874 00000722 5F                              pop rdi
   875 00000723 5B                              pop rbx
   876 00000724 5D                              pop rbp
   877 00000725 C3                              ret
   878                                  
   879                                  
   880                                  
   881                                  _start:
   882 00000726 E800FAFFFF              	call canonical_off
   883 0000072B E8C1000000              	call start_screen
   884 00000730 E874FCFFFF                  call init_level
   885 00000735 EB00                    	jmp .main_loop
   886                                  	
   887                                  
   888                                  	.main_loop:
   889 00000737 E8C9FAFFFF              		call print_pallet
   890 0000073C E854FBFFFF                      call move_ball
   891 00000741 E87EFEFFFF                      call print_blocks
   892 00000746 E886FDFFFF                      call check_level_complete
   893 0000074B E88DFAFFFF              		call print_ball
   894                                  		print board, board_size				
    82 00000750 B801000000          <1>  mov eax, sys_write
    83 00000755 BF01000000          <1>  mov edi, 1
    84 0000075A 48BE-               <1>  mov rsi, %1
    84 0000075C [400A000000000000]  <1>
    85 00000764 BA400A0000          <1>  mov edx, %2
    86 00000769 0F05                <1>  syscall
   895                                  		;setnonblocking	
   896                                  	.read_more:	
   897                                  		getchar	
    90 0000076B B800000000          <1>  mov rax, sys_read
    91 00000770 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000775 48BE-               <1>  mov rsi, input_char
    92 00000777 [0000000000000000]  <1>
    93 0000077F BA01000000          <1>  mov rdx, 1
    94 00000784 0F05                <1>  syscall
   898                                  		
   899 00000786 4883F801                		cmp rax, 1
   900 0000078A 7532                        	jne .done
   901                                  		
   902 0000078C 8A05(00000000)          		mov al,[input_char]
   903                                  
   904 00000792 3C61                    		cmp al, 'a'
   905 00000794 750E                    	    jne .not_left
   906 00000796 48C7C7FFFFFFFF          	    mov rdi, left_direction
   907 0000079D E87EFAFFFF              		call move_pallet
   908 000007A2 EB1A                    	    jmp .done
   909                                  		
   910                                  		.not_left:
   911 000007A4 3C64                    		 	cmp al, 'd'
   912 000007A6 750C                    	    	jne .not_right
   913 000007A8 BF01000000              			mov rdi, right_direction
   914 000007AD E86EFAFFFF              	    	call move_pallet
   915 000007B2 EB0A                        		jmp .done		
   916                                  
   917                                  		.not_right:
   918                                  
   919 000007B4 3C71                        		cmp al, 'q'
   920 000007B6 0F84A8000000                		je exit
   921                                  
   922 000007BC EBAD                    			jmp .read_more
   923                                  		
   924                                  		.done:	
   925                                  			;unsetnonblocking		
   926                                  			sleeptime	
    98 000007BE B823000000          <1>  mov eax, sys_nanosleep
    99 000007C3 48BF-               <1>  mov rdi, timespec
    99 000007C5 [0000000000000000]  <1>
   100 000007CD 31F6                <1>  xor esi, esi
   101 000007CF 0F05                <1>  syscall
   927                                  			print clear, clear_length
    82 000007D1 B801000000          <1>  mov eax, sys_write
    83 000007D6 BF01000000          <1>  mov edi, 1
    84 000007DB 48BE-               <1>  mov rsi, %1
    84 000007DD [1000000000000000]  <1>
    85 000007E5 BA07000000          <1>  mov edx, %2
    86 000007EA 0F05                <1>  syscall
   928 000007EC E946FFFFFF                  		jmp .main_loop
   929                                  
   930                                  
   931                                  
   932                                  start_screen:
   933                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000007F1 B801000000          <1>  mov eax, sys_write
    83 000007F6 BF01000000          <1>  mov edi, 1
    84 000007FB 48BE-               <1>  mov rsi, %1
    84 000007FD [1000000000000000]  <1>
    85 00000805 BA07000000          <1>  mov edx, %2
    86 0000080A 0F05                <1>  syscall
   934                                      print msg1, msg1_length
    82 0000080C B801000000          <1>  mov eax, sys_write
    83 00000811 BF01000000          <1>  mov edi, 1
    84 00000816 48BE-               <1>  mov rsi, %1
    84 00000818 [1700000000000000]  <1>
    85 00000820 BA14010000          <1>  mov edx, %2
    86 00000825 0F05                <1>  syscall
   935                                      
   936                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
   937                                          getchar                 ; Esperamos una tecla
    90 00000827 B800000000          <1>  mov rax, sys_read
    91 0000082C BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000831 48BE-               <1>  mov rsi, input_char
    92 00000833 [0000000000000000]  <1>
    93 0000083B BA01000000          <1>  mov rdx, 1
    94 00000840 0F05                <1>  syscall
   938 00000842 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
   939 00000846 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
   940                                          
   941                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000848 B801000000          <1>  mov eax, sys_write
    83 0000084D BF01000000          <1>  mov edi, 1
    84 00000852 48BE-               <1>  mov rsi, %1
    84 00000854 [1000000000000000]  <1>
    85 0000085C BA07000000          <1>  mov edx, %2
    86 00000861 0F05                <1>  syscall
   942 00000863 C3                          ret
   943                                  
   944                                  exit: 
   945 00000864 E804F9FFFF              	call canonical_on
   946 00000869 B83C000000              	mov    rax, 60
   947 0000086E BF00000000                  mov    rdi, 0
   948 00000873 0F05                        syscall
   949                                  
