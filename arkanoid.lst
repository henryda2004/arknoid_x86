     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293 000014CA 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   294 000014CF 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   295 000014D4 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   296 000014D9 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   297                                  
   298                                  
   299                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   300                                  
   301                                      ; Nivel 2: Bloques de prueba
   302                                      level2_blocks:
   303 000014DE 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   304                                      level2_blocks_count equ 1
   305                                  
   306                                      ; Nivel 3
   307                                      level3_blocks:
   308 000014E3 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   309                                  
   310                                      level3_blocks_count equ 1
   311                                  
   312                                      ; Nivel 4
   313                                      level4_blocks:
   314 000014E8 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   315                                      level4_blocks_count equ 1
   316                                  
   317                                      ; Nivel 5
   318                                      level5_blocks:
   319 000014ED 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   320                                      level5_blocks_count equ 1
   321                                  
   322                                      ; Array para mantener el estado de los bloques
   323 000014F2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   324                                  
   325                                      
   326                                      ; Variables para almacenar los valores
   327 00001556 0000000000000000            current_score dq 0          ; Score actual
   328 0000155E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   329                                      
   330                                      ; Buffer para convertir números a string
   331 0000155F 00<rep 14h>                 number_buffer: times 20 db 0
   332                                  
   333 00001573 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   334                                      
   335                                      ; Estructura para los enemigos (x, y, activo)
   336 00001578 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   337 00001596 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   338                                      
   339 00001597 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   340 0000159F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   341 000015A0 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   342 000015A1 00                          enemy_move_total db 0      ; Contador total de movimientos
   343 000015A2 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   344 000015A3 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   345                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   346                                      ; Añade esto en la sección .dataa
   347 000015A4 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   347 000015AD 12                 
   348 000015AE 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   348 000015B7 13                 
   349 000015B8 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   349 000015C1 1B                 
   350 000015C2 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   350 000015CB 1C                 
   351 000015CC 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   351 000015D5 2D                 
   352                                          ; Arreglo de punteros a los spawn points de cada nivel
   353                                      spawn_points_table:
   354 000015D6 [A415000000000000]              dq level1_spawn_points
   355 000015DE [AE15000000000000]              dq level2_spawn_points
   356 000015E6 [B815000000000000]              dq level3_spawn_points
   357 000015EE [C215000000000000]              dq level4_spawn_points
   358 000015F6 [CC15000000000000]              dq level5_spawn_points
   359                                  
   360                                      ; Variables para el comportamiento de enemigos
   361 000015FE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   362 000015FF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   363 00001600 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   364 00001601 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   365                                  
   366 0000160B 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   366 00001614 5B2020202020202020-
   366 0000161D 20205D0A0D         
   367                                      score_label_len: equ $ - score_label
   368 00001622 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   368 0000162B 657374727569646F73-
   368 00001634 3A205B2020205D0A0D 
   369                                      blocks_label_len: equ $ - blocks_label
   370                                      
   371                                      ; Posición donde insertar los números en los labels
   372                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   373                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   374                                      
   375                                      ; Definición de las vidas (x, y, estado)
   376                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   377                                      lives_data: 
   378 0000163D 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   379 00001640 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   380 00001643 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   381 00001646 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   382 00001649 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   383 0000164C 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   384 0000164F 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   385                                      lives_count equ 7    ; Total de vidas
   386 00001652 5E                          life_char db "^"    
   387 00001653 04                          current_lives db 4   ; Contador de vidas activas actual
   388                                  
   389                                  ; Estructura para almacenar las letras y sus posiciones
   390                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   391 00001654 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   392 000017E4 00                          letters_count db 0   
   393 000017E5 20                          last_letter db ' '    ; Variable para almacenar la última letra
   394 000017E6 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   394 000017EF 75616C3A205B205D0A-
   394 000017F8 0D                 
   395                                      last_letter_msg_len equ $ - last_letter_msg
   396 000017F9 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   397 000017FA 07                          max_lives db 7              ; Máximo número de vidas permitidas
   398 000017FB 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   399 00001803 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   400 0000180B 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   401                                  
   402 00001813 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   403 00001814 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   404 00001815 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   405 0000181D 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   406                                  
   407 0000181E 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   408 0000181F 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   409 00001820 00                          laser_count: db 0                ; Contador de láseres activos
   410 00001821 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   411 000018E9 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   412                                  
   413                                  section .text
   414                                  
   415                                  
   416                                  print_lives:
   417 000001DD 55                          push rbp
   418 000001DE 4889E5                      mov rbp, rsp
   419                                      
   420 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   421                                      
   422                                      .print_loop:
   423 000001E4 4983FC07                        cmp r12, lives_count
   424 000001E8 7D45                            jge .end
   425                                          
   426                                          ; Calcular offset de la vida actual
   427 000001EA 4C89E0                          mov rax, r12
   428 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   429 000001F1 488DB0[3D160000]                lea rsi, [lives_data + rax]
   430                                          
   431                                          ; Calcular posición en el tablero
   432 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   433 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   434                                          
   435                                          ; Calcular offset en el tablero
   436 00000201 B84E000000                      mov rax, column_cells
   437 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   438 0000020A 49F7E1                          mul r9
   439 0000020D 4C01C0                          add rax, r8
   440 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   441                                          
   442                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   443 00000217 807E0201                        cmp byte [rsi + 2], 1
   444 0000021B 7405                            je .draw_active
   445                                          
   446                                          ; Si está inactiva, dibujar espacio
   447 0000021D C60720                          mov byte [rdi], ' '
   448 00000220 EB08                            jmp .next_life
   449                                          
   450                                      .draw_active:
   451                                          ; Si está activa, dibujar el símbolo de vida
   452 00000222 8A05(52160000)                  mov al, [life_char]
   453 00000228 8807                            mov [rdi], al
   454                                          
   455                                      .next_life:
   456 0000022A 49FFC4                          inc r12
   457 0000022D EBB5                            jmp .print_loop
   458                                          
   459                                      .end:
   460 0000022F 5D                              pop rbp
   461 00000230 C3                              ret
   462                                  
   463                                  ; Función para desactivar una vida
   464                                  ; Función modificada para perder una vida
   465                                  lose_life:
   466 00000231 55                          push rbp
   467 00000232 4889E5                      mov rbp, rsp
   468                                      
   469                                      ; Verificar si aún quedan vidas
   470 00000235 803D(53160000)00            cmp byte [current_lives], 0
   471 0000023C 0F8493000000                je .game_lost
   472                                      
   473                                      ; Encontrar la última vida activa
   474 00000242 B907000000                  mov rcx, lives_count
   475 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   476                                      
   477                                      .find_active_life:
   478 0000024A 4889C8                          mov rax, rcx
   479 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   480 00000251 488DB0[3D160000]                lea rsi, [lives_data + rax]
   481 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   482 0000025C 7407                            je .deactivate_life
   483 0000025E 48FFC9                          dec rcx
   484 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   485 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   486                                          
   487                                      .deactivate_life:
   488                                          ; Calcular posición correcta en el tablero para borrar la vida
   489 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   490 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   491                                          
   492                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   493 0000026E B84E000000                      mov rax, column_cells
   494 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   495 00000277 49F7E1                          mul r9
   496 0000027A 4C01C0                          add rax, r8
   497 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   498                                          
   499                                          ; Borrar visualmente la vida
   500 00000284 C60720                          mov byte [rdi], ' '             
   501                                          
   502                                          ; Desactivar la vida en los datos
   503 00000287 C6460200                        mov byte [rsi + 2], 0          
   504 0000028B FE0D(53160000)                  dec byte [current_lives]
   505                                          
   506                                          ; Borrar visualmente la paleta anterior
   507 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   508 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   509                                          .erase_pallet_loop:
   510 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   511 000002A3 49FFC0                              inc r8
   512 000002A6 48FFC9                              dec rcx
   513 000002A9 75F4                                jnz .erase_pallet_loop
   514                                          
   515                                  
   516                                          ; Reiniciar posición de la bola y la paleta
   517 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   517 000002B3 000000             
   518 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   518 000002BE 000000             
   519 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   520 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   520 000002CF [36130000]         
   521                                          
   522 000002D3 EB07                            jmp .end
   523                                          
   524                                      .game_lost:
   525 000002D5 E81C000000                      call game_lost
   526 000002DA EB00                            jmp .end
   527                                          
   528                                      .end:
   529 000002DC 5D                              pop rbp
   530 000002DD C3                              ret
   531                                  ; Función modificada para verificar colisión con el borde inferior
   532                                  check_bottom_collision:
   533 000002DE 55                          push rbp
   534 000002DF 4889E5                      mov rbp, rsp
   535                                      
   536                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   537 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   538 000002E9 4883F81E                    cmp rax, row_cells - 2
   539 000002ED 7505                        jne .no_collision
   540                                      
   541                                      ; Si hay colisión, perder una vida
   542 000002EF E83DFFFFFF                  call lose_life
   543                                      
   544                                      .no_collision:
   545 000002F4 5D                              pop rbp
   546 000002F5 C3                              ret
   547                                  
   548                                  ; Nueva función para game over
   549                                  game_lost:
   550                                      ; Limpiar la pantalla
   551                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   552                                      
   553                                      ; Mostrar mensaje de derrota
   554                                      section .data
   555 000018F1 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   555 000018FA 6469646F210A0D     
   556                                          lost_msg_len: equ $ - lost_msg
   557                                      section .text
   558                                      
   559                                      ; Imprimir mensaje de derrota
   560                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [F118000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   561                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [1F19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   562                                      
   563                                      ; Mostrar puntaje final
   564 00000347 488B05(56150000)            mov rax, [current_score]
   565 0000034E 48BF-                       mov rdi, number_buffer
   565 00000350 [5F15000000000000] 
   566 00000358 E8CB0D0000                  call number_to_string
   567                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [5F15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   568                                      
   569                                      ; Esperar un momento antes de salir
   570 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   570 00000381 0000               
   571 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   571 0000038C 0000               
   572                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   573                                      
   574 000003A1 E976150000                  jmp exit
   575                                  
   576                                  
   577                                  ; Función para registrar una nueva letra en el mapa
   578                                  ; Entrada:
   579                                  ;   al - letra a registrar
   580                                  ;   r8b - posición x
   581                                  ;   r9b - posición y
   582                                  register_letter:
   583 000003A6 55                          push rbp
   584 000003A7 4889E5                      mov rbp, rsp
   585 000003AA 53                          push rbx
   586 000003AB 51                          push rcx
   587                                      
   588 000003AC 3C20                        cmp al, ' '
   589 000003AE 7438                        je .end
   590                                  
   591                                      ; Encontrar un espacio libre en el mapa
   592 000003B0 4831C9                      xor rcx, rcx
   593 000003B3 480FB615(E4170000)          movzx rdx, byte [letters_count]
   594                                      
   595                                      .find_slot:
   596 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   597 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   598                                          
   599 000003C1 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   600 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   601 000003CD 7405                            je .found_slot
   602                                          
   603 000003CF 48FFC1                          inc rcx
   604 000003D2 EBE7                            jmp .find_slot
   605                                          
   606                                      .found_slot:
   607                                          ; Guardar la información de la letra
   608 000003D4 448803                          mov [rbx], r8b           ; x
   609 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   610 000003DB 884302                          mov [rbx + 2], al        ; letra
   611 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   612                                          
   613 000003E2 FE05(E4170000)                  inc byte [letters_count]
   614                                          
   615                                      .end:
   616 000003E8 59                              pop rcx
   617 000003E9 5B                              pop rbx
   618 000003EA 5D                              pop rbp
   619 000003EB C3                              ret
   620                                  
   621                                  ; Función para imprimir todas las letras registradas
   622                                  print_letters:
   623 000003EC 55                          push rbp
   624 000003ED 4889E5                      mov rbp, rsp
   625 000003F0 53                          push rbx
   626 000003F1 51                          push rcx
   627                                      
   628 000003F2 4831C9                      xor rcx, rcx
   629                                      
   630                                      .print_loop:
   631 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   632 000003F9 7D37                            jge .end
   633                                          
   634                                          ; Obtener puntero a la letra actual
   635 000003FB 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   636                                          
   637                                          ; Verificar si está activa
   638 00000403 807B0300                        cmp byte [rbx + 3], 0
   639 00000407 7424                            je .next_letter
   640                                          
   641                                          ; Calcular posición en el tablero
   642 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   643 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   644                                          
   645                                          ; Calcular offset en el tablero
   646 00000412 B84E000000                      mov rax, column_cells
   647 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   648 0000041B 49F7E1                          mul r9
   649 0000041E 4C01C0                          add rax, r8
   650 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   651                                          
   652                                          ; Imprimir la letra
   653 00000428 8A4302                          mov al, [rbx + 2]
   654 0000042B 8807                            mov [rdi], al
   655                                          
   656                                      .next_letter:
   657 0000042D 48FFC1                          inc rcx
   658 00000430 EBC3                            jmp .print_loop
   659                                          
   660                                      .end:
   661 00000432 59                              pop rcx
   662 00000433 5B                              pop rbx
   663 00000434 5D                              pop rbp
   664 00000435 C3                              ret
   665                                  
   666                                  ; Función para borrar una letra específica
   667                                  ; Entrada:
   668                                  ;   r8b - posición x
   669                                  ;   r9b - posición y
   670                                  remove_letter:
   671 00000436 55                          push rbp
   672 00000437 4889E5                      mov rbp, rsp
   673 0000043A 53                          push rbx
   674 0000043B 51                          push rcx
   675                                      
   676 0000043C 4831C9                      xor rcx, rcx
   677                                      
   678                                      .find_loop:
   679 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   680 00000443 7D2E                            jge .end
   681                                          
   682 00000445 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   683                                          
   684                                          ; Verificar si está activa y coincide la posición
   685 0000044D 807B0300                        cmp byte [rbx + 3], 0
   686 00000451 741B                            je .next_letter
   687                                          
   688 00000453 8A03                            mov al, [rbx]
   689 00000455 4438C0                          cmp al, r8b
   690 00000458 7514                            jne .next_letter
   691                                          
   692 0000045A 8A4301                          mov al, [rbx + 1]
   693 0000045D 4438C8                          cmp al, r9b
   694 00000460 750C                            jne .next_letter
   695                                          
   696                                          ; Encontrada la letra, desactivarla
   697 00000462 C6430300                        mov byte [rbx + 3], 0
   698 00000466 FE0D(E4170000)                  dec byte [letters_count]
   699 0000046C EB05                            jmp .end
   700                                          
   701                                      .next_letter:
   702 0000046E 48FFC1                          inc rcx
   703 00000471 EBCC                            jmp .find_loop
   704                                          
   705                                      .end:
   706 00000473 59                              pop rcx
   707 00000474 5B                              pop rbx
   708 00000475 5D                              pop rbp
   709 00000476 C3                              ret
   710                                  ; Función para mover las letras hacia abajo
   711                                  move_letters:
   712 00000477 55                          push rbp
   713 00000478 4889E5                      mov rbp, rsp
   714 0000047B 53                          push rbx
   715 0000047C 57                          push rdi
   716 0000047D 56                          push rsi
   717 0000047E 4150                        push r8
   718 00000480 4151                        push r9
   719 00000482 4152                        push r10
   720 00000484 4153                        push r11
   721                                  
   722 00000486 4831C9                      xor rcx, rcx
   723                                  
   724                                      .move_loop:
   725 00000489 4883F964                        cmp rcx, 100
   726 0000048D 0F8DAD010000                    jge .print_last_letter
   727                                          
   728 00000493 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   729 0000049B 807B0300                        cmp byte [rbx + 3], 0
   730 0000049F 0F8493010000                    je .next_letter
   731                                  
   732 000004A5 4C0FB603                        movzx r8, byte [rbx]
   733 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   734                                  
   735 000004AE B84E000000                      mov rax, column_cells
   736 000004B3 4883C002                        add rax, 2
   737 000004B7 49F7E1                          mul r9
   738 000004BA 4C01C0                          add rax, r8
   739 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   740 000004C4 C60720                          mov byte [rdi], ' '
   741                                  
   742 000004C7 FE4301                          inc byte [rbx + 1]
   743 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   744                                  
   745 000004CF 4983F91F                        cmp r9, row_cells - 1
   746 000004D3 7C09                            jl .check_pallet_collision
   747                                  
   748 000004D5 C6430300                        mov byte [rbx + 3], 0
   749 000004D9 E95A010000                      jmp .next_letter
   750                                  
   751                                          .check_pallet_collision:
   752 000004DE B84E000000                          mov rax, column_cells
   753 000004E3 4883C002                            add rax, 2
   754 000004E7 49F7E1                              mul r9
   755 000004EA 4C01C0                              add rax, r8
   756 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   757                                  
   758 000004F4 8A07                                mov al, [rdi]
   759 000004F6 3C20                                cmp al, ' '
   760 000004F8 0F843A010000                        je .next_letter
   761 000004FE 3C3D                                cmp al, char_equal
   762 00000500 740A                                je .capture_letter
   763                                  
   764 00000502 8A4302                              mov al, [rbx + 2]
   765 00000505 8807                                mov [rdi], al
   766 00000507 E92C010000                          jmp .next_letter
   767                                  
   768                                          .capture_letter:
   769                                              ; Obtener la nueva letra
   770 0000050C 8A4302                              mov al, [rbx + 2]
   771                                              
   772                                              ; Comparar con la última letra
   773 0000050F 3A05(E5170000)                      cmp al, [last_letter]
   774 00000515 7407                                je .same_letter
   775                                              
   776                                              ; Es una letra diferente, resetear el procesamiento
   777 00000517 C605(F9170000)00                    mov byte [current_power_processed], 0
   778                                              
   779                                              .same_letter:
   780                                              ; Guardar la nueva letra
   781 0000051E 8805(E5170000)                      mov [last_letter], al
   782                                              
   783                                              ; Verificar si es 'E' para extender la paleta
   784 00000524 3C45                                cmp al, 'E'
   785 00000526 7441                                je .extend_pallet
   786                                              
   787                                              ; Verificar si es 'P' para añadir vida
   788 00000528 3C50                                cmp al, 'P'
   789 0000052A 7462                                je .check_add_life
   790                                  
   791 0000052C 3C53                                cmp al, 'S'
   792 0000052E 0F8493000000                        je .slow_ball
   793                                  
   794 00000534 3C43                                cmp al, 'C'
   795 00000536 0F84AD000000                        je .activate_catch
   796                                              
   797 0000053C 3C4C                                cmp al, 'L'
   798 0000053E 0F84C7000000                        je .activate_laser
   799                                  
   800                                              ; Si no es ningún power-up, restaurar tamaño normal
   801 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   802 0000054B 488905(47140000)                    mov [pallet_size], rax
   803 00000552 48C705(FB170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 0000055A 000000             
   804 0000055D C605(13180000)00                    mov byte [catch_power_active], 0
   805 00000564 E9CB000000                          jmp .finish_capture
   806                                  
   807                                              .extend_pallet:
   808 00000569 C605(13180000)00                        mov byte [catch_power_active], 0
   809 00000570 48C705(FB170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   809 00000578 000000             
   810 0000057B 488B05(57140000)                        mov rax, [extended_pallet_size]
   811 00000582 488905(47140000)                        mov [pallet_size], rax
   812 00000589 E9A6000000                              jmp .finish_capture
   813                                  
   814                                              .check_add_life:
   815 0000058E C605(13180000)00                        mov byte [catch_power_active], 0
   816 00000595 488B05(4F140000)                        mov rax, [default_pallet_size]
   817 0000059C 488905(47140000)                        mov [pallet_size], rax
   818 000005A3 48C705(FB170000)01-                     mov qword [ball_speed], 1 
   818 000005AB 000000             
   819                                                  ; Verificar si ya procesamos este power-up
   820 000005AE 803D(F9170000)00                        cmp byte [current_power_processed], 0
   821 000005B5 757D                                    jne .finish_capture
   822                                                  
   823                                                  ; Preservar registros importantes
   824 000005B7 51                                      push rcx
   825 000005B8 53                                      push rbx
   826                                                  
   827                                                  ; Marcar como procesado
   828 000005B9 C605(F9170000)01                        mov byte [current_power_processed], 1
   829                                                  
   830                                                  ; Añadir una vida
   831 000005C0 E872030000                              call add_life
   832                                                  
   833                                                  ; Restaurar registros
   834 000005C5 5B                                      pop rbx
   835 000005C6 59                                      pop rcx
   836                                                  
   837                                              .slow_ball:
   838 000005C7 C605(13180000)00                        mov byte [catch_power_active], 0                
   839 000005CE 488B05(4F140000)                        mov rax, [default_pallet_size]
   840 000005D5 488905(47140000)                        mov [pallet_size], rax
   841 000005DC 48C705(FB170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   841 000005E4 000000             
   842 000005E7 EB4B                                    jmp .finish_capture
   843                                  
   844                                              .activate_catch:
   845 000005E9 488B05(4F140000)                        mov rax, [default_pallet_size]
   846 000005F0 488905(47140000)                        mov [pallet_size], rax
   847 000005F7 48C705(FB170000)01-                     mov qword [ball_speed], 1
   847 000005FF 000000             
   848 00000602 C605(13180000)01                        mov byte [catch_power_active], 1
   849 00000609 EB29                                    jmp .finish_capture
   850                                  
   851                                              .activate_laser:
   852 0000060B C605(13180000)00                        mov byte [catch_power_active], 0
   853 00000612 488B05(4F140000)                        mov rax, [default_pallet_size]
   854 00000619 488905(47140000)                        mov [pallet_size], rax
   855 00000620 48C705(FB170000)01-                     mov qword [ball_speed], 1
   855 00000628 000000             
   856 0000062B C605(1E180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   857 00000632 EB00                                    jmp .finish_capture
   858                                  
   859                                              .finish_capture:
   860 00000634 C6430300                                mov byte [rbx + 3], 0
   861                                  
   862                                          .next_letter:
   863 00000638 48FFC1                              inc rcx
   864 0000063B E949FEFFFF                          jmp .move_loop
   865                                  
   866                                      .print_last_letter:
   867                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000640 B801000000          <1>  mov eax, sys_write
    83 00000645 BF01000000          <1>  mov edi, 1
    84 0000064A 48BE-               <1>  mov rsi, %1
    84 0000064C [E617000000000000]  <1>
    85 00000654 BA10000000          <1>  mov edx, %2
    86 00000659 0F05                <1>  syscall
   868 0000065B 8A05(E5170000)                  mov al, [last_letter]
   869 00000661 8805(F5170000)                  mov [last_letter_msg + 15], al
   870                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [F617000000000000]  <1>
    85 0000067B BA03000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   871                                  
   872                                      .end:
   873 00000682 415B                            pop r11
   874 00000684 415A                            pop r10
   875 00000686 4159                            pop r9
   876 00000688 4158                            pop r8
   877 0000068A 5E                              pop rsi
   878 0000068B 5F                              pop rdi
   879 0000068C 5B                              pop rbx
   880 0000068D 5D                              pop rbp
   881 0000068E C3                              ret
   882                                  
   883                                  
   884                                  
   885                                  ; Nueva función para actualizar los láseres
   886                                  update_lasers:
   887 0000068F 55                          push rbp
   888 00000690 4889E5                      mov rbp, rsp
   889                                      
   890                                      ; Verificar si el poder láser está activo
   891 00000693 803D(1E180000)00            cmp byte [laser_power_active], 0
   892 0000069A 741A                        je .end
   893                                      
   894                                      ; Verificar si se presionó la tecla de espacio
   895 0000069C 803D(1D180000)20            cmp byte [last_key], ' '
   896 000006A3 750C                        jne .skip_shooting
   897                                      
   898                                      ; Disparar nuevos láseres
   899 000006A5 E80E000000                  call shoot_lasers
   900 000006AA C605(1D180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   901                                      
   902                                      .skip_shooting:
   903                                      ; Mover los láseres existentes
   904 000006B1 E89C000000                  call move_lasers
   905                                      
   906                                      .end:
   907 000006B6 5D                              pop rbp
   908 000006B7 C3                              ret
   909                                  
   910                                  shoot_lasers:
   911 000006B8 55                          push rbp
   912 000006B9 4889E5                      mov rbp, rsp
   913 000006BC 53                          push rbx
   914                                      
   915                                      ; Verificar si hay espacio para más láseres
   916 000006BD 480FB605(20180000)          movzx rax, byte [laser_count]
   917 000006C5 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   918 000006C9 0F8D80000000                jge .end
   919                                      
   920                                      ; Obtener posición de la paleta
   921 000006CF 4C8B05(3F140000)            mov r8, [pallet_position]
   922 000006D6 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   923                                      
   924                                      ; Calcular coordenadas x,y
   925 000006DD 4C89C0                      mov rax, r8
   926 000006E0 41B94E000000                mov r9, column_cells
   927 000006E6 4983C102                    add r9, 2                     ; Ancho total de línea
   928 000006EA 4831D2                      xor rdx, rdx
   929 000006ED 49F7F1                      div r9                        ; rax = y, rdx = x
   930                                      
   931                                      ; Guardar coordenadas
   932 000006F0 4989C2                      mov r10, rax                  ; Y en r10
   933 000006F3 4989D3                      mov r11, rdx                  ; X en r11
   934                                      
   935                                      ; Validar coordenadas
   936 000006F6 4983FA00                    cmp r10, 0
   937 000006FA 7C53                        jl .end
   938 000006FC 4983FA20                    cmp r10, row_cells
   939 00000700 7D4D                        jge .end
   940 00000702 4983FB00                    cmp r11, 0
   941 00000706 7C47                        jl .end
   942 00000708 4983FB4E                    cmp r11, column_cells
   943 0000070C 7D41                        jge .end
   944                                      
   945                                      ; Calcular índice para el primer láser
   946 0000070E 480FB61D(20180000)          movzx rbx, byte [laser_count]
   947 00000716 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   948                                      
   949                                      ; Primer láser (izquierda)
   950 0000071A 488DBB[21180000]            lea rdi, [lasers + rbx]
   951 00000721 44881F                      mov [rdi], r11b              ; X
   952 00000724 4488D0                      mov al, r10b
   953 00000727 FEC8                        dec al                       ; Y - 1
   954 00000729 884701                      mov [rdi + 1], al           ; Y
   955                                      
   956                                      ; Segundo láser (derecha)
   957 0000072C 4488D8                      mov al, r11b
   958 0000072F 0205(47140000)              add al, byte [pallet_size]
   959 00000735 FEC8                        dec al                       ; Ajustar para el último carácter
   960 00000737 488DBB[23180000]            lea rdi, [lasers + rbx + 2]
   961 0000073E 8807                        mov [rdi], al               ; X
   962 00000740 4488D0                      mov al, r10b
   963 00000743 FEC8                        dec al                      ; Y - 1
   964 00000745 884701                      mov [rdi + 1], al          ; Y
   965                                      
   966                                      ; Incrementar contador de láseres
   967 00000748 8005(20180000)02            add byte [laser_count], 2
   968                                      
   969                                      
   970                                      .end:
   971 0000074F 5B                              pop rbx
   972 00000750 5D                              pop rbp
   973 00000751 C3                              ret
   974                                  
   975                                  ; Función corregida para mover láseres
   976                                  ; Función corregida para mover láseres
   977                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
   978                                  
   979                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
   980                                  move_lasers:
   981 00000752 55                          push rbp
   982 00000753 4889E5                      mov  rbp, rsp
   983 00000756 53                          push rbx
   984 00000757 57                          push rdi
   985 00000758 56                          push rsi
   986 00000759 4154                        push r12
   987 0000075B 4155                        push r13
   988 0000075D 4156                        push r14
   989 0000075F 4157                        push r15
   990                                  
   991                                      ; 1) Tomamos la cantidad de láseres
   992 00000761 480FB60D(20180000)          movzx rcx, byte [laser_count]
   993 00000769 4885C9                      test rcx, rcx
   994 0000076C 0F849C000000                jz .fin              ; Si es cero, no hay láseres => salir
   995                                  
   996                                      ; Ajustamos para que RCX sea el último índice de láser
   997 00000772 48FFC9                      dec rcx              ; Último índice es (laser_count - 1)
   998                                  
   999                                  .loop_lasers:
  1000                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1001 00000775 488DB409[21180000]          lea rsi, [lasers + rcx*2]
  1002                                  
  1003                                      ; 2) Cargar x,y actuales
  1004 0000077D 4C0FB606                    movzx r8,  byte [rsi]      ; x
  1005 00000781 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; y
  1006                                  
  1007                                      ; 3) Borrar el láser de su posición actual en pantalla
  1008 00000786 B84E000000                  mov rax, column_cells
  1009 0000078B 4883C002                    add rax, 2
  1010 0000078F 49F7E1                      mul r9
  1011 00000792 4C01C0                      add rax, r8
  1012 00000795 488DB8[000A0000]            lea rdi, [board + rax]
  1013 0000079C C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1014                                  
  1015                                      ; 4) Mover el láser hacia arriba (y - 1)
  1016 0000079F 49FFC9                      dec r9
  1017                                  
  1018                                      ; Verificar si ya salió de la pantalla (o si y < 1)
  1019 000007A2 4983F901                    cmp r9, 1
  1020 000007A6 7C38                        jl .delete_laser           ; Si y < 1 => eliminarlo
  1021                                  
  1022                                      ; 5) Si sigue en pantalla => guardar su nueva posición
  1023 000007A8 44884E01                    mov byte [rsi + 1], r9b
  1024                                  
  1025                                      ; 6) Dibujar láser en la nueva posición
  1026 000007AC B84E000000                  mov rax, column_cells
  1027 000007B1 4883C002                    add rax, 2
  1028 000007B5 49F7E1                      mul r9
  1029 000007B8 4C01C0                      add rax, r8
  1030 000007BB 488DB8[000A0000]            lea rdi, [board + rax]
  1031                                      
  1032                                      ; Verificar colisiones antes de dibujar el láser
  1033 000007C2 51                          push rcx
  1034 000007C3 56                          push rsi
  1035 000007C4 57                          push rdi
  1036 000007C5 E851000000                  call check_laser_collisions
  1037 000007CA 5F                          pop rdi
  1038 000007CB 5E                          pop rsi
  1039 000007CC 59                          pop rcx
  1040                                  
  1041                                      ; Si el láser sigue activo (no fue eliminado por colisión), dibujarlo
  1042 000007CD 8A05(1F180000)              mov al, [laser_symbol]
  1043 000007D3 8807                        mov [rdi], al
  1044                                  
  1045                                  .next_laser:
  1046                                      ; 7) Pasamos al láser anterior
  1047 000007D5 48FFC9                      dec rcx
  1048 000007D8 4883F9FF                    cmp rcx, -1
  1049 000007DC 7F97                        jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1050                                  
  1051 000007DE EB2E                        jmp .fin
  1052                                  
  1053                                  .delete_laser:
  1054                                      ; 8) Borrar el láser actual del array
  1055 000007E0 4C0FB625(20180000)          movzx r12, byte [laser_count]
  1056 000007E8 49FFCC                      dec r12                    ; r12 = último índice
  1057 000007EB 4939CC                      cmp r12, rcx
  1058 000007EE 7616                        jbe .just_decrement        ; Si rcx ya apunta al último
  1059                                  
  1060                                      ; Si NO es el último láser => copiamos el último en la posición actual
  1061 000007F0 488DBC09[21180000]          lea rdi, [lasers + rcx*2]
  1062 000007F8 4B8DB424[21180000]          lea rsi, [lasers + r12*2]
  1063 00000800 668B06                      mov ax, [rsi]             ; lee 2 bytes (x,y) del último
  1064 00000803 668907                      mov [rdi], ax             ; copy
  1065                                  
  1066                                  .just_decrement:
  1067 00000806 FE0D(20180000)              dec byte [laser_count]     ; Decrementar el contador total
  1068 0000080C EBC7                        jmp .next_laser
  1069                                  
  1070                                  .fin:
  1071 0000080E 415F                        pop r15
  1072 00000810 415E                        pop r14
  1073 00000812 415D                        pop r13
  1074 00000814 415C                        pop r12
  1075 00000816 5E                          pop rsi
  1076 00000817 5F                          pop rdi
  1077 00000818 5B                          pop rbx
  1078 00000819 5D                          pop rbp
  1079 0000081A C3                          ret
  1080                                  
  1081                                  
  1082                                  ; Nueva función para verificar colisión de láser con bloques y enemigos
  1083                                  check_laser_collisions:
  1084 0000081B 55                          push rbp
  1085 0000081C 4889E5                      mov rbp, rsp
  1086 0000081F 53                          push rbx
  1087 00000820 4154                        push r12
  1088 00000822 4155                        push r13
  1089 00000824 4156                        push r14
  1090 00000826 4157                        push r15
  1091                                  
  1092                                      ; Recorrer todos los láseres activos
  1093 00000828 480FB60D(20180000)          movzx rcx, byte [laser_count]
  1094 00000830 4885C9                      test rcx, rcx
  1095 00000833 7477                        jz .end              ; Si no hay láseres, salir
  1096                                  
  1097 00000835 4D31E4                      xor r12, r12        ; Índice del láser
  1098                                  
  1099                                  .check_laser_loop:
  1100                                      ; Obtener posición del láser actual
  1101 00000838 4B8DB424[21180000]          lea rsi, [lasers + r12*2]    ; Cada láser usa 2 bytes (x,y)
  1102 00000840 4C0FB606                    movzx r8, byte [rsi]         ; X del láser
  1103 00000844 4C0FB64E01                  movzx r9, byte [rsi + 1]     ; Y del láser
  1104                                  
  1105                                      ; Calcular posición en el tablero
  1106 00000849 B84E000000                  mov rax, column_cells
  1107 0000084E 4883C002                    add rax, 2
  1108 00000852 49F7E1                      mul r9
  1109 00000855 4C01C0                      add rax, r8
  1110 00000858 4C8D90[000A0000]            lea r10, [board + rax]       ; r10 = puntero a la posición en el tablero
  1111                                  
  1112                                      ; 1. Verificar colisión con bloques
  1113 0000085F 4150                        push r8
  1114 00000861 4151                        push r9
  1115 00000863 4152                        push r10
  1116 00000865 4154                        push r12
  1117 00000867 51                          push rcx
  1118 00000868 E8130A0000                  call check_block_collision    ; Usar la función existente de colisión de bloques
  1119 0000086D 59                          pop rcx
  1120 0000086E 415C                        pop r12
  1121 00000870 415A                        pop r10
  1122 00000872 4159                        pop r9
  1123 00000874 4158                        pop r8
  1124                                  
  1125 00000876 4885C0                      test rax, rax
  1126 00000879 7407                        jz .check_enemies            ; Si no hay colisión con bloque, verificar enemigos
  1127                                  
  1128                                      ; Si hubo colisión con bloque, eliminar el láser
  1129 0000087B E881000000                  call remove_laser
  1130 00000880 EB21                        jmp .next_laser
  1131                                  
  1132                                  .check_enemies:
  1133                                      ; 2. Verificar colisión con enemigos
  1134 00000882 4150                        push r8
  1135 00000884 4151                        push r9
  1136 00000886 4152                        push r10
  1137 00000888 4154                        push r12
  1138 0000088A 51                          push rcx
  1139 0000088B E827000000                  call check_laser_enemy_collision
  1140 00000890 59                          pop rcx
  1141 00000891 415C                        pop r12
  1142 00000893 415A                        pop r10
  1143 00000895 4159                        pop r9
  1144 00000897 4158                        pop r8
  1145                                  
  1146 00000899 4885C0                      test rax, rax
  1147 0000089C 7405                        jz .next_laser              ; Si no hay colisión con enemigo, continuar
  1148                                  
  1149                                      ; Si hubo colisión con enemigo, eliminar el láser
  1150 0000089E E85E000000                  call remove_laser
  1151                                  
  1152                                  .next_laser:
  1153 000008A3 4983C401                    add r12, 1                  ; Siguiente láser
  1154 000008A7 4939CC                      cmp r12, rcx
  1155 000008AA 7C8C                        jl .check_laser_loop
  1156                                  
  1157                                  .end:
  1158 000008AC 415F                        pop r15
  1159 000008AE 415E                        pop r14
  1160 000008B0 415D                        pop r13
  1161 000008B2 415C                        pop r12
  1162 000008B4 5B                          pop rbx
  1163 000008B5 5D                          pop rbp
  1164 000008B6 C3                          ret
  1165                                  
  1166                                  ; Nueva función para verificar colisión entre láser y enemigos
  1167                                  check_laser_enemy_collision:
  1168 000008B7 55                          push rbp
  1169 000008B8 4889E5                      mov rbp, rsp
  1170                                      
  1171 000008BB 4D31ED                      xor r13, r13                    ; Índice del enemigo
  1172 000008BE 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1173                                      
  1174                                  .check_loop:
  1175 000008C1 4983FD05                    cmp r13, 5                      ; Máximo 5 enemigos
  1176 000008C5 7D38                        jge .end
  1177                                      
  1178                                      ; Calcular offset del enemigo actual
  1179 000008C7 4C89E9                      mov rcx, r13
  1180 000008CA 486BC903                    imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1181 000008CE 488DB1[78150000]            lea rsi, [enemies + rcx]
  1182                                      
  1183                                      ; Verificar si el enemigo está activo
  1184 000008D5 807E0201                    cmp byte [rsi + 2], 1
  1185 000008D9 751F                        jne .next_enemy
  1186                                      
  1187                                      ; Obtener posición del enemigo
  1188 000008DB 4C0FB636                    movzx r14, byte [rsi]           ; X enemigo
  1189 000008DF 4C0FB67E01                  movzx r15, byte [rsi + 1]       ; Y enemigo
  1190                                      
  1191                                      ; Verificar colisión
  1192 000008E4 4D39F0                      cmp r8, r14                     ; Comparar X del láser con X del enemigo
  1193 000008E7 7511                        jne .next_enemy
  1194 000008E9 4D39F9                      cmp r9, r15                     ; Comparar Y del láser con Y del enemigo
  1195 000008EC 750C                        jne .next_enemy
  1196                                      
  1197                                      ; Colisión detectada
  1198 000008EE E8900E0000                  call destroy_enemy              ; Destruir enemigo
  1199 000008F3 B801000000                  mov rax, 1                      ; Indicar colisión
  1200 000008F8 EB05                        jmp .end
  1201                                      
  1202                                  .next_enemy:
  1203 000008FA 49FFC5                      inc r13
  1204 000008FD EBC2                        jmp .check_loop
  1205                                      
  1206                                  .end:
  1207 000008FF 5D                          pop rbp
  1208 00000900 C3                          ret
  1209                                  
  1210                                  ; Función auxiliar para eliminar un láser específico
  1211                                  remove_laser:
  1212 00000901 55                          push rbp
  1213 00000902 4889E5                      mov rbp, rsp
  1214                                  
  1215                                      ; Borrar el láser del tablero
  1216 00000905 41C60220                    mov byte [r10], ' '
  1217                                  
  1218                                      ; Mover el último láser a esta posición si no es el último
  1219 00000909 480FB605(20180000)          movzx rax, byte [laser_count]
  1220 00000911 48FFC8                      dec rax                    ; Índice del último láser
  1221 00000914 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1222 00000917 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1223                                  
  1224                                      ; Copiar último láser a la posición actual
  1225 00000919 4B8DBC24[21180000]          lea rdi, [lasers + r12*2]
  1226 00000921 488DB400[21180000]          lea rsi, [lasers + rax*2]
  1227 00000929 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1228 0000092C 668917                      mov [rdi], dx
  1229                                  
  1230                                  .just_decrease:
  1231 0000092F FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1232                                  
  1233 00000935 5D                          pop rbp
  1234 00000936 C3                          ret
  1235                                  
  1236                                  add_life:
  1237 00000937 55                          push rbp
  1238 00000938 4889E5                      mov rbp, rsp
  1239 0000093B 53                          push rbx
  1240 0000093C 51                          push rcx
  1241 0000093D 57                          push rdi
  1242 0000093E 56                          push rsi
  1243 0000093F 4150                        push r8
  1244 00000941 4151                        push r9
  1245                                      
  1246                                      ; Verificar si ya tenemos el máximo de vidas
  1247 00000943 480FB605(53160000)          movzx rax, byte [current_lives]
  1248 0000094B 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1249 0000094F 7D2C                        jge .end
  1250                                      
  1251                                      ; Incrementar el contador de vidas
  1252 00000951 FE05(53160000)              inc byte [current_lives]
  1253                                      
  1254                                      ; Encontrar la siguiente vida inactiva
  1255 00000957 4831C9                      xor rcx, rcx
  1256                                      
  1257                                      .find_inactive:
  1258 0000095A 4883F907                        cmp rcx, lives_count
  1259 0000095E 7D1D                            jge .end
  1260                                          
  1261                                          ; Calcular offset de la vida actual
  1262 00000960 4889C8                          mov rax, rcx
  1263 00000963 486BC003                        imul rax, 3
  1264 00000967 488DB0[3D160000]                lea rsi, [lives_data + rax]
  1265                                          
  1266                                          ; Verificar si está inactiva
  1267 0000096E 807E0200                        cmp byte [rsi + 2], 0
  1268 00000972 7405                            je .activate_life
  1269                                          
  1270 00000974 48FFC1                          inc rcx
  1271 00000977 EBE1                            jmp .find_inactive
  1272                                          
  1273                                      .activate_life:
  1274                                          ; Activar la vida
  1275 00000979 C6460201                        mov byte [rsi + 2], 1
  1276                                          
  1277                                      .end:
  1278 0000097D 4159                            pop r9
  1279 0000097F 4158                            pop r8
  1280 00000981 5E                              pop rsi
  1281 00000982 5F                              pop rdi
  1282 00000983 59                              pop rcx
  1283 00000984 5B                              pop rbx
  1284 00000985 5D                              pop rbp
  1285 00000986 C3                              ret
  1286                                  
  1287                                  
  1288                                  print_ball:
  1289 00000987 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1290 0000098E 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1291 00000995 4981C0[000A0000]        	add r8, board
  1292                                  
  1293 0000099C 4C89C9                  	mov rcx, r9
  1294 0000099F B850000000              	mov rax, column_cells + 2
  1295 000009A4 48F7E9                  	imul rcx
  1296                                  	
  1297 000009A7 4901C0                  	add r8, rax
  1298 000009AA 41C6004F                	mov byte [r8], char_O
  1299 000009AE C3                      	ret
  1300                                  
  1301                                  	
  1302                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1303                                  	
  1304                                  print_pallet:
  1305                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1306 000009AF 4C8B05(3F140000)            mov r8, [pallet_position]
  1307 000009B6 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1308                                      .clear_pallet:
  1309 000009BD 41C60020                        mov byte [r8], char_space
  1310 000009C1 49FFC0                          inc r8
  1311 000009C4 48FFC9                          dec rcx
  1312 000009C7 75F4                            jnz .clear_pallet
  1313                                  
  1314                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1315 000009C9 4C8B05(3F140000)            mov r8, [pallet_position]
  1316 000009D0 488B0D(47140000)            mov rcx, [pallet_size]
  1317                                      .write_pallet:
  1318 000009D7 41C6003D                        mov byte [r8], char_equal
  1319 000009DB 49FFC0                          inc r8
  1320 000009DE 48FFC9                          dec rcx
  1321 000009E1 75F4                            jnz .write_pallet
  1322                                  
  1323 000009E3 C3                          ret
  1324                                  
  1325                                  move_pallet:
  1326                                      
  1327 000009E4 803D(7F140000)00            cmp byte [ball_moving], 0
  1328 000009EB 7507                        jne .continue_movement
  1329 000009ED C605(7F140000)01            mov byte [ball_moving], 1
  1330                                  
  1331                                      .continue_movement:
  1332 000009F4 4883FFFF                        cmp rdi, left_direction
  1333 000009F8 7531                            jne .move_right
  1334                                  
  1335                                          .move_left:
  1336                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1337 000009FA 4C8B05(3F140000)                    mov r8, [pallet_position]
  1338 00000A01 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1339 00000A04 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1340 00000A07 3C58                                cmp al, 'X'        ; Comparar si es una X
  1341 00000A09 744E                                je .end            ; Si es X, no mover
  1342                                              
  1343 00000A0B 4C8B05(3F140000)                    mov r8, [pallet_position]
  1344 00000A12 4C8B0D(47140000)                    mov r9, [pallet_size]
  1345 00000A19 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1346 00000A1F 49FFC8                              dec r8
  1347 00000A22 4C8905(3F140000)                    mov [pallet_position], r8
  1348 00000A29 EB2E                                jmp .end
  1349                                              
  1350                                          .move_right:
  1351                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1352 00000A2B 4C8B05(3F140000)                    mov r8, [pallet_position]
  1353 00000A32 4C8B0D(47140000)                    mov r9, [pallet_size]
  1354 00000A39 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1355 00000A3C 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1356 00000A40 3C58                                cmp al, 'X'        ; Comparar si es una X
  1357 00000A42 7415                                je .end            ; Si es X, no mover
  1358                                              
  1359 00000A44 4C8B05(3F140000)                    mov r8, [pallet_position]
  1360 00000A4B 41C60020                            mov byte [r8], char_space
  1361 00000A4F 49FFC0                              inc r8
  1362 00000A52 4C8905(3F140000)                    mov [pallet_position], r8
  1363                                          .end:
  1364 00000A59 C3                                  ret
  1365                                  
  1366                                  
  1367                                  
  1368                                              
  1369                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1370                                  update_caught_ball_position:
  1371 00000A5A 55                          push rbp
  1372 00000A5B 4889E5                      mov rbp, rsp
  1373                                      
  1374                                      ; Calcular la nueva posición de la bola basada en la paleta
  1375 00000A5E 4C8B05(3F140000)            mov r8, [pallet_position]
  1376 00000A65 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1377 00000A6C B850000000                  mov rax, column_cells + 2
  1378 00000A71 4831D2                      xor rdx, rdx
  1379 00000A74 48F7F0                      div rax                ; División para obtener X,Y
  1380                                      
  1381                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1382 00000A77 4989C1                      mov r9, rax            ; Y de la paleta
  1383 00000A7A 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1384                                      
  1385                                      ; Añadir el offset guardado a la posición X
  1386 00000A7D 4889D0                      mov rax, rdx
  1387 00000A80 480305(15180000)            add rax, [ball_catch_offset]
  1388 00000A87 488905(5F140000)            mov [ball_x_pos], rax
  1389 00000A8E 4C890D(67140000)            mov [ball_y_pos], r9
  1390                                      
  1391 00000A95 5D                          pop rbp
  1392 00000A96 C3                          ret
  1393                                  move_ball:
  1394                                  
  1395 00000A97 803D(14180000)01            cmp byte [ball_caught], 1
  1396 00000A9E 0F849D000000                je .move_with_pallet
  1397                                  
  1398 00000AA4 803D(7F140000)00            cmp byte [ball_moving], 0
  1399 00000AAB 0F84B8010000                je .end
  1400                                  
  1401                                      ; Incrementar contador de velocidad
  1402 00000AB1 48FF05(0B180000)            inc qword [speed_counter]
  1403                                      
  1404                                      ; Verificar si debemos mover la bola en este ciclo
  1405 00000AB8 488B05(0B180000)            mov rax, [speed_counter]
  1406 00000ABF 483B05(FB170000)            cmp rax, [ball_speed]
  1407 00000AC6 0F8C9D010000                jl .end
  1408                                      
  1409                                      ; Resetear contador de velocidad
  1410 00000ACC 48C705(0B180000)00-         mov qword [speed_counter], 0
  1410 00000AD4 000000             
  1411                                  
  1412                                      ; Borrar la posición actual de la bola
  1413 00000AD7 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1414 00000ADE 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1415 00000AE5 4981C0[000A0000]            add r8, board
  1416 00000AEC 4C89C9                      mov rcx, r9
  1417 00000AEF B850000000                  mov rax, column_cells + 2
  1418 00000AF4 48F7E9                      imul rcx
  1419 00000AF7 4901C0                      add r8, rax
  1420 00000AFA 41C60020                    mov byte [r8], char_space
  1421                                  
  1422                                      ; Calcular siguiente posición X
  1423 00000AFE 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1424 00000B05 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1425 00000B0C 488B05(6F140000)            mov rax, [ball_direction_x]
  1426 00000B13 4901C0                      add r8, rax               ; Nueva posición X
  1427                                  
  1428                                      ; Calcular la dirección de memoria para la siguiente posición
  1429 00000B16 4D89C2                      mov r10, r8
  1430 00000B19 4981C2[000A0000]            add r10, board
  1431 00000B20 4C89C9                      mov rcx, r9
  1432 00000B23 B850000000                  mov rax, column_cells + 2
  1433 00000B28 48F7E9                      imul rcx
  1434 00000B2B 4901C2                      add r10, rax
  1435                                  
  1436                                      ; Verificar si hay una X en la siguiente posición X
  1437 00000B2E 418A02                      mov al, [r10]
  1438 00000B31 3C58                        cmp al, 'X'
  1439 00000B33 7565                        jne .check_block_x
  1440 00000B35 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1441 00000B3C E928010000                  jmp .end
  1442                                  
  1443                                      .move_with_pallet:
  1444                                          ; Borrar la posición actual de la bola
  1445 00000B41 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1446 00000B48 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1447 00000B4F 4D89C2                          mov r10, r8
  1448 00000B52 4981C2[000A0000]                add r10, board
  1449 00000B59 4C89C9                          mov rcx, r9
  1450 00000B5C B850000000                      mov rax, column_cells + 2
  1451 00000B61 48F7E9                          imul rcx
  1452 00000B64 4901C2                          add r10, rax
  1453 00000B67 41C60220                        mov byte [r10], char_space
  1454                                  
  1455                                          ; Actualizar posición X basada en la paleta
  1456 00000B6B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1457 00000B72 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1458 00000B79 4C0305(15180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1459 00000B80 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1460                                  
  1461                                          ; Mantener la bola una posición arriba de la paleta
  1462 00000B87 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1463 00000B8E 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1464                                  
  1465 00000B95 E9CF000000                      jmp .end
  1466                                  
  1467                                  
  1468                                      .check_block_x:
  1469                                          ; Verificar colisión con bloques en X
  1470 00000B9A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1471 00000B9C 4151                            push r9
  1472 00000B9E 4152                            push r10
  1473 00000BA0 E8DB060000                      call check_block_collision
  1474 00000BA5 415A                            pop r10
  1475 00000BA7 4159                            pop r9
  1476 00000BA9 4158                            pop r8
  1477 00000BAB 4885C0                          test rax, rax
  1478 00000BAE 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1479 00000BB0 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1480 00000BB7 E9AD000000                      jmp .end
  1481                                  
  1482                                      .check_paddle_x:
  1483                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1484 00000BBC 41803A3D                        cmp byte [r10], char_equal
  1485 00000BC0 750C                            jne .check_y_movement
  1486 00000BC2 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1487 00000BC9 E99B000000                      jmp .end
  1488                                  
  1489                                      .check_y_movement:
  1490                                          ; Calcular siguiente posición Y
  1491 00000BCE 488B05(77140000)                mov rax, [ball_direction_y]
  1492 00000BD5 4901C1                          add r9, rax                  ; Nueva posición Y
  1493                                  
  1494                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1495 00000BD8 4D89C2                          mov r10, r8
  1496 00000BDB 4981C2[000A0000]                add r10, board
  1497 00000BE2 4C89C9                          mov rcx, r9
  1498 00000BE5 B850000000                      mov rax, column_cells + 2
  1499 00000BEA 48F7E9                          imul rcx
  1500 00000BED 4901C2                          add r10, rax
  1501                                  
  1502                                          ; Verificar si hay una X en la siguiente posición Y
  1503 00000BF0 418A02                          mov al, [r10]
  1504 00000BF3 3C58                            cmp al, 'X'
  1505 00000BF5 7509                            jne .check_block_y
  1506 00000BF7 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1507 00000BFE EB69                            jmp .end
  1508                                  
  1509                                      .check_block_y:
  1510                                          ; Verificar colisión con bloques en Y
  1511 00000C00 4150                            push r8     ; Guardar registros que usa check_block_collision
  1512 00000C02 4151                            push r9
  1513 00000C04 4152                            push r10
  1514 00000C06 E875060000                      call check_block_collision
  1515 00000C0B 415A                            pop r10
  1516 00000C0D 4159                            pop r9
  1517 00000C0F 4158                            pop r8
  1518 00000C11 4885C0                          test rax, rax
  1519 00000C14 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1520 00000C16 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1521 00000C1D EB4A                            jmp .end
  1522                                  
  1523                                      .check_paddle_y:
  1524                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1525 00000C1F 41803A3D                        cmp byte [r10], char_equal
  1526 00000C23 7536                            jne .update_position
  1527                                  
  1528                                          ; Verificar si el poder catch está activo
  1529 00000C25 803D(13180000)01                cmp byte [catch_power_active], 1
  1530 00000C2C 7524                            jne .normal_bounce
  1531                                  
  1532                                          ; Activar el modo "atrapado"
  1533 00000C2E C605(14180000)01                mov byte [ball_caught], 1
  1534                                          
  1535                                          ; Guardar la posición X actual de la bola como offset
  1536 00000C35 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1537 00000C3C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1538 00000C43 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1539 00000C49 488905(15180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1540                                          
  1541 00000C50 EB17                            jmp .end
  1542                                  
  1543                                      .normal_bounce:
  1544 00000C52 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1545 00000C59 EB0E                            jmp .end
  1546                                  
  1547                                  
  1548                                      .update_position:
  1549 00000C5B 4C8905(5F140000)                mov [ball_x_pos], r8
  1550 00000C62 4C890D(67140000)                mov [ball_y_pos], r9
  1551                                  
  1552                                      .end:
  1553 00000C69 C3                              ret
  1554                                  
  1555                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1556                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1557                                  process_catch_release:
  1558 00000C6A 55                          push rbp
  1559 00000C6B 4889E5                      mov rbp, rsp
  1560                                  
  1561                                      ; Verificar si la bola está atrapada
  1562 00000C6E 803D(14180000)00            cmp byte [ball_caught], 0
  1563 00000C75 7436                        je .end
  1564                                  
  1565                                      ; Verificar si el poder catch está activo
  1566 00000C77 803D(13180000)01            cmp byte [catch_power_active], 1
  1567 00000C7E 752D                        jne .end
  1568                                  
  1569                                      ; Verificar si se presionó la tecla 'c'
  1570 00000C80 803D(1D180000)63            cmp byte [last_key], 'c'
  1571 00000C87 7524                        jne .end
  1572                                  
  1573                                      ; Liberar la bola y asignar dirección inicial
  1574 00000C89 C605(14180000)00            mov byte [ball_caught], 0
  1575 00000C90 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1575 00000C98 000000             
  1576 00000C9B 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1576 00000CA3 FFFFFF             
  1577                                  
  1578                                      ; Limpiar la tecla procesada
  1579 00000CA6 C605(1D180000)00            mov byte [last_key], 0
  1580                                  
  1581                                      .end:
  1582 00000CAD 5D                              pop rbp
  1583 00000CAE C3                              ret
  1584                                  
  1585                                  
  1586                                  display_level_number:
  1587 00000CAF 55                          push rbp
  1588 00000CB0 4889E5                      mov rbp, rsp
  1589                                      
  1590                                      ; Limpiar la pantalla primero
  1591                                      print clear, clear_length
    82 00000CB3 B801000000          <1>  mov eax, sys_write
    83 00000CB8 BF01000000          <1>  mov edi, 1
    84 00000CBD 48BE-               <1>  mov rsi, %1
    84 00000CBF [1000000000000000]  <1>
    85 00000CC7 BA07000000          <1>  mov edx, %2
    86 00000CCC 0F05                <1>  syscall
  1592                                      
  1593                                      ; Calcular la posición central para el mensaje
  1594                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1595 00000CCE B84E000000                  mov rax, column_cells
  1596 00000CD3 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1597 00000CD7 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1598                                      
  1599                                      ; Calcular la fila central
  1600 00000CDA BB20000000                  mov rbx, row_cells
  1601 00000CDF 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1602                                      
  1603                                      ; Calcular el offset en el buffer
  1604 00000CE2 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1605 00000CE7 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1606 00000CEA 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1607                                      
  1608                                      ; Escribir "NIVEL " en la posición calculada
  1609 00000CED 488DB8[000A0000]            lea rdi, [board + rax]
  1610 00000CF4 48BE-                       mov rsi, level_msg
  1610 00000CF6 [2414000000000000] 
  1611 00000CFE B906000000                  mov rcx, level_msg_len
  1612 00000D03 F3A4                        rep movsb
  1613                                      
  1614                                      ; Escribir el número del nivel
  1615 00000D05 8A05(B4140000)              mov al, [current_level]
  1616 00000D0B 0430                        add al, '0'                 ; convertir a ASCII
  1617 00000D0D 8807                        mov [rdi], al
  1618                                      
  1619                                      ; Mostrar el board con el mensaje
  1620                                      print board, board_size
    82 00000D0F B801000000          <1>  mov eax, sys_write
    83 00000D14 BF01000000          <1>  mov edi, 1
    84 00000D19 48BE-               <1>  mov rsi, %1
    84 00000D1B [000A000000000000]  <1>
    85 00000D23 BA000A0000          <1>  mov edx, %2
    86 00000D28 0F05                <1>  syscall
  1621                                      
  1622                                      ; Esperar un segundo
  1623 00000D2A B823000000                  mov rax, sys_nanosleep
  1624 00000D2F 48BF-                       mov rdi, level_display_time
  1624 00000D31 [2F14000000000000] 
  1625 00000D39 4831F6                      xor rsi, rsi
  1626 00000D3C 0F05                        syscall
  1627                                      
  1628 00000D3E 5D                          pop rbp
  1629 00000D3F C3                          ret
  1630                                  
  1631                                  ; Función para inicializar un tablero vacío
  1632                                  init_empty_board:
  1633 00000D40 56                          push rsi
  1634 00000D41 57                          push rdi
  1635 00000D42 51                          push rcx
  1636 00000D43 50                          push rax
  1637                                  
  1638 00000D44 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1639 00000D4B 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1640 00000D52 B9000A0000                  mov rcx, board_template_size
  1641 00000D57 F3A4                        rep movsb                   ; Copiar el tablero
  1642                                  
  1643 00000D59 58                          pop rax
  1644 00000D5A 59                          pop rcx
  1645 00000D5B 5F                          pop rdi
  1646 00000D5C 5E                          pop rsi
  1647 00000D5D C3                          ret
  1648                                  
  1649                                  
  1650                                  init_level:
  1651                                  
  1652 00000D5E 488B05(4F140000)            mov rax, [default_pallet_size]
  1653 00000D65 488905(47140000)            mov [pallet_size], rax
  1654 00000D6C 48C705(FB170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1654 00000D74 000000             
  1655                                  
  1656                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1657                                          ; Reiniciar letras activas
  1658 00000D77 488D3D(54160000)            lea rdi, [letters_map]
  1659 00000D7E B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1660 00000D83 4831C0                      xor rax, rax
  1661 00000D86 F3AA                        rep stosb                    ; Llenar con ceros
  1662                                      
  1663                                      ; Inicializar dirección de la bola (derecha y arriba)
  1664 00000D88 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1664 00000D90 000000             
  1665 00000D93 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1665 00000D9B FFFFFF             
  1666                                  
  1667                                  
  1668                                      ; Reiniciar contador de letras activas
  1669 00000D9E 4831C0                      xor rax, rax
  1670 00000DA1 8805(E4170000)              mov [letters_count], al
  1671                                  
  1672                                      ; Reiniciar última letra capturada
  1673 00000DA7 C605(E5170000)20            mov byte [last_letter], ' '
  1674 00000DAE C605(5E150000)00            mov byte [destroyed_blocks], 0 
  1675 00000DB5 E886FFFFFF                  call init_empty_board
  1676 00000DBA E8F0FEFFFF                  call display_level_number
  1677 00000DBF E8E5050000                  call init_enemies
  1678                                      
  1679 00000DC4 56                          push rsi
  1680 00000DC5 57                          push rdi
  1681 00000DC6 51                          push rcx
  1682 00000DC7 50                          push rax
  1683                                  
  1684 00000DC8 488D35(00000000)            lea rsi, [board_template]
  1685 00000DCF 488D3D(000A0000)            lea rdi, [board]
  1686 00000DD6 B9000A0000                  mov rcx, board_template_size
  1687 00000DDB F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1688                                  
  1689 00000DDD 58                          pop rax
  1690 00000DDE 59                          pop rcx
  1691 00000DDF 5F                          pop rdi
  1692 00000DE0 5E                          pop rsi
  1693                                  
  1694 00000DE1 B90A000000                  mov rcx, 10
  1695 00000DE6 4831C0                      xor rax, rax
  1696 00000DE9 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  1697 00000DF0 F3AA                        rep stosb      
  1698                                  
  1699                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1700 00000DF2 803D(B4140000)01            cmp byte [current_level], 1
  1701 00000DF9 7431                        je .level1
  1702 00000DFB 803D(B4140000)02            cmp byte [current_level], 2
  1703 00000E02 7454                        je .level2
  1704 00000E04 803D(B4140000)03            cmp byte [current_level], 3
  1705 00000E0B 7477                        je .level3
  1706 00000E0D 803D(B4140000)04            cmp byte [current_level], 4
  1707 00000E14 0F8492000000                je .level4
  1708 00000E1A 803D(B4140000)05            cmp byte [current_level], 5
  1709 00000E21 0F84AD000000                je .level5
  1710 00000E27 E9D0000000                  jmp .done
  1711                                  
  1712                                  
  1713                                  
  1714                                      .level1:
  1715 00000E2C C605(B5140000)08                mov byte [blocks_remaining], level1_blocks_count
  1716 00000E33 4831C9                          xor rcx, rcx             
  1717                                          .init_loop1:
  1718 00000E36 4883F908                            cmp rcx, level1_blocks_count
  1719 00000E3A 0F8DBC000000                        jge .done
  1720 00000E40 4889C8                              mov rax, rcx         
  1721 00000E43 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1722 00000E47 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1723 00000E4D 8891[F2140000]                      mov byte [block_states + rcx], dl
  1724 00000E53 48FFC1                              inc rcx
  1725 00000E56 EBDE                                jmp .init_loop1
  1726                                  
  1727                                      .level2:
  1728 00000E58 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1729 00000E5F 4831C9                          xor rcx, rcx             
  1730                                          .init_loop2:
  1731 00000E62 4883F901                            cmp rcx, level2_blocks_count
  1732 00000E66 0F8D90000000                        jge .done
  1733 00000E6C 4889C8                              mov rax, rcx         
  1734 00000E6F 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1735 00000E73 8A90[E1140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1736 00000E79 8891[F2140000]                      mov byte [block_states + rcx], dl
  1737 00000E7F 48FFC1                              inc rcx
  1738 00000E82 EBDE                                jmp .init_loop2
  1739                                      .level3:
  1740 00000E84 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1741 00000E8B 4831C9                          xor rcx, rcx             
  1742                                          .init_loop3:
  1743 00000E8E 4883F901                            cmp rcx, level3_blocks_count
  1744 00000E92 7D68                                jge .done
  1745 00000E94 4889C8                              mov rax, rcx         
  1746 00000E97 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1747 00000E9B 8A90[E6140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1748 00000EA1 8891[F2140000]                      mov byte [block_states + rcx], dl
  1749 00000EA7 48FFC1                              inc rcx
  1750 00000EAA EBE2                                jmp .init_loop3
  1751                                  
  1752                                      .level4:
  1753 00000EAC C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1754 00000EB3 4831C9                          xor rcx, rcx             
  1755                                          .init_loop4:
  1756 00000EB6 4883F901                            cmp rcx, level4_blocks_count
  1757 00000EBA 7D40                                jge .done
  1758 00000EBC 4889C8                              mov rax, rcx         
  1759 00000EBF 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1760 00000EC3 8A90[EB140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1761 00000EC9 8891[F2140000]                      mov byte [block_states + rcx], dl
  1762 00000ECF 48FFC1                              inc rcx
  1763 00000ED2 EBE2                                jmp .init_loop4
  1764                                  
  1765                                      .level5:
  1766 00000ED4 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1767 00000EDB 4831C9                          xor rcx, rcx             
  1768                                          .init_loop5:
  1769 00000EDE 4883F901                            cmp rcx, level5_blocks_count
  1770 00000EE2 7D18                                jge .done
  1771 00000EE4 4889C8                              mov rax, rcx         
  1772 00000EE7 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1773 00000EEB 8A90[F0140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1774 00000EF1 8891[F2140000]                      mov byte [block_states + rcx], dl
  1775 00000EF7 48FFC1                              inc rcx
  1776 00000EFA EBE2                                jmp .init_loop5
  1777                                      .done:
  1778 00000EFC C3                              ret
  1779                                  
  1780                                  
  1781                                  ; Función para verificar y manejar la transición de nivel
  1782                                  check_level_complete:
  1783                                      ; Verificar si quedan bloques
  1784 00000EFD 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1785 00000F04 753C                        jne .not_complete
  1786                                      
  1787                                      ; Incrementar el nivel
  1788 00000F06 FE05(B4140000)              inc byte [current_level]
  1789                                      
  1790                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1791 00000F0C 803D(B4140000)06            cmp byte [current_level], 6
  1792 00000F13 742E                        je game_win
  1793                                      
  1794                                      ; Reinicializar el juego para el siguiente nivel
  1795 00000F15 E844FEFFFF                  call init_level
  1796                                      
  1797                                      ; Reinicializar la posición de la bola y la paleta
  1798 00000F1A 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1798 00000F22 000000             
  1799 00000F25 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1799 00000F2D 000000             
  1800 00000F30 C605(7F140000)00            mov byte [ball_moving], 0
  1801 00000F37 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1801 00000F3E [36130000]         
  1802                                      
  1803                                      .not_complete:
  1804 00000F42 C3                              ret
  1805                                  
  1806                                      ; Nueva función para manejar la victoria del juego
  1807                                  game_win:
  1808                                      ; Limpiar la pantalla primero
  1809                                      print clear, clear_length
    82 00000F43 B801000000          <1>  mov eax, sys_write
    83 00000F48 BF01000000          <1>  mov edi, 1
    84 00000F4D 48BE-               <1>  mov rsi, %1
    84 00000F4F [1000000000000000]  <1>
    85 00000F57 BA07000000          <1>  mov edx, %2
    86 00000F5C 0F05                <1>  syscall
  1810                                      
  1811                                      ; Mensaje de victoria
  1812 00000F5E 488B05(56150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1813 00000F65 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1813 00000F67 [5F15000000000000] 
  1814 00000F6F E8B4010000                  call number_to_string
  1815                                      
  1816                                      ; Definir mensaje de victoria
  1817                                      section .data
  1818 00001901 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1818 0000190A 616465732120C2A148-
  1818 00001913 61732067616E61646F-
  1818 0000191C 210A0D             
  1819                                          win_msg_len: equ $ - win_msg
  1820 0000191F 50756E74616A652066-             score_msg: db "Puntaje final: "
  1820 00001928 696E616C3A20       
  1821                                          score_msg_len: equ $ - score_msg
  1822                                      section .text
  1823                                      
  1824                                      ; Imprimir mensajes
  1825                                      print win_msg, win_msg_len
    82 00000F74 B801000000          <1>  mov eax, sys_write
    83 00000F79 BF01000000          <1>  mov edi, 1
    84 00000F7E 48BE-               <1>  mov rsi, %1
    84 00000F80 [0119000000000000]  <1>
    85 00000F88 BA1E000000          <1>  mov edx, %2
    86 00000F8D 0F05                <1>  syscall
  1826                                      print score_msg, score_msg_len
    82 00000F8F B801000000          <1>  mov eax, sys_write
    83 00000F94 BF01000000          <1>  mov edi, 1
    84 00000F99 48BE-               <1>  mov rsi, %1
    84 00000F9B [1F19000000000000]  <1>
    85 00000FA3 BA0F000000          <1>  mov edx, %2
    86 00000FA8 0F05                <1>  syscall
  1827                                      print number_buffer, 20
    82 00000FAA B801000000          <1>  mov eax, sys_write
    83 00000FAF BF01000000          <1>  mov edi, 1
    84 00000FB4 48BE-               <1>  mov rsi, %1
    84 00000FB6 [5F15000000000000]  <1>
    85 00000FBE BA14000000          <1>  mov edx, %2
    86 00000FC3 0F05                <1>  syscall
  1828                                      
  1829                                      ; Esperar un momento antes de salir
  1830 00000FC5 48C70530F0FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1830 00000FCE 0000               
  1831 00000FD0 48C7052DF0FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1831 00000FD9 0000               
  1832                                      sleeptime
    98 00000FDB B823000000          <1>  mov eax, sys_nanosleep
    99 00000FE0 48BF-               <1>  mov rdi, timespec
    99 00000FE2 [0000000000000000]  <1>
   100 00000FEA 31F6                <1>  xor esi, esi
   101 00000FEC 0F05                <1>  syscall
  1833                                      
  1834 00000FEE E929090000                  jmp exit
  1835                                  
  1836                                  ; Función para imprimir los bloques
  1837                                  ; Función modificada para imprimir bloques
  1838                                  
  1839                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1840                                  get_current_level_blocks:
  1841 00000FF3 803D(B4140000)01            cmp byte [current_level], 1
  1842 00000FFA 7428                        je .level1
  1843 00000FFC 803D(B4140000)02            cmp byte [current_level], 2
  1844 00001003 7427                        je .level2
  1845 00001005 803D(B4140000)03            cmp byte [current_level], 3
  1846 0000100C 7426                        je .level3
  1847 0000100E 803D(B4140000)04            cmp byte [current_level], 4
  1848 00001015 7425                        je .level4
  1849 00001017 803D(B4140000)05            cmp byte [current_level], 5
  1850 0000101E 7424                        je .level5
  1851                                      ; Si llegamos aquí, hay un error en el nivel
  1852 00001020 4831C0                      xor rax, rax
  1853 00001023 C3                          ret
  1854                                  
  1855                                      .level1:
  1856 00001024 488D05(B6140000)                lea rax, [level1_blocks]
  1857 0000102B C3                              ret
  1858                                      .level2:
  1859 0000102C 488D05(DE140000)                lea rax, [level2_blocks]
  1860 00001033 C3                              ret
  1861                                      .level3:
  1862 00001034 488D05(E3140000)                lea rax, [level3_blocks]
  1863 0000103B C3                              ret
  1864                                      .level4:
  1865 0000103C 488D05(E8140000)                lea rax, [level4_blocks]
  1866 00001043 C3                              ret
  1867                                      .level5:
  1868 00001044 488D05(ED140000)                lea rax, [level5_blocks]
  1869 0000104B C3                              ret
  1870                                  ; Función para obtener la cantidad de bloques del nivel actual
  1871                                  get_current_level_count:
  1872 0000104C 803D(B4140000)01            cmp byte [current_level], 1
  1873 00001053 7428                        je .level1
  1874 00001055 803D(B4140000)02            cmp byte [current_level], 2
  1875 0000105C 7425                        je .level2
  1876 0000105E 803D(B4140000)03            cmp byte [current_level], 3
  1877 00001065 7422                        je .level3
  1878 00001067 803D(B4140000)04            cmp byte [current_level], 4
  1879 0000106E 741F                        je .level4
  1880 00001070 803D(B4140000)05            cmp byte [current_level], 5
  1881 00001077 741C                        je .level5
  1882                                      ; Si llegamos aquí, hay un error en el nivel
  1883 00001079 4831C0                      xor rax, rax
  1884 0000107C C3                          ret
  1885                                  
  1886                                      .level1:
  1887 0000107D B808000000                      mov rax, level1_blocks_count
  1888 00001082 C3                              ret
  1889                                      .level2:
  1890 00001083 B801000000                      mov rax, level2_blocks_count
  1891 00001088 C3                              ret
  1892                                      .level3:
  1893 00001089 B801000000                      mov rax, level3_blocks_count
  1894 0000108E C3                              ret
  1895                                      .level4:
  1896 0000108F B801000000                      mov rax, level4_blocks_count
  1897 00001094 C3                              ret
  1898                                      .level5:
  1899 00001095 B801000000                      mov rax, level5_blocks_count
  1900 0000109A C3                              ret
  1901                                  
  1902                                  
  1903                                  print_blocks:
  1904 0000109B 55                          push rbp
  1905 0000109C 4889E5                      mov rbp, rsp
  1906                                      
  1907                                      ; Obtener puntero a los bloques del nivel actual
  1908 0000109F E84FFFFFFF                  call get_current_level_blocks
  1909 000010A4 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1910                                      
  1911                                      ; Obtener cantidad de bloques del nivel actual
  1912 000010A7 E8A0FFFFFF                  call get_current_level_count
  1913 000010AC 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1914                                      
  1915 000010AF 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1916                                      
  1917                                      .print_loop:
  1918 000010B2 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1919 000010B5 7D6F                            jge .end
  1920                                          
  1921                                          ; Verificar si el bloque está activo
  1922 000010B7 490FB68424-                     movzx rax, byte [block_states + r12]
  1922 000010BC [F2140000]         
  1923 000010C0 4885C0                          test rax, rax
  1924 000010C3 745C                            jz .next_block
  1925                                          
  1926                                          ; Obtener posición y tipo del bloque usando r13
  1927 000010C5 4C89E0                          mov rax, r12
  1928 000010C8 486BC005                        imul rax, 5
  1929 000010CC 4C01E8                          add rax, r13
  1930 000010CF 448A00                          mov r8b, [rax]        ; X position
  1931 000010D2 448A4801                        mov r9b, [rax + 1]    ; Y position
  1932 000010D6 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1933                                  
  1934                                          ; El resto de la lógica de impresión permanece igual
  1935 000010DA 4D0FB6C0                        movzx r8, r8b
  1936 000010DE 4D0FB6C9                        movzx r9, r9b
  1937 000010E2 4981C0[000A0000]                add r8, board
  1938 000010E9 B850000000                      mov rax, column_cells + 2
  1939 000010EE 49F7E1                          mul r9
  1940 000010F1 4901C0                          add r8, rax
  1941                                          
  1942 000010F4 B906000000                      mov rcx, block_length
  1943 000010F9 48BE-                           mov rsi, block_type_1
  1943 000010FB [9014000000000000] 
  1944 00001103 490FB6C2                        movzx rax, r10b
  1945 00001107 48FFC8                          dec rax
  1946 0000110A 486BC006                        imul rax, block_length
  1947 0000110E 4801C6                          add rsi, rax
  1948                                          
  1949                                      .print_block_chars:
  1950 00001111 8A06                            mov al, [rsi]
  1951 00001113 418800                          mov [r8], al
  1952 00001116 48FFC6                          inc rsi
  1953 00001119 49FFC0                          inc r8
  1954 0000111C 48FFC9                          dec rcx
  1955 0000111F 75F0                            jnz .print_block_chars
  1956                                          
  1957                                      .next_block:
  1958 00001121 49FFC4                          inc r12
  1959 00001124 EB8C                            jmp .print_loop
  1960                                          
  1961                                      .end:
  1962 00001126 5D                              pop rbp
  1963 00001127 C3                              ret
  1964                                  
  1965                                  ; Función para convertir número a string
  1966                                  ; Input: RAX = número a convertir
  1967                                  ; RDI = buffer donde escribir el string
  1968                                  number_to_string:
  1969 00001128 53                          push rbx
  1970 00001129 52                          push rdx
  1971 0000112A 56                          push rsi
  1972 0000112B BB0A000000                  mov rbx, 10          ; Divisor
  1973 00001130 B900000000                  mov rcx, 0          ; Contador de dígitos
  1974                                      
  1975                                      ; Si el número es 0, manejarlo especialmente
  1976 00001135 4885C0                      test rax, rax
  1977 00001138 7509                        jnz .convert_loop
  1978 0000113A C60730                      mov byte [rdi], '0'
  1979 0000113D C6470100                    mov byte [rdi + 1], 0
  1980 00001141 EB20                        jmp .end
  1981                                      
  1982                                      .convert_loop:
  1983 00001143 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1984 00001146 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1985 00001149 80C230                          add dl, '0'     ; Convertir a ASCII
  1986 0000114C 52                              push rdx        ; Guardar el dígito
  1987 0000114D 48FFC1                          inc rcx         ; Incrementar contador
  1988 00001150 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1989 00001153 75EE                            jnz .convert_loop
  1990                                          
  1991                                      .write_loop:
  1992 00001155 5A                              pop rdx         ; Obtener dígito
  1993 00001156 8817                            mov [rdi], dl   ; Escribir al buffer
  1994 00001158 48FFC7                          inc rdi         ; Siguiente posición
  1995 0000115B 48FFC9                          dec rcx         ; Decrementar contador
  1996 0000115E 75F5                            jnz .write_loop
  1997                                          
  1998 00001160 C60700                      mov byte [rdi], 0   ; Null terminator
  1999                                      
  2000                                      .end:
  2001 00001163 5E                          pop rsi
  2002 00001164 5A                          pop rdx
  2003 00001165 5B                          pop rbx
  2004 00001166 C3                          ret
  2005                                  
  2006                                  ; Función para imprimir los labels
  2007                                  print_labels:
  2008 00001167 55                          push rbp
  2009 00001168 4889E5                      mov rbp, rsp
  2010                                  
  2011                                      ; Crear buffer temporal
  2012 0000116B 4883EC20                    sub rsp, 32
  2013                                  
  2014                                      ; Copiar labels a buffer temporal
  2015 0000116F 4889E7                      mov rdi, rsp
  2016 00001172 488D35(0B160000)            lea rsi, [score_label]
  2017 00001179 B917000000                  mov rcx, score_label_len
  2018 0000117E F3A4                        rep movsb
  2019                                  
  2020                                      ; Convertir score a string
  2021 00001180 488B05(56150000)            mov rax, [current_score]
  2022 00001187 48BF-                       mov rdi, number_buffer
  2022 00001189 [5F15000000000000] 
  2023 00001191 E892FFFFFF                  call number_to_string
  2024                                  
  2025                                      ; Calcular longitud del número
  2026 00001196 B900000000                  mov rcx, 0
  2027 0000119B 48BF-                       mov rdi, number_buffer
  2027 0000119D [5F15000000000000] 
  2028                                      .count_loop:
  2029 000011A5 803C0F00                        cmp byte [rdi + rcx], 0
  2030 000011A9 7405                            je .count_done
  2031 000011AB 48FFC1                          inc rcx
  2032 000011AE EBF5                            jmp .count_loop
  2033                                      .count_done:
  2034                                  
  2035                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2036 000011B0 4889E7                      mov rdi, rsp
  2037 000011B3 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2038 000011B7 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2039 000011BC 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2040                                      .pad_loop:
  2041 000011BF 4885F6                          test rsi, rsi
  2042 000011C2 740B                            jz .pad_done
  2043 000011C4 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2044 000011C7 48FFC7                          inc rdi
  2045 000011CA 48FFCE                          dec rsi
  2046 000011CD EBF0                            jmp .pad_loop
  2047                                      .pad_done:
  2048                                  
  2049                                      ; Copiar el número
  2050 000011CF 48BE-                       mov rsi, number_buffer
  2050 000011D1 [5F15000000000000] 
  2051 000011D9 F3A4                        rep movsb
  2052                                  
  2053                                      ; Imprimir el buffer completo
  2054                                      print rsp, score_label_len
    82 000011DB B801000000          <1>  mov eax, sys_write
    83 000011E0 BF01000000          <1>  mov edi, 1
    84 000011E5 4889E6              <1>  mov rsi, %1
    85 000011E8 BA17000000          <1>  mov edx, %2
    86 000011ED 0F05                <1>  syscall
  2055                                  
  2056                                      ; Repetir proceso para bloques destruidos
  2057 000011EF 4889E7                      mov rdi, rsp
  2058 000011F2 488D35(22160000)            lea rsi, [blocks_label]
  2059 000011F9 B91B000000                  mov rcx, blocks_label_len
  2060 000011FE F3A4                        rep movsb
  2061                                  
  2062                                      ; Verificar que el `[` esté en su posición correcta
  2063 00001200 4889E7                      mov rdi, rsp
  2064 00001203 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2065 00001207 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2066                                  
  2067                                      ; Convertir bloques destruidos a string
  2068 0000120A 480FB605(5E150000)          movzx rax, byte [destroyed_blocks]
  2069 00001212 48BF-                       mov rdi, number_buffer
  2069 00001214 [5F15000000000000] 
  2070 0000121C E807FFFFFF                  call number_to_string
  2071                                  
  2072                                      ; Calcular longitud del número
  2073 00001221 B900000000                  mov rcx, 0
  2074 00001226 48BF-                       mov rdi, number_buffer
  2074 00001228 [5F15000000000000] 
  2075                                      .count_loop2:
  2076 00001230 803C0F00                        cmp byte [rdi + rcx], 0
  2077 00001234 7405                            je .count_done2
  2078 00001236 48FFC1                          inc rcx
  2079 00001239 EBF5                            jmp .count_loop2
  2080                                      .count_done2:
  2081                                  
  2082                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2083 0000123B 4889E7                      mov rdi, rsp
  2084 0000123E 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2085 00001242 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2086 00001247 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2087                                      .pad_loop2:
  2088 0000124A 4885F6                          test rsi, rsi
  2089 0000124D 740B                            jz .pad_done2
  2090 0000124F C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2091 00001252 48FFC7                          inc rdi
  2092 00001255 48FFCE                          dec rsi
  2093 00001258 EBF0                            jmp .pad_loop2
  2094                                      .pad_done2:
  2095                                  
  2096                                      ; Copiar el número
  2097 0000125A 48BE-                       mov rsi, number_buffer
  2097 0000125C [5F15000000000000] 
  2098 00001264 F3A4                        rep movsb
  2099                                  
  2100                                      ; Imprimir el buffer completo
  2101                                      print rsp, blocks_label_len
    82 00001266 B801000000          <1>  mov eax, sys_write
    83 0000126B BF01000000          <1>  mov edi, 1
    84 00001270 4889E6              <1>  mov rsi, %1
    85 00001273 BA1B000000          <1>  mov edx, %2
    86 00001278 0F05                <1>  syscall
  2102                                  
  2103                                      ; Restaurar stack
  2104 0000127A 4883C420                    add rsp, 32
  2105 0000127E 5D                          pop rbp
  2106 0000127F C3                          ret
  2107                                  
  2108                                  
  2109                                  
  2110                                  check_block_collision:
  2111 00001280 55                          push rbp
  2112 00001281 4889E5                      mov rbp, rsp
  2113                                  
  2114                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2115 00001284 418A02                      mov al, [r10]
  2116                                  
  2117                                      ; Verificar si el carácter es un bloque
  2118 00001287 3C55                        cmp al, 'U'  
  2119 00001289 7419                        je .possible
  2120 0000128B 3C4F                        cmp al, 'O'  
  2121 0000128D 7415                        je .possible
  2122 0000128F 3C44                        cmp al, 'D'  
  2123 00001291 7411                        je .possible
  2124 00001293 3C4C                        cmp al, 'L'  
  2125 00001295 740D                        je .possible
  2126 00001297 3C56                        cmp al, 'V'  
  2127 00001299 7409                        je .possible
  2128 0000129B 3C38                        cmp al, '8'  
  2129 0000129D 7405                        je .possible
  2130                                  
  2131                                      ; No es bloque, salir
  2132 0000129F 4831C0                      xor rax, rax
  2133 000012A2 5D                          pop rbp
  2134 000012A3 C3                          ret
  2135                                  
  2136                                  .possible:
  2137 000012A4 53                          push rbx
  2138 000012A5 57                          push rdi
  2139 000012A6 56                          push rsi
  2140 000012A7 4154                        push r12
  2141 000012A9 4155                        push r13
  2142 000012AB 4156                        push r14
  2143 000012AD 4157                        push r15
  2144                                  
  2145                                      ; 1) Obtener base de los bloques del nivel actual
  2146 000012AF E83FFDFFFF                  call get_current_level_blocks
  2147 000012B4 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2148                                  
  2149                                      ; 2) Obtener la cantidad de bloques
  2150 000012B7 E890FDFFFF                  call get_current_level_count
  2151 000012BC 4989C6                      mov r14, rax
  2152                                  
  2153 000012BF 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2154                                  
  2155                                  .find_block_loop:
  2156 000012C2 4D39F4                      cmp r12, r14
  2157 000012C5 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2158                                  
  2159                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2160 000012CB 4C89E0                      mov rax, r12
  2161 000012CE 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2162 000012D2 4C01E8                      add rax, r13
  2163 000012D5 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2164                                  
  2165                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2166 000012D8 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2166 000012DD [F2140000]         
  2167 000012E1 4885DB                      test rbx, rbx
  2168 000012E4 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2169                                  
  2170                                      ; Obtener coordenadas
  2171 000012EA 418A17                      mov dl, [r15]         ; x
  2172 000012ED 418A4F01                    mov cl, [r15 + 1]     ; y
  2173                                  
  2174                                      ; Calcular posición en el board
  2175 000012F1 488D3D(000A0000)            lea rdi, [board]
  2176 000012F8 4831C0                      xor rax, rax
  2177 000012FB B84E000000                  mov rax, column_cells
  2178 00001300 4883C002                    add rax, 2
  2179 00001304 480FB6C9                    movzx rcx, cl         ; y
  2180 00001308 480FAFC1                    imul rax, rcx
  2181 0000130C 4801C7                      add rdi, rax
  2182 0000130F 480FB6C2                    movzx rax, dl         ; x
  2183 00001313 4801C7                      add rdi, rax
  2184                                  
  2185                                      ; Guardar la posición base del bloque
  2186 00001316 57                          push rdi
  2187                                  
  2188                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2189 00001317 4939FA                      cmp r10, rdi
  2190 0000131A 7274                        jb .skip_collision
  2191 0000131C 488D5F06                    lea rbx, [rdi + block_length]
  2192 00001320 4939DA                      cmp r10, rbx
  2193 00001323 736B                        jae .skip_collision
  2194                                  
  2195                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2196 00001325 41FE8C24[F2140000]          dec byte [block_states + r12]
  2197                                      ; Volver a cargar durabilidad
  2198 0000132D 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2198 00001332 [F2140000]         
  2199 00001336 4885DB                      test rbx, rbx
  2200 00001339 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2201                                  
  2202                                      ; >>> Llegó a 0 => Bloque destruido
  2203 0000133B 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2204 0000133C B906000000                  mov rcx, block_length
  2205                                  .clear_loop:
  2206 00001341 C60720                      mov byte [rdi], ' '
  2207 00001344 48FFC7                      inc rdi
  2208 00001347 E2F8                        loop .clear_loop
  2209                                  
  2210                                      ; Dibujar letra del bloque destruido
  2211 00001349 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2212 0000134D 4883EF06                    sub rdi, block_length
  2213 00001351 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2214                                      ; Después de escribir la letra en el tablero
  2215 00001353 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2216 00001357 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2217 0000135B 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2218 00001360 E841F0FFFF                  call register_letter
  2219                                      ; Actualizar contadores globales
  2220 00001365 FE0D(B5140000)              dec byte [blocks_remaining]
  2221 0000136B FE05(5E150000)              inc byte [destroyed_blocks]
  2222                                  
  2223                                      ; Sumar puntos según el tipo
  2224 00001371 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2225 00001376 486BC00A                    imul rax, 10
  2226 0000137A 480105(56150000)            add [current_score], rax
  2227                                  
  2228 00001381 B801000000                  mov rax, 1  ; colisión con destrucción
  2229 00001386 EB14                        jmp .end_pop
  2230                                  
  2231                                  .update_display:
  2232                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2233 00001388 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2234 0000138D 5F                          pop rdi     ; pop que quedó pendiente
  2235 0000138E EB0C                        jmp .end_pop
  2236                                  
  2237                                  .skip_collision:
  2238 00001390 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2239                                  .next_block:
  2240 00001391 49FFC4                      inc r12
  2241 00001394 E929FFFFFF                  jmp .find_block_loop
  2242                                  
  2243                                  .no_block_found:
  2244 00001399 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2245                                  
  2246                                  .end_pop:
  2247 0000139C 415F                        pop r15
  2248 0000139E 415E                        pop r14
  2249 000013A0 415D                        pop r13
  2250 000013A2 415C                        pop r12
  2251 000013A4 5E                          pop rsi
  2252 000013A5 5F                          pop rdi
  2253 000013A6 5B                          pop rbx
  2254 000013A7 5D                          pop rbp
  2255 000013A8 C3                          ret
  2256                                  
  2257                                  
  2258                                  
  2259                                  init_enemies:
  2260 000013A9 55                          push rbp
  2261 000013AA 4889E5                      mov rbp, rsp
  2262                                      ; Reiniciar contadores de movimiento
  2263 000013AD C605(A1150000)00            mov byte [enemy_move_total], 0
  2264 000013B4 C605(A2150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2265                                      ; Limpiar estado previo de enemigos
  2266 000013BB B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2267 000013C0 488D3D(78150000)            lea rdi, [enemies]
  2268 000013C7 30C0                        xor al, al
  2269 000013C9 F3AA                        rep stosb ; Limpiar datos de enemigos
  2270                                      
  2271                                      ; Marcar todos los enemigos como inactivos
  2272 000013CB 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  2273 000013D2 30C0                        xor al, al
  2274 000013D4 B90A000000                  mov rcx, 10
  2275 000013D9 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2276                                  
  2277 000013DB 5D                          pop rbp
  2278 000013DC C3                          ret
  2279                                  
  2280                                  
  2281                                  ; Función para mover enemigos
  2282                                  move_enemies:
  2283 000013DD 55                          push rbp
  2284 000013DE 4889E5                      mov rbp, rsp
  2285                                      
  2286                                      ; Incrementar contador de movimiento
  2287 000013E1 FE05(9F150000)              inc byte [enemy_move_counter]
  2288 000013E7 480FB605(9F150000)          movzx rax, byte [enemy_move_counter]
  2289 000013EF 3A05(A0150000)              cmp al, [enemy_move_delay]
  2290 000013F5 0F85AA010000                jne .end
  2291                                      
  2292                                      ; Resetear contador
  2293 000013FB C605(9F150000)00            mov byte [enemy_move_counter], 0
  2294                                      
  2295 00001402 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2296                                      
  2297                                      .enemy_loop:
  2298 00001405 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2299 00001409 0F8D96010000                    jge .end
  2300                                          
  2301                                          ; Calcular offset del enemigo actual
  2302 0000140F 4C89E0                          mov rax, r12
  2303 00001412 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2304 00001416 488DB0[78150000]                lea rsi, [enemies + rax]
  2305                                          
  2306                                          ; Verificar si el enemigo está activo
  2307 0000141D 807E0201                        cmp byte [rsi + 2], 1
  2308 00001421 0F8576010000                    jne .next_enemy
  2309                                          
  2310                                          ; Obtener posición actual
  2311 00001427 4C0FB606                        movzx r8, byte [rsi]            ; X
  2312 0000142B 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2313                                          
  2314                                          ; Limpiar posición actual antes de mover
  2315 00001430 4150                            push r8
  2316 00001432 4151                            push r9
  2317 00001434 B84E000000                      mov rax, column_cells
  2318 00001439 4883C002                        add rax, 2
  2319 0000143D 49F7E1                          mul r9
  2320 00001440 4C01C0                          add rax, r8
  2321 00001443 488DB8[000A0000]                lea rdi, [board + rax]
  2322 0000144A C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2323 0000144D 4159                            pop r9
  2324 0000144F 4158                            pop r8
  2325                                  
  2326                                          ; Determinar comportamiento basado en índice
  2327 00001451 4C89E0                          mov rax, r12
  2328 00001454 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2329 00001458 4885C0                          test rax, rax
  2330 0000145B 7402                            jz .chase_ball
  2331 0000145D EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2332                                          
  2333                                          ; Perseguir bola (comportamiento original)
  2334                                      .chase_ball:
  2335 0000145F 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2336 00001466 4D39D0                          cmp r8, r10
  2337 00001469 0F8F96000000                    jg .move_left
  2338 0000146F 0F8C95000000                    jl .move_right
  2339                                          
  2340 00001475 4C8B15(67140000)                mov r10, [ball_y_pos]
  2341 0000147C 4D39D1                          cmp r9, r10
  2342 0000147F 0F8F8A000000                    jg .move_up
  2343 00001485 0F8C89000000                    jl .move_down
  2344 0000148B E9A5000000                      jmp .check_collision
  2345                                          
  2346                                      .chase_paddle:
  2347                                          ; Obtener la posición X actual de la paleta
  2348 00001490 4C8B15(3F140000)                mov r10, [pallet_position]
  2349 00001497 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2350                                          
  2351                                          ; Calcular la posición X real de la paleta
  2352 0000149E 4C89D0                          mov rax, r10
  2353 000014A1 BB4E000000                      mov rbx, column_cells
  2354 000014A6 4883C302                        add rbx, 2                  ; Añadir newline chars
  2355 000014AA 4831D2                          xor rdx, rdx
  2356 000014AD 48F7F3                          div rbx                     ; rax = y, rdx = x
  2357                                          
  2358                                          ; rdx ahora contiene la posición X de la paleta
  2359                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2360 000014B0 488B0D(47140000)                mov rcx, [pallet_size]
  2361 000014B7 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2362 000014BA 4801CA                          add rdx, rcx
  2363                                          
  2364                                          ; Comparar con posición X del enemigo y mover gradualmente
  2365 000014BD 4939D0                          cmp r8, rdx
  2366 000014C0 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2367 000014C2 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2368 000014C4 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2369                                  
  2370                                      .check_y_paddle:
  2371                                          ; La Y de la paleta siempre es row_cells - 2
  2372 000014C6 41BA20000000                    mov r10, row_cells
  2373 000014CC 4983EA02                        sub r10, 2
  2374                                          
  2375                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2376 000014D0 4D39D1                          cmp r9, r10
  2377 000014D3 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2378 000014D5 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2379 000014D7 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2380                                          
  2381                                      .no_movement:
  2382 000014D9 EB5A                            jmp .check_collision
  2383                                  
  2384                                      ; También agregar una nueva sección para el movimiento suave
  2385                                      .smooth_transition:
  2386                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2387 000014DB 8A05(A2150000)                  mov al, [enemy_target]
  2388 000014E1 84C0                            test al, al
  2389 000014E3 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2390                                          
  2391                                          ; Verificar distancia en X
  2392 000014E5 4989D2                          mov r10, rdx              ; Posición X objetivo
  2393 000014E8 4D29C2                          sub r10, r8               ; Calcular diferencia
  2394 000014EB 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2395 000014EF 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2396 000014F1 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2397 000014F5 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2398 000014F7 EB3C                            jmp .check_collision
  2399                                          
  2400                                      .limit_right_movement:
  2401 000014F9 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2402 000014FD EB36                            jmp .check_collision
  2403                                          
  2404                                      .limit_left_movement:
  2405 000014FF 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2406 00001503 EB30                            jmp .check_collision
  2407                                      .move_left:
  2408 00001505 49FFC8                          dec r8
  2409 00001508 EB0F                            jmp .check_vertical
  2410                                          
  2411                                      .move_right:
  2412 0000150A 49FFC0                          inc r8
  2413 0000150D EB0A                            jmp .check_vertical
  2414                                          
  2415                                      .move_up:
  2416 0000150F 49FFC9                          dec r9
  2417 00001512 EB21                            jmp .check_collision
  2418                                          
  2419                                      .move_down:
  2420 00001514 49FFC1                          inc r9
  2421 00001517 EB1C                            jmp .check_collision
  2422                                          
  2423                                      .check_vertical:
  2424 00001519 8A05(A2150000)                  mov al, [enemy_target]
  2425 0000151F 84C0                            test al, al
  2426 00001521 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2427 00001527 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2428 0000152E 4D39D1                          cmp r9, r10
  2429 00001531 7FDC                            jg .move_up
  2430 00001533 7CDF                            jl .move_down
  2431                                          
  2432                                      .check_collision:
  2433                                          ; Verificar colisión con bordes
  2434 00001535 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2435 00001539 7E62                            jle .next_enemy
  2436 0000153B 4983F84E                        cmp r8, column_cells
  2437 0000153F 7D5C                            jge .next_enemy
  2438 00001541 4983F901                        cmp r9, 1                       ; Borde superior
  2439 00001545 7E56                            jle .next_enemy
  2440 00001547 4983F920                        cmp r9, row_cells
  2441 0000154B 7D50                            jge .next_enemy
  2442                                          
  2443                                          ; Verificar colisión con bloques antes de moverse
  2444 0000154D 4150                            push r8
  2445 0000154F 4151                            push r9
  2446 00001551 4152                            push r10
  2447                                          
  2448                                          ; Calcular posición en el tablero para verificar
  2449 00001553 B84E000000                      mov rax, column_cells
  2450 00001558 4883C002                        add rax, 2
  2451 0000155C 49F7E1                          mul r9
  2452 0000155F 4C01C0                          add rax, r8
  2453 00001562 4C8D90[000A0000]                lea r10, [board + rax]
  2454                                          
  2455                                          ; Verificar si hay un bloque en la nueva posición
  2456 00001569 418A02                          mov al, [r10]
  2457 0000156C 3C55                            cmp al, 'U'
  2458 0000156E 7427                            je .invalid_move
  2459 00001570 3C4F                            cmp al, 'O'
  2460 00001572 7423                            je .invalid_move
  2461 00001574 3C44                            cmp al, 'D'
  2462 00001576 741F                            je .invalid_move
  2463 00001578 3C4C                            cmp al, 'L'
  2464 0000157A 741B                            je .invalid_move
  2465 0000157C 3C56                            cmp al, 'V'
  2466 0000157E 7417                            je .invalid_move
  2467 00001580 3C38                            cmp al, '8'
  2468 00001582 7413                            je .invalid_move
  2469 00001584 3C58                            cmp al, 'X'
  2470 00001586 740F                            je .invalid_move
  2471                                          
  2472 00001588 415A                            pop r10
  2473 0000158A 4159                            pop r9
  2474 0000158C 4158                            pop r8
  2475                                          
  2476                                          ; Guardar nueva posición si es válida
  2477 0000158E 448806                          mov [rsi], r8b
  2478 00001591 44884E01                        mov [rsi + 1], r9b
  2479 00001595 EB06                            jmp .next_enemy
  2480                                          
  2481                                      .invalid_move:
  2482 00001597 415A                            pop r10
  2483 00001599 4159                            pop r9
  2484 0000159B 4158                            pop r8
  2485                                          
  2486                                      .next_enemy:
  2487 0000159D 49FFC4                          inc r12
  2488 000015A0 E960FEFFFF                      jmp .enemy_loop
  2489                                          
  2490                                      .end:
  2491 000015A5 5D                              pop rbp
  2492 000015A6 C3                              ret
  2493                                  
  2494                                  get_current_spawn_points:
  2495 000015A7 55                          push rbp
  2496 000015A8 4889E5                      mov rbp, rsp
  2497                                      
  2498 000015AB 480FB605(B4140000)          movzx rax, byte [current_level]
  2499 000015B3 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2500 000015B6 488B04C5[D6150000]          mov rax, [spawn_points_table + rax * 8]
  2501                                      
  2502 000015BE 5D                          pop rbp
  2503 000015BF C3                          ret
  2504                                  
  2505                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2506                                  check_enemy_spawn:
  2507 000015C0 55                          push rbp
  2508 000015C1 4889E5                      mov rbp, rsp
  2509                                      
  2510                                      ; Obtener spawn points del nivel actual
  2511 000015C4 E8DEFFFFFF                  call get_current_spawn_points
  2512 000015C9 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2513                                      
  2514                                      ; Obtener cantidad de bloques destruidos
  2515 000015CC 4C0FB62D(5E150000)          movzx r13, byte [destroyed_blocks]
  2516                                      
  2517                                      ; Verificar cada punto de spawn
  2518 000015D4 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2519                                      
  2520                                      .check_loop:
  2521 000015D7 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2522 000015DB 7D4B                            jge .end
  2523                                          
  2524                                          ; Verificar si este spawn point ya fue usado
  2525 000015DD 80B9[01160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2526 000015E4 743D                            je .next_enemy
  2527                                          
  2528                                          ; Verificar si este enemigo ya está activo
  2529 000015E6 4889C8                          mov rax, rcx
  2530 000015E9 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2531 000015ED 488DB0[78150000]                lea rsi, [enemies + rax]
  2532 000015F4 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2533 000015F8 7429                            je .next_enemy
  2534                                          
  2535                                          ; Verificar si debemos spawnear este enemigo
  2536 000015FA 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2537 000015FF 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2538 00001602 751F                            jne .next_enemy
  2539                                          
  2540                                          ; Marcar este spawn point como usado
  2541 00001604 C681[01160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2542                                          
  2543                                          ; Spawner nuevo enemigo
  2544 0000160B C60628                          mov byte [rsi], 40             ; X inicial
  2545 0000160E C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2546 00001612 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2547                                          
  2548                                          ; Inicializar comportamiento
  2549 00001616 4889C8                          mov rax, rcx
  2550 00001619 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2551 0000161D 8805(00160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2552                                          
  2553                                      .next_enemy:
  2554 00001623 48FFC1                          inc rcx
  2555 00001626 EBAF                            jmp .check_loop
  2556                                          
  2557                                      .end:
  2558 00001628 5D                              pop rbp
  2559 00001629 C3                              ret
  2560                                  
  2561                                  
  2562                                  ; Función para dibujar enemigos
  2563                                  print_enemies:
  2564 0000162A 55                          push rbp
  2565 0000162B 4889E5                      mov rbp, rsp
  2566                                      
  2567 0000162E 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2568                                      
  2569                                      .print_loop:
  2570 00001631 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2571 00001635 7D4B                            jge .end
  2572                                          
  2573                                          ; Calcular offset del enemigo actual
  2574 00001637 4C89E0                          mov rax, r12
  2575 0000163A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2576 0000163E 488DB0[78150000]                lea rsi, [enemies + rax]
  2577                                          
  2578                                          ; Verificar si el enemigo está activo
  2579 00001645 807E0201                        cmp byte [rsi + 2], 1
  2580 00001649 7532                            jne .next_enemy
  2581                                          
  2582                                          ; Calcular posición en el tablero
  2583 0000164B 4C0FB606                        movzx r8, byte [rsi]            ; X
  2584 0000164F 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2585                                          
  2586                                          ; Calcular offset en el tablero
  2587 00001654 B84E000000                      mov rax, column_cells
  2588 00001659 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2589 0000165D 49F7E1                          mul r9
  2590 00001660 4C01C0                          add rax, r8
  2591 00001663 488DB8[000A0000]                lea rdi, [board + rax]
  2592                                          
  2593                                          ; Obtener carácter del enemigo según el nivel
  2594 0000166A 480FB605(B4140000)              movzx rax, byte [current_level]
  2595 00001672 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2596 00001675 8A80[73150000]                  mov al, [enemy_chars + rax]
  2597                                          
  2598                                          ; Dibujar enemigo
  2599 0000167B 8807                            mov [rdi], al
  2600                                          
  2601                                      .next_enemy:
  2602 0000167D 49FFC4                          inc r12
  2603 00001680 EBAF                            jmp .print_loop
  2604                                          
  2605                                      .end:
  2606 00001682 5D                              pop rbp
  2607 00001683 C3                              ret
  2608                                  
  2609                                  ; Función para verificar colisión con enemigos
  2610                                  ; Función para verificar colisión con enemigos
  2611                                  check_enemy_collision:
  2612 00001684 55                          push rbp
  2613 00001685 4889E5                      mov rbp, rsp
  2614                                      
  2615 00001688 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2616 0000168B 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2617                                      
  2618                                      .check_loop:
  2619 0000168E 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2620 00001692 0F8DE9000000                    jge .end
  2621                                          
  2622                                          ; Calcular offset del enemigo actual
  2623 00001698 4C89E1                          mov rcx, r12
  2624 0000169B 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2625 0000169F 488DB1[78150000]                lea rsi, [enemies + rcx]
  2626                                          
  2627                                          ; Verificar si el enemigo está activo
  2628 000016A6 807E0201                        cmp byte [rsi + 2], 1
  2629 000016AA 0F85C9000000                    jne .next_enemy
  2630                                          
  2631                                          ; Verificar colisión con la bola
  2632 000016B0 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2633 000016B4 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2634                                          
  2635                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2636 000016B9 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2637 000016C0 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2638                                          
  2639                                          ; Comprobar colisión vertical (misma columna)
  2640 000016C7 4D39C2                          cmp r10, r8
  2641 000016CA 7525                            jne .check_horizontal
  2642 000016CC 4D29CB                          sub r11, r9
  2643 000016CF 4983FB01                        cmp r11, 1
  2644 000016D3 7F1C                            jg .check_horizontal
  2645 000016D5 4983FBFF                        cmp r11, -1
  2646 000016D9 7C16                            jl .check_horizontal
  2647                                          
  2648                                          ; Colisión vertical detectada
  2649 000016DB E8A3000000                      call destroy_enemy
  2650 000016E0 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2651 000016E7 B801000000                      mov rax, 1
  2652 000016EC E990000000                      jmp .end
  2653                                          
  2654                                      .check_horizontal:
  2655                                          ; Comprobar colisión horizontal (misma fila)
  2656 000016F1 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2657 000016F8 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2658 000016FF 4D39CB                          cmp r11, r9
  2659 00001702 7522                            jne .check_paddle
  2660 00001704 4D29C2                          sub r10, r8
  2661 00001707 4983FA01                        cmp r10, 1
  2662 0000170B 7F19                            jg .check_paddle
  2663 0000170D 4983FAFF                        cmp r10, -1
  2664 00001711 7C13                            jl .check_paddle
  2665                                          
  2666                                          ; Colisión horizontal detectada
  2667 00001713 E86B000000                      call destroy_enemy
  2668 00001718 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2669 0000171F B801000000                      mov rax, 1
  2670 00001724 EB5B                            jmp .end
  2671                                          
  2672                                      .check_paddle:
  2673                                          ; Verificar colisión con la paleta
  2674 00001726 4C8B15(3F140000)                mov r10, [pallet_position]
  2675 0000172D 4981EA[000A0000]                sub r10, board
  2676 00001734 4C89D0                          mov rax, r10
  2677 00001737 41BB4E000000                    mov r11, column_cells
  2678 0000173D 4983C302                        add r11, 2
  2679 00001741 4831D2                          xor rdx, rdx
  2680 00001744 49F7F3                          div r11                     ; División para obtener la posición Y
  2681 00001747 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2682                                          
  2683 0000174A 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2684                                          
  2685                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2686 00001751 41BD20000000                    mov r13, row_cells
  2687 00001757 4983ED02                        sub r13, 2                 ; Y de la paleta
  2688 0000175B 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2689 0000175E 7519                            jne .next_enemy
  2690                                          
  2691                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2692 00001760 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2693 00001763 7C14                            jl .next_enemy
  2694                                          
  2695 00001765 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2696 00001768 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2697 0000176B 7F0C                            jg .next_enemy
  2698                                          
  2699                                          ; Si llegamos aquí, hay colisión con la paleta
  2700 0000176D E811000000                      call destroy_enemy        ; Destruir el enemigo
  2701 00001772 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2702 00001777 EB08                            jmp .end
  2703                                          
  2704                                      .next_enemy:
  2705 00001779 49FFC4                          inc r12
  2706 0000177C E90DFFFFFF                      jmp .check_loop
  2707                                          
  2708                                      .end:
  2709 00001781 5D                              pop rbp
  2710 00001782 C3                              ret
  2711                                  
  2712                                  ; Función para destruir un enemigo
  2713                                  destroy_enemy:
  2714                                      ; Desactivar enemigo
  2715 00001783 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2716                                  
  2717                                      ; Sumar puntos por destruir enemigo
  2718 00001787 488B05(97150000)            mov rax, [enemy_points]
  2719 0000178E 480105(56150000)            add [current_score], rax
  2720                                  
  2721                                      ; No tocar bloques destruidos aquí
  2722 00001795 C3                          ret
  2723                                  
  2724                                  
  2725                                  _start:
  2726 00001796 E890E9FFFF              	call canonical_off
  2727 0000179B E809010000              	call start_screen
  2728 000017A0 E8B9F5FFFF                  call init_level
  2729 000017A5 E8FFFBFFFF                  call init_enemies
  2730 000017AA EB00                    	jmp .main_loop
  2731                                  	
  2732                                  
  2733                                  	.main_loop:
  2734 000017AC E8B6F9FFFF                      call print_labels
  2735 000017B1 E8E5F8FFFF                      call print_blocks
  2736 000017B6 E8BCECFFFF                      call move_letters
  2737 000017BB E8CFEEFFFF                      call update_lasers
  2738 000017C0 E827ECFFFF                      call print_letters
  2739 000017C5 E8E5F1FFFF              		call print_pallet
  2740 000017CA E8C8F2FFFF                      call move_ball
  2741 000017CF E80AEBFFFF                      call check_bottom_collision
  2742 000017D4 E804EAFFFF                      call print_lives
  2743 000017D9 E81FF7FFFF                      call check_level_complete
  2744 000017DE E8DDFDFFFF                      call check_enemy_spawn
  2745 000017E3 E8F5FBFFFF                      call move_enemies
  2746 000017E8 E897FEFFFF                      call check_enemy_collision
  2747 000017ED E838FEFFFF                      call print_enemies
  2748 000017F2 E890F1FFFF              		call print_ball
  2749                                  		print board, board_size				
    82 000017F7 B801000000          <1>  mov eax, sys_write
    83 000017FC BF01000000          <1>  mov edi, 1
    84 00001801 48BE-               <1>  mov rsi, %1
    84 00001803 [000A000000000000]  <1>
    85 0000180B BA000A0000          <1>  mov edx, %2
    86 00001810 0F05                <1>  syscall
  2750                                  		;setnonblocking	
  2751                                  	.read_more:	
  2752                                  	    getchar	
    90 00001812 B800000000          <1>  mov rax, sys_read
    91 00001817 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000181C 48BE-               <1>  mov rsi, input_char
    92 0000181E [0000000000000000]  <1>
    93 00001826 BA01000000          <1>  mov rdx, 1
    94 0000182B 0F05                <1>  syscall
  2753 0000182D 4883F801                	    cmp rax, 1
  2754 00001831 7543                    	    jne .done
  2755                                  	
  2756 00001833 8A05(00000000)          	    mov al, [input_char]
  2757 00001839 8805(1D180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2758                                  	
  2759 0000183F 3C61                    	    cmp al, 'a'
  2760 00001841 750E                    	    jne .not_left
  2761 00001843 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2762 0000184A E895F1FFFF              	    call move_pallet
  2763 0000184F EB25                    	    jmp .done
  2764                                  	
  2765                                      .not_left:
  2766 00001851 3C64                    	    cmp al, 'd'
  2767 00001853 750C                    	    jne .not_right
  2768 00001855 BF01000000              	    mov rdi, right_direction
  2769 0000185A E885F1FFFF              	    call move_pallet
  2770 0000185F EB15                    	    jmp .done
  2771                                  	
  2772                                      .not_right:
  2773 00001861 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2774 00001863 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2775                                  	
  2776 00001865 3C71                    	    cmp al, 'q' 
  2777 00001867 0F84AF000000            	    je exit
  2778 0000186D EBA3                    	    jmp .read_more
  2779                                  	
  2780                                      .release_ball:
  2781 0000186F E8F6F3FFFF              	    call process_catch_release
  2782 00001874 EB00                    	    jmp .done
  2783                                  	
  2784                                      .done:
  2785                                  	    sleeptime
    98 00001876 B823000000          <1>  mov eax, sys_nanosleep
    99 0000187B 48BF-               <1>  mov rdi, timespec
    99 0000187D [0000000000000000]  <1>
   100 00001885 31F6                <1>  xor esi, esi
   101 00001887 0F05                <1>  syscall
  2786                                  	    print clear, clear_length
    82 00001889 B801000000          <1>  mov eax, sys_write
    83 0000188E BF01000000          <1>  mov edi, 1
    84 00001893 48BE-               <1>  mov rsi, %1
    84 00001895 [1000000000000000]  <1>
    85 0000189D BA07000000          <1>  mov edx, %2
    86 000018A2 0F05                <1>  syscall
  2787 000018A4 E903FFFFFF              	    jmp .main_loop
  2788                                  
  2789                                  
  2790                                  
  2791                                  
  2792                                  start_screen:
  2793                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000018A9 B801000000          <1>  mov eax, sys_write
    83 000018AE BF01000000          <1>  mov edi, 1
    84 000018B3 48BE-               <1>  mov rsi, %1
    84 000018B5 [1000000000000000]  <1>
    85 000018BD BA07000000          <1>  mov edx, %2
    86 000018C2 0F05                <1>  syscall
  2794                                      print msg1, msg1_length
    82 000018C4 B801000000          <1>  mov eax, sys_write
    83 000018C9 BF01000000          <1>  mov edi, 1
    84 000018CE 48BE-               <1>  mov rsi, %1
    84 000018D0 [1700000000000000]  <1>
    85 000018D8 BA14010000          <1>  mov edx, %2
    86 000018DD 0F05                <1>  syscall
  2795                                      
  2796                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2797                                          getchar                 ; Esperamos una tecla
    90 000018DF B800000000          <1>  mov rax, sys_read
    91 000018E4 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000018E9 48BE-               <1>  mov rsi, input_char
    92 000018EB [0000000000000000]  <1>
    93 000018F3 BA01000000          <1>  mov rdx, 1
    94 000018F8 0F05                <1>  syscall
  2798 000018FA 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2799 000018FE 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2800                                          
  2801                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001900 B801000000          <1>  mov eax, sys_write
    83 00001905 BF01000000          <1>  mov edi, 1
    84 0000190A 48BE-               <1>  mov rsi, %1
    84 0000190C [1000000000000000]  <1>
    85 00001914 BA07000000          <1>  mov edx, %2
    86 00001919 0F05                <1>  syscall
  2802 0000191B C3                          ret
  2803                                  
  2804                                  exit: 
  2805 0000191C E84CE8FFFF              	call canonical_on
  2806 00001921 B83C000000              	mov    rax, 60
  2807 00001926 BF00000000                  mov    rdi, 0
  2808 0000192B 0F05                        syscall
  2809                                  
