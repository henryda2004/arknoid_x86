     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 3A07030220                      db 58, 7, 3, 2, ' '    ; Bloque 7
   288 000014AB 3D09030145                      db 61, 9, 3, 1, 'E'    ; Bloque 7
   289 000014B0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014BA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014C4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 0000152D 0000000000000000            current_score dq 0          ; Score actual
   319 00001535 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 00001536 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 0000154A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 0000154F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 0000156D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 0000156E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 00001576 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001577 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   333 00001578 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001579 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 0000157A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 0000157B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 00001584 12                 
   339 00001585 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 0000158E 13                 
   340 0000158F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001598 1B                 
   341 00001599 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 000015A2 1C                 
   342 000015A3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015AC 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015AD [7B15000000000000]              dq level1_spawn_points
   346 000015B5 [8515000000000000]              dq level2_spawn_points
   347 000015BD [8F15000000000000]              dq level3_spawn_points
   348 000015C5 [9915000000000000]              dq level4_spawn_points
   349 000015CD [A315000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015D5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015D6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015E2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015EB 5B2020202020202020-
   357 000015F4 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F9 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 00001602 657374727569646F73-
   359 0000160B 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365                                      
   366                                      ; Definición de las vidas (x, y, estado)
   367                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   368                                      lives_data: 
   369 00001614 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   370 00001617 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   371 0000161A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   372 0000161D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   373 00001620 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   374 00001623 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   375 00001626 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   376                                      lives_count equ 7    ; Total de vidas
   377 00001629 5E                          life_char db "^"    
   378 0000162A 07                          current_lives db 7   ; Contador de vidas activas actual
   379                                  
   380                                  ; Estructura para almacenar las letras y sus posiciones
   381                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   382 0000162B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   383 000017BB 00                          letters_count db 0   
   384 000017BC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   385 000017BD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   385 000017C6 75616C3A205B205D0A-
   385 000017CF 0D                 
   386                                      last_letter_msg_len equ $ - last_letter_msg
   387                                  section .text
   388                                  
   389                                  ;	Function: print_ball
   390                                  ; This function displays the position of the ball
   391                                  ; Arguments: none
   392                                  ;
   393                                  ; Return:
   394                                  ;	Void
   395                                  
   396                                  ; Función para imprimir las vidas
   397                                  ; Función modificada para imprimir las vidas
   398                                  print_lives:
   399 000001DD 55                          push rbp
   400 000001DE 4889E5                      mov rbp, rsp
   401                                      
   402 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   403                                      
   404                                      .print_loop:
   405 000001E4 4983FC07                        cmp r12, lives_count
   406 000001E8 7D45                            jge .end
   407                                          
   408                                          ; Calcular offset de la vida actual
   409 000001EA 4C89E0                          mov rax, r12
   410 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   411 000001F1 488DB0[14160000]                lea rsi, [lives_data + rax]
   412                                          
   413                                          ; Calcular posición en el tablero
   414 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   415 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   416                                          
   417                                          ; Calcular offset en el tablero
   418 00000201 B84E000000                      mov rax, column_cells
   419 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   420 0000020A 49F7E1                          mul r9
   421 0000020D 4C01C0                          add rax, r8
   422 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   423                                          
   424                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   425 00000217 807E0201                        cmp byte [rsi + 2], 1
   426 0000021B 7405                            je .draw_active
   427                                          
   428                                          ; Si está inactiva, dibujar espacio
   429 0000021D C60720                          mov byte [rdi], ' '
   430 00000220 EB08                            jmp .next_life
   431                                          
   432                                      .draw_active:
   433                                          ; Si está activa, dibujar el símbolo de vida
   434 00000222 8A05(29160000)                  mov al, [life_char]
   435 00000228 8807                            mov [rdi], al
   436                                          
   437                                      .next_life:
   438 0000022A 49FFC4                          inc r12
   439 0000022D EBB5                            jmp .print_loop
   440                                          
   441                                      .end:
   442 0000022F 5D                              pop rbp
   443 00000230 C3                              ret
   444                                  
   445                                  ; Función para desactivar una vida
   446                                  ; Función modificada para perder una vida
   447                                  lose_life:
   448 00000231 55                          push rbp
   449 00000232 4889E5                      mov rbp, rsp
   450                                      
   451                                      ; Verificar si aún quedan vidas
   452 00000235 803D(2A160000)00            cmp byte [current_lives], 0
   453 0000023C 0F8493000000                je .game_lost
   454                                      
   455                                      ; Encontrar la última vida activa
   456 00000242 B907000000                  mov rcx, lives_count
   457 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   458                                      
   459                                      .find_active_life:
   460 0000024A 4889C8                          mov rax, rcx
   461 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   462 00000251 488DB0[14160000]                lea rsi, [lives_data + rax]
   463 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   464 0000025C 7407                            je .deactivate_life
   465 0000025E 48FFC9                          dec rcx
   466 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   467 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   468                                          
   469                                      .deactivate_life:
   470                                          ; Calcular posición correcta en el tablero para borrar la vida
   471 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   472 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   473                                          
   474                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   475 0000026E B84E000000                      mov rax, column_cells
   476 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   477 00000277 49F7E1                          mul r9
   478 0000027A 4C01C0                          add rax, r8
   479 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   480                                          
   481                                          ; Borrar visualmente la vida
   482 00000284 C60720                          mov byte [rdi], ' '             
   483                                          
   484                                          ; Desactivar la vida en los datos
   485 00000287 C6460200                        mov byte [rsi + 2], 0          
   486 0000028B FE0D(2A160000)                  dec byte [current_lives]
   487                                          
   488                                          ; Borrar visualmente la paleta anterior
   489 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   490 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   491                                          .erase_pallet_loop:
   492 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   493 000002A3 49FFC0                              inc r8
   494 000002A6 48FFC9                              dec rcx
   495 000002A9 75F4                                jnz .erase_pallet_loop
   496                                          
   497                                  
   498                                          ; Reiniciar posición de la bola y la paleta
   499 000002AB 48C705(4F140000)28-             mov qword [ball_x_pos], 40
   499 000002B3 000000             
   500 000002B6 48C705(57140000)1C-             mov qword [ball_y_pos], 28
   500 000002BE 000000             
   501 000002C1 C605(6F140000)00                mov byte [ball_moving], 0
   502 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   502 000002CF [36130000]         
   503                                          
   504 000002D3 EB07                            jmp .end
   505                                          
   506                                      .game_lost:
   507 000002D5 E81C000000                      call game_lost
   508 000002DA EB00                            jmp .end
   509                                          
   510                                      .end:
   511 000002DC 5D                              pop rbp
   512 000002DD C3                              ret
   513                                  ; Función modificada para verificar colisión con el borde inferior
   514                                  check_bottom_collision:
   515 000002DE 55                          push rbp
   516 000002DF 4889E5                      mov rbp, rsp
   517                                      
   518                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   519 000002E2 488B05(57140000)            mov rax, [ball_y_pos]
   520 000002E9 4883F81E                    cmp rax, row_cells - 2
   521 000002ED 7505                        jne .no_collision
   522                                      
   523                                      ; Si hay colisión, perder una vida
   524 000002EF E83DFFFFFF                  call lose_life
   525                                      
   526                                      .no_collision:
   527 000002F4 5D                              pop rbp
   528 000002F5 C3                              ret
   529                                  
   530                                  ; Nueva función para game over
   531                                  game_lost:
   532                                      ; Limpiar la pantalla
   533                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   534                                      
   535                                      ; Mostrar mensaje de derrota
   536                                      section .data
   537 000017D0 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   537 000017D9 6469646F210A0D     
   538                                          lost_msg_len: equ $ - lost_msg
   539                                      section .text
   540                                      
   541                                      ; Imprimir mensaje de derrota
   542                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [D017000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   543                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [FE17000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   544                                      
   545                                      ; Mostrar puntaje final
   546 00000347 488B05(2D150000)            mov rax, [current_score]
   547 0000034E 48BF-                       mov rdi, number_buffer
   547 00000350 [3615000000000000] 
   548 00000358 E8EA070000                  call number_to_string
   549                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [3615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   550                                      
   551                                      ; Esperar un momento antes de salir
   552 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   552 00000381 0000               
   553 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   553 0000038C 0000               
   554                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   555                                      
   556 000003A1 E97F0F0000                  jmp exit
   557                                  
   558                                  
   559                                  ; Función para registrar una nueva letra en el mapa
   560                                  ; Entrada:
   561                                  ;   al - letra a registrar
   562                                  ;   r8b - posición x
   563                                  ;   r9b - posición y
   564                                  register_letter:
   565 000003A6 55                          push rbp
   566 000003A7 4889E5                      mov rbp, rsp
   567 000003AA 53                          push rbx
   568 000003AB 51                          push rcx
   569                                      
   570 000003AC 3C20                        cmp al, ' '
   571 000003AE 7438                        je .end
   572                                  
   573                                      ; Encontrar un espacio libre en el mapa
   574 000003B0 4831C9                      xor rcx, rcx
   575 000003B3 480FB615(BB170000)          movzx rdx, byte [letters_count]
   576                                      
   577                                      .find_slot:
   578 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   579 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   580                                          
   581 000003C1 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   582 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   583 000003CD 7405                            je .found_slot
   584                                          
   585 000003CF 48FFC1                          inc rcx
   586 000003D2 EBE7                            jmp .find_slot
   587                                          
   588                                      .found_slot:
   589                                          ; Guardar la información de la letra
   590 000003D4 448803                          mov [rbx], r8b           ; x
   591 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   592 000003DB 884302                          mov [rbx + 2], al        ; letra
   593 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   594                                          
   595 000003E2 FE05(BB170000)                  inc byte [letters_count]
   596                                          
   597                                      .end:
   598 000003E8 59                              pop rcx
   599 000003E9 5B                              pop rbx
   600 000003EA 5D                              pop rbp
   601 000003EB C3                              ret
   602                                  
   603                                  ; Función para imprimir todas las letras registradas
   604                                  print_letters:
   605 000003EC 55                          push rbp
   606 000003ED 4889E5                      mov rbp, rsp
   607 000003F0 53                          push rbx
   608 000003F1 51                          push rcx
   609                                      
   610 000003F2 4831C9                      xor rcx, rcx
   611                                      
   612                                      .print_loop:
   613 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   614 000003F9 7D37                            jge .end
   615                                          
   616                                          ; Obtener puntero a la letra actual
   617 000003FB 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   618                                          
   619                                          ; Verificar si está activa
   620 00000403 807B0300                        cmp byte [rbx + 3], 0
   621 00000407 7424                            je .next_letter
   622                                          
   623                                          ; Calcular posición en el tablero
   624 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   625 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   626                                          
   627                                          ; Calcular offset en el tablero
   628 00000412 B84E000000                      mov rax, column_cells
   629 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   630 0000041B 49F7E1                          mul r9
   631 0000041E 4C01C0                          add rax, r8
   632 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   633                                          
   634                                          ; Imprimir la letra
   635 00000428 8A4302                          mov al, [rbx + 2]
   636 0000042B 8807                            mov [rdi], al
   637                                          
   638                                      .next_letter:
   639 0000042D 48FFC1                          inc rcx
   640 00000430 EBC3                            jmp .print_loop
   641                                          
   642                                      .end:
   643 00000432 59                              pop rcx
   644 00000433 5B                              pop rbx
   645 00000434 5D                              pop rbp
   646 00000435 C3                              ret
   647                                  
   648                                  ; Función para borrar una letra específica
   649                                  ; Entrada:
   650                                  ;   r8b - posición x
   651                                  ;   r9b - posición y
   652                                  remove_letter:
   653 00000436 55                          push rbp
   654 00000437 4889E5                      mov rbp, rsp
   655 0000043A 53                          push rbx
   656 0000043B 51                          push rcx
   657                                      
   658 0000043C 4831C9                      xor rcx, rcx
   659                                      
   660                                      .find_loop:
   661 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   662 00000443 7D2E                            jge .end
   663                                          
   664 00000445 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   665                                          
   666                                          ; Verificar si está activa y coincide la posición
   667 0000044D 807B0300                        cmp byte [rbx + 3], 0
   668 00000451 741B                            je .next_letter
   669                                          
   670 00000453 8A03                            mov al, [rbx]
   671 00000455 4438C0                          cmp al, r8b
   672 00000458 7514                            jne .next_letter
   673                                          
   674 0000045A 8A4301                          mov al, [rbx + 1]
   675 0000045D 4438C8                          cmp al, r9b
   676 00000460 750C                            jne .next_letter
   677                                          
   678                                          ; Encontrada la letra, desactivarla
   679 00000462 C6430300                        mov byte [rbx + 3], 0
   680 00000466 FE0D(BB170000)                  dec byte [letters_count]
   681 0000046C EB05                            jmp .end
   682                                          
   683                                      .next_letter:
   684 0000046E 48FFC1                          inc rcx
   685 00000471 EBCC                            jmp .find_loop
   686                                          
   687                                      .end:
   688 00000473 59                              pop rcx
   689 00000474 5B                              pop rbx
   690 00000475 5D                              pop rbp
   691 00000476 C3                              ret
   692                                  ; Función para mover las letras hacia abajo
   693                                  move_letters:
   694 00000477 55                          push rbp
   695 00000478 4889E5                      mov rbp, rsp
   696 0000047B 53                          push rbx
   697 0000047C 57                          push rdi
   698 0000047D 56                          push rsi
   699                                  
   700 0000047E 4831C9                      xor rcx, rcx                    ; Índice de la letra actual
   701                                  
   702                                      .move_loop:
   703 00000481 4883F964                        cmp rcx, 100                ; Máximo 100 letras
   704 00000485 0F8D80000000                    jge .print_last_letter      ; Al terminar, mostrar la última letra
   705                                          
   706                                          ; Obtener puntero a la letra actual
   707 0000048B 488D1C8D[2B160000]              lea rbx, [letters_map + rcx * 4]
   708                                  
   709                                          ; Verificar si la letra está activa
   710 00000493 807B0300                        cmp byte [rbx + 3], 0
   711 00000497 746A                            je .next_letter
   712                                  
   713                                          ; Obtener la posición actual de la letra
   714 00000499 4C0FB603                        movzx r8, byte [rbx]        ; X
   715 0000049D 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; Y
   716                                  
   717                                          ; Calcular la posición en el tablero para borrar la letra anterior
   718 000004A2 B84E000000                      mov rax, column_cells
   719 000004A7 4883C002                        add rax, 2                  ; Incluye caracteres de nueva línea
   720 000004AB 49F7E1                          mul r9
   721 000004AE 4C01C0                          add rax, r8
   722 000004B1 488DB8[000A0000]                lea rdi, [board + rax]
   723 000004B8 C60720                          mov byte [rdi], ' '         ; Borra la letra en la posición anterior
   724                                  
   725                                          ; Incrementar la posición Y de la letra
   726 000004BB FE4301                          inc byte [rbx + 1]
   727 000004BE 4C0FB64B01                      movzx r9, byte [rbx + 1]
   728                                  
   729                                          ; Verificar si la letra alcanzó el final del tablero
   730 000004C3 4983F91F                        cmp r9, row_cells - 1
   731 000004C7 7C06                            jl .check_pallet_collision
   732                                  
   733                                          ; Desactivar la letra si llega al final
   734 000004C9 C6430300                        mov byte [rbx + 3], 0
   735 000004CD EB34                            jmp .next_letter
   736                                  
   737                                          .check_pallet_collision:
   738                                              ; Calcular la nueva posición en el tablero
   739 000004CF B84E000000                          mov rax, column_cells
   740 000004D4 4883C002                            add rax, 2
   741 000004D8 49F7E1                              mul r9
   742 000004DB 4C01C0                              add rax, r8
   743 000004DE 488DB8[000A0000]                    lea rdi, [board + rax]
   744                                  
   745                                              ; Verificar si hay colisión con la paleta (símbolo =)
   746 000004E5 8A07                                mov al, [rdi]
   747 000004E7 3C20                                cmp al, ' '
   748 000004E9 7418                                je .next_letter
   749 000004EB 3C3D                                cmp al, char_equal
   750 000004ED 7407                                je .capture_letter
   751                                  
   752                                              ; Si no hay colisión, dibujar la letra
   753 000004EF 8A4302                              mov al, [rbx + 2]
   754 000004F2 8807                                mov [rdi], al
   755 000004F4 EB0D                                jmp .next_letter
   756                                  
   757                                          .capture_letter:
   758                                              ; Guardar la letra capturada
   759 000004F6 8A4302                              mov al, [rbx + 2]       ; Obtener la letra
   760 000004F9 8805(BC170000)                      mov [last_letter], al   ; Guardarla como última letra capturada
   761                                              
   762                                              ; Desactivar la letra
   763 000004FF C6430300                            mov byte [rbx + 3], 0
   764                                  
   765                                          .next_letter:
   766 00000503 48FFC1                              inc rcx
   767 00000506 E976FFFFFF                          jmp .move_loop
   768                                  
   769                                      .print_last_letter:
   770                                          ; Imprimir el mensaje con la última letra
   771                                          print last_letter_msg, last_letter_msg_len - 3  ; Imprimir hasta antes del salto de línea
    82 0000050B B801000000          <1>  mov eax, sys_write
    83 00000510 BF01000000          <1>  mov edi, 1
    84 00000515 48BE-               <1>  mov rsi, %1
    84 00000517 [BD17000000000000]  <1>
    85 0000051F BA10000000          <1>  mov edx, %2
    86 00000524 0F05                <1>  syscall
   772                                          
   773                                          ; Imprimir la última letra
   774 00000526 8A05(BC170000)                  mov al, [last_letter]
   775 0000052C 8805(CC170000)                  mov [last_letter_msg + 15], al  ; Colocar la letra en el espacio entre corchetes
   776                                          
   777                                          ; Imprimir el salto de línea
   778                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000532 B801000000          <1>  mov eax, sys_write
    83 00000537 BF01000000          <1>  mov edi, 1
    84 0000053C 48BE-               <1>  mov rsi, %1
    84 0000053E [CD17000000000000]  <1>
    85 00000546 BA03000000          <1>  mov edx, %2
    86 0000054B 0F05                <1>  syscall
   779                                  
   780                                      .end:
   781 0000054D 5E                              pop rsi
   782 0000054E 5F                              pop rdi
   783 0000054F 5B                              pop rbx
   784 00000550 5D                              pop rbp
   785 00000551 C3                              ret
   786                                  
   787                                  print_ball:
   788 00000552 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   789 00000559 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   790 00000560 4981C0[000A0000]        	add r8, board
   791                                  
   792 00000567 4C89C9                  	mov rcx, r9
   793 0000056A B850000000              	mov rax, column_cells + 2
   794 0000056F 48F7E9                  	imul rcx
   795                                  	
   796 00000572 4901C0                  	add r8, rax
   797 00000575 41C6004F                	mov byte [r8], char_O
   798 00000579 C3                      	ret
   799                                  
   800                                  	
   801                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   802                                  	
   803                                  
   804                                  
   805                                  
   806                                  ;	Function: print_pallet
   807                                  ; This function moves the pallet in the game
   808                                  ; Arguments: none
   809                                  ;
   810                                  ; Return;
   811                                  ;	void
   812                                  print_pallet:
   813 0000057A 4C8B05(3F140000)        	mov r8, [pallet_position]
   814 00000581 488B0D(47140000)        	mov rcx, [pallet_size]
   815                                  	.write_pallet:
   816 00000588 41C6003D                		mov byte [r8], char_equal
   817 0000058C 49FFC0                  		inc r8
   818 0000058F 48FFC9                  		dec rcx
   819 00000592 75F4                    		jnz .write_pallet
   820                                  
   821 00000594 C3                      	ret
   822                                  	
   823                                  ;	Function: move_pallet
   824                                  ; This function is in charge of moving the pallet in a given direction
   825                                  ; Arguments:
   826                                  ;	rdi: left direction or right direction
   827                                  ;
   828                                  ; Return:
   829                                  ;	void
   830                                  move_pallet:
   831                                      
   832 00000595 803D(6F140000)00            cmp byte [ball_moving], 0
   833 0000059C 7507                        jne .continue_movement
   834 0000059E C605(6F140000)01            mov byte [ball_moving], 1
   835                                  
   836                                      .continue_movement:
   837 000005A5 4883FFFF                        cmp rdi, left_direction
   838 000005A9 7531                            jne .move_right
   839                                  
   840                                          .move_left:
   841                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   842 000005AB 4C8B05(3F140000)                    mov r8, [pallet_position]
   843 000005B2 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   844 000005B5 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   845 000005B8 3C58                                cmp al, 'X'        ; Comparar si es una X
   846 000005BA 744D                                je .end            ; Si es X, no mover
   847                                              
   848 000005BC 4C8B05(3F140000)                    mov r8, [pallet_position]
   849 000005C3 4C8B0D(47140000)                    mov r9, [pallet_size]
   850 000005CA 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   851 000005D0 49FFC8                              dec r8
   852 000005D3 4C8905(3F140000)                    mov [pallet_position], r8
   853 000005DA EB2D                                jmp .end
   854                                              
   855                                          .move_right:
   856                                              ; Verificar si la siguiente posición después de la paleta sería una X
   857 000005DC 4C8B05(3F140000)                    mov r8, [pallet_position]
   858 000005E3 4C8B0D(47140000)                    mov r9, [pallet_size]
   859 000005EA 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   860 000005ED 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   861 000005F0 3C58                                cmp al, 'X'        ; Comparar si es una X
   862 000005F2 7415                                je .end            ; Si es X, no mover
   863                                              
   864 000005F4 4C8B05(3F140000)                    mov r8, [pallet_position]
   865 000005FB 41C60020                            mov byte [r8], char_space
   866 000005FF 49FFC0                              inc r8
   867 00000602 4C8905(3F140000)                    mov [pallet_position], r8
   868                                          .end:
   869 00000609 C3                                  ret
   870                                  
   871                                  move_ball:
   872                                      ; Si la bola no está en movimiento, no hacer nada
   873 0000060A 803D(6F140000)00            cmp byte [ball_moving], 0
   874 00000611 0F8406010000                je .end
   875                                  
   876                                      ; Borrar la posición actual de la bola
   877 00000617 4C8B05(4F140000)            mov r8, [ball_x_pos]
   878 0000061E 4C8B0D(57140000)            mov r9, [ball_y_pos]
   879 00000625 4981C0[000A0000]            add r8, board
   880 0000062C 4C89C9                      mov rcx, r9
   881 0000062F B850000000                  mov rax, column_cells + 2
   882 00000634 48F7E9                      imul rcx
   883 00000637 4901C0                      add r8, rax
   884 0000063A 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   885                                  
   886                                      ; Calcular siguiente posición X
   887 0000063E 4C8B05(4F140000)            mov r8, [ball_x_pos]
   888 00000645 4C8B0D(57140000)            mov r9, [ball_y_pos]
   889 0000064C 488B05(5F140000)            mov rax, [ball_direction_x]
   890 00000653 4901C0                      add r8, rax                  ; Nueva posición X
   891                                  
   892                                      ; Calcular la dirección de memoria para la siguiente posición
   893 00000656 4D89C2                      mov r10, r8
   894 00000659 4981C2[000A0000]            add r10, board
   895 00000660 4C89C9                      mov rcx, r9
   896 00000663 B850000000                  mov rax, column_cells + 2
   897 00000668 48F7E9                      imul rcx
   898 0000066B 4901C2                      add r10, rax
   899                                  
   900                                      ; Verificar si hay una X en la siguiente posición X
   901 0000066E 418A02                      mov al, [r10]
   902 00000671 3C58                        cmp al, 'X'
   903 00000673 750C                        jne .check_block_x
   904 00000675 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   905 0000067C E99C000000                  jmp .end
   906                                  
   907                                      .check_block_x:
   908                                          ; Verificar colisión con bloques en X
   909 00000681 4150                            push r8     ; Guardar registros que usa check_block_collision
   910 00000683 4151                            push r9
   911 00000685 4152                            push r10
   912 00000687 E813060000                      call check_block_collision
   913 0000068C 415A                            pop r10
   914 0000068E 4159                            pop r9
   915 00000690 4158                            pop r8
   916 00000692 4885C0                          test rax, rax
   917 00000695 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   918 00000697 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   919 0000069E EB7D                            jmp .end
   920                                  
   921                                      .check_paddle_x:
   922                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   923 000006A0 41803A3D                        cmp byte [r10], char_equal
   924 000006A4 7509                            jne .check_y_movement
   925 000006A6 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   926 000006AD EB6E                            jmp .end
   927                                  
   928                                      .check_y_movement:
   929                                          ; Calcular siguiente posición Y
   930 000006AF 488B05(67140000)                mov rax, [ball_direction_y]
   931 000006B6 4901C1                          add r9, rax                  ; Nueva posición Y
   932                                  
   933                                          ; Calcular la dirección de memoria para la siguiente posición Y
   934 000006B9 4D89C2                          mov r10, r8
   935 000006BC 4981C2[000A0000]                add r10, board
   936 000006C3 4C89C9                          mov rcx, r9
   937 000006C6 B850000000                      mov rax, column_cells + 2
   938 000006CB 48F7E9                          imul rcx
   939 000006CE 4901C2                          add r10, rax
   940                                  
   941                                          ; Verificar si hay una X en la siguiente posición Y
   942 000006D1 418A02                          mov al, [r10]
   943 000006D4 3C58                            cmp al, 'X'
   944 000006D6 7509                            jne .check_block_y
   945 000006D8 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   946 000006DF EB3C                            jmp .end
   947                                  
   948                                      .check_block_y:
   949                                          ; Verificar colisión con bloques en Y
   950 000006E1 4150                            push r8     ; Guardar registros que usa check_block_collision
   951 000006E3 4151                            push r9
   952 000006E5 4152                            push r10
   953 000006E7 E8B3050000                      call check_block_collision
   954 000006EC 415A                            pop r10
   955 000006EE 4159                            pop r9
   956 000006F0 4158                            pop r8
   957 000006F2 4885C0                          test rax, rax
   958 000006F5 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   959 000006F7 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   960 000006FE EB1D                            jmp .end
   961                                  
   962                                      .check_paddle_y:
   963                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   964 00000700 41803A3D                    cmp byte [r10], char_equal
   965 00000704 7509                        jne .update_position
   966 00000706 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   967 0000070D EB0E                        jmp .end
   968                                  
   969                                  
   970                                      .update_position:
   971 0000070F 4C8905(4F140000)                mov [ball_x_pos], r8
   972 00000716 4C890D(57140000)                mov [ball_y_pos], r9
   973                                  
   974                                      .end:
   975 0000071D C3                              ret
   976                                  
   977                                  ; Función para inicializar el nivel
   978                                  ; Función para inicializar el nivel
   979                                  ; Función para mostrar el número de nivel
   980                                  display_level_number:
   981 0000071E 55                          push rbp
   982 0000071F 4889E5                      mov rbp, rsp
   983                                      
   984                                      ; Limpiar la pantalla primero
   985                                      print clear, clear_length
    82 00000722 B801000000          <1>  mov eax, sys_write
    83 00000727 BF01000000          <1>  mov edi, 1
    84 0000072C 48BE-               <1>  mov rsi, %1
    84 0000072E [1000000000000000]  <1>
    85 00000736 BA07000000          <1>  mov edx, %2
    86 0000073B 0F05                <1>  syscall
   986                                      
   987                                      ; Calcular la posición central para el mensaje
   988                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   989 0000073D B84E000000                  mov rax, column_cells
   990 00000742 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   991 00000746 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   992                                      
   993                                      ; Calcular la fila central
   994 00000749 BB20000000                  mov rbx, row_cells
   995 0000074E 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   996                                      
   997                                      ; Calcular el offset en el buffer
   998 00000751 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   999 00000756 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1000 00000759 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1001                                      
  1002                                      ; Escribir "NIVEL " en la posición calculada
  1003 0000075C 488DB8[000A0000]            lea rdi, [board + rax]
  1004 00000763 48BE-                       mov rsi, level_msg
  1004 00000765 [2414000000000000] 
  1005 0000076D B906000000                  mov rcx, level_msg_len
  1006 00000772 F3A4                        rep movsb
  1007                                      
  1008                                      ; Escribir el número del nivel
  1009 00000774 8A05(A4140000)              mov al, [current_level]
  1010 0000077A 0430                        add al, '0'                 ; convertir a ASCII
  1011 0000077C 8807                        mov [rdi], al
  1012                                      
  1013                                      ; Mostrar el board con el mensaje
  1014                                      print board, board_size
    82 0000077E B801000000          <1>  mov eax, sys_write
    83 00000783 BF01000000          <1>  mov edi, 1
    84 00000788 48BE-               <1>  mov rsi, %1
    84 0000078A [000A000000000000]  <1>
    85 00000792 BA000A0000          <1>  mov edx, %2
    86 00000797 0F05                <1>  syscall
  1015                                      
  1016                                      ; Esperar un segundo
  1017 00000799 B823000000                  mov rax, sys_nanosleep
  1018 0000079E 48BF-                       mov rdi, level_display_time
  1018 000007A0 [2F14000000000000] 
  1019 000007A8 4831F6                      xor rsi, rsi
  1020 000007AB 0F05                        syscall
  1021                                      
  1022 000007AD 5D                          pop rbp
  1023 000007AE C3                          ret
  1024                                  
  1025                                  ; Función para inicializar un tablero vacío
  1026                                  init_empty_board:
  1027 000007AF 56                          push rsi
  1028 000007B0 57                          push rdi
  1029 000007B1 51                          push rcx
  1030 000007B2 50                          push rax
  1031                                  
  1032 000007B3 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1033 000007BA 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1034 000007C1 B9000A0000                  mov rcx, board_template_size
  1035 000007C6 F3A4                        rep movsb                   ; Copiar el tablero
  1036                                  
  1037 000007C8 58                          pop rax
  1038 000007C9 59                          pop rcx
  1039 000007CA 5F                          pop rdi
  1040 000007CB 5E                          pop rsi
  1041 000007CC C3                          ret
  1042                                  
  1043                                  
  1044                                  init_level:
  1045                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1046 000007CD C605(35150000)00            mov byte [destroyed_blocks], 0 
  1047 000007D4 E8D6FFFFFF                  call init_empty_board
  1048 000007D9 E840FFFFFF                  call display_level_number
  1049 000007DE E8E5050000                  call init_enemies
  1050                                      
  1051 000007E3 56                          push rsi
  1052 000007E4 57                          push rdi
  1053 000007E5 51                          push rcx
  1054 000007E6 50                          push rax
  1055                                  
  1056 000007E7 488D35(00000000)            lea rsi, [board_template]
  1057 000007EE 488D3D(000A0000)            lea rdi, [board]
  1058 000007F5 B9000A0000                  mov rcx, board_template_size
  1059 000007FA F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1060                                  
  1061 000007FC 58                          pop rax
  1062 000007FD 59                          pop rcx
  1063 000007FE 5F                          pop rdi
  1064 000007FF 5E                          pop rsi
  1065                                  
  1066 00000800 B90A000000                  mov rcx, 10
  1067 00000805 4831C0                      xor rax, rax
  1068 00000808 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1069 0000080F F3AA                        rep stosb      
  1070                                  
  1071                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1072 00000811 803D(A4140000)01            cmp byte [current_level], 1
  1073 00000818 7431                        je .level1
  1074 0000081A 803D(A4140000)02            cmp byte [current_level], 2
  1075 00000821 7454                        je .level2
  1076 00000823 803D(A4140000)03            cmp byte [current_level], 3
  1077 0000082A 7477                        je .level3
  1078 0000082C 803D(A4140000)04            cmp byte [current_level], 4
  1079 00000833 0F8492000000                je .level4
  1080 00000839 803D(A4140000)05            cmp byte [current_level], 5
  1081 00000840 0F84AD000000                je .level5
  1082 00000846 E9D0000000                  jmp .done
  1083                                  
  1084                                  
  1085                                  
  1086                                      .level1:
  1087 0000084B C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1088 00000852 4831C9                          xor rcx, rcx             
  1089                                          .init_loop1:
  1090 00000855 4883F903                            cmp rcx, level1_blocks_count
  1091 00000859 0F8DBC000000                        jge .done
  1092 0000085F 4889C8                              mov rax, rcx         
  1093 00000862 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1094 00000866 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1095 0000086C 8891[C9140000]                      mov byte [block_states + rcx], dl
  1096 00000872 48FFC1                              inc rcx
  1097 00000875 EBDE                                jmp .init_loop1
  1098                                  
  1099                                      .level2:
  1100 00000877 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1101 0000087E 4831C9                          xor rcx, rcx             
  1102                                          .init_loop2:
  1103 00000881 4883F901                            cmp rcx, level2_blocks_count
  1104 00000885 0F8D90000000                        jge .done
  1105 0000088B 4889C8                              mov rax, rcx         
  1106 0000088E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1107 00000892 8A90[B8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1108 00000898 8891[C9140000]                      mov byte [block_states + rcx], dl
  1109 0000089E 48FFC1                              inc rcx
  1110 000008A1 EBDE                                jmp .init_loop2
  1111                                      .level3:
  1112 000008A3 C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1113 000008AA 4831C9                          xor rcx, rcx             
  1114                                          .init_loop3:
  1115 000008AD 4883F901                            cmp rcx, level3_blocks_count
  1116 000008B1 7D68                                jge .done
  1117 000008B3 4889C8                              mov rax, rcx         
  1118 000008B6 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1119 000008BA 8A90[BD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1120 000008C0 8891[C9140000]                      mov byte [block_states + rcx], dl
  1121 000008C6 48FFC1                              inc rcx
  1122 000008C9 EBE2                                jmp .init_loop3
  1123                                  
  1124                                      .level4:
  1125 000008CB C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1126 000008D2 4831C9                          xor rcx, rcx             
  1127                                          .init_loop4:
  1128 000008D5 4883F901                            cmp rcx, level4_blocks_count
  1129 000008D9 7D40                                jge .done
  1130 000008DB 4889C8                              mov rax, rcx         
  1131 000008DE 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1132 000008E2 8A90[C2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1133 000008E8 8891[C9140000]                      mov byte [block_states + rcx], dl
  1134 000008EE 48FFC1                              inc rcx
  1135 000008F1 EBE2                                jmp .init_loop4
  1136                                  
  1137                                      .level5:
  1138 000008F3 C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1139 000008FA 4831C9                          xor rcx, rcx             
  1140                                          .init_loop5:
  1141 000008FD 4883F901                            cmp rcx, level5_blocks_count
  1142 00000901 7D18                                jge .done
  1143 00000903 4889C8                              mov rax, rcx         
  1144 00000906 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1145 0000090A 8A90[C7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1146 00000910 8891[C9140000]                      mov byte [block_states + rcx], dl
  1147 00000916 48FFC1                              inc rcx
  1148 00000919 EBE2                                jmp .init_loop5
  1149                                      .done:
  1150 0000091B C3                              ret
  1151                                  
  1152                                  
  1153                                  ; Función para verificar y manejar la transición de nivel
  1154                                  check_level_complete:
  1155                                      ; Verificar si quedan bloques
  1156 0000091C 803D(A5140000)00            cmp byte [blocks_remaining], 0
  1157 00000923 753C                        jne .not_complete
  1158                                      
  1159                                      ; Incrementar el nivel
  1160 00000925 FE05(A4140000)              inc byte [current_level]
  1161                                      
  1162                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1163 0000092B 803D(A4140000)06            cmp byte [current_level], 6
  1164 00000932 742E                        je game_win
  1165                                      
  1166                                      ; Reinicializar el juego para el siguiente nivel
  1167 00000934 E894FEFFFF                  call init_level
  1168                                      
  1169                                      ; Reinicializar la posición de la bola y la paleta
  1170 00000939 48C705(4F140000)28-         mov qword [ball_x_pos], 40
  1170 00000941 000000             
  1171 00000944 48C705(57140000)1C-         mov qword [ball_y_pos], 28
  1171 0000094C 000000             
  1172 0000094F C605(6F140000)00            mov byte [ball_moving], 0
  1173 00000956 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
  1173 0000095D [38130000]         
  1174                                      
  1175                                      .not_complete:
  1176 00000961 C3                              ret
  1177                                  
  1178                                      ; Nueva función para manejar la victoria del juego
  1179                                  game_win:
  1180                                      ; Limpiar la pantalla primero
  1181                                      print clear, clear_length
    82 00000962 B801000000          <1>  mov eax, sys_write
    83 00000967 BF01000000          <1>  mov edi, 1
    84 0000096C 48BE-               <1>  mov rsi, %1
    84 0000096E [1000000000000000]  <1>
    85 00000976 BA07000000          <1>  mov edx, %2
    86 0000097B 0F05                <1>  syscall
  1182                                      
  1183                                      ; Mensaje de victoria
  1184 0000097D 488B05(2D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1185 00000984 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1185 00000986 [3615000000000000] 
  1186 0000098E E8B4010000                  call number_to_string
  1187                                      
  1188                                      ; Definir mensaje de victoria
  1189                                      section .data
  1190 000017E0 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1190 000017E9 616465732120C2A148-
  1190 000017F2 61732067616E61646F-
  1190 000017FB 210A0D             
  1191                                          win_msg_len: equ $ - win_msg
  1192 000017FE 50756E74616A652066-             score_msg: db "Puntaje final: "
  1192 00001807 696E616C3A20       
  1193                                          score_msg_len: equ $ - score_msg
  1194                                      section .text
  1195                                      
  1196                                      ; Imprimir mensajes
  1197                                      print win_msg, win_msg_len
    82 00000993 B801000000          <1>  mov eax, sys_write
    83 00000998 BF01000000          <1>  mov edi, 1
    84 0000099D 48BE-               <1>  mov rsi, %1
    84 0000099F [E017000000000000]  <1>
    85 000009A7 BA1E000000          <1>  mov edx, %2
    86 000009AC 0F05                <1>  syscall
  1198                                      print score_msg, score_msg_len
    82 000009AE B801000000          <1>  mov eax, sys_write
    83 000009B3 BF01000000          <1>  mov edi, 1
    84 000009B8 48BE-               <1>  mov rsi, %1
    84 000009BA [FE17000000000000]  <1>
    85 000009C2 BA0F000000          <1>  mov edx, %2
    86 000009C7 0F05                <1>  syscall
  1199                                      print number_buffer, 20
    82 000009C9 B801000000          <1>  mov eax, sys_write
    83 000009CE BF01000000          <1>  mov edi, 1
    84 000009D3 48BE-               <1>  mov rsi, %1
    84 000009D5 [3615000000000000]  <1>
    85 000009DD BA14000000          <1>  mov edx, %2
    86 000009E2 0F05                <1>  syscall
  1200                                      
  1201                                      ; Esperar un momento antes de salir
  1202 000009E4 48C70511F6FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1202 000009ED 0000               
  1203 000009EF 48C7050EF6FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1203 000009F8 0000               
  1204                                      sleeptime
    98 000009FA B823000000          <1>  mov eax, sys_nanosleep
    99 000009FF 48BF-               <1>  mov rdi, timespec
    99 00000A01 [0000000000000000]  <1>
   100 00000A09 31F6                <1>  xor esi, esi
   101 00000A0B 0F05                <1>  syscall
  1205                                      
  1206 00000A0D E913090000                  jmp exit
  1207                                  
  1208                                  ; Función para imprimir los bloques
  1209                                  ; Función modificada para imprimir bloques
  1210                                  
  1211                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1212                                  get_current_level_blocks:
  1213 00000A12 803D(A4140000)01            cmp byte [current_level], 1
  1214 00000A19 7428                        je .level1
  1215 00000A1B 803D(A4140000)02            cmp byte [current_level], 2
  1216 00000A22 7427                        je .level2
  1217 00000A24 803D(A4140000)03            cmp byte [current_level], 3
  1218 00000A2B 7426                        je .level3
  1219 00000A2D 803D(A4140000)04            cmp byte [current_level], 4
  1220 00000A34 7425                        je .level4
  1221 00000A36 803D(A4140000)05            cmp byte [current_level], 5
  1222 00000A3D 7424                        je .level5
  1223                                      ; Si llegamos aquí, hay un error en el nivel
  1224 00000A3F 4831C0                      xor rax, rax
  1225 00000A42 C3                          ret
  1226                                  
  1227                                      .level1:
  1228 00000A43 488D05(A6140000)                lea rax, [level1_blocks]
  1229 00000A4A C3                              ret
  1230                                      .level2:
  1231 00000A4B 488D05(B5140000)                lea rax, [level2_blocks]
  1232 00000A52 C3                              ret
  1233                                      .level3:
  1234 00000A53 488D05(BA140000)                lea rax, [level3_blocks]
  1235 00000A5A C3                              ret
  1236                                      .level4:
  1237 00000A5B 488D05(BF140000)                lea rax, [level4_blocks]
  1238 00000A62 C3                              ret
  1239                                      .level5:
  1240 00000A63 488D05(C4140000)                lea rax, [level5_blocks]
  1241 00000A6A C3                              ret
  1242                                  ; Función para obtener la cantidad de bloques del nivel actual
  1243                                  get_current_level_count:
  1244 00000A6B 803D(A4140000)01            cmp byte [current_level], 1
  1245 00000A72 7428                        je .level1
  1246 00000A74 803D(A4140000)02            cmp byte [current_level], 2
  1247 00000A7B 7425                        je .level2
  1248 00000A7D 803D(A4140000)03            cmp byte [current_level], 3
  1249 00000A84 7422                        je .level3
  1250 00000A86 803D(A4140000)04            cmp byte [current_level], 4
  1251 00000A8D 741F                        je .level4
  1252 00000A8F 803D(A4140000)05            cmp byte [current_level], 5
  1253 00000A96 741C                        je .level5
  1254                                      ; Si llegamos aquí, hay un error en el nivel
  1255 00000A98 4831C0                      xor rax, rax
  1256 00000A9B C3                          ret
  1257                                  
  1258                                      .level1:
  1259 00000A9C B803000000                      mov rax, level1_blocks_count
  1260 00000AA1 C3                              ret
  1261                                      .level2:
  1262 00000AA2 B801000000                      mov rax, level2_blocks_count
  1263 00000AA7 C3                              ret
  1264                                      .level3:
  1265 00000AA8 B801000000                      mov rax, level3_blocks_count
  1266 00000AAD C3                              ret
  1267                                      .level4:
  1268 00000AAE B801000000                      mov rax, level4_blocks_count
  1269 00000AB3 C3                              ret
  1270                                      .level5:
  1271 00000AB4 B801000000                      mov rax, level5_blocks_count
  1272 00000AB9 C3                              ret
  1273                                  
  1274                                  
  1275                                  print_blocks:
  1276 00000ABA 55                          push rbp
  1277 00000ABB 4889E5                      mov rbp, rsp
  1278                                      
  1279                                      ; Obtener puntero a los bloques del nivel actual
  1280 00000ABE E84FFFFFFF                  call get_current_level_blocks
  1281 00000AC3 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1282                                      
  1283                                      ; Obtener cantidad de bloques del nivel actual
  1284 00000AC6 E8A0FFFFFF                  call get_current_level_count
  1285 00000ACB 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1286                                      
  1287 00000ACE 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1288                                      
  1289                                      .print_loop:
  1290 00000AD1 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1291 00000AD4 7D6F                            jge .end
  1292                                          
  1293                                          ; Verificar si el bloque está activo
  1294 00000AD6 490FB68424-                     movzx rax, byte [block_states + r12]
  1294 00000ADB [C9140000]         
  1295 00000ADF 4885C0                          test rax, rax
  1296 00000AE2 745C                            jz .next_block
  1297                                          
  1298                                          ; Obtener posición y tipo del bloque usando r13
  1299 00000AE4 4C89E0                          mov rax, r12
  1300 00000AE7 486BC005                        imul rax, 5
  1301 00000AEB 4C01E8                          add rax, r13
  1302 00000AEE 448A00                          mov r8b, [rax]        ; X position
  1303 00000AF1 448A4801                        mov r9b, [rax + 1]    ; Y position
  1304 00000AF5 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1305                                  
  1306                                          ; El resto de la lógica de impresión permanece igual
  1307 00000AF9 4D0FB6C0                        movzx r8, r8b
  1308 00000AFD 4D0FB6C9                        movzx r9, r9b
  1309 00000B01 4981C0[000A0000]                add r8, board
  1310 00000B08 B850000000                      mov rax, column_cells + 2
  1311 00000B0D 49F7E1                          mul r9
  1312 00000B10 4901C0                          add r8, rax
  1313                                          
  1314 00000B13 B906000000                      mov rcx, block_length
  1315 00000B18 48BE-                           mov rsi, block_type_1
  1315 00000B1A [8014000000000000] 
  1316 00000B22 490FB6C2                        movzx rax, r10b
  1317 00000B26 48FFC8                          dec rax
  1318 00000B29 486BC006                        imul rax, block_length
  1319 00000B2D 4801C6                          add rsi, rax
  1320                                          
  1321                                      .print_block_chars:
  1322 00000B30 8A06                            mov al, [rsi]
  1323 00000B32 418800                          mov [r8], al
  1324 00000B35 48FFC6                          inc rsi
  1325 00000B38 49FFC0                          inc r8
  1326 00000B3B 48FFC9                          dec rcx
  1327 00000B3E 75F0                            jnz .print_block_chars
  1328                                          
  1329                                      .next_block:
  1330 00000B40 49FFC4                          inc r12
  1331 00000B43 EB8C                            jmp .print_loop
  1332                                          
  1333                                      .end:
  1334 00000B45 5D                              pop rbp
  1335 00000B46 C3                              ret
  1336                                  
  1337                                  ; Función para convertir número a string
  1338                                  ; Input: RAX = número a convertir
  1339                                  ; RDI = buffer donde escribir el string
  1340                                  number_to_string:
  1341 00000B47 53                          push rbx
  1342 00000B48 52                          push rdx
  1343 00000B49 56                          push rsi
  1344 00000B4A BB0A000000                  mov rbx, 10          ; Divisor
  1345 00000B4F B900000000                  mov rcx, 0          ; Contador de dígitos
  1346                                      
  1347                                      ; Si el número es 0, manejarlo especialmente
  1348 00000B54 4885C0                      test rax, rax
  1349 00000B57 7509                        jnz .convert_loop
  1350 00000B59 C60730                      mov byte [rdi], '0'
  1351 00000B5C C6470100                    mov byte [rdi + 1], 0
  1352 00000B60 EB20                        jmp .end
  1353                                      
  1354                                      .convert_loop:
  1355 00000B62 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1356 00000B65 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1357 00000B68 80C230                          add dl, '0'     ; Convertir a ASCII
  1358 00000B6B 52                              push rdx        ; Guardar el dígito
  1359 00000B6C 48FFC1                          inc rcx         ; Incrementar contador
  1360 00000B6F 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1361 00000B72 75EE                            jnz .convert_loop
  1362                                          
  1363                                      .write_loop:
  1364 00000B74 5A                              pop rdx         ; Obtener dígito
  1365 00000B75 8817                            mov [rdi], dl   ; Escribir al buffer
  1366 00000B77 48FFC7                          inc rdi         ; Siguiente posición
  1367 00000B7A 48FFC9                          dec rcx         ; Decrementar contador
  1368 00000B7D 75F5                            jnz .write_loop
  1369                                          
  1370 00000B7F C60700                      mov byte [rdi], 0   ; Null terminator
  1371                                      
  1372                                      .end:
  1373 00000B82 5E                          pop rsi
  1374 00000B83 5A                          pop rdx
  1375 00000B84 5B                          pop rbx
  1376 00000B85 C3                          ret
  1377                                  
  1378                                  ; Función para imprimir los labels
  1379                                  print_labels:
  1380 00000B86 55                          push rbp
  1381 00000B87 4889E5                      mov rbp, rsp
  1382                                  
  1383                                      ; Crear buffer temporal
  1384 00000B8A 4883EC20                    sub rsp, 32
  1385                                  
  1386                                      ; Copiar labels a buffer temporal
  1387 00000B8E 4889E7                      mov rdi, rsp
  1388 00000B91 488D35(E2150000)            lea rsi, [score_label]
  1389 00000B98 B917000000                  mov rcx, score_label_len
  1390 00000B9D F3A4                        rep movsb
  1391                                  
  1392                                      ; Convertir score a string
  1393 00000B9F 488B05(2D150000)            mov rax, [current_score]
  1394 00000BA6 48BF-                       mov rdi, number_buffer
  1394 00000BA8 [3615000000000000] 
  1395 00000BB0 E892FFFFFF                  call number_to_string
  1396                                  
  1397                                      ; Calcular longitud del número
  1398 00000BB5 B900000000                  mov rcx, 0
  1399 00000BBA 48BF-                       mov rdi, number_buffer
  1399 00000BBC [3615000000000000] 
  1400                                      .count_loop:
  1401 00000BC4 803C0F00                        cmp byte [rdi + rcx], 0
  1402 00000BC8 7405                            je .count_done
  1403 00000BCA 48FFC1                          inc rcx
  1404 00000BCD EBF5                            jmp .count_loop
  1405                                      .count_done:
  1406                                  
  1407                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1408 00000BCF 4889E7                      mov rdi, rsp
  1409 00000BD2 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1410 00000BD6 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1411 00000BDB 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1412                                      .pad_loop:
  1413 00000BDE 4885F6                          test rsi, rsi
  1414 00000BE1 740B                            jz .pad_done
  1415 00000BE3 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1416 00000BE6 48FFC7                          inc rdi
  1417 00000BE9 48FFCE                          dec rsi
  1418 00000BEC EBF0                            jmp .pad_loop
  1419                                      .pad_done:
  1420                                  
  1421                                      ; Copiar el número
  1422 00000BEE 48BE-                       mov rsi, number_buffer
  1422 00000BF0 [3615000000000000] 
  1423 00000BF8 F3A4                        rep movsb
  1424                                  
  1425                                      ; Imprimir el buffer completo
  1426                                      print rsp, score_label_len
    82 00000BFA B801000000          <1>  mov eax, sys_write
    83 00000BFF BF01000000          <1>  mov edi, 1
    84 00000C04 4889E6              <1>  mov rsi, %1
    85 00000C07 BA17000000          <1>  mov edx, %2
    86 00000C0C 0F05                <1>  syscall
  1427                                  
  1428                                      ; Repetir proceso para bloques destruidos
  1429 00000C0E 4889E7                      mov rdi, rsp
  1430 00000C11 488D35(F9150000)            lea rsi, [blocks_label]
  1431 00000C18 B91B000000                  mov rcx, blocks_label_len
  1432 00000C1D F3A4                        rep movsb
  1433                                  
  1434                                      ; Verificar que el `[` esté en su posición correcta
  1435 00000C1F 4889E7                      mov rdi, rsp
  1436 00000C22 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1437 00000C26 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1438                                  
  1439                                      ; Convertir bloques destruidos a string
  1440 00000C29 480FB605(35150000)          movzx rax, byte [destroyed_blocks]
  1441 00000C31 48BF-                       mov rdi, number_buffer
  1441 00000C33 [3615000000000000] 
  1442 00000C3B E807FFFFFF                  call number_to_string
  1443                                  
  1444                                      ; Calcular longitud del número
  1445 00000C40 B900000000                  mov rcx, 0
  1446 00000C45 48BF-                       mov rdi, number_buffer
  1446 00000C47 [3615000000000000] 
  1447                                      .count_loop2:
  1448 00000C4F 803C0F00                        cmp byte [rdi + rcx], 0
  1449 00000C53 7405                            je .count_done2
  1450 00000C55 48FFC1                          inc rcx
  1451 00000C58 EBF5                            jmp .count_loop2
  1452                                      .count_done2:
  1453                                  
  1454                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1455 00000C5A 4889E7                      mov rdi, rsp
  1456 00000C5D 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1457 00000C61 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1458 00000C66 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1459                                      .pad_loop2:
  1460 00000C69 4885F6                          test rsi, rsi
  1461 00000C6C 740B                            jz .pad_done2
  1462 00000C6E C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1463 00000C71 48FFC7                          inc rdi
  1464 00000C74 48FFCE                          dec rsi
  1465 00000C77 EBF0                            jmp .pad_loop2
  1466                                      .pad_done2:
  1467                                  
  1468                                      ; Copiar el número
  1469 00000C79 48BE-                       mov rsi, number_buffer
  1469 00000C7B [3615000000000000] 
  1470 00000C83 F3A4                        rep movsb
  1471                                  
  1472                                      ; Imprimir el buffer completo
  1473                                      print rsp, blocks_label_len
    82 00000C85 B801000000          <1>  mov eax, sys_write
    83 00000C8A BF01000000          <1>  mov edi, 1
    84 00000C8F 4889E6              <1>  mov rsi, %1
    85 00000C92 BA1B000000          <1>  mov edx, %2
    86 00000C97 0F05                <1>  syscall
  1474                                  
  1475                                      ; Restaurar stack
  1476 00000C99 4883C420                    add rsp, 32
  1477 00000C9D 5D                          pop rbp
  1478 00000C9E C3                          ret
  1479                                  
  1480                                  
  1481                                  ; Función modificada para detectar colisión
  1482                                  ; Función mejorada para detectar colisión y manejar la física
  1483                                  ; Función corregida para manejar colisiones con bloques completos
  1484                                  ;---------------------------------------------------------
  1485                                  ; check_block_collision:
  1486                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1487                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1488                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1489                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1490                                  ;   retorna 0.
  1491                                  ;---------------------------------------------------------
  1492                                  ;--------------------------------------
  1493                                  ; check_block_collision
  1494                                  ;--------------------------------------
  1495                                  ; Actualizar check_block_collision para usar el nivel actual
  1496                                  check_block_collision:
  1497 00000C9F 55                          push rbp
  1498 00000CA0 4889E5                      mov rbp, rsp
  1499                                  
  1500                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1501 00000CA3 418A02                      mov al, [r10]
  1502                                  
  1503                                      ; Verificar si el carácter es un bloque
  1504 00000CA6 3C55                        cmp al, 'U'  
  1505 00000CA8 7419                        je .possible
  1506 00000CAA 3C4F                        cmp al, 'O'  
  1507 00000CAC 7415                        je .possible
  1508 00000CAE 3C44                        cmp al, 'D'  
  1509 00000CB0 7411                        je .possible
  1510 00000CB2 3C4C                        cmp al, 'L'  
  1511 00000CB4 740D                        je .possible
  1512 00000CB6 3C56                        cmp al, 'V'  
  1513 00000CB8 7409                        je .possible
  1514 00000CBA 3C38                        cmp al, '8'  
  1515 00000CBC 7405                        je .possible
  1516                                  
  1517                                      ; No es bloque, salir
  1518 00000CBE 4831C0                      xor rax, rax
  1519 00000CC1 5D                          pop rbp
  1520 00000CC2 C3                          ret
  1521                                  
  1522                                  .possible:
  1523 00000CC3 53                          push rbx
  1524 00000CC4 57                          push rdi
  1525 00000CC5 56                          push rsi
  1526 00000CC6 4154                        push r12
  1527 00000CC8 4155                        push r13
  1528 00000CCA 4156                        push r14
  1529 00000CCC 4157                        push r15
  1530                                  
  1531                                      ; 1) Obtener base de los bloques del nivel actual
  1532 00000CCE E83FFDFFFF                  call get_current_level_blocks
  1533 00000CD3 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1534                                  
  1535                                      ; 2) Obtener la cantidad de bloques
  1536 00000CD6 E890FDFFFF                  call get_current_level_count
  1537 00000CDB 4989C6                      mov r14, rax
  1538                                  
  1539 00000CDE 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1540                                  
  1541                                  .find_block_loop:
  1542 00000CE1 4D39F4                      cmp r12, r14
  1543 00000CE4 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1544                                  
  1545                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1546 00000CEA 4C89E0                      mov rax, r12
  1547 00000CED 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1548 00000CF1 4C01E8                      add rax, r13
  1549 00000CF4 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1550                                  
  1551                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1552 00000CF7 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1552 00000CFC [C9140000]         
  1553 00000D00 4885DB                      test rbx, rbx
  1554 00000D03 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1555                                  
  1556                                      ; Obtener coordenadas
  1557 00000D09 418A17                      mov dl, [r15]         ; x
  1558 00000D0C 418A4F01                    mov cl, [r15 + 1]     ; y
  1559                                  
  1560                                      ; Calcular posición en el board
  1561 00000D10 488D3D(000A0000)            lea rdi, [board]
  1562 00000D17 4831C0                      xor rax, rax
  1563 00000D1A B84E000000                  mov rax, column_cells
  1564 00000D1F 4883C002                    add rax, 2
  1565 00000D23 480FB6C9                    movzx rcx, cl         ; y
  1566 00000D27 480FAFC1                    imul rax, rcx
  1567 00000D2B 4801C7                      add rdi, rax
  1568 00000D2E 480FB6C2                    movzx rax, dl         ; x
  1569 00000D32 4801C7                      add rdi, rax
  1570                                  
  1571                                      ; Guardar la posición base del bloque
  1572 00000D35 57                          push rdi
  1573                                  
  1574                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1575 00000D36 4939FA                      cmp r10, rdi
  1576 00000D39 7274                        jb .skip_collision
  1577 00000D3B 488D5F06                    lea rbx, [rdi + block_length]
  1578 00000D3F 4939DA                      cmp r10, rbx
  1579 00000D42 736B                        jae .skip_collision
  1580                                  
  1581                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1582 00000D44 41FE8C24[C9140000]          dec byte [block_states + r12]
  1583                                      ; Volver a cargar durabilidad
  1584 00000D4C 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1584 00000D51 [C9140000]         
  1585 00000D55 4885DB                      test rbx, rbx
  1586 00000D58 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1587                                  
  1588                                      ; >>> Llegó a 0 => Bloque destruido
  1589 00000D5A 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1590 00000D5B B906000000                  mov rcx, block_length
  1591                                  .clear_loop:
  1592 00000D60 C60720                      mov byte [rdi], ' '
  1593 00000D63 48FFC7                      inc rdi
  1594 00000D66 E2F8                        loop .clear_loop
  1595                                  
  1596                                      ; Dibujar letra del bloque destruido
  1597 00000D68 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1598 00000D6C 4883EF06                    sub rdi, block_length
  1599 00000D70 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1600                                      ; Después de escribir la letra en el tablero
  1601 00000D72 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1602 00000D76 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1603 00000D7A 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1604 00000D7F E822F6FFFF                  call register_letter
  1605                                      ; Actualizar contadores globales
  1606 00000D84 FE0D(A5140000)              dec byte [blocks_remaining]
  1607 00000D8A FE05(35150000)              inc byte [destroyed_blocks]
  1608                                  
  1609                                      ; Sumar puntos según el tipo
  1610 00000D90 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1611 00000D95 486BC00A                    imul rax, 10
  1612 00000D99 480105(2D150000)            add [current_score], rax
  1613                                  
  1614 00000DA0 B801000000                  mov rax, 1  ; colisión con destrucción
  1615 00000DA5 EB14                        jmp .end_pop
  1616                                  
  1617                                  .update_display:
  1618                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1619 00000DA7 B801000000                  mov rax, 1  ; colisión con "rebote"  
  1620 00000DAC 5F                          pop rdi     ; pop que quedó pendiente
  1621 00000DAD EB0C                        jmp .end_pop
  1622                                  
  1623                                  .skip_collision:
  1624 00000DAF 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1625                                  .next_block:
  1626 00000DB0 49FFC4                      inc r12
  1627 00000DB3 E929FFFFFF                  jmp .find_block_loop
  1628                                  
  1629                                  .no_block_found:
  1630 00000DB8 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1631                                  
  1632                                  .end_pop:
  1633 00000DBB 415F                        pop r15
  1634 00000DBD 415E                        pop r14
  1635 00000DBF 415D                        pop r13
  1636 00000DC1 415C                        pop r12
  1637 00000DC3 5E                          pop rsi
  1638 00000DC4 5F                          pop rdi
  1639 00000DC5 5B                          pop rbx
  1640 00000DC6 5D                          pop rbp
  1641 00000DC7 C3                          ret
  1642                                  
  1643                                  
  1644                                  
  1645                                  init_enemies:
  1646 00000DC8 55                          push rbp
  1647 00000DC9 4889E5                      mov rbp, rsp
  1648                                      ; Reiniciar contadores de movimiento
  1649 00000DCC C605(78150000)00            mov byte [enemy_move_total], 0
  1650 00000DD3 C605(79150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1651                                      ; Limpiar estado previo de enemigos
  1652 00000DDA B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1653 00000DDF 488D3D(4F150000)            lea rdi, [enemies]
  1654 00000DE6 30C0                        xor al, al
  1655 00000DE8 F3AA                        rep stosb ; Limpiar datos de enemigos
  1656                                      
  1657                                      ; Marcar todos los enemigos como inactivos
  1658 00000DEA 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1659 00000DF1 30C0                        xor al, al
  1660 00000DF3 B90A000000                  mov rcx, 10
  1661 00000DF8 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1662                                  
  1663 00000DFA 5D                          pop rbp
  1664 00000DFB C3                          ret
  1665                                  
  1666                                  
  1667                                  ; Función para mover enemigos
  1668                                  move_enemies:
  1669 00000DFC 55                          push rbp
  1670 00000DFD 4889E5                      mov rbp, rsp
  1671                                      
  1672                                      ; Incrementar contador de movimiento
  1673 00000E00 FE05(76150000)              inc byte [enemy_move_counter]
  1674 00000E06 480FB605(76150000)          movzx rax, byte [enemy_move_counter]
  1675 00000E0E 3A05(77150000)              cmp al, [enemy_move_delay]
  1676 00000E14 0F85AA010000                jne .end
  1677                                      
  1678                                      ; Resetear contador
  1679 00000E1A C605(76150000)00            mov byte [enemy_move_counter], 0
  1680                                      
  1681 00000E21 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1682                                      
  1683                                      .enemy_loop:
  1684 00000E24 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1685 00000E28 0F8D96010000                    jge .end
  1686                                          
  1687                                          ; Calcular offset del enemigo actual
  1688 00000E2E 4C89E0                          mov rax, r12
  1689 00000E31 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1690 00000E35 488DB0[4F150000]                lea rsi, [enemies + rax]
  1691                                          
  1692                                          ; Verificar si el enemigo está activo
  1693 00000E3C 807E0201                        cmp byte [rsi + 2], 1
  1694 00000E40 0F8576010000                    jne .next_enemy
  1695                                          
  1696                                          ; Obtener posición actual
  1697 00000E46 4C0FB606                        movzx r8, byte [rsi]            ; X
  1698 00000E4A 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1699                                          
  1700                                          ; Limpiar posición actual antes de mover
  1701 00000E4F 4150                            push r8
  1702 00000E51 4151                            push r9
  1703 00000E53 B84E000000                      mov rax, column_cells
  1704 00000E58 4883C002                        add rax, 2
  1705 00000E5C 49F7E1                          mul r9
  1706 00000E5F 4C01C0                          add rax, r8
  1707 00000E62 488DB8[000A0000]                lea rdi, [board + rax]
  1708 00000E69 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1709 00000E6C 4159                            pop r9
  1710 00000E6E 4158                            pop r8
  1711                                  
  1712                                          ; Determinar comportamiento basado en índice
  1713 00000E70 4C89E0                          mov rax, r12
  1714 00000E73 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1715 00000E77 4885C0                          test rax, rax
  1716 00000E7A 7402                            jz .chase_ball
  1717 00000E7C EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1718                                          
  1719                                          ; Perseguir bola (comportamiento original)
  1720                                      .chase_ball:
  1721 00000E7E 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1722 00000E85 4D39D0                          cmp r8, r10
  1723 00000E88 0F8F96000000                    jg .move_left
  1724 00000E8E 0F8C95000000                    jl .move_right
  1725                                          
  1726 00000E94 4C8B15(57140000)                mov r10, [ball_y_pos]
  1727 00000E9B 4D39D1                          cmp r9, r10
  1728 00000E9E 0F8F8A000000                    jg .move_up
  1729 00000EA4 0F8C89000000                    jl .move_down
  1730 00000EAA E9A5000000                      jmp .check_collision
  1731                                          
  1732                                      .chase_paddle:
  1733                                          ; Obtener la posición X actual de la paleta
  1734 00000EAF 4C8B15(3F140000)                mov r10, [pallet_position]
  1735 00000EB6 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1736                                          
  1737                                          ; Calcular la posición X real de la paleta
  1738 00000EBD 4C89D0                          mov rax, r10
  1739 00000EC0 BB4E000000                      mov rbx, column_cells
  1740 00000EC5 4883C302                        add rbx, 2                  ; Añadir newline chars
  1741 00000EC9 4831D2                          xor rdx, rdx
  1742 00000ECC 48F7F3                          div rbx                     ; rax = y, rdx = x
  1743                                          
  1744                                          ; rdx ahora contiene la posición X de la paleta
  1745                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1746 00000ECF 488B0D(47140000)                mov rcx, [pallet_size]
  1747 00000ED6 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1748 00000ED9 4801CA                          add rdx, rcx
  1749                                          
  1750                                          ; Comparar con posición X del enemigo y mover gradualmente
  1751 00000EDC 4939D0                          cmp r8, rdx
  1752 00000EDF 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1753 00000EE1 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1754 00000EE3 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1755                                  
  1756                                      .check_y_paddle:
  1757                                          ; La Y de la paleta siempre es row_cells - 2
  1758 00000EE5 41BA20000000                    mov r10, row_cells
  1759 00000EEB 4983EA02                        sub r10, 2
  1760                                          
  1761                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1762 00000EEF 4D39D1                          cmp r9, r10
  1763 00000EF2 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1764 00000EF4 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1765 00000EF6 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1766                                          
  1767                                      .no_movement:
  1768 00000EF8 EB5A                            jmp .check_collision
  1769                                  
  1770                                      ; También agregar una nueva sección para el movimiento suave
  1771                                      .smooth_transition:
  1772                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1773 00000EFA 8A05(79150000)                  mov al, [enemy_target]
  1774 00000F00 84C0                            test al, al
  1775 00000F02 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1776                                          
  1777                                          ; Verificar distancia en X
  1778 00000F04 4989D2                          mov r10, rdx              ; Posición X objetivo
  1779 00000F07 4D29C2                          sub r10, r8               ; Calcular diferencia
  1780 00000F0A 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1781 00000F0E 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1782 00000F10 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1783 00000F14 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1784 00000F16 EB3C                            jmp .check_collision
  1785                                          
  1786                                      .limit_right_movement:
  1787 00000F18 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1788 00000F1C EB36                            jmp .check_collision
  1789                                          
  1790                                      .limit_left_movement:
  1791 00000F1E 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1792 00000F22 EB30                            jmp .check_collision
  1793                                      .move_left:
  1794 00000F24 49FFC8                          dec r8
  1795 00000F27 EB0F                            jmp .check_vertical
  1796                                          
  1797                                      .move_right:
  1798 00000F29 49FFC0                          inc r8
  1799 00000F2C EB0A                            jmp .check_vertical
  1800                                          
  1801                                      .move_up:
  1802 00000F2E 49FFC9                          dec r9
  1803 00000F31 EB21                            jmp .check_collision
  1804                                          
  1805                                      .move_down:
  1806 00000F33 49FFC1                          inc r9
  1807 00000F36 EB1C                            jmp .check_collision
  1808                                          
  1809                                      .check_vertical:
  1810 00000F38 8A05(79150000)                  mov al, [enemy_target]
  1811 00000F3E 84C0                            test al, al
  1812 00000F40 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1813 00000F46 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1814 00000F4D 4D39D1                          cmp r9, r10
  1815 00000F50 7FDC                            jg .move_up
  1816 00000F52 7CDF                            jl .move_down
  1817                                          
  1818                                      .check_collision:
  1819                                          ; Verificar colisión con bordes
  1820 00000F54 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1821 00000F58 7E62                            jle .next_enemy
  1822 00000F5A 4983F84E                        cmp r8, column_cells
  1823 00000F5E 7D5C                            jge .next_enemy
  1824 00000F60 4983F901                        cmp r9, 1                       ; Borde superior
  1825 00000F64 7E56                            jle .next_enemy
  1826 00000F66 4983F920                        cmp r9, row_cells
  1827 00000F6A 7D50                            jge .next_enemy
  1828                                          
  1829                                          ; Verificar colisión con bloques antes de moverse
  1830 00000F6C 4150                            push r8
  1831 00000F6E 4151                            push r9
  1832 00000F70 4152                            push r10
  1833                                          
  1834                                          ; Calcular posición en el tablero para verificar
  1835 00000F72 B84E000000                      mov rax, column_cells
  1836 00000F77 4883C002                        add rax, 2
  1837 00000F7B 49F7E1                          mul r9
  1838 00000F7E 4C01C0                          add rax, r8
  1839 00000F81 4C8D90[000A0000]                lea r10, [board + rax]
  1840                                          
  1841                                          ; Verificar si hay un bloque en la nueva posición
  1842 00000F88 418A02                          mov al, [r10]
  1843 00000F8B 3C55                            cmp al, 'U'
  1844 00000F8D 7427                            je .invalid_move
  1845 00000F8F 3C4F                            cmp al, 'O'
  1846 00000F91 7423                            je .invalid_move
  1847 00000F93 3C44                            cmp al, 'D'
  1848 00000F95 741F                            je .invalid_move
  1849 00000F97 3C4C                            cmp al, 'L'
  1850 00000F99 741B                            je .invalid_move
  1851 00000F9B 3C56                            cmp al, 'V'
  1852 00000F9D 7417                            je .invalid_move
  1853 00000F9F 3C38                            cmp al, '8'
  1854 00000FA1 7413                            je .invalid_move
  1855 00000FA3 3C58                            cmp al, 'X'
  1856 00000FA5 740F                            je .invalid_move
  1857                                          
  1858 00000FA7 415A                            pop r10
  1859 00000FA9 4159                            pop r9
  1860 00000FAB 4158                            pop r8
  1861                                          
  1862                                          ; Guardar nueva posición si es válida
  1863 00000FAD 448806                          mov [rsi], r8b
  1864 00000FB0 44884E01                        mov [rsi + 1], r9b
  1865 00000FB4 EB06                            jmp .next_enemy
  1866                                          
  1867                                      .invalid_move:
  1868 00000FB6 415A                            pop r10
  1869 00000FB8 4159                            pop r9
  1870 00000FBA 4158                            pop r8
  1871                                          
  1872                                      .next_enemy:
  1873 00000FBC 49FFC4                          inc r12
  1874 00000FBF E960FEFFFF                      jmp .enemy_loop
  1875                                          
  1876                                      .end:
  1877 00000FC4 5D                              pop rbp
  1878 00000FC5 C3                              ret
  1879                                  
  1880                                  get_current_spawn_points:
  1881 00000FC6 55                          push rbp
  1882 00000FC7 4889E5                      mov rbp, rsp
  1883                                      
  1884 00000FCA 480FB605(A4140000)          movzx rax, byte [current_level]
  1885 00000FD2 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1886 00000FD5 488B04C5[AD150000]          mov rax, [spawn_points_table + rax * 8]
  1887                                      
  1888 00000FDD 5D                          pop rbp
  1889 00000FDE C3                          ret
  1890                                  
  1891                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1892                                  check_enemy_spawn:
  1893 00000FDF 55                          push rbp
  1894 00000FE0 4889E5                      mov rbp, rsp
  1895                                      
  1896                                      ; Obtener spawn points del nivel actual
  1897 00000FE3 E8DEFFFFFF                  call get_current_spawn_points
  1898 00000FE8 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1899                                      
  1900                                      ; Obtener cantidad de bloques destruidos
  1901 00000FEB 4C0FB62D(35150000)          movzx r13, byte [destroyed_blocks]
  1902                                      
  1903                                      ; Verificar cada punto de spawn
  1904 00000FF3 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1905                                      
  1906                                      .check_loop:
  1907 00000FF6 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1908 00000FFA 7D4B                            jge .end
  1909                                          
  1910                                          ; Verificar si este spawn point ya fue usado
  1911 00000FFC 80B9[D8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1912 00001003 743D                            je .next_enemy
  1913                                          
  1914                                          ; Verificar si este enemigo ya está activo
  1915 00001005 4889C8                          mov rax, rcx
  1916 00001008 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1917 0000100C 488DB0[4F150000]                lea rsi, [enemies + rax]
  1918 00001013 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1919 00001017 7429                            je .next_enemy
  1920                                          
  1921                                          ; Verificar si debemos spawnear este enemigo
  1922 00001019 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1923 0000101E 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1924 00001021 751F                            jne .next_enemy
  1925                                          
  1926                                          ; Marcar este spawn point como usado
  1927 00001023 C681[D8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1928                                          
  1929                                          ; Spawner nuevo enemigo
  1930 0000102A C60628                          mov byte [rsi], 40             ; X inicial
  1931 0000102D C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1932 00001031 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1933                                          
  1934                                          ; Inicializar comportamiento
  1935 00001035 4889C8                          mov rax, rcx
  1936 00001038 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1937 0000103C 8805(D7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1938                                          
  1939                                      .next_enemy:
  1940 00001042 48FFC1                          inc rcx
  1941 00001045 EBAF                            jmp .check_loop
  1942                                          
  1943                                      .end:
  1944 00001047 5D                              pop rbp
  1945 00001048 C3                              ret
  1946                                  
  1947                                  
  1948                                  ; Función para dibujar enemigos
  1949                                  print_enemies:
  1950 00001049 55                          push rbp
  1951 0000104A 4889E5                      mov rbp, rsp
  1952                                      
  1953 0000104D 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1954                                      
  1955                                      .print_loop:
  1956 00001050 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1957 00001054 7D4B                            jge .end
  1958                                          
  1959                                          ; Calcular offset del enemigo actual
  1960 00001056 4C89E0                          mov rax, r12
  1961 00001059 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1962 0000105D 488DB0[4F150000]                lea rsi, [enemies + rax]
  1963                                          
  1964                                          ; Verificar si el enemigo está activo
  1965 00001064 807E0201                        cmp byte [rsi + 2], 1
  1966 00001068 7532                            jne .next_enemy
  1967                                          
  1968                                          ; Calcular posición en el tablero
  1969 0000106A 4C0FB606                        movzx r8, byte [rsi]            ; X
  1970 0000106E 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1971                                          
  1972                                          ; Calcular offset en el tablero
  1973 00001073 B84E000000                      mov rax, column_cells
  1974 00001078 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1975 0000107C 49F7E1                          mul r9
  1976 0000107F 4C01C0                          add rax, r8
  1977 00001082 488DB8[000A0000]                lea rdi, [board + rax]
  1978                                          
  1979                                          ; Obtener carácter del enemigo según el nivel
  1980 00001089 480FB605(A4140000)              movzx rax, byte [current_level]
  1981 00001091 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1982 00001094 8A80[4A150000]                  mov al, [enemy_chars + rax]
  1983                                          
  1984                                          ; Dibujar enemigo
  1985 0000109A 8807                            mov [rdi], al
  1986                                          
  1987                                      .next_enemy:
  1988 0000109C 49FFC4                          inc r12
  1989 0000109F EBAF                            jmp .print_loop
  1990                                          
  1991                                      .end:
  1992 000010A1 5D                              pop rbp
  1993 000010A2 C3                              ret
  1994                                  
  1995                                  ; Función para verificar colisión con enemigos
  1996                                  ; Función para verificar colisión con enemigos
  1997                                  check_enemy_collision:
  1998 000010A3 55                          push rbp
  1999 000010A4 4889E5                      mov rbp, rsp
  2000                                      
  2001 000010A7 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2002 000010AA 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2003                                      
  2004                                      .check_loop:
  2005 000010AD 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2006 000010B1 0F8DE9000000                    jge .end
  2007                                          
  2008                                          ; Calcular offset del enemigo actual
  2009 000010B7 4C89E1                          mov rcx, r12
  2010 000010BA 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2011 000010BE 488DB1[4F150000]                lea rsi, [enemies + rcx]
  2012                                          
  2013                                          ; Verificar si el enemigo está activo
  2014 000010C5 807E0201                        cmp byte [rsi + 2], 1
  2015 000010C9 0F85C9000000                    jne .next_enemy
  2016                                          
  2017                                          ; Verificar colisión con la bola
  2018 000010CF 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2019 000010D3 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2020                                          
  2021                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2022 000010D8 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2023 000010DF 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2024                                          
  2025                                          ; Comprobar colisión vertical (misma columna)
  2026 000010E6 4D39C2                          cmp r10, r8
  2027 000010E9 7525                            jne .check_horizontal
  2028 000010EB 4D29CB                          sub r11, r9
  2029 000010EE 4983FB01                        cmp r11, 1
  2030 000010F2 7F1C                            jg .check_horizontal
  2031 000010F4 4983FBFF                        cmp r11, -1
  2032 000010F8 7C16                            jl .check_horizontal
  2033                                          
  2034                                          ; Colisión vertical detectada
  2035 000010FA E8A3000000                      call destroy_enemy
  2036 000010FF 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2037 00001106 B801000000                      mov rax, 1
  2038 0000110B E990000000                      jmp .end
  2039                                          
  2040                                      .check_horizontal:
  2041                                          ; Comprobar colisión horizontal (misma fila)
  2042 00001110 4C8B15(4F140000)                mov r10, [ball_x_pos]
  2043 00001117 4C8B1D(57140000)                mov r11, [ball_y_pos]
  2044 0000111E 4D39CB                          cmp r11, r9
  2045 00001121 7522                            jne .check_paddle
  2046 00001123 4D29C2                          sub r10, r8
  2047 00001126 4983FA01                        cmp r10, 1
  2048 0000112A 7F19                            jg .check_paddle
  2049 0000112C 4983FAFF                        cmp r10, -1
  2050 00001130 7C13                            jl .check_paddle
  2051                                          
  2052                                          ; Colisión horizontal detectada
  2053 00001132 E86B000000                      call destroy_enemy
  2054 00001137 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2055 0000113E B801000000                      mov rax, 1
  2056 00001143 EB5B                            jmp .end
  2057                                          
  2058                                      .check_paddle:
  2059                                          ; Verificar colisión con la paleta
  2060 00001145 4C8B15(3F140000)                mov r10, [pallet_position]
  2061 0000114C 4981EA[000A0000]                sub r10, board
  2062 00001153 4C89D0                          mov rax, r10
  2063 00001156 41BB4E000000                    mov r11, column_cells
  2064 0000115C 4983C302                        add r11, 2
  2065 00001160 4831D2                          xor rdx, rdx
  2066 00001163 49F7F3                          div r11                     ; División para obtener la posición Y
  2067 00001166 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2068                                          
  2069 00001169 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2070                                          
  2071                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2072 00001170 41BD20000000                    mov r13, row_cells
  2073 00001176 4983ED02                        sub r13, 2                 ; Y de la paleta
  2074 0000117A 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2075 0000117D 7519                            jne .next_enemy
  2076                                          
  2077                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2078 0000117F 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2079 00001182 7C14                            jl .next_enemy
  2080                                          
  2081 00001184 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2082 00001187 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2083 0000118A 7F0C                            jg .next_enemy
  2084                                          
  2085                                          ; Si llegamos aquí, hay colisión con la paleta
  2086 0000118C E811000000                      call destroy_enemy        ; Destruir el enemigo
  2087 00001191 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2088 00001196 EB08                            jmp .end
  2089                                          
  2090                                      .next_enemy:
  2091 00001198 49FFC4                          inc r12
  2092 0000119B E90DFFFFFF                      jmp .check_loop
  2093                                          
  2094                                      .end:
  2095 000011A0 5D                              pop rbp
  2096 000011A1 C3                              ret
  2097                                  
  2098                                  ; Función para destruir un enemigo
  2099                                  destroy_enemy:
  2100                                      ; Desactivar enemigo
  2101 000011A2 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2102                                  
  2103                                      ; Sumar puntos por destruir enemigo
  2104 000011A6 488B05(6E150000)            mov rax, [enemy_points]
  2105 000011AD 480105(2D150000)            add [current_score], rax
  2106                                  
  2107                                      ; No tocar bloques destruidos aquí
  2108 000011B4 C3                          ret
  2109                                  
  2110                                  
  2111                                  _start:
  2112 000011B5 E871EFFFFF              	call canonical_off
  2113 000011BA E8F3000000              	call start_screen
  2114 000011BF E809F6FFFF                  call init_level
  2115 000011C4 E8FFFBFFFF                  call init_enemies
  2116 000011C9 EB00                    	jmp .main_loop
  2117                                  	
  2118                                  
  2119                                  	.main_loop:
  2120 000011CB E8B6F9FFFF                      call print_labels
  2121 000011D0 E8E5F8FFFF                      call print_blocks
  2122 000011D5 E89DF2FFFF                      call move_letters
  2123 000011DA E80DF2FFFF                      call print_letters
  2124 000011DF E896F3FFFF              		call print_pallet
  2125 000011E4 E821F4FFFF                      call move_ball
  2126 000011E9 E8F0F0FFFF                      call check_bottom_collision
  2127 000011EE E8EAEFFFFF                      call print_lives
  2128 000011F3 E824F7FFFF                      call check_level_complete
  2129 000011F8 E8E2FDFFFF                      call check_enemy_spawn
  2130 000011FD E8FAFBFFFF                      call move_enemies
  2131 00001202 E89CFEFFFF                      call check_enemy_collision
  2132 00001207 E83DFEFFFF                      call print_enemies
  2133 0000120C E841F3FFFF              		call print_ball
  2134                                  		print board, board_size				
    82 00001211 B801000000          <1>  mov eax, sys_write
    83 00001216 BF01000000          <1>  mov edi, 1
    84 0000121B 48BE-               <1>  mov rsi, %1
    84 0000121D [000A000000000000]  <1>
    85 00001225 BA000A0000          <1>  mov edx, %2
    86 0000122A 0F05                <1>  syscall
  2135                                  		;setnonblocking	
  2136                                  	.read_more:	
  2137                                  		getchar	
    90 0000122C B800000000          <1>  mov rax, sys_read
    91 00001231 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001236 48BE-               <1>  mov rsi, input_char
    92 00001238 [0000000000000000]  <1>
    93 00001240 BA01000000          <1>  mov rdx, 1
    94 00001245 0F05                <1>  syscall
  2138                                  		
  2139 00001247 4883F801                		cmp rax, 1
  2140 0000124B 7532                        	jne .done
  2141                                  		
  2142 0000124D 8A05(00000000)          		mov al,[input_char]
  2143                                  
  2144 00001253 3C61                    		cmp al, 'a'
  2145 00001255 750E                    	    jne .not_left
  2146 00001257 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2147 0000125E E832F3FFFF              		call move_pallet
  2148 00001263 EB1A                    	    jmp .done
  2149                                  		
  2150                                  		.not_left:
  2151 00001265 3C64                    		 	cmp al, 'd'
  2152 00001267 750C                    	    	jne .not_right
  2153 00001269 BF01000000              			mov rdi, right_direction
  2154 0000126E E822F3FFFF              	    	call move_pallet
  2155 00001273 EB0A                        		jmp .done		
  2156                                  
  2157                                  		.not_right:
  2158                                  
  2159 00001275 3C71                        		cmp al, 'q'
  2160 00001277 0F84A8000000                		je exit
  2161                                  
  2162 0000127D EBAD                    			jmp .read_more
  2163                                  		
  2164                                  		.done:	
  2165                                  			;unsetnonblocking		
  2166                                  			sleeptime	
    98 0000127F B823000000          <1>  mov eax, sys_nanosleep
    99 00001284 48BF-               <1>  mov rdi, timespec
    99 00001286 [0000000000000000]  <1>
   100 0000128E 31F6                <1>  xor esi, esi
   101 00001290 0F05                <1>  syscall
  2167                                  			print clear, clear_length
    82 00001292 B801000000          <1>  mov eax, sys_write
    83 00001297 BF01000000          <1>  mov edi, 1
    84 0000129C 48BE-               <1>  mov rsi, %1
    84 0000129E [1000000000000000]  <1>
    85 000012A6 BA07000000          <1>  mov edx, %2
    86 000012AB 0F05                <1>  syscall
  2168 000012AD E919FFFFFF                  		jmp .main_loop
  2169                                  
  2170                                  
  2171                                  
  2172                                  start_screen:
  2173                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000012B2 B801000000          <1>  mov eax, sys_write
    83 000012B7 BF01000000          <1>  mov edi, 1
    84 000012BC 48BE-               <1>  mov rsi, %1
    84 000012BE [1000000000000000]  <1>
    85 000012C6 BA07000000          <1>  mov edx, %2
    86 000012CB 0F05                <1>  syscall
  2174                                      print msg1, msg1_length
    82 000012CD B801000000          <1>  mov eax, sys_write
    83 000012D2 BF01000000          <1>  mov edi, 1
    84 000012D7 48BE-               <1>  mov rsi, %1
    84 000012D9 [1700000000000000]  <1>
    85 000012E1 BA14010000          <1>  mov edx, %2
    86 000012E6 0F05                <1>  syscall
  2175                                      
  2176                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2177                                          getchar                 ; Esperamos una tecla
    90 000012E8 B800000000          <1>  mov rax, sys_read
    91 000012ED BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000012F2 48BE-               <1>  mov rsi, input_char
    92 000012F4 [0000000000000000]  <1>
    93 000012FC BA01000000          <1>  mov rdx, 1
    94 00001301 0F05                <1>  syscall
  2178 00001303 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2179 00001307 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2180                                          
  2181                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001309 B801000000          <1>  mov eax, sys_write
    83 0000130E BF01000000          <1>  mov edi, 1
    84 00001313 48BE-               <1>  mov rsi, %1
    84 00001315 [1000000000000000]  <1>
    85 0000131D BA07000000          <1>  mov edx, %2
    86 00001322 0F05                <1>  syscall
  2182 00001324 C3                          ret
  2183                                  
  2184                                  exit: 
  2185 00001325 E843EEFFFF              	call canonical_on
  2186 0000132A B83C000000              	mov    rax, 60
  2187 0000132F BF00000000                  mov    rdi, 0
  2188 00001334 0F05                        syscall
  2189                                  
