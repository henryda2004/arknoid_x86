     1                                  bits 64;codigo destinado a arcquitectura de 64 bits
     2                                  default rel;configura el uso de direcciones relativas, que son mas flecibles
     3                                  
     4                                  
     5                                  ;RAX: Registro acumulador. Se utiliza generalmente para operaciones aritméticas y como valor de retorno de funciones.
     6                                  ;RBX: Registro base. Generalmente preservado entre llamadas a funciones.
     7                                  ;RCX: Contador. Usado en operaciones de repetición y bucles.
     8                                  ;RDX: Registro de datos. Se usa en operaciones aritméticas complejas y como argumento adicional en llamadas a funciones.
     9                                  ;RDI y RSI: Usados para pasar parámetros en las llamadas a funciones. RDI es el primer argumento, RSI el segundo.
    10                                  ;RBP: Registro base del marco de pila. Usado para rastrear la base del stack frame en funciones.
    11                                  ;RSP: Puntero de pila. Rastrea el tope de la pila.
    12                                  ;R8-R15: Registros adicionales introducidos en x86-64 para proporcionar más flexibilidad.
    13                                  
    14                                  
    15                                  
    16                                  ; definiciones de llamadas al sistema operativo
    17                                  sys_read: equ 0	;equ es como define y estos numeros se basan en la tabla se syscalls de x86
    18                                  sys_write:	equ 1
    19                                  sys_nanosleep:	equ 35
    20                                  sys_time:	equ 201
    21                                  sys_fcntl:	equ 72
    22                                  
    23                                  ;configurcaion de archivo descriptor
    24                                  STDIN_FILENO: equ 0
    25                                  
    26                                  F_SETFL:	equ 0x0004
    27                                  O_NONBLOCK: equ 0x0004
    28                                  
    29                                  ;screen clean definition
    30                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    31                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    32                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    33                                  
    34                                  ;intervalos de tiempo utilizados
    35                                  timespec:
    36 00000000 0000000000000000            tv_sec  dq 0
    37 00000008 002D310100000000            tv_nsec dq 20000000
    38                                  
    39                                  
    40                                  ;This is for cleaning up the screen
    41 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H";27 es el codigo de escape, [2J limpia la pantalla y [H mueve el cursor al inicio
    42                                  clear_length:	equ $-clear
    43                                  	
    44                                  	
    45                                  
    46                                  ; Start Message
    47 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD;salto de linea y retorno de carro
    47 00000020 45434E4F4C4F474943-
    47 00000029 4F20444520434F5354-
    47 00000032 412052494341202020-
    47 0000003B 20202020200A0D     
    48 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    48 0000004B 525155495445435455-
    48 00000054 524120444520434F4D-
    48 0000005D 50555441444F524153-
    48 00000066 204920202020202020-
    48 0000006F 200A0D             
    49 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    49 0000007B 5354554449414E5445-
    49 00000084 3A2048454E5259204E-
    49 0000008D 554E455A2050455245-
    49 00000096 5A2020202020202020-
    49 0000009F 0A0D               
    50 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    50 000000AA 524F4645534F523A20-
    50 000000B3 45524E4553544F2052-
    50 000000BC 495645524120414C56-
    50 000000C5 415241444F20202020-
    50 000000CE 202020200A0D       
    51 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    51 000000DD 524B414E4F49442052-
    51 000000E6 4554524F2020202020-
    51 000000EF 2020200A0D         
    52 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    52 000000FD 524553494F4E452043-
    52 00000106 55414C515549455220-
    52 0000010F 5445434C4120504152-
    52 00000118 4120494E4943494152-
    52 00000121 20202020202020200A-
    52 0000012A 0D                 
    53                                  msg1_length: equ $-msg1;calcula la longitud del mensaje
    54                                  msg2_length: equ $-msg2
    55                                  msg3_length: equ $-msg3
    56                                  msg4_length: equ $-msg4
    57                                  msg5_length: equ $-msg5
    58                                  msg6_length: equ $-msg6
    59                                  
    60                                  ; Usefull macros
    61                                  
    62                                  
    63                                  
    64                                  %macro setnonblocking 0;este macro se encarga de configurar el archivo descriptor para que no bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    65                                  	mov rax, sys_fcntl
    66                                      mov rdi, STDIN_FILENO
    67                                      mov rsi, F_SETFL
    68                                      mov rdx, O_NONBLOCK
    69                                      syscall
    70                                  %endmacro
    71                                  
    72                                  %macro unsetnonblocking 0;este macro se encarga de configurar el archivo descriptor para que bloquee la entrada, se usa para que el programa no termine, ya que si no se presiona ninguna tecla el programa termina
    73                                  	mov rax, sys_fcntl
    74                                      mov rdi, STDIN_FILENO
    75                                      mov rsi, F_SETFL
    76                                      mov rdx, 0
    77                                      syscall
    78                                  %endmacro
    79                                  
    80                                  %macro full_line 0;este macro se encarga de dibujar una linea completa en la pantalla, se usa para dibujar el tablero
    81                                      times column_cells db "X"
    82                                      db 0x0a, 0xD
    83                                  %endmacro
    84                                  
    85                                  %macro hollow_line 0;este macro se encarga de dibujar una linea hueca en la pantalla, se usa para dibujar el tablero
    86                                      db "X"
    87                                      times column_cells-2 db " "
    88                                      db "X", 0x0a, 0xD
    89                                  %endmacro
    90                                  
    91                                  
    92                                  %macro print 2;este se usa para imprimir en pantalla, se encarga de escribir en pantalla
    93                                  	mov eax, sys_write
    94                                  	mov edi, 1 	; stdout
    95                                  	mov rsi, %1
    96                                  	mov edx, %2
    97                                  	syscall
    98                                  %endmacro
    99                                  
   100                                  %macro getchar 0;este se usa para leer una tecla presionada, se encarga de leer una tecla presionada
   101                                  	mov     rax, sys_read
   102                                      mov     rdi, STDIN_FILENO
   103                                      mov     rsi, input_char
   104                                      mov     rdx, 1 ; number of bytes
   105                                      syscall         ;read text input from keyboard
   106                                  %endmacro
   107                                  
   108                                  %macro sleeptime 0;este se usa para dormir el programa por un tiempo determinado, se encarga de dormir el programa por un tiempo determinado
   109                                  	mov eax, sys_nanosleep
   110                                  	mov rdi, timespec
   111                                  	xor esi, esi		; ignore remaining time in case of call interruption
   112                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   113                                  %endmacro
   114                                  
   115                                  
   116                                  
   117                                  global _start;se declara la etiqueta global _start, que es el punto de entrada del programa
   118                                  
   119                                  section .bss;seccion bss, se usa para declarar variables no inicializadas
   120                                  
   121 00000000 ??                      input_char: resb 1;reserva un byte para almacenar la tecla presionada
   122                                  
   123                                  section .data;seccion data, se usa para declarar variables inicializadas
   124                                  
   125                                  	; Guardamos la plantilla del tablero (32 filas)
   126                                      board_template:;se declara la plantilla del tablero, se hace asi porque se necesita dibujar el tablero en pantalla
   127                                          full_line
    81 00000000 58<rep 50h>         <1>  times column_cells db "X"
    82 00000050 0A0D                <1>  db 0x0a, 0xD
   128                                          %rep 30
   129                                          hollow_line
   130                                          %endrep
   129                              <1>  hollow_line
    86 00000052 58                  <2>  db "X"
    87 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000A4 58                  <2>  db "X"
    87 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000000F6 58                  <2>  db "X"
    87 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000148 58                  <2>  db "X"
    87 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000019A 58                  <2>  db "X"
    87 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000001EC 58                  <2>  db "X"
    87 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000023E 58                  <2>  db "X"
    87 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000290 58                  <2>  db "X"
    87 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000002E2 58                  <2>  db "X"
    87 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000334 58                  <2>  db "X"
    87 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000386 58                  <2>  db "X"
    87 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000003D8 58                  <2>  db "X"
    87 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000042A 58                  <2>  db "X"
    87 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000047C 58                  <2>  db "X"
    87 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000004CE 58                  <2>  db "X"
    87 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000520 58                  <2>  db "X"
    87 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000572 58                  <2>  db "X"
    87 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000005C4 58                  <2>  db "X"
    87 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000616 58                  <2>  db "X"
    87 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000668 58                  <2>  db "X"
    87 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000006BA 58                  <2>  db "X"
    87 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000070C 58                  <2>  db "X"
    87 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000075E 58                  <2>  db "X"
    87 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000007B0 58                  <2>  db "X"
    87 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000802 58                  <2>  db "X"
    87 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 00000854 58                  <2>  db "X"
    87 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008A6 58                  <2>  db "X"
    87 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 000008F8 58                  <2>  db "X"
    87 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000094A 58                  <2>  db "X"
    87 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   129                              <1>  hollow_line
    86 0000099C 58                  <2>  db "X"
    87 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    88 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   131                                          full_line
    81 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    82 00000A3E 0A0D                <1>  db 0x0a, 0xD
   132                                      board_template_size: equ $ - board_template;esto calcula el tamaño de la plantilla del tablero
   133                                  
   134                                      ; Espacio real que se usará en la ejecución
   135 00000A40 00<rep A40h>                board: times board_template_size db 0;times sirve para repetir un valor, en este caso se repite el tamaño de la plantilla del tablero
   136                                      board_size: equ board_template_size
   137                                  
   138                                  	; Added for the terminal issue
   139 00001480 00<rep 24h>             	termios:        times 36 db 0;termios es una estructura que se usa para configurar el terminal, se inicializa en 0
   140                                  	stdin:          equ 0;stdin es el archivo descriptor del terminal, se inicializa en 0
   141                                  	ICANON:         equ 1<<1;ICANON es una bandera que se usa para configurar el terminal, se inicializa en 1<<1
   142                                  	ECHO:           equ 1<<3;ECHO es una bandera que se usa para configurar el terminal, se inicializa en 1<<3
   143                                  	VTIME: 			equ 5;VTIME es una bandera que se usa para configurar el terminal, se inicializa en 5
   144                                  	VMIN:			equ 6;VMIN es una bandera que se usa para configurar el terminal, se inicializa en 6
   145                                  	CC_C:			equ 18;CC_C es una bandera que se usa para configurar el terminal, se inicializa en 18
   146                                  
   147                                  section .text
   148                                  canonical_off:;esta funcion se encarga de apagar el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser borrado porque no se necesita
   149 0000012B E86F000000                      call read_stdin_termios
   150                                  
   151                                          ; aqui abajo que pasa es que se apaga el bit de canonical en los flags de modo local, eso significa que se apaga el modo canonico
   152 00000130 50                              push rax
   153 00000131 B802000000                      mov eax, ICANON
   154 00000136 F7D0                            not eax
   155 00000138 2105(8C140000)                  and [termios+12], eax
   156 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   157 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   158 0000014C 58                              pop rax
   159                                  
   160 0000014D E86C000000                      call write_stdin_termios
   161 00000152 C3                              ret
   162                                  
   163                                  echo_off:;esta funcion se encarga de apagar el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se apga porque no se necesita
   164 00000153 E847000000                      call read_stdin_termios
   165                                  
   166                                          ; abajo lo que pasa esque se apaga el bit de echo en los flags de modo local, eso significa que se apaga el eco
   167 00000158 50                              push rax
   168 00000159 B808000000                      mov eax, ECHO
   169 0000015E F7D0                            not eax
   170 00000160 2105(8C140000)                  and [termios+12], eax
   171 00000166 58                              pop rax
   172                                  
   173 00000167 E852000000                      call write_stdin_termios
   174 0000016C C3                              ret
   175                                  
   176                                  canonical_on:;esta funcion se encarga de encender el modo canonico del terminal, el modo canonico es el modo por defecto del terminal y ocupa ser encendido porque se necesita
   177 0000016D E82D000000                      call read_stdin_termios
   178                                  
   179                                          ; esto lo que hace es que prende el bit de canonical en los flags de modo local, eso significa que se prende el modo canonico
   180 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   181 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   182 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   183 00000187 E832000000                      call write_stdin_termios
   184 0000018C C3                              ret
   185                                  
   186                                  echo_on:;esta funcion se encarga de encender el eco del terminal, el eco es el que muestra en pantalla lo que se escribe, se enciende porque se necesita
   187 0000018D E80D000000                      call read_stdin_termios
   188                                  
   189                                          ; set echo bit in local mode flags
   190 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   191                                  
   192 00000199 E820000000                      call write_stdin_termios
   193 0000019E C3                              ret
   194                                  
   195                                  read_stdin_termios:;esta funcion se encarga de leer la configuracion del terminal, lo hace mediante una llamada al sistema
   196 0000019F 50                              push rax
   197 000001A0 53                              push rbx
   198 000001A1 51                              push rcx
   199 000001A2 52                              push rdx
   200                                  
   201 000001A3 B836000000                      mov eax, 36h
   202 000001A8 BB00000000                      mov ebx, stdin
   203 000001AD B901540000                      mov ecx, 5401h
   204 000001B2 BA[80140000]                    mov edx, termios
   205 000001B7 CD80                            int 80h
   206                                  
   207 000001B9 5A                              pop rdx
   208 000001BA 59                              pop rcx
   209 000001BB 5B                              pop rbx
   210 000001BC 58                              pop rax
   211 000001BD C3                              ret
   212                                  
   213                                  write_stdin_termios:;esta funcion se encarga de escribir la configuracion del terminal, lo hace mediante una llamada al sistema
   214 000001BE 50                              push rax
   215 000001BF 53                              push rbx
   216 000001C0 51                              push rcx
   217 000001C1 52                              push rdx
   218                                  
   219 000001C2 B836000000                      mov eax, 36h
   220 000001C7 BB00000000                      mov ebx, stdin
   221 000001CC B902540000                      mov ecx, 5402h
   222 000001D1 BA[80140000]                    mov edx, termios
   223 000001D6 CD80                            int 80h
   224                                  
   225 000001D8 5A                              pop rdx
   226 000001D9 59                              pop rcx
   227 000001DA 5B                              pop rbx
   228 000001DB 58                              pop rax
   229 000001DC C3                              ret
   230                                  
   231                                  
   232                                  char_equal: equ 61;se inicializa el caracter "="
   233                                  char_space: equ 32;se inicializa el caracter " "
   234                                  char_O: equ 79;se inicializa el caracter "O"
   235                                  left_direction: equ -1;se inicializa la direccion izquierda
   236                                  right_direction: equ 1;se inicializa la direccion derecha
   237                                  
   238                                  
   239                                  section .data
   240                                  
   241                                  ; Mensajes para los niveles
   242 000014A4 4E4956454C20                level_msg: db "NIVEL "
   243                                      level_msg_len: equ $ - level_msg
   244 000014AA 31                          level_1_char: db "1"
   245 000014AB 32                          level_2_char: db "2"
   246 000014AC 33                          level_3_char: db "3"
   247 000014AD 34                          level_4_char: db "4"
   248 000014AE 35                          level_5_char: db "5"
   249                                      level_char_len: equ 1
   250                                  
   251                                      ; Timespec para la pausa del mensaje de nivel
   252                                      level_display_time:
   253 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   254 000014B7 0000000000000000                lvl_tv_nsec dq 0
   255                                          
   256 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   257 000014C7 0500000000000000            pallet_size dq 5
   258 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   259 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   260                                  
   261 000014DF 2800000000000000        	ball_x_pos: dq 40
   262 000014E7 1C00000000000000        	ball_y_pos: dq 28
   263 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   264 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   265 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   266 00001500 00                          ball_active db 0
   267                                  
   268 00001501 0000000000000000            ball2_x_pos:        dq 0
   269 00001509 0000000000000000            ball2_y_pos:        dq 0
   270 00001511 0000000000000000            ball2_direction_x:  dq 0
   271 00001519 0000000000000000            ball2_direction_y:  dq 0
   272 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   273 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   274                                  
   275                                      ; -- Pelota 3 --
   276 00001523 0000000000000000            ball3_x_pos:        dq 0
   277 0000152B 0000000000000000            ball3_y_pos:        dq 0
   278 00001533 0000000000000000            ball3_direction_x:  dq 0
   279 0000153B 0000000000000000            ball3_direction_y:  dq 0
   280 00001543 00                          ball3_moving:       db 0
   281 00001544 00                          ball3_active:       db 0
   282                                  
   283                                  
   284                                  ; Definir los límites de la pantalla o área de juego
   285                                      board_top_left_x equ 1
   286                                      board_top_left_y equ 1
   287                                      board_bottom_right_x equ column_cells - 1
   288                                      board_bottom_right_y equ row_cells
   289                                  
   290                                      ; Limites laterales
   291                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   292                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   293                                  
   294                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   295 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   296 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   297                                  
   298                                      ; Definición de tipos de bloques
   299 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   300 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   301 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   302 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   303 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   304 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   305                                      block_length: equ 6        ; Longitud de cada bloque
   306                                  
   307                                      ; Estructura para el nivel actual
   308 00001579 01                          current_level db 1
   309 0000157A 00                          blocks_remaining db 0
   310                                  
   311                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   312                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   313                                      level1_blocks:
   314                                          ; Tercera fila (tipo 3)
   315 0000157B 0105050220                      db 1, 5, 5, 2, ' '   
   316 00001580 0705050220                      db 7, 5, 5, 2, ' '    
   317 00001585 0D05050220                      db 13, 5, 5, 2, ' '   
   318 0000158A 1305050220                      db 19, 5, 5, 2, ' '   
   319 0000158F 1905050220                      db 25, 5, 5, 2, ' '   
   320 00001594 1F05050220                      db 31, 5, 5, 2, ' '   
   321 00001599 2505050220                      db 37, 5, 5, 2, ' '   
   322 0000159E 2B05050220                      db 43, 5, 5, 2, ' '   
   323 000015A3 3105050220                      db 49, 5, 5, 2, ' '   
   324 000015A8 3705050220                      db 55, 5, 5, 2, ' '   
   325 000015AD 3D05050220                      db 61, 5, 5, 2, ' '  
   326 000015B2 4305050220                      db 67, 5, 5, 2, ' '   
   327 000015B7 4905050220                      db 73, 5, 5, 2, ' '   
   328                                  
   329 000015BC 0106040145                      db 1, 6, 4, 1, 'E'   
   330 000015C1 0706020153                      db 7, 6, 2, 1, 'S'    
   331 000015C6 0D06040153                      db 13, 6, 4, 1, 'S'   
   332 000015CB 1306020153                      db 19, 6, 2, 1, 'S'   
   333 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   334 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   335 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   336 000015DF 2B06020143                      db 43, 6, 2, 1, 'C'   
   337 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   338 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   339 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   340 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   341 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   342                                  
   343 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   344 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   345 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   346 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   347 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   348 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   349 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   350 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   351 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   352 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   353 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   354 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   355 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   356                                  
   357 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   358 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   359 00001648 0D08040150                      db 13, 8, 4, 1, 'P'   
   360 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   361 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   362 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   363 0000165C 2508040145                      db 37, 8, 4, 1, 'E'   
   364 00001661 2B08020143                      db 43, 8, 2, 1, 'C'   
   365 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   366 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   367 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   368 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   369 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   370                                  
   371 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   372 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   373 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   374 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   375 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   376 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   377 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   378 000016A2 2B09030120                      db 43, 9, 3, 1, ' '     
   379 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   380 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   381 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   382 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   383 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   384                                  
   385 000016C0 010A040145                      db 1, 10, 4, 1, 'E'   
   386 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   387 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   388 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   389 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   390 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   391 000016DE 250A040143                      db 37, 10, 4, 1, 'C'   
   392 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   393 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   394 000016ED 370A02014C                      db 55, 10, 2, 1, 'L'   
   395 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   396 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   397 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   398                                  
   399                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   400                                  
   401                                      ; Nivel 2: Bloques de prueba
   402                                      level2_blocks:
   403 00001701 0103040120                      db 1, 3, 4, 1, ' '
   404                                  
   405 00001706 0104030120                      db 1, 4, 3, 1, ' '   
   406 0000170B 0704040120                      db 7, 4, 4, 1, ' '   
   407                                                  
   408 00001710 0105020120                      db 1, 5, 2, 1, ' '   
   409 00001715 0705030120                      db 7, 5, 3, 1, ' '
   410 0000171A 0D05040144                      db 13, 5, 4, 1, 'D'
   411                                  
   412 0000171F 0106010120                      db 1, 6, 1, 1, ' '   
   413 00001724 0706020120                      db 7, 6, 2, 1, ' '
   414 00001729 0D06030120                      db 13, 6, 3, 1, ' '
   415 0000172E 1306040120                      db 19, 6, 4, 1, ' '   
   416                                  
   417 00001733 0107040120                      db 1, 7, 4, 1, ' '   
   418 00001738 0707010120                      db 7, 7, 1, 1, ' '
   419 0000173D 0D07020120                      db 13, 7, 2, 1, ' '
   420 00001742 1307030120                      db 19, 7, 3, 1, ' '  
   421 00001747 1907040120                      db 25, 7, 4, 1, ' '   
   422                                  
   423 0000174C 0108030120                      db 1, 8, 3, 1, ' '   
   424 00001751 0708040120                      db 7, 8, 4, 1, ' '
   425 00001756 0D08010120                      db 13, 8, 1, 1, ' '
   426 0000175B 1308020120                      db 19, 8, 2, 1, ' '  
   427 00001760 1908030120                      db 25, 8, 3, 1, ' ' 
   428 00001765 1F08040120                      db 31, 8, 4, 1, ' '   
   429                                  
   430 0000176A 0109020120                      db 1, 9, 2, 1, ' '   
   431 0000176F 0709030120                      db 7, 9, 3, 1, ' '
   432 00001774 0D09040120                      db 13, 9, 4, 1, ' '
   433 00001779 1309010120                      db 19, 9, 1, 1, ' '  
   434 0000177E 1909020120                      db 25, 9, 2, 1, ' ' 
   435 00001783 1F09030143                      db 31, 9, 3, 1, 'C' 
   436 00001788 2509040120                      db 37, 9, 4, 1, ' '   
   437                                  
   438 0000178D 010A010120                      db 1, 10, 1, 1, ' '   
   439 00001792 070A020120                      db 7, 10, 2, 1, ' '
   440 00001797 0D0A030120                      db 13, 10, 3, 1, ' '
   441 0000179C 130A040120                      db 19, 10, 4, 1, ' '  
   442 000017A1 190A010120                      db 25, 10, 1, 1, ' ' 
   443 000017A6 1F0A020120                      db 31, 10, 2, 1, ' ' 
   444 000017AB 250A03014C                      db 37, 10, 3, 1, 'L'  
   445 000017B0 2B0A040120                      db 43, 10, 4, 1, ' '   
   446                                  
   447 000017B5 010B040120                      db 1, 11, 4, 1, ' '   
   448 000017BA 070B010120                      db 7, 11, 1, 1, ' '
   449 000017BF 0D0B020120                      db 13, 11, 2, 1, ' '
   450 000017C4 130B030144                      db 19, 11, 3, 1, 'D'  
   451 000017C9 190B040120                      db 25, 11, 4, 1, ' ' 
   452 000017CE 1F0B010120                      db 31, 11, 1, 1, ' ' 
   453 000017D3 250B020120                      db 37, 11, 2, 1, ' '  
   454 000017D8 2B0B030120                      db 43, 11, 3, 1, ' ' 
   455 000017DD 310B040120                      db 49, 11, 4, 1, ' '   
   456                                  
   457 000017E2 010C030120                      db 1, 12, 3, 1, ' '   
   458 000017E7 070C040120                      db 7, 12, 4, 1, ' '
   459 000017EC 0D0C010120                      db 13, 12, 1, 1, ' '
   460 000017F1 130C020120                      db 19, 12, 2, 1, ' '  
   461 000017F6 190C030120                      db 25, 12, 3, 1, ' ' 
   462 000017FB 1F0C040120                      db 31, 12, 4, 1, ' ' 
   463 00001800 250C010120                      db 37, 12, 1, 1, ' '  
   464 00001805 2B0C020120                      db 43, 12, 2, 1, ' ' 
   465 0000180A 310C030120                      db 49, 12, 3, 1, ' '
   466 0000180F 370C040120                      db 55, 12, 4, 1, ' '   
   467                                  
   468 00001814 010D020120                      db 1, 13, 2, 1, ' '   
   469 00001819 070D030120                      db 7, 13, 3, 1, ' '
   470 0000181E 0D0D040120                      db 13, 13, 4, 1, ' '
   471 00001823 130D010144                      db 19, 13, 1, 1, 'D'  
   472 00001828 190D020120                      db 25, 13, 2, 1, ' ' 
   473 0000182D 1F0D030120                      db 31, 13, 3, 1, ' ' 
   474 00001832 250D040120                      db 37, 13, 4, 1, ' '  
   475 00001837 2B0D010120                      db 43, 13, 1, 1, ' ' 
   476 0000183C 310D020120                      db 49, 13, 2, 1, ' '
   477 00001841 370D030120                      db 55, 13, 3, 1, ' ' 
   478 00001846 3D0D040120                      db 61, 13, 4, 1, ' '   
   479                                  
   480 0000184B 010E010120                      db 1, 14, 1, 1, ' '   
   481 00001850 070E020120                      db 7, 14, 2, 1, ' '
   482 00001855 0D0E030120                      db 13, 14, 3, 1, ' '
   483 0000185A 130E040120                      db 19, 14, 4, 1, ' '  
   484 0000185F 190E010120                      db 25, 14, 1, 1, ' ' 
   485 00001864 1F0E020120                      db 31, 14, 2, 1, ' ' 
   486 00001869 250E030120                      db 37, 14, 3, 1, ' '  
   487 0000186E 2B0E040120                      db 43, 14, 4, 1, ' ' 
   488 00001873 310E010120                      db 49, 14, 1, 1, ' '
   489 00001878 370E020120                      db 55, 14, 2, 1, ' ' 
   490 0000187D 3D0E030120                      db 61, 14, 3, 1, ' '  
   491 00001882 430E040120                      db 67, 14, 4, 1, ' '   
   492                                  
   493 00001887 010F050220                      db 1, 15, 5, 2, ' '   
   494 0000188C 070F050220                      db 7, 15, 5, 2, ' '
   495 00001891 0D0F050220                      db 13, 15, 5, 2, ' '
   496 00001896 130F050220                      db 19, 15, 5, 2, ' '  
   497 0000189B 190F050220                      db 25, 15, 5, 2, ' ' 
   498 000018A0 1F0F050220                      db 31, 15, 5, 2, ' ' 
   499 000018A5 250F050220                      db 37, 15, 5, 2, ' '  
   500 000018AA 2B0F050220                      db 43, 15, 5, 2, ' ' 
   501 000018AF 310F050220                      db 49, 15, 5, 2, ' '
   502 000018B4 370F050220                      db 55, 15, 5, 2, ' ' 
   503 000018B9 3D0F050220                      db 61, 15, 5, 2, ' '  
   504 000018BE 430F050220                      db 67, 15, 5, 2, ' '
   505 000018C3 490F040120                      db 73, 15, 4, 1, ' '   
   506                                         
   507                                  
   508                                      level2_blocks_count equ 91
   509                                  
   510                                      ; Nivel 3
   511                                      level3_blocks:
   512                                  
   513 000018C8 0102010120                      db 1, 2, 1, 1, ' '   
   514 000018CD 0702020120                      db 7, 2, 2, 1, ' '    
   515 000018D2 0D02010120                      db 13, 2, 1, 1, ' '   
   516 000018D7 1302020120                      db 19, 2, 2, 1, ' '   
   517 000018DC 1902010120                      db 25, 2, 1, 1, ' '   
   518 000018E1 1F02020120                      db 31, 2, 2, 1, ' '   
   519 000018E6 2502010120                      db 37, 2, 1, 1, ' '   
   520 000018EB 2B02020120                      db 43, 2, 2, 1, ' '   
   521 000018F0 3102010120                      db 49, 2, 1, 1, ' '   
   522 000018F5 3702020120                      db 55, 2, 2, 1, ' '   
   523 000018FA 3D02010120                      db 61, 2, 1, 1, ' '  
   524 000018FF 4302020120                      db 67, 2, 2, 1, ' '   
   525 00001904 4902010120                      db 73, 2, 1, 1, ' ' 
   526                                  
   527 00001909 0106040120                      db 1, 6, 4, 1, ' '   
   528 0000190E 0706040120                      db 7, 6, 4, 1, ' '    
   529 00001913 0D06040120                      db 13, 6, 4, 1, ' '   
   530 00001918 1306066320                      db 19, 6, 6, 99, ' '   
   531 0000191D 1906066320                      db 25, 6, 6, 99, ' '   
   532 00001922 1F06066320                      db 31, 6, 6, 99, ' '   
   533 00001927 2506066320                      db 37, 6, 6, 99, ' '   
   534 0000192C 2B06066320                      db 43, 6, 6, 99, ' '   
   535 00001931 3106066320                      db 49, 6, 6, 99, ' '   
   536 00001936 3706066320                      db 55, 6, 6, 99, ' '   
   537 0000193B 3D06066320                      db 61, 6, 6, 99, ' '  
   538 00001940 4306066320                      db 67, 6, 6, 99, ' '   
   539 00001945 4906066320                      db 73, 6, 6, 99, ' ' 
   540                                  
   541 0000194A 0108040120                      db 1, 8, 4, 1, ' '   
   542 0000194F 0708030120                      db 7, 8, 3, 1, ' '    
   543 00001954 0D08040120                      db 13, 8, 4, 1, ' '   
   544 00001959 1308030120                      db 19, 8, 3, 1, ' '   
   545 0000195E 1908040120                      db 25, 8, 4, 1, ' '   
   546 00001963 1F08030120                      db 31, 8, 3, 1, ' '   
   547 00001968 2508040120                      db 37, 8, 4, 1, ' '   
   548 0000196D 2B08030120                      db 43, 8, 3, 1, ' '   
   549 00001972 3108040120                      db 49, 8, 4, 1, ' '   
   550 00001977 3708030120                      db 55, 8, 3, 1, ' '   
   551 0000197C 3D08040120                      db 61, 8, 4, 1, ' '  
   552 00001981 4308030120                      db 67, 8, 3, 1, ' '   
   553 00001986 4908040120                      db 73, 8, 4, 1, ' ' 
   554                                  
   555 0000198B 010B066320                      db 1, 11, 6, 99, ' '   
   556 00001990 070B066320                      db 7, 11, 6, 99, ' '    
   557 00001995 0D0B066320                      db 13, 11, 6, 99, ' '   
   558 0000199A 130B066320                      db 19, 11, 6, 99, ' '   
   559 0000199F 190B066320                      db 25, 11, 6, 99, ' '   
   560 000019A4 1F0B066320                      db 31, 11, 6, 99, ' '   
   561 000019A9 250B066320                      db 37, 11, 6, 99, ' '   
   562 000019AE 2B0B066320                      db 43, 11, 6, 99, ' '   
   563 000019B3 310B066320                      db 49, 11, 6, 99, ' '   
   564 000019B8 370B066320                      db 55, 11, 6, 99, ' '   
   565 000019BD 3D0B030144                      db 61, 11, 3, 1, 'D'  
   566 000019C2 430B030120                      db 67, 11, 3, 1, ' '   
   567 000019C7 490B030120                      db 73, 11, 3, 1, ' ' 
   568                                  
   569 000019CC 010D010144                      db 1, 13, 1, 1, 'D'   
   570 000019D1 070D020150                      db 7, 13, 2, 1, 'P'    
   571 000019D6 0D0D010143                      db 13, 13, 1, 1, 'C'   
   572 000019DB 130D020120                      db 19, 13, 2, 1, ' '   
   573 000019E0 190D010120                      db 25, 13, 1, 1, ' '   
   574 000019E5 1F0D020120                      db 31, 13, 2, 1, ' '   
   575 000019EA 250D010120                      db 37, 13, 1, 1, ' '   
   576 000019EF 2B0D020120                      db 43, 13, 2, 1, ' '   
   577 000019F4 310D010120                      db 49, 13, 1, 1, ' '   
   578 000019F9 370D020120                      db 55, 13, 2, 1, ' '   
   579 000019FE 3D0D010120                      db 61, 13, 1, 1, ' '  
   580 00001A03 430D020120                      db 67, 13, 2, 1, ' '   
   581 00001A08 490D010120                      db 73, 13, 1, 1, ' ' 
   582                                  
   583 00001A0D 010F020120                      db 1, 15, 2, 1, ' '   
   584 00001A12 070F020120                      db 7, 15, 2, 1, ' '    
   585 00001A17 0D0F020120                      db 13, 15, 2, 1, ' '   
   586 00001A1C 130F066320                      db 19, 15, 6, 99, ' '   
   587 00001A21 190F066320                      db 25, 15, 6, 99, ' '   
   588 00001A26 1F0F066320                      db 31, 15, 6, 99, ' '   
   589 00001A2B 250F066320                      db 37, 15, 6, 99, ' '   
   590 00001A30 2B0F066320                      db 43, 15, 6, 99, ' '   
   591 00001A35 310F066320                      db 49, 15, 6, 99, ' '   
   592 00001A3A 370F066320                      db 55, 15, 6, 99, ' '   
   593 00001A3F 3D0F066320                      db 61, 15, 6, 99, ' '  
   594 00001A44 430F066320                      db 67, 15, 6, 99, ' '   
   595 00001A49 490F066320                      db 73, 15, 6, 99, ' ' 
   596                                  
   597 00001A4E 0112020120                      db 1, 18, 2, 1, ' '   
   598 00001A53 0712030120                      db 7, 18, 3, 1, ' '    
   599 00001A58 0D12020144                      db 13, 18, 2, 1, 'D'   
   600 00001A5D 1312030120                      db 19, 18, 3, 1, ' '   
   601 00001A62 1912020120                      db 25, 18, 2, 1, ' '   
   602 00001A67 1F12030120                      db 31, 18, 3, 1, ' '   
   603 00001A6C 2512020120                      db 37, 18, 2, 1, ' '   
   604 00001A71 2B12030120                      db 43, 18, 3, 1, ' '   
   605 00001A76 3112020120                      db 49, 18, 2, 1, ' '   
   606 00001A7B 3712030144                      db 55, 18, 3, 1, 'D'   
   607 00001A80 3D12020120                      db 61, 18, 2, 1, ' '  
   608 00001A85 4312030143                      db 67, 18, 3, 1, 'C'   
   609 00001A8A 4912020120                      db 73, 18, 2, 1, ' ' 
   610                                  
   611                                  
   612 00001A8F 0114066320                      db 1, 20, 6, 99, ' '   
   613 00001A94 0714066320                      db 7, 20, 6, 99, ' '    
   614 00001A99 0D14066320                      db 13, 20, 6, 99, ' '   
   615 00001A9E 1314066320                      db 19, 20, 6, 99, ' '   
   616 00001AA3 1914066320                      db 25, 20, 6, 99, ' '   
   617 00001AA8 1F14066320                      db 31, 20, 6, 99, ' '   
   618 00001AAD 2514066320                      db 37, 20, 6, 99, ' '   
   619 00001AB2 2B14066320                      db 43, 20, 6, 99, ' '   
   620 00001AB7 3114066320                      db 49, 20, 6, 99, ' '   
   621 00001ABC 3714066320                      db 55, 20, 6, 99, ' '   
   622 00001AC1 3D14010120                      db 61, 20, 1, 1, ' '  
   623 00001AC6 4314010153                      db 67, 20, 1, 1, 'S'   
   624 00001ACB 4914010143                      db 73, 20, 1, 1, 'C' 
   625                                  
   626                                      level3_blocks_count equ 104
   627                                  
   628                                      ; Nivel 4
   629                                      level4_blocks:
   630                                  
   631 00001AD0 0704010120                      db 7, 4, 1, 1, ' '    
   632 00001AD5 0D04020120                      db 13, 4, 2, 1, ' '   
   633 00001ADA 1304030120                      db 19, 4, 3, 1, ' '   
   634 00001ADF 1904050220                      db 25, 4, 5, 2, ' '   
   635 00001AE4 1F04020120                      db 31, 4, 2, 1, ' '
   636                                  
   637 00001AE9 2B04010120                      db 43, 4, 1, 1, ' '   
   638 00001AEE 3104020120                      db 49, 4, 2, 1, ' '   
   639 00001AF3 3704030144                      db 55, 4, 3, 1, 'D'   
   640 00001AF8 3D04040120                      db 61, 4, 4, 1, ' '  
   641 00001AFD 4304020120                      db 67, 4, 2, 1, ' ' 
   642                                  
   643 00001B02 0705020120                      db 7, 5, 2, 1, ' '    
   644 00001B07 0D05030120                      db 13, 5, 3, 1, ' '   
   645 00001B0C 1305050220                      db 19, 5, 5, 2, ' '   
   646 00001B11 1905020120                      db 25, 5, 2, 1, ' '   
   647 00001B16 1F05010120                      db 31, 5, 1, 1, ' '
   648                                  
   649 00001B1B 2B05020120                      db 43, 5, 2, 1, ' '   
   650 00001B20 3105030120                      db 49, 5, 3, 1, ' '   
   651 00001B25 3705040120                      db 55, 5, 4, 1, ' '   
   652 00001B2A 3D05020120                      db 61, 5, 2, 1, ' '  
   653 00001B2F 4305050220                      db 67, 5, 5, 2, ' '  
   654                                  
   655 00001B34 0706030120                      db 7, 6, 3, 1, ' '    
   656 00001B39 0D06050220                      db 13, 6, 5, 2, ' '   
   657 00001B3E 1306020120                      db 19, 6, 2, 1, ' '   
   658 00001B43 1906010120                      db 25, 6, 1, 1, ' '   
   659 00001B48 1F06020120                      db 31, 6, 2, 1, ' '
   660                                  
   661 00001B4D 2B06030120                      db 43, 6, 3, 1, ' '   
   662 00001B52 3106040120                      db 49, 6, 4, 1, ' '   
   663 00001B57 3706020120                      db 55, 6, 2, 1, ' '   
   664 00001B5C 3D06050220                      db 61, 6, 5, 2, ' '  
   665 00001B61 4306020120                      db 67, 6, 2, 1, ' '
   666                                  
   667 00001B66 0707050220                      db 7, 7, 5, 2, ' '    
   668 00001B6B 0D07020120                      db 13, 7, 2, 1, ' '   
   669 00001B70 1307010120                      db 19, 7, 1, 1, ' '   
   670 00001B75 1907020120                      db 25, 7, 2, 1, ' '   
   671 00001B7A 1F07030120                      db 31, 7, 3, 1, ' '
   672                                  
   673 00001B7F 2B07040120                      db 43, 7, 4, 1, ' '   
   674 00001B84 3107020120                      db 49, 7, 2, 1, ' '   
   675 00001B89 3707050220                      db 55, 7, 5, 2, ' '   
   676 00001B8E 3D07020120                      db 61, 7, 2, 1, ' '  
   677 00001B93 4307030120                      db 67, 7, 3, 1, ' '
   678                                  
   679 00001B98 0708020120                      db 7, 8, 2, 1, ' '    
   680 00001B9D 0D08010120                      db 13, 8, 1, 1, ' '   
   681 00001BA2 1308020120                      db 19, 8, 2, 1, ' '   
   682 00001BA7 1908030120                      db 25, 8, 3, 1, ' '   
   683 00001BAC 1F08040120                      db 31, 8, 4, 1, ' '
   684                                  
   685 00001BB1 2B08020120                      db 43, 8, 2, 1, ' '   
   686 00001BB6 3108050220                      db 49, 8, 5, 2, ' '   
   687 00001BBB 3708020120                      db 55, 8, 2, 1, ' '   
   688 00001BC0 3D08030120                      db 61, 8, 3, 1, ' '  
   689 00001BC5 4308040120                      db 67, 8, 4, 1, ' '
   690                                  
   691 00001BCA 0709010120                      db 7, 9, 1, 1, ' '    
   692 00001BCF 0D09020120                      db 13, 9, 2, 1, ' '   
   693 00001BD4 1309030120                      db 19, 9, 3, 1, ' '   
   694 00001BD9 1909040120                      db 25, 9, 4, 1, ' '   
   695 00001BDE 1F09020120                      db 31, 9, 2, 1, ' '
   696                                  
   697 00001BE3 2B09050220                      db 43, 9, 5, 2, ' '   
   698 00001BE8 3109020120                      db 49, 9, 2, 1, ' '   
   699 00001BED 3709030120                      db 55, 9, 3, 1, ' '   
   700 00001BF2 3D09040120                      db 61, 9, 4, 1, ' '  
   701 00001BF7 4309020120                      db 67, 9, 2, 1, ' '
   702                                  
   703 00001BFC 070A020120                      db 7, 10, 2, 1, ' '    
   704 00001C01 0D0A030120                      db 13, 10, 3, 1, ' '   
   705 00001C06 130A040120                      db 19, 10, 4, 1, ' '   
   706 00001C0B 190A020120                      db 25, 10, 2, 1, ' '   
   707 00001C10 1F0A010120                      db 31, 10, 1, 1, ' '
   708                                  
   709 00001C15 2B0A020120                      db 43, 10, 2, 1, ' '   
   710 00001C1A 310A030120                      db 49, 10, 3, 1, ' '   
   711 00001C1F 370A040120                      db 55, 10, 4, 1, ' '   
   712 00001C24 3D0A020120                      db 61, 10, 2, 1, ' '  
   713 00001C29 430A010120                      db 67, 10, 1, 1, ' '
   714                                  
   715 00001C2E 070B030120                      db 7, 11, 3, 1, ' '   
   716 00001C33 0D0B040120                      db 13, 11, 4, 1, ' '   
   717 00001C38 130B020120                      db 19, 11, 2, 1, ' '   
   718 00001C3D 190B010120                      db 25, 11, 1, 1, ' '  
   719 00001C42 1F0B050220                      db 31, 11, 5, 2, ' '
   720                                  
   721 00001C47 2B0B030120                      db 43, 11, 3, 1, ' '   
   722 00001C4C 310B040120                      db 49, 11, 4, 1, ' '   
   723 00001C51 370B020120                      db 55, 11, 2, 1, ' '   
   724 00001C56 3D0B010120                      db 61, 11, 1, 1, ' '  
   725 00001C5B 430B020120                      db 67, 11, 2, 1, ' '
   726                                  
   727 00001C60 070C040120                      db 7, 12, 4, 1, ' '   
   728 00001C65 0D0C020120                      db 13, 12, 2, 1, ' '   
   729 00001C6A 130C010120                      db 19, 12, 1, 1, ' '   
   730 00001C6F 190C050220                      db 25, 12, 5, 2, ' '  
   731 00001C74 1F0C030120                      db 31, 12, 3, 1, ' '
   732                                  
   733 00001C79 2B0C040120                      db 43, 12, 4, 1, ' '    
   734 00001C7E 310C020120                      db 49, 12, 2, 1, ' '   
   735 00001C83 370C010120                      db 55, 12, 1, 1, ' '   
   736 00001C88 3D0C020120                      db 61, 12, 2, 1, ' '   
   737 00001C8D 430C030120                      db 67, 12, 3, 1, ' '
   738                                  
   739 00001C92 070D020120                      db 7, 13, 2, 1, ' '   
   740 00001C97 0D0D010120                      db 13, 13, 1, 1, ' '   
   741 00001C9C 130D050220                      db 19, 13, 5, 2, ' '   
   742 00001CA1 190D030143                      db 25, 13, 3, 1, 'C'  
   743 00001CA6 1F0D040120                      db 31, 13, 4, 1, ' '
   744                                  
   745 00001CAB 2B0D020120                      db 43, 13, 2, 1, ' '    
   746 00001CB0 310D010120                      db 49, 13, 1, 1, ' '   
   747 00001CB5 370D020120                      db 55, 13, 2, 1, ' '   
   748 00001CBA 3D0D030120                      db 61, 13, 3, 1, ' '   
   749 00001CBF 430D050220                      db 67, 13, 5, 2, ' '
   750                                  
   751 00001CC4 070E010120                      db 7, 14, 1, 1, ' '   
   752 00001CC9 0D0E050220                      db 13, 14, 5, 2, ' '   
   753 00001CCE 130E030120                      db 19, 14, 3, 1, ' '   
   754 00001CD3 190E040120                      db 25, 14, 4, 1, ' '  
   755 00001CD8 1F0E020120                      db 31, 14, 2, 1, ' '
   756                                  
   757 00001CDD 2B0E010120                      db 43, 14, 1, 1, ' '    
   758 00001CE2 310E020120                      db 49, 14, 2, 1, ' '   
   759 00001CE7 370E030120                      db 55, 14, 3, 1, ' '   
   760 00001CEC 3D0E050220                      db 61, 14, 5, 2, ' '   
   761 00001CF1 430E020120                      db 67, 14, 2, 1, ' '
   762                                  
   763 00001CF6 070F050220                      db 7, 15, 5, 2, ' '   
   764 00001CFB 0D0F030120                      db 13, 15, 3, 1, ' '   
   765 00001D00 130F040120                      db 19, 15, 4, 1, ' '   
   766 00001D05 190F020120                      db 25, 15, 2, 1, ' '  
   767 00001D0A 1F0F010120                      db 31, 15, 1, 1, ' '
   768                                  
   769 00001D0F 2B0F020145                      db 43, 15, 2, 1, 'E'    
   770 00001D14 310F03014C                      db 49, 15, 3, 1, 'L'   
   771 00001D19 370F050220                      db 55, 15, 5, 2, ' '   
   772 00001D1E 3D0F020120                      db 61, 15, 2, 1, ' '   
   773 00001D23 430F010120                      db 67, 15, 1, 1, ' '
   774                                  
   775 00001D28 0710030120                      db 7, 16, 3, 1, ' '   
   776 00001D2D 0D10040120                      db 13, 16, 4, 1, ' '   
   777 00001D32 1310020120                      db 19, 16, 2, 1, ' '   
   778 00001D37 1910010120                      db 25, 16, 1, 1, ' '  
   779 00001D3C 1F10020120                      db 31, 16, 2, 1, ' '
   780                                  
   781 00001D41 2B10030120                      db 43, 16, 3, 1, ' '    
   782 00001D46 3110050220                      db 49, 16, 5, 2, ' '   
   783 00001D4B 3710020120                      db 55, 16, 2, 1, ' '   
   784 00001D50 3D10010120                      db 61, 16, 1, 1, ' '   
   785 00001D55 4310020120                      db 67, 16, 2, 1, ' '
   786                                  
   787 00001D5A 0711040120                      db 7, 17, 4, 1, ' '   
   788 00001D5F 0D11020120                      db 13, 17, 2, 1, ' '   
   789 00001D64 1311010120                      db 19, 17, 1, 1, ' '   
   790 00001D69 1911020120                      db 25, 17, 2, 1, ' '  
   791 00001D6E 1F11030120                      db 31, 17, 3, 1, ' '
   792                                  
   793 00001D73 2B11050220                      db 43, 17, 5, 2, ' '    
   794 00001D78 3111020120                      db 49, 17, 2, 1, ' '    
   795 00001D7D 3711010120                      db 55, 17, 1, 1, ' '   
   796 00001D82 3D11020120                      db 61, 17, 2, 1, ' '   
   797 00001D87 4311030120                      db 67, 17, 3, 1, ' '
   798                                  
   799                                      level4_blocks_count equ 140
   800                                  
   801                                      ; Nivel 5
   802                                      level5_blocks:
   803                                  
   804 00001D8C 1303020145                      db 19, 3, 2, 1, 'E'   
   805 00001D91 3703020120                      db 55, 3, 2, 1, ' '   
   806                                  
   807 00001D96 1304020120                      db 19, 4, 2, 1, ' '   
   808 00001D9B 370402014C                      db 55, 4, 2, 1, 'L' 
   809                                  
   810 00001DA0 1905020120                      db 25, 5, 2, 1, ' '   
   811 00001DA5 3105020153                      db 49, 5, 2, 1, 'S'   
   812                                  
   813 00001DAA 1906020120                      db 25, 6, 2, 1, ' '   
   814 00001DAF 3106020120                      db 49, 6, 2, 1, ' '   
   815                                  
   816 00001DB4 1307050220                      db 19, 7, 5, 2, ' '   
   817 00001DB9 1907050220                      db 25, 7, 5, 2, ' '  
   818 00001DBE 1F07050220                      db 31, 7, 5, 2, ' '
   819 00001DC3 2507050220                      db 37, 7, 5, 2, ' '
   820 00001DC8 2B07050220                      db 43, 7, 5, 2, ' '    
   821 00001DCD 3107050220                      db 49, 7, 5, 2, ' '    
   822 00001DD2 3707050220                      db 55, 7, 5, 2, ' '   
   823                                  
   824 00001DD7 1308050220                      db 19, 8, 5, 2, ' '   
   825 00001DDC 1908050220                      db 25, 8, 5, 2, ' '  
   826 00001DE1 1F08050220                      db 31, 8, 5, 2, ' '
   827 00001DE6 2508050220                      db 37, 8, 5, 2, ' '
   828 00001DEB 2B08050220                      db 43, 8, 5, 2, ' '    
   829 00001DF0 3108050220                      db 49, 8, 5, 2, ' '    
   830 00001DF5 3708050220                      db 55, 8, 5, 2, ' '   
   831                                  
   832 00001DFA 0D09050220                      db 13, 9, 5, 2, ' '   
   833 00001DFF 1309050220                      db 19, 9, 5, 2, ' '   
   834 00001E04 1909040143                      db 25, 9, 4, 1, 'C'  
   835 00001E09 1F09050220                      db 31, 9, 5, 2, ' '
   836 00001E0E 2509050220                      db 37, 9, 5, 2, ' '
   837 00001E13 2B09050220                      db 43, 9, 5, 2, ' '    
   838 00001E18 3109040144                      db 49, 9, 4, 1, 'D'    
   839 00001E1D 3709050220                      db 55, 9, 5, 2, ' '   
   840 00001E22 3D09050220                      db 61, 9, 5, 2, ' '  
   841                                  
   842 00001E27 0D0A050220                      db 13, 10, 5, 2, ' '   
   843 00001E2C 130A050220                      db 19, 10, 5, 2, ' '   
   844 00001E31 190A040120                      db 25, 10, 4, 1, ' '  
   845 00001E36 1F0A050220                      db 31, 10, 5, 2, ' '
   846 00001E3B 250A050220                      db 37, 10, 5, 2, ' '
   847 00001E40 2B0A050220                      db 43, 10, 5, 2, ' '    
   848 00001E45 310A040120                      db 49, 10, 4, 1, ' '    
   849 00001E4A 370A050220                      db 55, 10, 5, 2, ' '   
   850 00001E4F 3D0A050220                      db 61, 10, 5, 2, ' '   
   851                                          
   852 00001E54 070B050220                      db 7, 11, 5, 2, ' '   
   853 00001E59 0D0B050220                      db 13, 11, 5, 2, ' '   
   854 00001E5E 130B050220                      db 19, 11, 5, 2, ' '   
   855 00001E63 190B050220                      db 25, 11, 5, 2, ' '  
   856 00001E68 1F0B050220                      db 31, 11, 5, 2, ' '
   857 00001E6D 250B050220                      db 37, 11, 5, 2, ' '
   858 00001E72 2B0B050220                      db 43, 11, 5, 2, ' '    
   859 00001E77 310B050220                      db 49, 11, 5, 2, ' '    
   860 00001E7C 370B050220                      db 55, 11, 5, 2, ' '   
   861 00001E81 3D0B050220                      db 61, 11, 5, 2, ' '   
   862 00001E86 430B050220                      db 67, 11, 5, 2, ' '
   863                                  
   864 00001E8B 070C050220                      db 7, 12, 5, 2, ' '   
   865 00001E90 0D0C050220                      db 13, 12, 5, 2, ' '   
   866 00001E95 130C050220                      db 19, 12, 5, 2, ' '   
   867 00001E9A 190C050220                      db 25, 12, 5, 2, ' '  
   868 00001E9F 1F0C050220                      db 31, 12, 5, 2, ' '
   869 00001EA4 250C050220                      db 37, 12, 5, 2, ' '
   870 00001EA9 2B0C050220                      db 43, 12, 5, 2, ' '    
   871 00001EAE 310C050220                      db 49, 12, 5, 2, ' '    
   872 00001EB3 370C050220                      db 55, 12, 5, 2, ' '   
   873 00001EB8 3D0C050220                      db 61, 12, 5, 2, ' '   
   874 00001EBD 430C050220                      db 67, 12, 5, 2, ' '
   875                                  
   876 00001EC2 070D050220                      db 7, 13, 5, 2, ' '   
   877 00001EC7 0D0D050220                      db 13, 13, 5, 2, ' '   
   878 00001ECC 130D050220                      db 19, 13, 5, 2, ' '   
   879 00001ED1 190D050220                      db 25, 13, 5, 2, ' '  
   880 00001ED6 1F0D050220                      db 31, 13, 5, 2, ' '
   881 00001EDB 250D050220                      db 37, 13, 5, 2, ' '
   882 00001EE0 2B0D050220                      db 43, 13, 5, 2, ' '    
   883 00001EE5 310D050220                      db 49, 13, 5, 2, ' '    
   884 00001EEA 370D050220                      db 55, 13, 5, 2, ' '   
   885 00001EEF 3D0D050220                      db 61, 13, 5, 2, ' '   
   886 00001EF4 430D050220                      db 67, 13, 5, 2, ' '
   887                                  
   888                                          
   889 00001EF9 070E050220                      db 7, 14, 5, 2, ' '   
   890 00001EFE 130E050220                      db 19, 14, 5, 2, ' '   
   891 00001F03 190E050220                      db 25, 14, 5, 2, ' '  
   892 00001F08 1F0E050220                      db 31, 14, 5, 2, ' '
   893 00001F0D 250E050220                      db 37, 14, 5, 2, ' '
   894 00001F12 2B0E050220                      db 43, 14, 5, 2, ' '    
   895 00001F17 310E050220                      db 49, 14, 5, 2, ' '    
   896 00001F1C 370E050220                      db 55, 14, 5, 2, ' '   
   897 00001F21 430E050220                      db 67, 14, 5, 2, ' '
   898                                  
   899 00001F26 070F050220                      db 7, 15, 5, 2, ' '   
   900 00001F2B 130F050220                      db 19, 15, 5, 2, ' '      
   901 00001F30 370F050220                      db 55, 15, 5, 2, ' '   
   902 00001F35 430F050220                      db 67, 15, 5, 2, ' '
   903                                   
   904 00001F3A 0710050220                      db 7, 16, 5, 2, ' '   
   905 00001F3F 1310050220                      db 19, 16, 5, 2, ' '      
   906 00001F44 3710050220                      db 55, 16, 5, 2, ' '   
   907 00001F49 4310050220                      db 67, 16, 5, 2, ' '
   908                                  
   909                                  
   910 00001F4E 1911050220                      db 25, 17, 5, 2, ' '  
   911 00001F53 1F11050220                      db 31, 17, 5, 2, ' '
   912 00001F58 2B11050220                      db 43, 17, 5, 2, ' '    
   913 00001F5D 3111050220                      db 49, 17, 5, 2, ' ' 
   914                                  
   915 00001F62 1912050220                      db 25, 18, 5, 2, ' '  
   916 00001F67 1F12050220                      db 31, 18, 5, 2, ' '
   917 00001F6C 2B12050220                      db 43, 18, 5, 2, ' '    
   918 00001F71 3112050220                      db 49, 18, 5, 2, ' ' 
   919                                  
   920                                      level5_blocks_count equ 98
   921                                  
   922                                      ; Array para mantener el estado de los bloques
   923 00001F76 00<rep C8h>                 block_states: times 200 db 0  ; Durabilidad actual de cada bloque
   924                                  
   925                                      
   926                                      ; Variables para almacenar los valores
   927 0000203E 0000000000000000            current_score dq 0          ; Score actual
   928 00002046 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   929                                      
   930                                      ; Buffer para convertir números a string
   931 00002047 00<rep 14h>                 number_buffer: times 20 db 0
   932                                  
   933 0000205B 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   934                                      
   935                                      ; Estructura para los enemigos (x, y, activo)
   936 00002060 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   937 0000207E 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   938                                      
   939 0000207F 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   940 00002087 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   941 00002088 09                          enemy_move_delay db 9           ; Mover enemigos cada N ciclos
   942 00002089 00                          enemy_move_total db 0      ; Contador total de movimientos
   943 0000208A 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   944 0000208B 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   945                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   946 0000208C 464748494A4C788CA0-         level1_spawn_points: db 70, 71, 72, 73, 74, 76, 120, 140, 160, 180    ; 10 enemigos
   946 00002095 B4                 
   947 00002096 001E3246556E8296AA-         level2_spawn_points: db 0, 30, 50, 70, 85, 110, 130, 150, 170, 190    ; 10 enemigos
   947 0000209F BE                 
   948 000020A0 00000032373C646464-         level3_spawn_points: db 0, 0, 0, 50, 55, 60, 100, 100, 100, 100   ; 10 enemigos
   948 000020A9 64                 
   949 000020AA 00040F1E2832465A64-         level4_spawn_points: db 0, 4, 15, 30, 40, 50, 70, 90, 100, 120  ; 10 enemigos
   949 000020B3 78                 
   950 000020B4 00000A141E2328323C-         level5_spawn_points: db 0, 0, 10, 20, 30, 35, 40, 50, 60, 80 ; 10 enemigos
   950 000020BD 50                 
   951                                          ; Arreglo de punteros a los spawn points de cada nivel
   952                                      spawn_points_table:
   953 000020BE [8C20000000000000]              dq level1_spawn_points
   954 000020C6 [9620000000000000]              dq level2_spawn_points
   955 000020CE [A020000000000000]              dq level3_spawn_points
   956 000020D6 [AA20000000000000]              dq level4_spawn_points
   957 000020DE [B420000000000000]              dq level5_spawn_points
   958                                  
   959                                      ; Variables para el comportamiento de enemigos
   960 000020E6 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   961 000020E7 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   962 000020E8 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   963 000020E9 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   964                                  
   965 000020F3 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   965 000020FC 5B2020202020202020-
   965 00002105 20205D0A0D         
   966                                      score_label_len: equ $ - score_label
   967 0000210A 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   967 00002113 657374727569646F73-
   967 0000211C 3A205B2020205D0A0D 
   968                                      blocks_label_len: equ $ - blocks_label
   969                                      
   970                                      ; Posición donde insertar los números en los labels
   971                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   972                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   973                                      
   974                                      ; Definición de las vidas (x, y, estado)
   975                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   976                                      lives_data: 
   977 00002125 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   978 00002128 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   979 0000212B 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   980 0000212E 081E00                          db 8, 30, 0     ; Vida 4 (inactiva)
   981 00002131 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   982 00002134 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   983 00002137 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   984                                      lives_count equ 7    ; Total de vidas
   985 0000213A 5E                          life_char db "^"    
   986 0000213B 03                          current_lives db 3   ; Contador de vidas activas actual
   987                                  
   988                                  ; Estructura para almacenar las letras y sus posiciones
   989                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   990 0000213C 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   991 000022CC 00                          letters_count db 0   
   992 000022CD 20                          last_letter db ' '    ; Variable para almacenar la última letra
   993 000022CE 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   993 000022D7 75616C3A205B205D0A-
   993 000022E0 0D                 
   994                                      last_letter_msg_len equ $ - last_letter_msg
   995 000022E1 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   996 000022E2 07                          max_lives db 7              ; Máximo número de vidas permitidas
   997 000022E3 0700000000000000            ball_speed dq 7             ; Velocidad normal de la bola
   998 000022EB 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   999 000022F3 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
  1000                                     
  1001 000022FB 00                          initial_catch_active db 0   ; 0 = inactivo, 1 = activo
  1002                                  
  1003 000022FC 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
  1004 000022FD 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
  1005 000022FE 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
  1006 000022FF 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
  1007                                  
  1008 00002300 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
  1009 00002308 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
  1010                                  
  1011 00002309 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
  1012 0000230A 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
  1013 0000230B 00                          laser_count: db 0                ; Contador de láseres activos
  1014 0000230C 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
  1015 000023D4 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
  1016                                  
  1017                                      balls_data:     ; Array para almacenar hasta 3 bolas
  1018                                          ; Bola 1 (principal)
  1019 000023DC 0000000000000000                dq 0        ; x_pos
  1020 000023E4 0000000000000000                dq 0        ; y_pos
  1021 000023EC 0100000000000000                dq 1        ; direction_x
  1022 000023F4 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1023 000023FC 01                              db 1        ; active
  1024                                          ; Bola 2
  1025 000023FD 0000000000000000                dq 0        ; x_pos
  1026 00002405 0000000000000000                dq 0        ; y_pos
  1027 0000240D FFFFFFFFFFFFFFFF                dq -1       ; direction_x
  1028 00002415 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1029 0000241D 00                              db 0        ; active
  1030                                          ; Bola 3
  1031 0000241E 0000000000000000                dq 0        ; x_pos
  1032 00002426 0000000000000000                dq 0        ; y_pos
  1033 0000242E 0000000000000000                dq 0        ; direction_x
  1034 00002436 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
  1035 0000243E 00                              db 0        ; active
  1036                                      
  1037 0000243F 01                          balls_count db 1     ; Contador de bolas activas
  1038                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
  1039 00002440 00<rep Ah>                  enemy_last_x:       times 10 db 0
  1040 0000244A 00<rep Ah>                  enemy_last_y:       times 10 db 0
  1041 00002454 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
  1042 0000245E 00                          letter_move_counter db 0
  1043                                      initial_ball_offset_x equ 2    ; Offset desde el centro de la paleta
  1044                                      initial_ball_offset_y equ -1   ; Offset vertical desde la paleta
  1045                                  
  1046                                  section .text
  1047                                  
  1048                                  
  1049                                  print_lives:; Función para imprimir las vidas en la parte inferior
  1050 000001DD 55                          push rbp; Guardar el puntero de la base
  1051 000001DE 4889E5                      mov rbp, rsp; Establecer el puntero de la base
  1052                                      
  1053 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
  1054                                      
  1055                                      .print_loop:; Bucle para imprimir todas las vidas
  1056 000001E4 4983FC07                        cmp r12, lives_count; Verificar si se han impreso todas las vidas
  1057 000001E8 7D45                            jge .end; Si se han impreso todas las vidas, terminar
  1058                                          
  1059                                          ; Calcular offset de la vida actual
  1060 000001EA 4C89E0                          mov rax, r12    ; Calcular offset en el arreglo de vidas
  1061 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
  1062 000001F1 488DB0[25210000]                lea rsi, [lives_data + rax]    ; Cargar dirección de la vida actual
  1063                                          
  1064                                          ; Calcular posición en el tablero
  1065 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
  1066 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1067                                          
  1068                                          ; Calcular offset en el tablero
  1069 00000201 B850000000                      mov rax, column_cells        ; Ancho del tablero
  1070 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1071 0000020A 49F7E1                          mul r9                        ; Multiplicar por Y
  1072 0000020D 4C01C0                          add rax, r8                    ; Sumar X
  1073 00000210 488DB8[400A0000]                lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1074                                          
  1075                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
  1076 00000217 807E0201                        cmp byte [rsi + 2], 1     ; Verificar si la vida está activa
  1077 0000021B 7405                            je .draw_active           ; Si está activa, dibujar el carácter de vida 
  1078                                          
  1079                                          ; Si está inactiva, dibujar espacio
  1080 0000021D C60720                          mov byte [rdi], ' '
  1081 00000220 EB08                            jmp .next_life
  1082                                          
  1083                                      .draw_active:
  1084                                          ; Si está activa, dibujar el símbolo de vida
  1085 00000222 8A05(3A210000)                  mov al, [life_char]
  1086 00000228 8807                            mov [rdi], al
  1087                                          
  1088                                      .next_life:
  1089 0000022A 49FFC4                          inc r12
  1090 0000022D EBB5                            jmp .print_loop
  1091                                          
  1092                                      .end:
  1093 0000022F 5D                              pop rbp
  1094 00000230 C3                              ret
  1095                                  
  1096                                  ; Función para desactivar una vida
  1097                                  
  1098                                  lose_life:
  1099 00000231 55                          push rbp    ; Guardar el puntero de la base
  1100 00000232 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1101                                      
  1102                                      ; Verificar si aún quedan vidas
  1103 00000235 803D(3B210000)00            cmp byte [current_lives], 0   ; Verificar si quedan vidas
  1104 0000023C 0F84AB000000                je .game_lost             ; Si no quedan vidas, perder el juego
  1105                                      
  1106                                      ; Encontrar la última vida activa
  1107 00000242 B907000000                  mov rcx, lives_count    ; Cantidad total de vidas
  1108 00000247 48FFC9                      dec rcx               ; Índice de la última vida
  1109                                      
  1110                                      .find_active_life:  ; Bucle para encontrar la última vida activa
  1111 0000024A 4889C8                          mov rax, rcx    ; Calcular offset en el arreglo de vidas
  1112 0000024D 486BC003                        imul rax, 3    ; Cada vida ocupa 3 bytes (x, y, estado)
  1113 00000251 488DB0[25210000]                lea rsi, [lives_data + rax]   ; Cargar dirección de la vida actual
  1114 00000258 807E0201                        cmp byte [rsi + 2], 1   ; Verificar si la vida está activa
  1115 0000025C 740A                            je .deactivate_life   ; Si está activa, desactivarla
  1116 0000025E 48FFC9                          dec rcx   ; Si no está activa, probar con la siguiente vida
  1117 00000261 79E7                            jns .find_active_life   ; Si aún quedan vidas, continuar buscando
  1118 00000263 E985000000                      jmp .game_lost  ; Si no quedan vidas, perder el juego
  1119                                          
  1120                                      .deactivate_life:   ; Desactivar la vida encontrada
  1121                                          ; Borrar vida visualmente y en datos
  1122 00000268 4C0FB606                        movzx r8, byte [rsi]    ; X
  1123 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]    ; Y
  1124 00000271 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1125 00000276 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1126 0000027A 49F7E1                          mul r9  ; Multiplicar por Y
  1127 0000027D 4C01C0                          add rax, r8 ; Sumar X
  1128 00000280 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1129 00000287 C60720                          mov byte [rdi], ' ' ; Borrar visual
  1130 0000028A C6460200                        mov byte [rsi + 2], 0   ; Desactivar vida
  1131 0000028E FE0D(3B210000)                  dec byte [current_lives]    ; Decrementar contador de vidas
  1132                                          
  1133                                          ; Borrar paleta anterior
  1134 00000294 4C8B05(BF140000)                mov r8, [pallet_position]   ; Posición de la paleta
  1135 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]  ; Tamaño de la paleta
  1136                                          .erase_pallet_loop: ; Bucle para borrar la paleta
  1137 000002A2 41C60020                            mov byte [r8], ' '  ; Borrar visualmente
  1138 000002A6 49FFC0                              inc r8  ; Siguiente byte
  1139 000002A9 48FFC9                              dec rcx ; Decrementar contador
  1140 000002AC 75F4                                jnz .erase_pallet_loop  ; Si no se ha borrado toda la paleta, continuar
  1141                                          
  1142                                          ; Reiniciar solo la bola principal
  1143 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40      ; Posición inicial de la bola
  1143 000002B6 000000             
  1144 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28    ; Posición inicial de la bola
  1144 000002C1 000000             
  1145 000002C4 C605(FF140000)00                mov byte [ball_moving], 0   ; Detener la bola
  1146 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
  1147 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1147 000002D9 [B0130000]         
  1148                                          
  1149                                          ; Asegurarse que las otras bolas están desactivadas
  1150 000002DD C605(22150000)00                mov byte [ball2_active], 0  ; Desactivar bola 2
  1151 000002E4 C605(44150000)00                mov byte [ball3_active], 0      ; Desactivar bola 3
  1152                                          
  1153 000002EB EB07                            jmp .end    ; Salir
  1154                                          
  1155                                      .game_lost:
  1156 000002ED E8E2000000                      call game_lost  ; Perder el juego
  1157 000002F2 EB00                            jmp .end    ; Salir
  1158                                          
  1159                                      .end:
  1160 000002F4 5D                              pop rbp   ; Restaurar el puntero de la base
  1161 000002F5 C3                              ret  ; Retornar
  1162                                  ; Función modificada para verificar colisión con el borde inferior
  1163                                  check_bottom_collision:   ; Función para verificar colisión con el borde inferior
  1164 000002F6 55                          push rbp    ; Guardar el puntero de la base
  1165 000002F7 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1166                                      
  1167                                      ; Verificar si el nivel está completo (no quedan bloques)
  1168 000002FA 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Verificar si quedan bloques
  1169 00000301 0F84CB000000                je .balls_remain            ; Si no quedan bloques, no perder vidas
  1170                                      
  1171                                      ; Verificar bola principal
  1172 00000307 803D(00150000)01            cmp byte [ball_active], 1   ; Verificar si la bola principal está activa
  1173 0000030E 7542                        jne .check_ball2        ; Si no está activa, verificar bola 2
  1174 00000310 488B05(E7140000)            mov rax, [ball_y_pos]   ; Obtener posición Y de la bola principal
  1175 00000317 4883F81E                    cmp rax, row_cells - 2      ; Verificar si ha llegado al borde inferior
  1176 0000031B 7535                        jne .check_ball2    ; Si no ha llegado al borde, verificar bola 2
  1177                                      
  1178                                      ; Borrar visualmente la bola principal
  1179 0000031D 4C8B05(DF140000)            mov r8, [ball_x_pos]    ; Obtener posición X de la bola principal
  1180 00000324 4C8B0D(E7140000)            mov r9, [ball_y_pos]    ; Obtener posición Y de la bola principal
  1181 0000032B 4981C0[400A0000]            add r8, board        ; Calcular dirección en el tablero
  1182 00000332 4C89C9                      mov rcx, r9        ; Calcular offset en el tablero
  1183 00000335 B852000000                  mov rax, column_cells + 2   ; Ancho del tablero
  1184 0000033A 48F7E9                      imul rcx    ; Multiplicar por Y
  1185 0000033D 4901C0                      add r8, rax   ; Sumar X
  1186 00000340 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
  1187                                      
  1188 00000344 C605(00150000)00            mov byte [ball_active], 0   ; Desactivar bola principal
  1189 0000034B C605(FF140000)00            mov byte [ball_moving], 0   ; Detener la bola principal
  1190                                  
  1191                                  .check_ball2:   ; Verificar bola 2
  1192 00000352 803D(22150000)01            cmp byte [ball2_active], 1  ; Verificar si la bola 2 está activa
  1193 00000359 751B                        jne .check_ball3    ; Si no está activa, verificar bola 3
  1194 0000035B 488B05(09150000)            mov rax, [ball2_y_pos]  ; Obtener
  1195 00000362 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1196 00000366 750E                        jne .check_ball3    ; Si no ha llegado al borde, verificar bola 3
  1197 00000368 C605(22150000)00            mov byte [ball2_active], 0      ; Desactivar bola 2
  1198 0000036F C605(21150000)00            mov byte [ball2_moving], 0    ; Detener bola 2
  1199                                  
  1200                                  .check_ball3:   ; Verificar bola 3
  1201 00000376 803D(44150000)01            cmp byte [ball3_active], 1  ; Verificar si la bola 3 está activa
  1202 0000037D 751B                        jne .check_active_balls   ; Si no está activa, verificar bolas activas
  1203 0000037F 488B05(2B150000)            mov rax, [ball3_y_pos]  ; Obtener posición Y de la bola 3
  1204 00000386 4883F81E                    cmp rax, row_cells - 2  ; Verificar si ha llegado al borde inferior
  1205 0000038A 750E                        jne .check_active_balls  ; Si no ha llegado al borde, verificar bolas activas
  1206 0000038C C605(44150000)00            mov byte [ball3_active], 0  ; Desactivar bola 3
  1207 00000393 C605(43150000)00            mov byte [ball3_moving], 0  ; Detener bola 3
  1208                                  
  1209                                  .check_active_balls:        
  1210                                      ; Verificar si quedan bolas activas
  1211 0000039A 4831C9                      xor rcx, rcx    ; Contar bolas activas
  1212                                      
  1213                                      ; Contar bolas activas
  1214 0000039D 8A05(00150000)              mov al, byte [ball_active]  ; Verificar si la bola principal está activa
  1215 000003A3 4801C1                      add rcx, rax    ; Sumar al contador
  1216 000003A6 8A05(22150000)              mov al, byte [ball2_active] ; Verificar si la bola 2 está activa
  1217 000003AC 4801C1                      add rcx, rax    ; Sumar al contador
  1218 000003AF 8A05(44150000)              mov al, byte [ball3_active] ; Verificar si la bola 3 está activa
  1219 000003B5 4801C1                      add rcx, rax    ; Sumar al contador
  1220                                      
  1221                                      ; Si no hay bolas activas y quedan bloques, perder vida
  1222 000003B8 4885C9                      test rcx, rcx   ; Verificar si hay bolas activas
  1223 000003BB 7515                        jnz .balls_remain   ; Si hay bolas activas, salir
  1224                                      
  1225 000003BD 803D(7A150000)00            cmp byte [blocks_remaining], 0  ; Verificar si quedan bloques
  1226 000003C4 740C                        je .balls_remain               ; Si no quedan bloques, no perder vida
  1227                                      
  1228 000003C6 E866FEFFFF                  call lose_life
  1229 000003CB C605(00150000)01            mov byte [ball_active], 1      ; Reactivar bola principal
  1230                                      
  1231                                  .balls_remain:  ; Si quedan bolas, continuar
  1232 000003D2 5D                          pop rbp     ; Restaurar el puntero de la base
  1233 000003D3 C3                          ret    ; Retornar
  1234                                  
  1235                                  ; Nueva función para game over
  1236                                  game_lost:
  1237                                      ; Limpiar la pantalla
  1238                                      print clear, clear_length
    93 000003D4 B801000000          <1>  mov eax, sys_write
    94 000003D9 BF01000000          <1>  mov edi, 1
    95 000003DE 48BE-               <1>  mov rsi, %1
    95 000003E0 [1000000000000000]  <1>
    96 000003E8 BA07000000          <1>  mov edx, %2
    97 000003ED 0F05                <1>  syscall
  1239                                      
  1240                                      ; Mostrar mensaje de derrota
  1241                                      section .data   
  1242 0000245F C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
  1242 00002468 6469646F210A0D     
  1243                                          lost_msg_len: equ $ - lost_msg
  1244                                      section .text
  1245                                      
  1246                                      ; Imprimir mensaje de derrota
  1247                                      print lost_msg, lost_msg_len    ; Imprimir mensaje
    93 000003EF B801000000          <1>  mov eax, sys_write
    94 000003F4 BF01000000          <1>  mov edi, 1
    95 000003F9 48BE-               <1>  mov rsi, %1
    95 000003FB [5F24000000000000]  <1>
    96 00000403 BA10000000          <1>  mov edx, %2
    97 00000408 0F05                <1>  syscall
  1248                                      print score_msg, score_msg_len  ; Imprimir puntaje
    93 0000040A B801000000          <1>  mov eax, sys_write
    94 0000040F BF01000000          <1>  mov edi, 1
    95 00000414 48BE-               <1>  mov rsi, %1
    95 00000416 [8D24000000000000]  <1>
    96 0000041E BA0F000000          <1>  mov edx, %2
    97 00000423 0F05                <1>  syscall
  1249                                      
  1250                                      ; Mostrar puntaje final
  1251 00000425 488B05(3E200000)            mov rax, [current_score]    ; Cargar puntaje
  1252 0000042C 48BF-                       mov rdi, number_buffer  ; Buffer para convertir a string
  1252 0000042E [4720000000000000] 
  1253 00000436 E838150000                  call number_to_string   ; Convertir a string
  1254                                      print number_buffer, 20 ; Imprimir puntaje
    93 0000043B B801000000          <1>  mov eax, sys_write
    94 00000440 BF01000000          <1>  mov edi, 1
    95 00000445 48BE-               <1>  mov rsi, %1
    95 00000447 [4720000000000000]  <1>
    96 0000044F BA14000000          <1>  mov edx, %2
    97 00000454 0F05                <1>  syscall
  1255                                      
  1256                                      ; Esperar un momento antes de salir
  1257 00000456 48C7059FFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1257 0000045F 0000               
  1258 00000461 48C7059CFBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1258 0000046A 0000               
  1259                                      sleeptime
   109 0000046C B823000000          <1>  mov eax, sys_nanosleep
   110 00000471 48BF-               <1>  mov rdi, timespec
   110 00000473 [0000000000000000]  <1>
   111 0000047B 31F6                <1>  xor esi, esi
   112 0000047D 0F05                <1>  syscall
  1260                                      
  1261 0000047F E96D1F0000                  jmp exit
  1262                                  
  1263                                  
  1264                                  ; Función para registrar una nueva letra en el mapa
  1265                                  ; Entrada:
  1266                                  ;   al - letra a registrar
  1267                                  ;   r8b - posición x
  1268                                  ;   r9b - posición y
  1269                                  register_letter:        
  1270 00000484 55                          push rbp    ; Guardar el puntero de la base
  1271 00000485 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1272 00000488 53                          push rbx    ; Guardar registros
  1273 00000489 51                          push rcx    ; Guardar registros
  1274                                      
  1275 0000048A 3C20                        cmp al, ' '   ; Verificar si es un espacio
  1276 0000048C 7438                        je .end      ; Si es un espacio, salir
  1277                                  
  1278                                      ; Encontrar un espacio libre en el mapa
  1279 0000048E 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1280 00000491 480FB615(CC220000)          movzx rdx, byte [letters_count] ; Cantidad de letras registradas
  1281                                      
  1282                                      .find_slot:
  1283 00000499 4883F964                        cmp rcx, 100              ; Máximo de letras
  1284 0000049D 7D27                            jge .end                  ; Si no hay espacio, salir
  1285                                          
  1286 0000049F 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1287 000004A7 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
  1288 000004AB 7405                            je .found_slot
  1289                                          
  1290 000004AD 48FFC1                          inc rcx   ; Probar con la siguiente letra
  1291 000004B0 EBE7                            jmp .find_slot  ; Continuar buscando
  1292                                          
  1293                                      .found_slot:
  1294                                          ; Guardar la información de la letra
  1295 000004B2 448803                          mov [rbx], r8b           ; x
  1296 000004B5 44884B01                        mov [rbx + 1], r9b       ; y
  1297 000004B9 884302                          mov [rbx + 2], al        ; letra
  1298 000004BC C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
  1299                                          
  1300 000004C0 FE05(CC220000)                  inc byte [letters_count]
  1301                                          
  1302                                      .end:
  1303 000004C6 59                              pop rcx
  1304 000004C7 5B                              pop rbx
  1305 000004C8 5D                              pop rbp
  1306 000004C9 C3                              ret
  1307                                  
  1308                                  ; Función para imprimir todas las letras registradas
  1309                                  print_letters:
  1310 000004CA 55                          push rbp        ; Guardar el puntero de la base
  1311 000004CB 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1312 000004CE 53                          push rbx    ; Guardar registros
  1313 000004CF 51                          push rcx    ; Guardar registros
  1314                                      
  1315 000004D0 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1316                                      
  1317                                      .print_loop:
  1318 000004D3 4883F964                        cmp rcx, 100              ; Máximo de letras
  1319 000004D7 7D37                            jge .end              ; Si no hay más letras, salir
  1320                                          
  1321                                          ; Obtener puntero a la letra actual
  1322 000004D9 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]
  1323                                          
  1324                                          ; Verificar si está activa
  1325 000004E1 807B0300                        cmp byte [rbx + 3], 0
  1326 000004E5 7424                            je .next_letter
  1327                                          
  1328                                          ; Calcular posición en el tablero
  1329 000004E7 4C0FB603                        movzx r8, byte [rbx]      ; x
  1330 000004EB 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
  1331                                          
  1332                                          ; Calcular offset en el tablero
  1333 000004F0 B850000000                      mov rax, column_cells
  1334 000004F5 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
  1335 000004F9 49F7E1                          mul r9
  1336 000004FC 4C01C0                          add rax, r8
  1337 000004FF 488DB8[400A0000]                lea rdi, [board + rax]  ; Dirección en el tablero
  1338                                          
  1339                                          ; Imprimir la letra
  1340 00000506 8A4302                          mov al, [rbx + 2]   ; Obtener la letra
  1341 00000509 8807                            mov [rdi], al    ; Imprimir la letra
  1342                                          
  1343                                      .next_letter:
  1344 0000050B 48FFC1                          inc rcx   ; Siguiente letra
  1345 0000050E EBC3                            jmp .print_loop ; Continuar imprimiendo
  1346                                          
  1347                                      .end:
  1348 00000510 59                              pop rcx   ; Restaurar registros
  1349 00000511 5B                              pop rbx  ; Restaurar registros
  1350 00000512 5D                              pop rbp ; Restaurar el puntero de la base
  1351 00000513 C3                              ret   ; Retornar
  1352                                  
  1353                                  ; Función para borrar una letra específica
  1354                                  ; Entrada:
  1355                                  ;   r8b - posición x
  1356                                  ;   r9b - posición y
  1357                                  remove_letter:
  1358 00000514 55                          push rbp
  1359 00000515 4889E5                      mov rbp, rsp
  1360 00000518 53                          push rbx    ; Guardar registros
  1361 00000519 51                          push rcx    ; Guardar registros
  1362                                      
  1363 0000051A 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1364                                      
  1365                                      .find_loop:     
  1366 0000051D 4883F964                        cmp rcx, 100              ; Máximo de letras
  1367 00000521 7D2E                            jge .end
  1368                                          
  1369 00000523 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1370                                          
  1371                                          ; Verificar si está activa y coincide la posición
  1372 0000052B 807B0300                        cmp byte [rbx + 3], 0
  1373 0000052F 741B                            je .next_letter   ; Si no está activa, probar con la siguiente letra
  1374                                          
  1375 00000531 8A03                            mov al, [rbx]   ; x
  1376 00000533 4438C0                          cmp al, r8b    ; Verificar si coincide la posición x
  1377 00000536 7514                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1378                                          
  1379 00000538 8A4301                          mov al, [rbx + 1]   ; y
  1380 0000053B 4438C8                          cmp al, r9b   ; Verificar si coincide la posición y
  1381 0000053E 750C                            jne .next_letter    ; Si no coincide, probar con la siguiente letra
  1382                                          
  1383                                          ; Encontrada la letra, desactivarla 
  1384 00000540 C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1385 00000544 FE0D(CC220000)                  dec byte [letters_count]        ; Decrementar contador de letras
  1386 0000054A EB05                            jmp .end
  1387                                          
  1388                                      .next_letter:
  1389 0000054C 48FFC1                          inc rcx  ; Siguiente letra
  1390 0000054F EBCC                            jmp .find_loop  ; Continuar buscando
  1391                                          
  1392                                      .end:
  1393 00000551 59                              pop rcx
  1394 00000552 5B                              pop rbx
  1395 00000553 5D                              pop rbp
  1396 00000554 C3                              ret
  1397                                  ; Función para mover las letras hacia abajo
  1398                                  move_letters:
  1399 00000555 55                          push rbp    ; Guardar el puntero de la base
  1400 00000556 4889E5                      mov rbp, rsp    ; Establecer el puntero de la base
  1401 00000559 53                          push rbx    ; Guardar registros
  1402 0000055A 57                          push rdi    ; Guardar registros
  1403 0000055B 56                          push rsi    ; Guardar registros
  1404 0000055C 4150                        push r8    ; Guardar registros
  1405 0000055E 4151                        push r9   ; Guardar registros
  1406 00000560 4152                        push r10    ; Guardar registros
  1407 00000562 4153                        push r11    ; Guardar registros
  1408                                  
  1409 00000564 4831C9                      xor rcx, rcx    ; Índice de la letra actual
  1410                                  
  1411                                      ; Verificar si debemos mover la letra en este frame
  1412 00000567 FE05(5E240000)              inc byte [letter_move_counter]    ; Incrementar contador
  1413 0000056D 803D(5E240000)0B            cmp byte [letter_move_counter], 11 ; Ajusta este número para cambiar velocidad
  1414 00000574 0F8C20020000                jl .skip_all                         ; Si no es momento de mover, terminar
  1415 0000057A C605(5E240000)00            mov byte [letter_move_counter], 0 ; Resetear contador
  1416                                  
  1417                                      .move_loop:
  1418 00000581 4883F964                        cmp rcx, 100          ; Máximo de letras, se hace esta verificacion porque se pueden borrar letras
  1419 00000585 0F8D0D020000                    jge .print_last_letter  ; Si no hay más letras, imprimir la última letra
  1420                                          
  1421 0000058B 488D1C8D[3C210000]              lea rbx, [letters_map + rcx * 4]    ; Obtener puntero a la letra actual
  1422 00000593 807B0300                        cmp byte [rbx + 3], 0   ; Verificar si está activa
  1423 00000597 0F84F3010000                    je .next_letter       ; Si no está activa, probar con la siguiente letra
  1424                                  
  1425 0000059D 4C0FB603                        movzx r8, byte [rbx]    ; x
  1426 000005A1 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1427                                  
  1428 000005A6 B850000000                      mov rax, column_cells   ; Ancho del tablero
  1429 000005AB 4883C002                        add rax, 2  ; Incluir caracteres de nueva línea
  1430 000005AF 49F7E1                          mul r9  ; Multiplicar por Y
  1431 000005B2 4C01C0                          add rax, r8 ; Sumar X
  1432 000005B5 488DB8[400A0000]                lea rdi, [board + rax]  ; Cargar dirección en el tablero
  1433 000005BC C60720                          mov byte [rdi], ' ' ; Borrar visualmente la letra
  1434                                  
  1435 000005BF FE4301                          inc byte [rbx + 1]  ; Mover la letra hacia abajo
  1436 000005C2 4C0FB64B01                      movzx r9, byte [rbx + 1]    ; y
  1437                                  
  1438 000005C7 4983F91F                        cmp r9, row_cells - 1   ; Verificar si ha llegado al borde inferior
  1439 000005CB 7C09                            jl .check_pallet_collision  ; Si no ha llegado al borde, verificar colisión con la paleta
  1440                                  
  1441 000005CD C6430300                        mov byte [rbx + 3], 0   ; Desactivar letra
  1442 000005D1 E9BA010000                      jmp .next_letter    ; Probar con la siguiente letra
  1443                                  
  1444                                          .check_pallet_collision:    ; Verificar colisión con la paleta
  1445 000005D6 B850000000                          mov rax, column_cells   ; Ancho del tablero
  1446 000005DB 4883C002                            add rax, 2  ; Incluir caracteres de nueva línea
  1447 000005DF 49F7E1                              mul r9  ; Multiplicar por Y
  1448 000005E2 4C01C0                              add rax, r8 ; Sumar X
  1449 000005E5 488DB8[400A0000]                    lea rdi, [board + rax]      ; Cargar dirección en el tablero
  1450                                  
  1451 000005EC 8A07                                mov al, [rdi]   ; Obtener el carácter actual
  1452 000005EE 3C20                                cmp al, ' '  ; Verificar si es un espacio
  1453 000005F0 0F849A010000                        je .next_letter ; Si es un espacio, probar con la siguiente letra
  1454 000005F6 3C3D                                cmp al, char_equal  ; Verificar si es la paleta
  1455 000005F8 740A                                je .capture_letter  ; Si es la paleta, capturar la letra
  1456                                  
  1457 000005FA 8A4302                              mov al, [rbx + 2]   ; Obtener la letra
  1458 000005FD 8807                                mov [rdi], al   ; Imprimir la letra
  1459 000005FF E98C010000                          jmp .next_letter    ; Probar con la siguiente letra
  1460                                  
  1461                                          .capture_letter:    ; Capturar la letra
  1462                                              ; Obtener la nueva letra
  1463 00000604 8A4302                              mov al, [rbx + 2]
  1464                                              
  1465                                              ; Comparar con la última letra
  1466 00000607 3A05(CD220000)                      cmp al, [last_letter]
  1467 0000060D 7407                                je .same_letter
  1468                                              
  1469                                              ; Es una letra diferente, resetear el procesamiento
  1470 0000060F C605(E1220000)00                    mov byte [current_power_processed], 0
  1471                                              
  1472                                              .same_letter:
  1473                                              ; Guardar la nueva letra
  1474 00000616 8805(CD220000)                      mov [last_letter], al
  1475                                              
  1476                                              ; Verificar si es 'E' para extender la paleta
  1477 0000061C 3C45                                cmp al, 'E'
  1478 0000061E 7450                                je .extend_pallet
  1479                                              
  1480                                              ; Verificar si es 'P' para añadir vida
  1481 00000620 3C50                                cmp al, 'P'
  1482 00000622 7478                                je .check_add_life
  1483                                  
  1484 00000624 3C53                                cmp al, 'S'
  1485 00000626 0F84B4000000                        je .slow_ball
  1486                                  
  1487 0000062C 3C43                                cmp al, 'C'
  1488 0000062E 0F84D8000000                        je .activate_catch
  1489                                              
  1490 00000634 3C4C                                cmp al, 'L'
  1491 00000636 0F84F9000000                        je .activate_laser
  1492                                  
  1493 0000063C 3C44                                cmp al, 'D'
  1494 0000063E 0F841A010000                        je .activate_split
  1495                                  
  1496                                              ; Si no es ningún power-up, restaurar tamaño normal
  1497 00000644 488B05(CF140000)                    mov rax, [default_pallet_size]
  1498 0000064B 488905(C7140000)                    mov [pallet_size], rax
  1499 00000652 48C705(E3220000)07-                 mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1499 0000065A 000000             
  1500 0000065D C605(FC220000)00                    mov byte [catch_power_active], 0
  1501 00000664 C605(09230000)00                    mov byte [laser_power_active], 0
  1502 0000066B E91C010000                          jmp .finish_capture
  1503                                  
  1504                                              .extend_pallet:
  1505 00000670 C605(09230000)00                        mov byte [laser_power_active], 0
  1506 00000677 C605(FC220000)00                        mov byte [catch_power_active], 0
  1507 0000067E 48C705(E3220000)07-                     mov qword [ball_speed], 7    ; Restaurar velocidad normal
  1507 00000686 000000             
  1508 00000689 488B05(D7140000)                        mov rax, [extended_pallet_size]
  1509 00000690 488905(C7140000)                        mov [pallet_size], rax
  1510 00000697 E9F0000000                              jmp .finish_capture
  1511                                  
  1512                                              .check_add_life:
  1513 0000069C C605(09230000)00                        mov byte [laser_power_active], 0
  1514 000006A3 C605(FC220000)00                        mov byte [catch_power_active], 0
  1515 000006AA 488B05(CF140000)                        mov rax, [default_pallet_size]
  1516 000006B1 488905(C7140000)                        mov [pallet_size], rax
  1517 000006B8 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1517 000006C0 000000             
  1518                                                  ; Verificar si ya procesamos este power-up
  1519 000006C3 803D(E1220000)00                        cmp byte [current_power_processed], 0
  1520 000006CA 0F85BC000000                            jne .finish_capture
  1521                                                  
  1522                                                  ; Preservar registros importantes
  1523 000006D0 51                                      push rcx
  1524 000006D1 53                                      push rbx
  1525                                                  
  1526                                                  ; Marcar como procesado
  1527 000006D2 C605(E1220000)01                        mov byte [current_power_processed], 1
  1528                                                  
  1529                                                  ; Añadir una vida
  1530 000006D9 E8A8040000                              call add_life
  1531                                                  
  1532                                                  ; Restaurar registros
  1533 000006DE 5B                                      pop rbx
  1534 000006DF 59                                      pop rcx
  1535                                                  
  1536                                              .slow_ball:
  1537 000006E0 C605(09230000)00                        mov byte [laser_power_active], 0
  1538 000006E7 C605(FC220000)00                        mov byte [catch_power_active], 0                
  1539 000006EE 488B05(CF140000)                        mov rax, [default_pallet_size]
  1540 000006F5 488905(C7140000)                        mov [pallet_size], rax
  1541 000006FC 48C705(E3220000)0A-                     mov qword [ball_speed], 10    ; Activar velocidad lenta
  1541 00000704 000000             
  1542 00000707 E980000000                              jmp .finish_capture
  1543                                  
  1544                                              .activate_catch:
  1545 0000070C C605(09230000)00                        mov byte [laser_power_active], 0
  1546 00000713 488B05(CF140000)                        mov rax, [default_pallet_size]
  1547 0000071A 488905(C7140000)                        mov [pallet_size], rax
  1548 00000721 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1548 00000729 000000             
  1549 0000072C C605(FC220000)01                        mov byte [catch_power_active], 1
  1550 00000733 EB57                                    jmp .finish_capture
  1551                                  
  1552                                              .activate_laser:
  1553 00000735 C605(FC220000)00                        mov byte [catch_power_active], 0
  1554 0000073C 488B05(CF140000)                        mov rax, [default_pallet_size]
  1555 00000743 488905(C7140000)                        mov [pallet_size], rax
  1556 0000074A 48C705(E3220000)07-                     mov qword [ball_speed], 7
  1556 00000752 000000             
  1557 00000755 C605(09230000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1558 0000075C EB2E                                    jmp .finish_capture
  1559                                  
  1560                                              .activate_split:
  1561 0000075E C605(09230000)00                        mov byte [laser_power_active], 0
  1562 00000765 C605(FC220000)00                        mov byte [catch_power_active], 0
  1563 0000076C 488B05(CF140000)                        mov rax, [default_pallet_size]
  1564 00000773 488905(C7140000)                        mov [pallet_size], rax
  1565 0000077A 48C705(E3220000)07-                     mov qword [ball_speed], 7 
  1565 00000782 000000             
  1566 00000785 E8DF000000                              call activate_split_power
  1567 0000078A EB00                                    jmp .finish_capture
  1568                                  
  1569                                              .finish_capture:
  1570 0000078C C6430300                                mov byte [rbx + 3], 0
  1571                                  
  1572                                          .next_letter:
  1573 00000790 48FFC1                              inc rcx
  1574 00000793 E9E9FDFFFF                          jmp .move_loop
  1575                                  
  1576                                      .print_last_letter:
  1577                                          ; ;; en vez de imprimir, saltamos
  1578 00000798 EB0D                            jmp .end
  1579                                  
  1580                                  
  1581                                      .skip_all:                        ; Nueva etiqueta para saltar todo cuando no movemos
  1582 0000079A 415B                            pop r11                       ; Restaurar registros
  1583 0000079C 415A                            pop r10                      ; Restaurar registros
  1584 0000079E 4159                            pop r9
  1585 000007A0 4158                            pop r8
  1586 000007A2 5E                              pop rsi
  1587 000007A3 5F                              pop rdi
  1588 000007A4 5B                              pop rbx
  1589 000007A5 5D                              pop rbp
  1590 000007A6 C3                              ret
  1591                                  
  1592                                      .end:
  1593 000007A7 415B                            pop r11
  1594 000007A9 415A                            pop r10
  1595 000007AB 4159                            pop r9
  1596 000007AD 4158                            pop r8
  1597 000007AF 5E                              pop rsi
  1598 000007B0 5F                              pop rdi
  1599 000007B1 5B                              pop rbx
  1600 000007B2 5D                              pop rbp
  1601 000007B3 C3                              ret
  1602                                  
  1603                                  print_power_label:  ; Función para imprimir el mensaje de poder actual
  1604 000007B4 55                          push rbp
  1605 000007B5 4889E5                      mov  rbp, rsp
  1606                                      
  1607                                      ; Crear buffer temporal
  1608 000007B8 4883EC20                    sub rsp, 32
  1609                                      
  1610                                      ; Copiar el mensaje base al buffer
  1611 000007BC 4889E7                      mov rdi, rsp
  1612 000007BF 48BE-                       mov rsi, last_letter_msg
  1612 000007C1 [CE22000000000000] 
  1613 000007C9 B913000000                  mov rcx, last_letter_msg_len
  1614 000007CE F3A4                        rep movsb
  1615                                      
  1616                                      ; Insertar la última letra capturada
  1617 000007D0 8A05(CD220000)              mov al, [last_letter]
  1618 000007D6 8844240F                    mov byte [rsp + 15], al    ; Asumiendo que 15 es la posición correcta
  1619                                      
  1620                                      ; Imprimir el buffer completo
  1621                                      print rsp, last_letter_msg_len
    93 000007DA B801000000          <1>  mov eax, sys_write
    94 000007DF BF01000000          <1>  mov edi, 1
    95 000007E4 4889E6              <1>  mov rsi, %1
    96 000007E7 BA13000000          <1>  mov edx, %2
    97 000007EC 0F05                <1>  syscall
  1622                                      
  1623                                      ; Restaurar stack
  1624 000007EE 4883C420                    add rsp, 32
  1625 000007F2 5D                          pop rbp
  1626 000007F3 C3                          ret
  1627                                  
  1628                                  
  1629                                  
  1630                                  clear_lasers:
  1631 000007F4 55                          push rbp
  1632 000007F5 4889E5                      mov  rbp, rsp
  1633                                  
  1634                                      ; Recorrer el array de láseres
  1635 000007F8 4831C9                      xor rcx, rcx                ; Índice del láser
  1636 000007FB 480FB61D(0B230000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1637                                  
  1638                                      .clear_loop:
  1639 00000803 4839D9                          cmp rcx, rbx
  1640 00000806 7D2F                            jge .done                ; Salir si no quedan láseres
  1641                                  
  1642                                          ; Obtener posición del láser actual
  1643 00000808 488DB409[0C230000]              lea rsi, [lasers + rcx * 2]
  1644 00000810 4C0FB606                        movzx r8, byte [rsi]     ; X
  1645 00000814 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1646                                  
  1647                                          ; Calcular posición en el tablero
  1648 00000819 B850000000                      mov rax, column_cells
  1649 0000081E 4883C002                        add rax, 2
  1650 00000822 49F7E1                          mul r9
  1651 00000825 4C01C0                          add rax, r8
  1652 00000828 488DB8[400A0000]                lea rdi, [board + rax]
  1653                                  
  1654                                          ; Borrar el láser visualmente
  1655 0000082F C60720                          mov byte [rdi], ' '
  1656                                  
  1657                                          ; Pasar al siguiente láser
  1658 00000832 48FFC1                          inc rcx
  1659 00000835 EBCC                            jmp .clear_loop
  1660                                  
  1661                                      .done:
  1662                                          ; Resetear contador de láseres
  1663 00000837 C605(0B230000)00                mov byte [laser_count], 0
  1664                                  
  1665 0000083E 5D                              pop rbp
  1666 0000083F C3                              ret
  1667                                  
  1668                                  
  1669                                  ; Nueva función para actualizar los láseres
  1670                                  update_lasers:
  1671 00000840 55                          push rbp
  1672 00000841 4889E5                      mov rbp, rsp
  1673                                      
  1674                                      ; Verificar si el poder láser está activo
  1675 00000844 803D(09230000)00            cmp byte [laser_power_active], 0
  1676 0000084B 741A                        je .end
  1677                                      
  1678                                      ; Verificar si se presionó la tecla de espacio
  1679 0000084D 803D(08230000)20            cmp byte [last_key], ' '
  1680 00000854 750C                        jne .skip_shooting
  1681                                      
  1682                                      ; Disparar nuevos láseres
  1683 00000856 E8FD000000                  call shoot_lasers
  1684 0000085B C605(08230000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1685                                      
  1686                                      .skip_shooting:
  1687                                      ; Mover los láseres existentes
  1688 00000862 E88B010000                  call move_lasers
  1689                                      
  1690                                      .end:
  1691 00000867 5D                              pop rbp
  1692 00000868 C3                              ret
  1693                                  
  1694                                  activate_split_power:
  1695 00000869 55                          push rbp
  1696 0000086A 4889E5                      mov rbp, rsp
  1697 0000086D 50                          push rax
  1698 0000086E 53                          push rbx
  1699 0000086F 51                          push rcx
  1700 00000870 52                          push rdx
  1701                                      
  1702                                      ; Si ambas bolas extra ya están activas, salimos
  1703 00000871 8A0D(22150000)              mov cl, byte [ball2_active]
  1704 00000877 220D(44150000)              and cl, byte [ball3_active]
  1705 0000087D 80F901                      cmp cl, 1
  1706 00000880 0F84CC000000                je .end
  1707                                      
  1708                                  .find_active_ball:
  1709                                      ; Guardar posición de la bola activa
  1710 00000886 4831C0                      xor rax, rax    ; Limpiar rax
  1711 00000889 4831DB                      xor rbx, rbx    ; Limpiar rbx
  1712                                      
  1713                                      ; Revisar ball1
  1714 0000088C 803D(00150000)01            cmp byte [ball_active], 1
  1715 00000893 7417                        je .use_ball1
  1716                                      
  1717                                      ; Revisar ball2
  1718 00000895 803D(22150000)01            cmp byte [ball2_active], 1
  1719 0000089C 741E                        je .use_ball2
  1720                                      
  1721                                      ; Revisar ball3
  1722 0000089E 803D(44150000)01            cmp byte [ball3_active], 1
  1723 000008A5 7425                        je .use_ball3
  1724                                      
  1725 000008A7 E9A6000000                  jmp .end        ; Si no hay bolas activas, salimos
  1726                                  
  1727                                  .use_ball1:
  1728 000008AC 488B05(DF140000)            mov rax, qword [ball_x_pos]
  1729 000008B3 488B1D(E7140000)            mov rbx, qword [ball_y_pos]
  1730 000008BA EB20                        jmp .create_missing_balls
  1731                                  
  1732                                  .use_ball2:
  1733 000008BC 488B05(01150000)            mov rax, qword [ball2_x_pos]
  1734 000008C3 488B1D(09150000)            mov rbx, qword [ball2_y_pos]
  1735 000008CA EB10                        jmp .create_missing_balls
  1736                                  
  1737                                  .use_ball3:
  1738 000008CC 488B05(23150000)            mov rax, qword [ball3_x_pos]
  1739 000008D3 488B1D(2B150000)            mov rbx, qword [ball3_y_pos]
  1740 000008DA EB00                        jmp .create_missing_balls
  1741                                  
  1742                                  .create_missing_balls:
  1743                                      ; Intentar crear ball2 si no está activa
  1744 000008DC 803D(22150000)01            cmp byte [ball2_active], 1
  1745 000008E3 7432                        je .create_ball3    ; Si ball2 ya está activa, intentar crear ball3
  1746                                      
  1747                                      ; Crear ball2
  1748 000008E5 488905(01150000)            mov qword [ball2_x_pos], rax
  1749 000008EC 48891D(09150000)            mov qword [ball2_y_pos], rbx
  1750 000008F3 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  1750 000008FB FFFFFF             
  1751 000008FE 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  1751 00000906 FFFFFF             
  1752 00000909 C605(21150000)01            mov byte [ball2_moving], 1
  1753 00000910 C605(22150000)01            mov byte [ball2_active], 1
  1754                                      
  1755                                  .create_ball3:
  1756                                      ; Intentar crear ball3 si no está activa
  1757 00000917 803D(44150000)01            cmp byte [ball3_active], 1
  1758 0000091E 7432                        je .end
  1759                                      
  1760                                      ; Crear ball3
  1761 00000920 488905(23150000)            mov qword [ball3_x_pos], rax
  1762 00000927 48891D(2B150000)            mov qword [ball3_y_pos], rbx
  1763 0000092E 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  1763 00000936 000000             
  1764 00000939 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  1764 00000941 FFFFFF             
  1765 00000944 C605(43150000)01            mov byte [ball3_moving], 1
  1766 0000094B C605(44150000)01            mov byte [ball3_active], 1
  1767                                  
  1768                                  .end:
  1769 00000952 5A                          pop rdx
  1770 00000953 59                          pop rcx
  1771 00000954 5B                          pop rbx
  1772 00000955 58                          pop rax
  1773 00000956 5D                          pop rbp
  1774 00000957 C3                          ret
  1775                                  
  1776                                  
  1777                                  shoot_lasers:
  1778 00000958 55                          push rbp
  1779 00000959 4889E5                      mov rbp, rsp
  1780 0000095C 53                          push rbx
  1781                                      
  1782                                      ; Verificar si hay espacio para más láseres
  1783 0000095D 480FB605(0B230000)          movzx rax, byte [laser_count]
  1784 00000965 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1785 00000969 0F8D80000000                jge .end
  1786                                      
  1787                                      ; Obtener posición de la paleta
  1788 0000096F 4C8B05(BF140000)            mov r8, [pallet_position]
  1789 00000976 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1790                                      
  1791                                      ; Calcular coordenadas x,y
  1792 0000097D 4C89C0                      mov rax, r8
  1793 00000980 41B950000000                mov r9, column_cells
  1794 00000986 4983C102                    add r9, 2                     ; Ancho total de línea
  1795 0000098A 4831D2                      xor rdx, rdx
  1796 0000098D 49F7F1                      div r9                        ; rax = y, rdx = x
  1797                                      
  1798                                      ; Guardar coordenadas
  1799 00000990 4989C2                      mov r10, rax                  ; Y en r10
  1800 00000993 4989D3                      mov r11, rdx                  ; X en r11
  1801                                      
  1802                                      ; Validar coordenadas
  1803 00000996 4983FA00                    cmp r10, 0
  1804 0000099A 7C53                        jl .end
  1805 0000099C 4983FA20                    cmp r10, row_cells
  1806 000009A0 7D4D                        jge .end
  1807 000009A2 4983FB00                    cmp r11, 0
  1808 000009A6 7C47                        jl .end
  1809 000009A8 4983FB50                    cmp r11, column_cells
  1810 000009AC 7D41                        jge .end
  1811                                      
  1812                                      ; Calcular índice para el primer láser
  1813 000009AE 480FB61D(0B230000)          movzx rbx, byte [laser_count]
  1814 000009B6 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1815                                      
  1816                                      ; Primer láser (izquierda)
  1817 000009BA 488DBB[0C230000]            lea rdi, [lasers + rbx]
  1818 000009C1 44881F                      mov [rdi], r11b              ; X
  1819 000009C4 4488D0                      mov al, r10b
  1820 000009C7 FEC8                        dec al                       ; Y - 1
  1821 000009C9 884701                      mov [rdi + 1], al           ; Y
  1822                                      
  1823                                      ; Segundo láser (derecha)
  1824 000009CC 4488D8                      mov al, r11b
  1825 000009CF 0205(C7140000)              add al, byte [pallet_size]
  1826 000009D5 FEC8                        dec al                       ; Ajustar para el último carácter
  1827 000009D7 488DBB[0E230000]            lea rdi, [lasers + rbx + 2]
  1828 000009DE 8807                        mov [rdi], al               ; X
  1829 000009E0 4488D0                      mov al, r10b
  1830 000009E3 FEC8                        dec al                      ; Y - 1
  1831 000009E5 884701                      mov [rdi + 1], al          ; Y
  1832                                      
  1833                                      ; Incrementar contador de láseres
  1834 000009E8 8005(0B230000)02            add byte [laser_count], 2
  1835                                      
  1836                                      
  1837                                      .end:
  1838 000009EF 5B                              pop rbx
  1839 000009F0 5D                              pop rbp
  1840 000009F1 C3                              ret
  1841                                  
  1842                                  ; Función corregida para mover láseres
  1843                                  ; Función corregida para mover láseres
  1844                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1845                                  
  1846                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1847                                  ; ============================================================
  1848                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1849                                  ; ============================================================
  1850                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1851                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1852                                  ; ============================================================
  1853                                  move_lasers:
  1854 000009F2 55                          push rbp
  1855 000009F3 4889E5                      mov  rbp, rsp
  1856 000009F6 53                          push rbx
  1857 000009F7 57                          push rdi
  1858 000009F8 56                          push rsi
  1859 000009F9 4154                        push r12
  1860 000009FB 4155                        push r13
  1861 000009FD 4156                        push r14
  1862 000009FF 4157                        push r15
  1863                                  
  1864                                      ; 1) Tomamos la cantidad de láseres
  1865 00000A01 480FB60D(0B230000)          movzx rcx, byte [laser_count]
  1866 00000A09 4885C9                      test rcx, rcx
  1867 00000A0C 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1868                                  
  1869                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1870 00000A12 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1871                                  
  1872                                  .loop_lasers:
  1873                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1874 00000A15 488DB409[0C230000]          lea rsi, [lasers + rcx*2]
  1875                                  
  1876                                      ; 2) Cargar x,y actuales del láser
  1877 00000A1D 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1878 00000A21 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1879                                  
  1880                                      ; 3) Borrar el láser de su posición actual en pantalla
  1881                                      ;    (por si en el ciclo anterior se había dibujado)
  1882 00000A26 B850000000                  mov rax, column_cells
  1883 00000A2B 4883C002                    add rax, 2
  1884 00000A2F 49F7E1                      mul r9
  1885 00000A32 4C01C0                      add rax, r8
  1886 00000A35 488DB8[400A0000]            lea rdi, [board + rax]
  1887 00000A3C C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1888                                  
  1889                                      ; 4) Mover el láser hacia arriba (y - 1)
  1890 00000A3F 49FFC9                      dec r9
  1891                                  
  1892                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1893 00000A42 4983F901                    cmp r9, 1
  1894 00000A46 7C57                        jl .delete_laser
  1895                                  
  1896                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1897 00000A48 44884E01                    mov byte [rsi + 1], r9b
  1898                                  
  1899                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1900                                      ;    - Primero colisión con bloques
  1901                                      ; ---------------------------------------------------------
  1902                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1903 00000A4C B850000000                  mov rax, column_cells
  1904 00000A51 4883C002                    add rax, 2
  1905 00000A55 49F7E1                      mul r9
  1906 00000A58 4C01C0                      add rax, r8
  1907 00000A5B 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1908                                  
  1909                                      ; Revisar si hay bloque
  1910 00000A62 51                          push rcx
  1911 00000A63 56                          push rsi
  1912 00000A64 57                          push rdi
  1913 00000A65 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1914 00000A68 E85E100000                  call check_block_collision
  1915 00000A6D 5F                          pop rdi
  1916 00000A6E 5E                          pop rsi
  1917 00000A6F 59                          pop rcx
  1918                                  
  1919 00000A70 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1920 00000A73 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1921                                  
  1922                                      ;    - Luego colisión con enemigos
  1923                                      ; ---------------------------------------------------------
  1924 00000A75 51                          push rcx
  1925 00000A76 56                          push rsi
  1926 00000A77 57                          push rdi
  1927                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1928                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1929                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1930                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1931                                      ;
  1932                                      ; Hacemos algo como:
  1933 00000A78 4989FA                      mov r10, rdi
  1934 00000A7B E85A000000                  call check_laser_enemy_collision
  1935 00000A80 5F                          pop rdi
  1936 00000A81 5E                          pop rsi
  1937 00000A82 59                          pop rcx
  1938                                  
  1939 00000A83 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1940 00000A86 7517                        jnz .delete_laser
  1941                                  
  1942                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1943 00000A88 8A05(0A230000)              mov al, [laser_symbol]
  1944 00000A8E 8807                        mov [rdi], al
  1945                                  
  1946                                  .next_laser:
  1947                                      ; Pasamos al láser anterior en el array
  1948 00000A90 48FFC9                      dec rcx
  1949 00000A93 4883F9FF                    cmp rcx, -1
  1950 00000A97 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1951 00000A9D EB2E                        jmp .fin
  1952                                  
  1953                                  ; -----------------------------------------------------------------
  1954                                  ; Subrutina interna: .delete_laser
  1955                                  ; -----------------------------------------------------------------
  1956                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1957                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1958                                  .delete_laser:
  1959 00000A9F 4C0FB625(0B230000)          movzx r12, byte [laser_count]
  1960 00000AA7 49FFCC                      dec r12                    ; r12 = índice del último láser
  1961 00000AAA 4939CC                      cmp r12, rcx
  1962 00000AAD 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1963                                  
  1964                                      ; Copiamos el último láser a la posición actual
  1965 00000AAF 488DBC09[0C230000]          lea rdi, [lasers + rcx*2]
  1966 00000AB7 4B8DB424[0C230000]          lea rsi, [lasers + r12*2]
  1967 00000ABF 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1968 00000AC2 668907                      mov [rdi], ax             ; copiamos X,Y
  1969                                  
  1970                                  .just_decrement:
  1971 00000AC5 FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1972 00000ACB EBC3                        jmp .next_laser
  1973                                  
  1974                                  .fin:
  1975 00000ACD 415F                        pop r15
  1976 00000ACF 415E                        pop r14
  1977 00000AD1 415D                        pop r13
  1978 00000AD3 415C                        pop r12
  1979 00000AD5 5E                          pop rsi
  1980 00000AD6 5F                          pop rdi
  1981 00000AD7 5B                          pop rbx
  1982 00000AD8 5D                          pop rbp
  1983 00000AD9 C3                          ret
  1984                                  
  1985                                  
  1986                                  ; Nueva función para verificar colisión entre láser y enemigos
  1987                                  ; ==========================================================
  1988                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1989                                  ; ==========================================================
  1990                                  check_laser_enemy_collision:
  1991 00000ADA 55                          push rbp
  1992 00000ADB 4889E5                      mov  rbp, rsp
  1993                                      
  1994 00000ADE 4D31ED                      xor r13, r13            ; Índice del enemigo
  1995 00000AE1 4831C0                      xor rax, rax            ; 0 = no colisión
  1996                                  
  1997                                  .loop_enemies:
  1998 00000AE4 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1999 00000AE8 7D64                        jge .end
  2000                                  
  2001                                      ; r13 * 3 => offset del enemigo i
  2002 00000AEA 4C89E9                      mov rcx, r13
  2003 00000AED 486BC903                    imul rcx, 3
  2004 00000AF1 488DB1[60200000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  2005                                  
  2006                                      ; Verificar si está activo
  2007 00000AF8 807E0201                    cmp byte [rsi+2], 1
  2008 00000AFC 754B                        jne .next_enemy
  2009                                  
  2010                                      ; Cargar posición X/Y del enemigo
  2011 00000AFE 4C0FB636                    movzx r14, byte [rsi]      ; X
  2012 00000B02 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  2013                                  
  2014                                      ; Comparar con posición del láser (r8=X, r9=Y)
  2015 00000B07 4D39F0                      cmp r8, r14
  2016 00000B0A 753D                        jne .next_enemy
  2017 00000B0C 4D39F9                      cmp r9, r15
  2018 00000B0F 7538                        jne .next_enemy
  2019                                  
  2020                                      ; ==== Colisión detectada con láser ====
  2021                                  
  2022                                      ; 1) Desactivar enemigo
  2023 00000B11 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  2024                                  
  2025                                      ; 2) Sumar puntos
  2026 00000B15 488B05(7F200000)            mov rax, [enemy_points]
  2027 00000B1C 480105(3E200000)            add [current_score], rax
  2028                                  
  2029                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  2030                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  2031 00000B23 4983FF1E                    cmp r15, row_cells - 2
  2032 00000B27 7419                        je .skip_erase
  2033                                  
  2034                                      ; Borrar visualmente del board
  2035 00000B29 B850000000                  mov rax, column_cells
  2036 00000B2E 4883C002                    add rax, 2
  2037 00000B32 49F7E7                      mul r15
  2038 00000B35 4C01F0                      add rax, r14
  2039 00000B38 488DB8[400A0000]            lea rdi, [board + rax]
  2040 00000B3F C60720                      mov byte [rdi], ' '
  2041                                  
  2042                                  .skip_erase:
  2043                                  
  2044                                      ; 4) Devolver rax=1 => colisión con enemigo
  2045 00000B42 B801000000                  mov rax, 1
  2046 00000B47 EB05                        jmp .end
  2047                                  
  2048                                  .next_enemy:
  2049 00000B49 49FFC5                      inc r13
  2050 00000B4C EB96                        jmp .loop_enemies
  2051                                  
  2052                                  .end:
  2053 00000B4E 5D                          pop rbp
  2054 00000B4F C3                          ret
  2055                                  
  2056                                  
  2057                                  ; Función auxiliar para eliminar un láser específico
  2058                                  remove_laser:
  2059 00000B50 55                          push rbp
  2060 00000B51 4889E5                      mov rbp, rsp
  2061                                  
  2062                                      ; Borrar el láser del tablero
  2063 00000B54 41C60220                    mov byte [r10], ' '
  2064                                  
  2065                                      ; Mover el último láser a esta posición si no es el último
  2066 00000B58 480FB605(0B230000)          movzx rax, byte [laser_count]
  2067 00000B60 48FFC8                      dec rax                    ; Índice del último láser
  2068 00000B63 4939C4                      cmp r12, rax              ; Comparar con láser actual
  2069 00000B66 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  2070                                  
  2071                                      ; Copiar último láser a la posición actual
  2072 00000B68 4B8DBC24[0C230000]          lea rdi, [lasers + r12*2]
  2073 00000B70 488DB400[0C230000]          lea rsi, [lasers + rax*2]
  2074 00000B78 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  2075 00000B7B 668917                      mov [rdi], dx
  2076                                  
  2077                                  .just_decrease:
  2078 00000B7E FE0D(0B230000)              dec byte [laser_count]    ; Decrementar contador de láseres
  2079                                  
  2080 00000B84 5D                          pop rbp
  2081 00000B85 C3                          ret
  2082                                  
  2083                                  add_life:
  2084 00000B86 55                          push rbp
  2085 00000B87 4889E5                      mov rbp, rsp
  2086 00000B8A 53                          push rbx
  2087 00000B8B 51                          push rcx
  2088 00000B8C 57                          push rdi
  2089 00000B8D 56                          push rsi
  2090 00000B8E 4150                        push r8
  2091 00000B90 4151                        push r9
  2092                                      
  2093                                      ; Verificar si ya tenemos el máximo de vidas
  2094 00000B92 480FB605(3B210000)          movzx rax, byte [current_lives]
  2095 00000B9A 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  2096 00000B9E 7D2C                        jge .end
  2097                                      
  2098                                      ; Incrementar el contador de vidas
  2099 00000BA0 FE05(3B210000)              inc byte [current_lives]
  2100                                      
  2101                                      ; Encontrar la siguiente vida inactiva
  2102 00000BA6 4831C9                      xor rcx, rcx
  2103                                      
  2104                                      .find_inactive:
  2105 00000BA9 4883F907                        cmp rcx, lives_count
  2106 00000BAD 7D1D                            jge .end
  2107                                          
  2108                                          ; Calcular offset de la vida actual
  2109 00000BAF 4889C8                          mov rax, rcx
  2110 00000BB2 486BC003                        imul rax, 3
  2111 00000BB6 488DB0[25210000]                lea rsi, [lives_data + rax]
  2112                                          
  2113                                          ; Verificar si está inactiva
  2114 00000BBD 807E0200                        cmp byte [rsi + 2], 0
  2115 00000BC1 7405                            je .activate_life
  2116                                          
  2117 00000BC3 48FFC1                          inc rcx
  2118 00000BC6 EBE1                            jmp .find_inactive
  2119                                          
  2120                                      .activate_life:
  2121                                          ; Activar la vida
  2122 00000BC8 C6460201                        mov byte [rsi + 2], 1
  2123                                          
  2124                                      .end:
  2125 00000BCC 4159                            pop r9
  2126 00000BCE 4158                            pop r8
  2127 00000BD0 5E                              pop rsi
  2128 00000BD1 5F                              pop rdi
  2129 00000BD2 59                              pop rcx
  2130 00000BD3 5B                              pop rbx
  2131 00000BD4 5D                              pop rbp
  2132 00000BD5 C3                              ret
  2133                                  
  2134                                  
  2135                                  print_ball:
  2136 00000BD6 4C8B05(DF140000)        	mov r8, [ball_x_pos]
  2137 00000BDD 4C8B0D(E7140000)        	mov r9, [ball_y_pos]
  2138 00000BE4 4981C0[400A0000]        	add r8, board
  2139                                  
  2140 00000BEB 4C89C9                  	mov rcx, r9
  2141 00000BEE B852000000              	mov rax, column_cells + 2
  2142 00000BF3 48F7E9                  	imul rcx
  2143                                  	
  2144 00000BF6 4901C0                  	add r8, rax
  2145 00000BF9 41C6004F                	mov byte [r8], char_O
  2146 00000BFD C3                      	ret
  2147                                  
  2148                                  print_ball_2:
  2149 00000BFE 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2150 00000C05 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  2151 00000C0C 4981C0[400A0000]            add r8, board
  2152 00000C13 4C89C9                      mov rcx, r9
  2153 00000C16 B852000000                  mov rax, column_cells + 2
  2154 00000C1B 48F7E9                      imul rcx
  2155 00000C1E 4901C0                      add r8, rax
  2156 00000C21 41C6004F                    mov byte [r8], char_O
  2157 00000C25 C3                          ret
  2158                                  
  2159                                  print_ball_3:
  2160 00000C26 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2161 00000C2D 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2162 00000C34 4981C0[400A0000]            add r8, board
  2163 00000C3B 4C89C9                      mov rcx, r9
  2164 00000C3E B852000000                  mov rax, column_cells + 2
  2165 00000C43 48F7E9                      imul rcx
  2166 00000C46 4901C0                      add r8, rax
  2167 00000C49 41C6004F                    mov byte [r8], char_O
  2168 00000C4D C3                          ret
  2169                                  
  2170                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  2171                                  	
  2172                                  print_pallet:
  2173                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  2174 00000C4E 4C8B05(BF140000)            mov r8, [pallet_position]
  2175 00000C55 488B0D(C7140000)            mov rcx, [pallet_size]
  2176                                      .clear_pallet:
  2177 00000C5C 41C60020                        mov byte [r8], char_space
  2178 00000C60 49FFC0                          inc r8
  2179 00000C63 48FFC9                          dec rcx
  2180 00000C66 75F4                            jnz .clear_pallet
  2181                                  
  2182                                      ; Luego dibujar la nueva paleta con el tamaño actual
  2183 00000C68 4C8B05(BF140000)            mov r8, [pallet_position]
  2184 00000C6F 488B0D(C7140000)            mov rcx, [pallet_size]
  2185                                      .write_pallet:
  2186 00000C76 41C6003D                        mov byte [r8], char_equal
  2187 00000C7A 49FFC0                          inc r8
  2188 00000C7D 48FFC9                          dec rcx
  2189 00000C80 75F4                            jnz .write_pallet
  2190                                  
  2191 00000C82 C3                          ret
  2192                                  
  2193                                  move_pallet:
  2194                                      
  2195 00000C83 803D(FF140000)00            cmp byte [ball_moving], 0
  2196 00000C8A 7507                        jne .continue_movement
  2197 00000C8C C605(FF140000)01            mov byte [ball_moving], 1
  2198                                  
  2199                                      .continue_movement:
  2200 00000C93 4883FFFF                        cmp rdi, left_direction
  2201 00000C97 7531                            jne .move_right
  2202                                  
  2203                                          .move_left:
  2204                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  2205 00000C99 4C8B05(BF140000)                    mov r8, [pallet_position]
  2206 00000CA0 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  2207 00000CA3 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2208 00000CA6 3C58                                cmp al, 'X'        ; Comparar si es una X
  2209 00000CA8 744D                                je .end            ; Si es X, no mover
  2210                                              
  2211 00000CAA 4C8B05(BF140000)                    mov r8, [pallet_position]
  2212 00000CB1 4C8B0D(C7140000)                    mov r9, [pallet_size]
  2213 00000CB8 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  2214 00000CBE 49FFC8                              dec r8
  2215 00000CC1 4C8905(BF140000)                    mov [pallet_position], r8
  2216 00000CC8 EB2D                                jmp .end
  2217                                              
  2218                                          .move_right:
  2219                                              ; Verificar si la siguiente posición después de la paleta sería una X
  2220 00000CCA 4C8B05(BF140000)                    mov r8, [pallet_position]
  2221 00000CD1 4C8B0D(C7140000)                    mov r9, [pallet_size]
  2222 00000CD8 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  2223 00000CDB 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  2224 00000CDE 3C58                                cmp al, 'X'        ; Comparar si es una X
  2225 00000CE0 7415                                je .end            ; Si es X, no mover
  2226                                              
  2227 00000CE2 4C8B05(BF140000)                    mov r8, [pallet_position]
  2228 00000CE9 41C60020                            mov byte [r8], char_space
  2229 00000CED 49FFC0                              inc r8
  2230 00000CF0 4C8905(BF140000)                    mov [pallet_position], r8
  2231                                          .end:
  2232 00000CF7 C3                                  ret
  2233                                  
  2234                                  
  2235                                  
  2236                                              
  2237                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  2238                                  update_caught_ball_position:
  2239 00000CF8 55                          push rbp
  2240 00000CF9 4889E5                      mov rbp, rsp
  2241                                      
  2242                                      ; Calcular la nueva posición de la bola basada en la paleta
  2243 00000CFC 4C8B05(BF140000)            mov r8, [pallet_position]
  2244 00000D03 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  2245 00000D0A B852000000                  mov rax, column_cells + 2
  2246 00000D0F 4831D2                      xor rdx, rdx
  2247 00000D12 48F7F0                      div rax                ; División para obtener X,Y
  2248                                      
  2249                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  2250 00000D15 4989C1                      mov r9, rax            ; Y de la paleta
  2251 00000D18 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  2252                                      
  2253                                      ; Añadir el offset guardado a la posición X
  2254 00000D1B 4889D0                      mov rax, rdx
  2255 00000D1E 480305(00230000)            add rax, [ball_catch_offset]
  2256 00000D25 488905(DF140000)            mov [ball_x_pos], rax
  2257 00000D2C 4C890D(E7140000)            mov [ball_y_pos], r9
  2258                                      
  2259 00000D33 5D                          pop rbp
  2260 00000D34 C3                          ret
  2261                                  
  2262                                  
  2263                                  move_all_balls:
  2264 00000D35 55                          push rbp
  2265 00000D36 4889E5                      mov rbp, rsp
  2266 00000D39 53                          push rbx
  2267                                      
  2268                                      ; Inicializar contador de bolas
  2269 00000D3A 4831DB                      xor rbx, rbx
  2270                                      
  2271                                  .loop_balls:
  2272                                      ; Verificar si hemos procesado todas las bolas
  2273 00000D3D 3A1D(3F240000)              cmp bl, byte [balls_count]
  2274 00000D43 7D1D                        jge .end
  2275                                      
  2276                                      ; Calcular offset de la bola actual
  2277 00000D45 B821000000                  mov rax, BALL_STRUCT_SIZE
  2278 00000D4A 48F7E3                      mul rbx
  2279                                      
  2280                                      ; Verificar si la bola está activa
  2281 00000D4D 80B8[FC230000]01            cmp byte [balls_data + rax + 32], 1
  2282 00000D54 7507                        jne .next_ball
  2283                                      
  2284                                      ; Guardar offset en la pila
  2285 00000D56 50                          push rax
  2286                                      
  2287                                      ; Llamar a move_ball con los parámetros de esta bola
  2288 00000D57 E809000000                  call move_ball
  2289                                      
  2290                                      ; Restaurar offset
  2291 00000D5C 58                          pop rax
  2292                                      
  2293                                  .next_ball:
  2294 00000D5D 48FFC3                      inc rbx
  2295 00000D60 EBDB                        jmp .loop_balls
  2296                                      
  2297                                  .end:
  2298 00000D62 5B                          pop rbx
  2299 00000D63 5D                          pop rbp
  2300 00000D64 C3                          ret
  2301                                  
  2302                                  move_ball:
  2303                                  
  2304 00000D65 803D(FD220000)01            cmp byte [ball_caught], 1
  2305 00000D6C 0F849D000000                je .move_with_pallet
  2306                                  
  2307 00000D72 803D(FF140000)00            cmp byte [ball_moving], 0
  2308 00000D79 0F84B8010000                je .end
  2309                                  
  2310                                      ; Incrementar contador de velocidad
  2311 00000D7F 48FF05(F3220000)            inc qword [speed_counter]
  2312                                      
  2313                                      ; Verificar si debemos mover la bola en este ciclo
  2314 00000D86 488B05(F3220000)            mov rax, [speed_counter]
  2315 00000D8D 483B05(E3220000)            cmp rax, [ball_speed]
  2316 00000D94 0F8C9D010000                jl .end
  2317                                      
  2318                                      ; Resetear contador de velocidad
  2319 00000D9A 48C705(F3220000)00-         mov qword [speed_counter], 0
  2319 00000DA2 000000             
  2320                                  
  2321                                      ; Borrar la posición actual de la bola
  2322 00000DA5 4C8B05(DF140000)            mov r8, [ball_x_pos]
  2323 00000DAC 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  2324 00000DB3 4981C0[400A0000]            add r8, board
  2325 00000DBA 4C89C9                      mov rcx, r9
  2326 00000DBD B852000000                  mov rax, column_cells + 2
  2327 00000DC2 48F7E9                      imul rcx
  2328 00000DC5 4901C0                      add r8, rax
  2329 00000DC8 41C60020                    mov byte [r8], char_space
  2330                                  
  2331                                      ; Calcular siguiente posición X
  2332 00000DCC 4C8B05(DF140000)            mov r8, [ball_x_pos]
  2333 00000DD3 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  2334 00000DDA 488B05(EF140000)            mov rax, [ball_direction_x]
  2335 00000DE1 4901C0                      add r8, rax               ; Nueva posición X
  2336                                  
  2337                                      ; Calcular la dirección de memoria para la siguiente posición
  2338 00000DE4 4D89C2                      mov r10, r8
  2339 00000DE7 4981C2[400A0000]            add r10, board
  2340 00000DEE 4C89C9                      mov rcx, r9
  2341 00000DF1 B852000000                  mov rax, column_cells + 2
  2342 00000DF6 48F7E9                      imul rcx
  2343 00000DF9 4901C2                      add r10, rax
  2344                                  
  2345                                      ; Verificar si hay una X en la siguiente posición X
  2346 00000DFC 418A02                      mov al, [r10]
  2347 00000DFF 3C58                        cmp al, 'X'
  2348 00000E01 7565                        jne .check_block_x
  2349 00000E03 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  2350 00000E0A E928010000                  jmp .end
  2351                                  
  2352                                      .move_with_pallet:
  2353                                          ; Borrar la posición actual de la bola
  2354 00000E0F 4C8B05(DF140000)                mov r8, [ball_x_pos]
  2355 00000E16 4C8B0D(E7140000)                mov r9, [ball_y_pos]
  2356 00000E1D 4D89C2                          mov r10, r8
  2357 00000E20 4981C2[400A0000]                add r10, board
  2358 00000E27 4C89C9                          mov rcx, r9
  2359 00000E2A B852000000                      mov rax, column_cells + 2
  2360 00000E2F 48F7E9                          imul rcx
  2361 00000E32 4901C2                          add r10, rax
  2362 00000E35 41C60220                        mov byte [r10], char_space
  2363                                  
  2364                                          ; Actualizar posición X basada en la paleta
  2365 00000E39 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2366 00000E40 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2367 00000E47 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2368 00000E4E 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  2369                                  
  2370                                          ; Mantener la bola una posición arriba de la paleta
  2371 00000E55 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  2372 00000E5C 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  2373                                  
  2374 00000E63 E9CF000000                      jmp .end
  2375                                  
  2376                                  
  2377                                      .check_block_x:
  2378                                          ; Verificar colisión con bloques en X
  2379 00000E68 4150                            push r8     ; Guardar registros que usa check_block_collision
  2380 00000E6A 4151                            push r9
  2381 00000E6C 4152                            push r10
  2382 00000E6E E8580C0000                      call check_block_collision
  2383 00000E73 415A                            pop r10
  2384 00000E75 4159                            pop r9
  2385 00000E77 4158                            pop r8
  2386 00000E79 4885C0                          test rax, rax
  2387 00000E7C 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2388 00000E7E 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  2389 00000E85 E9AD000000                      jmp .end
  2390                                  
  2391                                      .check_paddle_x:
  2392                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2393 00000E8A 41803A3D                        cmp byte [r10], char_equal
  2394 00000E8E 750C                            jne .check_y_movement
  2395 00000E90 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  2396 00000E97 E99B000000                      jmp .end
  2397                                  
  2398                                      .check_y_movement:
  2399                                          ; Calcular siguiente posición Y
  2400 00000E9C 488B05(F7140000)                mov rax, [ball_direction_y]
  2401 00000EA3 4901C1                          add r9, rax                  ; Nueva posición Y
  2402                                  
  2403                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2404 00000EA6 4D89C2                          mov r10, r8
  2405 00000EA9 4981C2[400A0000]                add r10, board
  2406 00000EB0 4C89C9                          mov rcx, r9
  2407 00000EB3 B852000000                      mov rax, column_cells + 2
  2408 00000EB8 48F7E9                          imul rcx
  2409 00000EBB 4901C2                          add r10, rax
  2410                                  
  2411                                          ; Verificar si hay una X en la siguiente posición Y
  2412 00000EBE 418A02                          mov al, [r10]
  2413 00000EC1 3C58                            cmp al, 'X'
  2414 00000EC3 7509                            jne .check_block_y
  2415 00000EC5 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  2416 00000ECC EB69                            jmp .end
  2417                                  
  2418                                      .check_block_y:
  2419                                          ; Verificar colisión con bloques en Y
  2420 00000ECE 4150                            push r8     ; Guardar registros que usa check_block_collision
  2421 00000ED0 4151                            push r9
  2422 00000ED2 4152                            push r10
  2423 00000ED4 E8F20B0000                      call check_block_collision
  2424 00000ED9 415A                            pop r10
  2425 00000EDB 4159                            pop r9
  2426 00000EDD 4158                            pop r8
  2427 00000EDF 4885C0                          test rax, rax
  2428 00000EE2 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2429 00000EE4 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  2430 00000EEB EB4A                            jmp .end
  2431                                  
  2432                                      .check_paddle_y:
  2433                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2434 00000EED 41803A3D                        cmp byte [r10], char_equal
  2435 00000EF1 7536                            jne .update_position
  2436                                  
  2437                                          ; Verificar si el poder catch está activo
  2438 00000EF3 803D(FC220000)01                cmp byte [catch_power_active], 1
  2439 00000EFA 7524                            jne .normal_bounce
  2440                                  
  2441                                          ; Activar el modo "atrapado"
  2442 00000EFC C605(FD220000)01                mov byte [ball_caught], 1
  2443                                          
  2444                                          ; Guardar la posición X actual de la bola como offset
  2445 00000F03 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  2446 00000F0A 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2447 00000F11 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2448 00000F17 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2449                                          
  2450 00000F1E EB17                            jmp .end
  2451                                  
  2452                                      .normal_bounce:
  2453 00000F20 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  2454 00000F27 EB0E                            jmp .end
  2455                                  
  2456                                  
  2457                                      .update_position:
  2458 00000F29 4C8905(DF140000)                mov [ball_x_pos], r8
  2459 00000F30 4C890D(E7140000)                mov [ball_y_pos], r9
  2460                                  
  2461                                      .end:
  2462 00000F37 C3                              ret
  2463                                  
  2464                                  
  2465                                  move_ball_2:
  2466                                  
  2467 00000F38 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2468 00000F3F 0F849D000000                je .move_with_pallet
  2469                                  
  2470 00000F45 803D(21150000)00            cmp byte [ball2_moving], 0
  2471 00000F4C 0F84B8010000                je .end
  2472                                  
  2473                                      ; Incrementar contador de velocidad
  2474 00000F52 48FF05(F3220000)            inc qword [speed_counter]
  2475                                      
  2476                                      ; Verificar si debemos mover la bola en este ciclo
  2477 00000F59 488B05(F3220000)            mov rax, [speed_counter]
  2478 00000F60 483B05(E3220000)            cmp rax, [ball_speed]
  2479 00000F67 0F8C9D010000                jl .end
  2480                                      
  2481                                      ; Resetear contador de velocidad
  2482 00000F6D 48C705(F3220000)00-         mov qword [speed_counter], 0
  2482 00000F75 000000             
  2483                                  
  2484                                      ; Borrar la posición actual de la bola
  2485 00000F78 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2486 00000F7F 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  2487 00000F86 4981C0[400A0000]            add r8, board
  2488 00000F8D 4C89C9                      mov rcx, r9
  2489 00000F90 B852000000                  mov rax, column_cells + 2
  2490 00000F95 48F7E9                      imul rcx
  2491 00000F98 4901C0                      add r8, rax
  2492 00000F9B 41C60020                    mov byte [r8], char_space
  2493                                  
  2494                                      ; Calcular siguiente posición X
  2495 00000F9F 4C8B05(01150000)            mov r8, [ball2_x_pos]
  2496 00000FA6 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  2497 00000FAD 488B05(11150000)            mov rax, [ball2_direction_x]
  2498 00000FB4 4901C0                      add r8, rax               ; Nueva posición X
  2499                                  
  2500                                      ; Calcular la dirección de memoria para la siguiente posición
  2501 00000FB7 4D89C2                      mov r10, r8
  2502 00000FBA 4981C2[400A0000]            add r10, board
  2503 00000FC1 4C89C9                      mov rcx, r9
  2504 00000FC4 B852000000                  mov rax, column_cells + 2
  2505 00000FC9 48F7E9                      imul rcx
  2506 00000FCC 4901C2                      add r10, rax
  2507                                  
  2508                                      ; Verificar si hay una X en la siguiente posición X
  2509 00000FCF 418A02                      mov al, [r10]
  2510 00000FD2 3C58                        cmp al, 'X'
  2511 00000FD4 7565                        jne .check_block_x
  2512 00000FD6 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  2513 00000FDD E928010000                  jmp .end
  2514                                  
  2515                                      .move_with_pallet:
  2516                                          ; Borrar la posición actual de la bola
  2517 00000FE2 4C8B05(01150000)                mov r8, [ball2_x_pos]
  2518 00000FE9 4C8B0D(09150000)                mov r9, [ball2_y_pos]
  2519 00000FF0 4D89C2                          mov r10, r8
  2520 00000FF3 4981C2[400A0000]                add r10, board
  2521 00000FFA 4C89C9                          mov rcx, r9
  2522 00000FFD B852000000                      mov rax, column_cells + 2
  2523 00001002 48F7E9                          imul rcx
  2524 00001005 4901C2                          add r10, rax
  2525 00001008 41C60220                        mov byte [r10], char_space
  2526                                  
  2527                                          ; Actualizar posición X basada en la paleta
  2528 0000100C 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2529 00001013 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2530 0000101A 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2531 00001021 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  2532                                  
  2533                                          ; Mantener la bola una posición arriba de la paleta
  2534 00001028 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  2535 0000102F 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  2536                                  
  2537 00001036 E9CF000000                      jmp .end
  2538                                  
  2539                                  
  2540                                      .check_block_x:
  2541                                          ; Verificar colisión con bloques en X
  2542 0000103B 4150                            push r8     ; Guardar registros que usa check_block_collision
  2543 0000103D 4151                            push r9
  2544 0000103F 4152                            push r10
  2545 00001041 E8850A0000                      call check_block_collision
  2546 00001046 415A                            pop r10
  2547 00001048 4159                            pop r9
  2548 0000104A 4158                            pop r8
  2549 0000104C 4885C0                          test rax, rax
  2550 0000104F 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2551 00001051 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  2552 00001058 E9AD000000                      jmp .end
  2553                                  
  2554                                      .check_paddle_x:
  2555                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2556 0000105D 41803A3D                        cmp byte [r10], char_equal
  2557 00001061 750C                            jne .check_y_movement
  2558 00001063 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  2559 0000106A E99B000000                      jmp .end
  2560                                  
  2561                                      .check_y_movement:
  2562                                          ; Calcular siguiente posición Y
  2563 0000106F 488B05(19150000)                mov rax, [ball2_direction_y]
  2564 00001076 4901C1                          add r9, rax                  ; Nueva posición Y
  2565                                  
  2566                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2567 00001079 4D89C2                          mov r10, r8
  2568 0000107C 4981C2[400A0000]                add r10, board
  2569 00001083 4C89C9                          mov rcx, r9
  2570 00001086 B852000000                      mov rax, column_cells + 2
  2571 0000108B 48F7E9                          imul rcx
  2572 0000108E 4901C2                          add r10, rax
  2573                                  
  2574                                          ; Verificar si hay una X en la siguiente posición Y
  2575 00001091 418A02                          mov al, [r10]
  2576 00001094 3C58                            cmp al, 'X'
  2577 00001096 7509                            jne .check_block_y
  2578 00001098 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  2579 0000109F EB69                            jmp .end
  2580                                  
  2581                                      .check_block_y:
  2582                                          ; Verificar colisión con bloques en Y
  2583 000010A1 4150                            push r8     ; Guardar registros que usa check_block_collision
  2584 000010A3 4151                            push r9
  2585 000010A5 4152                            push r10
  2586 000010A7 E81F0A0000                      call check_block_collision
  2587 000010AC 415A                            pop r10
  2588 000010AE 4159                            pop r9
  2589 000010B0 4158                            pop r8
  2590 000010B2 4885C0                          test rax, rax
  2591 000010B5 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2592 000010B7 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  2593 000010BE EB4A                            jmp .end
  2594                                  
  2595                                      .check_paddle_y:
  2596                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2597 000010C0 41803A3D                        cmp byte [r10], char_equal
  2598 000010C4 7536                            jne .update_position
  2599                                  
  2600                                          ; Verificar si el poder catch está activo
  2601 000010C6 803D(FC220000)01                cmp byte [catch_power_active], 1
  2602 000010CD 7524                            jne .normal_bounce
  2603                                  
  2604                                          ; Activar el modo "atrapado"
  2605 000010CF C605(FE220000)01                mov byte [ball_caught_2], 1
  2606                                          
  2607                                          ; Guardar la posición X actual de la bola como offset
  2608 000010D6 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2609 000010DD 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2610 000010E4 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2611 000010EA 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2612                                          
  2613 000010F1 EB17                            jmp .end
  2614                                  
  2615                                      .normal_bounce:
  2616 000010F3 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2617 000010FA EB0E                            jmp .end
  2618                                  
  2619                                  
  2620                                      .update_position:
  2621 000010FC 4C8905(01150000)                mov [ball2_x_pos], r8
  2622 00001103 4C890D(09150000)                mov [ball2_y_pos], r9
  2623                                  
  2624                                      .end:
  2625 0000110A C3                              ret
  2626                                  
  2627                                  move_ball_3:
  2628                                  
  2629 0000110B 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2630 00001112 0F849D000000                je .move_with_pallet
  2631                                  
  2632 00001118 803D(43150000)00            cmp byte [ball3_moving], 0
  2633 0000111F 0F84B8010000                je .end
  2634                                  
  2635                                      ; Incrementar contador de velocidad
  2636 00001125 48FF05(F3220000)            inc qword [speed_counter]
  2637                                      
  2638                                      ; Verificar si debemos mover la bola en este ciclo
  2639 0000112C 488B05(F3220000)            mov rax, [speed_counter]
  2640 00001133 483B05(E3220000)            cmp rax, [ball_speed]
  2641 0000113A 0F8C9D010000                jl .end
  2642                                      
  2643                                      ; Resetear contador de velocidad
  2644 00001140 48C705(F3220000)00-         mov qword [speed_counter], 0
  2644 00001148 000000             
  2645                                  
  2646                                      ; Borrar la posición actual de la bola
  2647 0000114B 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2648 00001152 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2649 00001159 4981C0[400A0000]            add r8, board
  2650 00001160 4C89C9                      mov rcx, r9
  2651 00001163 B852000000                  mov rax, column_cells + 2
  2652 00001168 48F7E9                      imul rcx
  2653 0000116B 4901C0                      add r8, rax
  2654 0000116E 41C60020                    mov byte [r8], char_space
  2655                                  
  2656                                      ; Calcular siguiente posición X
  2657 00001172 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2658 00001179 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2659 00001180 488B05(33150000)            mov rax, [ball3_direction_x]
  2660 00001187 4901C0                      add r8, rax               ; Nueva posición X
  2661                                  
  2662                                      ; Calcular la dirección de memoria para la siguiente posición
  2663 0000118A 4D89C2                      mov r10, r8
  2664 0000118D 4981C2[400A0000]            add r10, board
  2665 00001194 4C89C9                      mov rcx, r9
  2666 00001197 B852000000                  mov rax, column_cells + 2
  2667 0000119C 48F7E9                      imul rcx
  2668 0000119F 4901C2                      add r10, rax
  2669                                  
  2670                                      ; Verificar si hay una X en la siguiente posición X
  2671 000011A2 418A02                      mov al, [r10]
  2672 000011A5 3C58                        cmp al, 'X'
  2673 000011A7 7565                        jne .check_block_x
  2674 000011A9 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2675 000011B0 E928010000                  jmp .end
  2676                                  
  2677                                      .move_with_pallet:
  2678                                          ; Borrar la posición actual de la bola
  2679 000011B5 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2680 000011BC 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2681 000011C3 4D89C2                          mov r10, r8
  2682 000011C6 4981C2[400A0000]                add r10, board
  2683 000011CD 4C89C9                          mov rcx, r9
  2684 000011D0 B852000000                      mov rax, column_cells + 2
  2685 000011D5 48F7E9                          imul rcx
  2686 000011D8 4901C2                          add r10, rax
  2687 000011DB 41C60220                        mov byte [r10], char_space
  2688                                  
  2689                                          ; Actualizar posición X basada en la paleta
  2690 000011DF 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2691 000011E6 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2692 000011ED 4C0305(00230000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2693 000011F4 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2694                                  
  2695                                          ; Mantener la bola una posición arriba de la paleta
  2696 000011FB 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2697 00001202 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2698                                  
  2699 00001209 E9CF000000                      jmp .end
  2700                                  
  2701                                  
  2702                                      .check_block_x:
  2703                                          ; Verificar colisión con bloques en X
  2704 0000120E 4150                            push r8     ; Guardar registros que usa check_block_collision
  2705 00001210 4151                            push r9
  2706 00001212 4152                            push r10
  2707 00001214 E8B2080000                      call check_block_collision
  2708 00001219 415A                            pop r10
  2709 0000121B 4159                            pop r9
  2710 0000121D 4158                            pop r8
  2711 0000121F 4885C0                          test rax, rax
  2712 00001222 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2713 00001224 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2714 0000122B E9AD000000                      jmp .end
  2715                                  
  2716                                      .check_paddle_x:
  2717                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2718 00001230 41803A3D                        cmp byte [r10], char_equal
  2719 00001234 750C                            jne .check_y_movement
  2720 00001236 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2721 0000123D E99B000000                      jmp .end
  2722                                  
  2723                                      .check_y_movement:
  2724                                          ; Calcular siguiente posición Y
  2725 00001242 488B05(3B150000)                mov rax, [ball3_direction_y]
  2726 00001249 4901C1                          add r9, rax                  ; Nueva posición Y
  2727                                  
  2728                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2729 0000124C 4D89C2                          mov r10, r8
  2730 0000124F 4981C2[400A0000]                add r10, board
  2731 00001256 4C89C9                          mov rcx, r9
  2732 00001259 B852000000                      mov rax, column_cells + 2
  2733 0000125E 48F7E9                          imul rcx
  2734 00001261 4901C2                          add r10, rax
  2735                                  
  2736                                          ; Verificar si hay una X en la siguiente posición Y
  2737 00001264 418A02                          mov al, [r10]
  2738 00001267 3C58                            cmp al, 'X'
  2739 00001269 7509                            jne .check_block_y
  2740 0000126B 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2741 00001272 EB69                            jmp .end
  2742                                  
  2743                                      .check_block_y:
  2744                                          ; Verificar colisión con bloques en Y
  2745 00001274 4150                            push r8     ; Guardar registros que usa check_block_collision
  2746 00001276 4151                            push r9
  2747 00001278 4152                            push r10
  2748 0000127A E84C080000                      call check_block_collision
  2749 0000127F 415A                            pop r10
  2750 00001281 4159                            pop r9
  2751 00001283 4158                            pop r8
  2752 00001285 4885C0                          test rax, rax
  2753 00001288 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2754 0000128A 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2755 00001291 EB4A                            jmp .end
  2756                                  
  2757                                      .check_paddle_y:
  2758                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2759 00001293 41803A3D                        cmp byte [r10], char_equal
  2760 00001297 7536                            jne .update_position
  2761                                  
  2762                                          ; Verificar si el poder catch está activo
  2763 00001299 803D(FC220000)01                cmp byte [catch_power_active], 1
  2764 000012A0 7524                            jne .normal_bounce
  2765                                  
  2766                                          ; Activar el modo "atrapado"
  2767 000012A2 C605(FF220000)01                mov byte [ball_caught_3], 1
  2768                                          
  2769                                          ; Guardar la posición X actual de la bola como offset
  2770 000012A9 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2771 000012B0 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2772 000012B7 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2773 000012BD 488905(00230000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2774                                          
  2775 000012C4 EB17                            jmp .end
  2776                                  
  2777                                      .normal_bounce:
  2778 000012C6 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2779 000012CD EB0E                            jmp .end
  2780                                  
  2781                                  
  2782                                      .update_position:
  2783 000012CF 4C8905(23150000)                mov [ball3_x_pos], r8
  2784 000012D6 4C890D(2B150000)                mov [ball3_y_pos], r9
  2785                                  
  2786                                      .end:
  2787 000012DD C3                              ret
  2788                                  
  2789                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2790                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2791                                  process_catch_release:
  2792 000012DE 55                          push rbp
  2793 000012DF 4889E5                      mov  rbp, rsp
  2794                                  
  2795                                      ; Verificar si el poder de catch está activo
  2796 000012E2 803D(FC220000)01            cmp byte [catch_power_active], 1
  2797 000012E9 0F8531010000                jne .no_catch_power
  2798                                  
  2799                                      ; Verificar si se presionó 'c' (derecha y arriba)
  2800 000012EF 803D(08230000)63            cmp byte [last_key], 'c'
  2801 000012F6 7412                        je .release_right
  2802                                      
  2803                                      ; Verificar si se presionó 'x' (izquierda y arriba)
  2804 000012F8 803D(08230000)78            cmp byte [last_key], 'x'
  2805 000012FF 0F8487000000                je .release_left
  2806                                      
  2807 00001305 E916010000                  jmp .no_catch_power
  2808                                  
  2809                                  .release_right:
  2810                                      ; Liberar la bola hacia la derecha
  2811 0000130A 803D(FD220000)01            cmp byte [ball_caught], 1
  2812 00001311 7522                        jne .check_ball2_right
  2813 00001313 C605(FD220000)00            mov byte [ball_caught], 0
  2814 0000131A 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Derecha
  2814 00001322 000000             
  2815 00001325 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2815 0000132D FFFFFF             
  2816 00001330 E9CD000000                  jmp .release_complete
  2817                                  
  2818                                  .check_ball2_right:
  2819 00001335 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2820 0000133C 7522                        jne .check_ball3_right
  2821 0000133E C605(FE220000)00            mov byte [ball_caught_2], 0
  2822 00001345 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2822 0000134D 000000             
  2823 00001350 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2823 00001358 FFFFFF             
  2824 0000135B E9A2000000                  jmp .release_complete
  2825                                  
  2826                                  .check_ball3_right:
  2827 00001360 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2828 00001367 0F8595000000                jne .release_complete
  2829 0000136D C605(FF220000)00            mov byte [ball_caught_3], 0
  2830 00001374 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2830 0000137C 000000             
  2831 0000137F 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2831 00001387 FFFFFF             
  2832 0000138A EB76                        jmp .release_complete
  2833                                  
  2834                                  .release_left:
  2835                                      ; Liberar la bola hacia la izquierda
  2836 0000138C 803D(FD220000)01            cmp byte [ball_caught], 1
  2837 00001393 751F                        jne .check_ball2_left
  2838 00001395 C605(FD220000)00            mov byte [ball_caught], 0
  2839 0000139C 48C705(EF140000)FF-         mov qword [ball_direction_x], -1   ; Izquierda
  2839 000013A4 FFFFFF             
  2840 000013A7 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Arriba
  2840 000013AF FFFFFF             
  2841 000013B2 EB4E                        jmp .release_complete
  2842                                  
  2843                                  .check_ball2_left:
  2844 000013B4 803D(FE220000)01            cmp byte [ball_caught_2], 1
  2845 000013BB 751F                        jne .check_ball3_left
  2846 000013BD C605(FE220000)00            mov byte [ball_caught_2], 0
  2847 000013C4 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  2847 000013CC FFFFFF             
  2848 000013CF 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2848 000013D7 FFFFFF             
  2849 000013DA EB26                        jmp .release_complete
  2850                                  
  2851                                  .check_ball3_left:
  2852 000013DC 803D(FF220000)01            cmp byte [ball_caught_3], 1
  2853 000013E3 751D                        jne .release_complete
  2854 000013E5 C605(FF220000)00            mov byte [ball_caught_3], 0
  2855 000013EC 48C705(33150000)FF-         mov qword [ball3_direction_x], -1
  2855 000013F4 FFFFFF             
  2856 000013F7 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2856 000013FF FFFFFF             
  2857                                  
  2858                                  .release_complete:
  2859                                      ; Si era el catch inicial, desactivarlo
  2860 00001402 803D(FB220000)01            cmp byte [initial_catch_active], 1
  2861 00001409 750E                        jne .finish
  2862 0000140B C605(FB220000)00            mov byte [initial_catch_active], 0
  2863 00001412 C605(FC220000)00            mov byte [catch_power_active], 0  ; Desactivar poder de catch después de la 1ra vez
  2864                                  
  2865                                  .finish:
  2866 00001419 C605(08230000)00            mov byte [last_key], 0  ; Limpiar la tecla
  2867                                  .no_catch_power:
  2868 00001420 5D                          pop rbp
  2869 00001421 C3                          ret
  2870                                  
  2871                                  
  2872                                  
  2873                                  display_level_number:
  2874 00001422 55                          push rbp
  2875 00001423 4889E5                      mov rbp, rsp
  2876                                      
  2877                                      ; Limpiar la pantalla primero
  2878                                      print clear, clear_length
    93 00001426 B801000000          <1>  mov eax, sys_write
    94 0000142B BF01000000          <1>  mov edi, 1
    95 00001430 48BE-               <1>  mov rsi, %1
    95 00001432 [1000000000000000]  <1>
    96 0000143A BA07000000          <1>  mov edx, %2
    97 0000143F 0F05                <1>  syscall
  2879                                      
  2880                                      ; Calcular la posición central para el mensaje
  2881                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2882 00001441 B850000000                  mov rax, column_cells
  2883 00001446 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2884 0000144A 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2885                                      
  2886                                      ; Calcular la fila central
  2887 0000144D BB20000000                  mov rbx, row_cells
  2888 00001452 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2889                                      
  2890                                      ; Calcular el offset en el buffer
  2891 00001455 B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2892 0000145A 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2893 0000145D 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2894                                      
  2895                                      ; Escribir "NIVEL " en la posición calculada
  2896 00001460 488DB8[400A0000]            lea rdi, [board + rax]
  2897 00001467 48BE-                       mov rsi, level_msg
  2897 00001469 [A414000000000000] 
  2898 00001471 B906000000                  mov rcx, level_msg_len
  2899 00001476 F3A4                        rep movsb
  2900                                      
  2901                                      ; Escribir el número del nivel
  2902 00001478 8A05(79150000)              mov al, [current_level]
  2903 0000147E 0430                        add al, '0'                 ; convertir a ASCII
  2904 00001480 8807                        mov [rdi], al
  2905                                      
  2906                                      ; Mostrar el board con el mensaje
  2907                                      print board, board_size
    93 00001482 B801000000          <1>  mov eax, sys_write
    94 00001487 BF01000000          <1>  mov edi, 1
    95 0000148C 48BE-               <1>  mov rsi, %1
    95 0000148E [400A000000000000]  <1>
    96 00001496 BA400A0000          <1>  mov edx, %2
    97 0000149B 0F05                <1>  syscall
  2908                                      
  2909                                      ; Esperar un segundo
  2910 0000149D B823000000                  mov rax, sys_nanosleep
  2911 000014A2 48BF-                       mov rdi, level_display_time
  2911 000014A4 [AF14000000000000] 
  2912 000014AC 4831F6                      xor rsi, rsi
  2913 000014AF 0F05                        syscall
  2914                                      
  2915 000014B1 5D                          pop rbp
  2916 000014B2 C3                          ret
  2917                                  
  2918                                  ; Función para inicializar un tablero vacío
  2919                                  init_empty_board:
  2920 000014B3 56                          push rsi
  2921 000014B4 57                          push rdi
  2922 000014B5 51                          push rcx
  2923 000014B6 50                          push rax
  2924                                  
  2925 000014B7 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2926 000014BE 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2927 000014C5 B9400A0000                  mov rcx, board_template_size
  2928 000014CA F3A4                        rep movsb                   ; Copiar el tablero
  2929                                  
  2930 000014CC 58                          pop rax
  2931 000014CD 59                          pop rcx
  2932 000014CE 5F                          pop rdi
  2933 000014CF 5E                          pop rsi
  2934 000014D0 C3                          ret
  2935                                  
  2936                                  clear_enemies_from_board:
  2937 000014D1 55                          push rbp
  2938 000014D2 4889E5                      mov rbp, rsp
  2939 000014D5 56                          push rsi
  2940 000014D6 57                          push rdi
  2941                                  
  2942                                      ; Primero limpiar board
  2943 000014D7 B9400A0000                  mov rcx, board_size      
  2944 000014DC 488D35(400A0000)            lea rsi, [board]         
  2945                                  
  2946                                  .clear_loop:
  2947 000014E3 4883F900                    cmp rcx, 0              
  2948 000014E7 741F                        je .clear_template      ; En vez de terminar, vamos a limpiar template
  2949                                      
  2950 000014E9 8A06                        mov al, [rsi]           
  2951 000014EB 3C40                        cmp al, '@'             
  2952 000014ED 740E                        je .make_space
  2953 000014EF 3C23                        cmp al, '#'             
  2954 000014F1 740A                        je .make_space
  2955 000014F3 3C24                        cmp al, '$'             
  2956 000014F5 7406                        je .make_space
  2957 000014F7 3C26                        cmp al, '&'             
  2958 000014F9 7402                        je .make_space
  2959                                      
  2960 000014FB EB03                        jmp .next               
  2961                                  
  2962                                  .make_space:
  2963 000014FD C60620                      mov byte [rsi], ' '     
  2964                                  
  2965                                  .next:
  2966 00001500 48FFC6                      inc rsi                 
  2967 00001503 48FFC9                      dec rcx                
  2968 00001506 EBDB                        jmp .clear_loop        
  2969                                  
  2970                                  .clear_template:
  2971                                      ; Ahora limpiar board_template
  2972 00001508 B9400A0000                  mov rcx, board_template_size
  2973 0000150D 488D35(00000000)            lea rsi, [board_template]
  2974                                  
  2975                                  .template_loop:
  2976 00001514 4883F900                    cmp rcx, 0
  2977 00001518 741F                        je .end
  2978                                      
  2979 0000151A 8A06                        mov al, [rsi]
  2980 0000151C 3C40                        cmp al, '@'
  2981 0000151E 740E                        je .make_space_template
  2982 00001520 3C23                        cmp al, '#'
  2983 00001522 740A                        je .make_space_template
  2984 00001524 3C24                        cmp al, '$'
  2985 00001526 7406                        je .make_space_template
  2986 00001528 3C26                        cmp al, '&'
  2987 0000152A 7402                        je .make_space_template
  2988                                      
  2989 0000152C EB03                        jmp .next_template
  2990                                  
  2991                                  .make_space_template:
  2992 0000152E C60620                      mov byte [rsi], ' '
  2993                                  
  2994                                  .next_template:
  2995 00001531 48FFC6                      inc rsi
  2996 00001534 48FFC9                      dec rcx
  2997 00001537 EBDB                        jmp .template_loop
  2998                                  
  2999                                  .end:
  3000 00001539 5F                          pop rdi
  3001 0000153A 5E                          pop rsi
  3002 0000153B 5D                          pop rbp
  3003 0000153C C3                          ret
  3004                                  
  3005                                  
  3006                                  
  3007                                  
  3008                                  init_level:
  3009 0000153D E88FFFFFFF                  call clear_enemies_from_board
  3010 00001542 C605(22150000)00            mov byte [ball2_active], 0
  3011 00001549 C605(44150000)00            mov byte [ball3_active], 0
  3012 00001550 C605(09230000)00            mov byte [laser_power_active], 0
  3013 00001557 E898F2FFFF                  call clear_lasers
  3014 0000155C 488B05(CF140000)            mov rax, [default_pallet_size]
  3015 00001563 488905(C7140000)            mov [pallet_size], rax
  3016 0000156A 48C705(E3220000)07-         mov qword [ball_speed], 7    ; Restaurar velocidad normal
  3016 00001572 000000             
  3017                                  
  3018                                      ; 1) Copiamos board_template en board para que quede "virgen"
  3019                                          ; Reiniciar letras activas
  3020 00001575 488D3D(3C210000)            lea rdi, [letters_map]
  3021 0000157C B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  3022 00001581 4831C0                      xor rax, rax
  3023 00001584 F3AA                        rep stosb                    ; Llenar con ceros
  3024                                      
  3025                                      ; Inicializar dirección de la bola (derecha y arriba)
  3026 00001586 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  3026 0000158E 000000             
  3027 00001591 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  3027 00001599 FFFFFF             
  3028                                  
  3029                                      ; En init_level, después de inicializar las direcciones
  3030 0000159C C605(FC220000)01            mov byte [catch_power_active], 1    ; Activar el poder catch
  3031 000015A3 C605(FD220000)01            mov byte [ball_caught], 1           ; Marcar la bola como atrapada
  3032 000015AA C605(FB220000)01            mov byte [initial_catch_active], 1  ; Marcar que es el catch inicial
  3033                                  
  3034                                      ; Calcular y guardar el offset inicial de la bola respecto a la paleta
  3035 000015B1 488B05(DF140000)            mov rax, [ball_x_pos]              ; Posición X actual de la bola
  3036 000015B8 482B05(BF140000)            sub rax, [pallet_position]         ; Restar la posición de la paleta
  3037 000015BF 4805[400A0000]              add rax, board                     ; Ajustar por el offset del tablero
  3038 000015C5 488905(00230000)            mov [ball_catch_offset], rax       ; Guardar el offset
  3039                                  
  3040                                  
  3041                                  
  3042                                      ; Reiniciar contador de letras activas
  3043 000015CC 4831C0                      xor rax, rax
  3044 000015CF 8805(CC220000)              mov [letters_count], al
  3045                                  
  3046                                      ; Reiniciar última letra capturada
  3047 000015D5 C605(CD220000)20            mov byte [last_letter], ' '
  3048 000015DC C605(46200000)00            mov byte [destroyed_blocks], 0 
  3049 000015E3 E8CBFEFFFF                  call init_empty_board
  3050 000015E8 E835FEFFFF                  call display_level_number
  3051                                  
  3052 000015ED 56                          push rsi
  3053 000015EE 57                          push rdi
  3054 000015EF 51                          push rcx
  3055 000015F0 50                          push rax
  3056                                  
  3057 000015F1 488D35(00000000)            lea rsi, [board_template]
  3058 000015F8 488D3D(400A0000)            lea rdi, [board]
  3059 000015FF B9400A0000                  mov rcx, board_template_size
  3060 00001604 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  3061                                  
  3062 00001606 58                          pop rax
  3063 00001607 59                          pop rcx
  3064 00001608 5F                          pop rdi
  3065 00001609 5E                          pop rsi
  3066                                  
  3067 0000160A B90A000000                  mov rcx, 10
  3068 0000160F 4831C0                      xor rax, rax
  3069 00001612 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3070 00001619 F3AA                        rep stosb   
  3071 0000161B E8D4050000                  call init_enemies   
  3072                                  
  3073                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  3074 00001620 803D(79150000)01            cmp byte [current_level], 1
  3075 00001627 7431                        je .level1
  3076 00001629 803D(79150000)02            cmp byte [current_level], 2
  3077 00001630 7454                        je .level2
  3078 00001632 803D(79150000)03            cmp byte [current_level], 3
  3079 00001639 7477                        je .level3
  3080 0000163B 803D(79150000)04            cmp byte [current_level], 4
  3081 00001642 0F8492000000                je .level4
  3082 00001648 803D(79150000)05            cmp byte [current_level], 5
  3083 0000164F 0F84B0000000                je .level5
  3084 00001655 E9D3000000                  jmp .done
  3085                                  
  3086                                  
  3087                                  
  3088                                      .level1:
  3089 0000165A C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  3090 00001661 4831C9                          xor rcx, rcx             
  3091                                          .init_loop1:
  3092 00001664 4883F94E                            cmp rcx, level1_blocks_count
  3093 00001668 0F8DBF000000                        jge .done
  3094 0000166E 4889C8                              mov rax, rcx         
  3095 00001671 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3096 00001675 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]  
  3097 0000167B 8891[761F0000]                      mov byte [block_states + rcx], dl
  3098 00001681 48FFC1                              inc rcx
  3099 00001684 EBDE                                jmp .init_loop1
  3100                                  
  3101                                      .level2:
  3102 00001686 C605(7A150000)5B                mov byte [blocks_remaining], level2_blocks_count
  3103 0000168D 4831C9                          xor rcx, rcx             
  3104                                          .init_loop2:
  3105 00001690 4883F95B                            cmp rcx, level2_blocks_count
  3106 00001694 0F8D93000000                        jge .done
  3107 0000169A 4889C8                              mov rax, rcx         
  3108 0000169D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3109 000016A1 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  3110 000016A7 8891[761F0000]                      mov byte [block_states + rcx], dl
  3111 000016AD 48FFC1                              inc rcx
  3112 000016B0 EBDE                                jmp .init_loop2
  3113                                      .level3:
  3114 000016B2 C605(7A150000)40                mov byte [blocks_remaining], 64
  3115 000016B9 4831C9                          xor rcx, rcx             
  3116                                          .init_loop3:
  3117 000016BC 4883F968                            cmp rcx, level3_blocks_count
  3118 000016C0 7D6B                                jge .done
  3119 000016C2 4889C8                              mov rax, rcx         
  3120 000016C5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3121 000016C9 8A90[CB180000]                      mov dl, byte [level3_blocks + rax + 3]  
  3122 000016CF 8891[761F0000]                      mov byte [block_states + rcx], dl
  3123 000016D5 48FFC1                              inc rcx
  3124 000016D8 EBE2                                jmp .init_loop3
  3125                                  
  3126                                      .level4:
  3127 000016DA C605(7A150000)8C                mov byte [blocks_remaining], level4_blocks_count
  3128 000016E1 4831C9                          xor rcx, rcx             
  3129                                          .init_loop4:
  3130 000016E4 4881F98C000000                      cmp rcx, level4_blocks_count
  3131 000016EB 7D40                                jge .done
  3132 000016ED 4889C8                              mov rax, rcx         
  3133 000016F0 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3134 000016F4 8A90[D31A0000]                      mov dl, byte [level4_blocks + rax + 3]  
  3135 000016FA 8891[761F0000]                      mov byte [block_states + rcx], dl
  3136 00001700 48FFC1                              inc rcx
  3137 00001703 EBDF                                jmp .init_loop4
  3138                                  
  3139                                      .level5:
  3140 00001705 C605(7A150000)62                mov byte [blocks_remaining], level5_blocks_count
  3141 0000170C 4831C9                          xor rcx, rcx             
  3142                                          .init_loop5:
  3143 0000170F 4883F962                            cmp rcx, level5_blocks_count
  3144 00001713 7D18                                jge .done
  3145 00001715 4889C8                              mov rax, rcx         
  3146 00001718 486BC005                            imul rax, 5         ; en vez de shl rax,2
  3147 0000171C 8A90[8F1D0000]                      mov dl, byte [level5_blocks + rax + 3]  
  3148 00001722 8891[761F0000]                      mov byte [block_states + rcx], dl
  3149 00001728 48FFC1                              inc rcx
  3150 0000172B EBE2                                jmp .init_loop5
  3151                                      .done:
  3152 0000172D C3                              ret
  3153                                  
  3154                                  
  3155                                  ; Función para verificar y manejar la transición de nivel
  3156                                  check_level_complete:
  3157                                      ; Verificar si quedan bloques
  3158 0000172E 803D(7A150000)00            cmp byte [blocks_remaining], 0
  3159 00001735 7556                        jne .not_complete
  3160                                      
  3161                                      ; Incrementar el nivel
  3162 00001737 FE05(79150000)              inc byte [current_level]
  3163                                      
  3164                                      ; Verificar si hemos completado todos los niveles
  3165 0000173D 803D(79150000)06            cmp byte [current_level], 6
  3166 00001744 7448                        je game_win
  3167                                      
  3168                                  
  3169 00001746 E886FDFFFF                  call clear_enemies_from_board
  3170                                      ; Primero establecer las posiciones seguras
  3171 0000174B 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  3171 00001752 [B0130000]         
  3172 00001756 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  3172 0000175E 000000             
  3173 00001761 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  3173 00001769 000000             
  3174 0000176C C605(FF140000)00            mov byte [ball_moving], 0
  3175                                      
  3176                                      ; Asegurar que la bola esté en un estado seguro
  3177 00001773 C605(FC220000)01            mov byte [catch_power_active], 1
  3178 0000177A C605(FD220000)01            mov byte [ball_caught], 1
  3179 00001781 C605(FB220000)01            mov byte [initial_catch_active], 1
  3180                                      
  3181                                      ; Reinicializar el juego para el siguiente nivel
  3182 00001788 E8B0FDFFFF                  call init_level
  3183                                      
  3184                                  .not_complete:
  3185 0000178D C3                          ret
  3186                                  
  3187                                      ; Nueva función para manejar la victoria del juego
  3188                                  game_win:
  3189                                      ; Limpiar la pantalla primero
  3190                                      print clear, clear_length
    93 0000178E B801000000          <1>  mov eax, sys_write
    94 00001793 BF01000000          <1>  mov edi, 1
    95 00001798 48BE-               <1>  mov rsi, %1
    95 0000179A [1000000000000000]  <1>
    96 000017A2 BA07000000          <1>  mov edx, %2
    97 000017A7 0F05                <1>  syscall
  3191                                      
  3192                                      ; Mensaje de victoria
  3193 000017A9 488B05(3E200000)            mov rax, [current_score]    ; Obtener el puntaje final
  3194 000017B0 48BF-                       mov rdi, number_buffer      ; Convertir a string
  3194 000017B2 [4720000000000000] 
  3195 000017BA E8B4010000                  call number_to_string
  3196                                      
  3197                                      ; Definir mensaje de victoria
  3198                                      section .data
  3199 0000246F C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  3199 00002478 616465732120C2A148-
  3199 00002481 61732067616E61646F-
  3199 0000248A 210A0D             
  3200                                          win_msg_len: equ $ - win_msg
  3201 0000248D 50756E74616A652066-             score_msg: db "Puntaje final: "
  3201 00002496 696E616C3A20       
  3202                                          score_msg_len: equ $ - score_msg
  3203                                      section .text
  3204                                      
  3205                                      ; Imprimir mensajes
  3206                                      print win_msg, win_msg_len
    93 000017BF B801000000          <1>  mov eax, sys_write
    94 000017C4 BF01000000          <1>  mov edi, 1
    95 000017C9 48BE-               <1>  mov rsi, %1
    95 000017CB [6F24000000000000]  <1>
    96 000017D3 BA1E000000          <1>  mov edx, %2
    97 000017D8 0F05                <1>  syscall
  3207                                      print score_msg, score_msg_len
    93 000017DA B801000000          <1>  mov eax, sys_write
    94 000017DF BF01000000          <1>  mov edi, 1
    95 000017E4 48BE-               <1>  mov rsi, %1
    95 000017E6 [8D24000000000000]  <1>
    96 000017EE BA0F000000          <1>  mov edx, %2
    97 000017F3 0F05                <1>  syscall
  3208                                      print number_buffer, 20
    93 000017F5 B801000000          <1>  mov eax, sys_write
    94 000017FA BF01000000          <1>  mov edi, 1
    95 000017FF 48BE-               <1>  mov rsi, %1
    95 00001801 [4720000000000000]  <1>
    96 00001809 BA14000000          <1>  mov edx, %2
    97 0000180E 0F05                <1>  syscall
  3209                                      
  3210                                      ; Esperar un momento antes de salir
  3211 00001810 48C705E5E7FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  3211 00001819 0000               
  3212 0000181B 48C705E2E7FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  3212 00001824 0000               
  3213                                      sleeptime
   109 00001826 B823000000          <1>  mov eax, sys_nanosleep
   110 0000182B 48BF-               <1>  mov rdi, timespec
   110 0000182D [0000000000000000]  <1>
   111 00001835 31F6                <1>  xor esi, esi
   112 00001837 0F05                <1>  syscall
  3214                                      
  3215 00001839 E9B30B0000                  jmp exit
  3216                                  
  3217                                  ; Función para imprimir los bloques
  3218                                  ; Función modificada para imprimir bloques
  3219                                  
  3220                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  3221                                  get_current_level_blocks:
  3222 0000183E 803D(79150000)01            cmp byte [current_level], 1
  3223 00001845 7428                        je .level1
  3224 00001847 803D(79150000)02            cmp byte [current_level], 2
  3225 0000184E 7427                        je .level2
  3226 00001850 803D(79150000)03            cmp byte [current_level], 3
  3227 00001857 7426                        je .level3
  3228 00001859 803D(79150000)04            cmp byte [current_level], 4
  3229 00001860 7425                        je .level4
  3230 00001862 803D(79150000)05            cmp byte [current_level], 5
  3231 00001869 7424                        je .level5
  3232                                      ; Si llegamos aquí, hay un error en el nivel
  3233 0000186B 4831C0                      xor rax, rax
  3234 0000186E C3                          ret
  3235                                  
  3236                                      .level1:
  3237 0000186F 488D05(7B150000)                lea rax, [level1_blocks]
  3238 00001876 C3                              ret
  3239                                      .level2:
  3240 00001877 488D05(01170000)                lea rax, [level2_blocks]
  3241 0000187E C3                              ret
  3242                                      .level3:
  3243 0000187F 488D05(C8180000)                lea rax, [level3_blocks]
  3244 00001886 C3                              ret
  3245                                      .level4:
  3246 00001887 488D05(D01A0000)                lea rax, [level4_blocks]
  3247 0000188E C3                              ret
  3248                                      .level5:
  3249 0000188F 488D05(8C1D0000)                lea rax, [level5_blocks]
  3250 00001896 C3                              ret
  3251                                  ; Función para obtener la cantidad de bloques del nivel actual
  3252                                  get_current_level_count:
  3253 00001897 803D(79150000)01            cmp byte [current_level], 1
  3254 0000189E 7428                        je .level1
  3255 000018A0 803D(79150000)02            cmp byte [current_level], 2
  3256 000018A7 7425                        je .level2
  3257 000018A9 803D(79150000)03            cmp byte [current_level], 3
  3258 000018B0 7422                        je .level3
  3259 000018B2 803D(79150000)04            cmp byte [current_level], 4
  3260 000018B9 741F                        je .level4
  3261 000018BB 803D(79150000)05            cmp byte [current_level], 5
  3262 000018C2 741C                        je .level5
  3263                                      ; Si llegamos aquí, hay un error en el nivel
  3264 000018C4 4831C0                      xor rax, rax
  3265 000018C7 C3                          ret
  3266                                  
  3267                                      .level1:
  3268 000018C8 B84E000000                      mov rax, level1_blocks_count
  3269 000018CD C3                              ret
  3270                                      .level2:
  3271 000018CE B85B000000                      mov rax, level2_blocks_count
  3272 000018D3 C3                              ret
  3273                                      .level3:
  3274 000018D4 B868000000                      mov rax, level3_blocks_count
  3275 000018D9 C3                              ret
  3276                                      .level4:
  3277 000018DA B88C000000                      mov rax, level4_blocks_count
  3278 000018DF C3                              ret
  3279                                      .level5:
  3280 000018E0 B862000000                      mov rax, level5_blocks_count
  3281 000018E5 C3                              ret
  3282                                  
  3283                                  
  3284                                  print_blocks:
  3285 000018E6 55                          push rbp
  3286 000018E7 4889E5                      mov rbp, rsp
  3287                                      
  3288                                      ; Obtener puntero a los bloques del nivel actual
  3289 000018EA E84FFFFFFF                  call get_current_level_blocks
  3290 000018EF 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  3291                                      
  3292                                      ; Obtener cantidad de bloques del nivel actual
  3293 000018F2 E8A0FFFFFF                  call get_current_level_count
  3294 000018F7 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  3295                                      
  3296 000018FA 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  3297                                      
  3298                                      .print_loop:
  3299 000018FD 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  3300 00001900 7D6F                            jge .end
  3301                                          
  3302                                          ; Verificar si el bloque está activo
  3303 00001902 490FB68424-                     movzx rax, byte [block_states + r12]
  3303 00001907 [761F0000]         
  3304 0000190B 4885C0                          test rax, rax
  3305 0000190E 745C                            jz .next_block
  3306                                          
  3307                                          ; Obtener posición y tipo del bloque usando r13
  3308 00001910 4C89E0                          mov rax, r12
  3309 00001913 486BC005                        imul rax, 5
  3310 00001917 4C01E8                          add rax, r13
  3311 0000191A 448A00                          mov r8b, [rax]        ; X position
  3312 0000191D 448A4801                        mov r9b, [rax + 1]    ; Y position
  3313 00001921 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  3314                                  
  3315                                          ; El resto de la lógica de impresión permanece igual
  3316 00001925 4D0FB6C0                        movzx r8, r8b
  3317 00001929 4D0FB6C9                        movzx r9, r9b
  3318 0000192D 4981C0[400A0000]                add r8, board
  3319 00001934 B852000000                      mov rax, column_cells + 2
  3320 00001939 49F7E1                          mul r9
  3321 0000193C 4901C0                          add r8, rax
  3322                                          
  3323 0000193F B906000000                      mov rcx, block_length
  3324 00001944 48BE-                           mov rsi, block_type_1
  3324 00001946 [5515000000000000] 
  3325 0000194E 490FB6C2                        movzx rax, r10b
  3326 00001952 48FFC8                          dec rax
  3327 00001955 486BC006                        imul rax, block_length
  3328 00001959 4801C6                          add rsi, rax
  3329                                          
  3330                                      .print_block_chars:
  3331 0000195C 8A06                            mov al, [rsi]
  3332 0000195E 418800                          mov [r8], al
  3333 00001961 48FFC6                          inc rsi
  3334 00001964 49FFC0                          inc r8
  3335 00001967 48FFC9                          dec rcx
  3336 0000196A 75F0                            jnz .print_block_chars
  3337                                          
  3338                                      .next_block:
  3339 0000196C 49FFC4                          inc r12
  3340 0000196F EB8C                            jmp .print_loop
  3341                                          
  3342                                      .end:
  3343 00001971 5D                              pop rbp
  3344 00001972 C3                              ret
  3345                                  
  3346                                  ; Función para convertir número a string
  3347                                  ; Input: RAX = número a convertir
  3348                                  ; RDI = buffer donde escribir el string
  3349                                  number_to_string:
  3350 00001973 53                          push rbx
  3351 00001974 52                          push rdx
  3352 00001975 56                          push rsi
  3353 00001976 BB0A000000                  mov rbx, 10          ; Divisor
  3354 0000197B B900000000                  mov rcx, 0          ; Contador de dígitos
  3355                                      
  3356                                      ; Si el número es 0, manejarlo especialmente
  3357 00001980 4885C0                      test rax, rax
  3358 00001983 7509                        jnz .convert_loop
  3359 00001985 C60730                      mov byte [rdi], '0'
  3360 00001988 C6470100                    mov byte [rdi + 1], 0
  3361 0000198C EB20                        jmp .end
  3362                                      
  3363                                      .convert_loop:
  3364 0000198E 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  3365 00001991 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  3366 00001994 80C230                          add dl, '0'     ; Convertir a ASCII
  3367 00001997 52                              push rdx        ; Guardar el dígito
  3368 00001998 48FFC1                          inc rcx         ; Incrementar contador
  3369 0000199B 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  3370 0000199E 75EE                            jnz .convert_loop
  3371                                          
  3372                                      .write_loop:
  3373 000019A0 5A                              pop rdx         ; Obtener dígito
  3374 000019A1 8817                            mov [rdi], dl   ; Escribir al buffer
  3375 000019A3 48FFC7                          inc rdi         ; Siguiente posición
  3376 000019A6 48FFC9                          dec rcx         ; Decrementar contador
  3377 000019A9 75F5                            jnz .write_loop
  3378                                          
  3379 000019AB C60700                      mov byte [rdi], 0   ; Null terminator
  3380                                      
  3381                                      .end:
  3382 000019AE 5E                          pop rsi
  3383 000019AF 5A                          pop rdx
  3384 000019B0 5B                          pop rbx
  3385 000019B1 C3                          ret
  3386                                  
  3387                                  ; Función para imprimir los labels
  3388                                  print_labels:
  3389 000019B2 55                          push rbp
  3390 000019B3 4889E5                      mov rbp, rsp
  3391                                  
  3392                                      ; Crear buffer temporal
  3393 000019B6 4883EC20                    sub rsp, 32
  3394                                  
  3395                                      ; Copiar labels a buffer temporal
  3396 000019BA 4889E7                      mov rdi, rsp
  3397 000019BD 488D35(F3200000)            lea rsi, [score_label]
  3398 000019C4 B917000000                  mov rcx, score_label_len
  3399 000019C9 F3A4                        rep movsb
  3400                                  
  3401                                      ; Convertir score a string
  3402 000019CB 488B05(3E200000)            mov rax, [current_score]
  3403 000019D2 48BF-                       mov rdi, number_buffer
  3403 000019D4 [4720000000000000] 
  3404 000019DC E892FFFFFF                  call number_to_string
  3405                                  
  3406                                      ; Calcular longitud del número
  3407 000019E1 B900000000                  mov rcx, 0
  3408 000019E6 48BF-                       mov rdi, number_buffer
  3408 000019E8 [4720000000000000] 
  3409                                      .count_loop:
  3410 000019F0 803C0F00                        cmp byte [rdi + rcx], 0
  3411 000019F4 7405                            je .count_done
  3412 000019F6 48FFC1                          inc rcx
  3413 000019F9 EBF5                            jmp .count_loop
  3414                                      .count_done:
  3415                                  
  3416                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3417 000019FB 4889E7                      mov rdi, rsp
  3418 000019FE 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  3419 00001A02 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  3420 00001A07 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  3421                                      .pad_loop:
  3422 00001A0A 4885F6                          test rsi, rsi
  3423 00001A0D 740B                            jz .pad_done
  3424 00001A0F C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3425 00001A12 48FFC7                          inc rdi
  3426 00001A15 48FFCE                          dec rsi
  3427 00001A18 EBF0                            jmp .pad_loop
  3428                                      .pad_done:
  3429                                  
  3430                                      ; Copiar el número
  3431 00001A1A 48BE-                       mov rsi, number_buffer
  3431 00001A1C [4720000000000000] 
  3432 00001A24 F3A4                        rep movsb
  3433                                  
  3434                                      ; Imprimir el buffer completo
  3435                                      print rsp, score_label_len
    93 00001A26 B801000000          <1>  mov eax, sys_write
    94 00001A2B BF01000000          <1>  mov edi, 1
    95 00001A30 4889E6              <1>  mov rsi, %1
    96 00001A33 BA17000000          <1>  mov edx, %2
    97 00001A38 0F05                <1>  syscall
  3436                                  
  3437                                      ; Repetir proceso para bloques destruidos
  3438 00001A3A 4889E7                      mov rdi, rsp
  3439 00001A3D 488D35(0A210000)            lea rsi, [blocks_label]
  3440 00001A44 B91B000000                  mov rcx, blocks_label_len
  3441 00001A49 F3A4                        rep movsb
  3442                                  
  3443                                      ; Verificar que el `[` esté en su posición correcta
  3444 00001A4B 4889E7                      mov rdi, rsp
  3445 00001A4E 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  3446 00001A52 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  3447                                  
  3448                                      ; Convertir bloques destruidos a string
  3449 00001A55 480FB605(46200000)          movzx rax, byte [destroyed_blocks]
  3450 00001A5D 48BF-                       mov rdi, number_buffer
  3450 00001A5F [4720000000000000] 
  3451 00001A67 E807FFFFFF                  call number_to_string
  3452                                  
  3453                                      ; Calcular longitud del número
  3454 00001A6C B900000000                  mov rcx, 0
  3455 00001A71 48BF-                       mov rdi, number_buffer
  3455 00001A73 [4720000000000000] 
  3456                                      .count_loop2:
  3457 00001A7B 803C0F00                        cmp byte [rdi + rcx], 0
  3458 00001A7F 7405                            je .count_done2
  3459 00001A81 48FFC1                          inc rcx
  3460 00001A84 EBF5                            jmp .count_loop2
  3461                                      .count_done2:
  3462                                  
  3463                                      ; Insertar el número en la posición correcta, alineado a la derecha
  3464 00001A86 4889E7                      mov rdi, rsp
  3465 00001A89 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  3466 00001A8D BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  3467 00001A92 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  3468                                      .pad_loop2:
  3469 00001A95 4885F6                          test rsi, rsi
  3470 00001A98 740B                            jz .pad_done2
  3471 00001A9A C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  3472 00001A9D 48FFC7                          inc rdi
  3473 00001AA0 48FFCE                          dec rsi
  3474 00001AA3 EBF0                            jmp .pad_loop2
  3475                                      .pad_done2:
  3476                                  
  3477                                      ; Copiar el número
  3478 00001AA5 48BE-                       mov rsi, number_buffer
  3478 00001AA7 [4720000000000000] 
  3479 00001AAF F3A4                        rep movsb
  3480                                  
  3481                                      ; Imprimir el buffer completo
  3482                                      print rsp, blocks_label_len
    93 00001AB1 B801000000          <1>  mov eax, sys_write
    94 00001AB6 BF01000000          <1>  mov edi, 1
    95 00001ABB 4889E6              <1>  mov rsi, %1
    96 00001ABE BA1B000000          <1>  mov edx, %2
    97 00001AC3 0F05                <1>  syscall
  3483                                  
  3484                                      ; Restaurar stack
  3485 00001AC5 4883C420                    add rsp, 32
  3486 00001AC9 5D                          pop rbp
  3487 00001ACA C3                          ret
  3488                                  
  3489                                  
  3490                                  
  3491                                  check_block_collision:
  3492 00001ACB 55                          push rbp
  3493 00001ACC 4889E5                      mov rbp, rsp
  3494                                  
  3495                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  3496 00001ACF 418A02                      mov al, [r10]
  3497                                  
  3498                                      ; Verificar si el carácter es un bloque
  3499 00001AD2 3C55                        cmp al, 'U'  
  3500 00001AD4 7419                        je .possible
  3501 00001AD6 3C4F                        cmp al, 'O'  
  3502 00001AD8 7415                        je .possible
  3503 00001ADA 3C44                        cmp al, 'D'  
  3504 00001ADC 7411                        je .possible
  3505 00001ADE 3C4C                        cmp al, 'L'  
  3506 00001AE0 740D                        je .possible
  3507 00001AE2 3C56                        cmp al, 'V'  
  3508 00001AE4 7409                        je .possible
  3509 00001AE6 3C38                        cmp al, '8'  
  3510 00001AE8 7405                        je .possible
  3511                                  
  3512                                      ; No es bloque, salir
  3513 00001AEA 4831C0                      xor rax, rax
  3514 00001AED 5D                          pop rbp
  3515 00001AEE C3                          ret
  3516                                  
  3517                                  .possible:
  3518 00001AEF 53                          push rbx
  3519 00001AF0 57                          push rdi
  3520 00001AF1 56                          push rsi
  3521 00001AF2 4154                        push r12
  3522 00001AF4 4155                        push r13
  3523 00001AF6 4156                        push r14
  3524 00001AF8 4157                        push r15
  3525                                  
  3526                                      ; 1) Obtener base de los bloques del nivel actual
  3527 00001AFA E83FFDFFFF                  call get_current_level_blocks
  3528 00001AFF 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  3529                                  
  3530                                      ; 2) Obtener la cantidad de bloques
  3531 00001B02 E890FDFFFF                  call get_current_level_count
  3532 00001B07 4989C6                      mov r14, rax
  3533                                  
  3534 00001B0A 4D31E4                      xor r12, r12  ; Índice del bloque actual
  3535                                  
  3536                                  .find_block_loop:
  3537 00001B0D 4D39F4                      cmp r12, r14
  3538 00001B10 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  3539                                  
  3540                                      ; Calcular puntero base del bloque actual en levelX_blocks
  3541 00001B16 4C89E0                      mov rax, r12
  3542 00001B19 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  3543 00001B1D 4C01E8                      add rax, r13
  3544 00001B20 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  3545                                  
  3546                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  3547 00001B23 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  3547 00001B28 [761F0000]         
  3548 00001B2C 4885DB                      test rbx, rbx
  3549 00001B2F 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  3550                                  
  3551                                      ; Obtener coordenadas
  3552 00001B35 418A17                      mov dl, [r15]         ; x
  3553 00001B38 418A4F01                    mov cl, [r15 + 1]     ; y
  3554                                  
  3555                                      ; Calcular posición en el board
  3556 00001B3C 488D3D(400A0000)            lea rdi, [board]
  3557 00001B43 4831C0                      xor rax, rax
  3558 00001B46 B850000000                  mov rax, column_cells
  3559 00001B4B 4883C002                    add rax, 2
  3560 00001B4F 480FB6C9                    movzx rcx, cl         ; y
  3561 00001B53 480FAFC1                    imul rax, rcx
  3562 00001B57 4801C7                      add rdi, rax
  3563 00001B5A 480FB6C2                    movzx rax, dl         ; x
  3564 00001B5E 4801C7                      add rdi, rax
  3565                                  
  3566                                      ; Guardar la posición base del bloque
  3567 00001B61 57                          push rdi
  3568                                  
  3569                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  3570 00001B62 4939FA                      cmp r10, rdi
  3571 00001B65 7274                        jb .skip_collision
  3572 00001B67 488D5F06                    lea rbx, [rdi + block_length]
  3573 00001B6B 4939DA                      cmp r10, rbx
  3574 00001B6E 736B                        jae .skip_collision
  3575                                  
  3576                                      ; ------- Hay colisión, reducir durabilidad en block_states
  3577 00001B70 41FE8C24[761F0000]          dec byte [block_states + r12]
  3578                                      ; Volver a cargar durabilidad
  3579 00001B78 490FB69C24-                 movzx rbx, byte [block_states + r12]
  3579 00001B7D [761F0000]         
  3580 00001B81 4885DB                      test rbx, rbx
  3581 00001B84 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  3582                                  
  3583                                      ; >>> Llegó a 0 => Bloque destruido
  3584 00001B86 5F                          pop rdi  ; recuperar puntero base del bloque en board
  3585 00001B87 B906000000                  mov rcx, block_length
  3586                                  .clear_loop:
  3587 00001B8C C60720                      mov byte [rdi], ' '
  3588 00001B8F 48FFC7                      inc rdi
  3589 00001B92 E2F8                        loop .clear_loop
  3590                                  
  3591                                      ; Dibujar letra del bloque destruido
  3592 00001B94 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  3593 00001B98 4883EF06                    sub rdi, block_length
  3594 00001B9C 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  3595                                      ; Después de escribir la letra en el tablero
  3596 00001B9E 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  3597 00001BA2 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  3598 00001BA6 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  3599 00001BAB E8D4E8FFFF                  call register_letter
  3600                                      ; Actualizar contadores globales
  3601 00001BB0 FE0D(7A150000)              dec byte [blocks_remaining]
  3602 00001BB6 FE05(46200000)              inc byte [destroyed_blocks]
  3603                                  
  3604                                      ; Sumar puntos según el tipo
  3605 00001BBC 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  3606 00001BC1 486BC00A                    imul rax, 10
  3607 00001BC5 480105(3E200000)            add [current_score], rax
  3608                                  
  3609 00001BCC B801000000                  mov rax, 1  ; colisión con destrucción
  3610 00001BD1 EB14                        jmp .end_pop
  3611                                  
  3612                                  .update_display:
  3613                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  3614 00001BD3 B801000000                  mov rax, 1  ; colisión con "rebote"  
  3615 00001BD8 5F                          pop rdi     ; pop que quedó pendiente
  3616 00001BD9 EB0C                        jmp .end_pop
  3617                                  
  3618                                  .skip_collision:
  3619 00001BDB 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  3620                                  .next_block:
  3621 00001BDC 49FFC4                      inc r12
  3622 00001BDF E929FFFFFF                  jmp .find_block_loop
  3623                                  
  3624                                  .no_block_found:
  3625 00001BE4 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  3626                                  
  3627                                  .end_pop:
  3628 00001BE7 415F                        pop r15
  3629 00001BE9 415E                        pop r14
  3630 00001BEB 415D                        pop r13
  3631 00001BED 415C                        pop r12
  3632 00001BEF 5E                          pop rsi
  3633 00001BF0 5F                          pop rdi
  3634 00001BF1 5B                          pop rbx
  3635 00001BF2 5D                          pop rbp
  3636 00001BF3 C3                          ret
  3637                                  
  3638                                  
  3639                                  
  3640                                  init_enemies:
  3641 00001BF4 55                          push rbp
  3642 00001BF5 4889E5                      mov rbp, rsp
  3643                                      
  3644                                      ; Reiniciar contadores de movimiento
  3645 00001BF8 C605(89200000)00            mov byte [enemy_move_total], 0
  3646 00001BFF C605(8A200000)00            mov byte [enemy_target], 0
  3647                                      
  3648                                      ; Limpiar completamente el array de enemigos
  3649 00001C06 B91E000000                  mov rcx, 30  ; 10 enemigos * 3 bytes cada uno
  3650 00001C0B 488D3D(60200000)            lea rdi, [enemies]
  3651 00001C12 30C0                        xor al, al
  3652 00001C14 F3AA                        rep stosb    ; Llenar todo con ceros
  3653                                      
  3654                                      ; Marcar todos los spawns como no activados
  3655 00001C16 488D3D(E9200000)            lea rdi, [enemy_spawns_triggered]
  3656 00001C1D B90A000000                  mov rcx, 10
  3657 00001C22 F3AA                        rep stosb
  3658                                      
  3659 00001C24 5D                          pop rbp
  3660 00001C25 C3                          ret
  3661                                  
  3662                                  
  3663                                  random_move_enemy:
  3664 00001C26 55                          push rbp
  3665 00001C27 4889E5                      mov  rbp, rsp
  3666 00001C2A 53                          push rbx
  3667 00001C2B 52                          push rdx
  3668 00001C2C 57                          push rdi
  3669                                  
  3670                                      ; r12 = índice del enemigo
  3671                                      ; 1) obtener puntero al enemigo i
  3672 00001C2D 4C89E0                      mov rax, r12
  3673 00001C30 486BC003                    imul rax, 3
  3674 00001C34 488D98[60200000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  3675                                  
  3676                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  3677 00001C3B 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  3678 00001C3F 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  3679                                  
  3680                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  3681 00001C44 480FB605(87200000)          movzx rax, byte [enemy_move_counter]
  3682 00001C4C 4883E003                    and rax, 3
  3683                                  
  3684 00001C50 4883F800                    cmp rax, 0
  3685 00001C54 741B                        je .try_left
  3686 00001C56 4883F801                    cmp rax, 1
  3687 00001C5A 7410                        je .try_right
  3688 00001C5C 4883F802                    cmp rax, 2
  3689 00001C60 7405                        je .try_up
  3690                                      ; si es 3 => mover abajo
  3691                                  .try_down:
  3692 00001C62 49FFC1                      inc r9
  3693 00001C65 EB0D                        jmp .check_valid
  3694                                  
  3695                                  .try_up:
  3696 00001C67 49FFC9                      dec r9
  3697 00001C6A EB08                        jmp .check_valid
  3698                                  
  3699                                  .try_right:
  3700 00001C6C 49FFC0                      inc r8
  3701 00001C6F EB03                        jmp .check_valid
  3702                                  
  3703                                  .try_left:
  3704 00001C71 49FFC8                      dec r8
  3705                                  
  3706                                  .check_valid:
  3707                                      ; 4) Verificar límites
  3708 00001C74 4983F801                    cmp r8, 1                    
  3709 00001C78 0F8EA4000000                jle .invalid_move
  3710 00001C7E 4983F850                    cmp r8, column_cells        
  3711 00001C82 0F8D9A000000                jge .invalid_move
  3712 00001C88 4983F901                    cmp r9, 1                    
  3713 00001C8C 0F8E90000000                jle .invalid_move
  3714 00001C92 4983F920                    cmp r9, row_cells          
  3715 00001C96 0F8D86000000                jge .invalid_move
  3716                                  
  3717                                      ; 5) Verificar colisión con bloques/enemigos
  3718 00001C9C 4150                        push r8
  3719 00001C9E 4151                        push r9
  3720 00001CA0 B850000000                  mov rax, column_cells
  3721 00001CA5 4883C002                    add rax, 2
  3722 00001CA9 49F7E1                      mul r9
  3723 00001CAC 4C01C0                      add rax, r8
  3724 00001CAF 488DB8[400A0000]            lea rdi, [board + rax]
  3725 00001CB6 8A07                        mov al, [rdi]
  3726                                  
  3727                                      ; Revisa si es bloque o borde
  3728 00001CB8 3C55                        cmp al, 'U'
  3729 00001CBA 7462                        je .pop_and_invalid
  3730 00001CBC 3C4F                        cmp al, 'O'
  3731 00001CBE 745E                        je .pop_and_invalid
  3732 00001CC0 3C44                        cmp al, 'D'
  3733 00001CC2 745A                        je .pop_and_invalid
  3734 00001CC4 3C4C                        cmp al, 'L'
  3735 00001CC6 7456                        je .pop_and_invalid
  3736 00001CC8 3C56                        cmp al, 'V'
  3737 00001CCA 7452                        je .pop_and_invalid
  3738 00001CCC 3C38                        cmp al, '8'
  3739 00001CCE 744E                        je .pop_and_invalid
  3740 00001CD0 3C58                        cmp al, 'X'
  3741 00001CD2 744A                        je .pop_and_invalid
  3742                                  
  3743                                      ; Revisa si hay enemigo
  3744 00001CD4 3C40                        cmp al, '@'
  3745 00001CD6 7446                        je .pop_and_invalid
  3746 00001CD8 3C23                        cmp al, '#'
  3747 00001CDA 7442                        je .pop_and_invalid
  3748 00001CDC 3C24                        cmp al, '$'
  3749 00001CDE 743E                        je .pop_and_invalid
  3750 00001CE0 3C26                        cmp al, '&'
  3751 00001CE2 743A                        je .pop_and_invalid
  3752                                  
  3753 00001CE4 E808030000                  call check_enemy_at_position
  3754 00001CE9 4883F801                    cmp rax, 1
  3755 00001CED 742F                        je .pop_and_invalid
  3756                                  
  3757                                      ; ------------------------------
  3758                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3759                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3760                                      ; ------------------------------
  3761 00001CEF 4159                        pop r9
  3762 00001CF1 4158                        pop r8
  3763                                  
  3764                                      ; (A) Borrar la posición antigua en el board
  3765                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3766 00001CF3 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3767 00001CF7 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3768 00001CFC B850000000                  mov rax, column_cells
  3769 00001D01 4883C002                    add rax, 2
  3770 00001D05 49F7E3                      mul r11
  3771 00001D08 4C01D0                      add rax, r10
  3772 00001D0B 488DB8[400A0000]            lea rdi, [board + rax]
  3773 00001D12 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3774                                  
  3775                                      ; (B) Guardar la nueva X,Y en la estructura
  3776 00001D15 448803                      mov byte [rbx], r8b
  3777 00001D18 44884B01                    mov byte [rbx + 1], r9b
  3778                                  
  3779 00001D1C EB0D                        jmp .done
  3780                                  
  3781                                  .pop_and_invalid:
  3782 00001D1E 4159                        pop r9
  3783 00001D20 4158                        pop r8
  3784                                  
  3785                                  .invalid_move:
  3786                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3787 00001D22 4C0FB603                    movzx r8, byte [rbx]
  3788 00001D26 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3789                                      ; Se queda donde estaba
  3790                                  .done:
  3791 00001D2B 5F                          pop rdi
  3792 00001D2C 5A                          pop rdx
  3793 00001D2D 5B                          pop rbx
  3794 00001D2E 5D                          pop rbp
  3795 00001D2F C3                          ret
  3796                                  
  3797                                  
  3798                                  ; Función para mover enemigos
  3799                                  move_enemies:
  3800 00001D30 55                          push rbp
  3801 00001D31 4889E5                      mov rbp, rsp
  3802                                      
  3803                                      ; Incrementar contador de movimiento
  3804 00001D34 FE05(87200000)              inc byte [enemy_move_counter]
  3805 00001D3A 480FB605(87200000)          movzx rax, byte [enemy_move_counter]
  3806 00001D42 3A05(88200000)              cmp al, [enemy_move_delay]
  3807 00001D48 0F85A1020000                jne .end
  3808                                      
  3809                                      ; Resetear contador
  3810 00001D4E C605(87200000)00            mov byte [enemy_move_counter], 0
  3811                                      
  3812 00001D55 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3813                                      
  3814                                      .enemy_loop:
  3815 00001D58 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3816 00001D5C 0F8D8D020000                    jge .end
  3817                                          
  3818                                          ; Calcular offset del enemigo actual
  3819 00001D62 4C89E0                          mov rax, r12
  3820 00001D65 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3821 00001D69 488DB0[60200000]                lea rsi, [enemies + rax]
  3822                                          
  3823                                          ; Verificar si el enemigo está activo
  3824 00001D70 807E0201                        cmp byte [rsi + 2], 1
  3825 00001D74 0F856D020000                    jne .next_enemy
  3826                                          
  3827                                          ; Obtener posición actual
  3828 00001D7A 4C0FB606                        movzx r8, byte [rsi]            ; X
  3829 00001D7E 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3830                                          
  3831 00001D83 488D3D(40240000)                lea rdi, [enemy_last_x]
  3832 00001D8A 4C01E7                          add rdi, r12
  3833 00001D8D 8A07                            mov al, [rdi]             ; al = last_x
  3834                                  
  3835 00001D8F 488D15(4A240000)                lea rdx, [enemy_last_y]
  3836 00001D96 4C01E2                          add rdx, r12
  3837 00001D99 8A22                            mov ah, [rdx]             ; ah = last_y
  3838                                  
  3839                                          ; r8 = X actual del enemigo
  3840                                          ; r9 = Y actual del enemigo
  3841                                  
  3842                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3843 00001D9B 88E2                            mov dl, ah      ; dl = old_Y
  3844 00001D9D 4488CB                          mov bl, r9b     ; bl = new_Y
  3845 00001DA0 38DA                            cmp dl, bl
  3846 00001DA2 752C                            jne .not_stuck
  3847                                  
  3848                                          ; => SI son iguales => pasa al siguiente check
  3849 00001DA4 88C2                            mov dl, al      ; dl = old_X
  3850 00001DA6 4488C3                          mov bl, r8b     ; bl = new_X
  3851 00001DA9 38DA                            cmp dl, bl
  3852 00001DAB 7523                            jne .not_stuck
  3853                                  
  3854                                          ; => MISMA POSICIÓN (STUCK)
  3855 00001DAD 488D1D(54240000)                lea rbx, [enemy_stuck_count]
  3856 00001DB4 4C01E3                          add rbx, r12
  3857 00001DB7 FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3858                                  
  3859                                          ; Verificar si supera umbral, digamos 3
  3860 00001DB9 480FB60B                        movzx rcx, byte [rbx]
  3861 00001DBD 4883F902                        cmp rcx, 2
  3862 00001DC1 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3863                                  
  3864                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3865                                          ;  1) resetear el stuck_count
  3866 00001DC3 C60300                          mov byte [rbx], 0
  3867                                  
  3868                                          ;  2) cambiar random
  3869 00001DC6 E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3870 00001DCB E917020000                      jmp .next_enemy
  3871                                  
  3872                                      .not_stuck:
  3873                                          ; => Se movió
  3874 00001DD0 488D1D(54240000)                lea rbx, [enemy_stuck_count]
  3875 00001DD7 4C01E3                          add rbx, r12
  3876 00001DDA C60300                          mov byte [rbx], 0            ; Resetear
  3877                                  
  3878                                          ; Guardar su nueva posición en “last_x, last_y”
  3879 00001DDD 488D3D(40240000)                lea rdi, [enemy_last_x]
  3880 00001DE4 4C01E7                          add rdi, r12
  3881 00001DE7 448807                          mov [rdi], r8b
  3882                                          
  3883 00001DEA 488D3D(4A240000)                lea rdi, [enemy_last_y]
  3884 00001DF1 4C01E7                          add rdi, r12
  3885 00001DF4 44880F                          mov [rdi], r9b
  3886                                  
  3887                                          ; Limpiar posición actual antes de mover
  3888                                      .check_normal_move:
  3889 00001DF7 4150                            push r8
  3890 00001DF9 4151                            push r9
  3891 00001DFB B850000000                      mov rax, column_cells
  3892 00001E00 4883C002                        add rax, 2
  3893 00001E04 49F7E1                          mul r9
  3894 00001E07 4C01C0                          add rax, r8
  3895 00001E0A 488DB8[400A0000]                lea rdi, [board + rax]
  3896 00001E11 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3897 00001E14 4159                            pop r9
  3898 00001E16 4158                            pop r8
  3899                                  
  3900                                          ; Determinar comportamiento basado en índice
  3901 00001E18 4C89E0                          mov rax, r12
  3902 00001E1B 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3903 00001E1F 4885C0                          test rax, rax
  3904 00001E22 7405                            jz .chase_ball
  3905 00001E24 E996000000                      jmp .chase_paddle             ; Si es 1, perseguir paleta
  3906                                          
  3907                                          ; Perseguir bola (comportamiento original)
  3908                                      .chase_ball:
  3909                                          ; Primero intentar con la bola principal
  3910 00001E29 803D(00150000)01                cmp byte [ball_active], 1
  3911 00001E30 7414                            je .use_ball1
  3912                                          
  3913                                          ; Si no está activa, probar con ball2
  3914 00001E32 803D(22150000)01                cmp byte [ball2_active], 1
  3915 00001E39 7414                            je .use_ball2
  3916                                          
  3917                                          ; Si no está activa, probar con ball3
  3918 00001E3B 803D(44150000)01                cmp byte [ball3_active], 1
  3919 00001E42 7414                            je .use_ball3
  3920                                          
  3921                                          ; Si no hay bolas activas, perseguir la paleta
  3922 00001E44 EB79                            jmp .chase_paddle
  3923                                  
  3924                                      .use_ball1:
  3925 00001E46 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3926 00001E4D EB12                            jmp .compare_positions
  3927                                  
  3928                                      .use_ball2:
  3929 00001E4F 4C8B15(01150000)                mov r10, [ball2_x_pos]
  3930 00001E56 EB09                            jmp .compare_positions
  3931                                  
  3932                                      .use_ball3:
  3933 00001E58 4C8B15(23150000)                mov r10, [ball3_x_pos]
  3934 00001E5F EB00                            jmp .compare_positions
  3935                                  
  3936                                      .compare_positions:
  3937                                          ; Comparar X
  3938 00001E61 4D39D0                          cmp r8, r10
  3939 00001E64 0F8FCA000000                    jg .move_left
  3940 00001E6A 0F8CC9000000                    jl .move_right
  3941                                          
  3942                                          ; Si llegamos aquí, las X son iguales
  3943                                          ; Ahora comparar Y según qué bola estemos siguiendo
  3944 00001E70 803D(00150000)01                cmp byte [ball_active], 1
  3945 00001E77 7417                            je .check_ball1_y
  3946 00001E79 803D(22150000)01                cmp byte [ball2_active], 1
  3947 00001E80 7417                            je .check_ball2_y
  3948 00001E82 803D(44150000)01                cmp byte [ball3_active], 1
  3949 00001E89 7417                            je .check_ball3_y
  3950 00001E8B E9D4000000                      jmp .check_collision
  3951                                  
  3952                                      .check_ball1_y:
  3953 00001E90 4C8B15(E7140000)                mov r10, [ball_y_pos]
  3954 00001E97 EB12                            jmp .compare_y
  3955                                  
  3956                                      .check_ball2_y:
  3957 00001E99 4C8B15(09150000)                mov r10, [ball2_y_pos]
  3958 00001EA0 EB09                            jmp .compare_y
  3959                                  
  3960                                      .check_ball3_y:
  3961 00001EA2 4C8B15(2B150000)                mov r10, [ball3_y_pos]
  3962 00001EA9 EB00                            jmp .compare_y
  3963                                  
  3964                                      .compare_y:
  3965 00001EAB 4D39D1                          cmp r9, r10
  3966 00001EAE 0F8F8A000000                    jg .move_up
  3967 00001EB4 0F8C89000000                    jl .move_down
  3968 00001EBA E9A5000000                      jmp .check_collision
  3969                                          
  3970                                      .chase_paddle:
  3971                                          ; Obtener la posición X actual de la paleta
  3972 00001EBF 4C8B15(BF140000)                mov r10, [pallet_position]
  3973 00001EC6 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  3974                                          
  3975                                          ; Calcular la posición X real de la paleta
  3976 00001ECD 4C89D0                          mov rax, r10
  3977 00001ED0 BB50000000                      mov rbx, column_cells
  3978 00001ED5 4883C302                        add rbx, 2                  ; Añadir newline chars
  3979 00001ED9 4831D2                          xor rdx, rdx
  3980 00001EDC 48F7F3                          div rbx                     ; rax = y, rdx = x
  3981                                          
  3982                                          ; rdx ahora contiene la posición X de la paleta
  3983                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  3984 00001EDF 488B0D(C7140000)                mov rcx, [pallet_size]
  3985 00001EE6 48D1E9                          shr rcx, 1                  ; Dividir por 2
  3986 00001EE9 4801CA                          add rdx, rcx
  3987                                          
  3988                                          ; Comparar con posición X del enemigo y mover gradualmente
  3989 00001EEC 4939D0                          cmp r8, rdx
  3990 00001EEF 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  3991 00001EF1 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  3992 00001EF3 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  3993                                  
  3994                                      .check_y_paddle:
  3995                                          ; La Y de la paleta siempre es row_cells - 2
  3996 00001EF5 41BA20000000                    mov r10, row_cells
  3997 00001EFB 4983EA02                        sub r10, 2
  3998                                          
  3999                                          ; Comparar con posición Y del enemigo y mover gradualmente
  4000 00001EFF 4D39D1                          cmp r9, r10
  4001 00001F02 7404                            je .no_movement            ; Si está en la misma Y, no mover
  4002 00001F04 7F38                            jg .move_up               ; Si está abajo, mover arriba
  4003 00001F06 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  4004                                          
  4005                                      .no_movement:
  4006 00001F08 EB5A                            jmp .check_collision
  4007                                  
  4008                                      ; También agregar una nueva sección para el movimiento suave
  4009                                      .smooth_transition:
  4010                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  4011 00001F0A 8A05(8A200000)                  mov al, [enemy_target]
  4012 00001F10 84C0                            test al, al
  4013 00001F12 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  4014                                          
  4015                                          ; Verificar distancia en X
  4016 00001F14 4989D2                          mov r10, rdx              ; Posición X objetivo
  4017 00001F17 4D29C2                          sub r10, r8               ; Calcular diferencia
  4018 00001F1A 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  4019 00001F1E 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  4020 00001F20 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  4021 00001F24 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  4022 00001F26 EB3C                            jmp .check_collision
  4023                                          
  4024                                      .limit_right_movement:
  4025 00001F28 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  4026 00001F2C EB36                            jmp .check_collision
  4027                                          
  4028                                      .limit_left_movement:
  4029 00001F2E 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  4030 00001F32 EB30                            jmp .check_collision
  4031                                      .move_left:
  4032 00001F34 49FFC8                          dec r8
  4033 00001F37 EB0F                            jmp .check_vertical
  4034                                          
  4035                                      .move_right:
  4036 00001F39 49FFC0                          inc r8
  4037 00001F3C EB0A                            jmp .check_vertical
  4038                                          
  4039                                      .move_up:
  4040 00001F3E 49FFC9                          dec r9
  4041 00001F41 EB21                            jmp .check_collision
  4042                                          
  4043                                      .move_down:
  4044 00001F43 49FFC1                          inc r9
  4045 00001F46 EB1C                            jmp .check_collision
  4046                                          
  4047                                      .check_vertical:
  4048 00001F48 8A05(8A200000)                  mov al, [enemy_target]
  4049 00001F4E 84C0                            test al, al
  4050 00001F50 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  4051 00001F56 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  4052 00001F5D 4D39D1                          cmp r9, r10
  4053 00001F60 7FDC                            jg .move_up
  4054 00001F62 7CDF                            jl .move_down
  4055                                          
  4056                                      .check_collision:
  4057                                          ; Verificar colisión con bordes
  4058 00001F64 4983F801                        cmp r8, 1                       ; Borde izquierdo
  4059 00001F68 7E7D                            jle .next_enemy
  4060 00001F6A 4983F850                        cmp r8, column_cells
  4061 00001F6E 7D77                            jge .next_enemy
  4062 00001F70 4983F901                        cmp r9, 1                       ; Borde superior
  4063 00001F74 7E71                            jle .next_enemy
  4064 00001F76 4983F920                        cmp r9, row_cells
  4065 00001F7A 7D6B                            jge .next_enemy
  4066                                          
  4067                                          ; Verificar colisión con bloques antes de moverse
  4068 00001F7C 4150                            push r8
  4069 00001F7E 4151                            push r9
  4070 00001F80 4152                            push r10
  4071                                          
  4072                                          ; Calcular posición en el tablero para verificar
  4073 00001F82 B850000000                      mov rax, column_cells
  4074 00001F87 4883C002                        add rax, 2
  4075 00001F8B 49F7E1                          mul r9
  4076 00001F8E 4C01C0                          add rax, r8
  4077 00001F91 4C8D90[400A0000]                lea r10, [board + rax]
  4078                                          
  4079                                          ; Verificar si hay un bloque en la nueva posición
  4080 00001F98 418A02                          mov al, [r10]
  4081 00001F9B 3C55                            cmp al, 'U'
  4082 00001F9D 7442                            je .invalid_move
  4083 00001F9F 3C4F                            cmp al, 'O'
  4084 00001FA1 743E                            je .invalid_move
  4085 00001FA3 3C44                            cmp al, 'D'
  4086 00001FA5 743A                            je .invalid_move
  4087 00001FA7 3C4C                            cmp al, 'L'
  4088 00001FA9 7436                            je .invalid_move
  4089 00001FAB 3C56                            cmp al, 'V'
  4090 00001FAD 7432                            je .invalid_move
  4091 00001FAF 3C38                            cmp al, '8'
  4092 00001FB1 742E                            je .invalid_move
  4093 00001FB3 3C58                            cmp al, 'X'
  4094 00001FB5 742A                            je .invalid_move
  4095 00001FB7 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  4096 00001FB9 7426                            je .invalid_move
  4097 00001FBB 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  4098 00001FBD 7422                            je .invalid_move
  4099 00001FBF 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  4100 00001FC1 741E                            je .invalid_move
  4101 00001FC3 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  4102 00001FC5 741A                            je .invalid_move
  4103                                          
  4104 00001FC7 E825000000                      call check_enemy_at_position
  4105 00001FCC 4883F801                        cmp rax, 1
  4106 00001FD0 740F                            je .invalid_move
  4107 00001FD2 415A                            pop r10
  4108 00001FD4 4159                            pop r9
  4109 00001FD6 4158                            pop r8
  4110                                          
  4111                                          ; Guardar nueva posición si es válida
  4112 00001FD8 448806                          mov [rsi], r8b
  4113 00001FDB 44884E01                        mov [rsi + 1], r9b
  4114 00001FDF EB06                            jmp .next_enemy
  4115                                          
  4116                                      .invalid_move:
  4117 00001FE1 415A                            pop r10
  4118 00001FE3 4159                            pop r9
  4119 00001FE5 4158                            pop r8
  4120                                          
  4121                                      .next_enemy:
  4122 00001FE7 49FFC4                          inc r12
  4123 00001FEA E969FDFFFF                      jmp .enemy_loop
  4124                                          
  4125                                      .end:
  4126 00001FEF 5D                              pop rbp
  4127 00001FF0 C3                              ret
  4128                                  
  4129                                  check_enemy_at_position:
  4130 00001FF1 55                          push rbp
  4131 00001FF2 4889E5                      mov rbp, rsp
  4132                                      
  4133                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  4134 00001FF5 B850000000                  mov rax, column_cells
  4135 00001FFA 4883C002                    add rax, 2
  4136 00001FFE 49F7E1                      mul r9
  4137 00002001 4C01C0                      add rax, r8
  4138 00002004 488DB8[400A0000]            lea rdi, [board + rax]
  4139 0000200B 480FB607                    movzx rax, byte [rdi]
  4140                                      
  4141                                      ; Verificar todos los caracteres de enemigos
  4142 0000200F 3C40                        cmp al, '@'
  4143 00002011 7411                        je .enemy_found
  4144 00002013 3C23                        cmp al, '#'
  4145 00002015 740D                        je .enemy_found
  4146 00002017 3C24                        cmp al, '$'
  4147 00002019 7409                        je .enemy_found
  4148 0000201B 3C26                        cmp al, '&'
  4149 0000201D 7405                        je .enemy_found
  4150                                      
  4151 0000201F 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  4152 00002022 EB05                        jmp .end
  4153                                      
  4154                                  .enemy_found:
  4155 00002024 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  4156                                      
  4157                                  .end:
  4158 00002029 5D                          pop rbp
  4159 0000202A C3                          ret
  4160                                  
  4161                                  get_current_spawn_points:
  4162 0000202B 55                          push rbp
  4163 0000202C 4889E5                      mov rbp, rsp
  4164                                      
  4165 0000202F 480FB605(79150000)          movzx rax, byte [current_level]
  4166 00002037 48FFC8                      dec rax                         ; Ajustar para índice base 0
  4167 0000203A 488B04C5[BE200000]          mov rax, [spawn_points_table + rax * 8]
  4168                                      
  4169 00002042 5D                          pop rbp
  4170 00002043 C3                          ret
  4171                                  
  4172                                  ; Función para verificar si debe aparecer un nuevo enemigo
  4173                                  check_enemy_spawn:
  4174 00002044 55                          push rbp
  4175 00002045 4889E5                      mov rbp, rsp
  4176                                      
  4177                                      ; Obtener spawn points del nivel actual
  4178 00002048 E8DEFFFFFF                  call get_current_spawn_points
  4179 0000204D 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  4180                                      
  4181                                      ; Obtener cantidad de bloques destruidos
  4182 00002050 4C0FB62D(46200000)          movzx r13, byte [destroyed_blocks]
  4183                                      
  4184                                      ; Verificar cada punto de spawn
  4185 00002058 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  4186                                      
  4187                                      .check_loop:
  4188 0000205B 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  4189 0000205F 7D4E                            jge .end
  4190                                          
  4191                                          ; Verificar si este spawn point ya fue usado
  4192 00002061 80B9[E9200000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  4193 00002068 7440                            je .next_enemy
  4194                                          
  4195                                          ; Verificar si este enemigo ya está activo
  4196 0000206A 4889C8                          mov rax, rcx
  4197 0000206D 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4198 00002071 488DB0[60200000]                lea rsi, [enemies + rax]
  4199 00002078 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  4200 0000207C 742C                            je .next_enemy
  4201                                          
  4202                                          ; Verificar si debemos spawnear este enemigo
  4203 0000207E 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  4204 00002083 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  4205 00002086 7522                            jne .next_enemy
  4206                                          
  4207                                          ; Marcar este spawn point como usado
  4208 00002088 C681[E9200000]01                mov byte [enemy_spawns_triggered + rcx], 1
  4209                                          
  4210                                          ; Spawner nuevo enemigo
  4211 0000208F B004                            mov al, 4
  4212 00002091 00C8                            add al, cl       ; con 'rcx' como índice
  4213 00002093 8806                            mov [rsi], al
  4214 00002095 C6460101                        mov byte [rsi+1], 1
  4215 00002099 C6460201                        mov byte [rsi+2], 1
  4216                                  
  4217                                          ; Inicializar comportamiento
  4218 0000209D 4889C8                          mov rax, rcx
  4219 000020A0 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  4220 000020A4 8805(E8200000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  4221                                          
  4222                                      .next_enemy:
  4223 000020AA 48FFC1                          inc rcx
  4224 000020AD EBAC                            jmp .check_loop
  4225                                          
  4226                                      .end:
  4227 000020AF 5D                              pop rbp
  4228 000020B0 C3                              ret
  4229                                  
  4230                                  
  4231                                  ; Función para dibujar enemigos
  4232                                  print_enemies:
  4233 000020B1 55                          push rbp
  4234 000020B2 4889E5                      mov rbp, rsp
  4235                                      
  4236 000020B5 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4237                                      
  4238                                      .print_loop:
  4239 000020B8 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  4240 000020BC 7D4B                            jge .end
  4241                                          
  4242                                          ; Calcular offset del enemigo actual
  4243 000020BE 4C89E0                          mov rax, r12
  4244 000020C1 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  4245 000020C5 488DB0[60200000]                lea rsi, [enemies + rax]
  4246                                          
  4247                                          ; Verificar si el enemigo está activo
  4248 000020CC 807E0201                        cmp byte [rsi + 2], 1
  4249 000020D0 7532                            jne .next_enemy
  4250                                          
  4251                                          ; Calcular posición en el tablero
  4252 000020D2 4C0FB606                        movzx r8, byte [rsi]            ; X
  4253 000020D6 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  4254                                          
  4255                                          ; Calcular offset en el tablero
  4256 000020DB B850000000                      mov rax, column_cells
  4257 000020E0 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  4258 000020E4 49F7E1                          mul r9
  4259 000020E7 4C01C0                          add rax, r8
  4260 000020EA 488DB8[400A0000]                lea rdi, [board + rax]
  4261                                          
  4262                                          ; Obtener carácter del enemigo según el nivel
  4263 000020F1 480FB605(79150000)              movzx rax, byte [current_level]
  4264 000020F9 48FFC8                          dec rax                         ; Ajustar para índice base 0
  4265 000020FC 8A80[5B200000]                  mov al, [enemy_chars + rax]
  4266                                          
  4267                                          ; Dibujar enemigo
  4268 00002102 8807                            mov [rdi], al
  4269                                          
  4270                                      .next_enemy:
  4271 00002104 49FFC4                          inc r12
  4272 00002107 EBAF                            jmp .print_loop
  4273                                          
  4274                                      .end:
  4275 00002109 5D                              pop rbp
  4276 0000210A C3                              ret
  4277                                  
  4278                                  ; Función para verificar colisión con enemigos
  4279                                  ; Función para verificar colisión con enemigos
  4280                                  check_enemy_collision:
  4281 0000210B 55                          push rbp
  4282 0000210C 4889E5                      mov rbp, rsp
  4283                                      
  4284 0000210F 4D31E4                      xor r12, r12                    ; Índice del enemigo
  4285 00002112 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  4286                                      
  4287                                      .check_loop:
  4288 00002115 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  4289 00002119 0F8DE9000000                    jge .end
  4290                                          
  4291                                          ; Calcular offset del enemigo actual
  4292 0000211F 4C89E1                          mov rcx, r12
  4293 00002122 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  4294 00002126 488DB1[60200000]                lea rsi, [enemies + rcx]
  4295                                          
  4296                                          ; Verificar si el enemigo está activo
  4297 0000212D 807E0201                        cmp byte [rsi + 2], 1
  4298 00002131 0F85C9000000                    jne .next_enemy
  4299                                          
  4300                                          ; Verificar colisión con la bola
  4301 00002137 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  4302 0000213B 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  4303                                          
  4304                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  4305 00002140 4C8B15(DF140000)                mov r10, [ball_x_pos]
  4306 00002147 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  4307                                          
  4308                                          ; Comprobar colisión vertical (misma columna)
  4309 0000214E 4D39C2                          cmp r10, r8
  4310 00002151 7525                            jne .check_horizontal
  4311 00002153 4D29CB                          sub r11, r9
  4312 00002156 4983FB01                        cmp r11, 1
  4313 0000215A 7F1C                            jg .check_horizontal
  4314 0000215C 4983FBFF                        cmp r11, -1
  4315 00002160 7C16                            jl .check_horizontal
  4316                                          
  4317                                          ; Colisión vertical detectada
  4318 00002162 E8A3000000                      call destroy_enemy
  4319 00002167 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  4320 0000216E B801000000                      mov rax, 1
  4321 00002173 E990000000                      jmp .end
  4322                                          
  4323                                      .check_horizontal:
  4324                                          ; Comprobar colisión horizontal (misma fila)
  4325 00002178 4C8B15(DF140000)                mov r10, [ball_x_pos]
  4326 0000217F 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  4327 00002186 4D39CB                          cmp r11, r9
  4328 00002189 7522                            jne .check_paddle
  4329 0000218B 4D29C2                          sub r10, r8
  4330 0000218E 4983FA01                        cmp r10, 1
  4331 00002192 7F19                            jg .check_paddle
  4332 00002194 4983FAFF                        cmp r10, -1
  4333 00002198 7C13                            jl .check_paddle
  4334                                          
  4335                                          ; Colisión horizontal detectada
  4336 0000219A E86B000000                      call destroy_enemy
  4337 0000219F 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  4338 000021A6 B801000000                      mov rax, 1
  4339 000021AB EB5B                            jmp .end
  4340                                          
  4341                                      .check_paddle:
  4342                                          ; Verificar colisión con la paleta
  4343 000021AD 4C8B15(BF140000)                mov r10, [pallet_position]
  4344 000021B4 4981EA[400A0000]                sub r10, board
  4345 000021BB 4C89D0                          mov rax, r10
  4346 000021BE 41BB50000000                    mov r11, column_cells
  4347 000021C4 4983C302                        add r11, 2
  4348 000021C8 4831D2                          xor rdx, rdx
  4349 000021CB 49F7F3                          div r11                     ; División para obtener la posición Y
  4350 000021CE 4989D3                          mov r11, rdx               ; X de la paleta en r11
  4351                                          
  4352 000021D1 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  4353                                          
  4354                                          ; Verificar si el enemigo está en la misma fila que la paleta
  4355 000021D8 41BD20000000                    mov r13, row_cells
  4356 000021DE 4983ED02                        sub r13, 2                 ; Y de la paleta
  4357 000021E2 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  4358 000021E5 7519                            jne .next_enemy
  4359                                          
  4360                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  4361 000021E7 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  4362 000021EA 7C14                            jl .next_enemy
  4363                                          
  4364 000021EC 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  4365 000021EF 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  4366 000021F2 7F0C                            jg .next_enemy
  4367                                          
  4368                                          ; Si llegamos aquí, hay colisión con la paleta
  4369 000021F4 E811000000                      call destroy_enemy        ; Destruir el enemigo
  4370 000021F9 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  4371 000021FE EB08                            jmp .end
  4372                                          
  4373                                      .next_enemy:
  4374 00002200 49FFC4                          inc r12
  4375 00002203 E90DFFFFFF                      jmp .check_loop
  4376                                          
  4377                                      .end:
  4378 00002208 5D                              pop rbp
  4379 00002209 C3                              ret
  4380                                  
  4381                                  ; Función para destruir un enemigo
  4382                                  destroy_enemy:
  4383                                      ; Desactivar enemigo
  4384 0000220A C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  4385                                  
  4386                                      ; Sumar puntos por destruir enemigo
  4387 0000220E 488B05(7F200000)            mov rax, [enemy_points]
  4388 00002215 480105(3E200000)            add [current_score], rax
  4389                                  
  4390                                      ; No tocar bloques destruidos aquí
  4391 0000221C C3                          ret
  4392                                  
  4393                                  
  4394                                  _start:
  4395 0000221D E809DFFFFF              	call canonical_off
  4396 00002222 E857010000              	call start_screen
  4397 00002227 E811F3FFFF                  call init_level
  4398 0000222C EB00                    	jmp .main_loop
  4399                                  	
  4400                                  
  4401                                      .main_loop:
  4402 0000222E E87FF7FFFF                      call print_labels
  4403 00002233 E8AEF6FFFF                      call print_blocks
  4404 00002238 E818E3FFFF                      call move_letters
  4405 0000223D E8FEE5FFFF                      call update_lasers
  4406 00002242 E883E2FFFF                      call print_letters
  4407 00002247 E802EAFFFF                      call print_pallet
  4408                                          
  4409                                          ; Mover bola principal solo si está activa
  4410 0000224C 803D(00150000)01                cmp byte [ball_active], 1
  4411 00002253 7505                            jne .skip_ball1
  4412 00002255 E80BEBFFFF                          call move_ball
  4413                                          .skip_ball1:
  4414                                  
  4415                                          ; Mover bola 2 si está activa
  4416 0000225A 803D(22150000)01                cmp byte [ball2_active], 1
  4417 00002261 7505                            jne .skip_ball2
  4418 00002263 E8D0ECFFFF                          call move_ball_2
  4419                                          .skip_ball2:
  4420                                  
  4421                                          ; Mover bola 3 si está activa
  4422 00002268 803D(44150000)01                cmp byte [ball3_active], 1
  4423 0000226F 7505                            jne .skip_ball3
  4424 00002271 E895EEFFFF                          call move_ball_3
  4425                                          .skip_ball3:
  4426                                  
  4427 00002276 E87BE0FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  4428 0000227B E85DDFFFFF                      call print_lives
  4429                                  
  4430                                          ; Imprimir solo las bolas activas
  4431 00002280 803D(00150000)01                cmp byte [ball_active], 1
  4432 00002287 7505                            jne .no_pb1
  4433 00002289 E848E9FFFF                          call print_ball
  4434                                          .no_pb1:
  4435                                  
  4436 0000228E 803D(22150000)01                cmp byte [ball2_active], 1
  4437 00002295 7505                            jne .no_pb2
  4438 00002297 E862E9FFFF                          call print_ball_2
  4439                                          .no_pb2:
  4440                                  
  4441 0000229C 803D(44150000)01                cmp byte [ball3_active], 1
  4442 000022A3 7505                            jne .no_pb3
  4443 000022A5 E87CE9FFFF                          call print_ball_3
  4444                                          .no_pb3:
  4445                                  
  4446 000022AA E87FF4FFFF                      call check_level_complete
  4447 000022AF E890FDFFFF                      call check_enemy_spawn
  4448 000022B4 E877FAFFFF                      call move_enemies
  4449 000022B9 E84DFEFFFF                      call check_enemy_collision
  4450 000022BE E8EEFDFFFF                      call print_enemies
  4451 000022C3 E8ECE4FFFF                      call print_power_label
  4452                                  		print board, board_size				
    93 000022C8 B801000000          <1>  mov eax, sys_write
    94 000022CD BF01000000          <1>  mov edi, 1
    95 000022D2 48BE-               <1>  mov rsi, %1
    95 000022D4 [400A000000000000]  <1>
    96 000022DC BA400A0000          <1>  mov edx, %2
    97 000022E1 0F05                <1>  syscall
  4453                                  		;setnonblocking	
  4454                                  	.read_more:	
  4455                                  	    getchar	
   101 000022E3 B800000000          <1>  mov rax, sys_read
   102 000022E8 BF00000000          <1>  mov rdi, STDIN_FILENO
   103 000022ED 48BE-               <1>  mov rsi, input_char
   103 000022EF [0000000000000000]  <1>
   104 000022F7 BA01000000          <1>  mov rdx, 1
   105 000022FC 0F05                <1>  syscall
  4456 000022FE 4883F801                	    cmp rax, 1
  4457 00002302 7547                    	    jne .done
  4458                                  	
  4459 00002304 8A05(00000000)          	    mov al, [input_char]
  4460 0000230A 8805(08230000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  4461                                  	
  4462 00002310 3C61                    	    cmp al, 'a'
  4463 00002312 750E                    	    jne .not_left
  4464 00002314 48C7C7FFFFFFFF          	    mov rdi, left_direction
  4465 0000231B E863E9FFFF              	    call move_pallet
  4466 00002320 EB29                    	    jmp .done
  4467                                  	
  4468                                      .not_left:
  4469 00002322 3C64                    	    cmp al, 'd'
  4470 00002324 750C                    	    jne .not_right
  4471 00002326 BF01000000              	    mov rdi, right_direction
  4472 0000232B E853E9FFFF              	    call move_pallet
  4473 00002330 EB19                    	    jmp .done
  4474                                  	
  4475                                      .not_right:
  4476 00002332 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  4477 00002334 740E                    	    je .release_ball        ; Si sí, liberar la bola
  4478                                  	
  4479 00002336 3C78                            cmp al, 'x'             ; Verificar si se presionó la tecla 'c'
  4480 00002338 740A                    	    je .release_ball        ; Si sí, liberar la bola
  4481                                  	
  4482                                  
  4483 0000233A 3C71                    	    cmp al, 'q' 
  4484 0000233C 0F84AF000000            	    je exit
  4485 00002342 EB9F                    	    jmp .read_more
  4486                                  	
  4487                                      .release_ball:
  4488 00002344 E895EFFFFF              	    call process_catch_release
  4489 00002349 EB00                    	    jmp .done
  4490                                  	
  4491                                      .done:
  4492                                  	    sleeptime
   109 0000234B B823000000          <1>  mov eax, sys_nanosleep
   110 00002350 48BF-               <1>  mov rdi, timespec
   110 00002352 [0000000000000000]  <1>
   111 0000235A 31F6                <1>  xor esi, esi
   112 0000235C 0F05                <1>  syscall
  4493                                  	    print clear, clear_length
    93 0000235E B801000000          <1>  mov eax, sys_write
    94 00002363 BF01000000          <1>  mov edi, 1
    95 00002368 48BE-               <1>  mov rsi, %1
    95 0000236A [1000000000000000]  <1>
    96 00002372 BA07000000          <1>  mov edx, %2
    97 00002377 0F05                <1>  syscall
  4494 00002379 E9B0FEFFFF              	    jmp .main_loop
  4495                                  
  4496                                  
  4497                                  
  4498                                  
  4499                                  start_screen:
  4500                                      print clear, clear_length    ; Limpiamos la pantalla primero
    93 0000237E B801000000          <1>  mov eax, sys_write
    94 00002383 BF01000000          <1>  mov edi, 1
    95 00002388 48BE-               <1>  mov rsi, %1
    95 0000238A [1000000000000000]  <1>
    96 00002392 BA07000000          <1>  mov edx, %2
    97 00002397 0F05                <1>  syscall
  4501                                      print msg1, msg1_length
    93 00002399 B801000000          <1>  mov eax, sys_write
    94 0000239E BF01000000          <1>  mov edi, 1
    95 000023A3 48BE-               <1>  mov rsi, %1
    95 000023A5 [1700000000000000]  <1>
    96 000023AD BA14010000          <1>  mov edx, %2
    97 000023B2 0F05                <1>  syscall
  4502                                      
  4503                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  4504                                          getchar                 ; Esperamos una tecla
   101 000023B4 B800000000          <1>  mov rax, sys_read
   102 000023B9 BF00000000          <1>  mov rdi, STDIN_FILENO
   103 000023BE 48BE-               <1>  mov rsi, input_char
   103 000023C0 [0000000000000000]  <1>
   104 000023C8 BA01000000          <1>  mov rdx, 1
   105 000023CD 0F05                <1>  syscall
  4505 000023CF 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  4506 000023D3 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  4507                                          
  4508                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    93 000023D5 B801000000          <1>  mov eax, sys_write
    94 000023DA BF01000000          <1>  mov edi, 1
    95 000023DF 48BE-               <1>  mov rsi, %1
    95 000023E1 [1000000000000000]  <1>
    96 000023E9 BA07000000          <1>  mov edx, %2
    97 000023EE 0F05                <1>  syscall
  4509 000023F0 C3                          ret
  4510                                  
  4511                                  exit: 
  4512 000023F1 E877DDFFFF              	call canonical_on
  4513 000023F6 B83C000000              	mov    rax, 60
  4514 000023FB BF00000000                  mov    rdi, 0
  4515 00002400 0F05                        syscall
  4516                                  
