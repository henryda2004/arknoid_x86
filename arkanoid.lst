     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293 000014CA 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   294 000014CF 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   295 000014D4 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   296 000014D9 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   297                                  
   298                                  
   299                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   300                                  
   301                                      ; Nivel 2: Bloques de prueba
   302                                      level2_blocks:
   303 000014DE 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   304                                      level2_blocks_count equ 1
   305                                  
   306                                      ; Nivel 3
   307                                      level3_blocks:
   308 000014E3 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   309                                  
   310                                      level3_blocks_count equ 1
   311                                  
   312                                      ; Nivel 4
   313                                      level4_blocks:
   314 000014E8 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   315                                      level4_blocks_count equ 1
   316                                  
   317                                      ; Nivel 5
   318                                      level5_blocks:
   319 000014ED 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   320                                      level5_blocks_count equ 1
   321                                  
   322                                      ; Array para mantener el estado de los bloques
   323 000014F2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   324                                  
   325                                      
   326                                      ; Variables para almacenar los valores
   327 00001556 0000000000000000            current_score dq 0          ; Score actual
   328 0000155E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   329                                      
   330                                      ; Buffer para convertir números a string
   331 0000155F 00<rep 14h>                 number_buffer: times 20 db 0
   332                                  
   333 00001573 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   334                                      
   335                                      ; Estructura para los enemigos (x, y, activo)
   336 00001578 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   337 00001596 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   338                                      
   339 00001597 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   340 0000159F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   341 000015A0 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   342 000015A1 00                          enemy_move_total db 0      ; Contador total de movimientos
   343 000015A2 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   344 000015A3 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   345                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   346                                      ; Añade esto en la sección .dataa
   347 000015A4 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   347 000015AD 12                 
   348 000015AE 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   348 000015B7 13                 
   349 000015B8 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   349 000015C1 1B                 
   350 000015C2 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   350 000015CB 1C                 
   351 000015CC 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   351 000015D5 2D                 
   352                                          ; Arreglo de punteros a los spawn points de cada nivel
   353                                      spawn_points_table:
   354 000015D6 [A415000000000000]              dq level1_spawn_points
   355 000015DE [AE15000000000000]              dq level2_spawn_points
   356 000015E6 [B815000000000000]              dq level3_spawn_points
   357 000015EE [C215000000000000]              dq level4_spawn_points
   358 000015F6 [CC15000000000000]              dq level5_spawn_points
   359                                  
   360                                      ; Variables para el comportamiento de enemigos
   361 000015FE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   362 000015FF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   363 00001600 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   364 00001601 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   365                                  
   366 0000160B 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   366 00001614 5B2020202020202020-
   366 0000161D 20205D0A0D         
   367                                      score_label_len: equ $ - score_label
   368 00001622 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   368 0000162B 657374727569646F73-
   368 00001634 3A205B2020205D0A0D 
   369                                      blocks_label_len: equ $ - blocks_label
   370                                      
   371                                      ; Posición donde insertar los números en los labels
   372                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   373                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   374                                      
   375                                      ; Definición de las vidas (x, y, estado)
   376                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   377                                      lives_data: 
   378 0000163D 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   379 00001640 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   380 00001643 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   381 00001646 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   382 00001649 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   383 0000164C 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   384 0000164F 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   385                                      lives_count equ 7    ; Total de vidas
   386 00001652 5E                          life_char db "^"    
   387 00001653 04                          current_lives db 4   ; Contador de vidas activas actual
   388                                  
   389                                  ; Estructura para almacenar las letras y sus posiciones
   390                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   391 00001654 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   392 000017E4 00                          letters_count db 0   
   393 000017E5 20                          last_letter db ' '    ; Variable para almacenar la última letra
   394 000017E6 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   394 000017EF 75616C3A205B205D0A-
   394 000017F8 0D                 
   395                                      last_letter_msg_len equ $ - last_letter_msg
   396 000017F9 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   397 000017FA 07                          max_lives db 7              ; Máximo número de vidas permitidas
   398 000017FB 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   399 00001803 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   400 0000180B 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   401                                  
   402 00001813 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   403 00001814 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   404 00001815 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   405 0000181D 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   406                                  
   407 0000181E 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   408 0000181F 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   409 00001820 00                          laser_count: db 0                ; Contador de láseres activos
   410 00001821 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   411 000018E9 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   412                                  
   413                                  section .text
   414                                  
   415                                  
   416                                  print_lives:
   417 000001DD 55                          push rbp
   418 000001DE 4889E5                      mov rbp, rsp
   419                                      
   420 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   421                                      
   422                                      .print_loop:
   423 000001E4 4983FC07                        cmp r12, lives_count
   424 000001E8 7D45                            jge .end
   425                                          
   426                                          ; Calcular offset de la vida actual
   427 000001EA 4C89E0                          mov rax, r12
   428 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   429 000001F1 488DB0[3D160000]                lea rsi, [lives_data + rax]
   430                                          
   431                                          ; Calcular posición en el tablero
   432 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   433 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   434                                          
   435                                          ; Calcular offset en el tablero
   436 00000201 B84E000000                      mov rax, column_cells
   437 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   438 0000020A 49F7E1                          mul r9
   439 0000020D 4C01C0                          add rax, r8
   440 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   441                                          
   442                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   443 00000217 807E0201                        cmp byte [rsi + 2], 1
   444 0000021B 7405                            je .draw_active
   445                                          
   446                                          ; Si está inactiva, dibujar espacio
   447 0000021D C60720                          mov byte [rdi], ' '
   448 00000220 EB08                            jmp .next_life
   449                                          
   450                                      .draw_active:
   451                                          ; Si está activa, dibujar el símbolo de vida
   452 00000222 8A05(52160000)                  mov al, [life_char]
   453 00000228 8807                            mov [rdi], al
   454                                          
   455                                      .next_life:
   456 0000022A 49FFC4                          inc r12
   457 0000022D EBB5                            jmp .print_loop
   458                                          
   459                                      .end:
   460 0000022F 5D                              pop rbp
   461 00000230 C3                              ret
   462                                  
   463                                  ; Función para desactivar una vida
   464                                  ; Función modificada para perder una vida
   465                                  lose_life:
   466 00000231 55                          push rbp
   467 00000232 4889E5                      mov rbp, rsp
   468                                      
   469                                      ; Verificar si aún quedan vidas
   470 00000235 803D(53160000)00            cmp byte [current_lives], 0
   471 0000023C 0F8493000000                je .game_lost
   472                                      
   473                                      ; Encontrar la última vida activa
   474 00000242 B907000000                  mov rcx, lives_count
   475 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   476                                      
   477                                      .find_active_life:
   478 0000024A 4889C8                          mov rax, rcx
   479 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   480 00000251 488DB0[3D160000]                lea rsi, [lives_data + rax]
   481 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   482 0000025C 7407                            je .deactivate_life
   483 0000025E 48FFC9                          dec rcx
   484 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   485 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   486                                          
   487                                      .deactivate_life:
   488                                          ; Calcular posición correcta en el tablero para borrar la vida
   489 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   490 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   491                                          
   492                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   493 0000026E B84E000000                      mov rax, column_cells
   494 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   495 00000277 49F7E1                          mul r9
   496 0000027A 4C01C0                          add rax, r8
   497 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   498                                          
   499                                          ; Borrar visualmente la vida
   500 00000284 C60720                          mov byte [rdi], ' '             
   501                                          
   502                                          ; Desactivar la vida en los datos
   503 00000287 C6460200                        mov byte [rsi + 2], 0          
   504 0000028B FE0D(53160000)                  dec byte [current_lives]
   505                                          
   506                                          ; Borrar visualmente la paleta anterior
   507 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   508 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   509                                          .erase_pallet_loop:
   510 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   511 000002A3 49FFC0                              inc r8
   512 000002A6 48FFC9                              dec rcx
   513 000002A9 75F4                                jnz .erase_pallet_loop
   514                                          
   515                                  
   516                                          ; Reiniciar posición de la bola y la paleta
   517 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   517 000002B3 000000             
   518 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   518 000002BE 000000             
   519 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   520 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   520 000002CF [36130000]         
   521                                          
   522 000002D3 EB07                            jmp .end
   523                                          
   524                                      .game_lost:
   525 000002D5 E81C000000                      call game_lost
   526 000002DA EB00                            jmp .end
   527                                          
   528                                      .end:
   529 000002DC 5D                              pop rbp
   530 000002DD C3                              ret
   531                                  ; Función modificada para verificar colisión con el borde inferior
   532                                  check_bottom_collision:
   533 000002DE 55                          push rbp
   534 000002DF 4889E5                      mov rbp, rsp
   535                                      
   536                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   537 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   538 000002E9 4883F81E                    cmp rax, row_cells - 2
   539 000002ED 7505                        jne .no_collision
   540                                      
   541                                      ; Si hay colisión, perder una vida
   542 000002EF E83DFFFFFF                  call lose_life
   543                                      
   544                                      .no_collision:
   545 000002F4 5D                              pop rbp
   546 000002F5 C3                              ret
   547                                  
   548                                  ; Nueva función para game over
   549                                  game_lost:
   550                                      ; Limpiar la pantalla
   551                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   552                                      
   553                                      ; Mostrar mensaje de derrota
   554                                      section .data
   555 000018F1 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   555 000018FA 6469646F210A0D     
   556                                          lost_msg_len: equ $ - lost_msg
   557                                      section .text
   558                                      
   559                                      ; Imprimir mensaje de derrota
   560                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [F118000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   561                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [1F19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   562                                      
   563                                      ; Mostrar puntaje final
   564 00000347 488B05(56150000)            mov rax, [current_score]
   565 0000034E 48BF-                       mov rdi, number_buffer
   565 00000350 [5F15000000000000] 
   566 00000358 E8F90D0000                  call number_to_string
   567                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [5F15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   568                                      
   569                                      ; Esperar un momento antes de salir
   570 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   570 00000381 0000               
   571 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   571 0000038C 0000               
   572                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   573                                      
   574 000003A1 E9A4150000                  jmp exit
   575                                  
   576                                  
   577                                  ; Función para registrar una nueva letra en el mapa
   578                                  ; Entrada:
   579                                  ;   al - letra a registrar
   580                                  ;   r8b - posición x
   581                                  ;   r9b - posición y
   582                                  register_letter:
   583 000003A6 55                          push rbp
   584 000003A7 4889E5                      mov rbp, rsp
   585 000003AA 53                          push rbx
   586 000003AB 51                          push rcx
   587                                      
   588 000003AC 3C20                        cmp al, ' '
   589 000003AE 7438                        je .end
   590                                  
   591                                      ; Encontrar un espacio libre en el mapa
   592 000003B0 4831C9                      xor rcx, rcx
   593 000003B3 480FB615(E4170000)          movzx rdx, byte [letters_count]
   594                                      
   595                                      .find_slot:
   596 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   597 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   598                                          
   599 000003C1 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   600 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   601 000003CD 7405                            je .found_slot
   602                                          
   603 000003CF 48FFC1                          inc rcx
   604 000003D2 EBE7                            jmp .find_slot
   605                                          
   606                                      .found_slot:
   607                                          ; Guardar la información de la letra
   608 000003D4 448803                          mov [rbx], r8b           ; x
   609 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   610 000003DB 884302                          mov [rbx + 2], al        ; letra
   611 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   612                                          
   613 000003E2 FE05(E4170000)                  inc byte [letters_count]
   614                                          
   615                                      .end:
   616 000003E8 59                              pop rcx
   617 000003E9 5B                              pop rbx
   618 000003EA 5D                              pop rbp
   619 000003EB C3                              ret
   620                                  
   621                                  ; Función para imprimir todas las letras registradas
   622                                  print_letters:
   623 000003EC 55                          push rbp
   624 000003ED 4889E5                      mov rbp, rsp
   625 000003F0 53                          push rbx
   626 000003F1 51                          push rcx
   627                                      
   628 000003F2 4831C9                      xor rcx, rcx
   629                                      
   630                                      .print_loop:
   631 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   632 000003F9 7D37                            jge .end
   633                                          
   634                                          ; Obtener puntero a la letra actual
   635 000003FB 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   636                                          
   637                                          ; Verificar si está activa
   638 00000403 807B0300                        cmp byte [rbx + 3], 0
   639 00000407 7424                            je .next_letter
   640                                          
   641                                          ; Calcular posición en el tablero
   642 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   643 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   644                                          
   645                                          ; Calcular offset en el tablero
   646 00000412 B84E000000                      mov rax, column_cells
   647 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   648 0000041B 49F7E1                          mul r9
   649 0000041E 4C01C0                          add rax, r8
   650 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   651                                          
   652                                          ; Imprimir la letra
   653 00000428 8A4302                          mov al, [rbx + 2]
   654 0000042B 8807                            mov [rdi], al
   655                                          
   656                                      .next_letter:
   657 0000042D 48FFC1                          inc rcx
   658 00000430 EBC3                            jmp .print_loop
   659                                          
   660                                      .end:
   661 00000432 59                              pop rcx
   662 00000433 5B                              pop rbx
   663 00000434 5D                              pop rbp
   664 00000435 C3                              ret
   665                                  
   666                                  ; Función para borrar una letra específica
   667                                  ; Entrada:
   668                                  ;   r8b - posición x
   669                                  ;   r9b - posición y
   670                                  remove_letter:
   671 00000436 55                          push rbp
   672 00000437 4889E5                      mov rbp, rsp
   673 0000043A 53                          push rbx
   674 0000043B 51                          push rcx
   675                                      
   676 0000043C 4831C9                      xor rcx, rcx
   677                                      
   678                                      .find_loop:
   679 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   680 00000443 7D2E                            jge .end
   681                                          
   682 00000445 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   683                                          
   684                                          ; Verificar si está activa y coincide la posición
   685 0000044D 807B0300                        cmp byte [rbx + 3], 0
   686 00000451 741B                            je .next_letter
   687                                          
   688 00000453 8A03                            mov al, [rbx]
   689 00000455 4438C0                          cmp al, r8b
   690 00000458 7514                            jne .next_letter
   691                                          
   692 0000045A 8A4301                          mov al, [rbx + 1]
   693 0000045D 4438C8                          cmp al, r9b
   694 00000460 750C                            jne .next_letter
   695                                          
   696                                          ; Encontrada la letra, desactivarla
   697 00000462 C6430300                        mov byte [rbx + 3], 0
   698 00000466 FE0D(E4170000)                  dec byte [letters_count]
   699 0000046C EB05                            jmp .end
   700                                          
   701                                      .next_letter:
   702 0000046E 48FFC1                          inc rcx
   703 00000471 EBCC                            jmp .find_loop
   704                                          
   705                                      .end:
   706 00000473 59                              pop rcx
   707 00000474 5B                              pop rbx
   708 00000475 5D                              pop rbp
   709 00000476 C3                              ret
   710                                  ; Función para mover las letras hacia abajo
   711                                  move_letters:
   712 00000477 55                          push rbp
   713 00000478 4889E5                      mov rbp, rsp
   714 0000047B 53                          push rbx
   715 0000047C 57                          push rdi
   716 0000047D 56                          push rsi
   717 0000047E 4150                        push r8
   718 00000480 4151                        push r9
   719 00000482 4152                        push r10
   720 00000484 4153                        push r11
   721                                  
   722 00000486 4831C9                      xor rcx, rcx
   723                                  
   724                                      .move_loop:
   725 00000489 4883F964                        cmp rcx, 100
   726 0000048D 0F8DD4010000                    jge .print_last_letter
   727                                          
   728 00000493 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   729 0000049B 807B0300                        cmp byte [rbx + 3], 0
   730 0000049F 0F84BA010000                    je .next_letter
   731                                  
   732 000004A5 4C0FB603                        movzx r8, byte [rbx]
   733 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   734                                  
   735 000004AE B84E000000                      mov rax, column_cells
   736 000004B3 4883C002                        add rax, 2
   737 000004B7 49F7E1                          mul r9
   738 000004BA 4C01C0                          add rax, r8
   739 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   740 000004C4 C60720                          mov byte [rdi], ' '
   741                                  
   742 000004C7 FE4301                          inc byte [rbx + 1]
   743 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   744                                  
   745 000004CF 4983F91F                        cmp r9, row_cells - 1
   746 000004D3 7C09                            jl .check_pallet_collision
   747                                  
   748 000004D5 C6430300                        mov byte [rbx + 3], 0
   749 000004D9 E981010000                      jmp .next_letter
   750                                  
   751                                          .check_pallet_collision:
   752 000004DE B84E000000                          mov rax, column_cells
   753 000004E3 4883C002                            add rax, 2
   754 000004E7 49F7E1                              mul r9
   755 000004EA 4C01C0                              add rax, r8
   756 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   757                                  
   758 000004F4 8A07                                mov al, [rdi]
   759 000004F6 3C20                                cmp al, ' '
   760 000004F8 0F8461010000                        je .next_letter
   761 000004FE 3C3D                                cmp al, char_equal
   762 00000500 740A                                je .capture_letter
   763                                  
   764 00000502 8A4302                              mov al, [rbx + 2]
   765 00000505 8807                                mov [rdi], al
   766 00000507 E953010000                          jmp .next_letter
   767                                  
   768                                          .capture_letter:
   769                                              ; Obtener la nueva letra
   770 0000050C 8A4302                              mov al, [rbx + 2]
   771                                              
   772                                              ; Comparar con la última letra
   773 0000050F 3A05(E5170000)                      cmp al, [last_letter]
   774 00000515 7407                                je .same_letter
   775                                              
   776                                              ; Es una letra diferente, resetear el procesamiento
   777 00000517 C605(F9170000)00                    mov byte [current_power_processed], 0
   778                                              
   779                                              .same_letter:
   780                                              ; Guardar la nueva letra
   781 0000051E 8805(E5170000)                      mov [last_letter], al
   782                                              
   783                                              ; Verificar si es 'E' para extender la paleta
   784 00000524 3C45                                cmp al, 'E'
   785 00000526 7448                                je .extend_pallet
   786                                              
   787                                              ; Verificar si es 'P' para añadir vida
   788 00000528 3C50                                cmp al, 'P'
   789 0000052A 7470                                je .check_add_life
   790                                  
   791 0000052C 3C53                                cmp al, 'S'
   792 0000052E 0F84AC000000                        je .slow_ball
   793                                  
   794 00000534 3C43                                cmp al, 'C'
   795 00000536 0F84CD000000                        je .activate_catch
   796                                              
   797 0000053C 3C4C                                cmp al, 'L'
   798 0000053E 0F84EE000000                        je .activate_laser
   799                                  
   800                                              ; Si no es ningún power-up, restaurar tamaño normal
   801 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   802 0000054B 488905(47140000)                    mov [pallet_size], rax
   803 00000552 48C705(FB170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 0000055A 000000             
   804 0000055D C605(13180000)00                    mov byte [catch_power_active], 0
   805 00000564 C605(1E180000)00                    mov byte [laser_power_active], 0
   806 0000056B E9EB000000                          jmp .finish_capture
   807                                  
   808                                              .extend_pallet:
   809 00000570 C605(1E180000)00                        mov byte [laser_power_active], 0
   810 00000577 C605(13180000)00                        mov byte [catch_power_active], 0
   811 0000057E 48C705(FB170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   811 00000586 000000             
   812 00000589 488B05(57140000)                        mov rax, [extended_pallet_size]
   813 00000590 488905(47140000)                        mov [pallet_size], rax
   814 00000597 E9BF000000                              jmp .finish_capture
   815                                  
   816                                              .check_add_life:
   817 0000059C C605(1E180000)00                        mov byte [laser_power_active], 0
   818 000005A3 C605(13180000)00                        mov byte [catch_power_active], 0
   819 000005AA 488B05(4F140000)                        mov rax, [default_pallet_size]
   820 000005B1 488905(47140000)                        mov [pallet_size], rax
   821 000005B8 48C705(FB170000)01-                     mov qword [ball_speed], 1 
   821 000005C0 000000             
   822                                                  ; Verificar si ya procesamos este power-up
   823 000005C3 803D(F9170000)00                        cmp byte [current_power_processed], 0
   824 000005CA 0F858B000000                            jne .finish_capture
   825                                                  
   826                                                  ; Preservar registros importantes
   827 000005D0 51                                      push rcx
   828 000005D1 53                                      push rbx
   829                                                  
   830                                                  ; Marcar como procesado
   831 000005D2 C605(F9170000)01                        mov byte [current_power_processed], 1
   832                                                  
   833                                                  ; Añadir una vida
   834 000005D9 E87B030000                              call add_life
   835                                                  
   836                                                  ; Restaurar registros
   837 000005DE 5B                                      pop rbx
   838 000005DF 59                                      pop rcx
   839                                                  
   840                                              .slow_ball:
   841 000005E0 C605(1E180000)00                        mov byte [laser_power_active], 0
   842 000005E7 C605(13180000)00                        mov byte [catch_power_active], 0                
   843 000005EE 488B05(4F140000)                        mov rax, [default_pallet_size]
   844 000005F5 488905(47140000)                        mov [pallet_size], rax
   845 000005FC 48C705(FB170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   845 00000604 000000             
   846 00000607 EB52                                    jmp .finish_capture
   847                                  
   848                                              .activate_catch:
   849 00000609 C605(1E180000)00                        mov byte [laser_power_active], 0
   850 00000610 488B05(4F140000)                        mov rax, [default_pallet_size]
   851 00000617 488905(47140000)                        mov [pallet_size], rax
   852 0000061E 48C705(FB170000)01-                     mov qword [ball_speed], 1
   852 00000626 000000             
   853 00000629 C605(13180000)01                        mov byte [catch_power_active], 1
   854 00000630 EB29                                    jmp .finish_capture
   855                                  
   856                                              .activate_laser:
   857 00000632 C605(13180000)00                        mov byte [catch_power_active], 0
   858 00000639 488B05(4F140000)                        mov rax, [default_pallet_size]
   859 00000640 488905(47140000)                        mov [pallet_size], rax
   860 00000647 48C705(FB170000)01-                     mov qword [ball_speed], 1
   860 0000064F 000000             
   861 00000652 C605(1E180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   862 00000659 EB00                                    jmp .finish_capture
   863                                  
   864                                              .finish_capture:
   865 0000065B C6430300                                mov byte [rbx + 3], 0
   866                                  
   867                                          .next_letter:
   868 0000065F 48FFC1                              inc rcx
   869 00000662 E922FEFFFF                          jmp .move_loop
   870                                  
   871                                      .print_last_letter:
   872                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [E617000000000000]  <1>
    85 0000067B BA10000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   873 00000682 8A05(E5170000)                  mov al, [last_letter]
   874 00000688 8805(F5170000)                  mov [last_letter_msg + 15], al
   875                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000068E B801000000          <1>  mov eax, sys_write
    83 00000693 BF01000000          <1>  mov edi, 1
    84 00000698 48BE-               <1>  mov rsi, %1
    84 0000069A [F617000000000000]  <1>
    85 000006A2 BA03000000          <1>  mov edx, %2
    86 000006A7 0F05                <1>  syscall
   876                                  
   877                                      .end:
   878 000006A9 415B                            pop r11
   879 000006AB 415A                            pop r10
   880 000006AD 4159                            pop r9
   881 000006AF 4158                            pop r8
   882 000006B1 5E                              pop rsi
   883 000006B2 5F                              pop rdi
   884 000006B3 5B                              pop rbx
   885 000006B4 5D                              pop rbp
   886 000006B5 C3                              ret
   887                                  
   888                                  
   889                                  clear_lasers:
   890 000006B6 55                          push rbp
   891 000006B7 4889E5                      mov  rbp, rsp
   892                                  
   893                                      ; Recorrer el array de láseres
   894 000006BA 4831C9                      xor rcx, rcx                ; Índice del láser
   895 000006BD 480FB61D(20180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   896                                  
   897                                      .clear_loop:
   898 000006C5 4839D9                          cmp rcx, rbx
   899 000006C8 7D2F                            jge .done                ; Salir si no quedan láseres
   900                                  
   901                                          ; Obtener posición del láser actual
   902 000006CA 488DB409[21180000]              lea rsi, [lasers + rcx * 2]
   903 000006D2 4C0FB606                        movzx r8, byte [rsi]     ; X
   904 000006D6 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
   905                                  
   906                                          ; Calcular posición en el tablero
   907 000006DB B84E000000                      mov rax, column_cells
   908 000006E0 4883C002                        add rax, 2
   909 000006E4 49F7E1                          mul r9
   910 000006E7 4C01C0                          add rax, r8
   911 000006EA 488DB8[000A0000]                lea rdi, [board + rax]
   912                                  
   913                                          ; Borrar el láser visualmente
   914 000006F1 C60720                          mov byte [rdi], ' '
   915                                  
   916                                          ; Pasar al siguiente láser
   917 000006F4 48FFC1                          inc rcx
   918 000006F7 EBCC                            jmp .clear_loop
   919                                  
   920                                      .done:
   921                                          ; Resetear contador de láseres
   922 000006F9 C605(20180000)00                mov byte [laser_count], 0
   923                                  
   924 00000700 5D                              pop rbp
   925 00000701 C3                              ret
   926                                  
   927                                  
   928                                  ; Nueva función para actualizar los láseres
   929                                  update_lasers:
   930 00000702 55                          push rbp
   931 00000703 4889E5                      mov rbp, rsp
   932                                      
   933                                      ; Verificar si el poder láser está activo
   934 00000706 803D(1E180000)00            cmp byte [laser_power_active], 0
   935 0000070D 741A                        je .end
   936                                      
   937                                      ; Verificar si se presionó la tecla de espacio
   938 0000070F 803D(1D180000)20            cmp byte [last_key], ' '
   939 00000716 750C                        jne .skip_shooting
   940                                      
   941                                      ; Disparar nuevos láseres
   942 00000718 E80E000000                  call shoot_lasers
   943 0000071D C605(1D180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   944                                      
   945                                      .skip_shooting:
   946                                      ; Mover los láseres existentes
   947 00000724 E89C000000                  call move_lasers
   948                                      
   949                                      .end:
   950 00000729 5D                              pop rbp
   951 0000072A C3                              ret
   952                                  
   953                                  shoot_lasers:
   954 0000072B 55                          push rbp
   955 0000072C 4889E5                      mov rbp, rsp
   956 0000072F 53                          push rbx
   957                                      
   958                                      ; Verificar si hay espacio para más láseres
   959 00000730 480FB605(20180000)          movzx rax, byte [laser_count]
   960 00000738 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   961 0000073C 0F8D80000000                jge .end
   962                                      
   963                                      ; Obtener posición de la paleta
   964 00000742 4C8B05(3F140000)            mov r8, [pallet_position]
   965 00000749 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   966                                      
   967                                      ; Calcular coordenadas x,y
   968 00000750 4C89C0                      mov rax, r8
   969 00000753 41B94E000000                mov r9, column_cells
   970 00000759 4983C102                    add r9, 2                     ; Ancho total de línea
   971 0000075D 4831D2                      xor rdx, rdx
   972 00000760 49F7F1                      div r9                        ; rax = y, rdx = x
   973                                      
   974                                      ; Guardar coordenadas
   975 00000763 4989C2                      mov r10, rax                  ; Y en r10
   976 00000766 4989D3                      mov r11, rdx                  ; X en r11
   977                                      
   978                                      ; Validar coordenadas
   979 00000769 4983FA00                    cmp r10, 0
   980 0000076D 7C53                        jl .end
   981 0000076F 4983FA20                    cmp r10, row_cells
   982 00000773 7D4D                        jge .end
   983 00000775 4983FB00                    cmp r11, 0
   984 00000779 7C47                        jl .end
   985 0000077B 4983FB4E                    cmp r11, column_cells
   986 0000077F 7D41                        jge .end
   987                                      
   988                                      ; Calcular índice para el primer láser
   989 00000781 480FB61D(20180000)          movzx rbx, byte [laser_count]
   990 00000789 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   991                                      
   992                                      ; Primer láser (izquierda)
   993 0000078D 488DBB[21180000]            lea rdi, [lasers + rbx]
   994 00000794 44881F                      mov [rdi], r11b              ; X
   995 00000797 4488D0                      mov al, r10b
   996 0000079A FEC8                        dec al                       ; Y - 1
   997 0000079C 884701                      mov [rdi + 1], al           ; Y
   998                                      
   999                                      ; Segundo láser (derecha)
  1000 0000079F 4488D8                      mov al, r11b
  1001 000007A2 0205(47140000)              add al, byte [pallet_size]
  1002 000007A8 FEC8                        dec al                       ; Ajustar para el último carácter
  1003 000007AA 488DBB[23180000]            lea rdi, [lasers + rbx + 2]
  1004 000007B1 8807                        mov [rdi], al               ; X
  1005 000007B3 4488D0                      mov al, r10b
  1006 000007B6 FEC8                        dec al                      ; Y - 1
  1007 000007B8 884701                      mov [rdi + 1], al          ; Y
  1008                                      
  1009                                      ; Incrementar contador de láseres
  1010 000007BB 8005(20180000)02            add byte [laser_count], 2
  1011                                      
  1012                                      
  1013                                      .end:
  1014 000007C2 5B                              pop rbx
  1015 000007C3 5D                              pop rbp
  1016 000007C4 C3                              ret
  1017                                  
  1018                                  ; Función corregida para mover láseres
  1019                                  ; Función corregida para mover láseres
  1020                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1021                                  
  1022                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1023                                  ; ============================================================
  1024                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1025                                  ; ============================================================
  1026                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1027                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1028                                  ; ============================================================
  1029                                  move_lasers:
  1030 000007C5 55                          push rbp
  1031 000007C6 4889E5                      mov  rbp, rsp
  1032 000007C9 53                          push rbx
  1033 000007CA 57                          push rdi
  1034 000007CB 56                          push rsi
  1035 000007CC 4154                        push r12
  1036 000007CE 4155                        push r13
  1037 000007D0 4156                        push r14
  1038 000007D2 4157                        push r15
  1039                                  
  1040                                      ; 1) Tomamos la cantidad de láseres
  1041 000007D4 480FB60D(20180000)          movzx rcx, byte [laser_count]
  1042 000007DC 4885C9                      test rcx, rcx
  1043 000007DF 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1044                                  
  1045                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1046 000007E5 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1047                                  
  1048                                  .loop_lasers:
  1049                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1050 000007E8 488DB409[21180000]          lea rsi, [lasers + rcx*2]
  1051                                  
  1052                                      ; 2) Cargar x,y actuales del láser
  1053 000007F0 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1054 000007F4 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1055                                  
  1056                                      ; 3) Borrar el láser de su posición actual en pantalla
  1057                                      ;    (por si en el ciclo anterior se había dibujado)
  1058 000007F9 B84E000000                  mov rax, column_cells
  1059 000007FE 4883C002                    add rax, 2
  1060 00000802 49F7E1                      mul r9
  1061 00000805 4C01C0                      add rax, r8
  1062 00000808 488DB8[000A0000]            lea rdi, [board + rax]
  1063 0000080F C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1064                                  
  1065                                      ; 4) Mover el láser hacia arriba (y - 1)
  1066 00000812 49FFC9                      dec r9
  1067                                  
  1068                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1069 00000815 4983F901                    cmp r9, 1
  1070 00000819 7C57                        jl .delete_laser
  1071                                  
  1072                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1073 0000081B 44884E01                    mov byte [rsi + 1], r9b
  1074                                  
  1075                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1076                                      ;    - Primero colisión con bloques
  1077                                      ; ---------------------------------------------------------
  1078                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1079 0000081F B84E000000                  mov rax, column_cells
  1080 00000824 4883C002                    add rax, 2
  1081 00000828 49F7E1                      mul r9
  1082 0000082B 4C01C0                      add rax, r8
  1083 0000082E 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1084                                  
  1085                                      ; Revisar si hay bloque
  1086 00000835 51                          push rcx
  1087 00000836 56                          push rsi
  1088 00000837 57                          push rdi
  1089 00000838 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1090 0000083B E86E0A0000                  call check_block_collision
  1091 00000840 5F                          pop rdi
  1092 00000841 5E                          pop rsi
  1093 00000842 59                          pop rcx
  1094                                  
  1095 00000843 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1096 00000846 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1097                                  
  1098                                      ;    - Luego colisión con enemigos
  1099                                      ; ---------------------------------------------------------
  1100 00000848 51                          push rcx
  1101 00000849 56                          push rsi
  1102 0000084A 57                          push rdi
  1103                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1104                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1105                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1106                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1107                                      ;
  1108                                      ; Hacemos algo como:
  1109 0000084B 4989FA                      mov r10, rdi
  1110 0000084E E85A000000                  call check_laser_enemy_collision
  1111 00000853 5F                          pop rdi
  1112 00000854 5E                          pop rsi
  1113 00000855 59                          pop rcx
  1114                                  
  1115 00000856 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1116 00000859 7517                        jnz .delete_laser
  1117                                  
  1118                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1119 0000085B 8A05(1F180000)              mov al, [laser_symbol]
  1120 00000861 8807                        mov [rdi], al
  1121                                  
  1122                                  .next_laser:
  1123                                      ; Pasamos al láser anterior en el array
  1124 00000863 48FFC9                      dec rcx
  1125 00000866 4883F9FF                    cmp rcx, -1
  1126 0000086A 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1127 00000870 EB2E                        jmp .fin
  1128                                  
  1129                                  ; -----------------------------------------------------------------
  1130                                  ; Subrutina interna: .delete_laser
  1131                                  ; -----------------------------------------------------------------
  1132                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1133                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1134                                  .delete_laser:
  1135 00000872 4C0FB625(20180000)          movzx r12, byte [laser_count]
  1136 0000087A 49FFCC                      dec r12                    ; r12 = índice del último láser
  1137 0000087D 4939CC                      cmp r12, rcx
  1138 00000880 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1139                                  
  1140                                      ; Copiamos el último láser a la posición actual
  1141 00000882 488DBC09[21180000]          lea rdi, [lasers + rcx*2]
  1142 0000088A 4B8DB424[21180000]          lea rsi, [lasers + r12*2]
  1143 00000892 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1144 00000895 668907                      mov [rdi], ax             ; copiamos X,Y
  1145                                  
  1146                                  .just_decrement:
  1147 00000898 FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1148 0000089E EBC3                        jmp .next_laser
  1149                                  
  1150                                  .fin:
  1151 000008A0 415F                        pop r15
  1152 000008A2 415E                        pop r14
  1153 000008A4 415D                        pop r13
  1154 000008A6 415C                        pop r12
  1155 000008A8 5E                          pop rsi
  1156 000008A9 5F                          pop rdi
  1157 000008AA 5B                          pop rbx
  1158 000008AB 5D                          pop rbp
  1159 000008AC C3                          ret
  1160                                  
  1161                                  
  1162                                  ; Nueva función para verificar colisión entre láser y enemigos
  1163                                  ; ==========================================================
  1164                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1165                                  ; ==========================================================
  1166                                  check_laser_enemy_collision:
  1167 000008AD 55                          push rbp
  1168 000008AE 4889E5                      mov  rbp, rsp
  1169                                      
  1170 000008B1 4D31ED                      xor r13, r13            ; Índice del enemigo
  1171 000008B4 4831C0                      xor rax, rax            ; 0 = no colisión
  1172                                  
  1173                                  .loop_enemies:
  1174 000008B7 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1175 000008BB 7D64                        jge .end
  1176                                  
  1177                                      ; r13 * 3 => offset del enemigo i
  1178 000008BD 4C89E9                      mov rcx, r13
  1179 000008C0 486BC903                    imul rcx, 3
  1180 000008C4 488DB1[78150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1181                                  
  1182                                      ; Verificar si está activo
  1183 000008CB 807E0201                    cmp byte [rsi+2], 1
  1184 000008CF 754B                        jne .next_enemy
  1185                                  
  1186                                      ; Cargar posición X/Y del enemigo
  1187 000008D1 4C0FB636                    movzx r14, byte [rsi]      ; X
  1188 000008D5 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1189                                  
  1190                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1191 000008DA 4D39F0                      cmp r8, r14
  1192 000008DD 753D                        jne .next_enemy
  1193 000008DF 4D39F9                      cmp r9, r15
  1194 000008E2 7538                        jne .next_enemy
  1195                                  
  1196                                      ; ==== Colisión detectada con láser ====
  1197                                  
  1198                                      ; 1) Desactivar enemigo
  1199 000008E4 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1200                                  
  1201                                      ; 2) Sumar puntos
  1202 000008E8 488B05(97150000)            mov rax, [enemy_points]
  1203 000008EF 480105(56150000)            add [current_score], rax
  1204                                  
  1205                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1206                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1207 000008F6 4983FF1E                    cmp r15, row_cells - 2
  1208 000008FA 7419                        je .skip_erase
  1209                                  
  1210                                      ; Borrar visualmente del board
  1211 000008FC B84E000000                  mov rax, column_cells
  1212 00000901 4883C002                    add rax, 2
  1213 00000905 49F7E7                      mul r15
  1214 00000908 4C01F0                      add rax, r14
  1215 0000090B 488DB8[000A0000]            lea rdi, [board + rax]
  1216 00000912 C60720                      mov byte [rdi], ' '
  1217                                  
  1218                                  .skip_erase:
  1219                                  
  1220                                      ; 4) Devolver rax=1 => colisión con enemigo
  1221 00000915 B801000000                  mov rax, 1
  1222 0000091A EB05                        jmp .end
  1223                                  
  1224                                  .next_enemy:
  1225 0000091C 49FFC5                      inc r13
  1226 0000091F EB96                        jmp .loop_enemies
  1227                                  
  1228                                  .end:
  1229 00000921 5D                          pop rbp
  1230 00000922 C3                          ret
  1231                                  
  1232                                  
  1233                                  ; Función auxiliar para eliminar un láser específico
  1234                                  remove_laser:
  1235 00000923 55                          push rbp
  1236 00000924 4889E5                      mov rbp, rsp
  1237                                  
  1238                                      ; Borrar el láser del tablero
  1239 00000927 41C60220                    mov byte [r10], ' '
  1240                                  
  1241                                      ; Mover el último láser a esta posición si no es el último
  1242 0000092B 480FB605(20180000)          movzx rax, byte [laser_count]
  1243 00000933 48FFC8                      dec rax                    ; Índice del último láser
  1244 00000936 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1245 00000939 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1246                                  
  1247                                      ; Copiar último láser a la posición actual
  1248 0000093B 4B8DBC24[21180000]          lea rdi, [lasers + r12*2]
  1249 00000943 488DB400[21180000]          lea rsi, [lasers + rax*2]
  1250 0000094B 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1251 0000094E 668917                      mov [rdi], dx
  1252                                  
  1253                                  .just_decrease:
  1254 00000951 FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1255                                  
  1256 00000957 5D                          pop rbp
  1257 00000958 C3                          ret
  1258                                  
  1259                                  add_life:
  1260 00000959 55                          push rbp
  1261 0000095A 4889E5                      mov rbp, rsp
  1262 0000095D 53                          push rbx
  1263 0000095E 51                          push rcx
  1264 0000095F 57                          push rdi
  1265 00000960 56                          push rsi
  1266 00000961 4150                        push r8
  1267 00000963 4151                        push r9
  1268                                      
  1269                                      ; Verificar si ya tenemos el máximo de vidas
  1270 00000965 480FB605(53160000)          movzx rax, byte [current_lives]
  1271 0000096D 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1272 00000971 7D2C                        jge .end
  1273                                      
  1274                                      ; Incrementar el contador de vidas
  1275 00000973 FE05(53160000)              inc byte [current_lives]
  1276                                      
  1277                                      ; Encontrar la siguiente vida inactiva
  1278 00000979 4831C9                      xor rcx, rcx
  1279                                      
  1280                                      .find_inactive:
  1281 0000097C 4883F907                        cmp rcx, lives_count
  1282 00000980 7D1D                            jge .end
  1283                                          
  1284                                          ; Calcular offset de la vida actual
  1285 00000982 4889C8                          mov rax, rcx
  1286 00000985 486BC003                        imul rax, 3
  1287 00000989 488DB0[3D160000]                lea rsi, [lives_data + rax]
  1288                                          
  1289                                          ; Verificar si está inactiva
  1290 00000990 807E0200                        cmp byte [rsi + 2], 0
  1291 00000994 7405                            je .activate_life
  1292                                          
  1293 00000996 48FFC1                          inc rcx
  1294 00000999 EBE1                            jmp .find_inactive
  1295                                          
  1296                                      .activate_life:
  1297                                          ; Activar la vida
  1298 0000099B C6460201                        mov byte [rsi + 2], 1
  1299                                          
  1300                                      .end:
  1301 0000099F 4159                            pop r9
  1302 000009A1 4158                            pop r8
  1303 000009A3 5E                              pop rsi
  1304 000009A4 5F                              pop rdi
  1305 000009A5 59                              pop rcx
  1306 000009A6 5B                              pop rbx
  1307 000009A7 5D                              pop rbp
  1308 000009A8 C3                              ret
  1309                                  
  1310                                  
  1311                                  print_ball:
  1312 000009A9 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1313 000009B0 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1314 000009B7 4981C0[000A0000]        	add r8, board
  1315                                  
  1316 000009BE 4C89C9                  	mov rcx, r9
  1317 000009C1 B850000000              	mov rax, column_cells + 2
  1318 000009C6 48F7E9                  	imul rcx
  1319                                  	
  1320 000009C9 4901C0                  	add r8, rax
  1321 000009CC 41C6004F                	mov byte [r8], char_O
  1322 000009D0 C3                      	ret
  1323                                  
  1324                                  	
  1325                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1326                                  	
  1327                                  print_pallet:
  1328                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1329 000009D1 4C8B05(3F140000)            mov r8, [pallet_position]
  1330 000009D8 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1331                                      .clear_pallet:
  1332 000009DF 41C60020                        mov byte [r8], char_space
  1333 000009E3 49FFC0                          inc r8
  1334 000009E6 48FFC9                          dec rcx
  1335 000009E9 75F4                            jnz .clear_pallet
  1336                                  
  1337                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1338 000009EB 4C8B05(3F140000)            mov r8, [pallet_position]
  1339 000009F2 488B0D(47140000)            mov rcx, [pallet_size]
  1340                                      .write_pallet:
  1341 000009F9 41C6003D                        mov byte [r8], char_equal
  1342 000009FD 49FFC0                          inc r8
  1343 00000A00 48FFC9                          dec rcx
  1344 00000A03 75F4                            jnz .write_pallet
  1345                                  
  1346 00000A05 C3                          ret
  1347                                  
  1348                                  move_pallet:
  1349                                      
  1350 00000A06 803D(7F140000)00            cmp byte [ball_moving], 0
  1351 00000A0D 7507                        jne .continue_movement
  1352 00000A0F C605(7F140000)01            mov byte [ball_moving], 1
  1353                                  
  1354                                      .continue_movement:
  1355 00000A16 4883FFFF                        cmp rdi, left_direction
  1356 00000A1A 7531                            jne .move_right
  1357                                  
  1358                                          .move_left:
  1359                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1360 00000A1C 4C8B05(3F140000)                    mov r8, [pallet_position]
  1361 00000A23 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1362 00000A26 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1363 00000A29 3C58                                cmp al, 'X'        ; Comparar si es una X
  1364 00000A2B 744E                                je .end            ; Si es X, no mover
  1365                                              
  1366 00000A2D 4C8B05(3F140000)                    mov r8, [pallet_position]
  1367 00000A34 4C8B0D(47140000)                    mov r9, [pallet_size]
  1368 00000A3B 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1369 00000A41 49FFC8                              dec r8
  1370 00000A44 4C8905(3F140000)                    mov [pallet_position], r8
  1371 00000A4B EB2E                                jmp .end
  1372                                              
  1373                                          .move_right:
  1374                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1375 00000A4D 4C8B05(3F140000)                    mov r8, [pallet_position]
  1376 00000A54 4C8B0D(47140000)                    mov r9, [pallet_size]
  1377 00000A5B 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1378 00000A5E 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1379 00000A62 3C58                                cmp al, 'X'        ; Comparar si es una X
  1380 00000A64 7415                                je .end            ; Si es X, no mover
  1381                                              
  1382 00000A66 4C8B05(3F140000)                    mov r8, [pallet_position]
  1383 00000A6D 41C60020                            mov byte [r8], char_space
  1384 00000A71 49FFC0                              inc r8
  1385 00000A74 4C8905(3F140000)                    mov [pallet_position], r8
  1386                                          .end:
  1387 00000A7B C3                                  ret
  1388                                  
  1389                                  
  1390                                  
  1391                                              
  1392                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1393                                  update_caught_ball_position:
  1394 00000A7C 55                          push rbp
  1395 00000A7D 4889E5                      mov rbp, rsp
  1396                                      
  1397                                      ; Calcular la nueva posición de la bola basada en la paleta
  1398 00000A80 4C8B05(3F140000)            mov r8, [pallet_position]
  1399 00000A87 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1400 00000A8E B850000000                  mov rax, column_cells + 2
  1401 00000A93 4831D2                      xor rdx, rdx
  1402 00000A96 48F7F0                      div rax                ; División para obtener X,Y
  1403                                      
  1404                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1405 00000A99 4989C1                      mov r9, rax            ; Y de la paleta
  1406 00000A9C 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1407                                      
  1408                                      ; Añadir el offset guardado a la posición X
  1409 00000A9F 4889D0                      mov rax, rdx
  1410 00000AA2 480305(15180000)            add rax, [ball_catch_offset]
  1411 00000AA9 488905(5F140000)            mov [ball_x_pos], rax
  1412 00000AB0 4C890D(67140000)            mov [ball_y_pos], r9
  1413                                      
  1414 00000AB7 5D                          pop rbp
  1415 00000AB8 C3                          ret
  1416                                  move_ball:
  1417                                  
  1418 00000AB9 803D(14180000)01            cmp byte [ball_caught], 1
  1419 00000AC0 0F849D000000                je .move_with_pallet
  1420                                  
  1421 00000AC6 803D(7F140000)00            cmp byte [ball_moving], 0
  1422 00000ACD 0F84B8010000                je .end
  1423                                  
  1424                                      ; Incrementar contador de velocidad
  1425 00000AD3 48FF05(0B180000)            inc qword [speed_counter]
  1426                                      
  1427                                      ; Verificar si debemos mover la bola en este ciclo
  1428 00000ADA 488B05(0B180000)            mov rax, [speed_counter]
  1429 00000AE1 483B05(FB170000)            cmp rax, [ball_speed]
  1430 00000AE8 0F8C9D010000                jl .end
  1431                                      
  1432                                      ; Resetear contador de velocidad
  1433 00000AEE 48C705(0B180000)00-         mov qword [speed_counter], 0
  1433 00000AF6 000000             
  1434                                  
  1435                                      ; Borrar la posición actual de la bola
  1436 00000AF9 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1437 00000B00 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1438 00000B07 4981C0[000A0000]            add r8, board
  1439 00000B0E 4C89C9                      mov rcx, r9
  1440 00000B11 B850000000                  mov rax, column_cells + 2
  1441 00000B16 48F7E9                      imul rcx
  1442 00000B19 4901C0                      add r8, rax
  1443 00000B1C 41C60020                    mov byte [r8], char_space
  1444                                  
  1445                                      ; Calcular siguiente posición X
  1446 00000B20 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1447 00000B27 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1448 00000B2E 488B05(6F140000)            mov rax, [ball_direction_x]
  1449 00000B35 4901C0                      add r8, rax               ; Nueva posición X
  1450                                  
  1451                                      ; Calcular la dirección de memoria para la siguiente posición
  1452 00000B38 4D89C2                      mov r10, r8
  1453 00000B3B 4981C2[000A0000]            add r10, board
  1454 00000B42 4C89C9                      mov rcx, r9
  1455 00000B45 B850000000                  mov rax, column_cells + 2
  1456 00000B4A 48F7E9                      imul rcx
  1457 00000B4D 4901C2                      add r10, rax
  1458                                  
  1459                                      ; Verificar si hay una X en la siguiente posición X
  1460 00000B50 418A02                      mov al, [r10]
  1461 00000B53 3C58                        cmp al, 'X'
  1462 00000B55 7565                        jne .check_block_x
  1463 00000B57 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1464 00000B5E E928010000                  jmp .end
  1465                                  
  1466                                      .move_with_pallet:
  1467                                          ; Borrar la posición actual de la bola
  1468 00000B63 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1469 00000B6A 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1470 00000B71 4D89C2                          mov r10, r8
  1471 00000B74 4981C2[000A0000]                add r10, board
  1472 00000B7B 4C89C9                          mov rcx, r9
  1473 00000B7E B850000000                      mov rax, column_cells + 2
  1474 00000B83 48F7E9                          imul rcx
  1475 00000B86 4901C2                          add r10, rax
  1476 00000B89 41C60220                        mov byte [r10], char_space
  1477                                  
  1478                                          ; Actualizar posición X basada en la paleta
  1479 00000B8D 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1480 00000B94 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1481 00000B9B 4C0305(15180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1482 00000BA2 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1483                                  
  1484                                          ; Mantener la bola una posición arriba de la paleta
  1485 00000BA9 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1486 00000BB0 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1487                                  
  1488 00000BB7 E9CF000000                      jmp .end
  1489                                  
  1490                                  
  1491                                      .check_block_x:
  1492                                          ; Verificar colisión con bloques en X
  1493 00000BBC 4150                            push r8     ; Guardar registros que usa check_block_collision
  1494 00000BBE 4151                            push r9
  1495 00000BC0 4152                            push r10
  1496 00000BC2 E8E7060000                      call check_block_collision
  1497 00000BC7 415A                            pop r10
  1498 00000BC9 4159                            pop r9
  1499 00000BCB 4158                            pop r8
  1500 00000BCD 4885C0                          test rax, rax
  1501 00000BD0 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1502 00000BD2 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1503 00000BD9 E9AD000000                      jmp .end
  1504                                  
  1505                                      .check_paddle_x:
  1506                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1507 00000BDE 41803A3D                        cmp byte [r10], char_equal
  1508 00000BE2 750C                            jne .check_y_movement
  1509 00000BE4 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1510 00000BEB E99B000000                      jmp .end
  1511                                  
  1512                                      .check_y_movement:
  1513                                          ; Calcular siguiente posición Y
  1514 00000BF0 488B05(77140000)                mov rax, [ball_direction_y]
  1515 00000BF7 4901C1                          add r9, rax                  ; Nueva posición Y
  1516                                  
  1517                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1518 00000BFA 4D89C2                          mov r10, r8
  1519 00000BFD 4981C2[000A0000]                add r10, board
  1520 00000C04 4C89C9                          mov rcx, r9
  1521 00000C07 B850000000                      mov rax, column_cells + 2
  1522 00000C0C 48F7E9                          imul rcx
  1523 00000C0F 4901C2                          add r10, rax
  1524                                  
  1525                                          ; Verificar si hay una X en la siguiente posición Y
  1526 00000C12 418A02                          mov al, [r10]
  1527 00000C15 3C58                            cmp al, 'X'
  1528 00000C17 7509                            jne .check_block_y
  1529 00000C19 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1530 00000C20 EB69                            jmp .end
  1531                                  
  1532                                      .check_block_y:
  1533                                          ; Verificar colisión con bloques en Y
  1534 00000C22 4150                            push r8     ; Guardar registros que usa check_block_collision
  1535 00000C24 4151                            push r9
  1536 00000C26 4152                            push r10
  1537 00000C28 E881060000                      call check_block_collision
  1538 00000C2D 415A                            pop r10
  1539 00000C2F 4159                            pop r9
  1540 00000C31 4158                            pop r8
  1541 00000C33 4885C0                          test rax, rax
  1542 00000C36 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1543 00000C38 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1544 00000C3F EB4A                            jmp .end
  1545                                  
  1546                                      .check_paddle_y:
  1547                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1548 00000C41 41803A3D                        cmp byte [r10], char_equal
  1549 00000C45 7536                            jne .update_position
  1550                                  
  1551                                          ; Verificar si el poder catch está activo
  1552 00000C47 803D(13180000)01                cmp byte [catch_power_active], 1
  1553 00000C4E 7524                            jne .normal_bounce
  1554                                  
  1555                                          ; Activar el modo "atrapado"
  1556 00000C50 C605(14180000)01                mov byte [ball_caught], 1
  1557                                          
  1558                                          ; Guardar la posición X actual de la bola como offset
  1559 00000C57 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1560 00000C5E 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1561 00000C65 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1562 00000C6B 488905(15180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1563                                          
  1564 00000C72 EB17                            jmp .end
  1565                                  
  1566                                      .normal_bounce:
  1567 00000C74 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1568 00000C7B EB0E                            jmp .end
  1569                                  
  1570                                  
  1571                                      .update_position:
  1572 00000C7D 4C8905(5F140000)                mov [ball_x_pos], r8
  1573 00000C84 4C890D(67140000)                mov [ball_y_pos], r9
  1574                                  
  1575                                      .end:
  1576 00000C8B C3                              ret
  1577                                  
  1578                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1579                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1580                                  process_catch_release:
  1581 00000C8C 55                          push rbp
  1582 00000C8D 4889E5                      mov rbp, rsp
  1583                                  
  1584                                      ; Verificar si la bola está atrapada
  1585 00000C90 803D(14180000)00            cmp byte [ball_caught], 0
  1586 00000C97 7436                        je .end
  1587                                  
  1588                                      ; Verificar si el poder catch está activo
  1589 00000C99 803D(13180000)01            cmp byte [catch_power_active], 1
  1590 00000CA0 752D                        jne .end
  1591                                  
  1592                                      ; Verificar si se presionó la tecla 'c'
  1593 00000CA2 803D(1D180000)63            cmp byte [last_key], 'c'
  1594 00000CA9 7524                        jne .end
  1595                                  
  1596                                      ; Liberar la bola y asignar dirección inicial
  1597 00000CAB C605(14180000)00            mov byte [ball_caught], 0
  1598 00000CB2 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1598 00000CBA 000000             
  1599 00000CBD 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1599 00000CC5 FFFFFF             
  1600                                  
  1601                                      ; Limpiar la tecla procesada
  1602 00000CC8 C605(1D180000)00            mov byte [last_key], 0
  1603                                  
  1604                                      .end:
  1605 00000CCF 5D                              pop rbp
  1606 00000CD0 C3                              ret
  1607                                  
  1608                                  
  1609                                  display_level_number:
  1610 00000CD1 55                          push rbp
  1611 00000CD2 4889E5                      mov rbp, rsp
  1612                                      
  1613                                      ; Limpiar la pantalla primero
  1614                                      print clear, clear_length
    82 00000CD5 B801000000          <1>  mov eax, sys_write
    83 00000CDA BF01000000          <1>  mov edi, 1
    84 00000CDF 48BE-               <1>  mov rsi, %1
    84 00000CE1 [1000000000000000]  <1>
    85 00000CE9 BA07000000          <1>  mov edx, %2
    86 00000CEE 0F05                <1>  syscall
  1615                                      
  1616                                      ; Calcular la posición central para el mensaje
  1617                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1618 00000CF0 B84E000000                  mov rax, column_cells
  1619 00000CF5 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1620 00000CF9 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1621                                      
  1622                                      ; Calcular la fila central
  1623 00000CFC BB20000000                  mov rbx, row_cells
  1624 00000D01 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1625                                      
  1626                                      ; Calcular el offset en el buffer
  1627 00000D04 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1628 00000D09 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1629 00000D0C 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1630                                      
  1631                                      ; Escribir "NIVEL " en la posición calculada
  1632 00000D0F 488DB8[000A0000]            lea rdi, [board + rax]
  1633 00000D16 48BE-                       mov rsi, level_msg
  1633 00000D18 [2414000000000000] 
  1634 00000D20 B906000000                  mov rcx, level_msg_len
  1635 00000D25 F3A4                        rep movsb
  1636                                      
  1637                                      ; Escribir el número del nivel
  1638 00000D27 8A05(B4140000)              mov al, [current_level]
  1639 00000D2D 0430                        add al, '0'                 ; convertir a ASCII
  1640 00000D2F 8807                        mov [rdi], al
  1641                                      
  1642                                      ; Mostrar el board con el mensaje
  1643                                      print board, board_size
    82 00000D31 B801000000          <1>  mov eax, sys_write
    83 00000D36 BF01000000          <1>  mov edi, 1
    84 00000D3B 48BE-               <1>  mov rsi, %1
    84 00000D3D [000A000000000000]  <1>
    85 00000D45 BA000A0000          <1>  mov edx, %2
    86 00000D4A 0F05                <1>  syscall
  1644                                      
  1645                                      ; Esperar un segundo
  1646 00000D4C B823000000                  mov rax, sys_nanosleep
  1647 00000D51 48BF-                       mov rdi, level_display_time
  1647 00000D53 [2F14000000000000] 
  1648 00000D5B 4831F6                      xor rsi, rsi
  1649 00000D5E 0F05                        syscall
  1650                                      
  1651 00000D60 5D                          pop rbp
  1652 00000D61 C3                          ret
  1653                                  
  1654                                  ; Función para inicializar un tablero vacío
  1655                                  init_empty_board:
  1656 00000D62 56                          push rsi
  1657 00000D63 57                          push rdi
  1658 00000D64 51                          push rcx
  1659 00000D65 50                          push rax
  1660                                  
  1661 00000D66 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1662 00000D6D 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1663 00000D74 B9000A0000                  mov rcx, board_template_size
  1664 00000D79 F3A4                        rep movsb                   ; Copiar el tablero
  1665                                  
  1666 00000D7B 58                          pop rax
  1667 00000D7C 59                          pop rcx
  1668 00000D7D 5F                          pop rdi
  1669 00000D7E 5E                          pop rsi
  1670 00000D7F C3                          ret
  1671                                  
  1672                                  
  1673                                  init_level:
  1674 00000D80 C605(1E180000)00            mov byte [laser_power_active], 0
  1675 00000D87 E82AF9FFFF                  call clear_lasers
  1676 00000D8C 488B05(4F140000)            mov rax, [default_pallet_size]
  1677 00000D93 488905(47140000)            mov [pallet_size], rax
  1678 00000D9A 48C705(FB170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1678 00000DA2 000000             
  1679                                  
  1680                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1681                                          ; Reiniciar letras activas
  1682 00000DA5 488D3D(54160000)            lea rdi, [letters_map]
  1683 00000DAC B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1684 00000DB1 4831C0                      xor rax, rax
  1685 00000DB4 F3AA                        rep stosb                    ; Llenar con ceros
  1686                                      
  1687                                      ; Inicializar dirección de la bola (derecha y arriba)
  1688 00000DB6 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1688 00000DBE 000000             
  1689 00000DC1 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1689 00000DC9 FFFFFF             
  1690                                  
  1691                                  
  1692                                      ; Reiniciar contador de letras activas
  1693 00000DCC 4831C0                      xor rax, rax
  1694 00000DCF 8805(E4170000)              mov [letters_count], al
  1695                                  
  1696                                      ; Reiniciar última letra capturada
  1697 00000DD5 C605(E5170000)20            mov byte [last_letter], ' '
  1698 00000DDC C605(5E150000)00            mov byte [destroyed_blocks], 0 
  1699 00000DE3 E87AFFFFFF                  call init_empty_board
  1700 00000DE8 E8E4FEFFFF                  call display_level_number
  1701 00000DED E8E5050000                  call init_enemies
  1702                                      
  1703 00000DF2 56                          push rsi
  1704 00000DF3 57                          push rdi
  1705 00000DF4 51                          push rcx
  1706 00000DF5 50                          push rax
  1707                                  
  1708 00000DF6 488D35(00000000)            lea rsi, [board_template]
  1709 00000DFD 488D3D(000A0000)            lea rdi, [board]
  1710 00000E04 B9000A0000                  mov rcx, board_template_size
  1711 00000E09 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1712                                  
  1713 00000E0B 58                          pop rax
  1714 00000E0C 59                          pop rcx
  1715 00000E0D 5F                          pop rdi
  1716 00000E0E 5E                          pop rsi
  1717                                  
  1718 00000E0F B90A000000                  mov rcx, 10
  1719 00000E14 4831C0                      xor rax, rax
  1720 00000E17 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  1721 00000E1E F3AA                        rep stosb      
  1722                                  
  1723                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1724 00000E20 803D(B4140000)01            cmp byte [current_level], 1
  1725 00000E27 7431                        je .level1
  1726 00000E29 803D(B4140000)02            cmp byte [current_level], 2
  1727 00000E30 7454                        je .level2
  1728 00000E32 803D(B4140000)03            cmp byte [current_level], 3
  1729 00000E39 7477                        je .level3
  1730 00000E3B 803D(B4140000)04            cmp byte [current_level], 4
  1731 00000E42 0F8492000000                je .level4
  1732 00000E48 803D(B4140000)05            cmp byte [current_level], 5
  1733 00000E4F 0F84AD000000                je .level5
  1734 00000E55 E9D0000000                  jmp .done
  1735                                  
  1736                                  
  1737                                  
  1738                                      .level1:
  1739 00000E5A C605(B5140000)08                mov byte [blocks_remaining], level1_blocks_count
  1740 00000E61 4831C9                          xor rcx, rcx             
  1741                                          .init_loop1:
  1742 00000E64 4883F908                            cmp rcx, level1_blocks_count
  1743 00000E68 0F8DBC000000                        jge .done
  1744 00000E6E 4889C8                              mov rax, rcx         
  1745 00000E71 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1746 00000E75 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1747 00000E7B 8891[F2140000]                      mov byte [block_states + rcx], dl
  1748 00000E81 48FFC1                              inc rcx
  1749 00000E84 EBDE                                jmp .init_loop1
  1750                                  
  1751                                      .level2:
  1752 00000E86 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1753 00000E8D 4831C9                          xor rcx, rcx             
  1754                                          .init_loop2:
  1755 00000E90 4883F901                            cmp rcx, level2_blocks_count
  1756 00000E94 0F8D90000000                        jge .done
  1757 00000E9A 4889C8                              mov rax, rcx         
  1758 00000E9D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1759 00000EA1 8A90[E1140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1760 00000EA7 8891[F2140000]                      mov byte [block_states + rcx], dl
  1761 00000EAD 48FFC1                              inc rcx
  1762 00000EB0 EBDE                                jmp .init_loop2
  1763                                      .level3:
  1764 00000EB2 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1765 00000EB9 4831C9                          xor rcx, rcx             
  1766                                          .init_loop3:
  1767 00000EBC 4883F901                            cmp rcx, level3_blocks_count
  1768 00000EC0 7D68                                jge .done
  1769 00000EC2 4889C8                              mov rax, rcx         
  1770 00000EC5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1771 00000EC9 8A90[E6140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1772 00000ECF 8891[F2140000]                      mov byte [block_states + rcx], dl
  1773 00000ED5 48FFC1                              inc rcx
  1774 00000ED8 EBE2                                jmp .init_loop3
  1775                                  
  1776                                      .level4:
  1777 00000EDA C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1778 00000EE1 4831C9                          xor rcx, rcx             
  1779                                          .init_loop4:
  1780 00000EE4 4883F901                            cmp rcx, level4_blocks_count
  1781 00000EE8 7D40                                jge .done
  1782 00000EEA 4889C8                              mov rax, rcx         
  1783 00000EED 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1784 00000EF1 8A90[EB140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1785 00000EF7 8891[F2140000]                      mov byte [block_states + rcx], dl
  1786 00000EFD 48FFC1                              inc rcx
  1787 00000F00 EBE2                                jmp .init_loop4
  1788                                  
  1789                                      .level5:
  1790 00000F02 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1791 00000F09 4831C9                          xor rcx, rcx             
  1792                                          .init_loop5:
  1793 00000F0C 4883F901                            cmp rcx, level5_blocks_count
  1794 00000F10 7D18                                jge .done
  1795 00000F12 4889C8                              mov rax, rcx         
  1796 00000F15 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1797 00000F19 8A90[F0140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1798 00000F1F 8891[F2140000]                      mov byte [block_states + rcx], dl
  1799 00000F25 48FFC1                              inc rcx
  1800 00000F28 EBE2                                jmp .init_loop5
  1801                                      .done:
  1802 00000F2A C3                              ret
  1803                                  
  1804                                  
  1805                                  ; Función para verificar y manejar la transición de nivel
  1806                                  check_level_complete:
  1807                                      ; Verificar si quedan bloques
  1808 00000F2B 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1809 00000F32 753C                        jne .not_complete
  1810                                      
  1811                                      ; Incrementar el nivel
  1812 00000F34 FE05(B4140000)              inc byte [current_level]
  1813                                      
  1814                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1815 00000F3A 803D(B4140000)06            cmp byte [current_level], 6
  1816 00000F41 742E                        je game_win
  1817                                      
  1818                                      ; Reinicializar el juego para el siguiente nivel
  1819 00000F43 E838FEFFFF                  call init_level
  1820                                      
  1821                                      ; Reinicializar la posición de la bola y la paleta
  1822 00000F48 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1822 00000F50 000000             
  1823 00000F53 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1823 00000F5B 000000             
  1824 00000F5E C605(7F140000)00            mov byte [ball_moving], 0
  1825 00000F65 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1825 00000F6C [36130000]         
  1826                                      
  1827                                      .not_complete:
  1828 00000F70 C3                              ret
  1829                                  
  1830                                      ; Nueva función para manejar la victoria del juego
  1831                                  game_win:
  1832                                      ; Limpiar la pantalla primero
  1833                                      print clear, clear_length
    82 00000F71 B801000000          <1>  mov eax, sys_write
    83 00000F76 BF01000000          <1>  mov edi, 1
    84 00000F7B 48BE-               <1>  mov rsi, %1
    84 00000F7D [1000000000000000]  <1>
    85 00000F85 BA07000000          <1>  mov edx, %2
    86 00000F8A 0F05                <1>  syscall
  1834                                      
  1835                                      ; Mensaje de victoria
  1836 00000F8C 488B05(56150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1837 00000F93 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1837 00000F95 [5F15000000000000] 
  1838 00000F9D E8B4010000                  call number_to_string
  1839                                      
  1840                                      ; Definir mensaje de victoria
  1841                                      section .data
  1842 00001901 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1842 0000190A 616465732120C2A148-
  1842 00001913 61732067616E61646F-
  1842 0000191C 210A0D             
  1843                                          win_msg_len: equ $ - win_msg
  1844 0000191F 50756E74616A652066-             score_msg: db "Puntaje final: "
  1844 00001928 696E616C3A20       
  1845                                          score_msg_len: equ $ - score_msg
  1846                                      section .text
  1847                                      
  1848                                      ; Imprimir mensajes
  1849                                      print win_msg, win_msg_len
    82 00000FA2 B801000000          <1>  mov eax, sys_write
    83 00000FA7 BF01000000          <1>  mov edi, 1
    84 00000FAC 48BE-               <1>  mov rsi, %1
    84 00000FAE [0119000000000000]  <1>
    85 00000FB6 BA1E000000          <1>  mov edx, %2
    86 00000FBB 0F05                <1>  syscall
  1850                                      print score_msg, score_msg_len
    82 00000FBD B801000000          <1>  mov eax, sys_write
    83 00000FC2 BF01000000          <1>  mov edi, 1
    84 00000FC7 48BE-               <1>  mov rsi, %1
    84 00000FC9 [1F19000000000000]  <1>
    85 00000FD1 BA0F000000          <1>  mov edx, %2
    86 00000FD6 0F05                <1>  syscall
  1851                                      print number_buffer, 20
    82 00000FD8 B801000000          <1>  mov eax, sys_write
    83 00000FDD BF01000000          <1>  mov edi, 1
    84 00000FE2 48BE-               <1>  mov rsi, %1
    84 00000FE4 [5F15000000000000]  <1>
    85 00000FEC BA14000000          <1>  mov edx, %2
    86 00000FF1 0F05                <1>  syscall
  1852                                      
  1853                                      ; Esperar un momento antes de salir
  1854 00000FF3 48C70502F0FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1854 00000FFC 0000               
  1855 00000FFE 48C705FFEFFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1855 00001007 0000               
  1856                                      sleeptime
    98 00001009 B823000000          <1>  mov eax, sys_nanosleep
    99 0000100E 48BF-               <1>  mov rdi, timespec
    99 00001010 [0000000000000000]  <1>
   100 00001018 31F6                <1>  xor esi, esi
   101 0000101A 0F05                <1>  syscall
  1857                                      
  1858 0000101C E929090000                  jmp exit
  1859                                  
  1860                                  ; Función para imprimir los bloques
  1861                                  ; Función modificada para imprimir bloques
  1862                                  
  1863                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1864                                  get_current_level_blocks:
  1865 00001021 803D(B4140000)01            cmp byte [current_level], 1
  1866 00001028 7428                        je .level1
  1867 0000102A 803D(B4140000)02            cmp byte [current_level], 2
  1868 00001031 7427                        je .level2
  1869 00001033 803D(B4140000)03            cmp byte [current_level], 3
  1870 0000103A 7426                        je .level3
  1871 0000103C 803D(B4140000)04            cmp byte [current_level], 4
  1872 00001043 7425                        je .level4
  1873 00001045 803D(B4140000)05            cmp byte [current_level], 5
  1874 0000104C 7424                        je .level5
  1875                                      ; Si llegamos aquí, hay un error en el nivel
  1876 0000104E 4831C0                      xor rax, rax
  1877 00001051 C3                          ret
  1878                                  
  1879                                      .level1:
  1880 00001052 488D05(B6140000)                lea rax, [level1_blocks]
  1881 00001059 C3                              ret
  1882                                      .level2:
  1883 0000105A 488D05(DE140000)                lea rax, [level2_blocks]
  1884 00001061 C3                              ret
  1885                                      .level3:
  1886 00001062 488D05(E3140000)                lea rax, [level3_blocks]
  1887 00001069 C3                              ret
  1888                                      .level4:
  1889 0000106A 488D05(E8140000)                lea rax, [level4_blocks]
  1890 00001071 C3                              ret
  1891                                      .level5:
  1892 00001072 488D05(ED140000)                lea rax, [level5_blocks]
  1893 00001079 C3                              ret
  1894                                  ; Función para obtener la cantidad de bloques del nivel actual
  1895                                  get_current_level_count:
  1896 0000107A 803D(B4140000)01            cmp byte [current_level], 1
  1897 00001081 7428                        je .level1
  1898 00001083 803D(B4140000)02            cmp byte [current_level], 2
  1899 0000108A 7425                        je .level2
  1900 0000108C 803D(B4140000)03            cmp byte [current_level], 3
  1901 00001093 7422                        je .level3
  1902 00001095 803D(B4140000)04            cmp byte [current_level], 4
  1903 0000109C 741F                        je .level4
  1904 0000109E 803D(B4140000)05            cmp byte [current_level], 5
  1905 000010A5 741C                        je .level5
  1906                                      ; Si llegamos aquí, hay un error en el nivel
  1907 000010A7 4831C0                      xor rax, rax
  1908 000010AA C3                          ret
  1909                                  
  1910                                      .level1:
  1911 000010AB B808000000                      mov rax, level1_blocks_count
  1912 000010B0 C3                              ret
  1913                                      .level2:
  1914 000010B1 B801000000                      mov rax, level2_blocks_count
  1915 000010B6 C3                              ret
  1916                                      .level3:
  1917 000010B7 B801000000                      mov rax, level3_blocks_count
  1918 000010BC C3                              ret
  1919                                      .level4:
  1920 000010BD B801000000                      mov rax, level4_blocks_count
  1921 000010C2 C3                              ret
  1922                                      .level5:
  1923 000010C3 B801000000                      mov rax, level5_blocks_count
  1924 000010C8 C3                              ret
  1925                                  
  1926                                  
  1927                                  print_blocks:
  1928 000010C9 55                          push rbp
  1929 000010CA 4889E5                      mov rbp, rsp
  1930                                      
  1931                                      ; Obtener puntero a los bloques del nivel actual
  1932 000010CD E84FFFFFFF                  call get_current_level_blocks
  1933 000010D2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1934                                      
  1935                                      ; Obtener cantidad de bloques del nivel actual
  1936 000010D5 E8A0FFFFFF                  call get_current_level_count
  1937 000010DA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1938                                      
  1939 000010DD 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1940                                      
  1941                                      .print_loop:
  1942 000010E0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1943 000010E3 7D6F                            jge .end
  1944                                          
  1945                                          ; Verificar si el bloque está activo
  1946 000010E5 490FB68424-                     movzx rax, byte [block_states + r12]
  1946 000010EA [F2140000]         
  1947 000010EE 4885C0                          test rax, rax
  1948 000010F1 745C                            jz .next_block
  1949                                          
  1950                                          ; Obtener posición y tipo del bloque usando r13
  1951 000010F3 4C89E0                          mov rax, r12
  1952 000010F6 486BC005                        imul rax, 5
  1953 000010FA 4C01E8                          add rax, r13
  1954 000010FD 448A00                          mov r8b, [rax]        ; X position
  1955 00001100 448A4801                        mov r9b, [rax + 1]    ; Y position
  1956 00001104 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1957                                  
  1958                                          ; El resto de la lógica de impresión permanece igual
  1959 00001108 4D0FB6C0                        movzx r8, r8b
  1960 0000110C 4D0FB6C9                        movzx r9, r9b
  1961 00001110 4981C0[000A0000]                add r8, board
  1962 00001117 B850000000                      mov rax, column_cells + 2
  1963 0000111C 49F7E1                          mul r9
  1964 0000111F 4901C0                          add r8, rax
  1965                                          
  1966 00001122 B906000000                      mov rcx, block_length
  1967 00001127 48BE-                           mov rsi, block_type_1
  1967 00001129 [9014000000000000] 
  1968 00001131 490FB6C2                        movzx rax, r10b
  1969 00001135 48FFC8                          dec rax
  1970 00001138 486BC006                        imul rax, block_length
  1971 0000113C 4801C6                          add rsi, rax
  1972                                          
  1973                                      .print_block_chars:
  1974 0000113F 8A06                            mov al, [rsi]
  1975 00001141 418800                          mov [r8], al
  1976 00001144 48FFC6                          inc rsi
  1977 00001147 49FFC0                          inc r8
  1978 0000114A 48FFC9                          dec rcx
  1979 0000114D 75F0                            jnz .print_block_chars
  1980                                          
  1981                                      .next_block:
  1982 0000114F 49FFC4                          inc r12
  1983 00001152 EB8C                            jmp .print_loop
  1984                                          
  1985                                      .end:
  1986 00001154 5D                              pop rbp
  1987 00001155 C3                              ret
  1988                                  
  1989                                  ; Función para convertir número a string
  1990                                  ; Input: RAX = número a convertir
  1991                                  ; RDI = buffer donde escribir el string
  1992                                  number_to_string:
  1993 00001156 53                          push rbx
  1994 00001157 52                          push rdx
  1995 00001158 56                          push rsi
  1996 00001159 BB0A000000                  mov rbx, 10          ; Divisor
  1997 0000115E B900000000                  mov rcx, 0          ; Contador de dígitos
  1998                                      
  1999                                      ; Si el número es 0, manejarlo especialmente
  2000 00001163 4885C0                      test rax, rax
  2001 00001166 7509                        jnz .convert_loop
  2002 00001168 C60730                      mov byte [rdi], '0'
  2003 0000116B C6470100                    mov byte [rdi + 1], 0
  2004 0000116F EB20                        jmp .end
  2005                                      
  2006                                      .convert_loop:
  2007 00001171 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2008 00001174 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2009 00001177 80C230                          add dl, '0'     ; Convertir a ASCII
  2010 0000117A 52                              push rdx        ; Guardar el dígito
  2011 0000117B 48FFC1                          inc rcx         ; Incrementar contador
  2012 0000117E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2013 00001181 75EE                            jnz .convert_loop
  2014                                          
  2015                                      .write_loop:
  2016 00001183 5A                              pop rdx         ; Obtener dígito
  2017 00001184 8817                            mov [rdi], dl   ; Escribir al buffer
  2018 00001186 48FFC7                          inc rdi         ; Siguiente posición
  2019 00001189 48FFC9                          dec rcx         ; Decrementar contador
  2020 0000118C 75F5                            jnz .write_loop
  2021                                          
  2022 0000118E C60700                      mov byte [rdi], 0   ; Null terminator
  2023                                      
  2024                                      .end:
  2025 00001191 5E                          pop rsi
  2026 00001192 5A                          pop rdx
  2027 00001193 5B                          pop rbx
  2028 00001194 C3                          ret
  2029                                  
  2030                                  ; Función para imprimir los labels
  2031                                  print_labels:
  2032 00001195 55                          push rbp
  2033 00001196 4889E5                      mov rbp, rsp
  2034                                  
  2035                                      ; Crear buffer temporal
  2036 00001199 4883EC20                    sub rsp, 32
  2037                                  
  2038                                      ; Copiar labels a buffer temporal
  2039 0000119D 4889E7                      mov rdi, rsp
  2040 000011A0 488D35(0B160000)            lea rsi, [score_label]
  2041 000011A7 B917000000                  mov rcx, score_label_len
  2042 000011AC F3A4                        rep movsb
  2043                                  
  2044                                      ; Convertir score a string
  2045 000011AE 488B05(56150000)            mov rax, [current_score]
  2046 000011B5 48BF-                       mov rdi, number_buffer
  2046 000011B7 [5F15000000000000] 
  2047 000011BF E892FFFFFF                  call number_to_string
  2048                                  
  2049                                      ; Calcular longitud del número
  2050 000011C4 B900000000                  mov rcx, 0
  2051 000011C9 48BF-                       mov rdi, number_buffer
  2051 000011CB [5F15000000000000] 
  2052                                      .count_loop:
  2053 000011D3 803C0F00                        cmp byte [rdi + rcx], 0
  2054 000011D7 7405                            je .count_done
  2055 000011D9 48FFC1                          inc rcx
  2056 000011DC EBF5                            jmp .count_loop
  2057                                      .count_done:
  2058                                  
  2059                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2060 000011DE 4889E7                      mov rdi, rsp
  2061 000011E1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2062 000011E5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2063 000011EA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2064                                      .pad_loop:
  2065 000011ED 4885F6                          test rsi, rsi
  2066 000011F0 740B                            jz .pad_done
  2067 000011F2 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2068 000011F5 48FFC7                          inc rdi
  2069 000011F8 48FFCE                          dec rsi
  2070 000011FB EBF0                            jmp .pad_loop
  2071                                      .pad_done:
  2072                                  
  2073                                      ; Copiar el número
  2074 000011FD 48BE-                       mov rsi, number_buffer
  2074 000011FF [5F15000000000000] 
  2075 00001207 F3A4                        rep movsb
  2076                                  
  2077                                      ; Imprimir el buffer completo
  2078                                      print rsp, score_label_len
    82 00001209 B801000000          <1>  mov eax, sys_write
    83 0000120E BF01000000          <1>  mov edi, 1
    84 00001213 4889E6              <1>  mov rsi, %1
    85 00001216 BA17000000          <1>  mov edx, %2
    86 0000121B 0F05                <1>  syscall
  2079                                  
  2080                                      ; Repetir proceso para bloques destruidos
  2081 0000121D 4889E7                      mov rdi, rsp
  2082 00001220 488D35(22160000)            lea rsi, [blocks_label]
  2083 00001227 B91B000000                  mov rcx, blocks_label_len
  2084 0000122C F3A4                        rep movsb
  2085                                  
  2086                                      ; Verificar que el `[` esté en su posición correcta
  2087 0000122E 4889E7                      mov rdi, rsp
  2088 00001231 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2089 00001235 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2090                                  
  2091                                      ; Convertir bloques destruidos a string
  2092 00001238 480FB605(5E150000)          movzx rax, byte [destroyed_blocks]
  2093 00001240 48BF-                       mov rdi, number_buffer
  2093 00001242 [5F15000000000000] 
  2094 0000124A E807FFFFFF                  call number_to_string
  2095                                  
  2096                                      ; Calcular longitud del número
  2097 0000124F B900000000                  mov rcx, 0
  2098 00001254 48BF-                       mov rdi, number_buffer
  2098 00001256 [5F15000000000000] 
  2099                                      .count_loop2:
  2100 0000125E 803C0F00                        cmp byte [rdi + rcx], 0
  2101 00001262 7405                            je .count_done2
  2102 00001264 48FFC1                          inc rcx
  2103 00001267 EBF5                            jmp .count_loop2
  2104                                      .count_done2:
  2105                                  
  2106                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2107 00001269 4889E7                      mov rdi, rsp
  2108 0000126C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2109 00001270 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2110 00001275 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2111                                      .pad_loop2:
  2112 00001278 4885F6                          test rsi, rsi
  2113 0000127B 740B                            jz .pad_done2
  2114 0000127D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2115 00001280 48FFC7                          inc rdi
  2116 00001283 48FFCE                          dec rsi
  2117 00001286 EBF0                            jmp .pad_loop2
  2118                                      .pad_done2:
  2119                                  
  2120                                      ; Copiar el número
  2121 00001288 48BE-                       mov rsi, number_buffer
  2121 0000128A [5F15000000000000] 
  2122 00001292 F3A4                        rep movsb
  2123                                  
  2124                                      ; Imprimir el buffer completo
  2125                                      print rsp, blocks_label_len
    82 00001294 B801000000          <1>  mov eax, sys_write
    83 00001299 BF01000000          <1>  mov edi, 1
    84 0000129E 4889E6              <1>  mov rsi, %1
    85 000012A1 BA1B000000          <1>  mov edx, %2
    86 000012A6 0F05                <1>  syscall
  2126                                  
  2127                                      ; Restaurar stack
  2128 000012A8 4883C420                    add rsp, 32
  2129 000012AC 5D                          pop rbp
  2130 000012AD C3                          ret
  2131                                  
  2132                                  
  2133                                  
  2134                                  check_block_collision:
  2135 000012AE 55                          push rbp
  2136 000012AF 4889E5                      mov rbp, rsp
  2137                                  
  2138                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2139 000012B2 418A02                      mov al, [r10]
  2140                                  
  2141                                      ; Verificar si el carácter es un bloque
  2142 000012B5 3C55                        cmp al, 'U'  
  2143 000012B7 7419                        je .possible
  2144 000012B9 3C4F                        cmp al, 'O'  
  2145 000012BB 7415                        je .possible
  2146 000012BD 3C44                        cmp al, 'D'  
  2147 000012BF 7411                        je .possible
  2148 000012C1 3C4C                        cmp al, 'L'  
  2149 000012C3 740D                        je .possible
  2150 000012C5 3C56                        cmp al, 'V'  
  2151 000012C7 7409                        je .possible
  2152 000012C9 3C38                        cmp al, '8'  
  2153 000012CB 7405                        je .possible
  2154                                  
  2155                                      ; No es bloque, salir
  2156 000012CD 4831C0                      xor rax, rax
  2157 000012D0 5D                          pop rbp
  2158 000012D1 C3                          ret
  2159                                  
  2160                                  .possible:
  2161 000012D2 53                          push rbx
  2162 000012D3 57                          push rdi
  2163 000012D4 56                          push rsi
  2164 000012D5 4154                        push r12
  2165 000012D7 4155                        push r13
  2166 000012D9 4156                        push r14
  2167 000012DB 4157                        push r15
  2168                                  
  2169                                      ; 1) Obtener base de los bloques del nivel actual
  2170 000012DD E83FFDFFFF                  call get_current_level_blocks
  2171 000012E2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2172                                  
  2173                                      ; 2) Obtener la cantidad de bloques
  2174 000012E5 E890FDFFFF                  call get_current_level_count
  2175 000012EA 4989C6                      mov r14, rax
  2176                                  
  2177 000012ED 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2178                                  
  2179                                  .find_block_loop:
  2180 000012F0 4D39F4                      cmp r12, r14
  2181 000012F3 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2182                                  
  2183                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2184 000012F9 4C89E0                      mov rax, r12
  2185 000012FC 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2186 00001300 4C01E8                      add rax, r13
  2187 00001303 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2188                                  
  2189                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2190 00001306 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2190 0000130B [F2140000]         
  2191 0000130F 4885DB                      test rbx, rbx
  2192 00001312 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2193                                  
  2194                                      ; Obtener coordenadas
  2195 00001318 418A17                      mov dl, [r15]         ; x
  2196 0000131B 418A4F01                    mov cl, [r15 + 1]     ; y
  2197                                  
  2198                                      ; Calcular posición en el board
  2199 0000131F 488D3D(000A0000)            lea rdi, [board]
  2200 00001326 4831C0                      xor rax, rax
  2201 00001329 B84E000000                  mov rax, column_cells
  2202 0000132E 4883C002                    add rax, 2
  2203 00001332 480FB6C9                    movzx rcx, cl         ; y
  2204 00001336 480FAFC1                    imul rax, rcx
  2205 0000133A 4801C7                      add rdi, rax
  2206 0000133D 480FB6C2                    movzx rax, dl         ; x
  2207 00001341 4801C7                      add rdi, rax
  2208                                  
  2209                                      ; Guardar la posición base del bloque
  2210 00001344 57                          push rdi
  2211                                  
  2212                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2213 00001345 4939FA                      cmp r10, rdi
  2214 00001348 7274                        jb .skip_collision
  2215 0000134A 488D5F06                    lea rbx, [rdi + block_length]
  2216 0000134E 4939DA                      cmp r10, rbx
  2217 00001351 736B                        jae .skip_collision
  2218                                  
  2219                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2220 00001353 41FE8C24[F2140000]          dec byte [block_states + r12]
  2221                                      ; Volver a cargar durabilidad
  2222 0000135B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2222 00001360 [F2140000]         
  2223 00001364 4885DB                      test rbx, rbx
  2224 00001367 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2225                                  
  2226                                      ; >>> Llegó a 0 => Bloque destruido
  2227 00001369 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2228 0000136A B906000000                  mov rcx, block_length
  2229                                  .clear_loop:
  2230 0000136F C60720                      mov byte [rdi], ' '
  2231 00001372 48FFC7                      inc rdi
  2232 00001375 E2F8                        loop .clear_loop
  2233                                  
  2234                                      ; Dibujar letra del bloque destruido
  2235 00001377 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2236 0000137B 4883EF06                    sub rdi, block_length
  2237 0000137F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2238                                      ; Después de escribir la letra en el tablero
  2239 00001381 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2240 00001385 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2241 00001389 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2242 0000138E E813F0FFFF                  call register_letter
  2243                                      ; Actualizar contadores globales
  2244 00001393 FE0D(B5140000)              dec byte [blocks_remaining]
  2245 00001399 FE05(5E150000)              inc byte [destroyed_blocks]
  2246                                  
  2247                                      ; Sumar puntos según el tipo
  2248 0000139F 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2249 000013A4 486BC00A                    imul rax, 10
  2250 000013A8 480105(56150000)            add [current_score], rax
  2251                                  
  2252 000013AF B801000000                  mov rax, 1  ; colisión con destrucción
  2253 000013B4 EB14                        jmp .end_pop
  2254                                  
  2255                                  .update_display:
  2256                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2257 000013B6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2258 000013BB 5F                          pop rdi     ; pop que quedó pendiente
  2259 000013BC EB0C                        jmp .end_pop
  2260                                  
  2261                                  .skip_collision:
  2262 000013BE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2263                                  .next_block:
  2264 000013BF 49FFC4                      inc r12
  2265 000013C2 E929FFFFFF                  jmp .find_block_loop
  2266                                  
  2267                                  .no_block_found:
  2268 000013C7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2269                                  
  2270                                  .end_pop:
  2271 000013CA 415F                        pop r15
  2272 000013CC 415E                        pop r14
  2273 000013CE 415D                        pop r13
  2274 000013D0 415C                        pop r12
  2275 000013D2 5E                          pop rsi
  2276 000013D3 5F                          pop rdi
  2277 000013D4 5B                          pop rbx
  2278 000013D5 5D                          pop rbp
  2279 000013D6 C3                          ret
  2280                                  
  2281                                  
  2282                                  
  2283                                  init_enemies:
  2284 000013D7 55                          push rbp
  2285 000013D8 4889E5                      mov rbp, rsp
  2286                                      ; Reiniciar contadores de movimiento
  2287 000013DB C605(A1150000)00            mov byte [enemy_move_total], 0
  2288 000013E2 C605(A2150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2289                                      ; Limpiar estado previo de enemigos
  2290 000013E9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2291 000013EE 488D3D(78150000)            lea rdi, [enemies]
  2292 000013F5 30C0                        xor al, al
  2293 000013F7 F3AA                        rep stosb ; Limpiar datos de enemigos
  2294                                      
  2295                                      ; Marcar todos los enemigos como inactivos
  2296 000013F9 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  2297 00001400 30C0                        xor al, al
  2298 00001402 B90A000000                  mov rcx, 10
  2299 00001407 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2300                                  
  2301 00001409 5D                          pop rbp
  2302 0000140A C3                          ret
  2303                                  
  2304                                  
  2305                                  ; Función para mover enemigos
  2306                                  move_enemies:
  2307 0000140B 55                          push rbp
  2308 0000140C 4889E5                      mov rbp, rsp
  2309                                      
  2310                                      ; Incrementar contador de movimiento
  2311 0000140F FE05(9F150000)              inc byte [enemy_move_counter]
  2312 00001415 480FB605(9F150000)          movzx rax, byte [enemy_move_counter]
  2313 0000141D 3A05(A0150000)              cmp al, [enemy_move_delay]
  2314 00001423 0F85AA010000                jne .end
  2315                                      
  2316                                      ; Resetear contador
  2317 00001429 C605(9F150000)00            mov byte [enemy_move_counter], 0
  2318                                      
  2319 00001430 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2320                                      
  2321                                      .enemy_loop:
  2322 00001433 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2323 00001437 0F8D96010000                    jge .end
  2324                                          
  2325                                          ; Calcular offset del enemigo actual
  2326 0000143D 4C89E0                          mov rax, r12
  2327 00001440 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2328 00001444 488DB0[78150000]                lea rsi, [enemies + rax]
  2329                                          
  2330                                          ; Verificar si el enemigo está activo
  2331 0000144B 807E0201                        cmp byte [rsi + 2], 1
  2332 0000144F 0F8576010000                    jne .next_enemy
  2333                                          
  2334                                          ; Obtener posición actual
  2335 00001455 4C0FB606                        movzx r8, byte [rsi]            ; X
  2336 00001459 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2337                                          
  2338                                          ; Limpiar posición actual antes de mover
  2339 0000145E 4150                            push r8
  2340 00001460 4151                            push r9
  2341 00001462 B84E000000                      mov rax, column_cells
  2342 00001467 4883C002                        add rax, 2
  2343 0000146B 49F7E1                          mul r9
  2344 0000146E 4C01C0                          add rax, r8
  2345 00001471 488DB8[000A0000]                lea rdi, [board + rax]
  2346 00001478 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2347 0000147B 4159                            pop r9
  2348 0000147D 4158                            pop r8
  2349                                  
  2350                                          ; Determinar comportamiento basado en índice
  2351 0000147F 4C89E0                          mov rax, r12
  2352 00001482 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2353 00001486 4885C0                          test rax, rax
  2354 00001489 7402                            jz .chase_ball
  2355 0000148B EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2356                                          
  2357                                          ; Perseguir bola (comportamiento original)
  2358                                      .chase_ball:
  2359 0000148D 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2360 00001494 4D39D0                          cmp r8, r10
  2361 00001497 0F8F96000000                    jg .move_left
  2362 0000149D 0F8C95000000                    jl .move_right
  2363                                          
  2364 000014A3 4C8B15(67140000)                mov r10, [ball_y_pos]
  2365 000014AA 4D39D1                          cmp r9, r10
  2366 000014AD 0F8F8A000000                    jg .move_up
  2367 000014B3 0F8C89000000                    jl .move_down
  2368 000014B9 E9A5000000                      jmp .check_collision
  2369                                          
  2370                                      .chase_paddle:
  2371                                          ; Obtener la posición X actual de la paleta
  2372 000014BE 4C8B15(3F140000)                mov r10, [pallet_position]
  2373 000014C5 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2374                                          
  2375                                          ; Calcular la posición X real de la paleta
  2376 000014CC 4C89D0                          mov rax, r10
  2377 000014CF BB4E000000                      mov rbx, column_cells
  2378 000014D4 4883C302                        add rbx, 2                  ; Añadir newline chars
  2379 000014D8 4831D2                          xor rdx, rdx
  2380 000014DB 48F7F3                          div rbx                     ; rax = y, rdx = x
  2381                                          
  2382                                          ; rdx ahora contiene la posición X de la paleta
  2383                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2384 000014DE 488B0D(47140000)                mov rcx, [pallet_size]
  2385 000014E5 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2386 000014E8 4801CA                          add rdx, rcx
  2387                                          
  2388                                          ; Comparar con posición X del enemigo y mover gradualmente
  2389 000014EB 4939D0                          cmp r8, rdx
  2390 000014EE 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2391 000014F0 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2392 000014F2 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2393                                  
  2394                                      .check_y_paddle:
  2395                                          ; La Y de la paleta siempre es row_cells - 2
  2396 000014F4 41BA20000000                    mov r10, row_cells
  2397 000014FA 4983EA02                        sub r10, 2
  2398                                          
  2399                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2400 000014FE 4D39D1                          cmp r9, r10
  2401 00001501 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2402 00001503 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2403 00001505 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2404                                          
  2405                                      .no_movement:
  2406 00001507 EB5A                            jmp .check_collision
  2407                                  
  2408                                      ; También agregar una nueva sección para el movimiento suave
  2409                                      .smooth_transition:
  2410                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2411 00001509 8A05(A2150000)                  mov al, [enemy_target]
  2412 0000150F 84C0                            test al, al
  2413 00001511 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2414                                          
  2415                                          ; Verificar distancia en X
  2416 00001513 4989D2                          mov r10, rdx              ; Posición X objetivo
  2417 00001516 4D29C2                          sub r10, r8               ; Calcular diferencia
  2418 00001519 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2419 0000151D 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2420 0000151F 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2421 00001523 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2422 00001525 EB3C                            jmp .check_collision
  2423                                          
  2424                                      .limit_right_movement:
  2425 00001527 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2426 0000152B EB36                            jmp .check_collision
  2427                                          
  2428                                      .limit_left_movement:
  2429 0000152D 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2430 00001531 EB30                            jmp .check_collision
  2431                                      .move_left:
  2432 00001533 49FFC8                          dec r8
  2433 00001536 EB0F                            jmp .check_vertical
  2434                                          
  2435                                      .move_right:
  2436 00001538 49FFC0                          inc r8
  2437 0000153B EB0A                            jmp .check_vertical
  2438                                          
  2439                                      .move_up:
  2440 0000153D 49FFC9                          dec r9
  2441 00001540 EB21                            jmp .check_collision
  2442                                          
  2443                                      .move_down:
  2444 00001542 49FFC1                          inc r9
  2445 00001545 EB1C                            jmp .check_collision
  2446                                          
  2447                                      .check_vertical:
  2448 00001547 8A05(A2150000)                  mov al, [enemy_target]
  2449 0000154D 84C0                            test al, al
  2450 0000154F 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2451 00001555 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2452 0000155C 4D39D1                          cmp r9, r10
  2453 0000155F 7FDC                            jg .move_up
  2454 00001561 7CDF                            jl .move_down
  2455                                          
  2456                                      .check_collision:
  2457                                          ; Verificar colisión con bordes
  2458 00001563 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2459 00001567 7E62                            jle .next_enemy
  2460 00001569 4983F84E                        cmp r8, column_cells
  2461 0000156D 7D5C                            jge .next_enemy
  2462 0000156F 4983F901                        cmp r9, 1                       ; Borde superior
  2463 00001573 7E56                            jle .next_enemy
  2464 00001575 4983F920                        cmp r9, row_cells
  2465 00001579 7D50                            jge .next_enemy
  2466                                          
  2467                                          ; Verificar colisión con bloques antes de moverse
  2468 0000157B 4150                            push r8
  2469 0000157D 4151                            push r9
  2470 0000157F 4152                            push r10
  2471                                          
  2472                                          ; Calcular posición en el tablero para verificar
  2473 00001581 B84E000000                      mov rax, column_cells
  2474 00001586 4883C002                        add rax, 2
  2475 0000158A 49F7E1                          mul r9
  2476 0000158D 4C01C0                          add rax, r8
  2477 00001590 4C8D90[000A0000]                lea r10, [board + rax]
  2478                                          
  2479                                          ; Verificar si hay un bloque en la nueva posición
  2480 00001597 418A02                          mov al, [r10]
  2481 0000159A 3C55                            cmp al, 'U'
  2482 0000159C 7427                            je .invalid_move
  2483 0000159E 3C4F                            cmp al, 'O'
  2484 000015A0 7423                            je .invalid_move
  2485 000015A2 3C44                            cmp al, 'D'
  2486 000015A4 741F                            je .invalid_move
  2487 000015A6 3C4C                            cmp al, 'L'
  2488 000015A8 741B                            je .invalid_move
  2489 000015AA 3C56                            cmp al, 'V'
  2490 000015AC 7417                            je .invalid_move
  2491 000015AE 3C38                            cmp al, '8'
  2492 000015B0 7413                            je .invalid_move
  2493 000015B2 3C58                            cmp al, 'X'
  2494 000015B4 740F                            je .invalid_move
  2495                                          
  2496 000015B6 415A                            pop r10
  2497 000015B8 4159                            pop r9
  2498 000015BA 4158                            pop r8
  2499                                          
  2500                                          ; Guardar nueva posición si es válida
  2501 000015BC 448806                          mov [rsi], r8b
  2502 000015BF 44884E01                        mov [rsi + 1], r9b
  2503 000015C3 EB06                            jmp .next_enemy
  2504                                          
  2505                                      .invalid_move:
  2506 000015C5 415A                            pop r10
  2507 000015C7 4159                            pop r9
  2508 000015C9 4158                            pop r8
  2509                                          
  2510                                      .next_enemy:
  2511 000015CB 49FFC4                          inc r12
  2512 000015CE E960FEFFFF                      jmp .enemy_loop
  2513                                          
  2514                                      .end:
  2515 000015D3 5D                              pop rbp
  2516 000015D4 C3                              ret
  2517                                  
  2518                                  get_current_spawn_points:
  2519 000015D5 55                          push rbp
  2520 000015D6 4889E5                      mov rbp, rsp
  2521                                      
  2522 000015D9 480FB605(B4140000)          movzx rax, byte [current_level]
  2523 000015E1 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2524 000015E4 488B04C5[D6150000]          mov rax, [spawn_points_table + rax * 8]
  2525                                      
  2526 000015EC 5D                          pop rbp
  2527 000015ED C3                          ret
  2528                                  
  2529                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2530                                  check_enemy_spawn:
  2531 000015EE 55                          push rbp
  2532 000015EF 4889E5                      mov rbp, rsp
  2533                                      
  2534                                      ; Obtener spawn points del nivel actual
  2535 000015F2 E8DEFFFFFF                  call get_current_spawn_points
  2536 000015F7 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2537                                      
  2538                                      ; Obtener cantidad de bloques destruidos
  2539 000015FA 4C0FB62D(5E150000)          movzx r13, byte [destroyed_blocks]
  2540                                      
  2541                                      ; Verificar cada punto de spawn
  2542 00001602 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2543                                      
  2544                                      .check_loop:
  2545 00001605 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2546 00001609 7D4B                            jge .end
  2547                                          
  2548                                          ; Verificar si este spawn point ya fue usado
  2549 0000160B 80B9[01160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2550 00001612 743D                            je .next_enemy
  2551                                          
  2552                                          ; Verificar si este enemigo ya está activo
  2553 00001614 4889C8                          mov rax, rcx
  2554 00001617 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2555 0000161B 488DB0[78150000]                lea rsi, [enemies + rax]
  2556 00001622 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2557 00001626 7429                            je .next_enemy
  2558                                          
  2559                                          ; Verificar si debemos spawnear este enemigo
  2560 00001628 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2561 0000162D 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2562 00001630 751F                            jne .next_enemy
  2563                                          
  2564                                          ; Marcar este spawn point como usado
  2565 00001632 C681[01160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2566                                          
  2567                                          ; Spawner nuevo enemigo
  2568 00001639 C60628                          mov byte [rsi], 40             ; X inicial
  2569 0000163C C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2570 00001640 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2571                                          
  2572                                          ; Inicializar comportamiento
  2573 00001644 4889C8                          mov rax, rcx
  2574 00001647 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2575 0000164B 8805(00160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2576                                          
  2577                                      .next_enemy:
  2578 00001651 48FFC1                          inc rcx
  2579 00001654 EBAF                            jmp .check_loop
  2580                                          
  2581                                      .end:
  2582 00001656 5D                              pop rbp
  2583 00001657 C3                              ret
  2584                                  
  2585                                  
  2586                                  ; Función para dibujar enemigos
  2587                                  print_enemies:
  2588 00001658 55                          push rbp
  2589 00001659 4889E5                      mov rbp, rsp
  2590                                      
  2591 0000165C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2592                                      
  2593                                      .print_loop:
  2594 0000165F 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2595 00001663 7D4B                            jge .end
  2596                                          
  2597                                          ; Calcular offset del enemigo actual
  2598 00001665 4C89E0                          mov rax, r12
  2599 00001668 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2600 0000166C 488DB0[78150000]                lea rsi, [enemies + rax]
  2601                                          
  2602                                          ; Verificar si el enemigo está activo
  2603 00001673 807E0201                        cmp byte [rsi + 2], 1
  2604 00001677 7532                            jne .next_enemy
  2605                                          
  2606                                          ; Calcular posición en el tablero
  2607 00001679 4C0FB606                        movzx r8, byte [rsi]            ; X
  2608 0000167D 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2609                                          
  2610                                          ; Calcular offset en el tablero
  2611 00001682 B84E000000                      mov rax, column_cells
  2612 00001687 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2613 0000168B 49F7E1                          mul r9
  2614 0000168E 4C01C0                          add rax, r8
  2615 00001691 488DB8[000A0000]                lea rdi, [board + rax]
  2616                                          
  2617                                          ; Obtener carácter del enemigo según el nivel
  2618 00001698 480FB605(B4140000)              movzx rax, byte [current_level]
  2619 000016A0 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2620 000016A3 8A80[73150000]                  mov al, [enemy_chars + rax]
  2621                                          
  2622                                          ; Dibujar enemigo
  2623 000016A9 8807                            mov [rdi], al
  2624                                          
  2625                                      .next_enemy:
  2626 000016AB 49FFC4                          inc r12
  2627 000016AE EBAF                            jmp .print_loop
  2628                                          
  2629                                      .end:
  2630 000016B0 5D                              pop rbp
  2631 000016B1 C3                              ret
  2632                                  
  2633                                  ; Función para verificar colisión con enemigos
  2634                                  ; Función para verificar colisión con enemigos
  2635                                  check_enemy_collision:
  2636 000016B2 55                          push rbp
  2637 000016B3 4889E5                      mov rbp, rsp
  2638                                      
  2639 000016B6 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2640 000016B9 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2641                                      
  2642                                      .check_loop:
  2643 000016BC 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2644 000016C0 0F8DE9000000                    jge .end
  2645                                          
  2646                                          ; Calcular offset del enemigo actual
  2647 000016C6 4C89E1                          mov rcx, r12
  2648 000016C9 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2649 000016CD 488DB1[78150000]                lea rsi, [enemies + rcx]
  2650                                          
  2651                                          ; Verificar si el enemigo está activo
  2652 000016D4 807E0201                        cmp byte [rsi + 2], 1
  2653 000016D8 0F85C9000000                    jne .next_enemy
  2654                                          
  2655                                          ; Verificar colisión con la bola
  2656 000016DE 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2657 000016E2 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2658                                          
  2659                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2660 000016E7 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2661 000016EE 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2662                                          
  2663                                          ; Comprobar colisión vertical (misma columna)
  2664 000016F5 4D39C2                          cmp r10, r8
  2665 000016F8 7525                            jne .check_horizontal
  2666 000016FA 4D29CB                          sub r11, r9
  2667 000016FD 4983FB01                        cmp r11, 1
  2668 00001701 7F1C                            jg .check_horizontal
  2669 00001703 4983FBFF                        cmp r11, -1
  2670 00001707 7C16                            jl .check_horizontal
  2671                                          
  2672                                          ; Colisión vertical detectada
  2673 00001709 E8A3000000                      call destroy_enemy
  2674 0000170E 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2675 00001715 B801000000                      mov rax, 1
  2676 0000171A E990000000                      jmp .end
  2677                                          
  2678                                      .check_horizontal:
  2679                                          ; Comprobar colisión horizontal (misma fila)
  2680 0000171F 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2681 00001726 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2682 0000172D 4D39CB                          cmp r11, r9
  2683 00001730 7522                            jne .check_paddle
  2684 00001732 4D29C2                          sub r10, r8
  2685 00001735 4983FA01                        cmp r10, 1
  2686 00001739 7F19                            jg .check_paddle
  2687 0000173B 4983FAFF                        cmp r10, -1
  2688 0000173F 7C13                            jl .check_paddle
  2689                                          
  2690                                          ; Colisión horizontal detectada
  2691 00001741 E86B000000                      call destroy_enemy
  2692 00001746 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2693 0000174D B801000000                      mov rax, 1
  2694 00001752 EB5B                            jmp .end
  2695                                          
  2696                                      .check_paddle:
  2697                                          ; Verificar colisión con la paleta
  2698 00001754 4C8B15(3F140000)                mov r10, [pallet_position]
  2699 0000175B 4981EA[000A0000]                sub r10, board
  2700 00001762 4C89D0                          mov rax, r10
  2701 00001765 41BB4E000000                    mov r11, column_cells
  2702 0000176B 4983C302                        add r11, 2
  2703 0000176F 4831D2                          xor rdx, rdx
  2704 00001772 49F7F3                          div r11                     ; División para obtener la posición Y
  2705 00001775 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2706                                          
  2707 00001778 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2708                                          
  2709                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2710 0000177F 41BD20000000                    mov r13, row_cells
  2711 00001785 4983ED02                        sub r13, 2                 ; Y de la paleta
  2712 00001789 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2713 0000178C 7519                            jne .next_enemy
  2714                                          
  2715                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2716 0000178E 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2717 00001791 7C14                            jl .next_enemy
  2718                                          
  2719 00001793 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2720 00001796 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2721 00001799 7F0C                            jg .next_enemy
  2722                                          
  2723                                          ; Si llegamos aquí, hay colisión con la paleta
  2724 0000179B E811000000                      call destroy_enemy        ; Destruir el enemigo
  2725 000017A0 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2726 000017A5 EB08                            jmp .end
  2727                                          
  2728                                      .next_enemy:
  2729 000017A7 49FFC4                          inc r12
  2730 000017AA E90DFFFFFF                      jmp .check_loop
  2731                                          
  2732                                      .end:
  2733 000017AF 5D                              pop rbp
  2734 000017B0 C3                              ret
  2735                                  
  2736                                  ; Función para destruir un enemigo
  2737                                  destroy_enemy:
  2738                                      ; Desactivar enemigo
  2739 000017B1 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2740                                  
  2741                                      ; Sumar puntos por destruir enemigo
  2742 000017B5 488B05(97150000)            mov rax, [enemy_points]
  2743 000017BC 480105(56150000)            add [current_score], rax
  2744                                  
  2745                                      ; No tocar bloques destruidos aquí
  2746 000017C3 C3                          ret
  2747                                  
  2748                                  
  2749                                  _start:
  2750 000017C4 E862E9FFFF              	call canonical_off
  2751 000017C9 E809010000              	call start_screen
  2752 000017CE E8ADF5FFFF                  call init_level
  2753 000017D3 E8FFFBFFFF                  call init_enemies
  2754 000017D8 EB00                    	jmp .main_loop
  2755                                  	
  2756                                  
  2757                                  	.main_loop:
  2758 000017DA E8B6F9FFFF                      call print_labels
  2759 000017DF E8E5F8FFFF                      call print_blocks
  2760 000017E4 E88EECFFFF                      call move_letters
  2761 000017E9 E814EFFFFF                      call update_lasers
  2762 000017EE E8F9EBFFFF                      call print_letters
  2763 000017F3 E8D9F1FFFF              		call print_pallet
  2764 000017F8 E8BCF2FFFF                      call move_ball
  2765 000017FD E8DCEAFFFF                      call check_bottom_collision
  2766 00001802 E8D6E9FFFF                      call print_lives
  2767 00001807 E81FF7FFFF                      call check_level_complete
  2768 0000180C E8DDFDFFFF                      call check_enemy_spawn
  2769 00001811 E8F5FBFFFF                      call move_enemies
  2770 00001816 E897FEFFFF                      call check_enemy_collision
  2771 0000181B E838FEFFFF                      call print_enemies
  2772 00001820 E884F1FFFF              		call print_ball
  2773                                  		print board, board_size				
    82 00001825 B801000000          <1>  mov eax, sys_write
    83 0000182A BF01000000          <1>  mov edi, 1
    84 0000182F 48BE-               <1>  mov rsi, %1
    84 00001831 [000A000000000000]  <1>
    85 00001839 BA000A0000          <1>  mov edx, %2
    86 0000183E 0F05                <1>  syscall
  2774                                  		;setnonblocking	
  2775                                  	.read_more:	
  2776                                  	    getchar	
    90 00001840 B800000000          <1>  mov rax, sys_read
    91 00001845 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000184A 48BE-               <1>  mov rsi, input_char
    92 0000184C [0000000000000000]  <1>
    93 00001854 BA01000000          <1>  mov rdx, 1
    94 00001859 0F05                <1>  syscall
  2777 0000185B 4883F801                	    cmp rax, 1
  2778 0000185F 7543                    	    jne .done
  2779                                  	
  2780 00001861 8A05(00000000)          	    mov al, [input_char]
  2781 00001867 8805(1D180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2782                                  	
  2783 0000186D 3C61                    	    cmp al, 'a'
  2784 0000186F 750E                    	    jne .not_left
  2785 00001871 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2786 00001878 E889F1FFFF              	    call move_pallet
  2787 0000187D EB25                    	    jmp .done
  2788                                  	
  2789                                      .not_left:
  2790 0000187F 3C64                    	    cmp al, 'd'
  2791 00001881 750C                    	    jne .not_right
  2792 00001883 BF01000000              	    mov rdi, right_direction
  2793 00001888 E879F1FFFF              	    call move_pallet
  2794 0000188D EB15                    	    jmp .done
  2795                                  	
  2796                                      .not_right:
  2797 0000188F 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2798 00001891 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2799                                  	
  2800 00001893 3C71                    	    cmp al, 'q' 
  2801 00001895 0F84AF000000            	    je exit
  2802 0000189B EBA3                    	    jmp .read_more
  2803                                  	
  2804                                      .release_ball:
  2805 0000189D E8EAF3FFFF              	    call process_catch_release
  2806 000018A2 EB00                    	    jmp .done
  2807                                  	
  2808                                      .done:
  2809                                  	    sleeptime
    98 000018A4 B823000000          <1>  mov eax, sys_nanosleep
    99 000018A9 48BF-               <1>  mov rdi, timespec
    99 000018AB [0000000000000000]  <1>
   100 000018B3 31F6                <1>  xor esi, esi
   101 000018B5 0F05                <1>  syscall
  2810                                  	    print clear, clear_length
    82 000018B7 B801000000          <1>  mov eax, sys_write
    83 000018BC BF01000000          <1>  mov edi, 1
    84 000018C1 48BE-               <1>  mov rsi, %1
    84 000018C3 [1000000000000000]  <1>
    85 000018CB BA07000000          <1>  mov edx, %2
    86 000018D0 0F05                <1>  syscall
  2811 000018D2 E903FFFFFF              	    jmp .main_loop
  2812                                  
  2813                                  
  2814                                  
  2815                                  
  2816                                  start_screen:
  2817                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000018D7 B801000000          <1>  mov eax, sys_write
    83 000018DC BF01000000          <1>  mov edi, 1
    84 000018E1 48BE-               <1>  mov rsi, %1
    84 000018E3 [1000000000000000]  <1>
    85 000018EB BA07000000          <1>  mov edx, %2
    86 000018F0 0F05                <1>  syscall
  2818                                      print msg1, msg1_length
    82 000018F2 B801000000          <1>  mov eax, sys_write
    83 000018F7 BF01000000          <1>  mov edi, 1
    84 000018FC 48BE-               <1>  mov rsi, %1
    84 000018FE [1700000000000000]  <1>
    85 00001906 BA14010000          <1>  mov edx, %2
    86 0000190B 0F05                <1>  syscall
  2819                                      
  2820                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2821                                          getchar                 ; Esperamos una tecla
    90 0000190D B800000000          <1>  mov rax, sys_read
    91 00001912 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001917 48BE-               <1>  mov rsi, input_char
    92 00001919 [0000000000000000]  <1>
    93 00001921 BA01000000          <1>  mov rdx, 1
    94 00001926 0F05                <1>  syscall
  2822 00001928 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2823 0000192C 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2824                                          
  2825                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000192E B801000000          <1>  mov eax, sys_write
    83 00001933 BF01000000          <1>  mov edi, 1
    84 00001938 48BE-               <1>  mov rsi, %1
    84 0000193A [1000000000000000]  <1>
    85 00001942 BA07000000          <1>  mov edx, %2
    86 00001947 0F05                <1>  syscall
  2826 00001949 C3                          ret
  2827                                  
  2828                                  exit: 
  2829 0000194A E81EE8FFFF              	call canonical_on
  2830 0000194F B83C000000              	mov    rax, 60
  2831 00001954 BF00000000                  mov    rdi, 0
  2832 00001959 0F05                        syscall
  2833                                  
