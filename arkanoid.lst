     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 50h>         <1>  times column_cells db "X"
    71 00000050 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000052 58                  <2>  db "X"
    76 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A4 58                  <2>  db "X"
    76 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F6 58                  <2>  db "X"
    76 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000148 58                  <2>  db "X"
    76 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000019A 58                  <2>  db "X"
    76 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001EC 58                  <2>  db "X"
    76 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000023E 58                  <2>  db "X"
    76 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000290 58                  <2>  db "X"
    76 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002E2 58                  <2>  db "X"
    76 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000334 58                  <2>  db "X"
    76 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000386 58                  <2>  db "X"
    76 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003D8 58                  <2>  db "X"
    76 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000042A 58                  <2>  db "X"
    76 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000047C 58                  <2>  db "X"
    76 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004CE 58                  <2>  db "X"
    76 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000520 58                  <2>  db "X"
    76 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000572 58                  <2>  db "X"
    76 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005C4 58                  <2>  db "X"
    76 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000616 58                  <2>  db "X"
    76 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000668 58                  <2>  db "X"
    76 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006BA 58                  <2>  db "X"
    76 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000070C 58                  <2>  db "X"
    76 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000075E 58                  <2>  db "X"
    76 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007B0 58                  <2>  db "X"
    76 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000802 58                  <2>  db "X"
    76 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000854 58                  <2>  db "X"
    76 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008A6 58                  <2>  db "X"
    76 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008F8 58                  <2>  db "X"
    76 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000094A 58                  <2>  db "X"
    76 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 0000099C 58                  <2>  db "X"
    76 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    71 00000A3E 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A40 00<rep A40h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001480 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(8C140000)                  and [termios+12], eax
   146 0000013E C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(98140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(8C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(8C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(97140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(98140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(8C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[80140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[80140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 000014A4 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 000014AA 31                          level_1_char: db "1"
   236 000014AB 32                          level_2_char: db "2"
   237 000014AC 33                          level_3_char: db "3"
   238 000014AD 34                          level_4_char: db "4"
   239 000014AE 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 000014AF 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 000014B7 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 000014BF [B013000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 000014C7 0500000000000000            pallet_size dq 5
   249 000014CF 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 000014D7 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 000014DF 2800000000000000        	ball_x_pos: dq 40
   253 000014E7 1C00000000000000        	ball_y_pos: dq 28
   254 000014EF 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 000014F7 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 000014FF 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001500 00                          ball_active db 0
   258                                  
   259 00001501 0000000000000000            ball2_x_pos:        dq 0
   260 00001509 0000000000000000            ball2_y_pos:        dq 0
   261 00001511 0000000000000000            ball2_direction_x:  dq 0
   262 00001519 0000000000000000            ball2_direction_y:  dq 0
   263 00001521 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 00001522 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 00001523 0000000000000000            ball3_x_pos:        dq 0
   268 0000152B 0000000000000000            ball3_y_pos:        dq 0
   269 00001533 0000000000000000            ball3_direction_x:  dq 0
   270 0000153B 0000000000000000            ball3_direction_y:  dq 0
   271 00001543 00                          ball3_moving:       db 0
   272 00001544 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 00001545 [920A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 0000154D [E00A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 00001555 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 0000155B 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 00001561 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 00001567 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 0000156D 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 00001573 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 00001579 02                          current_level db 2
   300 0000157A 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 0000157B 0105050220                      db 1, 5, 5, 2, ' '   
   307 00001580 0705050220                      db 7, 5, 5, 2, ' '    
   308 00001585 0D05050220                      db 13, 5, 5, 2, ' '   
   309 0000158A 1305050220                      db 19, 5, 5, 2, ' '   
   310 0000158F 1905050220                      db 25, 5, 5, 2, ' '   
   311 00001594 1F05050220                      db 31, 5, 5, 2, ' '   
   312 00001599 2505050220                      db 37, 5, 5, 2, ' '   
   313 0000159E 2B05050220                      db 43, 5, 5, 2, ' '   
   314 000015A3 3105050220                      db 49, 5, 5, 2, ' '   
   315 000015A8 3705050220                      db 55, 5, 5, 2, ' '   
   316 000015AD 3D05050220                      db 61, 5, 5, 2, ' '  
   317 000015B2 4305050220                      db 67, 5, 5, 2, ' '   
   318 000015B7 4905050220                      db 73, 5, 5, 2, ' '   
   319                                  
   320 000015BC 0106040120                      db 1, 6, 4, 1, ' '   
   321 000015C1 0706020120                      db 7, 6, 2, 1, ' '    
   322 000015C6 0D06040120                      db 13, 6, 4, 1, ' '   
   323 000015CB 1306020120                      db 19, 6, 2, 1, ' '   
   324 000015D0 1906040120                      db 25, 6, 4, 1, ' '   
   325 000015D5 1F06020120                      db 31, 6, 2, 1, ' '   
   326 000015DA 2506040120                      db 37, 6, 4, 1, ' '   
   327 000015DF 2B06020120                      db 43, 6, 2, 1, ' '   
   328 000015E4 3106040120                      db 49, 6, 4, 1, ' '   
   329 000015E9 3706020120                      db 55, 6, 2, 1, ' '   
   330 000015EE 3D06040120                      db 61, 6, 4, 1, ' '  
   331 000015F3 4306020120                      db 67, 6, 2, 1, ' '   
   332 000015F8 4906040120                      db 73, 6, 4, 1, ' ' 
   333                                  
   334 000015FD 0107010120                      db 1, 7, 1, 1, ' '   
   335 00001602 0707030120                      db 7, 7, 3, 1, ' '    
   336 00001607 0D07010120                      db 13, 7, 1, 1, ' '   
   337 0000160C 1307030120                      db 19, 7, 3, 1, ' '   
   338 00001611 1907010120                      db 25, 7, 1, 1, ' '   
   339 00001616 1F07030120                      db 31, 7, 3, 1, ' '   
   340 0000161B 2507010120                      db 37, 7, 1, 1, ' '   
   341 00001620 2B07030120                      db 43, 7, 3, 1, ' '   
   342 00001625 3107010120                      db 49, 7, 1, 1, ' '   
   343 0000162A 3707030120                      db 55, 7, 3, 1, ' '   
   344 0000162F 3D07010120                      db 61, 7, 1, 1, ' '  
   345 00001634 4307030120                      db 67, 7, 3, 1, ' '   
   346 00001639 4907010120                      db 73, 7, 1, 1, ' ' 
   347                                  
   348 0000163E 0108040120                      db 1, 8, 4, 1, ' '   
   349 00001643 0708020120                      db 7, 8, 2, 1, ' '    
   350 00001648 0D08040120                      db 13, 8, 4, 1, ' '   
   351 0000164D 1308020120                      db 19, 8, 2, 1, ' '   
   352 00001652 1908040120                      db 25, 8, 4, 1, ' '   
   353 00001657 1F08020120                      db 31, 8, 2, 1, ' '   
   354 0000165C 2508040120                      db 37, 8, 4, 1, ' '   
   355 00001661 2B08020120                      db 43, 8, 2, 1, ' '   
   356 00001666 3108040120                      db 49, 8, 4, 1, ' '   
   357 0000166B 3708020120                      db 55, 8, 2, 1, ' '   
   358 00001670 3D08040120                      db 61, 8, 4, 1, ' '  
   359 00001675 4308020120                      db 67, 8, 2, 1, ' '   
   360 0000167A 4908040120                      db 73, 8, 4, 1, ' ' 
   361                                  
   362 0000167F 0109010120                      db 1, 9, 1, 1, ' '   
   363 00001684 0709030120                      db 7, 9, 3, 1, ' '    
   364 00001689 0D09010120                      db 13, 9, 1, 1, ' '   
   365 0000168E 1309030120                      db 19, 9, 3, 1, ' '   
   366 00001693 1909010120                      db 25, 9, 1, 1, ' '   
   367 00001698 1F09030120                      db 31, 9, 3, 1, ' '   
   368 0000169D 2509010120                      db 37, 9, 1, 1, ' '   
   369 000016A2 2B09030120                      db 43, 9, 3, 1, ' '   
   370 000016A7 3109010120                      db 49, 9, 1, 1, ' '   
   371 000016AC 3709030120                      db 55, 9, 3, 1, ' '   
   372 000016B1 3D09010120                      db 61, 9, 1, 1, ' '  
   373 000016B6 4309030120                      db 67, 9, 3, 1, ' '   
   374 000016BB 4909010120                      db 73, 9, 1, 1, ' ' 
   375                                  
   376 000016C0 010A040120                      db 1, 10, 4, 1, ' '   
   377 000016C5 070A020120                      db 7, 10, 2, 1, ' '    
   378 000016CA 0D0A040120                      db 13, 10, 4, 1, ' '   
   379 000016CF 130A020120                      db 19, 10, 2, 1, ' '   
   380 000016D4 190A040120                      db 25, 10, 4, 1, ' '   
   381 000016D9 1F0A020120                      db 31, 10, 2, 1, ' '   
   382 000016DE 250A040120                      db 37, 10, 4, 1, ' '   
   383 000016E3 2B0A020120                      db 43, 10, 2, 1, ' '   
   384 000016E8 310A040120                      db 49, 10, 4, 1, ' '   
   385 000016ED 370A02014C                      db 55, 10, 2, 1, 'L'   
   386 000016F2 3D0A040120                      db 61, 10, 4, 1, ' '  
   387 000016F7 430A020120                      db 67, 10, 2, 1, ' '   
   388 000016FC 490A040120                      db 73, 10, 4, 1, ' ' 
   389                                  
   390                                      level1_blocks_count equ 78   ; Cantidad total de bloques
   391                                  
   392                                      ; Nivel 2: Bloques de prueba
   393                                      level2_blocks:
   394 00001701 0103040120                      db 1, 3, 4, 1, ' '
   395                                  
   396 00001706 0104030120                      db 1, 4, 3, 1, ' '   
   397 0000170B 0704040120                      db 7, 4, 4, 1, ' '   
   398                                                  
   399 00001710 0105020120                      db 1, 5, 2, 1, ' '   
   400 00001715 0705030120                      db 7, 5, 3, 1, ' '
   401 0000171A 0D05040120                      db 13, 5, 4, 1, ' '
   402                                  
   403 0000171F 0106010120                      db 1, 6, 1, 1, ' '   
   404 00001724 0706020120                      db 7, 6, 2, 1, ' '
   405 00001729 0D06030120                      db 13, 6, 3, 1, ' '
   406 0000172E 1306040120                      db 19, 6, 4, 1, ' '   
   407                                  
   408 00001733 0107040120                      db 1, 7, 4, 1, ' '   
   409 00001738 0707010120                      db 7, 7, 1, 1, ' '
   410 0000173D 0D07020120                      db 13, 7, 2, 1, ' '
   411 00001742 1307030120                      db 19, 7, 3, 1, ' '  
   412 00001747 1907040120                      db 25, 7, 4, 1, ' '   
   413                                  
   414 0000174C 0108030120                      db 1, 8, 3, 1, ' '   
   415 00001751 0708040120                      db 7, 8, 4, 1, ' '
   416 00001756 0D08010120                      db 13, 8, 1, 1, ' '
   417 0000175B 1308020120                      db 19, 8, 2, 1, ' '  
   418 00001760 1908030120                      db 25, 8, 3, 1, ' ' 
   419 00001765 1F08040120                      db 31, 8, 4, 1, ' '   
   420                                  
   421 0000176A 0109020120                      db 1, 9, 2, 1, ' '   
   422 0000176F 0709030120                      db 7, 9, 3, 1, ' '
   423 00001774 0D09040120                      db 13, 9, 4, 1, ' '
   424 00001779 1309010120                      db 19, 9, 1, 1, ' '  
   425 0000177E 1909020120                      db 25, 9, 2, 1, ' ' 
   426 00001783 1F09030120                      db 31, 9, 3, 1, ' ' 
   427 00001788 2509040120                      db 37, 9, 4, 1, ' '   
   428                                  
   429 0000178D 010A010120                      db 1, 10, 1, 1, ' '   
   430 00001792 070A020120                      db 7, 10, 2, 1, ' '
   431 00001797 0D0A030120                      db 13, 10, 3, 1, ' '
   432 0000179C 130A040120                      db 19, 10, 4, 1, ' '  
   433 000017A1 190A010120                      db 25, 10, 1, 1, ' ' 
   434 000017A6 1F0A020120                      db 31, 10, 2, 1, ' ' 
   435 000017AB 250A030120                      db 37, 10, 3, 1, ' '  
   436 000017B0 2B0A040120                      db 43, 10, 4, 1, ' '   
   437                                  
   438 000017B5 010B040120                      db 1, 11, 4, 1, ' '   
   439 000017BA 070B010120                      db 7, 11, 1, 1, ' '
   440 000017BF 0D0B020120                      db 13, 11, 2, 1, ' '
   441 000017C4 130B030120                      db 19, 11, 3, 1, ' '  
   442 000017C9 190B040120                      db 25, 11, 4, 1, ' ' 
   443 000017CE 1F0B010120                      db 31, 11, 1, 1, ' ' 
   444 000017D3 250B020120                      db 37, 11, 2, 1, ' '  
   445 000017D8 2B0B030120                      db 43, 11, 3, 1, ' ' 
   446 000017DD 310B040120                      db 49, 11, 4, 1, ' '   
   447                                  
   448 000017E2 010C030120                      db 1, 12, 3, 1, ' '   
   449 000017E7 070C040120                      db 7, 12, 4, 1, ' '
   450 000017EC 0D0C010120                      db 13, 12, 1, 1, ' '
   451 000017F1 130C020120                      db 19, 12, 2, 1, ' '  
   452 000017F6 190C030120                      db 25, 12, 3, 1, ' ' 
   453 000017FB 1F0C040120                      db 31, 12, 4, 1, ' ' 
   454 00001800 250C010120                      db 37, 12, 1, 1, ' '  
   455 00001805 2B0C020120                      db 43, 12, 2, 1, ' ' 
   456 0000180A 310C030120                      db 49, 12, 3, 1, ' '
   457 0000180F 370C040120                      db 55, 12, 4, 1, ' '   
   458                                  
   459 00001814 010D020120                      db 1, 13, 2, 1, ' '   
   460 00001819 070D030120                      db 7, 13, 3, 1, ' '
   461 0000181E 0D0D040120                      db 13, 13, 4, 1, ' '
   462 00001823 130D010120                      db 19, 13, 1, 1, ' '  
   463 00001828 190D020120                      db 25, 13, 2, 1, ' ' 
   464 0000182D 1F0D030120                      db 31, 13, 3, 1, ' ' 
   465 00001832 250D040120                      db 37, 13, 4, 1, ' '  
   466 00001837 2B0D010120                      db 43, 13, 1, 1, ' ' 
   467 0000183C 310D020120                      db 49, 13, 2, 1, ' '
   468 00001841 370D030120                      db 55, 13, 3, 1, ' ' 
   469 00001846 3D0D040120                      db 61, 13, 4, 1, ' '   
   470                                  
   471 0000184B 010E010120                      db 1, 14, 1, 1, ' '   
   472 00001850 070E020120                      db 7, 14, 2, 1, ' '
   473 00001855 0D0E030120                      db 13, 14, 3, 1, ' '
   474 0000185A 130E040120                      db 19, 14, 4, 1, ' '  
   475 0000185F 190E010120                      db 25, 14, 1, 1, ' ' 
   476 00001864 1F0E020120                      db 31, 14, 2, 1, ' ' 
   477 00001869 250E030120                      db 37, 14, 3, 1, ' '  
   478 0000186E 2B0E040120                      db 43, 14, 4, 1, ' ' 
   479 00001873 310E010120                      db 49, 14, 1, 1, ' '
   480 00001878 370E020120                      db 55, 14, 2, 1, ' ' 
   481 0000187D 3D0E030120                      db 61, 14, 3, 1, ' '  
   482 00001882 430E040120                      db 67, 14, 4, 1, ' '   
   483                                  
   484 00001887 010F050220                      db 1, 15, 5, 2, ' '   
   485 0000188C 070F050220                      db 7, 15, 5, 2, ' '
   486 00001891 0D0F050220                      db 13, 15, 5, 2, ' '
   487 00001896 130F050220                      db 19, 15, 5, 2, ' '  
   488 0000189B 190F050220                      db 25, 15, 5, 2, ' ' 
   489 000018A0 1F0F050220                      db 31, 15, 5, 2, ' ' 
   490 000018A5 250F050220                      db 37, 15, 5, 2, ' '  
   491 000018AA 2B0F050220                      db 43, 15, 5, 2, ' ' 
   492 000018AF 310F050220                      db 49, 15, 5, 2, ' '
   493 000018B4 370F050220                      db 55, 15, 5, 2, ' ' 
   494 000018B9 3D0F050220                      db 61, 15, 5, 2, ' '  
   495 000018BE 430F050220                      db 67, 15, 5, 2, ' '
   496 000018C3 490F040120                      db 73, 15, 4, 1, ' '   
   497                                         
   498                                  
   499                                      level2_blocks_count equ 91
   500                                  
   501                                      ; Nivel 3
   502                                      level3_blocks:
   503 000018C8 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   504                                  
   505                                      level3_blocks_count equ 1
   506                                  
   507                                      ; Nivel 4
   508                                      level4_blocks:
   509 000018CD 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   510                                      level4_blocks_count equ 1
   511                                  
   512                                      ; Nivel 5
   513                                      level5_blocks:
   514 000018D2 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   515                                      level5_blocks_count equ 1
   516                                  
   517                                      ; Array para mantener el estado de los bloques
   518 000018D7 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   519                                  
   520                                      
   521                                      ; Variables para almacenar los valores
   522 0000193B 0000000000000000            current_score dq 0          ; Score actual
   523 00001943 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   524                                      
   525                                      ; Buffer para convertir números a string
   526 00001944 00<rep 14h>                 number_buffer: times 20 db 0
   527                                  
   528 00001958 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   529                                      
   530                                      ; Estructura para los enemigos (x, y, activo)
   531 0000195D 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   532 0000197B 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   533                                      
   534 0000197C 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   535 00001984 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   536 00001985 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   537 00001986 00                          enemy_move_total db 0      ; Contador total de movimientos
   538 00001987 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   539 00001988 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   540                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   541                                      ; Añade esto en la sección .dataa
   542 00001989 00000006080A0C0E10-         level1_spawn_points: db 0, 0, 0, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   542 00001992 12                 
   543 00001993 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   543 0000199C 13                 
   544 0000199D 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   544 000019A6 1B                 
   545 000019A7 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   545 000019B0 1C                 
   546 000019B1 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   546 000019BA 2D                 
   547                                          ; Arreglo de punteros a los spawn points de cada nivel
   548                                      spawn_points_table:
   549 000019BB [8919000000000000]              dq level1_spawn_points
   550 000019C3 [9319000000000000]              dq level2_spawn_points
   551 000019CB [9D19000000000000]              dq level3_spawn_points
   552 000019D3 [A719000000000000]              dq level4_spawn_points
   553 000019DB [B119000000000000]              dq level5_spawn_points
   554                                  
   555                                      ; Variables para el comportamiento de enemigos
   556 000019E3 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   557 000019E4 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   558 000019E5 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   559 000019E6 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   560                                  
   561 000019F0 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   561 000019F9 5B2020202020202020-
   561 00001A02 20205D0A0D         
   562                                      score_label_len: equ $ - score_label
   563 00001A07 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   563 00001A10 657374727569646F73-
   563 00001A19 3A205B2020205D0A0D 
   564                                      blocks_label_len: equ $ - blocks_label
   565                                      
   566                                      ; Posición donde insertar los números en los labels
   567                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   568                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   569                                      
   570                                      ; Definición de las vidas (x, y, estado)
   571                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   572                                      lives_data: 
   573 00001A22 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   574 00001A25 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   575 00001A28 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   576 00001A2B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   577 00001A2E 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   578 00001A31 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   579 00001A34 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   580                                      lives_count equ 7    ; Total de vidas
   581 00001A37 5E                          life_char db "^"    
   582 00001A38 07                          current_lives db 7   ; Contador de vidas activas actual
   583                                  
   584                                  ; Estructura para almacenar las letras y sus posiciones
   585                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   586 00001A39 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   587 00001BC9 00                          letters_count db 0   
   588 00001BCA 20                          last_letter db ' '    ; Variable para almacenar la última letra
   589 00001BCB 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   589 00001BD4 75616C3A205B205D0A-
   589 00001BDD 0D                 
   590                                      last_letter_msg_len equ $ - last_letter_msg
   591 00001BDE 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   592 00001BDF 07                          max_lives db 7              ; Máximo número de vidas permitidas
   593 00001BE0 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   594 00001BE8 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   595 00001BF0 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   596                                  
   597 00001BF8 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   598 00001BF9 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   599 00001BFA 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
   600 00001BFB 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
   601                                  
   602 00001BFC 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   603 00001C04 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   604                                  
   605 00001C05 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   606 00001C06 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   607 00001C07 00                          laser_count: db 0                ; Contador de láseres activos
   608 00001C08 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   609 00001CD0 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   610                                  
   611                                      balls_data:     ; Array para almacenar hasta 3 bolas
   612                                          ; Bola 1 (principal)
   613 00001CD8 0000000000000000                dq 0        ; x_pos
   614 00001CE0 0000000000000000                dq 0        ; y_pos
   615 00001CE8 0100000000000000                dq 1        ; direction_x
   616 00001CF0 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   617 00001CF8 01                              db 1        ; active
   618                                          ; Bola 2
   619 00001CF9 0000000000000000                dq 0        ; x_pos
   620 00001D01 0000000000000000                dq 0        ; y_pos
   621 00001D09 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   622 00001D11 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   623 00001D19 00                              db 0        ; active
   624                                          ; Bola 3
   625 00001D1A 0000000000000000                dq 0        ; x_pos
   626 00001D22 0000000000000000                dq 0        ; y_pos
   627 00001D2A 0000000000000000                dq 0        ; direction_x
   628 00001D32 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   629 00001D3A 00                              db 0        ; active
   630                                      
   631 00001D3B 01                          balls_count db 1     ; Contador de bolas activas
   632                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   633 00001D3C 00<rep Ah>                  enemy_last_x:       times 10 db 0
   634 00001D46 00<rep Ah>                  enemy_last_y:       times 10 db 0
   635 00001D50 00<rep Ah>                  enemy_stuck_count:  times 10 db 0
   636                                  
   637                                  section .text
   638                                  
   639                                  
   640                                  print_lives:
   641 000001DD 55                          push rbp
   642 000001DE 4889E5                      mov rbp, rsp
   643                                      
   644 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   645                                      
   646                                      .print_loop:
   647 000001E4 4983FC07                        cmp r12, lives_count
   648 000001E8 7D45                            jge .end
   649                                          
   650                                          ; Calcular offset de la vida actual
   651 000001EA 4C89E0                          mov rax, r12
   652 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   653 000001F1 488DB0[221A0000]                lea rsi, [lives_data + rax]
   654                                          
   655                                          ; Calcular posición en el tablero
   656 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   657 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   658                                          
   659                                          ; Calcular offset en el tablero
   660 00000201 B850000000                      mov rax, column_cells
   661 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   662 0000020A 49F7E1                          mul r9
   663 0000020D 4C01C0                          add rax, r8
   664 00000210 488DB8[400A0000]                lea rdi, [board + rax]
   665                                          
   666                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   667 00000217 807E0201                        cmp byte [rsi + 2], 1
   668 0000021B 7405                            je .draw_active
   669                                          
   670                                          ; Si está inactiva, dibujar espacio
   671 0000021D C60720                          mov byte [rdi], ' '
   672 00000220 EB08                            jmp .next_life
   673                                          
   674                                      .draw_active:
   675                                          ; Si está activa, dibujar el símbolo de vida
   676 00000222 8A05(371A0000)                  mov al, [life_char]
   677 00000228 8807                            mov [rdi], al
   678                                          
   679                                      .next_life:
   680 0000022A 49FFC4                          inc r12
   681 0000022D EBB5                            jmp .print_loop
   682                                          
   683                                      .end:
   684 0000022F 5D                              pop rbp
   685 00000230 C3                              ret
   686                                  
   687                                  ; Función para desactivar una vida
   688                                  ; Función modificada para perder una vida
   689                                  ; Modificar lose_life para reiniciar solo la bola principal
   690                                  lose_life:
   691 00000231 55                          push rbp
   692 00000232 4889E5                      mov rbp, rsp
   693                                      
   694                                      ; Verificar si aún quedan vidas
   695 00000235 803D(381A0000)00            cmp byte [current_lives], 0
   696 0000023C 0F84AB000000                je .game_lost
   697                                      
   698                                      ; Encontrar la última vida activa
   699 00000242 B907000000                  mov rcx, lives_count
   700 00000247 48FFC9                      dec rcx
   701                                      
   702                                      .find_active_life:
   703 0000024A 4889C8                          mov rax, rcx
   704 0000024D 486BC003                        imul rax, 3
   705 00000251 488DB0[221A0000]                lea rsi, [lives_data + rax]
   706 00000258 807E0201                        cmp byte [rsi + 2], 1
   707 0000025C 740A                            je .deactivate_life
   708 0000025E 48FFC9                          dec rcx
   709 00000261 79E7                            jns .find_active_life
   710 00000263 E985000000                      jmp .game_lost
   711                                          
   712                                      .deactivate_life:
   713                                          ; Borrar vida visualmente y en datos
   714 00000268 4C0FB606                        movzx r8, byte [rsi]
   715 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   716 00000271 B850000000                      mov rax, column_cells
   717 00000276 4883C002                        add rax, 2
   718 0000027A 49F7E1                          mul r9
   719 0000027D 4C01C0                          add rax, r8
   720 00000280 488DB8[400A0000]                lea rdi, [board + rax]
   721 00000287 C60720                          mov byte [rdi], ' '
   722 0000028A C6460200                        mov byte [rsi + 2], 0
   723 0000028E FE0D(381A0000)                  dec byte [current_lives]
   724                                          
   725                                          ; Borrar paleta anterior
   726 00000294 4C8B05(BF140000)                mov r8, [pallet_position]
   727 0000029B 488B0D(C7140000)                mov rcx, [pallet_size]
   728                                          .erase_pallet_loop:
   729 000002A2 41C60020                            mov byte [r8], ' '
   730 000002A6 49FFC0                              inc r8
   731 000002A9 48FFC9                              dec rcx
   732 000002AC 75F4                                jnz .erase_pallet_loop
   733                                          
   734                                          ; Reiniciar solo la bola principal
   735 000002AE 48C705(DF140000)28-             mov qword [ball_x_pos], 40
   735 000002B6 000000             
   736 000002B9 48C705(E7140000)1C-             mov qword [ball_y_pos], 28
   736 000002C1 000000             
   737 000002C4 C605(FF140000)00                mov byte [ball_moving], 0
   738 000002CB C605(00150000)01                mov byte [ball_active], 1       ; Activar bola principal
   739 000002D2 48C705(BF140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   739 000002D9 [B0130000]         
   740                                          
   741                                          ; Asegurarse que las otras bolas están desactivadas
   742 000002DD C605(22150000)00                mov byte [ball2_active], 0
   743 000002E4 C605(44150000)00                mov byte [ball3_active], 0
   744                                          
   745 000002EB EB07                            jmp .end
   746                                          
   747                                      .game_lost:
   748 000002ED E8C7000000                      call game_lost
   749 000002F2 EB00                            jmp .end
   750                                          
   751                                      .end:
   752 000002F4 5D                              pop rbp
   753 000002F5 C3                              ret
   754                                  ; Función modificada para verificar colisión con el borde inferior
   755                                  check_bottom_collision:
   756 000002F6 55                          push rbp
   757 000002F7 4889E5                      mov rbp, rsp
   758                                      
   759                                      ; Verificar bola principal
   760 000002FA 803D(00150000)01            cmp byte [ball_active], 1
   761 00000301 7542                        jne .check_ball2
   762 00000303 488B05(E7140000)            mov rax, [ball_y_pos]
   763 0000030A 4883F81E                    cmp rax, row_cells - 2
   764 0000030E 7535                        jne .check_ball2
   765                                      
   766                                      ; Borrar visualmente la bola principal
   767 00000310 4C8B05(DF140000)            mov r8, [ball_x_pos]
   768 00000317 4C8B0D(E7140000)            mov r9, [ball_y_pos]
   769 0000031E 4981C0[400A0000]            add r8, board
   770 00000325 4C89C9                      mov rcx, r9
   771 00000328 B852000000                  mov rax, column_cells + 2
   772 0000032D 48F7E9                      imul rcx
   773 00000330 4901C0                      add r8, rax
   774 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   775                                      
   776 00000337 C605(00150000)00            mov byte [ball_active], 0
   777 0000033E C605(FF140000)00            mov byte [ball_moving], 0
   778                                  
   779                                  .check_ball2:
   780 00000345 803D(22150000)01            cmp byte [ball2_active], 1
   781 0000034C 751B                        jne .check_ball3
   782 0000034E 488B05(09150000)            mov rax, [ball2_y_pos]
   783 00000355 4883F81E                    cmp rax, row_cells - 2
   784 00000359 750E                        jne .check_ball3
   785 0000035B C605(22150000)00            mov byte [ball2_active], 0
   786 00000362 C605(21150000)00            mov byte [ball2_moving], 0
   787                                  
   788                                  .check_ball3:
   789 00000369 803D(44150000)01            cmp byte [ball3_active], 1
   790 00000370 751B                        jne .check_active_balls
   791 00000372 488B05(2B150000)            mov rax, [ball3_y_pos]
   792 00000379 4883F81E                    cmp rax, row_cells - 2
   793 0000037D 750E                        jne .check_active_balls
   794 0000037F C605(44150000)00            mov byte [ball3_active], 0
   795 00000386 C605(43150000)00            mov byte [ball3_moving], 0
   796                                  
   797                                  .check_active_balls:
   798                                      ; Verificar si quedan bolas activas
   799 0000038D 4831C9                      xor rcx, rcx
   800 00000390 803D(00150000)01            cmp byte [ball_active], 1
   801 00000397 741E                        je .balls_remain
   802 00000399 803D(22150000)01            cmp byte [ball2_active], 1
   803 000003A0 7415                        je .balls_remain
   804 000003A2 803D(44150000)01            cmp byte [ball3_active], 1
   805 000003A9 740C                        je .balls_remain
   806                                      
   807                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   808 000003AB E881FEFFFF                  call lose_life
   809 000003B0 C605(00150000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   810                                      
   811                                  .balls_remain:
   812 000003B7 5D                          pop rbp
   813 000003B8 C3                          ret
   814                                  
   815                                  
   816                                  
   817                                  ; Nueva función para game over
   818                                  game_lost:
   819                                      ; Limpiar la pantalla
   820                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   821                                      
   822                                      ; Mostrar mensaje de derrota
   823                                      section .data
   824 00001D5A C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   824 00001D63 6469646F210A0D     
   825                                          lost_msg_len: equ $ - lost_msg
   826                                      section .text
   827                                      
   828                                      ; Imprimir mensaje de derrota
   829                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [5A1D000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   830                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [881D000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   831                                      
   832                                      ; Mostrar puntaje final
   833 0000040A 488B05(3B190000)            mov rax, [current_score]
   834 00000411 48BF-                       mov rdi, number_buffer
   834 00000413 [4419000000000000] 
   835 0000041B E846130000                  call number_to_string
   836                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [4419000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   837                                      
   838                                      ; Esperar un momento antes de salir
   839 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   839 00000444 0000               
   840 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   840 0000044F 0000               
   841                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   842                                      
   843 00000464 E9111D0000                  jmp exit
   844                                  
   845                                  
   846                                  ; Función para registrar una nueva letra en el mapa
   847                                  ; Entrada:
   848                                  ;   al - letra a registrar
   849                                  ;   r8b - posición x
   850                                  ;   r9b - posición y
   851                                  register_letter:
   852 00000469 55                          push rbp
   853 0000046A 4889E5                      mov rbp, rsp
   854 0000046D 53                          push rbx
   855 0000046E 51                          push rcx
   856                                      
   857 0000046F 3C20                        cmp al, ' '
   858 00000471 7438                        je .end
   859                                  
   860                                      ; Encontrar un espacio libre en el mapa
   861 00000473 4831C9                      xor rcx, rcx
   862 00000476 480FB615(C91B0000)          movzx rdx, byte [letters_count]
   863                                      
   864                                      .find_slot:
   865 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   866 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   867                                          
   868 00000484 488D1C8D[391A0000]              lea rbx, [letters_map + rcx * 4]
   869 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   870 00000490 7405                            je .found_slot
   871                                          
   872 00000492 48FFC1                          inc rcx
   873 00000495 EBE7                            jmp .find_slot
   874                                          
   875                                      .found_slot:
   876                                          ; Guardar la información de la letra
   877 00000497 448803                          mov [rbx], r8b           ; x
   878 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   879 0000049E 884302                          mov [rbx + 2], al        ; letra
   880 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   881                                          
   882 000004A5 FE05(C91B0000)                  inc byte [letters_count]
   883                                          
   884                                      .end:
   885 000004AB 59                              pop rcx
   886 000004AC 5B                              pop rbx
   887 000004AD 5D                              pop rbp
   888 000004AE C3                              ret
   889                                  
   890                                  ; Función para imprimir todas las letras registradas
   891                                  print_letters:
   892 000004AF 55                          push rbp
   893 000004B0 4889E5                      mov rbp, rsp
   894 000004B3 53                          push rbx
   895 000004B4 51                          push rcx
   896                                      
   897 000004B5 4831C9                      xor rcx, rcx
   898                                      
   899                                      .print_loop:
   900 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   901 000004BC 7D37                            jge .end
   902                                          
   903                                          ; Obtener puntero a la letra actual
   904 000004BE 488D1C8D[391A0000]              lea rbx, [letters_map + rcx * 4]
   905                                          
   906                                          ; Verificar si está activa
   907 000004C6 807B0300                        cmp byte [rbx + 3], 0
   908 000004CA 7424                            je .next_letter
   909                                          
   910                                          ; Calcular posición en el tablero
   911 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   912 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   913                                          
   914                                          ; Calcular offset en el tablero
   915 000004D5 B850000000                      mov rax, column_cells
   916 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   917 000004DE 49F7E1                          mul r9
   918 000004E1 4C01C0                          add rax, r8
   919 000004E4 488DB8[400A0000]                lea rdi, [board + rax]
   920                                          
   921                                          ; Imprimir la letra
   922 000004EB 8A4302                          mov al, [rbx + 2]
   923 000004EE 8807                            mov [rdi], al
   924                                          
   925                                      .next_letter:
   926 000004F0 48FFC1                          inc rcx
   927 000004F3 EBC3                            jmp .print_loop
   928                                          
   929                                      .end:
   930 000004F5 59                              pop rcx
   931 000004F6 5B                              pop rbx
   932 000004F7 5D                              pop rbp
   933 000004F8 C3                              ret
   934                                  
   935                                  ; Función para borrar una letra específica
   936                                  ; Entrada:
   937                                  ;   r8b - posición x
   938                                  ;   r9b - posición y
   939                                  remove_letter:
   940 000004F9 55                          push rbp
   941 000004FA 4889E5                      mov rbp, rsp
   942 000004FD 53                          push rbx
   943 000004FE 51                          push rcx
   944                                      
   945 000004FF 4831C9                      xor rcx, rcx
   946                                      
   947                                      .find_loop:
   948 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   949 00000506 7D2E                            jge .end
   950                                          
   951 00000508 488D1C8D[391A0000]              lea rbx, [letters_map + rcx * 4]
   952                                          
   953                                          ; Verificar si está activa y coincide la posición
   954 00000510 807B0300                        cmp byte [rbx + 3], 0
   955 00000514 741B                            je .next_letter
   956                                          
   957 00000516 8A03                            mov al, [rbx]
   958 00000518 4438C0                          cmp al, r8b
   959 0000051B 7514                            jne .next_letter
   960                                          
   961 0000051D 8A4301                          mov al, [rbx + 1]
   962 00000520 4438C8                          cmp al, r9b
   963 00000523 750C                            jne .next_letter
   964                                          
   965                                          ; Encontrada la letra, desactivarla
   966 00000525 C6430300                        mov byte [rbx + 3], 0
   967 00000529 FE0D(C91B0000)                  dec byte [letters_count]
   968 0000052F EB05                            jmp .end
   969                                          
   970                                      .next_letter:
   971 00000531 48FFC1                          inc rcx
   972 00000534 EBCC                            jmp .find_loop
   973                                          
   974                                      .end:
   975 00000536 59                              pop rcx
   976 00000537 5B                              pop rbx
   977 00000538 5D                              pop rbp
   978 00000539 C3                              ret
   979                                  ; Función para mover las letras hacia abajo
   980                                  move_letters:
   981 0000053A 55                          push rbp
   982 0000053B 4889E5                      mov rbp, rsp
   983 0000053E 53                          push rbx
   984 0000053F 57                          push rdi
   985 00000540 56                          push rsi
   986 00000541 4150                        push r8
   987 00000543 4151                        push r9
   988 00000545 4152                        push r10
   989 00000547 4153                        push r11
   990                                  
   991 00000549 4831C9                      xor rcx, rcx
   992                                  
   993                                      .move_loop:
   994 0000054C 4883F964                        cmp rcx, 100
   995 00000550 0F8D0D020000                    jge .print_last_letter
   996                                          
   997 00000556 488D1C8D[391A0000]              lea rbx, [letters_map + rcx * 4]
   998 0000055E 807B0300                        cmp byte [rbx + 3], 0
   999 00000562 0F84F3010000                    je .next_letter
  1000                                  
  1001 00000568 4C0FB603                        movzx r8, byte [rbx]
  1002 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
  1003                                  
  1004 00000571 B850000000                      mov rax, column_cells
  1005 00000576 4883C002                        add rax, 2
  1006 0000057A 49F7E1                          mul r9
  1007 0000057D 4C01C0                          add rax, r8
  1008 00000580 488DB8[400A0000]                lea rdi, [board + rax]
  1009 00000587 C60720                          mov byte [rdi], ' '
  1010                                  
  1011 0000058A FE4301                          inc byte [rbx + 1]
  1012 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
  1013                                  
  1014 00000592 4983F91F                        cmp r9, row_cells - 1
  1015 00000596 7C09                            jl .check_pallet_collision
  1016                                  
  1017 00000598 C6430300                        mov byte [rbx + 3], 0
  1018 0000059C E9BA010000                      jmp .next_letter
  1019                                  
  1020                                          .check_pallet_collision:
  1021 000005A1 B850000000                          mov rax, column_cells
  1022 000005A6 4883C002                            add rax, 2
  1023 000005AA 49F7E1                              mul r9
  1024 000005AD 4C01C0                              add rax, r8
  1025 000005B0 488DB8[400A0000]                    lea rdi, [board + rax]
  1026                                  
  1027 000005B7 8A07                                mov al, [rdi]
  1028 000005B9 3C20                                cmp al, ' '
  1029 000005BB 0F849A010000                        je .next_letter
  1030 000005C1 3C3D                                cmp al, char_equal
  1031 000005C3 740A                                je .capture_letter
  1032                                  
  1033 000005C5 8A4302                              mov al, [rbx + 2]
  1034 000005C8 8807                                mov [rdi], al
  1035 000005CA E98C010000                          jmp .next_letter
  1036                                  
  1037                                          .capture_letter:
  1038                                              ; Obtener la nueva letra
  1039 000005CF 8A4302                              mov al, [rbx + 2]
  1040                                              
  1041                                              ; Comparar con la última letra
  1042 000005D2 3A05(CA1B0000)                      cmp al, [last_letter]
  1043 000005D8 7407                                je .same_letter
  1044                                              
  1045                                              ; Es una letra diferente, resetear el procesamiento
  1046 000005DA C605(DE1B0000)00                    mov byte [current_power_processed], 0
  1047                                              
  1048                                              .same_letter:
  1049                                              ; Guardar la nueva letra
  1050 000005E1 8805(CA1B0000)                      mov [last_letter], al
  1051                                              
  1052                                              ; Verificar si es 'E' para extender la paleta
  1053 000005E7 3C45                                cmp al, 'E'
  1054 000005E9 7450                                je .extend_pallet
  1055                                              
  1056                                              ; Verificar si es 'P' para añadir vida
  1057 000005EB 3C50                                cmp al, 'P'
  1058 000005ED 7478                                je .check_add_life
  1059                                  
  1060 000005EF 3C53                                cmp al, 'S'
  1061 000005F1 0F84B4000000                        je .slow_ball
  1062                                  
  1063 000005F7 3C43                                cmp al, 'C'
  1064 000005F9 0F84D8000000                        je .activate_catch
  1065                                              
  1066 000005FF 3C4C                                cmp al, 'L'
  1067 00000601 0F84F9000000                        je .activate_laser
  1068                                  
  1069 00000607 3C44                                cmp al, 'D'
  1070 00000609 0F841A010000                        je .activate_split
  1071                                  
  1072                                              ; Si no es ningún power-up, restaurar tamaño normal
  1073 0000060F 488B05(CF140000)                    mov rax, [default_pallet_size]
  1074 00000616 488905(C7140000)                    mov [pallet_size], rax
  1075 0000061D 48C705(E01B0000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1075 00000625 000000             
  1076 00000628 C605(F81B0000)00                    mov byte [catch_power_active], 0
  1077 0000062F C605(051C0000)00                    mov byte [laser_power_active], 0
  1078 00000636 E91C010000                          jmp .finish_capture
  1079                                  
  1080                                              .extend_pallet:
  1081 0000063B C605(051C0000)00                        mov byte [laser_power_active], 0
  1082 00000642 C605(F81B0000)00                        mov byte [catch_power_active], 0
  1083 00000649 48C705(E01B0000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1083 00000651 000000             
  1084 00000654 488B05(D7140000)                        mov rax, [extended_pallet_size]
  1085 0000065B 488905(C7140000)                        mov [pallet_size], rax
  1086 00000662 E9F0000000                              jmp .finish_capture
  1087                                  
  1088                                              .check_add_life:
  1089 00000667 C605(051C0000)00                        mov byte [laser_power_active], 0
  1090 0000066E C605(F81B0000)00                        mov byte [catch_power_active], 0
  1091 00000675 488B05(CF140000)                        mov rax, [default_pallet_size]
  1092 0000067C 488905(C7140000)                        mov [pallet_size], rax
  1093 00000683 48C705(E01B0000)01-                     mov qword [ball_speed], 1 
  1093 0000068B 000000             
  1094                                                  ; Verificar si ya procesamos este power-up
  1095 0000068E 803D(DE1B0000)00                        cmp byte [current_power_processed], 0
  1096 00000695 0F85BC000000                            jne .finish_capture
  1097                                                  
  1098                                                  ; Preservar registros importantes
  1099 0000069B 51                                      push rcx
  1100 0000069C 53                                      push rbx
  1101                                                  
  1102                                                  ; Marcar como procesado
  1103 0000069D C605(DE1B0000)01                        mov byte [current_power_processed], 1
  1104                                                  
  1105                                                  ; Añadir una vida
  1106 000006A4 E838040000                              call add_life
  1107                                                  
  1108                                                  ; Restaurar registros
  1109 000006A9 5B                                      pop rbx
  1110 000006AA 59                                      pop rcx
  1111                                                  
  1112                                              .slow_ball:
  1113 000006AB C605(051C0000)00                        mov byte [laser_power_active], 0
  1114 000006B2 C605(F81B0000)00                        mov byte [catch_power_active], 0                
  1115 000006B9 488B05(CF140000)                        mov rax, [default_pallet_size]
  1116 000006C0 488905(C7140000)                        mov [pallet_size], rax
  1117 000006C7 48C705(E01B0000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
  1117 000006CF 000000             
  1118 000006D2 E980000000                              jmp .finish_capture
  1119                                  
  1120                                              .activate_catch:
  1121 000006D7 C605(051C0000)00                        mov byte [laser_power_active], 0
  1122 000006DE 488B05(CF140000)                        mov rax, [default_pallet_size]
  1123 000006E5 488905(C7140000)                        mov [pallet_size], rax
  1124 000006EC 48C705(E01B0000)01-                     mov qword [ball_speed], 1
  1124 000006F4 000000             
  1125 000006F7 C605(F81B0000)01                        mov byte [catch_power_active], 1
  1126 000006FE EB57                                    jmp .finish_capture
  1127                                  
  1128                                              .activate_laser:
  1129 00000700 C605(F81B0000)00                        mov byte [catch_power_active], 0
  1130 00000707 488B05(CF140000)                        mov rax, [default_pallet_size]
  1131 0000070E 488905(C7140000)                        mov [pallet_size], rax
  1132 00000715 48C705(E01B0000)01-                     mov qword [ball_speed], 1
  1132 0000071D 000000             
  1133 00000720 C605(051C0000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
  1134 00000727 EB2E                                    jmp .finish_capture
  1135                                  
  1136                                              .activate_split:
  1137 00000729 C605(051C0000)00                        mov byte [laser_power_active], 0
  1138 00000730 C605(F81B0000)00                        mov byte [catch_power_active], 0
  1139 00000737 488B05(CF140000)                        mov rax, [default_pallet_size]
  1140 0000073E 488905(C7140000)                        mov [pallet_size], rax
  1141 00000745 48C705(E01B0000)01-                     mov qword [ball_speed], 1 
  1141 0000074D 000000             
  1142 00000750 E8D2000000                              call activate_split_power
  1143 00000755 EB00                                    jmp .finish_capture
  1144                                  
  1145                                              .finish_capture:
  1146 00000757 C6430300                                mov byte [rbx + 3], 0
  1147                                  
  1148                                          .next_letter:
  1149 0000075B 48FFC1                              inc rcx
  1150 0000075E E9E9FDFFFF                          jmp .move_loop
  1151                                  
  1152                                      .print_last_letter:
  1153                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000763 B801000000          <1>  mov eax, sys_write
    83 00000768 BF01000000          <1>  mov edi, 1
    84 0000076D 48BE-               <1>  mov rsi, %1
    84 0000076F [CB1B000000000000]  <1>
    85 00000777 BA10000000          <1>  mov edx, %2
    86 0000077C 0F05                <1>  syscall
  1154 0000077E 8A05(CA1B0000)                  mov al, [last_letter]
  1155 00000784 8805(DA1B0000)                  mov [last_letter_msg + 15], al
  1156                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 0000078A B801000000          <1>  mov eax, sys_write
    83 0000078F BF01000000          <1>  mov edi, 1
    84 00000794 48BE-               <1>  mov rsi, %1
    84 00000796 [DB1B000000000000]  <1>
    85 0000079E BA03000000          <1>  mov edx, %2
    86 000007A3 0F05                <1>  syscall
  1157                                  
  1158                                      .end:
  1159 000007A5 415B                            pop r11
  1160 000007A7 415A                            pop r10
  1161 000007A9 4159                            pop r9
  1162 000007AB 4158                            pop r8
  1163 000007AD 5E                              pop rsi
  1164 000007AE 5F                              pop rdi
  1165 000007AF 5B                              pop rbx
  1166 000007B0 5D                              pop rbp
  1167 000007B1 C3                              ret
  1168                                  
  1169                                  
  1170                                  clear_lasers:
  1171 000007B2 55                          push rbp
  1172 000007B3 4889E5                      mov  rbp, rsp
  1173                                  
  1174                                      ; Recorrer el array de láseres
  1175 000007B6 4831C9                      xor rcx, rcx                ; Índice del láser
  1176 000007B9 480FB61D(071C0000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
  1177                                  
  1178                                      .clear_loop:
  1179 000007C1 4839D9                          cmp rcx, rbx
  1180 000007C4 7D2F                            jge .done                ; Salir si no quedan láseres
  1181                                  
  1182                                          ; Obtener posición del láser actual
  1183 000007C6 488DB409[081C0000]              lea rsi, [lasers + rcx * 2]
  1184 000007CE 4C0FB606                        movzx r8, byte [rsi]     ; X
  1185 000007D2 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1186                                  
  1187                                          ; Calcular posición en el tablero
  1188 000007D7 B850000000                      mov rax, column_cells
  1189 000007DC 4883C002                        add rax, 2
  1190 000007E0 49F7E1                          mul r9
  1191 000007E3 4C01C0                          add rax, r8
  1192 000007E6 488DB8[400A0000]                lea rdi, [board + rax]
  1193                                  
  1194                                          ; Borrar el láser visualmente
  1195 000007ED C60720                          mov byte [rdi], ' '
  1196                                  
  1197                                          ; Pasar al siguiente láser
  1198 000007F0 48FFC1                          inc rcx
  1199 000007F3 EBCC                            jmp .clear_loop
  1200                                  
  1201                                      .done:
  1202                                          ; Resetear contador de láseres
  1203 000007F5 C605(071C0000)00                mov byte [laser_count], 0
  1204                                  
  1205 000007FC 5D                              pop rbp
  1206 000007FD C3                              ret
  1207                                  
  1208                                  
  1209                                  ; Nueva función para actualizar los láseres
  1210                                  update_lasers:
  1211 000007FE 55                          push rbp
  1212 000007FF 4889E5                      mov rbp, rsp
  1213                                      
  1214                                      ; Verificar si el poder láser está activo
  1215 00000802 803D(051C0000)00            cmp byte [laser_power_active], 0
  1216 00000809 741A                        je .end
  1217                                      
  1218                                      ; Verificar si se presionó la tecla de espacio
  1219 0000080B 803D(041C0000)20            cmp byte [last_key], ' '
  1220 00000812 750C                        jne .skip_shooting
  1221                                      
  1222                                      ; Disparar nuevos láseres
  1223 00000814 E89A000000                  call shoot_lasers
  1224 00000819 C605(041C0000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1225                                      
  1226                                      .skip_shooting:
  1227                                      ; Mover los láseres existentes
  1228 00000820 E828010000                  call move_lasers
  1229                                      
  1230                                      .end:
  1231 00000825 5D                              pop rbp
  1232 00000826 C3                              ret
  1233                                  
  1234                                  activate_split_power:
  1235 00000827 55                          push rbp
  1236 00000828 4889E5                      mov rbp, rsp
  1237                                      
  1238                                      ; Verificar si la bola2 y bola3 ya están activas
  1239 0000082B 803D(22150000)01            cmp byte [ball2_active], 1
  1240 00000832 750B                        jne .enable_balls
  1241 00000834 803D(44150000)01            cmp byte [ball3_active], 1
  1242 0000083B 7502                        jne .enable_balls
  1243                                      
  1244                                      ; Si ambas ya están activas, no hacemos nada.
  1245 0000083D EB72                        jmp .end
  1246                                  
  1247                                  .enable_balls:
  1248                                      ; Copiamos la posición de la bola principal
  1249 0000083F 488B05(DF140000)            mov rax, [ball_x_pos]
  1250 00000846 488905(01150000)            mov [ball2_x_pos], rax
  1251 0000084D 488905(23150000)            mov [ball3_x_pos], rax
  1252                                  
  1253 00000854 488B05(E7140000)            mov rax, [ball_y_pos]
  1254 0000085B 488905(09150000)            mov [ball2_y_pos], rax
  1255 00000862 488905(2B150000)            mov [ball3_y_pos], rax
  1256                                  
  1257                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1258                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1259 00000869 48C705(11150000)FF-         mov qword [ball2_direction_x], -1
  1259 00000871 FFFFFF             
  1260 00000874 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  1260 0000087C FFFFFF             
  1261 0000087F C605(21150000)01            mov byte [ball2_moving], 1
  1262 00000886 C605(22150000)01            mov byte [ball2_active], 1
  1263                                  
  1264 0000088D 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  1264 00000895 000000             
  1265 00000898 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  1265 000008A0 FFFFFF             
  1266 000008A3 C605(43150000)01            mov byte [ball3_moving], 1
  1267 000008AA C605(44150000)01            mov byte [ball3_active], 1
  1268                                  
  1269                                  .end:
  1270 000008B1 5D                          pop rbp
  1271 000008B2 C3                          ret
  1272                                  
  1273                                  
  1274                                  shoot_lasers:
  1275 000008B3 55                          push rbp
  1276 000008B4 4889E5                      mov rbp, rsp
  1277 000008B7 53                          push rbx
  1278                                      
  1279                                      ; Verificar si hay espacio para más láseres
  1280 000008B8 480FB605(071C0000)          movzx rax, byte [laser_count]
  1281 000008C0 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1282 000008C4 0F8D80000000                jge .end
  1283                                      
  1284                                      ; Obtener posición de la paleta
  1285 000008CA 4C8B05(BF140000)            mov r8, [pallet_position]
  1286 000008D1 4981E8[400A0000]            sub r8, board                  ; Offset relativo de la paleta
  1287                                      
  1288                                      ; Calcular coordenadas x,y
  1289 000008D8 4C89C0                      mov rax, r8
  1290 000008DB 41B950000000                mov r9, column_cells
  1291 000008E1 4983C102                    add r9, 2                     ; Ancho total de línea
  1292 000008E5 4831D2                      xor rdx, rdx
  1293 000008E8 49F7F1                      div r9                        ; rax = y, rdx = x
  1294                                      
  1295                                      ; Guardar coordenadas
  1296 000008EB 4989C2                      mov r10, rax                  ; Y en r10
  1297 000008EE 4989D3                      mov r11, rdx                  ; X en r11
  1298                                      
  1299                                      ; Validar coordenadas
  1300 000008F1 4983FA00                    cmp r10, 0
  1301 000008F5 7C53                        jl .end
  1302 000008F7 4983FA20                    cmp r10, row_cells
  1303 000008FB 7D4D                        jge .end
  1304 000008FD 4983FB00                    cmp r11, 0
  1305 00000901 7C47                        jl .end
  1306 00000903 4983FB50                    cmp r11, column_cells
  1307 00000907 7D41                        jge .end
  1308                                      
  1309                                      ; Calcular índice para el primer láser
  1310 00000909 480FB61D(071C0000)          movzx rbx, byte [laser_count]
  1311 00000911 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1312                                      
  1313                                      ; Primer láser (izquierda)
  1314 00000915 488DBB[081C0000]            lea rdi, [lasers + rbx]
  1315 0000091C 44881F                      mov [rdi], r11b              ; X
  1316 0000091F 4488D0                      mov al, r10b
  1317 00000922 FEC8                        dec al                       ; Y - 1
  1318 00000924 884701                      mov [rdi + 1], al           ; Y
  1319                                      
  1320                                      ; Segundo láser (derecha)
  1321 00000927 4488D8                      mov al, r11b
  1322 0000092A 0205(C7140000)              add al, byte [pallet_size]
  1323 00000930 FEC8                        dec al                       ; Ajustar para el último carácter
  1324 00000932 488DBB[0A1C0000]            lea rdi, [lasers + rbx + 2]
  1325 00000939 8807                        mov [rdi], al               ; X
  1326 0000093B 4488D0                      mov al, r10b
  1327 0000093E FEC8                        dec al                      ; Y - 1
  1328 00000940 884701                      mov [rdi + 1], al          ; Y
  1329                                      
  1330                                      ; Incrementar contador de láseres
  1331 00000943 8005(071C0000)02            add byte [laser_count], 2
  1332                                      
  1333                                      
  1334                                      .end:
  1335 0000094A 5B                              pop rbx
  1336 0000094B 5D                              pop rbp
  1337 0000094C C3                              ret
  1338                                  
  1339                                  ; Función corregida para mover láseres
  1340                                  ; Función corregida para mover láseres
  1341                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1342                                  
  1343                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1344                                  ; ============================================================
  1345                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1346                                  ; ============================================================
  1347                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1348                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1349                                  ; ============================================================
  1350                                  move_lasers:
  1351 0000094D 55                          push rbp
  1352 0000094E 4889E5                      mov  rbp, rsp
  1353 00000951 53                          push rbx
  1354 00000952 57                          push rdi
  1355 00000953 56                          push rsi
  1356 00000954 4154                        push r12
  1357 00000956 4155                        push r13
  1358 00000958 4156                        push r14
  1359 0000095A 4157                        push r15
  1360                                  
  1361                                      ; 1) Tomamos la cantidad de láseres
  1362 0000095C 480FB60D(071C0000)          movzx rcx, byte [laser_count]
  1363 00000964 4885C9                      test rcx, rcx
  1364 00000967 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1365                                  
  1366                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1367 0000096D 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1368                                  
  1369                                  .loop_lasers:
  1370                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1371 00000970 488DB409[081C0000]          lea rsi, [lasers + rcx*2]
  1372                                  
  1373                                      ; 2) Cargar x,y actuales del láser
  1374 00000978 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1375 0000097C 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1376                                  
  1377                                      ; 3) Borrar el láser de su posición actual en pantalla
  1378                                      ;    (por si en el ciclo anterior se había dibujado)
  1379 00000981 B850000000                  mov rax, column_cells
  1380 00000986 4883C002                    add rax, 2
  1381 0000098A 49F7E1                      mul r9
  1382 0000098D 4C01C0                      add rax, r8
  1383 00000990 488DB8[400A0000]            lea rdi, [board + rax]
  1384 00000997 C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1385                                  
  1386                                      ; 4) Mover el láser hacia arriba (y - 1)
  1387 0000099A 49FFC9                      dec r9
  1388                                  
  1389                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1390 0000099D 4983F901                    cmp r9, 1
  1391 000009A1 7C57                        jl .delete_laser
  1392                                  
  1393                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1394 000009A3 44884E01                    mov byte [rsi + 1], r9b
  1395                                  
  1396                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1397                                      ;    - Primero colisión con bloques
  1398                                      ; ---------------------------------------------------------
  1399                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1400 000009A7 B850000000                  mov rax, column_cells
  1401 000009AC 4883C002                    add rax, 2
  1402 000009B0 49F7E1                      mul r9
  1403 000009B3 4C01C0                      add rax, r8
  1404 000009B6 488DB8[400A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1405                                  
  1406                                      ; Revisar si hay bloque
  1407 000009BD 51                          push rcx
  1408 000009BE 56                          push rsi
  1409 000009BF 57                          push rdi
  1410 000009C0 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1411 000009C3 E8F60E0000                  call check_block_collision
  1412 000009C8 5F                          pop rdi
  1413 000009C9 5E                          pop rsi
  1414 000009CA 59                          pop rcx
  1415                                  
  1416 000009CB 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1417 000009CE 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1418                                  
  1419                                      ;    - Luego colisión con enemigos
  1420                                      ; ---------------------------------------------------------
  1421 000009D0 51                          push rcx
  1422 000009D1 56                          push rsi
  1423 000009D2 57                          push rdi
  1424                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1425                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1426                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1427                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1428                                      ;
  1429                                      ; Hacemos algo como:
  1430 000009D3 4989FA                      mov r10, rdi
  1431 000009D6 E85A000000                  call check_laser_enemy_collision
  1432 000009DB 5F                          pop rdi
  1433 000009DC 5E                          pop rsi
  1434 000009DD 59                          pop rcx
  1435                                  
  1436 000009DE 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1437 000009E1 7517                        jnz .delete_laser
  1438                                  
  1439                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1440 000009E3 8A05(061C0000)              mov al, [laser_symbol]
  1441 000009E9 8807                        mov [rdi], al
  1442                                  
  1443                                  .next_laser:
  1444                                      ; Pasamos al láser anterior en el array
  1445 000009EB 48FFC9                      dec rcx
  1446 000009EE 4883F9FF                    cmp rcx, -1
  1447 000009F2 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1448 000009F8 EB2E                        jmp .fin
  1449                                  
  1450                                  ; -----------------------------------------------------------------
  1451                                  ; Subrutina interna: .delete_laser
  1452                                  ; -----------------------------------------------------------------
  1453                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1454                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1455                                  .delete_laser:
  1456 000009FA 4C0FB625(071C0000)          movzx r12, byte [laser_count]
  1457 00000A02 49FFCC                      dec r12                    ; r12 = índice del último láser
  1458 00000A05 4939CC                      cmp r12, rcx
  1459 00000A08 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1460                                  
  1461                                      ; Copiamos el último láser a la posición actual
  1462 00000A0A 488DBC09[081C0000]          lea rdi, [lasers + rcx*2]
  1463 00000A12 4B8DB424[081C0000]          lea rsi, [lasers + r12*2]
  1464 00000A1A 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1465 00000A1D 668907                      mov [rdi], ax             ; copiamos X,Y
  1466                                  
  1467                                  .just_decrement:
  1468 00000A20 FE0D(071C0000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1469 00000A26 EBC3                        jmp .next_laser
  1470                                  
  1471                                  .fin:
  1472 00000A28 415F                        pop r15
  1473 00000A2A 415E                        pop r14
  1474 00000A2C 415D                        pop r13
  1475 00000A2E 415C                        pop r12
  1476 00000A30 5E                          pop rsi
  1477 00000A31 5F                          pop rdi
  1478 00000A32 5B                          pop rbx
  1479 00000A33 5D                          pop rbp
  1480 00000A34 C3                          ret
  1481                                  
  1482                                  
  1483                                  ; Nueva función para verificar colisión entre láser y enemigos
  1484                                  ; ==========================================================
  1485                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1486                                  ; ==========================================================
  1487                                  check_laser_enemy_collision:
  1488 00000A35 55                          push rbp
  1489 00000A36 4889E5                      mov  rbp, rsp
  1490                                      
  1491 00000A39 4D31ED                      xor r13, r13            ; Índice del enemigo
  1492 00000A3C 4831C0                      xor rax, rax            ; 0 = no colisión
  1493                                  
  1494                                  .loop_enemies:
  1495 00000A3F 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1496 00000A43 7D64                        jge .end
  1497                                  
  1498                                      ; r13 * 3 => offset del enemigo i
  1499 00000A45 4C89E9                      mov rcx, r13
  1500 00000A48 486BC903                    imul rcx, 3
  1501 00000A4C 488DB1[5D190000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1502                                  
  1503                                      ; Verificar si está activo
  1504 00000A53 807E0201                    cmp byte [rsi+2], 1
  1505 00000A57 754B                        jne .next_enemy
  1506                                  
  1507                                      ; Cargar posición X/Y del enemigo
  1508 00000A59 4C0FB636                    movzx r14, byte [rsi]      ; X
  1509 00000A5D 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1510                                  
  1511                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1512 00000A62 4D39F0                      cmp r8, r14
  1513 00000A65 753D                        jne .next_enemy
  1514 00000A67 4D39F9                      cmp r9, r15
  1515 00000A6A 7538                        jne .next_enemy
  1516                                  
  1517                                      ; ==== Colisión detectada con láser ====
  1518                                  
  1519                                      ; 1) Desactivar enemigo
  1520 00000A6C C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1521                                  
  1522                                      ; 2) Sumar puntos
  1523 00000A70 488B05(7C190000)            mov rax, [enemy_points]
  1524 00000A77 480105(3B190000)            add [current_score], rax
  1525                                  
  1526                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1527                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1528 00000A7E 4983FF1E                    cmp r15, row_cells - 2
  1529 00000A82 7419                        je .skip_erase
  1530                                  
  1531                                      ; Borrar visualmente del board
  1532 00000A84 B850000000                  mov rax, column_cells
  1533 00000A89 4883C002                    add rax, 2
  1534 00000A8D 49F7E7                      mul r15
  1535 00000A90 4C01F0                      add rax, r14
  1536 00000A93 488DB8[400A0000]            lea rdi, [board + rax]
  1537 00000A9A C60720                      mov byte [rdi], ' '
  1538                                  
  1539                                  .skip_erase:
  1540                                  
  1541                                      ; 4) Devolver rax=1 => colisión con enemigo
  1542 00000A9D B801000000                  mov rax, 1
  1543 00000AA2 EB05                        jmp .end
  1544                                  
  1545                                  .next_enemy:
  1546 00000AA4 49FFC5                      inc r13
  1547 00000AA7 EB96                        jmp .loop_enemies
  1548                                  
  1549                                  .end:
  1550 00000AA9 5D                          pop rbp
  1551 00000AAA C3                          ret
  1552                                  
  1553                                  
  1554                                  ; Función auxiliar para eliminar un láser específico
  1555                                  remove_laser:
  1556 00000AAB 55                          push rbp
  1557 00000AAC 4889E5                      mov rbp, rsp
  1558                                  
  1559                                      ; Borrar el láser del tablero
  1560 00000AAF 41C60220                    mov byte [r10], ' '
  1561                                  
  1562                                      ; Mover el último láser a esta posición si no es el último
  1563 00000AB3 480FB605(071C0000)          movzx rax, byte [laser_count]
  1564 00000ABB 48FFC8                      dec rax                    ; Índice del último láser
  1565 00000ABE 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1566 00000AC1 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1567                                  
  1568                                      ; Copiar último láser a la posición actual
  1569 00000AC3 4B8DBC24[081C0000]          lea rdi, [lasers + r12*2]
  1570 00000ACB 488DB400[081C0000]          lea rsi, [lasers + rax*2]
  1571 00000AD3 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1572 00000AD6 668917                      mov [rdi], dx
  1573                                  
  1574                                  .just_decrease:
  1575 00000AD9 FE0D(071C0000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1576                                  
  1577 00000ADF 5D                          pop rbp
  1578 00000AE0 C3                          ret
  1579                                  
  1580                                  add_life:
  1581 00000AE1 55                          push rbp
  1582 00000AE2 4889E5                      mov rbp, rsp
  1583 00000AE5 53                          push rbx
  1584 00000AE6 51                          push rcx
  1585 00000AE7 57                          push rdi
  1586 00000AE8 56                          push rsi
  1587 00000AE9 4150                        push r8
  1588 00000AEB 4151                        push r9
  1589                                      
  1590                                      ; Verificar si ya tenemos el máximo de vidas
  1591 00000AED 480FB605(381A0000)          movzx rax, byte [current_lives]
  1592 00000AF5 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1593 00000AF9 7D2C                        jge .end
  1594                                      
  1595                                      ; Incrementar el contador de vidas
  1596 00000AFB FE05(381A0000)              inc byte [current_lives]
  1597                                      
  1598                                      ; Encontrar la siguiente vida inactiva
  1599 00000B01 4831C9                      xor rcx, rcx
  1600                                      
  1601                                      .find_inactive:
  1602 00000B04 4883F907                        cmp rcx, lives_count
  1603 00000B08 7D1D                            jge .end
  1604                                          
  1605                                          ; Calcular offset de la vida actual
  1606 00000B0A 4889C8                          mov rax, rcx
  1607 00000B0D 486BC003                        imul rax, 3
  1608 00000B11 488DB0[221A0000]                lea rsi, [lives_data + rax]
  1609                                          
  1610                                          ; Verificar si está inactiva
  1611 00000B18 807E0200                        cmp byte [rsi + 2], 0
  1612 00000B1C 7405                            je .activate_life
  1613                                          
  1614 00000B1E 48FFC1                          inc rcx
  1615 00000B21 EBE1                            jmp .find_inactive
  1616                                          
  1617                                      .activate_life:
  1618                                          ; Activar la vida
  1619 00000B23 C6460201                        mov byte [rsi + 2], 1
  1620                                          
  1621                                      .end:
  1622 00000B27 4159                            pop r9
  1623 00000B29 4158                            pop r8
  1624 00000B2B 5E                              pop rsi
  1625 00000B2C 5F                              pop rdi
  1626 00000B2D 59                              pop rcx
  1627 00000B2E 5B                              pop rbx
  1628 00000B2F 5D                              pop rbp
  1629 00000B30 C3                              ret
  1630                                  
  1631                                  
  1632                                  print_ball:
  1633 00000B31 4C8B05(DF140000)        	mov r8, [ball_x_pos]
  1634 00000B38 4C8B0D(E7140000)        	mov r9, [ball_y_pos]
  1635 00000B3F 4981C0[400A0000]        	add r8, board
  1636                                  
  1637 00000B46 4C89C9                  	mov rcx, r9
  1638 00000B49 B852000000              	mov rax, column_cells + 2
  1639 00000B4E 48F7E9                  	imul rcx
  1640                                  	
  1641 00000B51 4901C0                  	add r8, rax
  1642 00000B54 41C6004F                	mov byte [r8], char_O
  1643 00000B58 C3                      	ret
  1644                                  
  1645                                  print_ball_2:
  1646 00000B59 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1647 00000B60 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1648 00000B67 4981C0[400A0000]            add r8, board
  1649 00000B6E 4C89C9                      mov rcx, r9
  1650 00000B71 B852000000                  mov rax, column_cells + 2
  1651 00000B76 48F7E9                      imul rcx
  1652 00000B79 4901C0                      add r8, rax
  1653 00000B7C 41C6004F                    mov byte [r8], char_O
  1654 00000B80 C3                          ret
  1655                                  
  1656                                  print_ball_3:
  1657 00000B81 4C8B05(23150000)            mov r8, [ball3_x_pos]
  1658 00000B88 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  1659 00000B8F 4981C0[400A0000]            add r8, board
  1660 00000B96 4C89C9                      mov rcx, r9
  1661 00000B99 B852000000                  mov rax, column_cells + 2
  1662 00000B9E 48F7E9                      imul rcx
  1663 00000BA1 4901C0                      add r8, rax
  1664 00000BA4 41C6004F                    mov byte [r8], char_O
  1665 00000BA8 C3                          ret
  1666                                  
  1667                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1668                                  	
  1669                                  print_pallet:
  1670                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1671 00000BA9 4C8B05(BF140000)            mov r8, [pallet_position]
  1672 00000BB0 488B0D(D7140000)            mov rcx, [extended_pallet_size]
  1673                                      .clear_pallet:
  1674 00000BB7 41C60020                        mov byte [r8], char_space
  1675 00000BBB 49FFC0                          inc r8
  1676 00000BBE 48FFC9                          dec rcx
  1677 00000BC1 75F4                            jnz .clear_pallet
  1678                                  
  1679                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1680 00000BC3 4C8B05(BF140000)            mov r8, [pallet_position]
  1681 00000BCA 488B0D(C7140000)            mov rcx, [pallet_size]
  1682                                      .write_pallet:
  1683 00000BD1 41C6003D                        mov byte [r8], char_equal
  1684 00000BD5 49FFC0                          inc r8
  1685 00000BD8 48FFC9                          dec rcx
  1686 00000BDB 75F4                            jnz .write_pallet
  1687                                  
  1688 00000BDD C3                          ret
  1689                                  
  1690                                  move_pallet:
  1691                                      
  1692 00000BDE 803D(FF140000)00            cmp byte [ball_moving], 0
  1693 00000BE5 7507                        jne .continue_movement
  1694 00000BE7 C605(FF140000)01            mov byte [ball_moving], 1
  1695                                  
  1696                                      .continue_movement:
  1697 00000BEE 4883FFFF                        cmp rdi, left_direction
  1698 00000BF2 7531                            jne .move_right
  1699                                  
  1700                                          .move_left:
  1701                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1702 00000BF4 4C8B05(BF140000)                    mov r8, [pallet_position]
  1703 00000BFB 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1704 00000BFE 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1705 00000C01 3C58                                cmp al, 'X'        ; Comparar si es una X
  1706 00000C03 744E                                je .end            ; Si es X, no mover
  1707                                              
  1708 00000C05 4C8B05(BF140000)                    mov r8, [pallet_position]
  1709 00000C0C 4C8B0D(C7140000)                    mov r9, [pallet_size]
  1710 00000C13 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1711 00000C19 49FFC8                              dec r8
  1712 00000C1C 4C8905(BF140000)                    mov [pallet_position], r8
  1713 00000C23 EB2E                                jmp .end
  1714                                              
  1715                                          .move_right:
  1716                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1717 00000C25 4C8B05(BF140000)                    mov r8, [pallet_position]
  1718 00000C2C 4C8B0D(C7140000)                    mov r9, [pallet_size]
  1719 00000C33 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1720 00000C36 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1721 00000C3A 3C58                                cmp al, 'X'        ; Comparar si es una X
  1722 00000C3C 7415                                je .end            ; Si es X, no mover
  1723                                              
  1724 00000C3E 4C8B05(BF140000)                    mov r8, [pallet_position]
  1725 00000C45 41C60020                            mov byte [r8], char_space
  1726 00000C49 49FFC0                              inc r8
  1727 00000C4C 4C8905(BF140000)                    mov [pallet_position], r8
  1728                                          .end:
  1729 00000C53 C3                                  ret
  1730                                  
  1731                                  
  1732                                  
  1733                                              
  1734                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1735                                  update_caught_ball_position:
  1736 00000C54 55                          push rbp
  1737 00000C55 4889E5                      mov rbp, rsp
  1738                                      
  1739                                      ; Calcular la nueva posición de la bola basada en la paleta
  1740 00000C58 4C8B05(BF140000)            mov r8, [pallet_position]
  1741 00000C5F 4981E8[400A0000]            sub r8, board          ; Obtener posición relativa
  1742 00000C66 B852000000                  mov rax, column_cells + 2
  1743 00000C6B 4831D2                      xor rdx, rdx
  1744 00000C6E 48F7F0                      div rax                ; División para obtener X,Y
  1745                                      
  1746                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1747 00000C71 4989C1                      mov r9, rax            ; Y de la paleta
  1748 00000C74 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1749                                      
  1750                                      ; Añadir el offset guardado a la posición X
  1751 00000C77 4889D0                      mov rax, rdx
  1752 00000C7A 480305(FC1B0000)            add rax, [ball_catch_offset]
  1753 00000C81 488905(DF140000)            mov [ball_x_pos], rax
  1754 00000C88 4C890D(E7140000)            mov [ball_y_pos], r9
  1755                                      
  1756 00000C8F 5D                          pop rbp
  1757 00000C90 C3                          ret
  1758                                  
  1759                                  
  1760                                  move_all_balls:
  1761 00000C91 55                          push rbp
  1762 00000C92 4889E5                      mov rbp, rsp
  1763 00000C95 53                          push rbx
  1764                                      
  1765                                      ; Inicializar contador de bolas
  1766 00000C96 4831DB                      xor rbx, rbx
  1767                                      
  1768                                  .loop_balls:
  1769                                      ; Verificar si hemos procesado todas las bolas
  1770 00000C99 3A1D(3B1D0000)              cmp bl, byte [balls_count]
  1771 00000C9F 7D1D                        jge .end
  1772                                      
  1773                                      ; Calcular offset de la bola actual
  1774 00000CA1 B821000000                  mov rax, BALL_STRUCT_SIZE
  1775 00000CA6 48F7E3                      mul rbx
  1776                                      
  1777                                      ; Verificar si la bola está activa
  1778 00000CA9 80B8[F81C0000]01            cmp byte [balls_data + rax + 32], 1
  1779 00000CB0 7507                        jne .next_ball
  1780                                      
  1781                                      ; Guardar offset en la pila
  1782 00000CB2 50                          push rax
  1783                                      
  1784                                      ; Llamar a move_ball con los parámetros de esta bola
  1785 00000CB3 E809000000                  call move_ball
  1786                                      
  1787                                      ; Restaurar offset
  1788 00000CB8 58                          pop rax
  1789                                      
  1790                                  .next_ball:
  1791 00000CB9 48FFC3                      inc rbx
  1792 00000CBC EBDB                        jmp .loop_balls
  1793                                      
  1794                                  .end:
  1795 00000CBE 5B                          pop rbx
  1796 00000CBF 5D                          pop rbp
  1797 00000CC0 C3                          ret
  1798                                  
  1799                                  move_ball:
  1800                                  
  1801 00000CC1 803D(F91B0000)01            cmp byte [ball_caught], 1
  1802 00000CC8 0F849D000000                je .move_with_pallet
  1803                                  
  1804 00000CCE 803D(FF140000)00            cmp byte [ball_moving], 0
  1805 00000CD5 0F84B8010000                je .end
  1806                                  
  1807                                      ; Incrementar contador de velocidad
  1808 00000CDB 48FF05(F01B0000)            inc qword [speed_counter]
  1809                                      
  1810                                      ; Verificar si debemos mover la bola en este ciclo
  1811 00000CE2 488B05(F01B0000)            mov rax, [speed_counter]
  1812 00000CE9 483B05(E01B0000)            cmp rax, [ball_speed]
  1813 00000CF0 0F8C9D010000                jl .end
  1814                                      
  1815                                      ; Resetear contador de velocidad
  1816 00000CF6 48C705(F01B0000)00-         mov qword [speed_counter], 0
  1816 00000CFE 000000             
  1817                                  
  1818                                      ; Borrar la posición actual de la bola
  1819 00000D01 4C8B05(DF140000)            mov r8, [ball_x_pos]
  1820 00000D08 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  1821 00000D0F 4981C0[400A0000]            add r8, board
  1822 00000D16 4C89C9                      mov rcx, r9
  1823 00000D19 B852000000                  mov rax, column_cells + 2
  1824 00000D1E 48F7E9                      imul rcx
  1825 00000D21 4901C0                      add r8, rax
  1826 00000D24 41C60020                    mov byte [r8], char_space
  1827                                  
  1828                                      ; Calcular siguiente posición X
  1829 00000D28 4C8B05(DF140000)            mov r8, [ball_x_pos]
  1830 00000D2F 4C8B0D(E7140000)            mov r9, [ball_y_pos]
  1831 00000D36 488B05(EF140000)            mov rax, [ball_direction_x]
  1832 00000D3D 4901C0                      add r8, rax               ; Nueva posición X
  1833                                  
  1834                                      ; Calcular la dirección de memoria para la siguiente posición
  1835 00000D40 4D89C2                      mov r10, r8
  1836 00000D43 4981C2[400A0000]            add r10, board
  1837 00000D4A 4C89C9                      mov rcx, r9
  1838 00000D4D B852000000                  mov rax, column_cells + 2
  1839 00000D52 48F7E9                      imul rcx
  1840 00000D55 4901C2                      add r10, rax
  1841                                  
  1842                                      ; Verificar si hay una X en la siguiente posición X
  1843 00000D58 418A02                      mov al, [r10]
  1844 00000D5B 3C58                        cmp al, 'X'
  1845 00000D5D 7565                        jne .check_block_x
  1846 00000D5F 48F71D(EF140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1847 00000D66 E928010000                  jmp .end
  1848                                  
  1849                                      .move_with_pallet:
  1850                                          ; Borrar la posición actual de la bola
  1851 00000D6B 4C8B05(DF140000)                mov r8, [ball_x_pos]
  1852 00000D72 4C8B0D(E7140000)                mov r9, [ball_y_pos]
  1853 00000D79 4D89C2                          mov r10, r8
  1854 00000D7C 4981C2[400A0000]                add r10, board
  1855 00000D83 4C89C9                          mov rcx, r9
  1856 00000D86 B852000000                      mov rax, column_cells + 2
  1857 00000D8B 48F7E9                          imul rcx
  1858 00000D8E 4901C2                          add r10, rax
  1859 00000D91 41C60220                        mov byte [r10], char_space
  1860                                  
  1861                                          ; Actualizar posición X basada en la paleta
  1862 00000D95 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1863 00000D9C 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1864 00000DA3 4C0305(FC1B0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1865 00000DAA 4C8905(DF140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1866                                  
  1867                                          ; Mantener la bola una posición arriba de la paleta
  1868 00000DB1 4C8B0D(E7140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1869 00000DB8 4C890D(E7140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1870                                  
  1871 00000DBF E9CF000000                      jmp .end
  1872                                  
  1873                                  
  1874                                      .check_block_x:
  1875                                          ; Verificar colisión con bloques en X
  1876 00000DC4 4150                            push r8     ; Guardar registros que usa check_block_collision
  1877 00000DC6 4151                            push r9
  1878 00000DC8 4152                            push r10
  1879 00000DCA E8EF0A0000                      call check_block_collision
  1880 00000DCF 415A                            pop r10
  1881 00000DD1 4159                            pop r9
  1882 00000DD3 4158                            pop r8
  1883 00000DD5 4885C0                          test rax, rax
  1884 00000DD8 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1885 00000DDA 48F71D(EF140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1886 00000DE1 E9AD000000                      jmp .end
  1887                                  
  1888                                      .check_paddle_x:
  1889                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1890 00000DE6 41803A3D                        cmp byte [r10], char_equal
  1891 00000DEA 750C                            jne .check_y_movement
  1892 00000DEC 48F71D(EF140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1893 00000DF3 E99B000000                      jmp .end
  1894                                  
  1895                                      .check_y_movement:
  1896                                          ; Calcular siguiente posición Y
  1897 00000DF8 488B05(F7140000)                mov rax, [ball_direction_y]
  1898 00000DFF 4901C1                          add r9, rax                  ; Nueva posición Y
  1899                                  
  1900                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1901 00000E02 4D89C2                          mov r10, r8
  1902 00000E05 4981C2[400A0000]                add r10, board
  1903 00000E0C 4C89C9                          mov rcx, r9
  1904 00000E0F B852000000                      mov rax, column_cells + 2
  1905 00000E14 48F7E9                          imul rcx
  1906 00000E17 4901C2                          add r10, rax
  1907                                  
  1908                                          ; Verificar si hay una X en la siguiente posición Y
  1909 00000E1A 418A02                          mov al, [r10]
  1910 00000E1D 3C58                            cmp al, 'X'
  1911 00000E1F 7509                            jne .check_block_y
  1912 00000E21 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1913 00000E28 EB69                            jmp .end
  1914                                  
  1915                                      .check_block_y:
  1916                                          ; Verificar colisión con bloques en Y
  1917 00000E2A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1918 00000E2C 4151                            push r9
  1919 00000E2E 4152                            push r10
  1920 00000E30 E8890A0000                      call check_block_collision
  1921 00000E35 415A                            pop r10
  1922 00000E37 4159                            pop r9
  1923 00000E39 4158                            pop r8
  1924 00000E3B 4885C0                          test rax, rax
  1925 00000E3E 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1926 00000E40 48F71D(F7140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1927 00000E47 EB4A                            jmp .end
  1928                                  
  1929                                      .check_paddle_y:
  1930                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1931 00000E49 41803A3D                        cmp byte [r10], char_equal
  1932 00000E4D 7536                            jne .update_position
  1933                                  
  1934                                          ; Verificar si el poder catch está activo
  1935 00000E4F 803D(F81B0000)01                cmp byte [catch_power_active], 1
  1936 00000E56 7524                            jne .normal_bounce
  1937                                  
  1938                                          ; Activar el modo "atrapado"
  1939 00000E58 C605(F91B0000)01                mov byte [ball_caught], 1
  1940                                          
  1941                                          ; Guardar la posición X actual de la bola como offset
  1942 00000E5F 488B05(DF140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1943 00000E66 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1944 00000E6D 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1945 00000E73 488905(FC1B0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1946                                          
  1947 00000E7A EB17                            jmp .end
  1948                                  
  1949                                      .normal_bounce:
  1950 00000E7C 48F71D(F7140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1951 00000E83 EB0E                            jmp .end
  1952                                  
  1953                                  
  1954                                      .update_position:
  1955 00000E85 4C8905(DF140000)                mov [ball_x_pos], r8
  1956 00000E8C 4C890D(E7140000)                mov [ball_y_pos], r9
  1957                                  
  1958                                      .end:
  1959 00000E93 C3                              ret
  1960                                  
  1961                                  
  1962                                  move_ball_2:
  1963                                  
  1964 00000E94 803D(FA1B0000)01            cmp byte [ball_caught_2], 1
  1965 00000E9B 0F849D000000                je .move_with_pallet
  1966                                  
  1967 00000EA1 803D(21150000)00            cmp byte [ball2_moving], 0
  1968 00000EA8 0F84B8010000                je .end
  1969                                  
  1970                                      ; Incrementar contador de velocidad
  1971 00000EAE 48FF05(F01B0000)            inc qword [speed_counter]
  1972                                      
  1973                                      ; Verificar si debemos mover la bola en este ciclo
  1974 00000EB5 488B05(F01B0000)            mov rax, [speed_counter]
  1975 00000EBC 483B05(E01B0000)            cmp rax, [ball_speed]
  1976 00000EC3 0F8C9D010000                jl .end
  1977                                      
  1978                                      ; Resetear contador de velocidad
  1979 00000EC9 48C705(F01B0000)00-         mov qword [speed_counter], 0
  1979 00000ED1 000000             
  1980                                  
  1981                                      ; Borrar la posición actual de la bola
  1982 00000ED4 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1983 00000EDB 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1984 00000EE2 4981C0[400A0000]            add r8, board
  1985 00000EE9 4C89C9                      mov rcx, r9
  1986 00000EEC B852000000                  mov rax, column_cells + 2
  1987 00000EF1 48F7E9                      imul rcx
  1988 00000EF4 4901C0                      add r8, rax
  1989 00000EF7 41C60020                    mov byte [r8], char_space
  1990                                  
  1991                                      ; Calcular siguiente posición X
  1992 00000EFB 4C8B05(01150000)            mov r8, [ball2_x_pos]
  1993 00000F02 4C8B0D(09150000)            mov r9, [ball2_y_pos]
  1994 00000F09 488B05(11150000)            mov rax, [ball2_direction_x]
  1995 00000F10 4901C0                      add r8, rax               ; Nueva posición X
  1996                                  
  1997                                      ; Calcular la dirección de memoria para la siguiente posición
  1998 00000F13 4D89C2                      mov r10, r8
  1999 00000F16 4981C2[400A0000]            add r10, board
  2000 00000F1D 4C89C9                      mov rcx, r9
  2001 00000F20 B852000000                  mov rax, column_cells + 2
  2002 00000F25 48F7E9                      imul rcx
  2003 00000F28 4901C2                      add r10, rax
  2004                                  
  2005                                      ; Verificar si hay una X en la siguiente posición X
  2006 00000F2B 418A02                      mov al, [r10]
  2007 00000F2E 3C58                        cmp al, 'X'
  2008 00000F30 7565                        jne .check_block_x
  2009 00000F32 48F71D(11150000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  2010 00000F39 E928010000                  jmp .end
  2011                                  
  2012                                      .move_with_pallet:
  2013                                          ; Borrar la posición actual de la bola
  2014 00000F3E 4C8B05(01150000)                mov r8, [ball2_x_pos]
  2015 00000F45 4C8B0D(09150000)                mov r9, [ball2_y_pos]
  2016 00000F4C 4D89C2                          mov r10, r8
  2017 00000F4F 4981C2[400A0000]                add r10, board
  2018 00000F56 4C89C9                          mov rcx, r9
  2019 00000F59 B852000000                      mov rax, column_cells + 2
  2020 00000F5E 48F7E9                          imul rcx
  2021 00000F61 4901C2                          add r10, rax
  2022 00000F64 41C60220                        mov byte [r10], char_space
  2023                                  
  2024                                          ; Actualizar posición X basada en la paleta
  2025 00000F68 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2026 00000F6F 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2027 00000F76 4C0305(FC1B0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2028 00000F7D 4C8905(01150000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  2029                                  
  2030                                          ; Mantener la bola una posición arriba de la paleta
  2031 00000F84 4C8B0D(09150000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  2032 00000F8B 4C890D(09150000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  2033                                  
  2034 00000F92 E9CF000000                      jmp .end
  2035                                  
  2036                                  
  2037                                      .check_block_x:
  2038                                          ; Verificar colisión con bloques en X
  2039 00000F97 4150                            push r8     ; Guardar registros que usa check_block_collision
  2040 00000F99 4151                            push r9
  2041 00000F9B 4152                            push r10
  2042 00000F9D E81C090000                      call check_block_collision
  2043 00000FA2 415A                            pop r10
  2044 00000FA4 4159                            pop r9
  2045 00000FA6 4158                            pop r8
  2046 00000FA8 4885C0                          test rax, rax
  2047 00000FAB 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2048 00000FAD 48F71D(11150000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  2049 00000FB4 E9AD000000                      jmp .end
  2050                                  
  2051                                      .check_paddle_x:
  2052                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2053 00000FB9 41803A3D                        cmp byte [r10], char_equal
  2054 00000FBD 750C                            jne .check_y_movement
  2055 00000FBF 48F71D(11150000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  2056 00000FC6 E99B000000                      jmp .end
  2057                                  
  2058                                      .check_y_movement:
  2059                                          ; Calcular siguiente posición Y
  2060 00000FCB 488B05(19150000)                mov rax, [ball2_direction_y]
  2061 00000FD2 4901C1                          add r9, rax                  ; Nueva posición Y
  2062                                  
  2063                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2064 00000FD5 4D89C2                          mov r10, r8
  2065 00000FD8 4981C2[400A0000]                add r10, board
  2066 00000FDF 4C89C9                          mov rcx, r9
  2067 00000FE2 B852000000                      mov rax, column_cells + 2
  2068 00000FE7 48F7E9                          imul rcx
  2069 00000FEA 4901C2                          add r10, rax
  2070                                  
  2071                                          ; Verificar si hay una X en la siguiente posición Y
  2072 00000FED 418A02                          mov al, [r10]
  2073 00000FF0 3C58                            cmp al, 'X'
  2074 00000FF2 7509                            jne .check_block_y
  2075 00000FF4 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  2076 00000FFB EB69                            jmp .end
  2077                                  
  2078                                      .check_block_y:
  2079                                          ; Verificar colisión con bloques en Y
  2080 00000FFD 4150                            push r8     ; Guardar registros que usa check_block_collision
  2081 00000FFF 4151                            push r9
  2082 00001001 4152                            push r10
  2083 00001003 E8B6080000                      call check_block_collision
  2084 00001008 415A                            pop r10
  2085 0000100A 4159                            pop r9
  2086 0000100C 4158                            pop r8
  2087 0000100E 4885C0                          test rax, rax
  2088 00001011 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2089 00001013 48F71D(19150000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  2090 0000101A EB4A                            jmp .end
  2091                                  
  2092                                      .check_paddle_y:
  2093                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2094 0000101C 41803A3D                        cmp byte [r10], char_equal
  2095 00001020 7536                            jne .update_position
  2096                                  
  2097                                          ; Verificar si el poder catch está activo
  2098 00001022 803D(F81B0000)01                cmp byte [catch_power_active], 1
  2099 00001029 7524                            jne .normal_bounce
  2100                                  
  2101                                          ; Activar el modo "atrapado"
  2102 0000102B C605(FA1B0000)01                mov byte [ball_caught_2], 1
  2103                                          
  2104                                          ; Guardar la posición X actual de la bola como offset
  2105 00001032 488B05(01150000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  2106 00001039 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2107 00001040 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2108 00001046 488905(FC1B0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2109                                          
  2110 0000104D EB17                            jmp .end
  2111                                  
  2112                                      .normal_bounce:
  2113 0000104F 48F71D(19150000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  2114 00001056 EB0E                            jmp .end
  2115                                  
  2116                                  
  2117                                      .update_position:
  2118 00001058 4C8905(01150000)                mov [ball2_x_pos], r8
  2119 0000105F 4C890D(09150000)                mov [ball2_y_pos], r9
  2120                                  
  2121                                      .end:
  2122 00001066 C3                              ret
  2123                                  
  2124                                  move_ball_3:
  2125                                  
  2126 00001067 803D(FB1B0000)01            cmp byte [ball_caught_3], 1
  2127 0000106E 0F849D000000                je .move_with_pallet
  2128                                  
  2129 00001074 803D(43150000)00            cmp byte [ball3_moving], 0
  2130 0000107B 0F84B8010000                je .end
  2131                                  
  2132                                      ; Incrementar contador de velocidad
  2133 00001081 48FF05(F01B0000)            inc qword [speed_counter]
  2134                                      
  2135                                      ; Verificar si debemos mover la bola en este ciclo
  2136 00001088 488B05(F01B0000)            mov rax, [speed_counter]
  2137 0000108F 483B05(E01B0000)            cmp rax, [ball_speed]
  2138 00001096 0F8C9D010000                jl .end
  2139                                      
  2140                                      ; Resetear contador de velocidad
  2141 0000109C 48C705(F01B0000)00-         mov qword [speed_counter], 0
  2141 000010A4 000000             
  2142                                  
  2143                                      ; Borrar la posición actual de la bola
  2144 000010A7 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2145 000010AE 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2146 000010B5 4981C0[400A0000]            add r8, board
  2147 000010BC 4C89C9                      mov rcx, r9
  2148 000010BF B852000000                  mov rax, column_cells + 2
  2149 000010C4 48F7E9                      imul rcx
  2150 000010C7 4901C0                      add r8, rax
  2151 000010CA 41C60020                    mov byte [r8], char_space
  2152                                  
  2153                                      ; Calcular siguiente posición X
  2154 000010CE 4C8B05(23150000)            mov r8, [ball3_x_pos]
  2155 000010D5 4C8B0D(2B150000)            mov r9, [ball3_y_pos]
  2156 000010DC 488B05(33150000)            mov rax, [ball3_direction_x]
  2157 000010E3 4901C0                      add r8, rax               ; Nueva posición X
  2158                                  
  2159                                      ; Calcular la dirección de memoria para la siguiente posición
  2160 000010E6 4D89C2                      mov r10, r8
  2161 000010E9 4981C2[400A0000]            add r10, board
  2162 000010F0 4C89C9                      mov rcx, r9
  2163 000010F3 B852000000                  mov rax, column_cells + 2
  2164 000010F8 48F7E9                      imul rcx
  2165 000010FB 4901C2                      add r10, rax
  2166                                  
  2167                                      ; Verificar si hay una X en la siguiente posición X
  2168 000010FE 418A02                      mov al, [r10]
  2169 00001101 3C58                        cmp al, 'X'
  2170 00001103 7565                        jne .check_block_x
  2171 00001105 48F71D(33150000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  2172 0000110C E928010000                  jmp .end
  2173                                  
  2174                                      .move_with_pallet:
  2175                                          ; Borrar la posición actual de la bola
  2176 00001111 4C8B05(23150000)                mov r8, [ball3_x_pos]
  2177 00001118 4C8B0D(2B150000)                mov r9, [ball3_y_pos]
  2178 0000111F 4D89C2                          mov r10, r8
  2179 00001122 4981C2[400A0000]                add r10, board
  2180 00001129 4C89C9                          mov rcx, r9
  2181 0000112C B852000000                      mov rax, column_cells + 2
  2182 00001131 48F7E9                          imul rcx
  2183 00001134 4901C2                          add r10, rax
  2184 00001137 41C60220                        mov byte [r10], char_space
  2185                                  
  2186                                          ; Actualizar posición X basada en la paleta
  2187 0000113B 4C8B05(BF140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2188 00001142 4981E8[400A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2189 00001149 4C0305(FC1B0000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2190 00001150 4C8905(23150000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2191                                  
  2192                                          ; Mantener la bola una posición arriba de la paleta
  2193 00001157 4C8B0D(2B150000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2194 0000115E 4C890D(2B150000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2195                                  
  2196 00001165 E9CF000000                      jmp .end
  2197                                  
  2198                                  
  2199                                      .check_block_x:
  2200                                          ; Verificar colisión con bloques en X
  2201 0000116A 4150                            push r8     ; Guardar registros que usa check_block_collision
  2202 0000116C 4151                            push r9
  2203 0000116E 4152                            push r10
  2204 00001170 E849070000                      call check_block_collision
  2205 00001175 415A                            pop r10
  2206 00001177 4159                            pop r9
  2207 00001179 4158                            pop r8
  2208 0000117B 4885C0                          test rax, rax
  2209 0000117E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2210 00001180 48F71D(33150000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2211 00001187 E9AD000000                      jmp .end
  2212                                  
  2213                                      .check_paddle_x:
  2214                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2215 0000118C 41803A3D                        cmp byte [r10], char_equal
  2216 00001190 750C                            jne .check_y_movement
  2217 00001192 48F71D(33150000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2218 00001199 E99B000000                      jmp .end
  2219                                  
  2220                                      .check_y_movement:
  2221                                          ; Calcular siguiente posición Y
  2222 0000119E 488B05(3B150000)                mov rax, [ball3_direction_y]
  2223 000011A5 4901C1                          add r9, rax                  ; Nueva posición Y
  2224                                  
  2225                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2226 000011A8 4D89C2                          mov r10, r8
  2227 000011AB 4981C2[400A0000]                add r10, board
  2228 000011B2 4C89C9                          mov rcx, r9
  2229 000011B5 B852000000                      mov rax, column_cells + 2
  2230 000011BA 48F7E9                          imul rcx
  2231 000011BD 4901C2                          add r10, rax
  2232                                  
  2233                                          ; Verificar si hay una X en la siguiente posición Y
  2234 000011C0 418A02                          mov al, [r10]
  2235 000011C3 3C58                            cmp al, 'X'
  2236 000011C5 7509                            jne .check_block_y
  2237 000011C7 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2238 000011CE EB69                            jmp .end
  2239                                  
  2240                                      .check_block_y:
  2241                                          ; Verificar colisión con bloques en Y
  2242 000011D0 4150                            push r8     ; Guardar registros que usa check_block_collision
  2243 000011D2 4151                            push r9
  2244 000011D4 4152                            push r10
  2245 000011D6 E8E3060000                      call check_block_collision
  2246 000011DB 415A                            pop r10
  2247 000011DD 4159                            pop r9
  2248 000011DF 4158                            pop r8
  2249 000011E1 4885C0                          test rax, rax
  2250 000011E4 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2251 000011E6 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2252 000011ED EB4A                            jmp .end
  2253                                  
  2254                                      .check_paddle_y:
  2255                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2256 000011EF 41803A3D                        cmp byte [r10], char_equal
  2257 000011F3 7536                            jne .update_position
  2258                                  
  2259                                          ; Verificar si el poder catch está activo
  2260 000011F5 803D(F81B0000)01                cmp byte [catch_power_active], 1
  2261 000011FC 7524                            jne .normal_bounce
  2262                                  
  2263                                          ; Activar el modo "atrapado"
  2264 000011FE C605(FB1B0000)01                mov byte [ball_caught_3], 1
  2265                                          
  2266                                          ; Guardar la posición X actual de la bola como offset
  2267 00001205 488B05(23150000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2268 0000120C 482B05(BF140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2269 00001213 4805[400A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2270 00001219 488905(FC1B0000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2271                                          
  2272 00001220 EB17                            jmp .end
  2273                                  
  2274                                      .normal_bounce:
  2275 00001222 48F71D(3B150000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2276 00001229 EB0E                            jmp .end
  2277                                  
  2278                                  
  2279                                      .update_position:
  2280 0000122B 4C8905(23150000)                mov [ball3_x_pos], r8
  2281 00001232 4C890D(2B150000)                mov [ball3_y_pos], r9
  2282                                  
  2283                                      .end:
  2284 00001239 C3                              ret
  2285                                  
  2286                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2287                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2288                                  process_catch_release:
  2289 0000123A 55                          push rbp
  2290 0000123B 4889E5                      mov  rbp, rsp
  2291                                  
  2292                                      ; Verificar si el poder está activo
  2293 0000123E 803D(F81B0000)01            cmp byte [catch_power_active], 1
  2294 00001245 0F8586000000                jne .no_catch_power
  2295                                  
  2296                                      ; Verificar si se presionó 'c'
  2297 0000124B 803D(041C0000)63            cmp byte [last_key], 'c'
  2298 00001252 757D                        jne .no_catch_power
  2299                                  
  2300                                      ; Ahora revisamos bola 1
  2301 00001254 803D(F91B0000)01            cmp byte [ball_caught], 1
  2302 0000125B 751F                        jne .check_ball2
  2303                                      ; Suelta la bola 1
  2304 0000125D C605(F91B0000)00            mov byte [ball_caught], 0
  2305 00001264 48C705(EF140000)01-         mov qword [ball_direction_x], 1
  2305 0000126C 000000             
  2306 0000126F 48C705(F7140000)FF-         mov qword [ball_direction_y], -1
  2306 00001277 FFFFFF             
  2307 0000127A EB4E                        jmp .finish
  2308                                  
  2309                                  .check_ball2:
  2310 0000127C 803D(FA1B0000)01            cmp byte [ball_caught_2], 1
  2311 00001283 751F                        jne .check_ball3
  2312                                      ; Suelta la bola 2
  2313 00001285 C605(FA1B0000)00            mov byte [ball_caught_2], 0
  2314 0000128C 48C705(11150000)01-         mov qword [ball2_direction_x], 1
  2314 00001294 000000             
  2315 00001297 48C705(19150000)FF-         mov qword [ball2_direction_y], -1
  2315 0000129F FFFFFF             
  2316 000012A2 EB26                        jmp .finish
  2317                                  
  2318                                  .check_ball3:
  2319 000012A4 803D(FB1B0000)01            cmp byte [ball_caught_3], 1
  2320 000012AB 751D                        jne .finish
  2321                                      ; Suelta la bola 3
  2322 000012AD C605(FB1B0000)00            mov byte [ball_caught_3], 0
  2323 000012B4 48C705(33150000)01-         mov qword [ball3_direction_x], 1
  2323 000012BC 000000             
  2324 000012BF 48C705(3B150000)FF-         mov qword [ball3_direction_y], -1
  2324 000012C7 FFFFFF             
  2325                                  
  2326                                  .finish:
  2327                                      ; Limpiar la tecla
  2328 000012CA C605(041C0000)00            mov byte [last_key], 0
  2329                                  
  2330                                  .no_catch_power:
  2331 000012D1 5D                          pop rbp
  2332 000012D2 C3                          ret
  2333                                  
  2334                                  
  2335                                  
  2336                                  display_level_number:
  2337 000012D3 55                          push rbp
  2338 000012D4 4889E5                      mov rbp, rsp
  2339                                      
  2340                                      ; Limpiar la pantalla primero
  2341                                      print clear, clear_length
    82 000012D7 B801000000          <1>  mov eax, sys_write
    83 000012DC BF01000000          <1>  mov edi, 1
    84 000012E1 48BE-               <1>  mov rsi, %1
    84 000012E3 [1000000000000000]  <1>
    85 000012EB BA07000000          <1>  mov edx, %2
    86 000012F0 0F05                <1>  syscall
  2342                                      
  2343                                      ; Calcular la posición central para el mensaje
  2344                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2345 000012F2 B850000000                  mov rax, column_cells
  2346 000012F7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2347 000012FB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2348                                      
  2349                                      ; Calcular la fila central
  2350 000012FE BB20000000                  mov rbx, row_cells
  2351 00001303 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2352                                      
  2353                                      ; Calcular el offset en el buffer
  2354 00001306 B952000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2355 0000130B 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2356 0000130E 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2357                                      
  2358                                      ; Escribir "NIVEL " en la posición calculada
  2359 00001311 488DB8[400A0000]            lea rdi, [board + rax]
  2360 00001318 48BE-                       mov rsi, level_msg
  2360 0000131A [A414000000000000] 
  2361 00001322 B906000000                  mov rcx, level_msg_len
  2362 00001327 F3A4                        rep movsb
  2363                                      
  2364                                      ; Escribir el número del nivel
  2365 00001329 8A05(79150000)              mov al, [current_level]
  2366 0000132F 0430                        add al, '0'                 ; convertir a ASCII
  2367 00001331 8807                        mov [rdi], al
  2368                                      
  2369                                      ; Mostrar el board con el mensaje
  2370                                      print board, board_size
    82 00001333 B801000000          <1>  mov eax, sys_write
    83 00001338 BF01000000          <1>  mov edi, 1
    84 0000133D 48BE-               <1>  mov rsi, %1
    84 0000133F [400A000000000000]  <1>
    85 00001347 BA400A0000          <1>  mov edx, %2
    86 0000134C 0F05                <1>  syscall
  2371                                      
  2372                                      ; Esperar un segundo
  2373 0000134E B823000000                  mov rax, sys_nanosleep
  2374 00001353 48BF-                       mov rdi, level_display_time
  2374 00001355 [AF14000000000000] 
  2375 0000135D 4831F6                      xor rsi, rsi
  2376 00001360 0F05                        syscall
  2377                                      
  2378 00001362 5D                          pop rbp
  2379 00001363 C3                          ret
  2380                                  
  2381                                  ; Función para inicializar un tablero vacío
  2382                                  init_empty_board:
  2383 00001364 56                          push rsi
  2384 00001365 57                          push rdi
  2385 00001366 51                          push rcx
  2386 00001367 50                          push rax
  2387                                  
  2388 00001368 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2389 0000136F 488D3D(400A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2390 00001376 B9400A0000                  mov rcx, board_template_size
  2391 0000137B F3A4                        rep movsb                   ; Copiar el tablero
  2392                                  
  2393 0000137D 58                          pop rax
  2394 0000137E 59                          pop rcx
  2395 0000137F 5F                          pop rdi
  2396 00001380 5E                          pop rsi
  2397 00001381 C3                          ret
  2398                                  
  2399                                  
  2400                                  init_level:
  2401                                            ; Asegurarse que las otras bolas están desactivadas
  2402 00001382 C605(22150000)00            mov byte [ball2_active], 0
  2403 00001389 C605(44150000)00            mov byte [ball3_active], 0
  2404 00001390 C605(051C0000)00            mov byte [laser_power_active], 0
  2405 00001397 E816F4FFFF                  call clear_lasers
  2406 0000139C 488B05(CF140000)            mov rax, [default_pallet_size]
  2407 000013A3 488905(C7140000)            mov [pallet_size], rax
  2408 000013AA 48C705(E01B0000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2408 000013B2 000000             
  2409                                  
  2410                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2411                                          ; Reiniciar letras activas
  2412 000013B5 488D3D(391A0000)            lea rdi, [letters_map]
  2413 000013BC B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2414 000013C1 4831C0                      xor rax, rax
  2415 000013C4 F3AA                        rep stosb                    ; Llenar con ceros
  2416                                      
  2417                                      ; Inicializar dirección de la bola (derecha y arriba)
  2418 000013C6 48C705(EF140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2418 000013CE 000000             
  2419 000013D1 48C705(F7140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2419 000013D9 FFFFFF             
  2420                                  
  2421                                  
  2422                                      ; Reiniciar contador de letras activas
  2423 000013DC 4831C0                      xor rax, rax
  2424 000013DF 8805(C91B0000)              mov [letters_count], al
  2425                                  
  2426                                      ; Reiniciar última letra capturada
  2427 000013E5 C605(CA1B0000)20            mov byte [last_letter], ' '
  2428 000013EC C605(43190000)00            mov byte [destroyed_blocks], 0 
  2429 000013F3 E86CFFFFFF                  call init_empty_board
  2430 000013F8 E8D6FEFFFF                  call display_level_number
  2431 000013FD E8E5050000                  call init_enemies
  2432                                      
  2433 00001402 56                          push rsi
  2434 00001403 57                          push rdi
  2435 00001404 51                          push rcx
  2436 00001405 50                          push rax
  2437                                  
  2438 00001406 488D35(00000000)            lea rsi, [board_template]
  2439 0000140D 488D3D(400A0000)            lea rdi, [board]
  2440 00001414 B9400A0000                  mov rcx, board_template_size
  2441 00001419 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2442                                  
  2443 0000141B 58                          pop rax
  2444 0000141C 59                          pop rcx
  2445 0000141D 5F                          pop rdi
  2446 0000141E 5E                          pop rsi
  2447                                  
  2448 0000141F B90A000000                  mov rcx, 10
  2449 00001424 4831C0                      xor rax, rax
  2450 00001427 488D3D(E6190000)            lea rdi, [enemy_spawns_triggered]
  2451 0000142E F3AA                        rep stosb      
  2452                                  
  2453                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2454 00001430 803D(79150000)01            cmp byte [current_level], 1
  2455 00001437 7431                        je .level1
  2456 00001439 803D(79150000)02            cmp byte [current_level], 2
  2457 00001440 7454                        je .level2
  2458 00001442 803D(79150000)03            cmp byte [current_level], 3
  2459 00001449 7477                        je .level3
  2460 0000144B 803D(79150000)04            cmp byte [current_level], 4
  2461 00001452 0F8492000000                je .level4
  2462 00001458 803D(79150000)05            cmp byte [current_level], 5
  2463 0000145F 0F84AD000000                je .level5
  2464 00001465 E9D0000000                  jmp .done
  2465                                  
  2466                                  
  2467                                  
  2468                                      .level1:
  2469 0000146A C605(7A150000)4E                mov byte [blocks_remaining], level1_blocks_count
  2470 00001471 4831C9                          xor rcx, rcx             
  2471                                          .init_loop1:
  2472 00001474 4883F94E                            cmp rcx, level1_blocks_count
  2473 00001478 0F8DBC000000                        jge .done
  2474 0000147E 4889C8                              mov rax, rcx         
  2475 00001481 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2476 00001485 8A90[7E150000]                      mov dl, byte [level1_blocks + rax + 3]  
  2477 0000148B 8891[D7180000]                      mov byte [block_states + rcx], dl
  2478 00001491 48FFC1                              inc rcx
  2479 00001494 EBDE                                jmp .init_loop1
  2480                                  
  2481                                      .level2:
  2482 00001496 C605(7A150000)5B                mov byte [blocks_remaining], level2_blocks_count
  2483 0000149D 4831C9                          xor rcx, rcx             
  2484                                          .init_loop2:
  2485 000014A0 4883F95B                            cmp rcx, level2_blocks_count
  2486 000014A4 0F8D90000000                        jge .done
  2487 000014AA 4889C8                              mov rax, rcx         
  2488 000014AD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2489 000014B1 8A90[04170000]                      mov dl, byte [level2_blocks + rax + 3]  
  2490 000014B7 8891[D7180000]                      mov byte [block_states + rcx], dl
  2491 000014BD 48FFC1                              inc rcx
  2492 000014C0 EBDE                                jmp .init_loop2
  2493                                      .level3:
  2494 000014C2 C605(7A150000)01                mov byte [blocks_remaining], level3_blocks_count
  2495 000014C9 4831C9                          xor rcx, rcx             
  2496                                          .init_loop3:
  2497 000014CC 4883F901                            cmp rcx, level3_blocks_count
  2498 000014D0 7D68                                jge .done
  2499 000014D2 4889C8                              mov rax, rcx         
  2500 000014D5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2501 000014D9 8A90[CB180000]                      mov dl, byte [level3_blocks + rax + 3]  
  2502 000014DF 8891[D7180000]                      mov byte [block_states + rcx], dl
  2503 000014E5 48FFC1                              inc rcx
  2504 000014E8 EBE2                                jmp .init_loop3
  2505                                  
  2506                                      .level4:
  2507 000014EA C605(7A150000)01                mov byte [blocks_remaining], level4_blocks_count
  2508 000014F1 4831C9                          xor rcx, rcx             
  2509                                          .init_loop4:
  2510 000014F4 4883F901                            cmp rcx, level4_blocks_count
  2511 000014F8 7D40                                jge .done
  2512 000014FA 4889C8                              mov rax, rcx         
  2513 000014FD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2514 00001501 8A90[D0180000]                      mov dl, byte [level4_blocks + rax + 3]  
  2515 00001507 8891[D7180000]                      mov byte [block_states + rcx], dl
  2516 0000150D 48FFC1                              inc rcx
  2517 00001510 EBE2                                jmp .init_loop4
  2518                                  
  2519                                      .level5:
  2520 00001512 C605(7A150000)01                mov byte [blocks_remaining], level5_blocks_count
  2521 00001519 4831C9                          xor rcx, rcx             
  2522                                          .init_loop5:
  2523 0000151C 4883F901                            cmp rcx, level5_blocks_count
  2524 00001520 7D18                                jge .done
  2525 00001522 4889C8                              mov rax, rcx         
  2526 00001525 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2527 00001529 8A90[D5180000]                      mov dl, byte [level5_blocks + rax + 3]  
  2528 0000152F 8891[D7180000]                      mov byte [block_states + rcx], dl
  2529 00001535 48FFC1                              inc rcx
  2530 00001538 EBE2                                jmp .init_loop5
  2531                                      .done:
  2532 0000153A C3                              ret
  2533                                  
  2534                                  
  2535                                  ; Función para verificar y manejar la transición de nivel
  2536                                  check_level_complete:
  2537                                      ; Verificar si quedan bloques
  2538 0000153B 803D(7A150000)00            cmp byte [blocks_remaining], 0
  2539 00001542 753C                        jne .not_complete
  2540                                      
  2541                                      ; Incrementar el nivel
  2542 00001544 FE05(79150000)              inc byte [current_level]
  2543                                      
  2544                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2545 0000154A 803D(79150000)06            cmp byte [current_level], 6
  2546 00001551 742E                        je game_win
  2547                                      
  2548                                      ; Reinicializar el juego para el siguiente nivel
  2549 00001553 E82AFEFFFF                  call init_level
  2550                                      
  2551                                      ; Reinicializar la posición de la bola y la paleta
  2552 00001558 48C705(DF140000)28-         mov qword [ball_x_pos], 40
  2552 00001560 000000             
  2553 00001563 48C705(E7140000)1C-         mov qword [ball_y_pos], 28
  2553 0000156B 000000             
  2554 0000156E C605(FF140000)00            mov byte [ball_moving], 0
  2555 00001575 48C705(BF140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2555 0000157C [B0130000]         
  2556                                      
  2557                                      .not_complete:
  2558 00001580 C3                              ret
  2559                                  
  2560                                      ; Nueva función para manejar la victoria del juego
  2561                                  game_win:
  2562                                      ; Limpiar la pantalla primero
  2563                                      print clear, clear_length
    82 00001581 B801000000          <1>  mov eax, sys_write
    83 00001586 BF01000000          <1>  mov edi, 1
    84 0000158B 48BE-               <1>  mov rsi, %1
    84 0000158D [1000000000000000]  <1>
    85 00001595 BA07000000          <1>  mov edx, %2
    86 0000159A 0F05                <1>  syscall
  2564                                      
  2565                                      ; Mensaje de victoria
  2566 0000159C 488B05(3B190000)            mov rax, [current_score]    ; Obtener el puntaje final
  2567 000015A3 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2567 000015A5 [4419000000000000] 
  2568 000015AD E8B4010000                  call number_to_string
  2569                                      
  2570                                      ; Definir mensaje de victoria
  2571                                      section .data
  2572 00001D6A C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2572 00001D73 616465732120C2A148-
  2572 00001D7C 61732067616E61646F-
  2572 00001D85 210A0D             
  2573                                          win_msg_len: equ $ - win_msg
  2574 00001D88 50756E74616A652066-             score_msg: db "Puntaje final: "
  2574 00001D91 696E616C3A20       
  2575                                          score_msg_len: equ $ - score_msg
  2576                                      section .text
  2577                                      
  2578                                      ; Imprimir mensajes
  2579                                      print win_msg, win_msg_len
    82 000015B2 B801000000          <1>  mov eax, sys_write
    83 000015B7 BF01000000          <1>  mov edi, 1
    84 000015BC 48BE-               <1>  mov rsi, %1
    84 000015BE [6A1D000000000000]  <1>
    85 000015C6 BA1E000000          <1>  mov edx, %2
    86 000015CB 0F05                <1>  syscall
  2580                                      print score_msg, score_msg_len
    82 000015CD B801000000          <1>  mov eax, sys_write
    83 000015D2 BF01000000          <1>  mov edi, 1
    84 000015D7 48BE-               <1>  mov rsi, %1
    84 000015D9 [881D000000000000]  <1>
    85 000015E1 BA0F000000          <1>  mov edx, %2
    86 000015E6 0F05                <1>  syscall
  2581                                      print number_buffer, 20
    82 000015E8 B801000000          <1>  mov eax, sys_write
    83 000015ED BF01000000          <1>  mov edi, 1
    84 000015F2 48BE-               <1>  mov rsi, %1
    84 000015F4 [4419000000000000]  <1>
    85 000015FC BA14000000          <1>  mov edx, %2
    86 00001601 0F05                <1>  syscall
  2582                                      
  2583                                      ; Esperar un momento antes de salir
  2584 00001603 48C705F2E9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2584 0000160C 0000               
  2585 0000160E 48C705EFE9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2585 00001617 0000               
  2586                                      sleeptime
    98 00001619 B823000000          <1>  mov eax, sys_nanosleep
    99 0000161E 48BF-               <1>  mov rdi, timespec
    99 00001620 [0000000000000000]  <1>
   100 00001628 31F6                <1>  xor esi, esi
   101 0000162A 0F05                <1>  syscall
  2587                                      
  2588 0000162C E9490B0000                  jmp exit
  2589                                  
  2590                                  ; Función para imprimir los bloques
  2591                                  ; Función modificada para imprimir bloques
  2592                                  
  2593                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2594                                  get_current_level_blocks:
  2595 00001631 803D(79150000)01            cmp byte [current_level], 1
  2596 00001638 7428                        je .level1
  2597 0000163A 803D(79150000)02            cmp byte [current_level], 2
  2598 00001641 7427                        je .level2
  2599 00001643 803D(79150000)03            cmp byte [current_level], 3
  2600 0000164A 7426                        je .level3
  2601 0000164C 803D(79150000)04            cmp byte [current_level], 4
  2602 00001653 7425                        je .level4
  2603 00001655 803D(79150000)05            cmp byte [current_level], 5
  2604 0000165C 7424                        je .level5
  2605                                      ; Si llegamos aquí, hay un error en el nivel
  2606 0000165E 4831C0                      xor rax, rax
  2607 00001661 C3                          ret
  2608                                  
  2609                                      .level1:
  2610 00001662 488D05(7B150000)                lea rax, [level1_blocks]
  2611 00001669 C3                              ret
  2612                                      .level2:
  2613 0000166A 488D05(01170000)                lea rax, [level2_blocks]
  2614 00001671 C3                              ret
  2615                                      .level3:
  2616 00001672 488D05(C8180000)                lea rax, [level3_blocks]
  2617 00001679 C3                              ret
  2618                                      .level4:
  2619 0000167A 488D05(CD180000)                lea rax, [level4_blocks]
  2620 00001681 C3                              ret
  2621                                      .level5:
  2622 00001682 488D05(D2180000)                lea rax, [level5_blocks]
  2623 00001689 C3                              ret
  2624                                  ; Función para obtener la cantidad de bloques del nivel actual
  2625                                  get_current_level_count:
  2626 0000168A 803D(79150000)01            cmp byte [current_level], 1
  2627 00001691 7428                        je .level1
  2628 00001693 803D(79150000)02            cmp byte [current_level], 2
  2629 0000169A 7425                        je .level2
  2630 0000169C 803D(79150000)03            cmp byte [current_level], 3
  2631 000016A3 7422                        je .level3
  2632 000016A5 803D(79150000)04            cmp byte [current_level], 4
  2633 000016AC 741F                        je .level4
  2634 000016AE 803D(79150000)05            cmp byte [current_level], 5
  2635 000016B5 741C                        je .level5
  2636                                      ; Si llegamos aquí, hay un error en el nivel
  2637 000016B7 4831C0                      xor rax, rax
  2638 000016BA C3                          ret
  2639                                  
  2640                                      .level1:
  2641 000016BB B84E000000                      mov rax, level1_blocks_count
  2642 000016C0 C3                              ret
  2643                                      .level2:
  2644 000016C1 B85B000000                      mov rax, level2_blocks_count
  2645 000016C6 C3                              ret
  2646                                      .level3:
  2647 000016C7 B801000000                      mov rax, level3_blocks_count
  2648 000016CC C3                              ret
  2649                                      .level4:
  2650 000016CD B801000000                      mov rax, level4_blocks_count
  2651 000016D2 C3                              ret
  2652                                      .level5:
  2653 000016D3 B801000000                      mov rax, level5_blocks_count
  2654 000016D8 C3                              ret
  2655                                  
  2656                                  
  2657                                  print_blocks:
  2658 000016D9 55                          push rbp
  2659 000016DA 4889E5                      mov rbp, rsp
  2660                                      
  2661                                      ; Obtener puntero a los bloques del nivel actual
  2662 000016DD E84FFFFFFF                  call get_current_level_blocks
  2663 000016E2 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2664                                      
  2665                                      ; Obtener cantidad de bloques del nivel actual
  2666 000016E5 E8A0FFFFFF                  call get_current_level_count
  2667 000016EA 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2668                                      
  2669 000016ED 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2670                                      
  2671                                      .print_loop:
  2672 000016F0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2673 000016F3 7D6F                            jge .end
  2674                                          
  2675                                          ; Verificar si el bloque está activo
  2676 000016F5 490FB68424-                     movzx rax, byte [block_states + r12]
  2676 000016FA [D7180000]         
  2677 000016FE 4885C0                          test rax, rax
  2678 00001701 745C                            jz .next_block
  2679                                          
  2680                                          ; Obtener posición y tipo del bloque usando r13
  2681 00001703 4C89E0                          mov rax, r12
  2682 00001706 486BC005                        imul rax, 5
  2683 0000170A 4C01E8                          add rax, r13
  2684 0000170D 448A00                          mov r8b, [rax]        ; X position
  2685 00001710 448A4801                        mov r9b, [rax + 1]    ; Y position
  2686 00001714 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2687                                  
  2688                                          ; El resto de la lógica de impresión permanece igual
  2689 00001718 4D0FB6C0                        movzx r8, r8b
  2690 0000171C 4D0FB6C9                        movzx r9, r9b
  2691 00001720 4981C0[400A0000]                add r8, board
  2692 00001727 B852000000                      mov rax, column_cells + 2
  2693 0000172C 49F7E1                          mul r9
  2694 0000172F 4901C0                          add r8, rax
  2695                                          
  2696 00001732 B906000000                      mov rcx, block_length
  2697 00001737 48BE-                           mov rsi, block_type_1
  2697 00001739 [5515000000000000] 
  2698 00001741 490FB6C2                        movzx rax, r10b
  2699 00001745 48FFC8                          dec rax
  2700 00001748 486BC006                        imul rax, block_length
  2701 0000174C 4801C6                          add rsi, rax
  2702                                          
  2703                                      .print_block_chars:
  2704 0000174F 8A06                            mov al, [rsi]
  2705 00001751 418800                          mov [r8], al
  2706 00001754 48FFC6                          inc rsi
  2707 00001757 49FFC0                          inc r8
  2708 0000175A 48FFC9                          dec rcx
  2709 0000175D 75F0                            jnz .print_block_chars
  2710                                          
  2711                                      .next_block:
  2712 0000175F 49FFC4                          inc r12
  2713 00001762 EB8C                            jmp .print_loop
  2714                                          
  2715                                      .end:
  2716 00001764 5D                              pop rbp
  2717 00001765 C3                              ret
  2718                                  
  2719                                  ; Función para convertir número a string
  2720                                  ; Input: RAX = número a convertir
  2721                                  ; RDI = buffer donde escribir el string
  2722                                  number_to_string:
  2723 00001766 53                          push rbx
  2724 00001767 52                          push rdx
  2725 00001768 56                          push rsi
  2726 00001769 BB0A000000                  mov rbx, 10          ; Divisor
  2727 0000176E B900000000                  mov rcx, 0          ; Contador de dígitos
  2728                                      
  2729                                      ; Si el número es 0, manejarlo especialmente
  2730 00001773 4885C0                      test rax, rax
  2731 00001776 7509                        jnz .convert_loop
  2732 00001778 C60730                      mov byte [rdi], '0'
  2733 0000177B C6470100                    mov byte [rdi + 1], 0
  2734 0000177F EB20                        jmp .end
  2735                                      
  2736                                      .convert_loop:
  2737 00001781 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2738 00001784 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2739 00001787 80C230                          add dl, '0'     ; Convertir a ASCII
  2740 0000178A 52                              push rdx        ; Guardar el dígito
  2741 0000178B 48FFC1                          inc rcx         ; Incrementar contador
  2742 0000178E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2743 00001791 75EE                            jnz .convert_loop
  2744                                          
  2745                                      .write_loop:
  2746 00001793 5A                              pop rdx         ; Obtener dígito
  2747 00001794 8817                            mov [rdi], dl   ; Escribir al buffer
  2748 00001796 48FFC7                          inc rdi         ; Siguiente posición
  2749 00001799 48FFC9                          dec rcx         ; Decrementar contador
  2750 0000179C 75F5                            jnz .write_loop
  2751                                          
  2752 0000179E C60700                      mov byte [rdi], 0   ; Null terminator
  2753                                      
  2754                                      .end:
  2755 000017A1 5E                          pop rsi
  2756 000017A2 5A                          pop rdx
  2757 000017A3 5B                          pop rbx
  2758 000017A4 C3                          ret
  2759                                  
  2760                                  ; Función para imprimir los labels
  2761                                  print_labels:
  2762 000017A5 55                          push rbp
  2763 000017A6 4889E5                      mov rbp, rsp
  2764                                  
  2765                                      ; Crear buffer temporal
  2766 000017A9 4883EC20                    sub rsp, 32
  2767                                  
  2768                                      ; Copiar labels a buffer temporal
  2769 000017AD 4889E7                      mov rdi, rsp
  2770 000017B0 488D35(F0190000)            lea rsi, [score_label]
  2771 000017B7 B917000000                  mov rcx, score_label_len
  2772 000017BC F3A4                        rep movsb
  2773                                  
  2774                                      ; Convertir score a string
  2775 000017BE 488B05(3B190000)            mov rax, [current_score]
  2776 000017C5 48BF-                       mov rdi, number_buffer
  2776 000017C7 [4419000000000000] 
  2777 000017CF E892FFFFFF                  call number_to_string
  2778                                  
  2779                                      ; Calcular longitud del número
  2780 000017D4 B900000000                  mov rcx, 0
  2781 000017D9 48BF-                       mov rdi, number_buffer
  2781 000017DB [4419000000000000] 
  2782                                      .count_loop:
  2783 000017E3 803C0F00                        cmp byte [rdi + rcx], 0
  2784 000017E7 7405                            je .count_done
  2785 000017E9 48FFC1                          inc rcx
  2786 000017EC EBF5                            jmp .count_loop
  2787                                      .count_done:
  2788                                  
  2789                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2790 000017EE 4889E7                      mov rdi, rsp
  2791 000017F1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2792 000017F5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2793 000017FA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2794                                      .pad_loop:
  2795 000017FD 4885F6                          test rsi, rsi
  2796 00001800 740B                            jz .pad_done
  2797 00001802 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2798 00001805 48FFC7                          inc rdi
  2799 00001808 48FFCE                          dec rsi
  2800 0000180B EBF0                            jmp .pad_loop
  2801                                      .pad_done:
  2802                                  
  2803                                      ; Copiar el número
  2804 0000180D 48BE-                       mov rsi, number_buffer
  2804 0000180F [4419000000000000] 
  2805 00001817 F3A4                        rep movsb
  2806                                  
  2807                                      ; Imprimir el buffer completo
  2808                                      print rsp, score_label_len
    82 00001819 B801000000          <1>  mov eax, sys_write
    83 0000181E BF01000000          <1>  mov edi, 1
    84 00001823 4889E6              <1>  mov rsi, %1
    85 00001826 BA17000000          <1>  mov edx, %2
    86 0000182B 0F05                <1>  syscall
  2809                                  
  2810                                      ; Repetir proceso para bloques destruidos
  2811 0000182D 4889E7                      mov rdi, rsp
  2812 00001830 488D35(071A0000)            lea rsi, [blocks_label]
  2813 00001837 B91B000000                  mov rcx, blocks_label_len
  2814 0000183C F3A4                        rep movsb
  2815                                  
  2816                                      ; Verificar que el `[` esté en su posición correcta
  2817 0000183E 4889E7                      mov rdi, rsp
  2818 00001841 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2819 00001845 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2820                                  
  2821                                      ; Convertir bloques destruidos a string
  2822 00001848 480FB605(43190000)          movzx rax, byte [destroyed_blocks]
  2823 00001850 48BF-                       mov rdi, number_buffer
  2823 00001852 [4419000000000000] 
  2824 0000185A E807FFFFFF                  call number_to_string
  2825                                  
  2826                                      ; Calcular longitud del número
  2827 0000185F B900000000                  mov rcx, 0
  2828 00001864 48BF-                       mov rdi, number_buffer
  2828 00001866 [4419000000000000] 
  2829                                      .count_loop2:
  2830 0000186E 803C0F00                        cmp byte [rdi + rcx], 0
  2831 00001872 7405                            je .count_done2
  2832 00001874 48FFC1                          inc rcx
  2833 00001877 EBF5                            jmp .count_loop2
  2834                                      .count_done2:
  2835                                  
  2836                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2837 00001879 4889E7                      mov rdi, rsp
  2838 0000187C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2839 00001880 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2840 00001885 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2841                                      .pad_loop2:
  2842 00001888 4885F6                          test rsi, rsi
  2843 0000188B 740B                            jz .pad_done2
  2844 0000188D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2845 00001890 48FFC7                          inc rdi
  2846 00001893 48FFCE                          dec rsi
  2847 00001896 EBF0                            jmp .pad_loop2
  2848                                      .pad_done2:
  2849                                  
  2850                                      ; Copiar el número
  2851 00001898 48BE-                       mov rsi, number_buffer
  2851 0000189A [4419000000000000] 
  2852 000018A2 F3A4                        rep movsb
  2853                                  
  2854                                      ; Imprimir el buffer completo
  2855                                      print rsp, blocks_label_len
    82 000018A4 B801000000          <1>  mov eax, sys_write
    83 000018A9 BF01000000          <1>  mov edi, 1
    84 000018AE 4889E6              <1>  mov rsi, %1
    85 000018B1 BA1B000000          <1>  mov edx, %2
    86 000018B6 0F05                <1>  syscall
  2856                                  
  2857                                      ; Restaurar stack
  2858 000018B8 4883C420                    add rsp, 32
  2859 000018BC 5D                          pop rbp
  2860 000018BD C3                          ret
  2861                                  
  2862                                  
  2863                                  
  2864                                  check_block_collision:
  2865 000018BE 55                          push rbp
  2866 000018BF 4889E5                      mov rbp, rsp
  2867                                  
  2868                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2869 000018C2 418A02                      mov al, [r10]
  2870                                  
  2871                                      ; Verificar si el carácter es un bloque
  2872 000018C5 3C55                        cmp al, 'U'  
  2873 000018C7 7419                        je .possible
  2874 000018C9 3C4F                        cmp al, 'O'  
  2875 000018CB 7415                        je .possible
  2876 000018CD 3C44                        cmp al, 'D'  
  2877 000018CF 7411                        je .possible
  2878 000018D1 3C4C                        cmp al, 'L'  
  2879 000018D3 740D                        je .possible
  2880 000018D5 3C56                        cmp al, 'V'  
  2881 000018D7 7409                        je .possible
  2882 000018D9 3C38                        cmp al, '8'  
  2883 000018DB 7405                        je .possible
  2884                                  
  2885                                      ; No es bloque, salir
  2886 000018DD 4831C0                      xor rax, rax
  2887 000018E0 5D                          pop rbp
  2888 000018E1 C3                          ret
  2889                                  
  2890                                  .possible:
  2891 000018E2 53                          push rbx
  2892 000018E3 57                          push rdi
  2893 000018E4 56                          push rsi
  2894 000018E5 4154                        push r12
  2895 000018E7 4155                        push r13
  2896 000018E9 4156                        push r14
  2897 000018EB 4157                        push r15
  2898                                  
  2899                                      ; 1) Obtener base de los bloques del nivel actual
  2900 000018ED E83FFDFFFF                  call get_current_level_blocks
  2901 000018F2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2902                                  
  2903                                      ; 2) Obtener la cantidad de bloques
  2904 000018F5 E890FDFFFF                  call get_current_level_count
  2905 000018FA 4989C6                      mov r14, rax
  2906                                  
  2907 000018FD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2908                                  
  2909                                  .find_block_loop:
  2910 00001900 4D39F4                      cmp r12, r14
  2911 00001903 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2912                                  
  2913                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2914 00001909 4C89E0                      mov rax, r12
  2915 0000190C 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2916 00001910 4C01E8                      add rax, r13
  2917 00001913 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2918                                  
  2919                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2920 00001916 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2920 0000191B [D7180000]         
  2921 0000191F 4885DB                      test rbx, rbx
  2922 00001922 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2923                                  
  2924                                      ; Obtener coordenadas
  2925 00001928 418A17                      mov dl, [r15]         ; x
  2926 0000192B 418A4F01                    mov cl, [r15 + 1]     ; y
  2927                                  
  2928                                      ; Calcular posición en el board
  2929 0000192F 488D3D(400A0000)            lea rdi, [board]
  2930 00001936 4831C0                      xor rax, rax
  2931 00001939 B850000000                  mov rax, column_cells
  2932 0000193E 4883C002                    add rax, 2
  2933 00001942 480FB6C9                    movzx rcx, cl         ; y
  2934 00001946 480FAFC1                    imul rax, rcx
  2935 0000194A 4801C7                      add rdi, rax
  2936 0000194D 480FB6C2                    movzx rax, dl         ; x
  2937 00001951 4801C7                      add rdi, rax
  2938                                  
  2939                                      ; Guardar la posición base del bloque
  2940 00001954 57                          push rdi
  2941                                  
  2942                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2943 00001955 4939FA                      cmp r10, rdi
  2944 00001958 7274                        jb .skip_collision
  2945 0000195A 488D5F06                    lea rbx, [rdi + block_length]
  2946 0000195E 4939DA                      cmp r10, rbx
  2947 00001961 736B                        jae .skip_collision
  2948                                  
  2949                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2950 00001963 41FE8C24[D7180000]          dec byte [block_states + r12]
  2951                                      ; Volver a cargar durabilidad
  2952 0000196B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2952 00001970 [D7180000]         
  2953 00001974 4885DB                      test rbx, rbx
  2954 00001977 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2955                                  
  2956                                      ; >>> Llegó a 0 => Bloque destruido
  2957 00001979 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2958 0000197A B906000000                  mov rcx, block_length
  2959                                  .clear_loop:
  2960 0000197F C60720                      mov byte [rdi], ' '
  2961 00001982 48FFC7                      inc rdi
  2962 00001985 E2F8                        loop .clear_loop
  2963                                  
  2964                                      ; Dibujar letra del bloque destruido
  2965 00001987 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2966 0000198B 4883EF06                    sub rdi, block_length
  2967 0000198F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2968                                      ; Después de escribir la letra en el tablero
  2969 00001991 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2970 00001995 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2971 00001999 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2972 0000199E E8C6EAFFFF                  call register_letter
  2973                                      ; Actualizar contadores globales
  2974 000019A3 FE0D(7A150000)              dec byte [blocks_remaining]
  2975 000019A9 FE05(43190000)              inc byte [destroyed_blocks]
  2976                                  
  2977                                      ; Sumar puntos según el tipo
  2978 000019AF 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2979 000019B4 486BC00A                    imul rax, 10
  2980 000019B8 480105(3B190000)            add [current_score], rax
  2981                                  
  2982 000019BF B801000000                  mov rax, 1  ; colisión con destrucción
  2983 000019C4 EB14                        jmp .end_pop
  2984                                  
  2985                                  .update_display:
  2986                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2987 000019C6 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2988 000019CB 5F                          pop rdi     ; pop que quedó pendiente
  2989 000019CC EB0C                        jmp .end_pop
  2990                                  
  2991                                  .skip_collision:
  2992 000019CE 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2993                                  .next_block:
  2994 000019CF 49FFC4                      inc r12
  2995 000019D2 E929FFFFFF                  jmp .find_block_loop
  2996                                  
  2997                                  .no_block_found:
  2998 000019D7 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2999                                  
  3000                                  .end_pop:
  3001 000019DA 415F                        pop r15
  3002 000019DC 415E                        pop r14
  3003 000019DE 415D                        pop r13
  3004 000019E0 415C                        pop r12
  3005 000019E2 5E                          pop rsi
  3006 000019E3 5F                          pop rdi
  3007 000019E4 5B                          pop rbx
  3008 000019E5 5D                          pop rbp
  3009 000019E6 C3                          ret
  3010                                  
  3011                                  
  3012                                  
  3013                                  init_enemies:
  3014 000019E7 55                          push rbp
  3015 000019E8 4889E5                      mov rbp, rsp
  3016                                      ; Reiniciar contadores de movimiento
  3017 000019EB C605(86190000)00            mov byte [enemy_move_total], 0
  3018 000019F2 C605(87190000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  3019                                      ; Limpiar estado previo de enemigos
  3020 000019F9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  3021 000019FE 488D3D(5D190000)            lea rdi, [enemies]
  3022 00001A05 30C0                        xor al, al
  3023 00001A07 F3AA                        rep stosb ; Limpiar datos de enemigos
  3024                                      
  3025                                      ; Marcar todos los enemigos como inactivos
  3026 00001A09 488D3D(E6190000)            lea rdi, [enemy_spawns_triggered]
  3027 00001A10 30C0                        xor al, al
  3028 00001A12 B90A000000                  mov rcx, 10
  3029 00001A17 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  3030                                  
  3031 00001A19 5D                          pop rbp
  3032 00001A1A C3                          ret
  3033                                  
  3034                                  
  3035                                  random_move_enemy:
  3036 00001A1B 55                          push rbp
  3037 00001A1C 4889E5                      mov  rbp, rsp
  3038 00001A1F 53                          push rbx
  3039 00001A20 52                          push rdx
  3040 00001A21 57                          push rdi
  3041                                  
  3042                                      ; r12 = índice del enemigo
  3043                                      ; 1) obtener puntero al enemigo i
  3044 00001A22 4C89E0                      mov rax, r12
  3045 00001A25 486BC003                    imul rax, 3
  3046 00001A29 488D98[5D190000]            lea rbx, [enemies + rax]     ; rbx => &enemies[r12]
  3047                                  
  3048                                      ; 2) Cargar X, Y actuales (NO SE BORRA AQUÍ TODAVÍA)
  3049 00001A30 4C0FB603                    movzx r8, byte [rbx]         ; r8 = X actual
  3050 00001A34 4C0FB64B01                  movzx r9, byte [rbx + 1]     ; r9 = Y actual
  3051                                  
  3052                                      ; 3) Generar "movimiento aleatorio" => tomamos [enemy_move_counter] & 3
  3053 00001A39 480FB605(84190000)          movzx rax, byte [enemy_move_counter]
  3054 00001A41 4883E003                    and rax, 3
  3055                                  
  3056 00001A45 4883F800                    cmp rax, 0
  3057 00001A49 741B                        je .try_left
  3058 00001A4B 4883F801                    cmp rax, 1
  3059 00001A4F 7410                        je .try_right
  3060 00001A51 4883F802                    cmp rax, 2
  3061 00001A55 7405                        je .try_up
  3062                                      ; si es 3 => mover abajo
  3063                                  .try_down:
  3064 00001A57 49FFC1                      inc r9
  3065 00001A5A EB0D                        jmp .check_valid
  3066                                  
  3067                                  .try_up:
  3068 00001A5C 49FFC9                      dec r9
  3069 00001A5F EB08                        jmp .check_valid
  3070                                  
  3071                                  .try_right:
  3072 00001A61 49FFC0                      inc r8
  3073 00001A64 EB03                        jmp .check_valid
  3074                                  
  3075                                  .try_left:
  3076 00001A66 49FFC8                      dec r8
  3077                                  
  3078                                  .check_valid:
  3079                                      ; 4) Verificar límites
  3080 00001A69 4983F801                    cmp r8, 1                    
  3081 00001A6D 0F8EA4000000                jle .invalid_move
  3082 00001A73 4983F850                    cmp r8, column_cells        
  3083 00001A77 0F8D9A000000                jge .invalid_move
  3084 00001A7D 4983F901                    cmp r9, 1                    
  3085 00001A81 0F8E90000000                jle .invalid_move
  3086 00001A87 4983F920                    cmp r9, row_cells          
  3087 00001A8B 0F8D86000000                jge .invalid_move
  3088                                  
  3089                                      ; 5) Verificar colisión con bloques/enemigos
  3090 00001A91 4150                        push r8
  3091 00001A93 4151                        push r9
  3092 00001A95 B850000000                  mov rax, column_cells
  3093 00001A9A 4883C002                    add rax, 2
  3094 00001A9E 49F7E1                      mul r9
  3095 00001AA1 4C01C0                      add rax, r8
  3096 00001AA4 488DB8[400A0000]            lea rdi, [board + rax]
  3097 00001AAB 8A07                        mov al, [rdi]
  3098                                  
  3099                                      ; Revisa si es bloque o borde
  3100 00001AAD 3C55                        cmp al, 'U'
  3101 00001AAF 7462                        je .pop_and_invalid
  3102 00001AB1 3C4F                        cmp al, 'O'
  3103 00001AB3 745E                        je .pop_and_invalid
  3104 00001AB5 3C44                        cmp al, 'D'
  3105 00001AB7 745A                        je .pop_and_invalid
  3106 00001AB9 3C4C                        cmp al, 'L'
  3107 00001ABB 7456                        je .pop_and_invalid
  3108 00001ABD 3C56                        cmp al, 'V'
  3109 00001ABF 7452                        je .pop_and_invalid
  3110 00001AC1 3C38                        cmp al, '8'
  3111 00001AC3 744E                        je .pop_and_invalid
  3112 00001AC5 3C58                        cmp al, 'X'
  3113 00001AC7 744A                        je .pop_and_invalid
  3114                                  
  3115                                      ; Revisa si hay enemigo
  3116 00001AC9 3C40                        cmp al, '@'
  3117 00001ACB 7446                        je .pop_and_invalid
  3118 00001ACD 3C23                        cmp al, '#'
  3119 00001ACF 7442                        je .pop_and_invalid
  3120 00001AD1 3C24                        cmp al, '$'
  3121 00001AD3 743E                        je .pop_and_invalid
  3122 00001AD5 3C26                        cmp al, '&'
  3123 00001AD7 743A                        je .pop_and_invalid
  3124                                  
  3125 00001AD9 E8A0020000                  call check_enemy_at_position
  3126 00001ADE 4883F801                    cmp rax, 1
  3127 00001AE2 742F                        je .pop_and_invalid
  3128                                  
  3129                                      ; ------------------------------
  3130                                      ; SI LLEGAMOS AQUI => POSICIÓN NUEVA ES VÁLIDA
  3131                                      ; AHORA SÍ BORRAMOS LA POSICIÓN ANTIGUA:
  3132                                      ; ------------------------------
  3133 00001AE4 4159                        pop r9
  3134 00001AE6 4158                        pop r8
  3135                                  
  3136                                      ; (A) Borrar la posición antigua en el board
  3137                                      ;    (X,Y) originales estaban en [rbx], [rbx+1].
  3138 00001AE8 4C0FB613                    movzx r10, byte [rbx]   ; oldX
  3139 00001AEC 4C0FB65B01                  movzx r11, byte [rbx+1] ; oldY
  3140 00001AF1 B850000000                  mov rax, column_cells
  3141 00001AF6 4883C002                    add rax, 2
  3142 00001AFA 49F7E3                      mul r11
  3143 00001AFD 4C01D0                      add rax, r10
  3144 00001B00 488DB8[400A0000]            lea rdi, [board + rax]
  3145 00001B07 C60720                      mov byte [rdi], ' '     ; BORRA la posición vieja
  3146                                  
  3147                                      ; (B) Guardar la nueva X,Y en la estructura
  3148 00001B0A 448803                      mov byte [rbx], r8b
  3149 00001B0D 44884B01                    mov byte [rbx + 1], r9b
  3150                                  
  3151 00001B11 EB0D                        jmp .done
  3152                                  
  3153                                  .pop_and_invalid:
  3154 00001B13 4159                        pop r9
  3155 00001B15 4158                        pop r8
  3156                                  
  3157                                  .invalid_move:
  3158                                      ; Restablecer la posición X,Y en [rbx], [rbx+1] (no se borró la vieja)
  3159 00001B17 4C0FB603                    movzx r8, byte [rbx]
  3160 00001B1B 4C0FB64B01                  movzx r9, byte [rbx + 1]
  3161                                      ; Se queda donde estaba
  3162                                  .done:
  3163 00001B20 5F                          pop rdi
  3164 00001B21 5A                          pop rdx
  3165 00001B22 5B                          pop rbx
  3166 00001B23 5D                          pop rbp
  3167 00001B24 C3                          ret
  3168                                  
  3169                                  
  3170                                  ; Función para mover enemigos
  3171                                  move_enemies:
  3172 00001B25 55                          push rbp
  3173 00001B26 4889E5                      mov rbp, rsp
  3174                                      
  3175                                      ; Incrementar contador de movimiento
  3176 00001B29 FE05(84190000)              inc byte [enemy_move_counter]
  3177 00001B2F 480FB605(84190000)          movzx rax, byte [enemy_move_counter]
  3178 00001B37 3A05(85190000)              cmp al, [enemy_move_delay]
  3179 00001B3D 0F8539020000                jne .end
  3180                                      
  3181                                      ; Resetear contador
  3182 00001B43 C605(84190000)00            mov byte [enemy_move_counter], 0
  3183                                      
  3184 00001B4A 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3185                                      
  3186                                      .enemy_loop:
  3187 00001B4D 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  3188 00001B51 0F8D25020000                    jge .end
  3189                                          
  3190                                          ; Calcular offset del enemigo actual
  3191 00001B57 4C89E0                          mov rax, r12
  3192 00001B5A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3193 00001B5E 488DB0[5D190000]                lea rsi, [enemies + rax]
  3194                                          
  3195                                          ; Verificar si el enemigo está activo
  3196 00001B65 807E0201                        cmp byte [rsi + 2], 1
  3197 00001B69 0F8505020000                    jne .next_enemy
  3198                                          
  3199                                          ; Obtener posición actual
  3200 00001B6F 4C0FB606                        movzx r8, byte [rsi]            ; X
  3201 00001B73 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3202                                          
  3203 00001B78 488D3D(3C1D0000)                lea rdi, [enemy_last_x]
  3204 00001B7F 4C01E7                          add rdi, r12
  3205 00001B82 8A07                            mov al, [rdi]             ; al = last_x
  3206                                  
  3207 00001B84 488D15(461D0000)                lea rdx, [enemy_last_y]
  3208 00001B8B 4C01E2                          add rdx, r12
  3209 00001B8E 8A22                            mov ah, [rdx]             ; ah = last_y
  3210                                  
  3211                                          ; r8 = X actual del enemigo
  3212                                          ; r9 = Y actual del enemigo
  3213                                  
  3214                                          ; *** En lugar de cmp ah, r9b => hacemos lo siguiente:
  3215 00001B90 88E2                            mov dl, ah      ; dl = old_Y
  3216 00001B92 4488CB                          mov bl, r9b     ; bl = new_Y
  3217 00001B95 38DA                            cmp dl, bl
  3218 00001B97 752C                            jne .not_stuck
  3219                                  
  3220                                          ; => SI son iguales => pasa al siguiente check
  3221 00001B99 88C2                            mov dl, al      ; dl = old_X
  3222 00001B9B 4488C3                          mov bl, r8b     ; bl = new_X
  3223 00001B9E 38DA                            cmp dl, bl
  3224 00001BA0 7523                            jne .not_stuck
  3225                                  
  3226                                          ; => MISMA POSICIÓN (STUCK)
  3227 00001BA2 488D1D(501D0000)                lea rbx, [enemy_stuck_count]
  3228 00001BA9 4C01E3                          add rbx, r12
  3229 00001BAC FE03                            inc byte [rbx]              ; Aumentar contador de “pegarse”
  3230                                  
  3231                                          ; Verificar si supera umbral, digamos 3
  3232 00001BAE 480FB60B                        movzx rcx, byte [rbx]
  3233 00001BB2 4883F902                        cmp rcx, 2
  3234 00001BB6 7C34                            jl .check_normal_move       ; Si aún no llega a 3, seguir normal
  3235                                  
  3236                                          ; SI LLEGA A 3, FORZAR UN MOVIMIENTO ALEATORIO:
  3237                                          ;  1) resetear el stuck_count
  3238 00001BB8 C60300                          mov byte [rbx], 0
  3239                                  
  3240                                          ;  2) cambiar random
  3241 00001BBB E85BFEFFFF                      call random_move_enemy        ; (Ver ejemplo de abajo)
  3242 00001BC0 E9AF010000                      jmp .next_enemy
  3243                                  
  3244                                      .not_stuck:
  3245                                          ; => Se movió
  3246 00001BC5 488D1D(501D0000)                lea rbx, [enemy_stuck_count]
  3247 00001BCC 4C01E3                          add rbx, r12
  3248 00001BCF C60300                          mov byte [rbx], 0            ; Resetear
  3249                                  
  3250                                          ; Guardar su nueva posición en “last_x, last_y”
  3251 00001BD2 488D3D(3C1D0000)                lea rdi, [enemy_last_x]
  3252 00001BD9 4C01E7                          add rdi, r12
  3253 00001BDC 448807                          mov [rdi], r8b
  3254                                          
  3255 00001BDF 488D3D(461D0000)                lea rdi, [enemy_last_y]
  3256 00001BE6 4C01E7                          add rdi, r12
  3257 00001BE9 44880F                          mov [rdi], r9b
  3258                                  
  3259                                          ; Limpiar posición actual antes de mover
  3260                                      .check_normal_move:
  3261 00001BEC 4150                            push r8
  3262 00001BEE 4151                            push r9
  3263 00001BF0 B850000000                      mov rax, column_cells
  3264 00001BF5 4883C002                        add rax, 2
  3265 00001BF9 49F7E1                          mul r9
  3266 00001BFC 4C01C0                          add rax, r8
  3267 00001BFF 488DB8[400A0000]                lea rdi, [board + rax]
  3268 00001C06 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  3269 00001C09 4159                            pop r9
  3270 00001C0B 4158                            pop r8
  3271                                  
  3272                                          ; Determinar comportamiento basado en índice
  3273 00001C0D 4C89E0                          mov rax, r12
  3274 00001C10 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  3275 00001C14 4885C0                          test rax, rax
  3276 00001C17 7402                            jz .chase_ball
  3277 00001C19 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  3278                                          
  3279                                          ; Perseguir bola (comportamiento original)
  3280                                      .chase_ball:
  3281 00001C1B 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3282 00001C22 4D39D0                          cmp r8, r10
  3283 00001C25 0F8F96000000                    jg .move_left
  3284 00001C2B 0F8C95000000                    jl .move_right
  3285                                          
  3286 00001C31 4C8B15(E7140000)                mov r10, [ball_y_pos]
  3287 00001C38 4D39D1                          cmp r9, r10
  3288 00001C3B 0F8F8A000000                    jg .move_up
  3289 00001C41 0F8C89000000                    jl .move_down
  3290 00001C47 E9A5000000                      jmp .check_collision
  3291                                          
  3292                                      .chase_paddle:
  3293                                          ; Obtener la posición X actual de la paleta
  3294 00001C4C 4C8B15(BF140000)                mov r10, [pallet_position]
  3295 00001C53 4981EA[400A0000]                sub r10, board              ; Convertir a offset relativo
  3296                                          
  3297                                          ; Calcular la posición X real de la paleta
  3298 00001C5A 4C89D0                          mov rax, r10
  3299 00001C5D BB50000000                      mov rbx, column_cells
  3300 00001C62 4883C302                        add rbx, 2                  ; Añadir newline chars
  3301 00001C66 4831D2                          xor rdx, rdx
  3302 00001C69 48F7F3                          div rbx                     ; rax = y, rdx = x
  3303                                          
  3304                                          ; rdx ahora contiene la posición X de la paleta
  3305                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  3306 00001C6C 488B0D(C7140000)                mov rcx, [pallet_size]
  3307 00001C73 48D1E9                          shr rcx, 1                  ; Dividir por 2
  3308 00001C76 4801CA                          add rdx, rcx
  3309                                          
  3310                                          ; Comparar con posición X del enemigo y mover gradualmente
  3311 00001C79 4939D0                          cmp r8, rdx
  3312 00001C7C 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  3313 00001C7E 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  3314 00001C80 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  3315                                  
  3316                                      .check_y_paddle:
  3317                                          ; La Y de la paleta siempre es row_cells - 2
  3318 00001C82 41BA20000000                    mov r10, row_cells
  3319 00001C88 4983EA02                        sub r10, 2
  3320                                          
  3321                                          ; Comparar con posición Y del enemigo y mover gradualmente
  3322 00001C8C 4D39D1                          cmp r9, r10
  3323 00001C8F 7404                            je .no_movement            ; Si está en la misma Y, no mover
  3324 00001C91 7F38                            jg .move_up               ; Si está abajo, mover arriba
  3325 00001C93 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  3326                                          
  3327                                      .no_movement:
  3328 00001C95 EB5A                            jmp .check_collision
  3329                                  
  3330                                      ; También agregar una nueva sección para el movimiento suave
  3331                                      .smooth_transition:
  3332                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  3333 00001C97 8A05(87190000)                  mov al, [enemy_target]
  3334 00001C9D 84C0                            test al, al
  3335 00001C9F 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  3336                                          
  3337                                          ; Verificar distancia en X
  3338 00001CA1 4989D2                          mov r10, rdx              ; Posición X objetivo
  3339 00001CA4 4D29C2                          sub r10, r8               ; Calcular diferencia
  3340 00001CA7 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  3341 00001CAB 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  3342 00001CAD 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  3343 00001CB1 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  3344 00001CB3 EB3C                            jmp .check_collision
  3345                                          
  3346                                      .limit_right_movement:
  3347 00001CB5 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  3348 00001CB9 EB36                            jmp .check_collision
  3349                                          
  3350                                      .limit_left_movement:
  3351 00001CBB 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  3352 00001CBF EB30                            jmp .check_collision
  3353                                      .move_left:
  3354 00001CC1 49FFC8                          dec r8
  3355 00001CC4 EB0F                            jmp .check_vertical
  3356                                          
  3357                                      .move_right:
  3358 00001CC6 49FFC0                          inc r8
  3359 00001CC9 EB0A                            jmp .check_vertical
  3360                                          
  3361                                      .move_up:
  3362 00001CCB 49FFC9                          dec r9
  3363 00001CCE EB21                            jmp .check_collision
  3364                                          
  3365                                      .move_down:
  3366 00001CD0 49FFC1                          inc r9
  3367 00001CD3 EB1C                            jmp .check_collision
  3368                                          
  3369                                      .check_vertical:
  3370 00001CD5 8A05(87190000)                  mov al, [enemy_target]
  3371 00001CDB 84C0                            test al, al
  3372 00001CDD 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  3373 00001CE3 4C8B15(E7140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  3374 00001CEA 4D39D1                          cmp r9, r10
  3375 00001CED 7FDC                            jg .move_up
  3376 00001CEF 7CDF                            jl .move_down
  3377                                          
  3378                                      .check_collision:
  3379                                          ; Verificar colisión con bordes
  3380 00001CF1 4983F801                        cmp r8, 1                       ; Borde izquierdo
  3381 00001CF5 7E7D                            jle .next_enemy
  3382 00001CF7 4983F850                        cmp r8, column_cells
  3383 00001CFB 7D77                            jge .next_enemy
  3384 00001CFD 4983F901                        cmp r9, 1                       ; Borde superior
  3385 00001D01 7E71                            jle .next_enemy
  3386 00001D03 4983F920                        cmp r9, row_cells
  3387 00001D07 7D6B                            jge .next_enemy
  3388                                          
  3389                                          ; Verificar colisión con bloques antes de moverse
  3390 00001D09 4150                            push r8
  3391 00001D0B 4151                            push r9
  3392 00001D0D 4152                            push r10
  3393                                          
  3394                                          ; Calcular posición en el tablero para verificar
  3395 00001D0F B850000000                      mov rax, column_cells
  3396 00001D14 4883C002                        add rax, 2
  3397 00001D18 49F7E1                          mul r9
  3398 00001D1B 4C01C0                          add rax, r8
  3399 00001D1E 4C8D90[400A0000]                lea r10, [board + rax]
  3400                                          
  3401                                          ; Verificar si hay un bloque en la nueva posición
  3402 00001D25 418A02                          mov al, [r10]
  3403 00001D28 3C55                            cmp al, 'U'
  3404 00001D2A 7442                            je .invalid_move
  3405 00001D2C 3C4F                            cmp al, 'O'
  3406 00001D2E 743E                            je .invalid_move
  3407 00001D30 3C44                            cmp al, 'D'
  3408 00001D32 743A                            je .invalid_move
  3409 00001D34 3C4C                            cmp al, 'L'
  3410 00001D36 7436                            je .invalid_move
  3411 00001D38 3C56                            cmp al, 'V'
  3412 00001D3A 7432                            je .invalid_move
  3413 00001D3C 3C38                            cmp al, '8'
  3414 00001D3E 742E                            je .invalid_move
  3415 00001D40 3C58                            cmp al, 'X'
  3416 00001D42 742A                            je .invalid_move
  3417 00001D44 3C40                            cmp al, '@'                 ; Enemigo nivel 1 y 5
  3418 00001D46 7426                            je .invalid_move
  3419 00001D48 3C23                            cmp al, '#'                 ; Enemigo nivel 2
  3420 00001D4A 7422                            je .invalid_move
  3421 00001D4C 3C24                            cmp al, '$'                 ; Enemigo nivel 3
  3422 00001D4E 741E                            je .invalid_move
  3423 00001D50 3C26                            cmp al, '&'                 ; Enemigo nivel 4
  3424 00001D52 741A                            je .invalid_move
  3425                                          
  3426 00001D54 E825000000                      call check_enemy_at_position
  3427 00001D59 4883F801                        cmp rax, 1
  3428 00001D5D 740F                            je .invalid_move
  3429 00001D5F 415A                            pop r10
  3430 00001D61 4159                            pop r9
  3431 00001D63 4158                            pop r8
  3432                                          
  3433                                          ; Guardar nueva posición si es válida
  3434 00001D65 448806                          mov [rsi], r8b
  3435 00001D68 44884E01                        mov [rsi + 1], r9b
  3436 00001D6C EB06                            jmp .next_enemy
  3437                                          
  3438                                      .invalid_move:
  3439 00001D6E 415A                            pop r10
  3440 00001D70 4159                            pop r9
  3441 00001D72 4158                            pop r8
  3442                                          
  3443                                      .next_enemy:
  3444 00001D74 49FFC4                          inc r12
  3445 00001D77 E9D1FDFFFF                      jmp .enemy_loop
  3446                                          
  3447                                      .end:
  3448 00001D7C 5D                              pop rbp
  3449 00001D7D C3                              ret
  3450                                  
  3451                                  check_enemy_at_position:
  3452 00001D7E 55                          push rbp
  3453 00001D7F 4889E5                      mov rbp, rsp
  3454                                      
  3455                                      ; Parámetros esperados en r8 (X) y r9 (Y)
  3456 00001D82 B850000000                  mov rax, column_cells
  3457 00001D87 4883C002                    add rax, 2
  3458 00001D8B 49F7E1                      mul r9
  3459 00001D8E 4C01C0                      add rax, r8
  3460 00001D91 488DB8[400A0000]            lea rdi, [board + rax]
  3461 00001D98 480FB607                    movzx rax, byte [rdi]
  3462                                      
  3463                                      ; Verificar todos los caracteres de enemigos
  3464 00001D9C 3C40                        cmp al, '@'
  3465 00001D9E 7411                        je .enemy_found
  3466 00001DA0 3C23                        cmp al, '#'
  3467 00001DA2 740D                        je .enemy_found
  3468 00001DA4 3C24                        cmp al, '$'
  3469 00001DA6 7409                        je .enemy_found
  3470 00001DA8 3C26                        cmp al, '&'
  3471 00001DAA 7405                        je .enemy_found
  3472                                      
  3473 00001DAC 4831C0                      xor rax, rax    ; No hay enemigo (retorna 0)
  3474 00001DAF EB05                        jmp .end
  3475                                      
  3476                                  .enemy_found:
  3477 00001DB1 B801000000                  mov rax, 1      ; Hay enemigo (retorna 1)
  3478                                      
  3479                                  .end:
  3480 00001DB6 5D                          pop rbp
  3481 00001DB7 C3                          ret
  3482                                  
  3483                                  get_current_spawn_points:
  3484 00001DB8 55                          push rbp
  3485 00001DB9 4889E5                      mov rbp, rsp
  3486                                      
  3487 00001DBC 480FB605(79150000)          movzx rax, byte [current_level]
  3488 00001DC4 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3489 00001DC7 488B04C5[BB190000]          mov rax, [spawn_points_table + rax * 8]
  3490                                      
  3491 00001DCF 5D                          pop rbp
  3492 00001DD0 C3                          ret
  3493                                  
  3494                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3495                                  check_enemy_spawn:
  3496 00001DD1 55                          push rbp
  3497 00001DD2 4889E5                      mov rbp, rsp
  3498                                      
  3499                                      ; Obtener spawn points del nivel actual
  3500 00001DD5 E8DEFFFFFF                  call get_current_spawn_points
  3501 00001DDA 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3502                                      
  3503                                      ; Obtener cantidad de bloques destruidos
  3504 00001DDD 4C0FB62D(43190000)          movzx r13, byte [destroyed_blocks]
  3505                                      
  3506                                      ; Verificar cada punto de spawn
  3507 00001DE5 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3508                                      
  3509                                      .check_loop:
  3510 00001DE8 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3511 00001DEC 7D4E                            jge .end
  3512                                          
  3513                                          ; Verificar si este spawn point ya fue usado
  3514 00001DEE 80B9[E6190000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3515 00001DF5 7440                            je .next_enemy
  3516                                          
  3517                                          ; Verificar si este enemigo ya está activo
  3518 00001DF7 4889C8                          mov rax, rcx
  3519 00001DFA 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3520 00001DFE 488DB0[5D190000]                lea rsi, [enemies + rax]
  3521 00001E05 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3522 00001E09 742C                            je .next_enemy
  3523                                          
  3524                                          ; Verificar si debemos spawnear este enemigo
  3525 00001E0B 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3526 00001E10 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3527 00001E13 7522                            jne .next_enemy
  3528                                          
  3529                                          ; Marcar este spawn point como usado
  3530 00001E15 C681[E6190000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3531                                          
  3532                                          ; Spawner nuevo enemigo
  3533 00001E1C B004                            mov al, 4
  3534 00001E1E 00C8                            add al, cl       ; con 'rcx' como índice
  3535 00001E20 8806                            mov [rsi], al
  3536 00001E22 C6460102                        mov byte [rsi+1], 2
  3537 00001E26 C6460201                        mov byte [rsi+2], 1
  3538                                  
  3539                                          ; Inicializar comportamiento
  3540 00001E2A 4889C8                          mov rax, rcx
  3541 00001E2D 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3542 00001E31 8805(E5190000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3543                                          
  3544                                      .next_enemy:
  3545 00001E37 48FFC1                          inc rcx
  3546 00001E3A EBAC                            jmp .check_loop
  3547                                          
  3548                                      .end:
  3549 00001E3C 5D                              pop rbp
  3550 00001E3D C3                              ret
  3551                                  
  3552                                  
  3553                                  ; Función para dibujar enemigos
  3554                                  print_enemies:
  3555 00001E3E 55                          push rbp
  3556 00001E3F 4889E5                      mov rbp, rsp
  3557                                      
  3558 00001E42 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3559                                      
  3560                                      .print_loop:
  3561 00001E45 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3562 00001E49 7D4B                            jge .end
  3563                                          
  3564                                          ; Calcular offset del enemigo actual
  3565 00001E4B 4C89E0                          mov rax, r12
  3566 00001E4E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3567 00001E52 488DB0[5D190000]                lea rsi, [enemies + rax]
  3568                                          
  3569                                          ; Verificar si el enemigo está activo
  3570 00001E59 807E0201                        cmp byte [rsi + 2], 1
  3571 00001E5D 7532                            jne .next_enemy
  3572                                          
  3573                                          ; Calcular posición en el tablero
  3574 00001E5F 4C0FB606                        movzx r8, byte [rsi]            ; X
  3575 00001E63 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3576                                          
  3577                                          ; Calcular offset en el tablero
  3578 00001E68 B850000000                      mov rax, column_cells
  3579 00001E6D 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3580 00001E71 49F7E1                          mul r9
  3581 00001E74 4C01C0                          add rax, r8
  3582 00001E77 488DB8[400A0000]                lea rdi, [board + rax]
  3583                                          
  3584                                          ; Obtener carácter del enemigo según el nivel
  3585 00001E7E 480FB605(79150000)              movzx rax, byte [current_level]
  3586 00001E86 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3587 00001E89 8A80[58190000]                  mov al, [enemy_chars + rax]
  3588                                          
  3589                                          ; Dibujar enemigo
  3590 00001E8F 8807                            mov [rdi], al
  3591                                          
  3592                                      .next_enemy:
  3593 00001E91 49FFC4                          inc r12
  3594 00001E94 EBAF                            jmp .print_loop
  3595                                          
  3596                                      .end:
  3597 00001E96 5D                              pop rbp
  3598 00001E97 C3                              ret
  3599                                  
  3600                                  ; Función para verificar colisión con enemigos
  3601                                  ; Función para verificar colisión con enemigos
  3602                                  check_enemy_collision:
  3603 00001E98 55                          push rbp
  3604 00001E99 4889E5                      mov rbp, rsp
  3605                                      
  3606 00001E9C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3607 00001E9F 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3608                                      
  3609                                      .check_loop:
  3610 00001EA2 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3611 00001EA6 0F8DE9000000                    jge .end
  3612                                          
  3613                                          ; Calcular offset del enemigo actual
  3614 00001EAC 4C89E1                          mov rcx, r12
  3615 00001EAF 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3616 00001EB3 488DB1[5D190000]                lea rsi, [enemies + rcx]
  3617                                          
  3618                                          ; Verificar si el enemigo está activo
  3619 00001EBA 807E0201                        cmp byte [rsi + 2], 1
  3620 00001EBE 0F85C9000000                    jne .next_enemy
  3621                                          
  3622                                          ; Verificar colisión con la bola
  3623 00001EC4 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3624 00001EC8 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3625                                          
  3626                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3627 00001ECD 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3628 00001ED4 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  3629                                          
  3630                                          ; Comprobar colisión vertical (misma columna)
  3631 00001EDB 4D39C2                          cmp r10, r8
  3632 00001EDE 7525                            jne .check_horizontal
  3633 00001EE0 4D29CB                          sub r11, r9
  3634 00001EE3 4983FB01                        cmp r11, 1
  3635 00001EE7 7F1C                            jg .check_horizontal
  3636 00001EE9 4983FBFF                        cmp r11, -1
  3637 00001EED 7C16                            jl .check_horizontal
  3638                                          
  3639                                          ; Colisión vertical detectada
  3640 00001EEF E8A3000000                      call destroy_enemy
  3641 00001EF4 48F71D(F7140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3642 00001EFB B801000000                      mov rax, 1
  3643 00001F00 E990000000                      jmp .end
  3644                                          
  3645                                      .check_horizontal:
  3646                                          ; Comprobar colisión horizontal (misma fila)
  3647 00001F05 4C8B15(DF140000)                mov r10, [ball_x_pos]
  3648 00001F0C 4C8B1D(E7140000)                mov r11, [ball_y_pos]
  3649 00001F13 4D39CB                          cmp r11, r9
  3650 00001F16 7522                            jne .check_paddle
  3651 00001F18 4D29C2                          sub r10, r8
  3652 00001F1B 4983FA01                        cmp r10, 1
  3653 00001F1F 7F19                            jg .check_paddle
  3654 00001F21 4983FAFF                        cmp r10, -1
  3655 00001F25 7C13                            jl .check_paddle
  3656                                          
  3657                                          ; Colisión horizontal detectada
  3658 00001F27 E86B000000                      call destroy_enemy
  3659 00001F2C 48F71D(EF140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3660 00001F33 B801000000                      mov rax, 1
  3661 00001F38 EB5B                            jmp .end
  3662                                          
  3663                                      .check_paddle:
  3664                                          ; Verificar colisión con la paleta
  3665 00001F3A 4C8B15(BF140000)                mov r10, [pallet_position]
  3666 00001F41 4981EA[400A0000]                sub r10, board
  3667 00001F48 4C89D0                          mov rax, r10
  3668 00001F4B 41BB50000000                    mov r11, column_cells
  3669 00001F51 4983C302                        add r11, 2
  3670 00001F55 4831D2                          xor rdx, rdx
  3671 00001F58 49F7F3                          div r11                     ; División para obtener la posición Y
  3672 00001F5B 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3673                                          
  3674 00001F5E 488B0D(C7140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3675                                          
  3676                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3677 00001F65 41BD20000000                    mov r13, row_cells
  3678 00001F6B 4983ED02                        sub r13, 2                 ; Y de la paleta
  3679 00001F6F 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3680 00001F72 7519                            jne .next_enemy
  3681                                          
  3682                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3683 00001F74 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3684 00001F77 7C14                            jl .next_enemy
  3685                                          
  3686 00001F79 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3687 00001F7C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3688 00001F7F 7F0C                            jg .next_enemy
  3689                                          
  3690                                          ; Si llegamos aquí, hay colisión con la paleta
  3691 00001F81 E811000000                      call destroy_enemy        ; Destruir el enemigo
  3692 00001F86 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3693 00001F8B EB08                            jmp .end
  3694                                          
  3695                                      .next_enemy:
  3696 00001F8D 49FFC4                          inc r12
  3697 00001F90 E90DFFFFFF                      jmp .check_loop
  3698                                          
  3699                                      .end:
  3700 00001F95 5D                              pop rbp
  3701 00001F96 C3                              ret
  3702                                  
  3703                                  ; Función para destruir un enemigo
  3704                                  destroy_enemy:
  3705                                      ; Desactivar enemigo
  3706 00001F97 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3707                                  
  3708                                      ; Sumar puntos por destruir enemigo
  3709 00001F9B 488B05(7C190000)            mov rax, [enemy_points]
  3710 00001FA2 480105(3B190000)            add [current_score], rax
  3711                                  
  3712                                      ; No tocar bloques destruidos aquí
  3713 00001FA9 C3                          ret
  3714                                  
  3715                                  
  3716                                  _start:
  3717 00001FAA E87CE1FFFF              	call canonical_off
  3718 00001FAF E853010000              	call start_screen
  3719 00001FB4 E8C9F3FFFF                  call init_level
  3720 00001FB9 E829FAFFFF                  call init_enemies
  3721 00001FBE EB00                    	jmp .main_loop
  3722                                  	
  3723                                  
  3724                                      .main_loop:
  3725 00001FC0 E8E0F7FFFF                      call print_labels
  3726 00001FC5 E80FF7FFFF                      call print_blocks
  3727 00001FCA E86BE5FFFF                      call move_letters
  3728 00001FCF E82AE8FFFF                      call update_lasers
  3729 00001FD4 E8D6E4FFFF                      call print_letters
  3730 00001FD9 E8CBEBFFFF                      call print_pallet
  3731                                          
  3732                                          ; Mover bola principal solo si está activa
  3733 00001FDE 803D(00150000)01                cmp byte [ball_active], 1
  3734 00001FE5 7505                            jne .skip_ball1
  3735 00001FE7 E8D5ECFFFF                          call move_ball
  3736                                          .skip_ball1:
  3737                                  
  3738                                          ; Mover bola 2 si está activa
  3739 00001FEC 803D(22150000)01                cmp byte [ball2_active], 1
  3740 00001FF3 7505                            jne .skip_ball2
  3741 00001FF5 E89AEEFFFF                          call move_ball_2
  3742                                          .skip_ball2:
  3743                                  
  3744                                          ; Mover bola 3 si está activa
  3745 00001FFA 803D(44150000)01                cmp byte [ball3_active], 1
  3746 00002001 7505                            jne .skip_ball3
  3747 00002003 E85FF0FFFF                          call move_ball_3
  3748                                          .skip_ball3:
  3749                                  
  3750 00002008 E8E9E2FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3751 0000200D E8CBE1FFFF                      call print_lives
  3752                                  
  3753                                          ; Imprimir solo las bolas activas
  3754 00002012 803D(00150000)01                cmp byte [ball_active], 1
  3755 00002019 7505                            jne .no_pb1
  3756 0000201B E811EBFFFF                          call print_ball
  3757                                          .no_pb1:
  3758                                  
  3759 00002020 803D(22150000)01                cmp byte [ball2_active], 1
  3760 00002027 7505                            jne .no_pb2
  3761 00002029 E82BEBFFFF                          call print_ball_2
  3762                                          .no_pb2:
  3763                                  
  3764 0000202E 803D(44150000)01                cmp byte [ball3_active], 1
  3765 00002035 7505                            jne .no_pb3
  3766 00002037 E845EBFFFF                          call print_ball_3
  3767                                          .no_pb3:
  3768                                  
  3769 0000203C E8FAF4FFFF                      call check_level_complete
  3770 00002041 E88BFDFFFF                      call check_enemy_spawn
  3771 00002046 E8DAFAFFFF                      call move_enemies
  3772 0000204B E848FEFFFF                      call check_enemy_collision
  3773 00002050 E8E9FDFFFF                      call print_enemies
  3774                                  		print board, board_size				
    82 00002055 B801000000          <1>  mov eax, sys_write
    83 0000205A BF01000000          <1>  mov edi, 1
    84 0000205F 48BE-               <1>  mov rsi, %1
    84 00002061 [400A000000000000]  <1>
    85 00002069 BA400A0000          <1>  mov edx, %2
    86 0000206E 0F05                <1>  syscall
  3775                                  		;setnonblocking	
  3776                                  	.read_more:	
  3777                                  	    getchar	
    90 00002070 B800000000          <1>  mov rax, sys_read
    91 00002075 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000207A 48BE-               <1>  mov rsi, input_char
    92 0000207C [0000000000000000]  <1>
    93 00002084 BA01000000          <1>  mov rdx, 1
    94 00002089 0F05                <1>  syscall
  3778 0000208B 4883F801                	    cmp rax, 1
  3779 0000208F 7543                    	    jne .done
  3780                                  	
  3781 00002091 8A05(00000000)          	    mov al, [input_char]
  3782 00002097 8805(041C0000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3783                                  	
  3784 0000209D 3C61                    	    cmp al, 'a'
  3785 0000209F 750E                    	    jne .not_left
  3786 000020A1 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3787 000020A8 E831EBFFFF              	    call move_pallet
  3788 000020AD EB25                    	    jmp .done
  3789                                  	
  3790                                      .not_left:
  3791 000020AF 3C64                    	    cmp al, 'd'
  3792 000020B1 750C                    	    jne .not_right
  3793 000020B3 BF01000000              	    mov rdi, right_direction
  3794 000020B8 E821EBFFFF              	    call move_pallet
  3795 000020BD EB15                    	    jmp .done
  3796                                  	
  3797                                      .not_right:
  3798 000020BF 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3799 000020C1 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3800                                  	
  3801 000020C3 3C71                    	    cmp al, 'q' 
  3802 000020C5 0F84AF000000            	    je exit
  3803 000020CB EBA3                    	    jmp .read_more
  3804                                  	
  3805                                      .release_ball:
  3806 000020CD E868F1FFFF              	    call process_catch_release
  3807 000020D2 EB00                    	    jmp .done
  3808                                  	
  3809                                      .done:
  3810                                  	    sleeptime
    98 000020D4 B823000000          <1>  mov eax, sys_nanosleep
    99 000020D9 48BF-               <1>  mov rdi, timespec
    99 000020DB [0000000000000000]  <1>
   100 000020E3 31F6                <1>  xor esi, esi
   101 000020E5 0F05                <1>  syscall
  3811                                  	    print clear, clear_length
    82 000020E7 B801000000          <1>  mov eax, sys_write
    83 000020EC BF01000000          <1>  mov edi, 1
    84 000020F1 48BE-               <1>  mov rsi, %1
    84 000020F3 [1000000000000000]  <1>
    85 000020FB BA07000000          <1>  mov edx, %2
    86 00002100 0F05                <1>  syscall
  3812 00002102 E9B9FEFFFF              	    jmp .main_loop
  3813                                  
  3814                                  
  3815                                  
  3816                                  
  3817                                  start_screen:
  3818                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00002107 B801000000          <1>  mov eax, sys_write
    83 0000210C BF01000000          <1>  mov edi, 1
    84 00002111 48BE-               <1>  mov rsi, %1
    84 00002113 [1000000000000000]  <1>
    85 0000211B BA07000000          <1>  mov edx, %2
    86 00002120 0F05                <1>  syscall
  3819                                      print msg1, msg1_length
    82 00002122 B801000000          <1>  mov eax, sys_write
    83 00002127 BF01000000          <1>  mov edi, 1
    84 0000212C 48BE-               <1>  mov rsi, %1
    84 0000212E [1700000000000000]  <1>
    85 00002136 BA14010000          <1>  mov edx, %2
    86 0000213B 0F05                <1>  syscall
  3820                                      
  3821                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3822                                          getchar                 ; Esperamos una tecla
    90 0000213D B800000000          <1>  mov rax, sys_read
    91 00002142 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00002147 48BE-               <1>  mov rsi, input_char
    92 00002149 [0000000000000000]  <1>
    93 00002151 BA01000000          <1>  mov rdx, 1
    94 00002156 0F05                <1>  syscall
  3823 00002158 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3824 0000215C 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3825                                          
  3826                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000215E B801000000          <1>  mov eax, sys_write
    83 00002163 BF01000000          <1>  mov edi, 1
    84 00002168 48BE-               <1>  mov rsi, %1
    84 0000216A [1000000000000000]  <1>
    85 00002172 BA07000000          <1>  mov edx, %2
    86 00002177 0F05                <1>  syscall
  3827 00002179 C3                          ret
  3828                                  
  3829                                  exit: 
  3830 0000217A E8EEDFFFFF              	call canonical_on
  3831 0000217F B83C000000              	mov    rax, 60
  3832 00002184 BF00000000                  mov    rdi, 0
  3833 00002189 0F05                        syscall
  3834                                  
