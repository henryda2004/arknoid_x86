     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE ENTER PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452045-
    41 00000106 4E5445522050415241-
    41 0000010F 20494E494349415220-
    41 00000118 202020202020200A0D 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	board:
   115                                  		full_line
    70 00000000 58<rep 50h>         <1>  times column_cells db "X"
    71 00000050 0A0D                <1>  db 0x0a, 0xD
   116                                          %rep 30
   117                                          hollow_line
   118                                          %endrep
   117                              <1>  hollow_line
    75 00000052 58                  <2>  db "X"
    76 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000000A4 58                  <2>  db "X"
    76 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000000F6 58                  <2>  db "X"
    76 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000148 58                  <2>  db "X"
    76 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000019A 58                  <2>  db "X"
    76 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000001EC 58                  <2>  db "X"
    76 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000023E 58                  <2>  db "X"
    76 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000290 58                  <2>  db "X"
    76 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000002E2 58                  <2>  db "X"
    76 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000334 58                  <2>  db "X"
    76 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000386 58                  <2>  db "X"
    76 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000003D8 58                  <2>  db "X"
    76 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000042A 58                  <2>  db "X"
    76 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000047C 58                  <2>  db "X"
    76 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000004CE 58                  <2>  db "X"
    76 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000520 58                  <2>  db "X"
    76 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000572 58                  <2>  db "X"
    76 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000005C4 58                  <2>  db "X"
    76 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000616 58                  <2>  db "X"
    76 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000668 58                  <2>  db "X"
    76 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000006BA 58                  <2>  db "X"
    76 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000070C 58                  <2>  db "X"
    76 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000075E 58                  <2>  db "X"
    76 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000007B0 58                  <2>  db "X"
    76 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000802 58                  <2>  db "X"
    76 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000854 58                  <2>  db "X"
    76 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000008A6 58                  <2>  db "X"
    76 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000008F8 58                  <2>  db "X"
    76 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000094A 58                  <2>  db "X"
    76 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000099C 58                  <2>  db "X"
    76 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   119                                          full_line
    70 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    71 00000A3E 0A0D                <1>  db 0x0a, 0xD
   120                                  	board_size:   equ   $ - board
   121                                  
   122                                  	; Added for the terminal issue
   123 00000A40 00<rep 24h>             	termios:        times 36 db 0
   124                                  	stdin:          equ 0
   125                                  	ICANON:         equ 1<<1
   126                                  	ECHO:           equ 1<<3
   127                                  	VTIME: 			equ 5
   128                                  	VMIN:			equ 6
   129                                  	CC_C:			equ 18
   130                                  
   131                                  section .text
   132                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   133                                  canonical_off:
   134 00000121 E86F000000                      call read_stdin_termios
   135                                  
   136                                          ; clear canonical bit in local mode flags
   137 00000126 50                              push rax
   138 00000127 B802000000                      mov eax, ICANON
   139 0000012C F7D0                            not eax
   140 0000012E 2105(4C0A0000)                  and [termios+12], eax
   141 00000134 C605(570A0000)00        		mov byte[termios+CC_C+VTIME], 0
   142 0000013B C605(580A0000)00        		mov byte[termios+CC_C+VMIN], 0
   143 00000142 58                              pop rax
   144                                  
   145 00000143 E86C000000                      call write_stdin_termios
   146 00000148 C3                              ret
   147                                  
   148                                  echo_off:
   149 00000149 E847000000                      call read_stdin_termios
   150                                  
   151                                          ; clear echo bit in local mode flags
   152 0000014E 50                              push rax
   153 0000014F B808000000                      mov eax, ECHO
   154 00000154 F7D0                            not eax
   155 00000156 2105(4C0A0000)                  and [termios+12], eax
   156 0000015C 58                              pop rax
   157                                  
   158 0000015D E852000000                      call write_stdin_termios
   159 00000162 C3                              ret
   160                                  
   161                                  canonical_on:
   162 00000163 E82D000000                      call read_stdin_termios
   163                                  
   164                                          ; set canonical bit in local mode flags
   165 00000168 830D(4C0A0000)02                or dword [termios+12], ICANON
   166 0000016F C605(570A0000)00        		mov byte[termios+CC_C+VTIME], 0
   167 00000176 C605(580A0000)01        		mov byte[termios+CC_C+VMIN], 1
   168 0000017D E832000000                      call write_stdin_termios
   169 00000182 C3                              ret
   170                                  
   171                                  echo_on:
   172 00000183 E80D000000                      call read_stdin_termios
   173                                  
   174                                          ; set echo bit in local mode flags
   175 00000188 830D(4C0A0000)08                or dword [termios+12], ECHO
   176                                  
   177 0000018F E820000000                      call write_stdin_termios
   178 00000194 C3                              ret
   179                                  
   180                                  read_stdin_termios:
   181 00000195 50                              push rax
   182 00000196 53                              push rbx
   183 00000197 51                              push rcx
   184 00000198 52                              push rdx
   185                                  
   186 00000199 B836000000                      mov eax, 36h
   187 0000019E BB00000000                      mov ebx, stdin
   188 000001A3 B901540000                      mov ecx, 5401h
   189 000001A8 BA[400A0000]                    mov edx, termios
   190 000001AD CD80                            int 80h
   191                                  
   192 000001AF 5A                              pop rdx
   193 000001B0 59                              pop rcx
   194 000001B1 5B                              pop rbx
   195 000001B2 58                              pop rax
   196 000001B3 C3                              ret
   197                                  
   198                                  write_stdin_termios:
   199 000001B4 50                              push rax
   200 000001B5 53                              push rbx
   201 000001B6 51                              push rcx
   202 000001B7 52                              push rdx
   203                                  
   204 000001B8 B836000000                      mov eax, 36h
   205 000001BD BB00000000                      mov ebx, stdin
   206 000001C2 B902540000                      mov ecx, 5402h
   207 000001C7 BA[400A0000]                    mov edx, termios
   208 000001CC CD80                            int 80h
   209                                  
   210 000001CE 5A                              pop rdx
   211 000001CF 59                              pop rcx
   212 000001D0 5B                              pop rbx
   213 000001D1 58                              pop rax
   214 000001D2 C3                              ret
   215                                  
   216                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   217                                  
   218                                  char_equal: equ 61
   219                                  char_space: equ 32
   220                                  char_O: equ 79
   221                                  left_direction: equ -1
   222                                  right_direction: equ 1
   223                                  
   224                                  
   225                                  section .data
   226 00000A64 [7209000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   227 00000A6C 0300000000000000        	pallet_size dq 3
   228                                  
   229 00000A74 2800000000000000        	ball_x_pos: dq 40
   230 00000A7C 1C00000000000000        	ball_y_pos: dq 28
   231 00000A84 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   232 00000A8C FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   233 00000A94 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   234                                  
   235                                  ; Definir los límites de la pantalla o área de juego
   236                                      board_top_left_x equ 1
   237                                      board_top_left_y equ 1
   238                                      board_bottom_right_x equ column_cells - 1
   239                                      board_bottom_right_y equ row_cells
   240                                  
   241                                      ; Limites laterales
   242                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   243                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   244                                  
   245                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   246 00000A95 [5200000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   247 00000A9D [A000000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   248                                  
   249                                      ; Caracteres para los bloques
   250                                      char_block equ 'U'
   251                                      
   252                                      ; Estructura para el nivel actual
   253 00000AA5 01                          current_level db 1          ; Nivel actual
   254 00000AA6 00                          blocks_remaining db 0       ; Bloques restantes por destruir
   255                                      
   256                                      ; Definición del nivel 1 (ejemplo con un bloque de 4 'U's)
   257                                      level1_blocks:
   258                                          ; Formato: x_pos, y_pos, durability
   259 00000AA7 260501                          db 38, 5, 1  ; Primer bloque - posición x
   260 00000AAA 270501                          db 39, 5, 1  ; Segundo bloque
   261 00000AAD 280501                          db 40, 5, 1  ; Tercer bloque
   262 00000AB0 290501                          db 41, 5, 1  ; Cuarto bloque
   263                                      level1_blocks_count equ 4   ; Cantidad de bloques en nivel 1
   264                                  
   265                                      ; Array para mantener el estado de los bloques
   266 00000AB3 01<rep 64h>                 block_states: times 100 db 1  ; Máximo 100 bloques, 1=activo, 0=destruido
   267                                  
   268                                  
   269                                  section .text
   270                                  
   271                                  ;	Function: print_ball
   272                                  ; This function displays the position of the ball
   273                                  ; Arguments: none
   274                                  ;
   275                                  ; Return:
   276                                  ;	Void
   277                                  print_ball:
   278 000001D3 4C8B05(740A0000)        	mov r8, [ball_x_pos]
   279 000001DA 4C8B0D(7C0A0000)        	mov r9, [ball_y_pos]
   280 000001E1 4981C0[00000000]        	add r8, board
   281                                  
   282 000001E8 4C89C9                  	mov rcx, r9
   283 000001EB B852000000              	mov rax, column_cells + 2
   284 000001F0 48F7E9                  	imul rcx
   285                                  	
   286 000001F3 4901C0                  	add r8, rax
   287 000001F6 41C6004F                	mov byte [r8], char_O
   288 000001FA C3                      	ret
   289                                  
   290                                  	
   291                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   292                                  	
   293                                  
   294                                  
   295                                  
   296                                  ;	Function: print_pallet
   297                                  ; This function moves the pallet in the game
   298                                  ; Arguments: none
   299                                  ;
   300                                  ; Return;
   301                                  ;	void
   302                                  print_pallet:
   303 000001FB 4C8B05(640A0000)        	mov r8, [pallet_position]
   304 00000202 488B0D(6C0A0000)        	mov rcx, [pallet_size]
   305                                  	.write_pallet:
   306 00000209 41C6003D                		mov byte [r8], char_equal
   307 0000020D 49FFC0                  		inc r8
   308 00000210 48FFC9                  		dec rcx
   309 00000213 75F4                    		jnz .write_pallet
   310                                  
   311 00000215 C3                      	ret
   312                                  	
   313                                  ;	Function: move_pallet
   314                                  ; This function is in charge of moving the pallet in a given direction
   315                                  ; Arguments:
   316                                  ;	rdi: left direction or right direction
   317                                  ;
   318                                  ; Return:
   319                                  ;	void
   320                                  move_pallet:
   321                                      
   322 00000216 803D(940A0000)00            cmp byte [ball_moving], 0
   323 0000021D 7507                        jne .continue_movement
   324 0000021F C605(940A0000)01            mov byte [ball_moving], 1
   325                                  
   326                                      .continue_movement:
   327 00000226 4883FFFF                        cmp rdi, left_direction
   328 0000022A 7531                            jne .move_right
   329                                  
   330                                          .move_left:
   331                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   332 0000022C 4C8B05(640A0000)                    mov r8, [pallet_position]
   333 00000233 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   334 00000236 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   335 00000239 3C58                                cmp al, 'X'        ; Comparar si es una X
   336 0000023B 744D                                je .end            ; Si es X, no mover
   337                                              
   338 0000023D 4C8B05(640A0000)                    mov r8, [pallet_position]
   339 00000244 4C8B0D(6C0A0000)                    mov r9, [pallet_size]
   340 0000024B 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   341 00000251 49FFC8                              dec r8
   342 00000254 4C8905(640A0000)                    mov [pallet_position], r8
   343 0000025B EB2D                                jmp .end
   344                                              
   345                                          .move_right:
   346                                              ; Verificar si la siguiente posición después de la paleta sería una X
   347 0000025D 4C8B05(640A0000)                    mov r8, [pallet_position]
   348 00000264 4C8B0D(6C0A0000)                    mov r9, [pallet_size]
   349 0000026B 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   350 0000026E 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   351 00000271 3C58                                cmp al, 'X'        ; Comparar si es una X
   352 00000273 7415                                je .end            ; Si es X, no mover
   353                                              
   354 00000275 4C8B05(640A0000)                    mov r8, [pallet_position]
   355 0000027C 41C60020                            mov byte [r8], char_space
   356 00000280 49FFC0                              inc r8
   357 00000283 4C8905(640A0000)                    mov [pallet_position], r8
   358                                          .end:
   359 0000028A C3                                  ret
   360                                  
   361                                  move_ball:
   362                                      ; Si la bola no está en movimiento, no hacer nada
   363 0000028B 803D(940A0000)00            cmp byte [ball_moving], 0
   364 00000292 0F8406010000                je .end
   365                                  
   366                                      ; Borrar la posición actual de la bola
   367 00000298 4C8B05(740A0000)            mov r8, [ball_x_pos]
   368 0000029F 4C8B0D(7C0A0000)            mov r9, [ball_y_pos]
   369 000002A6 4981C0[00000000]            add r8, board
   370 000002AD 4C89C9                      mov rcx, r9
   371 000002B0 B852000000                  mov rax, column_cells + 2
   372 000002B5 48F7E9                      imul rcx
   373 000002B8 4901C0                      add r8, rax
   374 000002BB 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   375                                  
   376                                      ; Calcular siguiente posición X
   377 000002BF 4C8B05(740A0000)            mov r8, [ball_x_pos]
   378 000002C6 4C8B0D(7C0A0000)            mov r9, [ball_y_pos]
   379 000002CD 488B05(840A0000)            mov rax, [ball_direction_x]
   380 000002D4 4901C0                      add r8, rax                  ; Nueva posición X
   381                                  
   382                                      ; Calcular la dirección de memoria para la siguiente posición
   383 000002D7 4D89C2                      mov r10, r8
   384 000002DA 4981C2[00000000]            add r10, board
   385 000002E1 4C89C9                      mov rcx, r9
   386 000002E4 B852000000                  mov rax, column_cells + 2
   387 000002E9 48F7E9                      imul rcx
   388 000002EC 4901C2                      add r10, rax
   389                                  
   390                                      ; Verificar si hay una X en la siguiente posición X
   391 000002EF 418A02                      mov al, [r10]
   392 000002F2 3C58                        cmp al, 'X'
   393 000002F4 750C                        jne .check_block_x
   394 000002F6 48F71D(840A0000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   395 000002FD E99C000000                  jmp .end
   396                                  
   397                                      .check_block_x:
   398                                          ; Verificar colisión con bloques en X
   399 00000302 4150                            push r8     ; Guardar registros que usa check_block_collision
   400 00000304 4151                            push r9
   401 00000306 4152                            push r10
   402 00000308 E8F7000000                      call check_block_collision
   403 0000030D 415A                            pop r10
   404 0000030F 4159                            pop r9
   405 00000311 4158                            pop r8
   406 00000313 4885C0                          test rax, rax
   407 00000316 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   408 00000318 48F71D(840A0000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   409 0000031F EB7D                            jmp .end
   410                                  
   411                                      .check_paddle_x:
   412                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   413 00000321 41803A3D                        cmp byte [r10], char_equal
   414 00000325 7509                            jne .check_y_movement
   415 00000327 48F71D(840A0000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   416 0000032E EB6E                            jmp .end
   417                                  
   418                                      .check_y_movement:
   419                                          ; Calcular siguiente posición Y
   420 00000330 488B05(8C0A0000)                mov rax, [ball_direction_y]
   421 00000337 4901C1                          add r9, rax                  ; Nueva posición Y
   422                                  
   423                                          ; Calcular la dirección de memoria para la siguiente posición Y
   424 0000033A 4D89C2                          mov r10, r8
   425 0000033D 4981C2[00000000]                add r10, board
   426 00000344 4C89C9                          mov rcx, r9
   427 00000347 B852000000                      mov rax, column_cells + 2
   428 0000034C 48F7E9                          imul rcx
   429 0000034F 4901C2                          add r10, rax
   430                                  
   431                                          ; Verificar si hay una X en la siguiente posición Y
   432 00000352 418A02                          mov al, [r10]
   433 00000355 3C58                            cmp al, 'X'
   434 00000357 7509                            jne .check_block_y
   435 00000359 48F71D(8C0A0000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   436 00000360 EB3C                            jmp .end
   437                                  
   438                                      .check_block_y:
   439                                          ; Verificar colisión con bloques en Y
   440 00000362 4150                            push r8     ; Guardar registros que usa check_block_collision
   441 00000364 4151                            push r9
   442 00000366 4152                            push r10
   443 00000368 E897000000                      call check_block_collision
   444 0000036D 415A                            pop r10
   445 0000036F 4159                            pop r9
   446 00000371 4158                            pop r8
   447 00000373 4885C0                          test rax, rax
   448 00000376 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   449 00000378 48F71D(8C0A0000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   450 0000037F EB1D                            jmp .end
   451                                  
   452                                      .check_paddle_y:
   453                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   454 00000381 41803A3D                    cmp byte [r10], char_equal
   455 00000385 7509                        jne .update_position
   456 00000387 48F71D(8C0A0000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   457 0000038E EB0E                        jmp .end
   458                                  
   459                                  
   460                                      .update_position:
   461 00000390 4C8905(740A0000)                mov [ball_x_pos], r8
   462 00000397 4C890D(7C0A0000)                mov [ball_y_pos], r9
   463                                  
   464                                      .end:
   465 0000039E C3                              ret
   466                                  
   467                                  ; Función para inicializar el nivel
   468                                  init_level:
   469                                      ; Establecer la cantidad de bloques restantes
   470 0000039F B004                        mov al, level1_blocks_count
   471 000003A1 8805(A60A0000)              mov [blocks_remaining], al
   472                                      
   473                                      ; Inicializar estados de los bloques
   474 000003A7 B904000000                  mov rcx, level1_blocks_count
   475 000003AC 48BF-                       mov rdi, block_states
   475 000003AE [B30A000000000000] 
   476 000003B6 B001                        mov al, 1
   477 000003B8 F3AA                        rep stosb                   ; Establecer todos los bloques como activos
   478 000003BA C3                          ret
   479                                  
   480                                  ; Función para imprimir los bloques
   481                                  print_blocks:
   482 000003BB 4D31E4                      xor r12, r12               ; Índice del bloque actual
   483                                      
   484                                  .print_loop:
   485 000003BE 4983FC04                    cmp r12, level1_blocks_count
   486 000003C2 7D3F                        jge .end
   487                                      
   488                                      ; Verificar si el bloque está activo
   489 000003C4 418A8424[B30A0000]          mov al, [block_states + r12]
   490 000003CC 84C0                        test al, al
   491 000003CE 742E                        jz .next_block             ; Si está destruido, saltar al siguiente
   492                                      
   493                                      ; Calcular posición en el tablero
   494 000003D0 478A8464[A70A0000]          mov r8b, [level1_blocks + r12 * 3]     ; X position
   495 000003D8 478A8C64[A80A0000]          mov r9b, [level1_blocks + r12 * 3 + 1] ; Y position
   496                                      
   497                                      ; Convertir posición a dirección de memoria
   498 000003E0 4D0FB6C0                    movzx r8, r8b
   499 000003E4 4D0FB6C9                    movzx r9, r9b
   500 000003E8 4981C0[00000000]            add r8, board
   501 000003EF B852000000                  mov rax, column_cells + 2
   502 000003F4 49F7E1                      mul r9
   503 000003F7 4901C0                      add r8, rax
   504                                      
   505                                      ; Imprimir el bloque
   506 000003FA 41C60055                    mov byte [r8], char_block
   507                                      
   508                                  .next_block:
   509 000003FE 49FFC4                      inc r12
   510 00000401 EBBB                        jmp .print_loop
   511                                      
   512                                  .end:
   513 00000403 C3                          ret
   514                                  
   515                                  ; Función para detectar colisión con bloques
   516                                  check_block_collision:
   517                                      ; r8 = x_pos de la bola
   518                                      ; r9 = y_pos de la bola
   519                                      
   520 00000404 4D31E4                      xor r12, r12               ; Índice del bloque actual
   521                                      
   522                                  .check_loop:
   523 00000407 4983FC04                    cmp r12, level1_blocks_count
   524 0000040B 7D40                        jge .no_collision
   525                                      
   526                                      ; Verificar si el bloque está activo
   527 0000040D 418A8424[B30A0000]          mov al, [block_states + r12]
   528 00000415 84C0                        test al, al
   529 00000417 742F                        jz .next_block             ; Si está destruido, saltar al siguiente
   530                                      
   531                                      ; Verificar colisión
   532 00000419 438A8464[A70A0000]          mov al, [level1_blocks + r12 * 3]     ; X position del bloque
   533 00000421 4138C0                      cmp r8b, al
   534 00000424 7522                        jne .next_block
   535                                      
   536 00000426 438A8464[A80A0000]          mov al, [level1_blocks + r12 * 3 + 1] ; Y position del bloque
   537 0000042E 4138C1                      cmp r9b, al
   538 00000431 7515                        jne .next_block
   539                                      
   540                                      ; Colisión detectada
   541 00000433 41C68424[B30A0000]-         mov byte [block_states + r12], 0  ; Destruir el bloque
   541 0000043B 00                 
   542 0000043C FE0D(A60A0000)              dec byte [blocks_remaining]       ; Decrementar contador de bloques
   543 00000442 B801000000                  mov rax, 1                        ; Retornar 1 indicando colisión
   544 00000447 C3                          ret
   545                                      
   546                                  .next_block:
   547 00000448 49FFC4                      inc r12
   548 0000044B EBBA                        jmp .check_loop
   549                                      
   550                                  .no_collision:
   551 0000044D 4831C0                      xor rax, rax                      ; Retornar 0 indicando no colisión
   552 00000450 C3                          ret
   553                                  
   554                                  _start:
   555 00000451 E8CBFCFFFF              	call canonical_off
   556 00000456 E8D9000000              	call start_screen
   557 0000045B E83FFFFFFF                  call init_level
   558 00000460 EB00                    	jmp .main_loop
   559                                  	
   560                                  
   561                                  	.main_loop:
   562 00000462 E894FDFFFF              		call print_pallet
   563 00000467 E81FFEFFFF                      call move_ball
   564 0000046C E84AFFFFFF                      call print_blocks
   565 00000471 E85DFDFFFF              		call print_ball
   566                                  		print board, board_size				
    82 00000476 B801000000          <1>  mov eax, sys_write
    83 0000047B BF01000000          <1>  mov edi, 1
    84 00000480 48BE-               <1>  mov rsi, %1
    84 00000482 [0000000000000000]  <1>
    85 0000048A BA400A0000          <1>  mov edx, %2
    86 0000048F 0F05                <1>  syscall
   567                                  		;setnonblocking	
   568                                  	.read_more:	
   569                                  		getchar	
    90 00000491 B800000000          <1>  mov rax, sys_read
    91 00000496 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000049B 48BE-               <1>  mov rsi, input_char
    92 0000049D [0000000000000000]  <1>
    93 000004A5 BA01000000          <1>  mov rdx, 1
    94 000004AA 0F05                <1>  syscall
   570                                  		
   571 000004AC 4883F801                		cmp rax, 1
   572 000004B0 7532                        	jne .done
   573                                  		
   574 000004B2 8A05(00000000)          		mov al,[input_char]
   575                                  
   576 000004B8 3C61                    		cmp al, 'a'
   577 000004BA 750E                    	    jne .not_left
   578 000004BC 48C7C7FFFFFFFF          	    mov rdi, left_direction
   579 000004C3 E84EFDFFFF              		call move_pallet
   580 000004C8 EB1A                    	    jmp .done
   581                                  		
   582                                  		.not_left:
   583 000004CA 3C64                    		 	cmp al, 'd'
   584 000004CC 750C                    	    	jne .not_right
   585 000004CE BF01000000              			mov rdi, right_direction
   586 000004D3 E83EFDFFFF              	    	call move_pallet
   587 000004D8 EB0A                        		jmp .done		
   588                                  
   589                                  		.not_right:
   590                                  
   591 000004DA 3C71                        		cmp al, 'q'
   592 000004DC 0F84C5000000                		je exit
   593                                  
   594 000004E2 EBAD                    			jmp .read_more
   595                                  		
   596                                  		.done:	
   597                                  			;unsetnonblocking		
   598                                  			sleeptime	
    98 000004E4 B823000000          <1>  mov eax, sys_nanosleep
    99 000004E9 48BF-               <1>  mov rdi, timespec
    99 000004EB [0000000000000000]  <1>
   100 000004F3 31F6                <1>  xor esi, esi
   101 000004F5 0F05                <1>  syscall
   599                                  			print clear, clear_length
    82 000004F7 B801000000          <1>  mov eax, sys_write
    83 000004FC BF01000000          <1>  mov edi, 1
    84 00000501 48BE-               <1>  mov rsi, %1
    84 00000503 [1000000000000000]  <1>
    85 0000050B BA07000000          <1>  mov edx, %2
    86 00000510 0F05                <1>  syscall
   600 00000512 E94BFFFFFF                  		jmp .main_loop
   601                                  
   602                                  		print clear, clear_length
    82 00000517 B801000000          <1>  mov eax, sys_write
    83 0000051C BF01000000          <1>  mov edi, 1
    84 00000521 48BE-               <1>  mov rsi, %1
    84 00000523 [1000000000000000]  <1>
    85 0000052B BA07000000          <1>  mov edx, %2
    86 00000530 0F05                <1>  syscall
   603                                  		
   604 00000532 EB73                    		jmp exit
   605                                  
   606                                  
   607                                  start_screen:
   608                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000534 B801000000          <1>  mov eax, sys_write
    83 00000539 BF01000000          <1>  mov edi, 1
    84 0000053E 48BE-               <1>  mov rsi, %1
    84 00000540 [1000000000000000]  <1>
    85 00000548 BA07000000          <1>  mov edx, %2
    86 0000054D 0F05                <1>  syscall
   609                                      print msg1, msg1_length
    82 0000054F B801000000          <1>  mov eax, sys_write
    83 00000554 BF01000000          <1>  mov edi, 1
    84 00000559 48BE-               <1>  mov rsi, %1
    84 0000055B [1700000000000000]  <1>
    85 00000563 BA0A010000          <1>  mov edx, %2
    86 00000568 0F05                <1>  syscall
   610                                      
   611                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
   612                                          getchar                 ; Esperamos una tecla
    90 0000056A B800000000          <1>  mov rax, sys_read
    91 0000056F BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000574 48BE-               <1>  mov rsi, input_char
    92 00000576 [0000000000000000]  <1>
    93 0000057E BA01000000          <1>  mov rdx, 1
    94 00000583 0F05                <1>  syscall
   613 00000585 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
   614 00000589 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
   615                                          
   616                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000058B B801000000          <1>  mov eax, sys_write
    83 00000590 BF01000000          <1>  mov edi, 1
    84 00000595 48BE-               <1>  mov rsi, %1
    84 00000597 [1000000000000000]  <1>
    85 0000059F BA07000000          <1>  mov edx, %2
    86 000005A4 0F05                <1>  syscall
   617 000005A6 C3                          ret
   618                                  
   619                                  exit: 
   620 000005A7 E8B7FBFFFF              	call canonical_on
   621 000005AC B83C000000              	mov    rax, 60
   622 000005B1 BF00000000                  mov    rdi, 0
   623 000005B6 0F05                        syscall
   624                                  
