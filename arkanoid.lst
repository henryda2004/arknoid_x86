     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293                                      level1_blocks_count equ 4   ; Cantidad total de bloques
   294                                  
   295                                      ; Nivel 2: Bloques de prueba
   296                                      level2_blocks:
   297 000014CA 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   298                                      level2_blocks_count equ 1
   299                                  
   300                                      ; Nivel 3
   301                                      level3_blocks:
   302 000014CF 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   303                                  
   304                                      level3_blocks_count equ 1
   305                                  
   306                                      ; Nivel 4
   307                                      level4_blocks:
   308 000014D4 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   309                                      level4_blocks_count equ 1
   310                                  
   311                                      ; Nivel 5
   312                                      level5_blocks:
   313 000014D9 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   314                                      level5_blocks_count equ 1
   315                                  
   316                                      ; Array para mantener el estado de los bloques
   317 000014DE 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   318                                  
   319                                      
   320                                      ; Variables para almacenar los valores
   321 00001542 0000000000000000            current_score dq 0          ; Score actual
   322 0000154A 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   323                                      
   324                                      ; Buffer para convertir números a string
   325 0000154B 00<rep 14h>                 number_buffer: times 20 db 0
   326                                  
   327 0000155F 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   328                                      
   329                                      ; Estructura para los enemigos (x, y, activo)
   330 00001564 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   331 00001582 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   332                                      
   333 00001583 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   334 0000158B 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   335 0000158C 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   336 0000158D 00                          enemy_move_total db 0      ; Contador total de movimientos
   337 0000158E 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   338 0000158F 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   339                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   340                                      ; Añade esto en la sección .dataa
   341 00001590 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   341 00001599 12                 
   342 0000159A 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   342 000015A3 13                 
   343 000015A4 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   343 000015AD 1B                 
   344 000015AE 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   344 000015B7 1C                 
   345 000015B8 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   345 000015C1 2D                 
   346                                          ; Arreglo de punteros a los spawn points de cada nivel
   347                                      spawn_points_table:
   348 000015C2 [9015000000000000]              dq level1_spawn_points
   349 000015CA [9A15000000000000]              dq level2_spawn_points
   350 000015D2 [A415000000000000]              dq level3_spawn_points
   351 000015DA [AE15000000000000]              dq level4_spawn_points
   352 000015E2 [B815000000000000]              dq level5_spawn_points
   353                                  
   354                                      ; Variables para el comportamiento de enemigos
   355 000015EA 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   356 000015EB 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   357 000015EC 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   358 000015ED 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   359                                  
   360 000015F7 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   360 00001600 5B2020202020202020-
   360 00001609 20205D0A0D         
   361                                      score_label_len: equ $ - score_label
   362 0000160E 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   362 00001617 657374727569646F73-
   362 00001620 3A205B2020205D0A0D 
   363                                      blocks_label_len: equ $ - blocks_label
   364                                      
   365                                      ; Posición donde insertar los números en los labels
   366                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   367                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   368                                      
   369                                      ; Definición de las vidas (x, y, estado)
   370                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   371                                      lives_data: 
   372 00001629 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   373 0000162C 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   374 0000162F 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   375 00001632 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   376 00001635 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   377 00001638 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   378 0000163B 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   379                                      lives_count equ 7    ; Total de vidas
   380 0000163E 5E                          life_char db "^"    
   381 0000163F 04                          current_lives db 4   ; Contador de vidas activas actual
   382                                  
   383                                  ; Estructura para almacenar las letras y sus posiciones
   384                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   385 00001640 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   386 000017D0 00                          letters_count db 0   
   387 000017D1 20                          last_letter db ' '    ; Variable para almacenar la última letra
   388 000017D2 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   388 000017DB 75616C3A205B205D0A-
   388 000017E4 0D                 
   389                                      last_letter_msg_len equ $ - last_letter_msg
   390 000017E5 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   391 000017E6 07                          max_lives db 7              ; Máximo número de vidas permitidas
   392 000017E7 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   393 000017EF 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   394 000017F7 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   395                                  
   396 000017FF 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   397 00001800 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   398 00001801 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   399 00001809 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   400                                  
   401 0000180A 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   402 0000180B 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   403 0000180C 00                          laser_count: db 0                ; Contador de láseres activos
   404 0000180D 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   405 000018D5 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   406                                  
   407                                  section .text
   408                                  
   409                                  
   410                                  print_lives:
   411 000001DD 55                          push rbp
   412 000001DE 4889E5                      mov rbp, rsp
   413                                      
   414 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   415                                      
   416                                      .print_loop:
   417 000001E4 4983FC07                        cmp r12, lives_count
   418 000001E8 7D45                            jge .end
   419                                          
   420                                          ; Calcular offset de la vida actual
   421 000001EA 4C89E0                          mov rax, r12
   422 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   423 000001F1 488DB0[29160000]                lea rsi, [lives_data + rax]
   424                                          
   425                                          ; Calcular posición en el tablero
   426 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   427 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   428                                          
   429                                          ; Calcular offset en el tablero
   430 00000201 B84E000000                      mov rax, column_cells
   431 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   432 0000020A 49F7E1                          mul r9
   433 0000020D 4C01C0                          add rax, r8
   434 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   435                                          
   436                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   437 00000217 807E0201                        cmp byte [rsi + 2], 1
   438 0000021B 7405                            je .draw_active
   439                                          
   440                                          ; Si está inactiva, dibujar espacio
   441 0000021D C60720                          mov byte [rdi], ' '
   442 00000220 EB08                            jmp .next_life
   443                                          
   444                                      .draw_active:
   445                                          ; Si está activa, dibujar el símbolo de vida
   446 00000222 8A05(3E160000)                  mov al, [life_char]
   447 00000228 8807                            mov [rdi], al
   448                                          
   449                                      .next_life:
   450 0000022A 49FFC4                          inc r12
   451 0000022D EBB5                            jmp .print_loop
   452                                          
   453                                      .end:
   454 0000022F 5D                              pop rbp
   455 00000230 C3                              ret
   456                                  
   457                                  ; Función para desactivar una vida
   458                                  ; Función modificada para perder una vida
   459                                  lose_life:
   460 00000231 55                          push rbp
   461 00000232 4889E5                      mov rbp, rsp
   462                                      
   463                                      ; Verificar si aún quedan vidas
   464 00000235 803D(3F160000)00            cmp byte [current_lives], 0
   465 0000023C 0F8493000000                je .game_lost
   466                                      
   467                                      ; Encontrar la última vida activa
   468 00000242 B907000000                  mov rcx, lives_count
   469 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   470                                      
   471                                      .find_active_life:
   472 0000024A 4889C8                          mov rax, rcx
   473 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   474 00000251 488DB0[29160000]                lea rsi, [lives_data + rax]
   475 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   476 0000025C 7407                            je .deactivate_life
   477 0000025E 48FFC9                          dec rcx
   478 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   479 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   480                                          
   481                                      .deactivate_life:
   482                                          ; Calcular posición correcta en el tablero para borrar la vida
   483 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   484 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   485                                          
   486                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   487 0000026E B84E000000                      mov rax, column_cells
   488 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   489 00000277 49F7E1                          mul r9
   490 0000027A 4C01C0                          add rax, r8
   491 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   492                                          
   493                                          ; Borrar visualmente la vida
   494 00000284 C60720                          mov byte [rdi], ' '             
   495                                          
   496                                          ; Desactivar la vida en los datos
   497 00000287 C6460200                        mov byte [rsi + 2], 0          
   498 0000028B FE0D(3F160000)                  dec byte [current_lives]
   499                                          
   500                                          ; Borrar visualmente la paleta anterior
   501 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   502 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   503                                          .erase_pallet_loop:
   504 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   505 000002A3 49FFC0                              inc r8
   506 000002A6 48FFC9                              dec rcx
   507 000002A9 75F4                                jnz .erase_pallet_loop
   508                                          
   509                                  
   510                                          ; Reiniciar posición de la bola y la paleta
   511 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   511 000002B3 000000             
   512 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   512 000002BE 000000             
   513 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   514 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   514 000002CF [36130000]         
   515                                          
   516 000002D3 EB07                            jmp .end
   517                                          
   518                                      .game_lost:
   519 000002D5 E81C000000                      call game_lost
   520 000002DA EB00                            jmp .end
   521                                          
   522                                      .end:
   523 000002DC 5D                              pop rbp
   524 000002DD C3                              ret
   525                                  ; Función modificada para verificar colisión con el borde inferior
   526                                  check_bottom_collision:
   527 000002DE 55                          push rbp
   528 000002DF 4889E5                      mov rbp, rsp
   529                                      
   530                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   531 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   532 000002E9 4883F81E                    cmp rax, row_cells - 2
   533 000002ED 7505                        jne .no_collision
   534                                      
   535                                      ; Si hay colisión, perder una vida
   536 000002EF E83DFFFFFF                  call lose_life
   537                                      
   538                                      .no_collision:
   539 000002F4 5D                              pop rbp
   540 000002F5 C3                              ret
   541                                  
   542                                  ; Nueva función para game over
   543                                  game_lost:
   544                                      ; Limpiar la pantalla
   545                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   546                                      
   547                                      ; Mostrar mensaje de derrota
   548                                      section .data
   549 000018DD C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   549 000018E6 6469646F210A0D     
   550                                          lost_msg_len: equ $ - lost_msg
   551                                      section .text
   552                                      
   553                                      ; Imprimir mensaje de derrota
   554                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [DD18000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   555                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [0B19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   556                                      
   557                                      ; Mostrar puntaje final
   558 00000347 488B05(42150000)            mov rax, [current_score]
   559 0000034E 48BF-                       mov rdi, number_buffer
   559 00000350 [4B15000000000000] 
   560 00000358 E8B90C0000                  call number_to_string
   561                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4B15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   562                                      
   563                                      ; Esperar un momento antes de salir
   564 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   564 00000381 0000               
   565 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   565 0000038C 0000               
   566                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   567                                      
   568 000003A1 E964140000                  jmp exit
   569                                  
   570                                  
   571                                  ; Función para registrar una nueva letra en el mapa
   572                                  ; Entrada:
   573                                  ;   al - letra a registrar
   574                                  ;   r8b - posición x
   575                                  ;   r9b - posición y
   576                                  register_letter:
   577 000003A6 55                          push rbp
   578 000003A7 4889E5                      mov rbp, rsp
   579 000003AA 53                          push rbx
   580 000003AB 51                          push rcx
   581                                      
   582 000003AC 3C20                        cmp al, ' '
   583 000003AE 7438                        je .end
   584                                  
   585                                      ; Encontrar un espacio libre en el mapa
   586 000003B0 4831C9                      xor rcx, rcx
   587 000003B3 480FB615(D0170000)          movzx rdx, byte [letters_count]
   588                                      
   589                                      .find_slot:
   590 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   591 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   592                                          
   593 000003C1 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   594 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   595 000003CD 7405                            je .found_slot
   596                                          
   597 000003CF 48FFC1                          inc rcx
   598 000003D2 EBE7                            jmp .find_slot
   599                                          
   600                                      .found_slot:
   601                                          ; Guardar la información de la letra
   602 000003D4 448803                          mov [rbx], r8b           ; x
   603 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   604 000003DB 884302                          mov [rbx + 2], al        ; letra
   605 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   606                                          
   607 000003E2 FE05(D0170000)                  inc byte [letters_count]
   608                                          
   609                                      .end:
   610 000003E8 59                              pop rcx
   611 000003E9 5B                              pop rbx
   612 000003EA 5D                              pop rbp
   613 000003EB C3                              ret
   614                                  
   615                                  ; Función para imprimir todas las letras registradas
   616                                  print_letters:
   617 000003EC 55                          push rbp
   618 000003ED 4889E5                      mov rbp, rsp
   619 000003F0 53                          push rbx
   620 000003F1 51                          push rcx
   621                                      
   622 000003F2 4831C9                      xor rcx, rcx
   623                                      
   624                                      .print_loop:
   625 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   626 000003F9 7D37                            jge .end
   627                                          
   628                                          ; Obtener puntero a la letra actual
   629 000003FB 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   630                                          
   631                                          ; Verificar si está activa
   632 00000403 807B0300                        cmp byte [rbx + 3], 0
   633 00000407 7424                            je .next_letter
   634                                          
   635                                          ; Calcular posición en el tablero
   636 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   637 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   638                                          
   639                                          ; Calcular offset en el tablero
   640 00000412 B84E000000                      mov rax, column_cells
   641 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   642 0000041B 49F7E1                          mul r9
   643 0000041E 4C01C0                          add rax, r8
   644 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   645                                          
   646                                          ; Imprimir la letra
   647 00000428 8A4302                          mov al, [rbx + 2]
   648 0000042B 8807                            mov [rdi], al
   649                                          
   650                                      .next_letter:
   651 0000042D 48FFC1                          inc rcx
   652 00000430 EBC3                            jmp .print_loop
   653                                          
   654                                      .end:
   655 00000432 59                              pop rcx
   656 00000433 5B                              pop rbx
   657 00000434 5D                              pop rbp
   658 00000435 C3                              ret
   659                                  
   660                                  ; Función para borrar una letra específica
   661                                  ; Entrada:
   662                                  ;   r8b - posición x
   663                                  ;   r9b - posición y
   664                                  remove_letter:
   665 00000436 55                          push rbp
   666 00000437 4889E5                      mov rbp, rsp
   667 0000043A 53                          push rbx
   668 0000043B 51                          push rcx
   669                                      
   670 0000043C 4831C9                      xor rcx, rcx
   671                                      
   672                                      .find_loop:
   673 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   674 00000443 7D2E                            jge .end
   675                                          
   676 00000445 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   677                                          
   678                                          ; Verificar si está activa y coincide la posición
   679 0000044D 807B0300                        cmp byte [rbx + 3], 0
   680 00000451 741B                            je .next_letter
   681                                          
   682 00000453 8A03                            mov al, [rbx]
   683 00000455 4438C0                          cmp al, r8b
   684 00000458 7514                            jne .next_letter
   685                                          
   686 0000045A 8A4301                          mov al, [rbx + 1]
   687 0000045D 4438C8                          cmp al, r9b
   688 00000460 750C                            jne .next_letter
   689                                          
   690                                          ; Encontrada la letra, desactivarla
   691 00000462 C6430300                        mov byte [rbx + 3], 0
   692 00000466 FE0D(D0170000)                  dec byte [letters_count]
   693 0000046C EB05                            jmp .end
   694                                          
   695                                      .next_letter:
   696 0000046E 48FFC1                          inc rcx
   697 00000471 EBCC                            jmp .find_loop
   698                                          
   699                                      .end:
   700 00000473 59                              pop rcx
   701 00000474 5B                              pop rbx
   702 00000475 5D                              pop rbp
   703 00000476 C3                              ret
   704                                  ; Función para mover las letras hacia abajo
   705                                  move_letters:
   706 00000477 55                          push rbp
   707 00000478 4889E5                      mov rbp, rsp
   708 0000047B 53                          push rbx
   709 0000047C 57                          push rdi
   710 0000047D 56                          push rsi
   711 0000047E 4150                        push r8
   712 00000480 4151                        push r9
   713 00000482 4152                        push r10
   714 00000484 4153                        push r11
   715                                  
   716 00000486 4831C9                      xor rcx, rcx
   717                                  
   718                                      .move_loop:
   719 00000489 4883F964                        cmp rcx, 100
   720 0000048D 0F8DAD010000                    jge .print_last_letter
   721                                          
   722 00000493 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   723 0000049B 807B0300                        cmp byte [rbx + 3], 0
   724 0000049F 0F8493010000                    je .next_letter
   725                                  
   726 000004A5 4C0FB603                        movzx r8, byte [rbx]
   727 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   728                                  
   729 000004AE B84E000000                      mov rax, column_cells
   730 000004B3 4883C002                        add rax, 2
   731 000004B7 49F7E1                          mul r9
   732 000004BA 4C01C0                          add rax, r8
   733 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   734 000004C4 C60720                          mov byte [rdi], ' '
   735                                  
   736 000004C7 FE4301                          inc byte [rbx + 1]
   737 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   738                                  
   739 000004CF 4983F91F                        cmp r9, row_cells - 1
   740 000004D3 7C09                            jl .check_pallet_collision
   741                                  
   742 000004D5 C6430300                        mov byte [rbx + 3], 0
   743 000004D9 E95A010000                      jmp .next_letter
   744                                  
   745                                          .check_pallet_collision:
   746 000004DE B84E000000                          mov rax, column_cells
   747 000004E3 4883C002                            add rax, 2
   748 000004E7 49F7E1                              mul r9
   749 000004EA 4C01C0                              add rax, r8
   750 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   751                                  
   752 000004F4 8A07                                mov al, [rdi]
   753 000004F6 3C20                                cmp al, ' '
   754 000004F8 0F843A010000                        je .next_letter
   755 000004FE 3C3D                                cmp al, char_equal
   756 00000500 740A                                je .capture_letter
   757                                  
   758 00000502 8A4302                              mov al, [rbx + 2]
   759 00000505 8807                                mov [rdi], al
   760 00000507 E92C010000                          jmp .next_letter
   761                                  
   762                                          .capture_letter:
   763                                              ; Obtener la nueva letra
   764 0000050C 8A4302                              mov al, [rbx + 2]
   765                                              
   766                                              ; Comparar con la última letra
   767 0000050F 3A05(D1170000)                      cmp al, [last_letter]
   768 00000515 7407                                je .same_letter
   769                                              
   770                                              ; Es una letra diferente, resetear el procesamiento
   771 00000517 C605(E5170000)00                    mov byte [current_power_processed], 0
   772                                              
   773                                              .same_letter:
   774                                              ; Guardar la nueva letra
   775 0000051E 8805(D1170000)                      mov [last_letter], al
   776                                              
   777                                              ; Verificar si es 'E' para extender la paleta
   778 00000524 3C45                                cmp al, 'E'
   779 00000526 7441                                je .extend_pallet
   780                                              
   781                                              ; Verificar si es 'P' para añadir vida
   782 00000528 3C50                                cmp al, 'P'
   783 0000052A 7462                                je .check_add_life
   784                                  
   785 0000052C 3C53                                cmp al, 'S'
   786 0000052E 0F8493000000                        je .slow_ball
   787                                  
   788 00000534 3C43                                cmp al, 'C'
   789 00000536 0F84AD000000                        je .activate_catch
   790                                              
   791 0000053C 3C4C                                cmp al, 'L'
   792 0000053E 0F84C7000000                        je .activate_laser
   793                                  
   794                                              ; Si no es ningún power-up, restaurar tamaño normal
   795 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   796 0000054B 488905(47140000)                    mov [pallet_size], rax
   797 00000552 48C705(E7170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   797 0000055A 000000             
   798 0000055D C605(FF170000)00                    mov byte [catch_power_active], 0
   799 00000564 E9CB000000                          jmp .finish_capture
   800                                  
   801                                              .extend_pallet:
   802 00000569 C605(FF170000)00                        mov byte [catch_power_active], 0
   803 00000570 48C705(E7170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 00000578 000000             
   804 0000057B 488B05(57140000)                        mov rax, [extended_pallet_size]
   805 00000582 488905(47140000)                        mov [pallet_size], rax
   806 00000589 E9A6000000                              jmp .finish_capture
   807                                  
   808                                              .check_add_life:
   809 0000058E C605(FF170000)00                        mov byte [catch_power_active], 0
   810 00000595 488B05(4F140000)                        mov rax, [default_pallet_size]
   811 0000059C 488905(47140000)                        mov [pallet_size], rax
   812 000005A3 48C705(E7170000)01-                     mov qword [ball_speed], 1 
   812 000005AB 000000             
   813                                                  ; Verificar si ya procesamos este power-up
   814 000005AE 803D(E5170000)00                        cmp byte [current_power_processed], 0
   815 000005B5 757D                                    jne .finish_capture
   816                                                  
   817                                                  ; Preservar registros importantes
   818 000005B7 51                                      push rcx
   819 000005B8 53                                      push rbx
   820                                                  
   821                                                  ; Marcar como procesado
   822 000005B9 C605(E5170000)01                        mov byte [current_power_processed], 1
   823                                                  
   824                                                  ; Añadir una vida
   825 000005C0 E860020000                              call add_life
   826                                                  
   827                                                  ; Restaurar registros
   828 000005C5 5B                                      pop rbx
   829 000005C6 59                                      pop rcx
   830                                                  
   831                                              .slow_ball:
   832 000005C7 C605(FF170000)00                        mov byte [catch_power_active], 0                
   833 000005CE 488B05(4F140000)                        mov rax, [default_pallet_size]
   834 000005D5 488905(47140000)                        mov [pallet_size], rax
   835 000005DC 48C705(E7170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   835 000005E4 000000             
   836 000005E7 EB4B                                    jmp .finish_capture
   837                                  
   838                                              .activate_catch:
   839 000005E9 488B05(4F140000)                        mov rax, [default_pallet_size]
   840 000005F0 488905(47140000)                        mov [pallet_size], rax
   841 000005F7 48C705(E7170000)01-                     mov qword [ball_speed], 1
   841 000005FF 000000             
   842 00000602 C605(FF170000)01                        mov byte [catch_power_active], 1
   843 00000609 EB29                                    jmp .finish_capture
   844                                  
   845                                              .activate_laser:
   846 0000060B C605(FF170000)00                        mov byte [catch_power_active], 0
   847 00000612 488B05(4F140000)                        mov rax, [default_pallet_size]
   848 00000619 488905(47140000)                        mov [pallet_size], rax
   849 00000620 48C705(E7170000)01-                     mov qword [ball_speed], 1
   849 00000628 000000             
   850 0000062B C605(0A180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   851 00000632 EB00                                    jmp .finish_capture
   852                                  
   853                                              .finish_capture:
   854 00000634 C6430300                                mov byte [rbx + 3], 0
   855                                  
   856                                          .next_letter:
   857 00000638 48FFC1                              inc rcx
   858 0000063B E949FEFFFF                          jmp .move_loop
   859                                  
   860                                      .print_last_letter:
   861                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000640 B801000000          <1>  mov eax, sys_write
    83 00000645 BF01000000          <1>  mov edi, 1
    84 0000064A 48BE-               <1>  mov rsi, %1
    84 0000064C [D217000000000000]  <1>
    85 00000654 BA10000000          <1>  mov edx, %2
    86 00000659 0F05                <1>  syscall
   862 0000065B 8A05(D1170000)                  mov al, [last_letter]
   863 00000661 8805(E1170000)                  mov [last_letter_msg + 15], al
   864                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [E217000000000000]  <1>
    85 0000067B BA03000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   865                                  
   866                                      .end:
   867 00000682 415B                            pop r11
   868 00000684 415A                            pop r10
   869 00000686 4159                            pop r9
   870 00000688 4158                            pop r8
   871 0000068A 5E                              pop rsi
   872 0000068B 5F                              pop rdi
   873 0000068C 5B                              pop rbx
   874 0000068D 5D                              pop rbp
   875 0000068E C3                              ret
   876                                  
   877                                  
   878                                  
   879                                  ; Nueva función para actualizar los láseres
   880                                  update_lasers:
   881 0000068F 55                          push rbp
   882 00000690 4889E5                      mov rbp, rsp
   883                                      
   884                                      ; Verificar si el poder láser está activo
   885 00000693 803D(0A180000)00            cmp byte [laser_power_active], 0
   886 0000069A 741A                        je .end
   887                                      
   888                                      ; Verificar si se presionó la tecla de espacio
   889 0000069C 803D(09180000)20            cmp byte [last_key], ' '
   890 000006A3 750C                        jne .skip_shooting
   891                                      
   892                                      ; Disparar nuevos láseres
   893 000006A5 E80E000000                  call shoot_lasers
   894 000006AA C605(09180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   895                                      
   896                                      .skip_shooting:
   897                                      ; Mover los láseres existentes
   898 000006B1 E89C000000                  call move_lasers
   899                                      
   900                                      .end:
   901 000006B6 5D                              pop rbp
   902 000006B7 C3                              ret
   903                                  
   904                                  shoot_lasers:
   905 000006B8 55                          push rbp
   906 000006B9 4889E5                      mov rbp, rsp
   907 000006BC 53                          push rbx
   908                                      
   909                                      ; Verificar si hay espacio para más láseres
   910 000006BD 480FB605(0C180000)          movzx rax, byte [laser_count]
   911 000006C5 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   912 000006C9 0F8D80000000                jge .end
   913                                      
   914                                      ; Obtener posición de la paleta
   915 000006CF 4C8B05(3F140000)            mov r8, [pallet_position]
   916 000006D6 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   917                                      
   918                                      ; Calcular coordenadas x,y
   919 000006DD 4C89C0                      mov rax, r8
   920 000006E0 41B94E000000                mov r9, column_cells
   921 000006E6 4983C102                    add r9, 2                     ; Ancho total de línea
   922 000006EA 4831D2                      xor rdx, rdx
   923 000006ED 49F7F1                      div r9                        ; rax = y, rdx = x
   924                                      
   925                                      ; Guardar coordenadas
   926 000006F0 4989C2                      mov r10, rax                  ; Y en r10
   927 000006F3 4989D3                      mov r11, rdx                  ; X en r11
   928                                      
   929                                      ; Validar coordenadas
   930 000006F6 4983FA00                    cmp r10, 0
   931 000006FA 7C53                        jl .end
   932 000006FC 4983FA20                    cmp r10, row_cells
   933 00000700 7D4D                        jge .end
   934 00000702 4983FB00                    cmp r11, 0
   935 00000706 7C47                        jl .end
   936 00000708 4983FB4E                    cmp r11, column_cells
   937 0000070C 7D41                        jge .end
   938                                      
   939                                      ; Calcular índice para el primer láser
   940 0000070E 480FB61D(0C180000)          movzx rbx, byte [laser_count]
   941 00000716 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   942                                      
   943                                      ; Primer láser (izquierda)
   944 0000071A 488DBB[0D180000]            lea rdi, [lasers + rbx]
   945 00000721 44881F                      mov [rdi], r11b              ; X
   946 00000724 4488D0                      mov al, r10b
   947 00000727 FEC8                        dec al                       ; Y - 1
   948 00000729 884701                      mov [rdi + 1], al           ; Y
   949                                      
   950                                      ; Segundo láser (derecha)
   951 0000072C 4488D8                      mov al, r11b
   952 0000072F 0205(47140000)              add al, byte [pallet_size]
   953 00000735 FEC8                        dec al                       ; Ajustar para el último carácter
   954 00000737 488DBB[0F180000]            lea rdi, [lasers + rbx + 2]
   955 0000073E 8807                        mov [rdi], al               ; X
   956 00000740 4488D0                      mov al, r10b
   957 00000743 FEC8                        dec al                      ; Y - 1
   958 00000745 884701                      mov [rdi + 1], al          ; Y
   959                                      
   960                                      ; Incrementar contador de láseres
   961 00000748 8005(0C180000)02            add byte [laser_count], 2
   962                                      
   963                                      
   964                                      .end:
   965 0000074F 5B                              pop rbx
   966 00000750 5D                              pop rbp
   967 00000751 C3                              ret
   968                                  
   969                                  move_lasers:
   970 00000752 55                          push rbp
   971 00000753 4889E5                      mov rbp, rsp
   972                                      
   973 00000756 4831C9                      xor rcx, rcx                  ; Índice del láser
   974                                      
   975                                      .move_loop:
   976 00000759 480FB605(0C180000)              movzx rax, byte [laser_count]
   977 00000761 4839C1                          cmp rcx, rax
   978 00000764 0F8DB9000000                    jge .end
   979                                          
   980                                          ; Obtener coordenadas del láser actual
   981 0000076A 488DB409[0D180000]              lea rsi, [lasers + rcx * 2]
   982 00000772 4C0FB606                        movzx r8, byte [rsi]      ; x
   983 00000776 4C0FB64E01                      movzx r9, byte [rsi + 1]  ; y
   984                                          
   985                                          ; Validar coordenadas
   986 0000077B 4983F800                        cmp r8, 0
   987 0000077F 7C68                            jl .delete_laser
   988 00000781 4983F84E                        cmp r8, column_cells
   989 00000785 7D62                            jge .delete_laser
   990 00000787 4983F900                        cmp r9, 0
   991 0000078B 7C5C                            jl .delete_laser
   992 0000078D 4983F920                        cmp r9, row_cells
   993 00000791 7D56                            jge .delete_laser
   994                                          
   995                                          ; Borrar láser en posición actual
   996 00000793 B84E000000                      mov rax, column_cells
   997 00000798 4883C002                        add rax, 2
   998 0000079C 49F7E1                          mul r9
   999 0000079F 4C01C0                          add rax, r8
  1000 000007A2 483D000A0000                    cmp rax, board_size       ; Verificar límites del tablero
  1001 000007A8 7D3F                            jge .delete_laser
  1002 000007AA 488DB8[000A0000]                lea rdi, [board + rax]
  1003 000007B1 C60720                          mov byte [rdi], ' '
  1004                                          
  1005                                          ; Mover hacia arriba
  1006 000007B4 49FFC9                          dec r9
  1007                                          
  1008                                          ; Si alcanza el borde superior, eliminar
  1009 000007B7 4983F900                        cmp r9, 0
  1010 000007BB 7C2C                            jl .delete_laser
  1011                                          
  1012                                          ; Actualizar posición
  1013 000007BD 44884E01                        mov [rsi + 1], r9b
  1014                                          
  1015                                          ; Dibujar en nueva posición
  1016 000007C1 B84E000000                      mov rax, column_cells
  1017 000007C6 4883C002                        add rax, 2
  1018 000007CA 49F7E1                          mul r9
  1019 000007CD 4C01C0                          add rax, r8
  1020 000007D0 483D000A0000                    cmp rax, board_size       ; Verificar límites del tablero
  1021 000007D6 7D11                            jge .delete_laser
  1022 000007D8 488DB8[000A0000]                lea rdi, [board + rax]
  1023 000007DF 8A05(0B180000)                  mov al, [laser_symbol]
  1024 000007E5 8807                            mov [rdi], al
  1025 000007E7 EB32                            jmp .next_laser
  1026                                          
  1027                                      .delete_laser:
  1028                                          ; Eliminar láser actual
  1029 000007E9 488DBC09[0D180000]              lea rdi, [lasers + rcx * 2]
  1030 000007F1 488DB409[0F180000]              lea rsi, [lasers + (rcx + 1) * 2]
  1031 000007F9 480FB615(0C180000)              movzx rdx, byte [laser_count]
  1032 00000801 4829CA                          sub rdx, rcx
  1033 00000804 48FFCA                          dec rdx
  1034 00000807 48D1E2                          shl rdx, 1
  1035 0000080A 4883FA00                        cmp rdx, 0
  1036 0000080E 7E02                            jle .skip_move
  1037 00000810 F3A4                            rep movsb
  1038                                      .skip_move:
  1039 00000812 FE0D(0C180000)                  dec byte [laser_count]
  1040 00000818 48FFC9                          dec rcx
  1041                                          
  1042                                      .next_laser:
  1043 0000081B 48FFC1                          inc rcx
  1044 0000081E E936FFFFFF                      jmp .move_loop
  1045                                          
  1046                                      .end:
  1047 00000823 5D                              pop rbp
  1048 00000824 C3                              ret
  1049                                  
  1050                                  
  1051                                  add_life:
  1052 00000825 55                          push rbp
  1053 00000826 4889E5                      mov rbp, rsp
  1054 00000829 53                          push rbx
  1055 0000082A 51                          push rcx
  1056 0000082B 57                          push rdi
  1057 0000082C 56                          push rsi
  1058 0000082D 4150                        push r8
  1059 0000082F 4151                        push r9
  1060                                      
  1061                                      ; Verificar si ya tenemos el máximo de vidas
  1062 00000831 480FB605(3F160000)          movzx rax, byte [current_lives]
  1063 00000839 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1064 0000083D 7D2C                        jge .end
  1065                                      
  1066                                      ; Incrementar el contador de vidas
  1067 0000083F FE05(3F160000)              inc byte [current_lives]
  1068                                      
  1069                                      ; Encontrar la siguiente vida inactiva
  1070 00000845 4831C9                      xor rcx, rcx
  1071                                      
  1072                                      .find_inactive:
  1073 00000848 4883F907                        cmp rcx, lives_count
  1074 0000084C 7D1D                            jge .end
  1075                                          
  1076                                          ; Calcular offset de la vida actual
  1077 0000084E 4889C8                          mov rax, rcx
  1078 00000851 486BC003                        imul rax, 3
  1079 00000855 488DB0[29160000]                lea rsi, [lives_data + rax]
  1080                                          
  1081                                          ; Verificar si está inactiva
  1082 0000085C 807E0200                        cmp byte [rsi + 2], 0
  1083 00000860 7405                            je .activate_life
  1084                                          
  1085 00000862 48FFC1                          inc rcx
  1086 00000865 EBE1                            jmp .find_inactive
  1087                                          
  1088                                      .activate_life:
  1089                                          ; Activar la vida
  1090 00000867 C6460201                        mov byte [rsi + 2], 1
  1091                                          
  1092                                      .end:
  1093 0000086B 4159                            pop r9
  1094 0000086D 4158                            pop r8
  1095 0000086F 5E                              pop rsi
  1096 00000870 5F                              pop rdi
  1097 00000871 59                              pop rcx
  1098 00000872 5B                              pop rbx
  1099 00000873 5D                              pop rbp
  1100 00000874 C3                              ret
  1101                                  
  1102                                  
  1103                                  print_ball:
  1104 00000875 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1105 0000087C 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1106 00000883 4981C0[000A0000]        	add r8, board
  1107                                  
  1108 0000088A 4C89C9                  	mov rcx, r9
  1109 0000088D B850000000              	mov rax, column_cells + 2
  1110 00000892 48F7E9                  	imul rcx
  1111                                  	
  1112 00000895 4901C0                  	add r8, rax
  1113 00000898 41C6004F                	mov byte [r8], char_O
  1114 0000089C C3                      	ret
  1115                                  
  1116                                  	
  1117                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1118                                  	
  1119                                  print_pallet:
  1120                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1121 0000089D 4C8B05(3F140000)            mov r8, [pallet_position]
  1122 000008A4 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1123                                      .clear_pallet:
  1124 000008AB 41C60020                        mov byte [r8], char_space
  1125 000008AF 49FFC0                          inc r8
  1126 000008B2 48FFC9                          dec rcx
  1127 000008B5 75F4                            jnz .clear_pallet
  1128                                  
  1129                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1130 000008B7 4C8B05(3F140000)            mov r8, [pallet_position]
  1131 000008BE 488B0D(47140000)            mov rcx, [pallet_size]
  1132                                      .write_pallet:
  1133 000008C5 41C6003D                        mov byte [r8], char_equal
  1134 000008C9 49FFC0                          inc r8
  1135 000008CC 48FFC9                          dec rcx
  1136 000008CF 75F4                            jnz .write_pallet
  1137                                  
  1138 000008D1 C3                          ret
  1139                                  
  1140                                  move_pallet:
  1141                                      
  1142 000008D2 803D(7F140000)00            cmp byte [ball_moving], 0
  1143 000008D9 7507                        jne .continue_movement
  1144 000008DB C605(7F140000)01            mov byte [ball_moving], 1
  1145                                  
  1146                                      .continue_movement:
  1147 000008E2 4883FFFF                        cmp rdi, left_direction
  1148 000008E6 7531                            jne .move_right
  1149                                  
  1150                                          .move_left:
  1151                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1152 000008E8 4C8B05(3F140000)                    mov r8, [pallet_position]
  1153 000008EF 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1154 000008F2 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1155 000008F5 3C58                                cmp al, 'X'        ; Comparar si es una X
  1156 000008F7 744E                                je .end            ; Si es X, no mover
  1157                                              
  1158 000008F9 4C8B05(3F140000)                    mov r8, [pallet_position]
  1159 00000900 4C8B0D(47140000)                    mov r9, [pallet_size]
  1160 00000907 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1161 0000090D 49FFC8                              dec r8
  1162 00000910 4C8905(3F140000)                    mov [pallet_position], r8
  1163 00000917 EB2E                                jmp .end
  1164                                              
  1165                                          .move_right:
  1166                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1167 00000919 4C8B05(3F140000)                    mov r8, [pallet_position]
  1168 00000920 4C8B0D(47140000)                    mov r9, [pallet_size]
  1169 00000927 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1170 0000092A 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1171 0000092E 3C58                                cmp al, 'X'        ; Comparar si es una X
  1172 00000930 7415                                je .end            ; Si es X, no mover
  1173                                              
  1174 00000932 4C8B05(3F140000)                    mov r8, [pallet_position]
  1175 00000939 41C60020                            mov byte [r8], char_space
  1176 0000093D 49FFC0                              inc r8
  1177 00000940 4C8905(3F140000)                    mov [pallet_position], r8
  1178                                          .end:
  1179 00000947 C3                                  ret
  1180                                  
  1181                                  
  1182                                  
  1183                                              
  1184                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1185                                  update_caught_ball_position:
  1186 00000948 55                          push rbp
  1187 00000949 4889E5                      mov rbp, rsp
  1188                                      
  1189                                      ; Calcular la nueva posición de la bola basada en la paleta
  1190 0000094C 4C8B05(3F140000)            mov r8, [pallet_position]
  1191 00000953 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1192 0000095A B850000000                  mov rax, column_cells + 2
  1193 0000095F 4831D2                      xor rdx, rdx
  1194 00000962 48F7F0                      div rax                ; División para obtener X,Y
  1195                                      
  1196                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1197 00000965 4989C1                      mov r9, rax            ; Y de la paleta
  1198 00000968 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1199                                      
  1200                                      ; Añadir el offset guardado a la posición X
  1201 0000096B 4889D0                      mov rax, rdx
  1202 0000096E 480305(01180000)            add rax, [ball_catch_offset]
  1203 00000975 488905(5F140000)            mov [ball_x_pos], rax
  1204 0000097C 4C890D(67140000)            mov [ball_y_pos], r9
  1205                                      
  1206 00000983 5D                          pop rbp
  1207 00000984 C3                          ret
  1208                                  move_ball:
  1209                                  
  1210 00000985 803D(00180000)01            cmp byte [ball_caught], 1
  1211 0000098C 0F849D000000                je .move_with_pallet
  1212                                  
  1213 00000992 803D(7F140000)00            cmp byte [ball_moving], 0
  1214 00000999 0F84B8010000                je .end
  1215                                  
  1216                                      ; Incrementar contador de velocidad
  1217 0000099F 48FF05(F7170000)            inc qword [speed_counter]
  1218                                      
  1219                                      ; Verificar si debemos mover la bola en este ciclo
  1220 000009A6 488B05(F7170000)            mov rax, [speed_counter]
  1221 000009AD 483B05(E7170000)            cmp rax, [ball_speed]
  1222 000009B4 0F8C9D010000                jl .end
  1223                                      
  1224                                      ; Resetear contador de velocidad
  1225 000009BA 48C705(F7170000)00-         mov qword [speed_counter], 0
  1225 000009C2 000000             
  1226                                  
  1227                                      ; Borrar la posición actual de la bola
  1228 000009C5 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1229 000009CC 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1230 000009D3 4981C0[000A0000]            add r8, board
  1231 000009DA 4C89C9                      mov rcx, r9
  1232 000009DD B850000000                  mov rax, column_cells + 2
  1233 000009E2 48F7E9                      imul rcx
  1234 000009E5 4901C0                      add r8, rax
  1235 000009E8 41C60020                    mov byte [r8], char_space
  1236                                  
  1237                                      ; Calcular siguiente posición X
  1238 000009EC 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1239 000009F3 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1240 000009FA 488B05(6F140000)            mov rax, [ball_direction_x]
  1241 00000A01 4901C0                      add r8, rax               ; Nueva posición X
  1242                                  
  1243                                      ; Calcular la dirección de memoria para la siguiente posición
  1244 00000A04 4D89C2                      mov r10, r8
  1245 00000A07 4981C2[000A0000]            add r10, board
  1246 00000A0E 4C89C9                      mov rcx, r9
  1247 00000A11 B850000000                  mov rax, column_cells + 2
  1248 00000A16 48F7E9                      imul rcx
  1249 00000A19 4901C2                      add r10, rax
  1250                                  
  1251                                      ; Verificar si hay una X en la siguiente posición X
  1252 00000A1C 418A02                      mov al, [r10]
  1253 00000A1F 3C58                        cmp al, 'X'
  1254 00000A21 7565                        jne .check_block_x
  1255 00000A23 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1256 00000A2A E928010000                  jmp .end
  1257                                  
  1258                                      .move_with_pallet:
  1259                                          ; Borrar la posición actual de la bola
  1260 00000A2F 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1261 00000A36 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1262 00000A3D 4D89C2                          mov r10, r8
  1263 00000A40 4981C2[000A0000]                add r10, board
  1264 00000A47 4C89C9                          mov rcx, r9
  1265 00000A4A B850000000                      mov rax, column_cells + 2
  1266 00000A4F 48F7E9                          imul rcx
  1267 00000A52 4901C2                          add r10, rax
  1268 00000A55 41C60220                        mov byte [r10], char_space
  1269                                  
  1270                                          ; Actualizar posición X basada en la paleta
  1271 00000A59 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1272 00000A60 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1273 00000A67 4C0305(01180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1274 00000A6E 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1275                                  
  1276                                          ; Mantener la bola una posición arriba de la paleta
  1277 00000A75 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1278 00000A7C 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1279                                  
  1280 00000A83 E9CF000000                      jmp .end
  1281                                  
  1282                                  
  1283                                      .check_block_x:
  1284                                          ; Verificar colisión con bloques en X
  1285 00000A88 4150                            push r8     ; Guardar registros que usa check_block_collision
  1286 00000A8A 4151                            push r9
  1287 00000A8C 4152                            push r10
  1288 00000A8E E8DB060000                      call check_block_collision
  1289 00000A93 415A                            pop r10
  1290 00000A95 4159                            pop r9
  1291 00000A97 4158                            pop r8
  1292 00000A99 4885C0                          test rax, rax
  1293 00000A9C 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1294 00000A9E 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1295 00000AA5 E9AD000000                      jmp .end
  1296                                  
  1297                                      .check_paddle_x:
  1298                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1299 00000AAA 41803A3D                        cmp byte [r10], char_equal
  1300 00000AAE 750C                            jne .check_y_movement
  1301 00000AB0 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1302 00000AB7 E99B000000                      jmp .end
  1303                                  
  1304                                      .check_y_movement:
  1305                                          ; Calcular siguiente posición Y
  1306 00000ABC 488B05(77140000)                mov rax, [ball_direction_y]
  1307 00000AC3 4901C1                          add r9, rax                  ; Nueva posición Y
  1308                                  
  1309                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1310 00000AC6 4D89C2                          mov r10, r8
  1311 00000AC9 4981C2[000A0000]                add r10, board
  1312 00000AD0 4C89C9                          mov rcx, r9
  1313 00000AD3 B850000000                      mov rax, column_cells + 2
  1314 00000AD8 48F7E9                          imul rcx
  1315 00000ADB 4901C2                          add r10, rax
  1316                                  
  1317                                          ; Verificar si hay una X en la siguiente posición Y
  1318 00000ADE 418A02                          mov al, [r10]
  1319 00000AE1 3C58                            cmp al, 'X'
  1320 00000AE3 7509                            jne .check_block_y
  1321 00000AE5 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1322 00000AEC EB69                            jmp .end
  1323                                  
  1324                                      .check_block_y:
  1325                                          ; Verificar colisión con bloques en Y
  1326 00000AEE 4150                            push r8     ; Guardar registros que usa check_block_collision
  1327 00000AF0 4151                            push r9
  1328 00000AF2 4152                            push r10
  1329 00000AF4 E875060000                      call check_block_collision
  1330 00000AF9 415A                            pop r10
  1331 00000AFB 4159                            pop r9
  1332 00000AFD 4158                            pop r8
  1333 00000AFF 4885C0                          test rax, rax
  1334 00000B02 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1335 00000B04 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1336 00000B0B EB4A                            jmp .end
  1337                                  
  1338                                      .check_paddle_y:
  1339                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1340 00000B0D 41803A3D                        cmp byte [r10], char_equal
  1341 00000B11 7536                            jne .update_position
  1342                                  
  1343                                          ; Verificar si el poder catch está activo
  1344 00000B13 803D(FF170000)01                cmp byte [catch_power_active], 1
  1345 00000B1A 7524                            jne .normal_bounce
  1346                                  
  1347                                          ; Activar el modo "atrapado"
  1348 00000B1C C605(00180000)01                mov byte [ball_caught], 1
  1349                                          
  1350                                          ; Guardar la posición X actual de la bola como offset
  1351 00000B23 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1352 00000B2A 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1353 00000B31 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1354 00000B37 488905(01180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1355                                          
  1356 00000B3E EB17                            jmp .end
  1357                                  
  1358                                      .normal_bounce:
  1359 00000B40 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1360 00000B47 EB0E                            jmp .end
  1361                                  
  1362                                  
  1363                                      .update_position:
  1364 00000B49 4C8905(5F140000)                mov [ball_x_pos], r8
  1365 00000B50 4C890D(67140000)                mov [ball_y_pos], r9
  1366                                  
  1367                                      .end:
  1368 00000B57 C3                              ret
  1369                                  
  1370                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1371                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1372                                  process_catch_release:
  1373 00000B58 55                          push rbp
  1374 00000B59 4889E5                      mov rbp, rsp
  1375                                  
  1376                                      ; Verificar si la bola está atrapada
  1377 00000B5C 803D(00180000)00            cmp byte [ball_caught], 0
  1378 00000B63 7436                        je .end
  1379                                  
  1380                                      ; Verificar si el poder catch está activo
  1381 00000B65 803D(FF170000)01            cmp byte [catch_power_active], 1
  1382 00000B6C 752D                        jne .end
  1383                                  
  1384                                      ; Verificar si se presionó la tecla 'c'
  1385 00000B6E 803D(09180000)63            cmp byte [last_key], 'c'
  1386 00000B75 7524                        jne .end
  1387                                  
  1388                                      ; Liberar la bola y asignar dirección inicial
  1389 00000B77 C605(00180000)00            mov byte [ball_caught], 0
  1390 00000B7E 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1390 00000B86 000000             
  1391 00000B89 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1391 00000B91 FFFFFF             
  1392                                  
  1393                                      ; Limpiar la tecla procesada
  1394 00000B94 C605(09180000)00            mov byte [last_key], 0
  1395                                  
  1396                                      .end:
  1397 00000B9B 5D                              pop rbp
  1398 00000B9C C3                              ret
  1399                                  
  1400                                  
  1401                                  display_level_number:
  1402 00000B9D 55                          push rbp
  1403 00000B9E 4889E5                      mov rbp, rsp
  1404                                      
  1405                                      ; Limpiar la pantalla primero
  1406                                      print clear, clear_length
    82 00000BA1 B801000000          <1>  mov eax, sys_write
    83 00000BA6 BF01000000          <1>  mov edi, 1
    84 00000BAB 48BE-               <1>  mov rsi, %1
    84 00000BAD [1000000000000000]  <1>
    85 00000BB5 BA07000000          <1>  mov edx, %2
    86 00000BBA 0F05                <1>  syscall
  1407                                      
  1408                                      ; Calcular la posición central para el mensaje
  1409                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1410 00000BBC B84E000000                  mov rax, column_cells
  1411 00000BC1 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1412 00000BC5 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1413                                      
  1414                                      ; Calcular la fila central
  1415 00000BC8 BB20000000                  mov rbx, row_cells
  1416 00000BCD 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1417                                      
  1418                                      ; Calcular el offset en el buffer
  1419 00000BD0 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1420 00000BD5 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1421 00000BD8 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1422                                      
  1423                                      ; Escribir "NIVEL " en la posición calculada
  1424 00000BDB 488DB8[000A0000]            lea rdi, [board + rax]
  1425 00000BE2 48BE-                       mov rsi, level_msg
  1425 00000BE4 [2414000000000000] 
  1426 00000BEC B906000000                  mov rcx, level_msg_len
  1427 00000BF1 F3A4                        rep movsb
  1428                                      
  1429                                      ; Escribir el número del nivel
  1430 00000BF3 8A05(B4140000)              mov al, [current_level]
  1431 00000BF9 0430                        add al, '0'                 ; convertir a ASCII
  1432 00000BFB 8807                        mov [rdi], al
  1433                                      
  1434                                      ; Mostrar el board con el mensaje
  1435                                      print board, board_size
    82 00000BFD B801000000          <1>  mov eax, sys_write
    83 00000C02 BF01000000          <1>  mov edi, 1
    84 00000C07 48BE-               <1>  mov rsi, %1
    84 00000C09 [000A000000000000]  <1>
    85 00000C11 BA000A0000          <1>  mov edx, %2
    86 00000C16 0F05                <1>  syscall
  1436                                      
  1437                                      ; Esperar un segundo
  1438 00000C18 B823000000                  mov rax, sys_nanosleep
  1439 00000C1D 48BF-                       mov rdi, level_display_time
  1439 00000C1F [2F14000000000000] 
  1440 00000C27 4831F6                      xor rsi, rsi
  1441 00000C2A 0F05                        syscall
  1442                                      
  1443 00000C2C 5D                          pop rbp
  1444 00000C2D C3                          ret
  1445                                  
  1446                                  ; Función para inicializar un tablero vacío
  1447                                  init_empty_board:
  1448 00000C2E 56                          push rsi
  1449 00000C2F 57                          push rdi
  1450 00000C30 51                          push rcx
  1451 00000C31 50                          push rax
  1452                                  
  1453 00000C32 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1454 00000C39 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1455 00000C40 B9000A0000                  mov rcx, board_template_size
  1456 00000C45 F3A4                        rep movsb                   ; Copiar el tablero
  1457                                  
  1458 00000C47 58                          pop rax
  1459 00000C48 59                          pop rcx
  1460 00000C49 5F                          pop rdi
  1461 00000C4A 5E                          pop rsi
  1462 00000C4B C3                          ret
  1463                                  
  1464                                  
  1465                                  init_level:
  1466                                  
  1467 00000C4C 488B05(4F140000)            mov rax, [default_pallet_size]
  1468 00000C53 488905(47140000)            mov [pallet_size], rax
  1469 00000C5A 48C705(E7170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1469 00000C62 000000             
  1470                                  
  1471                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1472                                          ; Reiniciar letras activas
  1473 00000C65 488D3D(40160000)            lea rdi, [letters_map]
  1474 00000C6C B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1475 00000C71 4831C0                      xor rax, rax
  1476 00000C74 F3AA                        rep stosb                    ; Llenar con ceros
  1477                                      
  1478                                      ; Inicializar dirección de la bola (derecha y arriba)
  1479 00000C76 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1479 00000C7E 000000             
  1480 00000C81 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1480 00000C89 FFFFFF             
  1481                                  
  1482                                  
  1483                                      ; Reiniciar contador de letras activas
  1484 00000C8C 4831C0                      xor rax, rax
  1485 00000C8F 8805(D0170000)              mov [letters_count], al
  1486                                  
  1487                                      ; Reiniciar última letra capturada
  1488 00000C95 C605(D1170000)20            mov byte [last_letter], ' '
  1489 00000C9C C605(4A150000)00            mov byte [destroyed_blocks], 0 
  1490 00000CA3 E886FFFFFF                  call init_empty_board
  1491 00000CA8 E8F0FEFFFF                  call display_level_number
  1492 00000CAD E8E5050000                  call init_enemies
  1493                                      
  1494 00000CB2 56                          push rsi
  1495 00000CB3 57                          push rdi
  1496 00000CB4 51                          push rcx
  1497 00000CB5 50                          push rax
  1498                                  
  1499 00000CB6 488D35(00000000)            lea rsi, [board_template]
  1500 00000CBD 488D3D(000A0000)            lea rdi, [board]
  1501 00000CC4 B9000A0000                  mov rcx, board_template_size
  1502 00000CC9 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1503                                  
  1504 00000CCB 58                          pop rax
  1505 00000CCC 59                          pop rcx
  1506 00000CCD 5F                          pop rdi
  1507 00000CCE 5E                          pop rsi
  1508                                  
  1509 00000CCF B90A000000                  mov rcx, 10
  1510 00000CD4 4831C0                      xor rax, rax
  1511 00000CD7 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  1512 00000CDE F3AA                        rep stosb      
  1513                                  
  1514                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1515 00000CE0 803D(B4140000)01            cmp byte [current_level], 1
  1516 00000CE7 7431                        je .level1
  1517 00000CE9 803D(B4140000)02            cmp byte [current_level], 2
  1518 00000CF0 7454                        je .level2
  1519 00000CF2 803D(B4140000)03            cmp byte [current_level], 3
  1520 00000CF9 7477                        je .level3
  1521 00000CFB 803D(B4140000)04            cmp byte [current_level], 4
  1522 00000D02 0F8492000000                je .level4
  1523 00000D08 803D(B4140000)05            cmp byte [current_level], 5
  1524 00000D0F 0F84AD000000                je .level5
  1525 00000D15 E9D0000000                  jmp .done
  1526                                  
  1527                                  
  1528                                  
  1529                                      .level1:
  1530 00000D1A C605(B5140000)04                mov byte [blocks_remaining], level1_blocks_count
  1531 00000D21 4831C9                          xor rcx, rcx             
  1532                                          .init_loop1:
  1533 00000D24 4883F904                            cmp rcx, level1_blocks_count
  1534 00000D28 0F8DBC000000                        jge .done
  1535 00000D2E 4889C8                              mov rax, rcx         
  1536 00000D31 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1537 00000D35 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1538 00000D3B 8891[DE140000]                      mov byte [block_states + rcx], dl
  1539 00000D41 48FFC1                              inc rcx
  1540 00000D44 EBDE                                jmp .init_loop1
  1541                                  
  1542                                      .level2:
  1543 00000D46 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1544 00000D4D 4831C9                          xor rcx, rcx             
  1545                                          .init_loop2:
  1546 00000D50 4883F901                            cmp rcx, level2_blocks_count
  1547 00000D54 0F8D90000000                        jge .done
  1548 00000D5A 4889C8                              mov rax, rcx         
  1549 00000D5D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1550 00000D61 8A90[CD140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1551 00000D67 8891[DE140000]                      mov byte [block_states + rcx], dl
  1552 00000D6D 48FFC1                              inc rcx
  1553 00000D70 EBDE                                jmp .init_loop2
  1554                                      .level3:
  1555 00000D72 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1556 00000D79 4831C9                          xor rcx, rcx             
  1557                                          .init_loop3:
  1558 00000D7C 4883F901                            cmp rcx, level3_blocks_count
  1559 00000D80 7D68                                jge .done
  1560 00000D82 4889C8                              mov rax, rcx         
  1561 00000D85 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1562 00000D89 8A90[D2140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1563 00000D8F 8891[DE140000]                      mov byte [block_states + rcx], dl
  1564 00000D95 48FFC1                              inc rcx
  1565 00000D98 EBE2                                jmp .init_loop3
  1566                                  
  1567                                      .level4:
  1568 00000D9A C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1569 00000DA1 4831C9                          xor rcx, rcx             
  1570                                          .init_loop4:
  1571 00000DA4 4883F901                            cmp rcx, level4_blocks_count
  1572 00000DA8 7D40                                jge .done
  1573 00000DAA 4889C8                              mov rax, rcx         
  1574 00000DAD 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1575 00000DB1 8A90[D7140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1576 00000DB7 8891[DE140000]                      mov byte [block_states + rcx], dl
  1577 00000DBD 48FFC1                              inc rcx
  1578 00000DC0 EBE2                                jmp .init_loop4
  1579                                  
  1580                                      .level5:
  1581 00000DC2 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1582 00000DC9 4831C9                          xor rcx, rcx             
  1583                                          .init_loop5:
  1584 00000DCC 4883F901                            cmp rcx, level5_blocks_count
  1585 00000DD0 7D18                                jge .done
  1586 00000DD2 4889C8                              mov rax, rcx         
  1587 00000DD5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1588 00000DD9 8A90[DC140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1589 00000DDF 8891[DE140000]                      mov byte [block_states + rcx], dl
  1590 00000DE5 48FFC1                              inc rcx
  1591 00000DE8 EBE2                                jmp .init_loop5
  1592                                      .done:
  1593 00000DEA C3                              ret
  1594                                  
  1595                                  
  1596                                  ; Función para verificar y manejar la transición de nivel
  1597                                  check_level_complete:
  1598                                      ; Verificar si quedan bloques
  1599 00000DEB 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1600 00000DF2 753C                        jne .not_complete
  1601                                      
  1602                                      ; Incrementar el nivel
  1603 00000DF4 FE05(B4140000)              inc byte [current_level]
  1604                                      
  1605                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1606 00000DFA 803D(B4140000)06            cmp byte [current_level], 6
  1607 00000E01 742E                        je game_win
  1608                                      
  1609                                      ; Reinicializar el juego para el siguiente nivel
  1610 00000E03 E844FEFFFF                  call init_level
  1611                                      
  1612                                      ; Reinicializar la posición de la bola y la paleta
  1613 00000E08 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1613 00000E10 000000             
  1614 00000E13 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1614 00000E1B 000000             
  1615 00000E1E C605(7F140000)00            mov byte [ball_moving], 0
  1616 00000E25 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1616 00000E2C [36130000]         
  1617                                      
  1618                                      .not_complete:
  1619 00000E30 C3                              ret
  1620                                  
  1621                                      ; Nueva función para manejar la victoria del juego
  1622                                  game_win:
  1623                                      ; Limpiar la pantalla primero
  1624                                      print clear, clear_length
    82 00000E31 B801000000          <1>  mov eax, sys_write
    83 00000E36 BF01000000          <1>  mov edi, 1
    84 00000E3B 48BE-               <1>  mov rsi, %1
    84 00000E3D [1000000000000000]  <1>
    85 00000E45 BA07000000          <1>  mov edx, %2
    86 00000E4A 0F05                <1>  syscall
  1625                                      
  1626                                      ; Mensaje de victoria
  1627 00000E4C 488B05(42150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1628 00000E53 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1628 00000E55 [4B15000000000000] 
  1629 00000E5D E8B4010000                  call number_to_string
  1630                                      
  1631                                      ; Definir mensaje de victoria
  1632                                      section .data
  1633 000018ED C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1633 000018F6 616465732120C2A148-
  1633 000018FF 61732067616E61646F-
  1633 00001908 210A0D             
  1634                                          win_msg_len: equ $ - win_msg
  1635 0000190B 50756E74616A652066-             score_msg: db "Puntaje final: "
  1635 00001914 696E616C3A20       
  1636                                          score_msg_len: equ $ - score_msg
  1637                                      section .text
  1638                                      
  1639                                      ; Imprimir mensajes
  1640                                      print win_msg, win_msg_len
    82 00000E62 B801000000          <1>  mov eax, sys_write
    83 00000E67 BF01000000          <1>  mov edi, 1
    84 00000E6C 48BE-               <1>  mov rsi, %1
    84 00000E6E [ED18000000000000]  <1>
    85 00000E76 BA1E000000          <1>  mov edx, %2
    86 00000E7B 0F05                <1>  syscall
  1641                                      print score_msg, score_msg_len
    82 00000E7D B801000000          <1>  mov eax, sys_write
    83 00000E82 BF01000000          <1>  mov edi, 1
    84 00000E87 48BE-               <1>  mov rsi, %1
    84 00000E89 [0B19000000000000]  <1>
    85 00000E91 BA0F000000          <1>  mov edx, %2
    86 00000E96 0F05                <1>  syscall
  1642                                      print number_buffer, 20
    82 00000E98 B801000000          <1>  mov eax, sys_write
    83 00000E9D BF01000000          <1>  mov edi, 1
    84 00000EA2 48BE-               <1>  mov rsi, %1
    84 00000EA4 [4B15000000000000]  <1>
    85 00000EAC BA14000000          <1>  mov edx, %2
    86 00000EB1 0F05                <1>  syscall
  1643                                      
  1644                                      ; Esperar un momento antes de salir
  1645 00000EB3 48C70542F1FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1645 00000EBC 0000               
  1646 00000EBE 48C7053FF1FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1646 00000EC7 0000               
  1647                                      sleeptime
    98 00000EC9 B823000000          <1>  mov eax, sys_nanosleep
    99 00000ECE 48BF-               <1>  mov rdi, timespec
    99 00000ED0 [0000000000000000]  <1>
   100 00000ED8 31F6                <1>  xor esi, esi
   101 00000EDA 0F05                <1>  syscall
  1648                                      
  1649 00000EDC E929090000                  jmp exit
  1650                                  
  1651                                  ; Función para imprimir los bloques
  1652                                  ; Función modificada para imprimir bloques
  1653                                  
  1654                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1655                                  get_current_level_blocks:
  1656 00000EE1 803D(B4140000)01            cmp byte [current_level], 1
  1657 00000EE8 7428                        je .level1
  1658 00000EEA 803D(B4140000)02            cmp byte [current_level], 2
  1659 00000EF1 7427                        je .level2
  1660 00000EF3 803D(B4140000)03            cmp byte [current_level], 3
  1661 00000EFA 7426                        je .level3
  1662 00000EFC 803D(B4140000)04            cmp byte [current_level], 4
  1663 00000F03 7425                        je .level4
  1664 00000F05 803D(B4140000)05            cmp byte [current_level], 5
  1665 00000F0C 7424                        je .level5
  1666                                      ; Si llegamos aquí, hay un error en el nivel
  1667 00000F0E 4831C0                      xor rax, rax
  1668 00000F11 C3                          ret
  1669                                  
  1670                                      .level1:
  1671 00000F12 488D05(B6140000)                lea rax, [level1_blocks]
  1672 00000F19 C3                              ret
  1673                                      .level2:
  1674 00000F1A 488D05(CA140000)                lea rax, [level2_blocks]
  1675 00000F21 C3                              ret
  1676                                      .level3:
  1677 00000F22 488D05(CF140000)                lea rax, [level3_blocks]
  1678 00000F29 C3                              ret
  1679                                      .level4:
  1680 00000F2A 488D05(D4140000)                lea rax, [level4_blocks]
  1681 00000F31 C3                              ret
  1682                                      .level5:
  1683 00000F32 488D05(D9140000)                lea rax, [level5_blocks]
  1684 00000F39 C3                              ret
  1685                                  ; Función para obtener la cantidad de bloques del nivel actual
  1686                                  get_current_level_count:
  1687 00000F3A 803D(B4140000)01            cmp byte [current_level], 1
  1688 00000F41 7428                        je .level1
  1689 00000F43 803D(B4140000)02            cmp byte [current_level], 2
  1690 00000F4A 7425                        je .level2
  1691 00000F4C 803D(B4140000)03            cmp byte [current_level], 3
  1692 00000F53 7422                        je .level3
  1693 00000F55 803D(B4140000)04            cmp byte [current_level], 4
  1694 00000F5C 741F                        je .level4
  1695 00000F5E 803D(B4140000)05            cmp byte [current_level], 5
  1696 00000F65 741C                        je .level5
  1697                                      ; Si llegamos aquí, hay un error en el nivel
  1698 00000F67 4831C0                      xor rax, rax
  1699 00000F6A C3                          ret
  1700                                  
  1701                                      .level1:
  1702 00000F6B B804000000                      mov rax, level1_blocks_count
  1703 00000F70 C3                              ret
  1704                                      .level2:
  1705 00000F71 B801000000                      mov rax, level2_blocks_count
  1706 00000F76 C3                              ret
  1707                                      .level3:
  1708 00000F77 B801000000                      mov rax, level3_blocks_count
  1709 00000F7C C3                              ret
  1710                                      .level4:
  1711 00000F7D B801000000                      mov rax, level4_blocks_count
  1712 00000F82 C3                              ret
  1713                                      .level5:
  1714 00000F83 B801000000                      mov rax, level5_blocks_count
  1715 00000F88 C3                              ret
  1716                                  
  1717                                  
  1718                                  print_blocks:
  1719 00000F89 55                          push rbp
  1720 00000F8A 4889E5                      mov rbp, rsp
  1721                                      
  1722                                      ; Obtener puntero a los bloques del nivel actual
  1723 00000F8D E84FFFFFFF                  call get_current_level_blocks
  1724 00000F92 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1725                                      
  1726                                      ; Obtener cantidad de bloques del nivel actual
  1727 00000F95 E8A0FFFFFF                  call get_current_level_count
  1728 00000F9A 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1729                                      
  1730 00000F9D 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1731                                      
  1732                                      .print_loop:
  1733 00000FA0 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1734 00000FA3 7D6F                            jge .end
  1735                                          
  1736                                          ; Verificar si el bloque está activo
  1737 00000FA5 490FB68424-                     movzx rax, byte [block_states + r12]
  1737 00000FAA [DE140000]         
  1738 00000FAE 4885C0                          test rax, rax
  1739 00000FB1 745C                            jz .next_block
  1740                                          
  1741                                          ; Obtener posición y tipo del bloque usando r13
  1742 00000FB3 4C89E0                          mov rax, r12
  1743 00000FB6 486BC005                        imul rax, 5
  1744 00000FBA 4C01E8                          add rax, r13
  1745 00000FBD 448A00                          mov r8b, [rax]        ; X position
  1746 00000FC0 448A4801                        mov r9b, [rax + 1]    ; Y position
  1747 00000FC4 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1748                                  
  1749                                          ; El resto de la lógica de impresión permanece igual
  1750 00000FC8 4D0FB6C0                        movzx r8, r8b
  1751 00000FCC 4D0FB6C9                        movzx r9, r9b
  1752 00000FD0 4981C0[000A0000]                add r8, board
  1753 00000FD7 B850000000                      mov rax, column_cells + 2
  1754 00000FDC 49F7E1                          mul r9
  1755 00000FDF 4901C0                          add r8, rax
  1756                                          
  1757 00000FE2 B906000000                      mov rcx, block_length
  1758 00000FE7 48BE-                           mov rsi, block_type_1
  1758 00000FE9 [9014000000000000] 
  1759 00000FF1 490FB6C2                        movzx rax, r10b
  1760 00000FF5 48FFC8                          dec rax
  1761 00000FF8 486BC006                        imul rax, block_length
  1762 00000FFC 4801C6                          add rsi, rax
  1763                                          
  1764                                      .print_block_chars:
  1765 00000FFF 8A06                            mov al, [rsi]
  1766 00001001 418800                          mov [r8], al
  1767 00001004 48FFC6                          inc rsi
  1768 00001007 49FFC0                          inc r8
  1769 0000100A 48FFC9                          dec rcx
  1770 0000100D 75F0                            jnz .print_block_chars
  1771                                          
  1772                                      .next_block:
  1773 0000100F 49FFC4                          inc r12
  1774 00001012 EB8C                            jmp .print_loop
  1775                                          
  1776                                      .end:
  1777 00001014 5D                              pop rbp
  1778 00001015 C3                              ret
  1779                                  
  1780                                  ; Función para convertir número a string
  1781                                  ; Input: RAX = número a convertir
  1782                                  ; RDI = buffer donde escribir el string
  1783                                  number_to_string:
  1784 00001016 53                          push rbx
  1785 00001017 52                          push rdx
  1786 00001018 56                          push rsi
  1787 00001019 BB0A000000                  mov rbx, 10          ; Divisor
  1788 0000101E B900000000                  mov rcx, 0          ; Contador de dígitos
  1789                                      
  1790                                      ; Si el número es 0, manejarlo especialmente
  1791 00001023 4885C0                      test rax, rax
  1792 00001026 7509                        jnz .convert_loop
  1793 00001028 C60730                      mov byte [rdi], '0'
  1794 0000102B C6470100                    mov byte [rdi + 1], 0
  1795 0000102F EB20                        jmp .end
  1796                                      
  1797                                      .convert_loop:
  1798 00001031 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1799 00001034 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1800 00001037 80C230                          add dl, '0'     ; Convertir a ASCII
  1801 0000103A 52                              push rdx        ; Guardar el dígito
  1802 0000103B 48FFC1                          inc rcx         ; Incrementar contador
  1803 0000103E 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1804 00001041 75EE                            jnz .convert_loop
  1805                                          
  1806                                      .write_loop:
  1807 00001043 5A                              pop rdx         ; Obtener dígito
  1808 00001044 8817                            mov [rdi], dl   ; Escribir al buffer
  1809 00001046 48FFC7                          inc rdi         ; Siguiente posición
  1810 00001049 48FFC9                          dec rcx         ; Decrementar contador
  1811 0000104C 75F5                            jnz .write_loop
  1812                                          
  1813 0000104E C60700                      mov byte [rdi], 0   ; Null terminator
  1814                                      
  1815                                      .end:
  1816 00001051 5E                          pop rsi
  1817 00001052 5A                          pop rdx
  1818 00001053 5B                          pop rbx
  1819 00001054 C3                          ret
  1820                                  
  1821                                  ; Función para imprimir los labels
  1822                                  print_labels:
  1823 00001055 55                          push rbp
  1824 00001056 4889E5                      mov rbp, rsp
  1825                                  
  1826                                      ; Crear buffer temporal
  1827 00001059 4883EC20                    sub rsp, 32
  1828                                  
  1829                                      ; Copiar labels a buffer temporal
  1830 0000105D 4889E7                      mov rdi, rsp
  1831 00001060 488D35(F7150000)            lea rsi, [score_label]
  1832 00001067 B917000000                  mov rcx, score_label_len
  1833 0000106C F3A4                        rep movsb
  1834                                  
  1835                                      ; Convertir score a string
  1836 0000106E 488B05(42150000)            mov rax, [current_score]
  1837 00001075 48BF-                       mov rdi, number_buffer
  1837 00001077 [4B15000000000000] 
  1838 0000107F E892FFFFFF                  call number_to_string
  1839                                  
  1840                                      ; Calcular longitud del número
  1841 00001084 B900000000                  mov rcx, 0
  1842 00001089 48BF-                       mov rdi, number_buffer
  1842 0000108B [4B15000000000000] 
  1843                                      .count_loop:
  1844 00001093 803C0F00                        cmp byte [rdi + rcx], 0
  1845 00001097 7405                            je .count_done
  1846 00001099 48FFC1                          inc rcx
  1847 0000109C EBF5                            jmp .count_loop
  1848                                      .count_done:
  1849                                  
  1850                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1851 0000109E 4889E7                      mov rdi, rsp
  1852 000010A1 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1853 000010A5 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1854 000010AA 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1855                                      .pad_loop:
  1856 000010AD 4885F6                          test rsi, rsi
  1857 000010B0 740B                            jz .pad_done
  1858 000010B2 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1859 000010B5 48FFC7                          inc rdi
  1860 000010B8 48FFCE                          dec rsi
  1861 000010BB EBF0                            jmp .pad_loop
  1862                                      .pad_done:
  1863                                  
  1864                                      ; Copiar el número
  1865 000010BD 48BE-                       mov rsi, number_buffer
  1865 000010BF [4B15000000000000] 
  1866 000010C7 F3A4                        rep movsb
  1867                                  
  1868                                      ; Imprimir el buffer completo
  1869                                      print rsp, score_label_len
    82 000010C9 B801000000          <1>  mov eax, sys_write
    83 000010CE BF01000000          <1>  mov edi, 1
    84 000010D3 4889E6              <1>  mov rsi, %1
    85 000010D6 BA17000000          <1>  mov edx, %2
    86 000010DB 0F05                <1>  syscall
  1870                                  
  1871                                      ; Repetir proceso para bloques destruidos
  1872 000010DD 4889E7                      mov rdi, rsp
  1873 000010E0 488D35(0E160000)            lea rsi, [blocks_label]
  1874 000010E7 B91B000000                  mov rcx, blocks_label_len
  1875 000010EC F3A4                        rep movsb
  1876                                  
  1877                                      ; Verificar que el `[` esté en su posición correcta
  1878 000010EE 4889E7                      mov rdi, rsp
  1879 000010F1 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1880 000010F5 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1881                                  
  1882                                      ; Convertir bloques destruidos a string
  1883 000010F8 480FB605(4A150000)          movzx rax, byte [destroyed_blocks]
  1884 00001100 48BF-                       mov rdi, number_buffer
  1884 00001102 [4B15000000000000] 
  1885 0000110A E807FFFFFF                  call number_to_string
  1886                                  
  1887                                      ; Calcular longitud del número
  1888 0000110F B900000000                  mov rcx, 0
  1889 00001114 48BF-                       mov rdi, number_buffer
  1889 00001116 [4B15000000000000] 
  1890                                      .count_loop2:
  1891 0000111E 803C0F00                        cmp byte [rdi + rcx], 0
  1892 00001122 7405                            je .count_done2
  1893 00001124 48FFC1                          inc rcx
  1894 00001127 EBF5                            jmp .count_loop2
  1895                                      .count_done2:
  1896                                  
  1897                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1898 00001129 4889E7                      mov rdi, rsp
  1899 0000112C 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1900 00001130 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1901 00001135 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1902                                      .pad_loop2:
  1903 00001138 4885F6                          test rsi, rsi
  1904 0000113B 740B                            jz .pad_done2
  1905 0000113D C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1906 00001140 48FFC7                          inc rdi
  1907 00001143 48FFCE                          dec rsi
  1908 00001146 EBF0                            jmp .pad_loop2
  1909                                      .pad_done2:
  1910                                  
  1911                                      ; Copiar el número
  1912 00001148 48BE-                       mov rsi, number_buffer
  1912 0000114A [4B15000000000000] 
  1913 00001152 F3A4                        rep movsb
  1914                                  
  1915                                      ; Imprimir el buffer completo
  1916                                      print rsp, blocks_label_len
    82 00001154 B801000000          <1>  mov eax, sys_write
    83 00001159 BF01000000          <1>  mov edi, 1
    84 0000115E 4889E6              <1>  mov rsi, %1
    85 00001161 BA1B000000          <1>  mov edx, %2
    86 00001166 0F05                <1>  syscall
  1917                                  
  1918                                      ; Restaurar stack
  1919 00001168 4883C420                    add rsp, 32
  1920 0000116C 5D                          pop rbp
  1921 0000116D C3                          ret
  1922                                  
  1923                                  
  1924                                  
  1925                                  check_block_collision:
  1926 0000116E 55                          push rbp
  1927 0000116F 4889E5                      mov rbp, rsp
  1928                                  
  1929                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1930 00001172 418A02                      mov al, [r10]
  1931                                  
  1932                                      ; Verificar si el carácter es un bloque
  1933 00001175 3C55                        cmp al, 'U'  
  1934 00001177 7419                        je .possible
  1935 00001179 3C4F                        cmp al, 'O'  
  1936 0000117B 7415                        je .possible
  1937 0000117D 3C44                        cmp al, 'D'  
  1938 0000117F 7411                        je .possible
  1939 00001181 3C4C                        cmp al, 'L'  
  1940 00001183 740D                        je .possible
  1941 00001185 3C56                        cmp al, 'V'  
  1942 00001187 7409                        je .possible
  1943 00001189 3C38                        cmp al, '8'  
  1944 0000118B 7405                        je .possible
  1945                                  
  1946                                      ; No es bloque, salir
  1947 0000118D 4831C0                      xor rax, rax
  1948 00001190 5D                          pop rbp
  1949 00001191 C3                          ret
  1950                                  
  1951                                  .possible:
  1952 00001192 53                          push rbx
  1953 00001193 57                          push rdi
  1954 00001194 56                          push rsi
  1955 00001195 4154                        push r12
  1956 00001197 4155                        push r13
  1957 00001199 4156                        push r14
  1958 0000119B 4157                        push r15
  1959                                  
  1960                                      ; 1) Obtener base de los bloques del nivel actual
  1961 0000119D E83FFDFFFF                  call get_current_level_blocks
  1962 000011A2 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1963                                  
  1964                                      ; 2) Obtener la cantidad de bloques
  1965 000011A5 E890FDFFFF                  call get_current_level_count
  1966 000011AA 4989C6                      mov r14, rax
  1967                                  
  1968 000011AD 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1969                                  
  1970                                  .find_block_loop:
  1971 000011B0 4D39F4                      cmp r12, r14
  1972 000011B3 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1973                                  
  1974                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1975 000011B9 4C89E0                      mov rax, r12
  1976 000011BC 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1977 000011C0 4C01E8                      add rax, r13
  1978 000011C3 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1979                                  
  1980                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1981 000011C6 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1981 000011CB [DE140000]         
  1982 000011CF 4885DB                      test rbx, rbx
  1983 000011D2 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1984                                  
  1985                                      ; Obtener coordenadas
  1986 000011D8 418A17                      mov dl, [r15]         ; x
  1987 000011DB 418A4F01                    mov cl, [r15 + 1]     ; y
  1988                                  
  1989                                      ; Calcular posición en el board
  1990 000011DF 488D3D(000A0000)            lea rdi, [board]
  1991 000011E6 4831C0                      xor rax, rax
  1992 000011E9 B84E000000                  mov rax, column_cells
  1993 000011EE 4883C002                    add rax, 2
  1994 000011F2 480FB6C9                    movzx rcx, cl         ; y
  1995 000011F6 480FAFC1                    imul rax, rcx
  1996 000011FA 4801C7                      add rdi, rax
  1997 000011FD 480FB6C2                    movzx rax, dl         ; x
  1998 00001201 4801C7                      add rdi, rax
  1999                                  
  2000                                      ; Guardar la posición base del bloque
  2001 00001204 57                          push rdi
  2002                                  
  2003                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2004 00001205 4939FA                      cmp r10, rdi
  2005 00001208 7274                        jb .skip_collision
  2006 0000120A 488D5F06                    lea rbx, [rdi + block_length]
  2007 0000120E 4939DA                      cmp r10, rbx
  2008 00001211 736B                        jae .skip_collision
  2009                                  
  2010                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2011 00001213 41FE8C24[DE140000]          dec byte [block_states + r12]
  2012                                      ; Volver a cargar durabilidad
  2013 0000121B 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2013 00001220 [DE140000]         
  2014 00001224 4885DB                      test rbx, rbx
  2015 00001227 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2016                                  
  2017                                      ; >>> Llegó a 0 => Bloque destruido
  2018 00001229 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2019 0000122A B906000000                  mov rcx, block_length
  2020                                  .clear_loop:
  2021 0000122F C60720                      mov byte [rdi], ' '
  2022 00001232 48FFC7                      inc rdi
  2023 00001235 E2F8                        loop .clear_loop
  2024                                  
  2025                                      ; Dibujar letra del bloque destruido
  2026 00001237 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2027 0000123B 4883EF06                    sub rdi, block_length
  2028 0000123F 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2029                                      ; Después de escribir la letra en el tablero
  2030 00001241 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2031 00001245 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2032 00001249 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2033 0000124E E853F1FFFF                  call register_letter
  2034                                      ; Actualizar contadores globales
  2035 00001253 FE0D(B5140000)              dec byte [blocks_remaining]
  2036 00001259 FE05(4A150000)              inc byte [destroyed_blocks]
  2037                                  
  2038                                      ; Sumar puntos según el tipo
  2039 0000125F 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2040 00001264 486BC00A                    imul rax, 10
  2041 00001268 480105(42150000)            add [current_score], rax
  2042                                  
  2043 0000126F B801000000                  mov rax, 1  ; colisión con destrucción
  2044 00001274 EB14                        jmp .end_pop
  2045                                  
  2046                                  .update_display:
  2047                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2048 00001276 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2049 0000127B 5F                          pop rdi     ; pop que quedó pendiente
  2050 0000127C EB0C                        jmp .end_pop
  2051                                  
  2052                                  .skip_collision:
  2053 0000127E 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2054                                  .next_block:
  2055 0000127F 49FFC4                      inc r12
  2056 00001282 E929FFFFFF                  jmp .find_block_loop
  2057                                  
  2058                                  .no_block_found:
  2059 00001287 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2060                                  
  2061                                  .end_pop:
  2062 0000128A 415F                        pop r15
  2063 0000128C 415E                        pop r14
  2064 0000128E 415D                        pop r13
  2065 00001290 415C                        pop r12
  2066 00001292 5E                          pop rsi
  2067 00001293 5F                          pop rdi
  2068 00001294 5B                          pop rbx
  2069 00001295 5D                          pop rbp
  2070 00001296 C3                          ret
  2071                                  
  2072                                  
  2073                                  
  2074                                  init_enemies:
  2075 00001297 55                          push rbp
  2076 00001298 4889E5                      mov rbp, rsp
  2077                                      ; Reiniciar contadores de movimiento
  2078 0000129B C605(8D150000)00            mov byte [enemy_move_total], 0
  2079 000012A2 C605(8E150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2080                                      ; Limpiar estado previo de enemigos
  2081 000012A9 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2082 000012AE 488D3D(64150000)            lea rdi, [enemies]
  2083 000012B5 30C0                        xor al, al
  2084 000012B7 F3AA                        rep stosb ; Limpiar datos de enemigos
  2085                                      
  2086                                      ; Marcar todos los enemigos como inactivos
  2087 000012B9 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  2088 000012C0 30C0                        xor al, al
  2089 000012C2 B90A000000                  mov rcx, 10
  2090 000012C7 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2091                                  
  2092 000012C9 5D                          pop rbp
  2093 000012CA C3                          ret
  2094                                  
  2095                                  
  2096                                  ; Función para mover enemigos
  2097                                  move_enemies:
  2098 000012CB 55                          push rbp
  2099 000012CC 4889E5                      mov rbp, rsp
  2100                                      
  2101                                      ; Incrementar contador de movimiento
  2102 000012CF FE05(8B150000)              inc byte [enemy_move_counter]
  2103 000012D5 480FB605(8B150000)          movzx rax, byte [enemy_move_counter]
  2104 000012DD 3A05(8C150000)              cmp al, [enemy_move_delay]
  2105 000012E3 0F85AA010000                jne .end
  2106                                      
  2107                                      ; Resetear contador
  2108 000012E9 C605(8B150000)00            mov byte [enemy_move_counter], 0
  2109                                      
  2110 000012F0 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2111                                      
  2112                                      .enemy_loop:
  2113 000012F3 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2114 000012F7 0F8D96010000                    jge .end
  2115                                          
  2116                                          ; Calcular offset del enemigo actual
  2117 000012FD 4C89E0                          mov rax, r12
  2118 00001300 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2119 00001304 488DB0[64150000]                lea rsi, [enemies + rax]
  2120                                          
  2121                                          ; Verificar si el enemigo está activo
  2122 0000130B 807E0201                        cmp byte [rsi + 2], 1
  2123 0000130F 0F8576010000                    jne .next_enemy
  2124                                          
  2125                                          ; Obtener posición actual
  2126 00001315 4C0FB606                        movzx r8, byte [rsi]            ; X
  2127 00001319 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2128                                          
  2129                                          ; Limpiar posición actual antes de mover
  2130 0000131E 4150                            push r8
  2131 00001320 4151                            push r9
  2132 00001322 B84E000000                      mov rax, column_cells
  2133 00001327 4883C002                        add rax, 2
  2134 0000132B 49F7E1                          mul r9
  2135 0000132E 4C01C0                          add rax, r8
  2136 00001331 488DB8[000A0000]                lea rdi, [board + rax]
  2137 00001338 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2138 0000133B 4159                            pop r9
  2139 0000133D 4158                            pop r8
  2140                                  
  2141                                          ; Determinar comportamiento basado en índice
  2142 0000133F 4C89E0                          mov rax, r12
  2143 00001342 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2144 00001346 4885C0                          test rax, rax
  2145 00001349 7402                            jz .chase_ball
  2146 0000134B EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2147                                          
  2148                                          ; Perseguir bola (comportamiento original)
  2149                                      .chase_ball:
  2150 0000134D 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2151 00001354 4D39D0                          cmp r8, r10
  2152 00001357 0F8F96000000                    jg .move_left
  2153 0000135D 0F8C95000000                    jl .move_right
  2154                                          
  2155 00001363 4C8B15(67140000)                mov r10, [ball_y_pos]
  2156 0000136A 4D39D1                          cmp r9, r10
  2157 0000136D 0F8F8A000000                    jg .move_up
  2158 00001373 0F8C89000000                    jl .move_down
  2159 00001379 E9A5000000                      jmp .check_collision
  2160                                          
  2161                                      .chase_paddle:
  2162                                          ; Obtener la posición X actual de la paleta
  2163 0000137E 4C8B15(3F140000)                mov r10, [pallet_position]
  2164 00001385 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2165                                          
  2166                                          ; Calcular la posición X real de la paleta
  2167 0000138C 4C89D0                          mov rax, r10
  2168 0000138F BB4E000000                      mov rbx, column_cells
  2169 00001394 4883C302                        add rbx, 2                  ; Añadir newline chars
  2170 00001398 4831D2                          xor rdx, rdx
  2171 0000139B 48F7F3                          div rbx                     ; rax = y, rdx = x
  2172                                          
  2173                                          ; rdx ahora contiene la posición X de la paleta
  2174                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2175 0000139E 488B0D(47140000)                mov rcx, [pallet_size]
  2176 000013A5 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2177 000013A8 4801CA                          add rdx, rcx
  2178                                          
  2179                                          ; Comparar con posición X del enemigo y mover gradualmente
  2180 000013AB 4939D0                          cmp r8, rdx
  2181 000013AE 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2182 000013B0 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2183 000013B2 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2184                                  
  2185                                      .check_y_paddle:
  2186                                          ; La Y de la paleta siempre es row_cells - 2
  2187 000013B4 41BA20000000                    mov r10, row_cells
  2188 000013BA 4983EA02                        sub r10, 2
  2189                                          
  2190                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2191 000013BE 4D39D1                          cmp r9, r10
  2192 000013C1 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2193 000013C3 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2194 000013C5 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2195                                          
  2196                                      .no_movement:
  2197 000013C7 EB5A                            jmp .check_collision
  2198                                  
  2199                                      ; También agregar una nueva sección para el movimiento suave
  2200                                      .smooth_transition:
  2201                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2202 000013C9 8A05(8E150000)                  mov al, [enemy_target]
  2203 000013CF 84C0                            test al, al
  2204 000013D1 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2205                                          
  2206                                          ; Verificar distancia en X
  2207 000013D3 4989D2                          mov r10, rdx              ; Posición X objetivo
  2208 000013D6 4D29C2                          sub r10, r8               ; Calcular diferencia
  2209 000013D9 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2210 000013DD 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2211 000013DF 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2212 000013E3 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2213 000013E5 EB3C                            jmp .check_collision
  2214                                          
  2215                                      .limit_right_movement:
  2216 000013E7 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2217 000013EB EB36                            jmp .check_collision
  2218                                          
  2219                                      .limit_left_movement:
  2220 000013ED 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2221 000013F1 EB30                            jmp .check_collision
  2222                                      .move_left:
  2223 000013F3 49FFC8                          dec r8
  2224 000013F6 EB0F                            jmp .check_vertical
  2225                                          
  2226                                      .move_right:
  2227 000013F8 49FFC0                          inc r8
  2228 000013FB EB0A                            jmp .check_vertical
  2229                                          
  2230                                      .move_up:
  2231 000013FD 49FFC9                          dec r9
  2232 00001400 EB21                            jmp .check_collision
  2233                                          
  2234                                      .move_down:
  2235 00001402 49FFC1                          inc r9
  2236 00001405 EB1C                            jmp .check_collision
  2237                                          
  2238                                      .check_vertical:
  2239 00001407 8A05(8E150000)                  mov al, [enemy_target]
  2240 0000140D 84C0                            test al, al
  2241 0000140F 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2242 00001415 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2243 0000141C 4D39D1                          cmp r9, r10
  2244 0000141F 7FDC                            jg .move_up
  2245 00001421 7CDF                            jl .move_down
  2246                                          
  2247                                      .check_collision:
  2248                                          ; Verificar colisión con bordes
  2249 00001423 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2250 00001427 7E62                            jle .next_enemy
  2251 00001429 4983F84E                        cmp r8, column_cells
  2252 0000142D 7D5C                            jge .next_enemy
  2253 0000142F 4983F901                        cmp r9, 1                       ; Borde superior
  2254 00001433 7E56                            jle .next_enemy
  2255 00001435 4983F920                        cmp r9, row_cells
  2256 00001439 7D50                            jge .next_enemy
  2257                                          
  2258                                          ; Verificar colisión con bloques antes de moverse
  2259 0000143B 4150                            push r8
  2260 0000143D 4151                            push r9
  2261 0000143F 4152                            push r10
  2262                                          
  2263                                          ; Calcular posición en el tablero para verificar
  2264 00001441 B84E000000                      mov rax, column_cells
  2265 00001446 4883C002                        add rax, 2
  2266 0000144A 49F7E1                          mul r9
  2267 0000144D 4C01C0                          add rax, r8
  2268 00001450 4C8D90[000A0000]                lea r10, [board + rax]
  2269                                          
  2270                                          ; Verificar si hay un bloque en la nueva posición
  2271 00001457 418A02                          mov al, [r10]
  2272 0000145A 3C55                            cmp al, 'U'
  2273 0000145C 7427                            je .invalid_move
  2274 0000145E 3C4F                            cmp al, 'O'
  2275 00001460 7423                            je .invalid_move
  2276 00001462 3C44                            cmp al, 'D'
  2277 00001464 741F                            je .invalid_move
  2278 00001466 3C4C                            cmp al, 'L'
  2279 00001468 741B                            je .invalid_move
  2280 0000146A 3C56                            cmp al, 'V'
  2281 0000146C 7417                            je .invalid_move
  2282 0000146E 3C38                            cmp al, '8'
  2283 00001470 7413                            je .invalid_move
  2284 00001472 3C58                            cmp al, 'X'
  2285 00001474 740F                            je .invalid_move
  2286                                          
  2287 00001476 415A                            pop r10
  2288 00001478 4159                            pop r9
  2289 0000147A 4158                            pop r8
  2290                                          
  2291                                          ; Guardar nueva posición si es válida
  2292 0000147C 448806                          mov [rsi], r8b
  2293 0000147F 44884E01                        mov [rsi + 1], r9b
  2294 00001483 EB06                            jmp .next_enemy
  2295                                          
  2296                                      .invalid_move:
  2297 00001485 415A                            pop r10
  2298 00001487 4159                            pop r9
  2299 00001489 4158                            pop r8
  2300                                          
  2301                                      .next_enemy:
  2302 0000148B 49FFC4                          inc r12
  2303 0000148E E960FEFFFF                      jmp .enemy_loop
  2304                                          
  2305                                      .end:
  2306 00001493 5D                              pop rbp
  2307 00001494 C3                              ret
  2308                                  
  2309                                  get_current_spawn_points:
  2310 00001495 55                          push rbp
  2311 00001496 4889E5                      mov rbp, rsp
  2312                                      
  2313 00001499 480FB605(B4140000)          movzx rax, byte [current_level]
  2314 000014A1 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2315 000014A4 488B04C5[C2150000]          mov rax, [spawn_points_table + rax * 8]
  2316                                      
  2317 000014AC 5D                          pop rbp
  2318 000014AD C3                          ret
  2319                                  
  2320                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2321                                  check_enemy_spawn:
  2322 000014AE 55                          push rbp
  2323 000014AF 4889E5                      mov rbp, rsp
  2324                                      
  2325                                      ; Obtener spawn points del nivel actual
  2326 000014B2 E8DEFFFFFF                  call get_current_spawn_points
  2327 000014B7 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2328                                      
  2329                                      ; Obtener cantidad de bloques destruidos
  2330 000014BA 4C0FB62D(4A150000)          movzx r13, byte [destroyed_blocks]
  2331                                      
  2332                                      ; Verificar cada punto de spawn
  2333 000014C2 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2334                                      
  2335                                      .check_loop:
  2336 000014C5 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2337 000014C9 7D4B                            jge .end
  2338                                          
  2339                                          ; Verificar si este spawn point ya fue usado
  2340 000014CB 80B9[ED150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2341 000014D2 743D                            je .next_enemy
  2342                                          
  2343                                          ; Verificar si este enemigo ya está activo
  2344 000014D4 4889C8                          mov rax, rcx
  2345 000014D7 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2346 000014DB 488DB0[64150000]                lea rsi, [enemies + rax]
  2347 000014E2 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2348 000014E6 7429                            je .next_enemy
  2349                                          
  2350                                          ; Verificar si debemos spawnear este enemigo
  2351 000014E8 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2352 000014ED 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2353 000014F0 751F                            jne .next_enemy
  2354                                          
  2355                                          ; Marcar este spawn point como usado
  2356 000014F2 C681[ED150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2357                                          
  2358                                          ; Spawner nuevo enemigo
  2359 000014F9 C60628                          mov byte [rsi], 40             ; X inicial
  2360 000014FC C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2361 00001500 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2362                                          
  2363                                          ; Inicializar comportamiento
  2364 00001504 4889C8                          mov rax, rcx
  2365 00001507 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2366 0000150B 8805(EC150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2367                                          
  2368                                      .next_enemy:
  2369 00001511 48FFC1                          inc rcx
  2370 00001514 EBAF                            jmp .check_loop
  2371                                          
  2372                                      .end:
  2373 00001516 5D                              pop rbp
  2374 00001517 C3                              ret
  2375                                  
  2376                                  
  2377                                  ; Función para dibujar enemigos
  2378                                  print_enemies:
  2379 00001518 55                          push rbp
  2380 00001519 4889E5                      mov rbp, rsp
  2381                                      
  2382 0000151C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2383                                      
  2384                                      .print_loop:
  2385 0000151F 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2386 00001523 7D4B                            jge .end
  2387                                          
  2388                                          ; Calcular offset del enemigo actual
  2389 00001525 4C89E0                          mov rax, r12
  2390 00001528 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2391 0000152C 488DB0[64150000]                lea rsi, [enemies + rax]
  2392                                          
  2393                                          ; Verificar si el enemigo está activo
  2394 00001533 807E0201                        cmp byte [rsi + 2], 1
  2395 00001537 7532                            jne .next_enemy
  2396                                          
  2397                                          ; Calcular posición en el tablero
  2398 00001539 4C0FB606                        movzx r8, byte [rsi]            ; X
  2399 0000153D 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2400                                          
  2401                                          ; Calcular offset en el tablero
  2402 00001542 B84E000000                      mov rax, column_cells
  2403 00001547 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2404 0000154B 49F7E1                          mul r9
  2405 0000154E 4C01C0                          add rax, r8
  2406 00001551 488DB8[000A0000]                lea rdi, [board + rax]
  2407                                          
  2408                                          ; Obtener carácter del enemigo según el nivel
  2409 00001558 480FB605(B4140000)              movzx rax, byte [current_level]
  2410 00001560 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2411 00001563 8A80[5F150000]                  mov al, [enemy_chars + rax]
  2412                                          
  2413                                          ; Dibujar enemigo
  2414 00001569 8807                            mov [rdi], al
  2415                                          
  2416                                      .next_enemy:
  2417 0000156B 49FFC4                          inc r12
  2418 0000156E EBAF                            jmp .print_loop
  2419                                          
  2420                                      .end:
  2421 00001570 5D                              pop rbp
  2422 00001571 C3                              ret
  2423                                  
  2424                                  ; Función para verificar colisión con enemigos
  2425                                  ; Función para verificar colisión con enemigos
  2426                                  check_enemy_collision:
  2427 00001572 55                          push rbp
  2428 00001573 4889E5                      mov rbp, rsp
  2429                                      
  2430 00001576 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2431 00001579 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2432                                      
  2433                                      .check_loop:
  2434 0000157C 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2435 00001580 0F8DE9000000                    jge .end
  2436                                          
  2437                                          ; Calcular offset del enemigo actual
  2438 00001586 4C89E1                          mov rcx, r12
  2439 00001589 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2440 0000158D 488DB1[64150000]                lea rsi, [enemies + rcx]
  2441                                          
  2442                                          ; Verificar si el enemigo está activo
  2443 00001594 807E0201                        cmp byte [rsi + 2], 1
  2444 00001598 0F85C9000000                    jne .next_enemy
  2445                                          
  2446                                          ; Verificar colisión con la bola
  2447 0000159E 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2448 000015A2 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2449                                          
  2450                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2451 000015A7 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2452 000015AE 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2453                                          
  2454                                          ; Comprobar colisión vertical (misma columna)
  2455 000015B5 4D39C2                          cmp r10, r8
  2456 000015B8 7525                            jne .check_horizontal
  2457 000015BA 4D29CB                          sub r11, r9
  2458 000015BD 4983FB01                        cmp r11, 1
  2459 000015C1 7F1C                            jg .check_horizontal
  2460 000015C3 4983FBFF                        cmp r11, -1
  2461 000015C7 7C16                            jl .check_horizontal
  2462                                          
  2463                                          ; Colisión vertical detectada
  2464 000015C9 E8A3000000                      call destroy_enemy
  2465 000015CE 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2466 000015D5 B801000000                      mov rax, 1
  2467 000015DA E990000000                      jmp .end
  2468                                          
  2469                                      .check_horizontal:
  2470                                          ; Comprobar colisión horizontal (misma fila)
  2471 000015DF 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2472 000015E6 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2473 000015ED 4D39CB                          cmp r11, r9
  2474 000015F0 7522                            jne .check_paddle
  2475 000015F2 4D29C2                          sub r10, r8
  2476 000015F5 4983FA01                        cmp r10, 1
  2477 000015F9 7F19                            jg .check_paddle
  2478 000015FB 4983FAFF                        cmp r10, -1
  2479 000015FF 7C13                            jl .check_paddle
  2480                                          
  2481                                          ; Colisión horizontal detectada
  2482 00001601 E86B000000                      call destroy_enemy
  2483 00001606 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2484 0000160D B801000000                      mov rax, 1
  2485 00001612 EB5B                            jmp .end
  2486                                          
  2487                                      .check_paddle:
  2488                                          ; Verificar colisión con la paleta
  2489 00001614 4C8B15(3F140000)                mov r10, [pallet_position]
  2490 0000161B 4981EA[000A0000]                sub r10, board
  2491 00001622 4C89D0                          mov rax, r10
  2492 00001625 41BB4E000000                    mov r11, column_cells
  2493 0000162B 4983C302                        add r11, 2
  2494 0000162F 4831D2                          xor rdx, rdx
  2495 00001632 49F7F3                          div r11                     ; División para obtener la posición Y
  2496 00001635 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2497                                          
  2498 00001638 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2499                                          
  2500                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2501 0000163F 41BD20000000                    mov r13, row_cells
  2502 00001645 4983ED02                        sub r13, 2                 ; Y de la paleta
  2503 00001649 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2504 0000164C 7519                            jne .next_enemy
  2505                                          
  2506                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2507 0000164E 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2508 00001651 7C14                            jl .next_enemy
  2509                                          
  2510 00001653 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2511 00001656 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2512 00001659 7F0C                            jg .next_enemy
  2513                                          
  2514                                          ; Si llegamos aquí, hay colisión con la paleta
  2515 0000165B E811000000                      call destroy_enemy        ; Destruir el enemigo
  2516 00001660 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2517 00001665 EB08                            jmp .end
  2518                                          
  2519                                      .next_enemy:
  2520 00001667 49FFC4                          inc r12
  2521 0000166A E90DFFFFFF                      jmp .check_loop
  2522                                          
  2523                                      .end:
  2524 0000166F 5D                              pop rbp
  2525 00001670 C3                              ret
  2526                                  
  2527                                  ; Función para destruir un enemigo
  2528                                  destroy_enemy:
  2529                                      ; Desactivar enemigo
  2530 00001671 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2531                                  
  2532                                      ; Sumar puntos por destruir enemigo
  2533 00001675 488B05(83150000)            mov rax, [enemy_points]
  2534 0000167C 480105(42150000)            add [current_score], rax
  2535                                  
  2536                                      ; No tocar bloques destruidos aquí
  2537 00001683 C3                          ret
  2538                                  
  2539                                  
  2540                                  _start:
  2541 00001684 E8A2EAFFFF              	call canonical_off
  2542 00001689 E809010000              	call start_screen
  2543 0000168E E8B9F5FFFF                  call init_level
  2544 00001693 E8FFFBFFFF                  call init_enemies
  2545 00001698 EB00                    	jmp .main_loop
  2546                                  	
  2547                                  
  2548                                  	.main_loop:
  2549 0000169A E8B6F9FFFF                      call print_labels
  2550 0000169F E8E5F8FFFF                      call print_blocks
  2551 000016A4 E8CEEDFFFF                      call move_letters
  2552 000016A9 E8E1EFFFFF                      call update_lasers
  2553 000016AE E839EDFFFF                      call print_letters
  2554 000016B3 E8E5F1FFFF              		call print_pallet
  2555 000016B8 E8C8F2FFFF                      call move_ball
  2556 000016BD E81CECFFFF                      call check_bottom_collision
  2557 000016C2 E816EBFFFF                      call print_lives
  2558 000016C7 E81FF7FFFF                      call check_level_complete
  2559 000016CC E8DDFDFFFF                      call check_enemy_spawn
  2560 000016D1 E8F5FBFFFF                      call move_enemies
  2561 000016D6 E897FEFFFF                      call check_enemy_collision
  2562 000016DB E838FEFFFF                      call print_enemies
  2563 000016E0 E890F1FFFF              		call print_ball
  2564                                  		print board, board_size				
    82 000016E5 B801000000          <1>  mov eax, sys_write
    83 000016EA BF01000000          <1>  mov edi, 1
    84 000016EF 48BE-               <1>  mov rsi, %1
    84 000016F1 [000A000000000000]  <1>
    85 000016F9 BA000A0000          <1>  mov edx, %2
    86 000016FE 0F05                <1>  syscall
  2565                                  		;setnonblocking	
  2566                                  	.read_more:	
  2567                                  	    getchar	
    90 00001700 B800000000          <1>  mov rax, sys_read
    91 00001705 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000170A 48BE-               <1>  mov rsi, input_char
    92 0000170C [0000000000000000]  <1>
    93 00001714 BA01000000          <1>  mov rdx, 1
    94 00001719 0F05                <1>  syscall
  2568 0000171B 4883F801                	    cmp rax, 1
  2569 0000171F 7543                    	    jne .done
  2570                                  	
  2571 00001721 8A05(00000000)          	    mov al, [input_char]
  2572 00001727 8805(09180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2573                                  	
  2574 0000172D 3C61                    	    cmp al, 'a'
  2575 0000172F 750E                    	    jne .not_left
  2576 00001731 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2577 00001738 E895F1FFFF              	    call move_pallet
  2578 0000173D EB25                    	    jmp .done
  2579                                  	
  2580                                      .not_left:
  2581 0000173F 3C64                    	    cmp al, 'd'
  2582 00001741 750C                    	    jne .not_right
  2583 00001743 BF01000000              	    mov rdi, right_direction
  2584 00001748 E885F1FFFF              	    call move_pallet
  2585 0000174D EB15                    	    jmp .done
  2586                                  	
  2587                                      .not_right:
  2588 0000174F 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2589 00001751 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2590                                  	
  2591 00001753 3C71                    	    cmp al, 'q' 
  2592 00001755 0F84AF000000            	    je exit
  2593 0000175B EBA3                    	    jmp .read_more
  2594                                  	
  2595                                      .release_ball:
  2596 0000175D E8F6F3FFFF              	    call process_catch_release
  2597 00001762 EB00                    	    jmp .done
  2598                                  	
  2599                                      .done:
  2600                                  	    sleeptime
    98 00001764 B823000000          <1>  mov eax, sys_nanosleep
    99 00001769 48BF-               <1>  mov rdi, timespec
    99 0000176B [0000000000000000]  <1>
   100 00001773 31F6                <1>  xor esi, esi
   101 00001775 0F05                <1>  syscall
  2601                                  	    print clear, clear_length
    82 00001777 B801000000          <1>  mov eax, sys_write
    83 0000177C BF01000000          <1>  mov edi, 1
    84 00001781 48BE-               <1>  mov rsi, %1
    84 00001783 [1000000000000000]  <1>
    85 0000178B BA07000000          <1>  mov edx, %2
    86 00001790 0F05                <1>  syscall
  2602 00001792 E903FFFFFF              	    jmp .main_loop
  2603                                  
  2604                                  
  2605                                  
  2606                                  
  2607                                  start_screen:
  2608                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001797 B801000000          <1>  mov eax, sys_write
    83 0000179C BF01000000          <1>  mov edi, 1
    84 000017A1 48BE-               <1>  mov rsi, %1
    84 000017A3 [1000000000000000]  <1>
    85 000017AB BA07000000          <1>  mov edx, %2
    86 000017B0 0F05                <1>  syscall
  2609                                      print msg1, msg1_length
    82 000017B2 B801000000          <1>  mov eax, sys_write
    83 000017B7 BF01000000          <1>  mov edi, 1
    84 000017BC 48BE-               <1>  mov rsi, %1
    84 000017BE [1700000000000000]  <1>
    85 000017C6 BA14010000          <1>  mov edx, %2
    86 000017CB 0F05                <1>  syscall
  2610                                      
  2611                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2612                                          getchar                 ; Esperamos una tecla
    90 000017CD B800000000          <1>  mov rax, sys_read
    91 000017D2 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000017D7 48BE-               <1>  mov rsi, input_char
    92 000017D9 [0000000000000000]  <1>
    93 000017E1 BA01000000          <1>  mov rdx, 1
    94 000017E6 0F05                <1>  syscall
  2613 000017E8 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2614 000017EC 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2615                                          
  2616                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000017EE B801000000          <1>  mov eax, sys_write
    83 000017F3 BF01000000          <1>  mov edi, 1
    84 000017F8 48BE-               <1>  mov rsi, %1
    84 000017FA [1000000000000000]  <1>
    85 00001802 BA07000000          <1>  mov edx, %2
    86 00001807 0F05                <1>  syscall
  2617 00001809 C3                          ret
  2618                                  
  2619                                  exit: 
  2620 0000180A E85EE9FFFF              	call canonical_on
  2621 0000180F B83C000000              	mov    rax, 60
  2622 00001814 BF00000000                  mov    rdi, 0
  2623 00001819 0F05                        syscall
  2624                                  
