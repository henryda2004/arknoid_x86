     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3813000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 38070301                        db 56, 7, 3, 1    ; Bloque 7
   288 000014AA 14070301                        db 20, 7, 3, 1    ; Bloque 7
   289 000014AE 1E070301                        db 30, 7, 3, 1    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B2 3C070101                        db 60, 7, 1, 1    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014B6 3C070201                        db 60, 7, 2, 1    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BA 3C070401                        db 60, 7, 4, 1    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014BE 3C070501                        db 60, 7, 5, 1    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 00001526 0000000000000000            current_score dq 0          ; Score actual
   319 0000152E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 0000152F 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 00001543 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 00001548 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 00001566 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 00001567 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 0000156F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001570 01                          enemy_move_delay db 1           ; Mover enemigos cada N ciclos
   333 00001571 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001572 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 00001573 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 00001574 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 0000157D 12                 
   339 0000157E 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 00001587 13                 
   340 00001588 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001591 1B                 
   341 00001592 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 0000159B 1C                 
   342 0000159C 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015A5 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015A6 [7415000000000000]              dq level1_spawn_points
   346 000015AE [7E15000000000000]              dq level2_spawn_points
   347 000015B6 [8815000000000000]              dq level3_spawn_points
   348 000015BE [9215000000000000]              dq level4_spawn_points
   349 000015C6 [9C15000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015CE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015CF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D0 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D1 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015DB 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015E4 5B2020202020202020-
   357 000015ED 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F2 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 000015FB 657374727569646F73-
   359 00001604 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365 0000160D 03                          lives_remaining db 3 ; Número inicial de vidas
   366                                  
   367                                  
   368                                  section .text
   369                                  
   370                                  ;	Function: print_ball
   371                                  ; This function displays the position of the ball
   372                                  ; Arguments: none
   373                                  ;
   374                                  ; Return:
   375                                  ;	Void
   376                                  print_lives:
   377 000001DD 57                          push rdi
   378 000001DE 56                          push rsi
   379 000001DF 51                          push rcx
   380 000001E0 50                          push rax
   381                                      
   382                                      ; Posición inicial dentro del tablero (fila inferior izquierda desplazada hacia adentro)
   383 000001E1 48BF-                       mov rdi, board
   383 000001E3 [000A000000000000] 
   384 000001EB 4881C762090000              add rdi, (row_cells - 2) * (column_cells + 2) + 2 ; Fila interna, no en el borde
   385                                  
   386                                      ; Número de vidas restantes
   387 000001F2 480FB60D(0D160000)          movzx rcx, byte [lives_remaining] ; Número de vidas
   388                                      
   389                                      .print_life:
   390 000001FA 4885C9                          test rcx, rcx
   391 000001FD 740B                            jz .done ; Si no hay más vidas, salir
   392                                          
   393 000001FF C6075E                          mov byte [rdi], '^' ; Dibujar vida
   394 00000202 48FFC7                          inc rdi             ; Mover al siguiente espacio
   395 00000205 48FFC9                          dec rcx             ; Reducir el contador
   396 00000208 EBF0                            jmp .print_life
   397                                          
   398                                      .done:
   399 0000020A 58                              pop rax
   400 0000020B 59                              pop rcx
   401 0000020C 5E                              pop rsi
   402 0000020D 5F                              pop rdi
   403 0000020E C3                              ret
   404                                  
   405                                  
   406                                  print_ball:
   407 0000020F 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   408 00000216 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   409 0000021D 4981C0[000A0000]        	add r8, board
   410                                  
   411 00000224 4C89C9                  	mov rcx, r9
   412 00000227 B850000000              	mov rax, column_cells + 2
   413 0000022C 48F7E9                  	imul rcx
   414                                  	
   415 0000022F 4901C0                  	add r8, rax
   416 00000232 41C6004F                	mov byte [r8], char_O
   417 00000236 C3                      	ret
   418                                  
   419                                  	
   420                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   421                                  	
   422                                  
   423                                  
   424                                  
   425                                  ;	Function: print_pallet
   426                                  ; This function moves the pallet in the game
   427                                  ; Arguments: none
   428                                  ;
   429                                  ; Return;
   430                                  ;	void
   431                                  print_pallet:
   432 00000237 4C8B05(3F140000)        	mov r8, [pallet_position]
   433 0000023E 488B0D(47140000)        	mov rcx, [pallet_size]
   434                                  	.write_pallet:
   435 00000245 41C6003D                		mov byte [r8], char_equal
   436 00000249 49FFC0                  		inc r8
   437 0000024C 48FFC9                  		dec rcx
   438 0000024F 75F4                    		jnz .write_pallet
   439                                  
   440 00000251 C3                      	ret
   441                                  	
   442                                  ;	Function: move_pallet
   443                                  ; This function is in charge of moving the pallet in a given direction
   444                                  ; Arguments:
   445                                  ;	rdi: left direction or right direction
   446                                  ;
   447                                  ; Return:
   448                                  ;	void
   449                                  move_pallet:
   450                                      
   451 00000252 803D(6F140000)00            cmp byte [ball_moving], 0
   452 00000259 7507                        jne .continue_movement
   453 0000025B C605(6F140000)01            mov byte [ball_moving], 1
   454                                  
   455                                      .continue_movement:
   456 00000262 4883FFFF                        cmp rdi, left_direction
   457 00000266 7531                            jne .move_right
   458                                  
   459                                          .move_left:
   460                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   461 00000268 4C8B05(3F140000)                    mov r8, [pallet_position]
   462 0000026F 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   463 00000272 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   464 00000275 3C58                                cmp al, 'X'        ; Comparar si es una X
   465 00000277 744D                                je .end            ; Si es X, no mover
   466                                              
   467 00000279 4C8B05(3F140000)                    mov r8, [pallet_position]
   468 00000280 4C8B0D(47140000)                    mov r9, [pallet_size]
   469 00000287 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   470 0000028D 49FFC8                              dec r8
   471 00000290 4C8905(3F140000)                    mov [pallet_position], r8
   472 00000297 EB2D                                jmp .end
   473                                              
   474                                          .move_right:
   475                                              ; Verificar si la siguiente posición después de la paleta sería una X
   476 00000299 4C8B05(3F140000)                    mov r8, [pallet_position]
   477 000002A0 4C8B0D(47140000)                    mov r9, [pallet_size]
   478 000002A7 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   479 000002AA 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   480 000002AD 3C58                                cmp al, 'X'        ; Comparar si es una X
   481 000002AF 7415                                je .end            ; Si es X, no mover
   482                                              
   483 000002B1 4C8B05(3F140000)                    mov r8, [pallet_position]
   484 000002B8 41C60020                            mov byte [r8], char_space
   485 000002BC 49FFC0                              inc r8
   486 000002BF 4C8905(3F140000)                    mov [pallet_position], r8
   487                                          .end:
   488 000002C6 C3                                  ret
   489                                  
   490                                  move_ball:
   491                                      ; Si la bola no está en movimiento, no hacer nada
   492 000002C7 803D(6F140000)00            cmp byte [ball_moving], 0
   493 000002CE 0F8406010000                je .end
   494                                  
   495                                      ; Borrar la posición actual de la bola
   496 000002D4 4C8B05(4F140000)            mov r8, [ball_x_pos]
   497 000002DB 4C8B0D(57140000)            mov r9, [ball_y_pos]
   498 000002E2 4981C0[000A0000]            add r8, board
   499 000002E9 4C89C9                      mov rcx, r9
   500 000002EC B850000000                  mov rax, column_cells + 2
   501 000002F1 48F7E9                      imul rcx
   502 000002F4 4901C0                      add r8, rax
   503 000002F7 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   504                                  
   505                                      ; Calcular siguiente posición X
   506 000002FB 4C8B05(4F140000)            mov r8, [ball_x_pos]
   507 00000302 4C8B0D(57140000)            mov r9, [ball_y_pos]
   508 00000309 488B05(5F140000)            mov rax, [ball_direction_x]
   509 00000310 4901C0                      add r8, rax                  ; Nueva posición X
   510                                  
   511                                      ; Calcular la dirección de memoria para la siguiente posición
   512 00000313 4D89C2                      mov r10, r8
   513 00000316 4981C2[000A0000]            add r10, board
   514 0000031D 4C89C9                      mov rcx, r9
   515 00000320 B850000000                  mov rax, column_cells + 2
   516 00000325 48F7E9                      imul rcx
   517 00000328 4901C2                      add r10, rax
   518                                  
   519                                      ; Verificar si hay una X en la siguiente posición X
   520 0000032B 418A02                      mov al, [r10]
   521 0000032E 3C58                        cmp al, 'X'
   522 00000330 750C                        jne .check_block_x
   523 00000332 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   524 00000339 E99C000000                  jmp .end
   525                                  
   526                                      .check_block_x:
   527                                          ; Verificar colisión con bloques en X
   528 0000033E 4150                            push r8     ; Guardar registros que usa check_block_collision
   529 00000340 4151                            push r9
   530 00000342 4152                            push r10
   531 00000344 E80D060000                      call check_block_collision
   532 00000349 415A                            pop r10
   533 0000034B 4159                            pop r9
   534 0000034D 4158                            pop r8
   535 0000034F 4885C0                          test rax, rax
   536 00000352 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   537 00000354 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   538 0000035B EB7D                            jmp .end
   539                                  
   540                                      .check_paddle_x:
   541                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   542 0000035D 41803A3D                        cmp byte [r10], char_equal
   543 00000361 7509                            jne .check_y_movement
   544 00000363 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   545 0000036A EB6E                            jmp .end
   546                                  
   547                                      .check_y_movement:
   548                                          ; Calcular siguiente posición Y
   549 0000036C 488B05(67140000)                mov rax, [ball_direction_y]
   550 00000373 4901C1                          add r9, rax                  ; Nueva posición Y
   551                                  
   552                                          ; Calcular la dirección de memoria para la siguiente posición Y
   553 00000376 4D89C2                          mov r10, r8
   554 00000379 4981C2[000A0000]                add r10, board
   555 00000380 4C89C9                          mov rcx, r9
   556 00000383 B850000000                      mov rax, column_cells + 2
   557 00000388 48F7E9                          imul rcx
   558 0000038B 4901C2                          add r10, rax
   559                                  
   560                                          ; Verificar si hay una X en la siguiente posición Y
   561 0000038E 418A02                          mov al, [r10]
   562 00000391 3C58                            cmp al, 'X'
   563 00000393 7509                            jne .check_block_y
   564 00000395 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   565 0000039C EB3C                            jmp .end
   566                                  
   567                                      .check_block_y:
   568                                          ; Verificar colisión con bloques en Y
   569 0000039E 4150                            push r8     ; Guardar registros que usa check_block_collision
   570 000003A0 4151                            push r9
   571 000003A2 4152                            push r10
   572 000003A4 E8AD050000                      call check_block_collision
   573 000003A9 415A                            pop r10
   574 000003AB 4159                            pop r9
   575 000003AD 4158                            pop r8
   576 000003AF 4885C0                          test rax, rax
   577 000003B2 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   578 000003B4 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   579 000003BB EB1D                            jmp .end
   580                                  
   581                                      .check_paddle_y:
   582                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   583 000003BD 41803A3D                    cmp byte [r10], char_equal
   584 000003C1 7509                        jne .update_position
   585 000003C3 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   586 000003CA EB0E                        jmp .end
   587                                  
   588                                  
   589                                      .update_position:
   590 000003CC 4C8905(4F140000)                mov [ball_x_pos], r8
   591 000003D3 4C890D(57140000)                mov [ball_y_pos], r9
   592                                  
   593                                      .end:
   594 000003DA C3                              ret
   595                                  
   596                                  ; Función para inicializar el nivel
   597                                  ; Función para inicializar el nivel
   598                                  ; Función para mostrar el número de nivel
   599                                  display_level_number:
   600 000003DB 55                          push rbp
   601 000003DC 4889E5                      mov rbp, rsp
   602                                      
   603                                      ; Limpiar la pantalla primero
   604                                      print clear, clear_length
    82 000003DF B801000000          <1>  mov eax, sys_write
    83 000003E4 BF01000000          <1>  mov edi, 1
    84 000003E9 48BE-               <1>  mov rsi, %1
    84 000003EB [1000000000000000]  <1>
    85 000003F3 BA07000000          <1>  mov edx, %2
    86 000003F8 0F05                <1>  syscall
   605                                      
   606                                      ; Calcular la posición central para el mensaje
   607                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   608 000003FA B84E000000                  mov rax, column_cells
   609 000003FF 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   610 00000403 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   611                                      
   612                                      ; Calcular la fila central
   613 00000406 BB20000000                  mov rbx, row_cells
   614 0000040B 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   615                                      
   616                                      ; Calcular el offset en el buffer
   617 0000040E B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   618 00000413 48F7E3                      mul rbx                     ; multiplicar por la fila central
   619 00000416 4801D8                      add rax, rbx                ; añadir el offset horizontal
   620                                      
   621                                      ; Escribir "NIVEL " en la posición calculada
   622 00000419 488DB8[000A0000]            lea rdi, [board + rax]
   623 00000420 48BE-                       mov rsi, level_msg
   623 00000422 [2414000000000000] 
   624 0000042A B906000000                  mov rcx, level_msg_len
   625 0000042F F3A4                        rep movsb
   626                                      
   627                                      ; Escribir el número del nivel
   628 00000431 8A05(A4140000)              mov al, [current_level]
   629 00000437 0430                        add al, '0'                 ; convertir a ASCII
   630 00000439 8807                        mov [rdi], al
   631                                      
   632                                      ; Mostrar el board con el mensaje
   633                                      print board, board_size
    82 0000043B B801000000          <1>  mov eax, sys_write
    83 00000440 BF01000000          <1>  mov edi, 1
    84 00000445 48BE-               <1>  mov rsi, %1
    84 00000447 [000A000000000000]  <1>
    85 0000044F BA000A0000          <1>  mov edx, %2
    86 00000454 0F05                <1>  syscall
   634                                      
   635                                      ; Esperar un segundo
   636 00000456 B823000000                  mov rax, sys_nanosleep
   637 0000045B 48BF-                       mov rdi, level_display_time
   637 0000045D [2F14000000000000] 
   638 00000465 4831F6                      xor rsi, rsi
   639 00000468 0F05                        syscall
   640                                      
   641 0000046A 5D                          pop rbp
   642 0000046B C3                          ret
   643                                  
   644                                  ; Función para inicializar un tablero vacío
   645                                  init_empty_board:
   646 0000046C 56                          push rsi
   647 0000046D 57                          push rdi
   648 0000046E 51                          push rcx
   649 0000046F 50                          push rax
   650                                  
   651 00000470 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   652 00000477 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   653 0000047E B9000A0000                  mov rcx, board_template_size
   654 00000483 F3A4                        rep movsb                   ; Copiar el tablero
   655                                  
   656 00000485 58                          pop rax
   657 00000486 59                          pop rcx
   658 00000487 5F                          pop rdi
   659 00000488 5E                          pop rsi
   660 00000489 C3                          ret
   661                                  
   662                                  
   663                                  init_level:
   664                                      ; 1) Copiamos board_template en board para que quede "virgen"
   665 0000048A C605(2E150000)00            mov byte [destroyed_blocks], 0 
   666 00000491 E8D6FFFFFF                  call init_empty_board
   667 00000496 E840FFFFFF                  call display_level_number
   668 0000049B E8B5050000                  call init_enemies
   669                                      
   670 000004A0 56                          push rsi
   671 000004A1 57                          push rdi
   672 000004A2 51                          push rcx
   673 000004A3 50                          push rax
   674                                  
   675 000004A4 488D35(00000000)            lea rsi, [board_template]
   676 000004AB 488D3D(000A0000)            lea rdi, [board]
   677 000004B2 B9000A0000                  mov rcx, board_template_size
   678 000004B7 F3A4                        rep movsb                 ; Copiamos la plantilla a board
   679                                  
   680 000004B9 58                          pop rax
   681 000004BA 59                          pop rcx
   682 000004BB 5F                          pop rdi
   683 000004BC 5E                          pop rsi
   684                                  
   685 000004BD B90A000000                  mov rcx, 10
   686 000004C2 4831C0                      xor rax, rax
   687 000004C5 488D3D(D1150000)            lea rdi, [enemy_spawns_triggered]
   688 000004CC F3AA                        rep stosb      
   689                                  
   690                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   691 000004CE 803D(A4140000)01            cmp byte [current_level], 1
   692 000004D5 7431                        je .level1
   693 000004D7 803D(A4140000)02            cmp byte [current_level], 2
   694 000004DE 7454                        je .level2
   695 000004E0 803D(A4140000)03            cmp byte [current_level], 3
   696 000004E7 7477                        je .level3
   697 000004E9 803D(A4140000)04            cmp byte [current_level], 4
   698 000004F0 0F8492000000                je .level4
   699 000004F6 803D(A4140000)05            cmp byte [current_level], 5
   700 000004FD 0F84AD000000                je .level5
   701 00000503 E9D0000000                  jmp .done
   702                                  
   703                                  
   704                                  
   705                                      .level1:
   706 00000508 C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
   707 0000050F 4831C9                          xor rcx, rcx             
   708                                          .init_loop1:
   709 00000512 4883F903                            cmp rcx, level1_blocks_count
   710 00000516 0F8DBC000000                        jge .done
   711 0000051C 4889C8                              mov rax, rcx         
   712 0000051F 48C1E002                            shl rax, 2          
   713 00000523 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   714 00000529 8891[C2140000]                      mov byte [block_states + rcx], dl
   715 0000052F 48FFC1                              inc rcx
   716 00000532 EBDE                                jmp .init_loop1
   717                                  
   718                                      .level2:
   719 00000534 C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   720 0000053B 4831C9                          xor rcx, rcx             
   721                                          .init_loop2:
   722 0000053E 4883F901                            cmp rcx, level2_blocks_count
   723 00000542 0F8D90000000                        jge .done
   724 00000548 4889C8                              mov rax, rcx         
   725 0000054B 48C1E002                            shl rax, 2          
   726 0000054F 8A90[B5140000]                      mov dl, byte [level2_blocks + rax + 3]  
   727 00000555 8891[C2140000]                      mov byte [block_states + rcx], dl
   728 0000055B 48FFC1                              inc rcx
   729 0000055E EBDE                                jmp .init_loop2
   730                                      .level3:
   731 00000560 C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   732 00000567 4831C9                          xor rcx, rcx             
   733                                          .init_loop3:
   734 0000056A 4883F901                            cmp rcx, level3_blocks_count
   735 0000056E 7D68                                jge .done
   736 00000570 4889C8                              mov rax, rcx         
   737 00000573 48C1E002                            shl rax, 2          
   738 00000577 8A90[B9140000]                      mov dl, byte [level3_blocks + rax + 3]  
   739 0000057D 8891[C2140000]                      mov byte [block_states + rcx], dl
   740 00000583 48FFC1                              inc rcx
   741 00000586 EBE2                                jmp .init_loop3
   742                                  
   743                                      .level4:
   744 00000588 C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   745 0000058F 4831C9                          xor rcx, rcx             
   746                                          .init_loop4:
   747 00000592 4883F901                            cmp rcx, level4_blocks_count
   748 00000596 7D40                                jge .done
   749 00000598 4889C8                              mov rax, rcx         
   750 0000059B 48C1E002                            shl rax, 2          
   751 0000059F 8A90[BD140000]                      mov dl, byte [level4_blocks + rax + 3]  
   752 000005A5 8891[C2140000]                      mov byte [block_states + rcx], dl
   753 000005AB 48FFC1                              inc rcx
   754 000005AE EBE2                                jmp .init_loop4
   755                                  
   756                                      .level5:
   757 000005B0 C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   758 000005B7 4831C9                          xor rcx, rcx             
   759                                          .init_loop5:
   760 000005BA 4883F901                            cmp rcx, level5_blocks_count
   761 000005BE 7D18                                jge .done
   762 000005C0 4889C8                              mov rax, rcx         
   763 000005C3 48C1E002                            shl rax, 2          
   764 000005C7 8A90[C1140000]                      mov dl, byte [level5_blocks + rax + 3]  
   765 000005CD 8891[C2140000]                      mov byte [block_states + rcx], dl
   766 000005D3 48FFC1                              inc rcx
   767 000005D6 EBE2                                jmp .init_loop5
   768                                      .done:
   769 000005D8 C3                              ret
   770                                  
   771                                  
   772                                  ; Función para verificar y manejar la transición de nivel
   773                                  check_level_complete:
   774                                      ; Verificar si quedan bloques
   775 000005D9 803D(A5140000)00            cmp byte [blocks_remaining], 0
   776 000005E0 753C                        jne .not_complete
   777                                      
   778                                      ; Incrementar el nivel
   779 000005E2 FE05(A4140000)              inc byte [current_level]
   780                                      
   781                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   782 000005E8 803D(A4140000)06            cmp byte [current_level], 6
   783 000005EF 742E                        je game_win
   784                                      
   785                                      ; Reinicializar el juego para el siguiente nivel
   786 000005F1 E894FEFFFF                  call init_level
   787                                      
   788                                      ; Reinicializar la posición de la bola y la paleta
   789 000005F6 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   789 000005FE 000000             
   790 00000601 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   790 00000609 000000             
   791 0000060C C605(6F140000)00            mov byte [ball_moving], 0
   792 00000613 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   792 0000061A [38130000]         
   793                                      
   794                                      .not_complete:
   795 0000061E C3                              ret
   796                                  
   797                                      ; Nueva función para manejar la victoria del juego
   798                                  game_win:
   799                                      ; Limpiar la pantalla primero
   800                                      print clear, clear_length
    82 0000061F B801000000          <1>  mov eax, sys_write
    83 00000624 BF01000000          <1>  mov edi, 1
    84 00000629 48BE-               <1>  mov rsi, %1
    84 0000062B [1000000000000000]  <1>
    85 00000633 BA07000000          <1>  mov edx, %2
    86 00000638 0F05                <1>  syscall
   801                                      
   802                                      ; Mensaje de victoria
   803 0000063A 488B05(26150000)            mov rax, [current_score]    ; Obtener el puntaje final
   804 00000641 48BF-                       mov rdi, number_buffer      ; Convertir a string
   804 00000643 [2F15000000000000] 
   805 0000064B E8AE010000                  call number_to_string
   806                                      
   807                                      ; Definir mensaje de victoria
   808                                      section .data
   809 0000160E C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   809 00001617 616465732120C2A148-
   809 00001620 61732067616E61646F-
   809 00001629 210A0D             
   810                                          win_msg_len: equ $ - win_msg
   811 0000162C 50756E74616A652066-             score_msg: db "Puntaje final: "
   811 00001635 696E616C3A20       
   812                                          score_msg_len: equ $ - score_msg
   813                                      section .text
   814                                      
   815                                      ; Imprimir mensajes
   816                                      print win_msg, win_msg_len
    82 00000650 B801000000          <1>  mov eax, sys_write
    83 00000655 BF01000000          <1>  mov edi, 1
    84 0000065A 48BE-               <1>  mov rsi, %1
    84 0000065C [0E16000000000000]  <1>
    85 00000664 BA1E000000          <1>  mov edx, %2
    86 00000669 0F05                <1>  syscall
   817                                      print score_msg, score_msg_len
    82 0000066B B801000000          <1>  mov eax, sys_write
    83 00000670 BF01000000          <1>  mov edi, 1
    84 00000675 48BE-               <1>  mov rsi, %1
    84 00000677 [2C16000000000000]  <1>
    85 0000067F BA0F000000          <1>  mov edx, %2
    86 00000684 0F05                <1>  syscall
   818                                      print number_buffer, 20
    82 00000686 B801000000          <1>  mov eax, sys_write
    83 0000068B BF01000000          <1>  mov edi, 1
    84 00000690 48BE-               <1>  mov rsi, %1
    84 00000692 [2F15000000000000]  <1>
    85 0000069A BA14000000          <1>  mov edx, %2
    86 0000069F 0F05                <1>  syscall
   819                                      
   820                                      ; Esperar un momento antes de salir
   821 000006A1 48C70554F9FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   821 000006AA 0000               
   822 000006AC 48C70551F9FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   822 000006B5 0000               
   823                                      sleeptime
    98 000006B7 B823000000          <1>  mov eax, sys_nanosleep
    99 000006BC 48BF-               <1>  mov rdi, timespec
    99 000006BE [0000000000000000]  <1>
   100 000006C6 31F6                <1>  xor esi, esi
   101 000006C8 0F05                <1>  syscall
   824                                      
   825 000006CA E9D4080000                  jmp exit
   826                                  
   827                                  ; Función para imprimir los bloques
   828                                  ; Función modificada para imprimir bloques
   829                                  
   830                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   831                                  get_current_level_blocks:
   832 000006CF 803D(A4140000)01            cmp byte [current_level], 1
   833 000006D6 7428                        je .level1
   834 000006D8 803D(A4140000)02            cmp byte [current_level], 2
   835 000006DF 7427                        je .level2
   836 000006E1 803D(A4140000)03            cmp byte [current_level], 3
   837 000006E8 7426                        je .level3
   838 000006EA 803D(A4140000)04            cmp byte [current_level], 4
   839 000006F1 7425                        je .level4
   840 000006F3 803D(A4140000)05            cmp byte [current_level], 5
   841 000006FA 7424                        je .level5
   842                                      ; Si llegamos aquí, hay un error en el nivel
   843 000006FC 4831C0                      xor rax, rax
   844 000006FF C3                          ret
   845                                  
   846                                      .level1:
   847 00000700 488D05(A6140000)                lea rax, [level1_blocks]
   848 00000707 C3                              ret
   849                                      .level2:
   850 00000708 488D05(B2140000)                lea rax, [level2_blocks]
   851 0000070F C3                              ret
   852                                      .level3:
   853 00000710 488D05(B6140000)                lea rax, [level3_blocks]
   854 00000717 C3                              ret
   855                                      .level4:
   856 00000718 488D05(BA140000)                lea rax, [level4_blocks]
   857 0000071F C3                              ret
   858                                      .level5:
   859 00000720 488D05(BE140000)                lea rax, [level5_blocks]
   860 00000727 C3                              ret
   861                                  ; Función para obtener la cantidad de bloques del nivel actual
   862                                  get_current_level_count:
   863 00000728 803D(A4140000)01            cmp byte [current_level], 1
   864 0000072F 7428                        je .level1
   865 00000731 803D(A4140000)02            cmp byte [current_level], 2
   866 00000738 7425                        je .level2
   867 0000073A 803D(A4140000)03            cmp byte [current_level], 3
   868 00000741 7422                        je .level3
   869 00000743 803D(A4140000)04            cmp byte [current_level], 4
   870 0000074A 741F                        je .level4
   871 0000074C 803D(A4140000)05            cmp byte [current_level], 5
   872 00000753 741C                        je .level5
   873                                      ; Si llegamos aquí, hay un error en el nivel
   874 00000755 4831C0                      xor rax, rax
   875 00000758 C3                          ret
   876                                  
   877                                      .level1:
   878 00000759 B803000000                      mov rax, level1_blocks_count
   879 0000075E C3                              ret
   880                                      .level2:
   881 0000075F B801000000                      mov rax, level2_blocks_count
   882 00000764 C3                              ret
   883                                      .level3:
   884 00000765 B801000000                      mov rax, level3_blocks_count
   885 0000076A C3                              ret
   886                                      .level4:
   887 0000076B B801000000                      mov rax, level4_blocks_count
   888 00000770 C3                              ret
   889                                      .level5:
   890 00000771 B801000000                      mov rax, level5_blocks_count
   891 00000776 C3                              ret
   892                                  
   893                                  
   894                                  print_blocks:
   895 00000777 55                          push rbp
   896 00000778 4889E5                      mov rbp, rsp
   897                                      
   898                                      ; Obtener puntero a los bloques del nivel actual
   899 0000077B E84FFFFFFF                  call get_current_level_blocks
   900 00000780 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
   901                                      
   902                                      ; Obtener cantidad de bloques del nivel actual
   903 00000783 E8A0FFFFFF                  call get_current_level_count
   904 00000788 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
   905                                      
   906 0000078B 4D31E4                      xor r12, r12                  ; Índice del bloque actual
   907                                      
   908                                      .print_loop:
   909 0000078E 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
   910 00000791 7D69                            jge .end
   911                                          
   912                                          ; Verificar si el bloque está activo
   913 00000793 490FB68424-                     movzx rax, byte [block_states + r12]
   913 00000798 [C2140000]         
   914 0000079C 4885C0                          test rax, rax
   915 0000079F 7456                            jz .next_block
   916                                          
   917                                          ; Obtener posición y tipo del bloque usando r13
   918 000007A1 478A44A500                      mov r8b, [r13 + r12 * 4]      ; X position
   919 000007A6 478A4CA501                      mov r9b, [r13 + r12 * 4 + 1]  ; Y position
   920 000007AB 478A54A502                      mov r10b, [r13 + r12 * 4 + 2] ; Tipo de bloque
   921                                          
   922                                          ; El resto de la lógica de impresión permanece igual
   923 000007B0 4D0FB6C0                        movzx r8, r8b
   924 000007B4 4D0FB6C9                        movzx r9, r9b
   925 000007B8 4981C0[000A0000]                add r8, board
   926 000007BF B850000000                      mov rax, column_cells + 2
   927 000007C4 49F7E1                          mul r9
   928 000007C7 4901C0                          add r8, rax
   929                                          
   930 000007CA B906000000                      mov rcx, block_length
   931 000007CF 48BE-                           mov rsi, block_type_1
   931 000007D1 [8014000000000000] 
   932 000007D9 490FB6C2                        movzx rax, r10b
   933 000007DD 48FFC8                          dec rax
   934 000007E0 486BC006                        imul rax, block_length
   935 000007E4 4801C6                          add rsi, rax
   936                                          
   937                                      .print_block_chars:
   938 000007E7 8A06                            mov al, [rsi]
   939 000007E9 418800                          mov [r8], al
   940 000007EC 48FFC6                          inc rsi
   941 000007EF 49FFC0                          inc r8
   942 000007F2 48FFC9                          dec rcx
   943 000007F5 75F0                            jnz .print_block_chars
   944                                          
   945                                      .next_block:
   946 000007F7 49FFC4                          inc r12
   947 000007FA EB92                            jmp .print_loop
   948                                          
   949                                      .end:
   950 000007FC 5D                              pop rbp
   951 000007FD C3                              ret
   952                                  
   953                                  ; Función para convertir número a string
   954                                  ; Input: RAX = número a convertir
   955                                  ; RDI = buffer donde escribir el string
   956                                  number_to_string:
   957 000007FE 53                          push rbx
   958 000007FF 52                          push rdx
   959 00000800 56                          push rsi
   960 00000801 BB0A000000                  mov rbx, 10          ; Divisor
   961 00000806 B900000000                  mov rcx, 0          ; Contador de dígitos
   962                                      
   963                                      ; Si el número es 0, manejarlo especialmente
   964 0000080B 4885C0                      test rax, rax
   965 0000080E 7509                        jnz .convert_loop
   966 00000810 C60730                      mov byte [rdi], '0'
   967 00000813 C6470100                    mov byte [rdi + 1], 0
   968 00000817 EB20                        jmp .end
   969                                      
   970                                      .convert_loop:
   971 00000819 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
   972 0000081C 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
   973 0000081F 80C230                          add dl, '0'     ; Convertir a ASCII
   974 00000822 52                              push rdx        ; Guardar el dígito
   975 00000823 48FFC1                          inc rcx         ; Incrementar contador
   976 00000826 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
   977 00000829 75EE                            jnz .convert_loop
   978                                          
   979                                      .write_loop:
   980 0000082B 5A                              pop rdx         ; Obtener dígito
   981 0000082C 8817                            mov [rdi], dl   ; Escribir al buffer
   982 0000082E 48FFC7                          inc rdi         ; Siguiente posición
   983 00000831 48FFC9                          dec rcx         ; Decrementar contador
   984 00000834 75F5                            jnz .write_loop
   985                                          
   986 00000836 C60700                      mov byte [rdi], 0   ; Null terminator
   987                                      
   988                                      .end:
   989 00000839 5E                          pop rsi
   990 0000083A 5A                          pop rdx
   991 0000083B 5B                          pop rbx
   992 0000083C C3                          ret
   993                                  
   994                                  ; Función para imprimir los labels
   995                                  print_labels:
   996 0000083D 55                          push rbp
   997 0000083E 4889E5                      mov rbp, rsp
   998                                  
   999                                      ; Crear buffer temporal
  1000 00000841 4883EC20                    sub rsp, 32
  1001                                  
  1002                                      ; Copiar labels a buffer temporal
  1003 00000845 4889E7                      mov rdi, rsp
  1004 00000848 488D35(DB150000)            lea rsi, [score_label]
  1005 0000084F B917000000                  mov rcx, score_label_len
  1006 00000854 F3A4                        rep movsb
  1007                                  
  1008                                      ; Convertir score a string
  1009 00000856 488B05(26150000)            mov rax, [current_score]
  1010 0000085D 48BF-                       mov rdi, number_buffer
  1010 0000085F [2F15000000000000] 
  1011 00000867 E892FFFFFF                  call number_to_string
  1012                                  
  1013                                      ; Calcular longitud del número
  1014 0000086C B900000000                  mov rcx, 0
  1015 00000871 48BF-                       mov rdi, number_buffer
  1015 00000873 [2F15000000000000] 
  1016                                      .count_loop:
  1017 0000087B 803C0F00                        cmp byte [rdi + rcx], 0
  1018 0000087F 7405                            je .count_done
  1019 00000881 48FFC1                          inc rcx
  1020 00000884 EBF5                            jmp .count_loop
  1021                                      .count_done:
  1022                                  
  1023                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1024 00000886 4889E7                      mov rdi, rsp
  1025 00000889 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1026 0000088D BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1027 00000892 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1028                                      .pad_loop:
  1029 00000895 4885F6                          test rsi, rsi
  1030 00000898 740B                            jz .pad_done
  1031 0000089A C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1032 0000089D 48FFC7                          inc rdi
  1033 000008A0 48FFCE                          dec rsi
  1034 000008A3 EBF0                            jmp .pad_loop
  1035                                      .pad_done:
  1036                                  
  1037                                      ; Copiar el número
  1038 000008A5 48BE-                       mov rsi, number_buffer
  1038 000008A7 [2F15000000000000] 
  1039 000008AF F3A4                        rep movsb
  1040                                  
  1041                                      ; Imprimir el buffer completo
  1042                                      print rsp, score_label_len
    82 000008B1 B801000000          <1>  mov eax, sys_write
    83 000008B6 BF01000000          <1>  mov edi, 1
    84 000008BB 4889E6              <1>  mov rsi, %1
    85 000008BE BA17000000          <1>  mov edx, %2
    86 000008C3 0F05                <1>  syscall
  1043                                  
  1044                                      ; Repetir proceso para bloques destruidos
  1045 000008C5 4889E7                      mov rdi, rsp
  1046 000008C8 488D35(F2150000)            lea rsi, [blocks_label]
  1047 000008CF B91B000000                  mov rcx, blocks_label_len
  1048 000008D4 F3A4                        rep movsb
  1049                                  
  1050                                      ; Verificar que el `[` esté en su posición correcta
  1051 000008D6 4889E7                      mov rdi, rsp
  1052 000008D9 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1053 000008DD C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1054                                  
  1055                                      ; Convertir bloques destruidos a string
  1056 000008E0 480FB605(2E150000)          movzx rax, byte [destroyed_blocks]
  1057 000008E8 48BF-                       mov rdi, number_buffer
  1057 000008EA [2F15000000000000] 
  1058 000008F2 E807FFFFFF                  call number_to_string
  1059                                  
  1060                                      ; Calcular longitud del número
  1061 000008F7 B900000000                  mov rcx, 0
  1062 000008FC 48BF-                       mov rdi, number_buffer
  1062 000008FE [2F15000000000000] 
  1063                                      .count_loop2:
  1064 00000906 803C0F00                        cmp byte [rdi + rcx], 0
  1065 0000090A 7405                            je .count_done2
  1066 0000090C 48FFC1                          inc rcx
  1067 0000090F EBF5                            jmp .count_loop2
  1068                                      .count_done2:
  1069                                  
  1070                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1071 00000911 4889E7                      mov rdi, rsp
  1072 00000914 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1073 00000918 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1074 0000091D 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1075                                      .pad_loop2:
  1076 00000920 4885F6                          test rsi, rsi
  1077 00000923 740B                            jz .pad_done2
  1078 00000925 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1079 00000928 48FFC7                          inc rdi
  1080 0000092B 48FFCE                          dec rsi
  1081 0000092E EBF0                            jmp .pad_loop2
  1082                                      .pad_done2:
  1083                                  
  1084                                      ; Copiar el número
  1085 00000930 48BE-                       mov rsi, number_buffer
  1085 00000932 [2F15000000000000] 
  1086 0000093A F3A4                        rep movsb
  1087                                  
  1088                                      ; Imprimir el buffer completo
  1089                                      print rsp, blocks_label_len
    82 0000093C B801000000          <1>  mov eax, sys_write
    83 00000941 BF01000000          <1>  mov edi, 1
    84 00000946 4889E6              <1>  mov rsi, %1
    85 00000949 BA1B000000          <1>  mov edx, %2
    86 0000094E 0F05                <1>  syscall
  1090                                  
  1091                                      ; Restaurar stack
  1092 00000950 4883C420                    add rsp, 32
  1093 00000954 5D                          pop rbp
  1094 00000955 C3                          ret
  1095                                  
  1096                                  
  1097                                  ; Función modificada para detectar colisión
  1098                                  ; Función mejorada para detectar colisión y manejar la física
  1099                                  ; Función corregida para manejar colisiones con bloques completos
  1100                                  ;---------------------------------------------------------
  1101                                  ; check_block_collision:
  1102                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1103                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1104                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1105                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1106                                  ;   retorna 0.
  1107                                  ;---------------------------------------------------------
  1108                                  ;--------------------------------------
  1109                                  ; check_block_collision
  1110                                  ;--------------------------------------
  1111                                  ; Actualizar check_block_collision para usar el nivel actual
  1112                                  check_block_collision:
  1113 00000956 55                          push rbp
  1114 00000957 4889E5                      mov rbp, rsp
  1115                                  
  1116 0000095A 418A02                      mov al, [r10]
  1117                                  
  1118                                      ; Verificación de caracteres igual que antes...
  1119 0000095D 3C55                        cmp al, 'U'  
  1120 0000095F 7419                        je .possible
  1121 00000961 3C4F                        cmp al, 'O'  
  1122 00000963 7415                        je .possible
  1123 00000965 3C44                        cmp al, 'D'  
  1124 00000967 7411                        je .possible
  1125 00000969 3C4C                        cmp al, 'L'  
  1126 0000096B 740D                        je .possible
  1127 0000096D 3C56                        cmp al, 'V'  
  1128 0000096F 7409                        je .possible
  1129 00000971 3C38                        cmp al, '8'  
  1130 00000973 7405                        je .possible
  1131                                  
  1132 00000975 4831C0                      xor rax, rax
  1133 00000978 5D                          pop rbp
  1134 00000979 C3                          ret
  1135                                  
  1136                                      .possible:
  1137 0000097A 53                              push rbx
  1138 0000097B 57                              push rdi
  1139 0000097C 56                              push rsi
  1140 0000097D 4154                            push r12
  1141                                  
  1142                                          ; Obtener puntero a los bloques del nivel actual
  1143 0000097F E84BFDFFFF                      call get_current_level_blocks
  1144 00000984 4989C5                          mov r13, rax                  ; Guardar puntero a los bloques
  1145                                          
  1146                                          ; Obtener cantidad de bloques del nivel actual
  1147 00000987 E89CFDFFFF                      call get_current_level_count
  1148 0000098C 4989C6                          mov r14, rax                  ; Guardar cantidad de bloques
  1149                                  
  1150 0000098F 4D31E4                          xor r12, r12
  1151                                      .find_block_loop:
  1152 00000992 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1153 00000995 0F8DB0000000                    jge .no_block_found
  1154                                  
  1155                                          ; El resto de la lógica de verificación de colisiones...
  1156 0000099B 418A9C24[C2140000]              mov bl, [block_states + r12]
  1157 000009A3 84DB                            test bl, bl
  1158 000009A5 0F8498000000                    jz .next_block
  1159                                  
  1160                                          ; Usar r13 para acceder a los bloques del nivel actual
  1161 000009AB 4C89E8                          mov rax, r13
  1162 000009AE 4D6BE404                        imul r12, 4
  1163 000009B2 4C01E0                          add rax, r12
  1164 000009B5 8A10                            mov dl, [rax]       ; x
  1165 000009B7 8A4801                          mov cl, [rax+1]     ; y
  1166                                  
  1167                                          ; Revertir r12
  1168 000009BA 4D89E4                          mov r12, r12
  1169 000009BD 49C1EC02                        shr r12, 2
  1170                                  
  1171                                          ; La misma lógica de detección de colisiones...
  1172 000009C1 488D3D(000A0000)                lea rdi, [board]
  1173 000009C8 4831C0                          xor rax, rax
  1174 000009CB B850000000                      mov rax, column_cells + 2
  1175 000009D0 480FB6C9                        movzx rcx, cl
  1176 000009D4 480FAFC1                        imul rax, rcx
  1177 000009D8 4801C7                          add rdi, rax
  1178 000009DB 480FB6C2                        movzx rax, dl
  1179 000009DF 4801C7                          add rdi, rax
  1180                                  
  1181 000009E2 4939FA                          cmp r10, rdi
  1182 000009E5 725C                            jb .next_block
  1183 000009E7 488D5F06                        lea rbx, [rdi + 6]
  1184 000009EB 4939DA                          cmp r10, rbx
  1185 000009EE 7353                            jae .next_block
  1186                                  
  1187                                          ; Manejo de colisión igual que antes...
  1188 000009F0 41FE8C24[C2140000]              dec byte [block_states + r12]
  1189 000009F8 418A9C24[C2140000]              mov bl, [block_states + r12]
  1190 00000A00 84DB                            test bl, bl
  1191 00000A02 7533                            jnz .still_alive
  1192                                  
  1193 00000A04 B906000000                      mov rcx, block_length
  1194                                      .erase_block_chars:
  1195 00000A09 C60720                          mov byte [rdi], char_space
  1196 00000A0C 48FFC7                          inc rdi
  1197 00000A0F E2F8                            loop .erase_block_chars
  1198                                  
  1199 00000A11 FE0D(A5140000)                  dec byte [blocks_remaining]
  1200 00000A17 FE05(2E150000)                  inc byte [destroyed_blocks]     ; Incrementar contador de bloques destruidos
  1201                                      
  1202                                          ; Calcular puntos basado en la durabilidad original del bloque
  1203 00000A1D 4C89E0                          mov rax, r12                    ; Índice del bloque
  1204 00000A20 486BC004                        imul rax, 4                     ; Multiplicar por 4 (tamaño de cada entrada)
  1205 00000A24 4C01E8                          add rax, r13                    ; Agregar base de los bloques
  1206 00000A27 480FB64002                      movzx rax, byte [rax + 2]       ; Obtener tipo de bloque (durabilidad original)
  1207 00000A2C 486BC00A                        imul rax, 10                    ; Multiplicar por 10
  1208 00000A30 480105(26150000)                add [current_score], rax        ; Agregar al score total
  1209                                  
  1210                                      .still_alive:
  1211 00000A37 B801000000                      mov rax, 1
  1212 00000A3C 415C                            pop r12
  1213 00000A3E 5E                              pop rsi
  1214 00000A3F 5F                              pop rdi
  1215 00000A40 5B                              pop rbx
  1216 00000A41 5D                              pop rbp
  1217 00000A42 C3                              ret
  1218                                  
  1219                                      .next_block:
  1220 00000A43 49FFC4                          inc r12
  1221 00000A46 E947FFFFFF                      jmp .find_block_loop
  1222                                  
  1223                                      .no_block_found:
  1224 00000A4B 4831C0                          xor rax, rax
  1225 00000A4E 415C                            pop r12
  1226 00000A50 5E                              pop rsi
  1227 00000A51 5F                              pop rdi
  1228 00000A52 5B                              pop rbx
  1229 00000A53 5D                              pop rbp
  1230 00000A54 C3                              ret
  1231                                  
  1232                                  init_enemies:
  1233 00000A55 55                          push rbp
  1234 00000A56 4889E5                      mov rbp, rsp
  1235                                      ; Reiniciar contadores de movimiento
  1236 00000A59 C605(71150000)00            mov byte [enemy_move_total], 0
  1237 00000A60 C605(72150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1238                                      ; Limpiar estado previo de enemigos
  1239 00000A67 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1240 00000A6C 488D3D(48150000)            lea rdi, [enemies]
  1241 00000A73 30C0                        xor al, al
  1242 00000A75 F3AA                        rep stosb ; Limpiar datos de enemigos
  1243                                      
  1244                                      ; Marcar todos los enemigos como inactivos
  1245 00000A77 488D3D(D1150000)            lea rdi, [enemy_spawns_triggered]
  1246 00000A7E 30C0                        xor al, al
  1247 00000A80 B90A000000                  mov rcx, 10
  1248 00000A85 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1249                                  
  1250 00000A87 5D                          pop rbp
  1251 00000A88 C3                          ret
  1252                                  
  1253                                  
  1254                                  ; Función para mover enemigos
  1255                                  move_enemies:
  1256 00000A89 55                          push rbp
  1257 00000A8A 4889E5                      mov rbp, rsp
  1258                                      
  1259                                      ; Incrementar contador de movimiento
  1260 00000A8D FE05(6F150000)              inc byte [enemy_move_counter]
  1261 00000A93 480FB605(6F150000)          movzx rax, byte [enemy_move_counter]
  1262 00000A9B 3A05(70150000)              cmp al, [enemy_move_delay]
  1263 00000AA1 0F85AA010000                jne .end
  1264                                      
  1265                                      ; Resetear contador
  1266 00000AA7 C605(6F150000)00            mov byte [enemy_move_counter], 0
  1267                                      
  1268 00000AAE 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1269                                      
  1270                                      .enemy_loop:
  1271 00000AB1 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1272 00000AB5 0F8D96010000                    jge .end
  1273                                          
  1274                                          ; Calcular offset del enemigo actual
  1275 00000ABB 4C89E0                          mov rax, r12
  1276 00000ABE 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1277 00000AC2 488DB0[48150000]                lea rsi, [enemies + rax]
  1278                                          
  1279                                          ; Verificar si el enemigo está activo
  1280 00000AC9 807E0201                        cmp byte [rsi + 2], 1
  1281 00000ACD 0F8576010000                    jne .next_enemy
  1282                                          
  1283                                          ; Obtener posición actual
  1284 00000AD3 4C0FB606                        movzx r8, byte [rsi]            ; X
  1285 00000AD7 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1286                                          
  1287                                          ; Limpiar posición actual antes de mover
  1288 00000ADC 4150                            push r8
  1289 00000ADE 4151                            push r9
  1290 00000AE0 B84E000000                      mov rax, column_cells
  1291 00000AE5 4883C002                        add rax, 2
  1292 00000AE9 49F7E1                          mul r9
  1293 00000AEC 4C01C0                          add rax, r8
  1294 00000AEF 488DB8[000A0000]                lea rdi, [board + rax]
  1295 00000AF6 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1296 00000AF9 4159                            pop r9
  1297 00000AFB 4158                            pop r8
  1298                                  
  1299                                          ; Determinar comportamiento basado en índice
  1300 00000AFD 4C89E0                          mov rax, r12
  1301 00000B00 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1302 00000B04 4885C0                          test rax, rax
  1303 00000B07 7402                            jz .chase_ball
  1304 00000B09 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1305                                          
  1306                                          ; Perseguir bola (comportamiento original)
  1307                                      .chase_ball:
  1308 00000B0B 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1309 00000B12 4D39D0                          cmp r8, r10
  1310 00000B15 0F8F96000000                    jg .move_left
  1311 00000B1B 0F8C95000000                    jl .move_right
  1312                                          
  1313 00000B21 4C8B15(57140000)                mov r10, [ball_y_pos]
  1314 00000B28 4D39D1                          cmp r9, r10
  1315 00000B2B 0F8F8A000000                    jg .move_up
  1316 00000B31 0F8C89000000                    jl .move_down
  1317 00000B37 E9A5000000                      jmp .check_collision
  1318                                          
  1319                                      .chase_paddle:
  1320                                          ; Obtener la posición X actual de la paleta
  1321 00000B3C 4C8B15(3F140000)                mov r10, [pallet_position]
  1322 00000B43 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1323                                          
  1324                                          ; Calcular la posición X real de la paleta
  1325 00000B4A 4C89D0                          mov rax, r10
  1326 00000B4D BB4E000000                      mov rbx, column_cells
  1327 00000B52 4883C302                        add rbx, 2                  ; Añadir newline chars
  1328 00000B56 4831D2                          xor rdx, rdx
  1329 00000B59 48F7F3                          div rbx                     ; rax = y, rdx = x
  1330                                          
  1331                                          ; rdx ahora contiene la posición X de la paleta
  1332                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1333 00000B5C 488B0D(47140000)                mov rcx, [pallet_size]
  1334 00000B63 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1335 00000B66 4801CA                          add rdx, rcx
  1336                                          
  1337                                          ; Comparar con posición X del enemigo y mover gradualmente
  1338 00000B69 4939D0                          cmp r8, rdx
  1339 00000B6C 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1340 00000B6E 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1341 00000B70 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1342                                  
  1343                                      .check_y_paddle:
  1344                                          ; La Y de la paleta siempre es row_cells - 2
  1345 00000B72 41BA20000000                    mov r10, row_cells
  1346 00000B78 4983EA02                        sub r10, 2
  1347                                          
  1348                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1349 00000B7C 4D39D1                          cmp r9, r10
  1350 00000B7F 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1351 00000B81 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1352 00000B83 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1353                                          
  1354                                      .no_movement:
  1355 00000B85 EB5A                            jmp .check_collision
  1356                                  
  1357                                      ; También agregar una nueva sección para el movimiento suave
  1358                                      .smooth_transition:
  1359                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1360 00000B87 8A05(72150000)                  mov al, [enemy_target]
  1361 00000B8D 84C0                            test al, al
  1362 00000B8F 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1363                                          
  1364                                          ; Verificar distancia en X
  1365 00000B91 4989D2                          mov r10, rdx              ; Posición X objetivo
  1366 00000B94 4D29C2                          sub r10, r8               ; Calcular diferencia
  1367 00000B97 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1368 00000B9B 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1369 00000B9D 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1370 00000BA1 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1371 00000BA3 EB3C                            jmp .check_collision
  1372                                          
  1373                                      .limit_right_movement:
  1374 00000BA5 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1375 00000BA9 EB36                            jmp .check_collision
  1376                                          
  1377                                      .limit_left_movement:
  1378 00000BAB 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1379 00000BAF EB30                            jmp .check_collision
  1380                                      .move_left:
  1381 00000BB1 49FFC8                          dec r8
  1382 00000BB4 EB0F                            jmp .check_vertical
  1383                                          
  1384                                      .move_right:
  1385 00000BB6 49FFC0                          inc r8
  1386 00000BB9 EB0A                            jmp .check_vertical
  1387                                          
  1388                                      .move_up:
  1389 00000BBB 49FFC9                          dec r9
  1390 00000BBE EB21                            jmp .check_collision
  1391                                          
  1392                                      .move_down:
  1393 00000BC0 49FFC1                          inc r9
  1394 00000BC3 EB1C                            jmp .check_collision
  1395                                          
  1396                                      .check_vertical:
  1397 00000BC5 8A05(72150000)                  mov al, [enemy_target]
  1398 00000BCB 84C0                            test al, al
  1399 00000BCD 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1400 00000BD3 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1401 00000BDA 4D39D1                          cmp r9, r10
  1402 00000BDD 7FDC                            jg .move_up
  1403 00000BDF 7CDF                            jl .move_down
  1404                                          
  1405                                      .check_collision:
  1406                                          ; Verificar colisión con bordes
  1407 00000BE1 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1408 00000BE5 7E62                            jle .next_enemy
  1409 00000BE7 4983F84E                        cmp r8, column_cells
  1410 00000BEB 7D5C                            jge .next_enemy
  1411 00000BED 4983F901                        cmp r9, 1                       ; Borde superior
  1412 00000BF1 7E56                            jle .next_enemy
  1413 00000BF3 4983F920                        cmp r9, row_cells
  1414 00000BF7 7D50                            jge .next_enemy
  1415                                          
  1416                                          ; Verificar colisión con bloques antes de moverse
  1417 00000BF9 4150                            push r8
  1418 00000BFB 4151                            push r9
  1419 00000BFD 4152                            push r10
  1420                                          
  1421                                          ; Calcular posición en el tablero para verificar
  1422 00000BFF B84E000000                      mov rax, column_cells
  1423 00000C04 4883C002                        add rax, 2
  1424 00000C08 49F7E1                          mul r9
  1425 00000C0B 4C01C0                          add rax, r8
  1426 00000C0E 4C8D90[000A0000]                lea r10, [board + rax]
  1427                                          
  1428                                          ; Verificar si hay un bloque en la nueva posición
  1429 00000C15 418A02                          mov al, [r10]
  1430 00000C18 3C55                            cmp al, 'U'
  1431 00000C1A 7427                            je .invalid_move
  1432 00000C1C 3C4F                            cmp al, 'O'
  1433 00000C1E 7423                            je .invalid_move
  1434 00000C20 3C44                            cmp al, 'D'
  1435 00000C22 741F                            je .invalid_move
  1436 00000C24 3C4C                            cmp al, 'L'
  1437 00000C26 741B                            je .invalid_move
  1438 00000C28 3C56                            cmp al, 'V'
  1439 00000C2A 7417                            je .invalid_move
  1440 00000C2C 3C38                            cmp al, '8'
  1441 00000C2E 7413                            je .invalid_move
  1442 00000C30 3C58                            cmp al, 'X'
  1443 00000C32 740F                            je .invalid_move
  1444                                          
  1445 00000C34 415A                            pop r10
  1446 00000C36 4159                            pop r9
  1447 00000C38 4158                            pop r8
  1448                                          
  1449                                          ; Guardar nueva posición si es válida
  1450 00000C3A 448806                          mov [rsi], r8b
  1451 00000C3D 44884E01                        mov [rsi + 1], r9b
  1452 00000C41 EB06                            jmp .next_enemy
  1453                                          
  1454                                      .invalid_move:
  1455 00000C43 415A                            pop r10
  1456 00000C45 4159                            pop r9
  1457 00000C47 4158                            pop r8
  1458                                          
  1459                                      .next_enemy:
  1460 00000C49 49FFC4                          inc r12
  1461 00000C4C E960FEFFFF                      jmp .enemy_loop
  1462                                          
  1463                                      .end:
  1464 00000C51 5D                              pop rbp
  1465 00000C52 C3                              ret
  1466                                  
  1467                                  get_current_spawn_points:
  1468 00000C53 55                          push rbp
  1469 00000C54 4889E5                      mov rbp, rsp
  1470                                      
  1471 00000C57 480FB605(A4140000)          movzx rax, byte [current_level]
  1472 00000C5F 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1473 00000C62 488B04C5[A6150000]          mov rax, [spawn_points_table + rax * 8]
  1474                                      
  1475 00000C6A 5D                          pop rbp
  1476 00000C6B C3                          ret
  1477                                  
  1478                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1479                                  check_enemy_spawn:
  1480 00000C6C 55                          push rbp
  1481 00000C6D 4889E5                      mov rbp, rsp
  1482                                      
  1483                                      ; Obtener spawn points del nivel actual
  1484 00000C70 E8DEFFFFFF                  call get_current_spawn_points
  1485 00000C75 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1486                                      
  1487                                      ; Obtener cantidad de bloques destruidos
  1488 00000C78 4C0FB62D(2E150000)          movzx r13, byte [destroyed_blocks]
  1489                                      
  1490                                      ; Verificar cada punto de spawn
  1491 00000C80 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1492                                      
  1493                                      .check_loop:
  1494 00000C83 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1495 00000C87 7D4B                            jge .end
  1496                                          
  1497                                          ; Verificar si este spawn point ya fue usado
  1498 00000C89 80B9[D1150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1499 00000C90 743D                            je .next_enemy
  1500                                          
  1501                                          ; Verificar si este enemigo ya está activo
  1502 00000C92 4889C8                          mov rax, rcx
  1503 00000C95 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1504 00000C99 488DB0[48150000]                lea rsi, [enemies + rax]
  1505 00000CA0 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1506 00000CA4 7429                            je .next_enemy
  1507                                          
  1508                                          ; Verificar si debemos spawnear este enemigo
  1509 00000CA6 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1510 00000CAB 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1511 00000CAE 751F                            jne .next_enemy
  1512                                          
  1513                                          ; Marcar este spawn point como usado
  1514 00000CB0 C681[D1150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1515                                          
  1516                                          ; Spawner nuevo enemigo
  1517 00000CB7 C60628                          mov byte [rsi], 40             ; X inicial
  1518 00000CBA C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1519 00000CBE C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1520                                          
  1521                                          ; Inicializar comportamiento
  1522 00000CC2 4889C8                          mov rax, rcx
  1523 00000CC5 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1524 00000CC9 8805(D0150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1525                                          
  1526                                      .next_enemy:
  1527 00000CCF 48FFC1                          inc rcx
  1528 00000CD2 EBAF                            jmp .check_loop
  1529                                          
  1530                                      .end:
  1531 00000CD4 5D                              pop rbp
  1532 00000CD5 C3                              ret
  1533                                  
  1534                                  
  1535                                  ; Función para dibujar enemigos
  1536                                  print_enemies:
  1537 00000CD6 55                          push rbp
  1538 00000CD7 4889E5                      mov rbp, rsp
  1539                                      
  1540 00000CDA 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1541                                      
  1542                                      .print_loop:
  1543 00000CDD 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1544 00000CE1 7D4B                            jge .end
  1545                                          
  1546                                          ; Calcular offset del enemigo actual
  1547 00000CE3 4C89E0                          mov rax, r12
  1548 00000CE6 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1549 00000CEA 488DB0[48150000]                lea rsi, [enemies + rax]
  1550                                          
  1551                                          ; Verificar si el enemigo está activo
  1552 00000CF1 807E0201                        cmp byte [rsi + 2], 1
  1553 00000CF5 7532                            jne .next_enemy
  1554                                          
  1555                                          ; Calcular posición en el tablero
  1556 00000CF7 4C0FB606                        movzx r8, byte [rsi]            ; X
  1557 00000CFB 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1558                                          
  1559                                          ; Calcular offset en el tablero
  1560 00000D00 B84E000000                      mov rax, column_cells
  1561 00000D05 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1562 00000D09 49F7E1                          mul r9
  1563 00000D0C 4C01C0                          add rax, r8
  1564 00000D0F 488DB8[000A0000]                lea rdi, [board + rax]
  1565                                          
  1566                                          ; Obtener carácter del enemigo según el nivel
  1567 00000D16 480FB605(A4140000)              movzx rax, byte [current_level]
  1568 00000D1E 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1569 00000D21 8A80[43150000]                  mov al, [enemy_chars + rax]
  1570                                          
  1571                                          ; Dibujar enemigo
  1572 00000D27 8807                            mov [rdi], al
  1573                                          
  1574                                      .next_enemy:
  1575 00000D29 49FFC4                          inc r12
  1576 00000D2C EBAF                            jmp .print_loop
  1577                                          
  1578                                      .end:
  1579 00000D2E 5D                              pop rbp
  1580 00000D2F C3                              ret
  1581                                  
  1582                                  ; Función para verificar colisión con enemigos
  1583                                  ; Función para verificar colisión con enemigos
  1584                                  check_enemy_collision:
  1585 00000D30 55                          push rbp
  1586 00000D31 4889E5                      mov rbp, rsp
  1587                                      
  1588 00000D34 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1589 00000D37 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1590                                      
  1591                                      .check_loop:
  1592 00000D3A 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1593 00000D3E 0F8DE9000000                    jge .end
  1594                                          
  1595                                          ; Calcular offset del enemigo actual
  1596 00000D44 4C89E1                          mov rcx, r12
  1597 00000D47 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1598 00000D4B 488DB1[48150000]                lea rsi, [enemies + rcx]
  1599                                          
  1600                                          ; Verificar si el enemigo está activo
  1601 00000D52 807E0201                        cmp byte [rsi + 2], 1
  1602 00000D56 0F85C9000000                    jne .next_enemy
  1603                                          
  1604                                          ; Verificar colisión con la bola
  1605 00000D5C 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1606 00000D60 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1607                                          
  1608                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1609 00000D65 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1610 00000D6C 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1611                                          
  1612                                          ; Comprobar colisión vertical (misma columna)
  1613 00000D73 4D39C2                          cmp r10, r8
  1614 00000D76 7525                            jne .check_horizontal
  1615 00000D78 4D29CB                          sub r11, r9
  1616 00000D7B 4983FB01                        cmp r11, 1
  1617 00000D7F 7F1C                            jg .check_horizontal
  1618 00000D81 4983FBFF                        cmp r11, -1
  1619 00000D85 7C16                            jl .check_horizontal
  1620                                          
  1621                                          ; Colisión vertical detectada
  1622 00000D87 E8A3000000                      call destroy_enemy
  1623 00000D8C 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1624 00000D93 B801000000                      mov rax, 1
  1625 00000D98 E990000000                      jmp .end
  1626                                          
  1627                                      .check_horizontal:
  1628                                          ; Comprobar colisión horizontal (misma fila)
  1629 00000D9D 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1630 00000DA4 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1631 00000DAB 4D39CB                          cmp r11, r9
  1632 00000DAE 7522                            jne .check_paddle
  1633 00000DB0 4D29C2                          sub r10, r8
  1634 00000DB3 4983FA01                        cmp r10, 1
  1635 00000DB7 7F19                            jg .check_paddle
  1636 00000DB9 4983FAFF                        cmp r10, -1
  1637 00000DBD 7C13                            jl .check_paddle
  1638                                          
  1639                                          ; Colisión horizontal detectada
  1640 00000DBF E86B000000                      call destroy_enemy
  1641 00000DC4 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1642 00000DCB B801000000                      mov rax, 1
  1643 00000DD0 EB5B                            jmp .end
  1644                                          
  1645                                      .check_paddle:
  1646                                          ; Verificar colisión con la paleta
  1647 00000DD2 4C8B15(3F140000)                mov r10, [pallet_position]
  1648 00000DD9 4981EA[000A0000]                sub r10, board
  1649 00000DE0 4C89D0                          mov rax, r10
  1650 00000DE3 41BB4E000000                    mov r11, column_cells
  1651 00000DE9 4983C302                        add r11, 2
  1652 00000DED 4831D2                          xor rdx, rdx
  1653 00000DF0 49F7F3                          div r11                     ; División para obtener la posición Y
  1654 00000DF3 4989D3                          mov r11, rdx               ; X de la paleta en r11
  1655                                          
  1656 00000DF6 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  1657                                          
  1658                                          ; Verificar si el enemigo está en la misma fila que la paleta
  1659 00000DFD 41BD20000000                    mov r13, row_cells
  1660 00000E03 4983ED02                        sub r13, 2                 ; Y de la paleta
  1661 00000E07 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  1662 00000E0A 7519                            jne .next_enemy
  1663                                          
  1664                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  1665 00000E0C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  1666 00000E0F 7C14                            jl .next_enemy
  1667                                          
  1668 00000E11 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  1669 00000E14 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  1670 00000E17 7F0C                            jg .next_enemy
  1671                                          
  1672                                          ; Si llegamos aquí, hay colisión con la paleta
  1673 00000E19 E811000000                      call destroy_enemy        ; Destruir el enemigo
  1674 00000E1E B801000000                      mov rax, 1                ; Indicar que hubo colisión
  1675 00000E23 EB08                            jmp .end
  1676                                          
  1677                                      .next_enemy:
  1678 00000E25 49FFC4                          inc r12
  1679 00000E28 E90DFFFFFF                      jmp .check_loop
  1680                                          
  1681                                      .end:
  1682 00000E2D 5D                              pop rbp
  1683 00000E2E C3                              ret
  1684                                  
  1685                                  ; Función para destruir un enemigo
  1686                                  destroy_enemy:
  1687                                      ; Desactivar enemigo
  1688 00000E2F C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  1689                                  
  1690                                      ; Sumar puntos por destruir enemigo
  1691 00000E33 488B05(67150000)            mov rax, [enemy_points]
  1692 00000E3A 480105(26150000)            add [current_score], rax
  1693                                  
  1694                                      ; No tocar bloques destruidos aquí
  1695 00000E41 C3                          ret
  1696                                  
  1697                                  
  1698                                  _start:
  1699 00000E42 E8E4F2FFFF              	call canonical_off
  1700 00000E47 E8E4000000              	call start_screen
  1701 00000E4C E839F6FFFF                  call init_level
  1702 00000E51 E8FFFBFFFF                  call init_enemies
  1703 00000E56 EB00                    	jmp .main_loop
  1704                                  	
  1705                                  
  1706                                  	.main_loop:
  1707 00000E58 E8E0F9FFFF                      call print_labels
  1708 00000E5D E8D5F3FFFF              		call print_pallet
  1709 00000E62 E860F4FFFF                      call move_ball
  1710 00000E67 E80BF9FFFF                      call print_blocks
  1711 00000E6C E868F7FFFF                      call check_level_complete
  1712 00000E71 E8F6FDFFFF                      call check_enemy_spawn
  1713 00000E76 E80EFCFFFF                      call move_enemies
  1714 00000E7B E8B0FEFFFF                      call check_enemy_collision
  1715 00000E80 E851FEFFFF                      call print_enemies
  1716 00000E85 E885F3FFFF              		call print_ball
  1717 00000E8A E84EF3FFFF                      call print_lives
  1718                                  		print board, board_size				
    82 00000E8F B801000000          <1>  mov eax, sys_write
    83 00000E94 BF01000000          <1>  mov edi, 1
    84 00000E99 48BE-               <1>  mov rsi, %1
    84 00000E9B [000A000000000000]  <1>
    85 00000EA3 BA000A0000          <1>  mov edx, %2
    86 00000EA8 0F05                <1>  syscall
  1719                                  		;setnonblocking	
  1720                                  	.read_more:	
  1721                                  		getchar	
    90 00000EAA B800000000          <1>  mov rax, sys_read
    91 00000EAF BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000EB4 48BE-               <1>  mov rsi, input_char
    92 00000EB6 [0000000000000000]  <1>
    93 00000EBE BA01000000          <1>  mov rdx, 1
    94 00000EC3 0F05                <1>  syscall
  1722                                  		
  1723 00000EC5 4883F801                		cmp rax, 1
  1724 00000EC9 7532                        	jne .done
  1725                                  		
  1726 00000ECB 8A05(00000000)          		mov al,[input_char]
  1727                                  
  1728 00000ED1 3C61                    		cmp al, 'a'
  1729 00000ED3 750E                    	    jne .not_left
  1730 00000ED5 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1731 00000EDC E871F3FFFF              		call move_pallet
  1732 00000EE1 EB1A                    	    jmp .done
  1733                                  		
  1734                                  		.not_left:
  1735 00000EE3 3C64                    		 	cmp al, 'd'
  1736 00000EE5 750C                    	    	jne .not_right
  1737 00000EE7 BF01000000              			mov rdi, right_direction
  1738 00000EEC E861F3FFFF              	    	call move_pallet
  1739 00000EF1 EB0A                        		jmp .done		
  1740                                  
  1741                                  		.not_right:
  1742                                  
  1743 00000EF3 3C71                        		cmp al, 'q'
  1744 00000EF5 0F84A8000000                		je exit
  1745                                  
  1746 00000EFB EBAD                    			jmp .read_more
  1747                                  		
  1748                                  		.done:	
  1749                                  			;unsetnonblocking		
  1750                                  			sleeptime	
    98 00000EFD B823000000          <1>  mov eax, sys_nanosleep
    99 00000F02 48BF-               <1>  mov rdi, timespec
    99 00000F04 [0000000000000000]  <1>
   100 00000F0C 31F6                <1>  xor esi, esi
   101 00000F0E 0F05                <1>  syscall
  1751                                  			print clear, clear_length
    82 00000F10 B801000000          <1>  mov eax, sys_write
    83 00000F15 BF01000000          <1>  mov edi, 1
    84 00000F1A 48BE-               <1>  mov rsi, %1
    84 00000F1C [1000000000000000]  <1>
    85 00000F24 BA07000000          <1>  mov edx, %2
    86 00000F29 0F05                <1>  syscall
  1752 00000F2B E928FFFFFF                  		jmp .main_loop
  1753                                  
  1754                                  
  1755                                  
  1756                                  start_screen:
  1757                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00000F30 B801000000          <1>  mov eax, sys_write
    83 00000F35 BF01000000          <1>  mov edi, 1
    84 00000F3A 48BE-               <1>  mov rsi, %1
    84 00000F3C [1000000000000000]  <1>
    85 00000F44 BA07000000          <1>  mov edx, %2
    86 00000F49 0F05                <1>  syscall
  1758                                      print msg1, msg1_length
    82 00000F4B B801000000          <1>  mov eax, sys_write
    83 00000F50 BF01000000          <1>  mov edi, 1
    84 00000F55 48BE-               <1>  mov rsi, %1
    84 00000F57 [1700000000000000]  <1>
    85 00000F5F BA14010000          <1>  mov edx, %2
    86 00000F64 0F05                <1>  syscall
  1759                                      
  1760                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1761                                          getchar                 ; Esperamos una tecla
    90 00000F66 B800000000          <1>  mov rax, sys_read
    91 00000F6B BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000F70 48BE-               <1>  mov rsi, input_char
    92 00000F72 [0000000000000000]  <1>
    93 00000F7A BA01000000          <1>  mov rdx, 1
    94 00000F7F 0F05                <1>  syscall
  1762 00000F81 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1763 00000F85 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1764                                          
  1765                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00000F87 B801000000          <1>  mov eax, sys_write
    83 00000F8C BF01000000          <1>  mov edi, 1
    84 00000F91 48BE-               <1>  mov rsi, %1
    84 00000F93 [1000000000000000]  <1>
    85 00000F9B BA07000000          <1>  mov edx, %2
    86 00000FA0 0F05                <1>  syscall
  1766 00000FA2 C3                          ret
  1767                                  
  1768                                  exit: 
  1769 00000FA3 E8C5F1FFFF              	call canonical_on
  1770 00000FA8 B83C000000              	mov    rax, 60
  1771 00000FAD BF00000000                  mov    rdi, 0
  1772 00000FB2 0F05                        syscall
  1773                                  
