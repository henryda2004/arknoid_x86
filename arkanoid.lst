     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030145                      db 58, 7, 3, 1, 'E'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293                                      level1_blocks_count equ 4   ; Cantidad total de bloques
   294                                  
   295                                      ; Nivel 2: Bloques de prueba
   296                                      level2_blocks:
   297 000014CA 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   298                                      level2_blocks_count equ 1
   299                                  
   300                                      ; Nivel 3
   301                                      level3_blocks:
   302 000014CF 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   303                                  
   304                                      level3_blocks_count equ 1
   305                                  
   306                                      ; Nivel 4
   307                                      level4_blocks:
   308 000014D4 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   309                                      level4_blocks_count equ 1
   310                                  
   311                                      ; Nivel 5
   312                                      level5_blocks:
   313 000014D9 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   314                                      level5_blocks_count equ 1
   315                                  
   316                                      ; Array para mantener el estado de los bloques
   317 000014DE 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   318                                  
   319                                      
   320                                      ; Variables para almacenar los valores
   321 00001542 0000000000000000            current_score dq 0          ; Score actual
   322 0000154A 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   323                                      
   324                                      ; Buffer para convertir números a string
   325 0000154B 00<rep 14h>                 number_buffer: times 20 db 0
   326                                  
   327 0000155F 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   328                                      
   329                                      ; Estructura para los enemigos (x, y, activo)
   330 00001564 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   331 00001582 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   332                                      
   333 00001583 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   334 0000158B 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   335 0000158C 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   336 0000158D 00                          enemy_move_total db 0      ; Contador total de movimientos
   337 0000158E 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   338 0000158F 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   339                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   340                                      ; Añade esto en la sección .dataa
   341 00001590 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   341 00001599 12                 
   342 0000159A 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   342 000015A3 13                 
   343 000015A4 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   343 000015AD 1B                 
   344 000015AE 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   344 000015B7 1C                 
   345 000015B8 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   345 000015C1 2D                 
   346                                          ; Arreglo de punteros a los spawn points de cada nivel
   347                                      spawn_points_table:
   348 000015C2 [9015000000000000]              dq level1_spawn_points
   349 000015CA [9A15000000000000]              dq level2_spawn_points
   350 000015D2 [A415000000000000]              dq level3_spawn_points
   351 000015DA [AE15000000000000]              dq level4_spawn_points
   352 000015E2 [B815000000000000]              dq level5_spawn_points
   353                                  
   354                                      ; Variables para el comportamiento de enemigos
   355 000015EA 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   356 000015EB 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   357 000015EC 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   358 000015ED 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   359                                  
   360 000015F7 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   360 00001600 5B2020202020202020-
   360 00001609 20205D0A0D         
   361                                      score_label_len: equ $ - score_label
   362 0000160E 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   362 00001617 657374727569646F73-
   362 00001620 3A205B2020205D0A0D 
   363                                      blocks_label_len: equ $ - blocks_label
   364                                      
   365                                      ; Posición donde insertar los números en los labels
   366                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   367                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   368                                      
   369                                      ; Definición de las vidas (x, y, estado)
   370                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   371                                      lives_data: 
   372 00001629 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   373 0000162C 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   374 0000162F 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   375 00001632 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   376 00001635 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   377 00001638 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   378 0000163B 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   379                                      lives_count equ 7    ; Total de vidas
   380 0000163E 5E                          life_char db "^"    
   381 0000163F 04                          current_lives db 4   ; Contador de vidas activas actual
   382                                  
   383                                  ; Estructura para almacenar las letras y sus posiciones
   384                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   385 00001640 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   386 000017D0 00                          letters_count db 0   
   387 000017D1 20                          last_letter db ' '    ; Variable para almacenar la última letra
   388 000017D2 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   388 000017DB 75616C3A205B205D0A-
   388 000017E4 0D                 
   389                                      last_letter_msg_len equ $ - last_letter_msg
   390 000017E5 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   391 000017E6 07                          max_lives db 7              ; Máximo número de vidas permitidas
   392 000017E7 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   393 000017EF 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   394 000017F7 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   395                                  
   396 000017FF 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   397 00001800 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   398 00001801 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   399 00001809 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   400                                  
   401                                  
   402                                  section .text
   403                                  
   404                                  
   405                                  print_lives:
   406 000001DD 55                          push rbp
   407 000001DE 4889E5                      mov rbp, rsp
   408                                      
   409 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   410                                      
   411                                      .print_loop:
   412 000001E4 4983FC07                        cmp r12, lives_count
   413 000001E8 7D45                            jge .end
   414                                          
   415                                          ; Calcular offset de la vida actual
   416 000001EA 4C89E0                          mov rax, r12
   417 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   418 000001F1 488DB0[29160000]                lea rsi, [lives_data + rax]
   419                                          
   420                                          ; Calcular posición en el tablero
   421 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   422 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   423                                          
   424                                          ; Calcular offset en el tablero
   425 00000201 B84E000000                      mov rax, column_cells
   426 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   427 0000020A 49F7E1                          mul r9
   428 0000020D 4C01C0                          add rax, r8
   429 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   430                                          
   431                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   432 00000217 807E0201                        cmp byte [rsi + 2], 1
   433 0000021B 7405                            je .draw_active
   434                                          
   435                                          ; Si está inactiva, dibujar espacio
   436 0000021D C60720                          mov byte [rdi], ' '
   437 00000220 EB08                            jmp .next_life
   438                                          
   439                                      .draw_active:
   440                                          ; Si está activa, dibujar el símbolo de vida
   441 00000222 8A05(3E160000)                  mov al, [life_char]
   442 00000228 8807                            mov [rdi], al
   443                                          
   444                                      .next_life:
   445 0000022A 49FFC4                          inc r12
   446 0000022D EBB5                            jmp .print_loop
   447                                          
   448                                      .end:
   449 0000022F 5D                              pop rbp
   450 00000230 C3                              ret
   451                                  
   452                                  ; Función para desactivar una vida
   453                                  ; Función modificada para perder una vida
   454                                  lose_life:
   455 00000231 55                          push rbp
   456 00000232 4889E5                      mov rbp, rsp
   457                                      
   458                                      ; Verificar si aún quedan vidas
   459 00000235 803D(3F160000)00            cmp byte [current_lives], 0
   460 0000023C 0F8493000000                je .game_lost
   461                                      
   462                                      ; Encontrar la última vida activa
   463 00000242 B907000000                  mov rcx, lives_count
   464 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   465                                      
   466                                      .find_active_life:
   467 0000024A 4889C8                          mov rax, rcx
   468 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   469 00000251 488DB0[29160000]                lea rsi, [lives_data + rax]
   470 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   471 0000025C 7407                            je .deactivate_life
   472 0000025E 48FFC9                          dec rcx
   473 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   474 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   475                                          
   476                                      .deactivate_life:
   477                                          ; Calcular posición correcta en el tablero para borrar la vida
   478 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   479 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   480                                          
   481                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   482 0000026E B84E000000                      mov rax, column_cells
   483 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   484 00000277 49F7E1                          mul r9
   485 0000027A 4C01C0                          add rax, r8
   486 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   487                                          
   488                                          ; Borrar visualmente la vida
   489 00000284 C60720                          mov byte [rdi], ' '             
   490                                          
   491                                          ; Desactivar la vida en los datos
   492 00000287 C6460200                        mov byte [rsi + 2], 0          
   493 0000028B FE0D(3F160000)                  dec byte [current_lives]
   494                                          
   495                                          ; Borrar visualmente la paleta anterior
   496 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   497 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   498                                          .erase_pallet_loop:
   499 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   500 000002A3 49FFC0                              inc r8
   501 000002A6 48FFC9                              dec rcx
   502 000002A9 75F4                                jnz .erase_pallet_loop
   503                                          
   504                                  
   505                                          ; Reiniciar posición de la bola y la paleta
   506 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   506 000002B3 000000             
   507 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   507 000002BE 000000             
   508 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   509 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   509 000002CF [36130000]         
   510                                          
   511 000002D3 EB07                            jmp .end
   512                                          
   513                                      .game_lost:
   514 000002D5 E81C000000                      call game_lost
   515 000002DA EB00                            jmp .end
   516                                          
   517                                      .end:
   518 000002DC 5D                              pop rbp
   519 000002DD C3                              ret
   520                                  ; Función modificada para verificar colisión con el borde inferior
   521                                  check_bottom_collision:
   522 000002DE 55                          push rbp
   523 000002DF 4889E5                      mov rbp, rsp
   524                                      
   525                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   526 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   527 000002E9 4883F81E                    cmp rax, row_cells - 2
   528 000002ED 7505                        jne .no_collision
   529                                      
   530                                      ; Si hay colisión, perder una vida
   531 000002EF E83DFFFFFF                  call lose_life
   532                                      
   533                                      .no_collision:
   534 000002F4 5D                              pop rbp
   535 000002F5 C3                              ret
   536                                  
   537                                  ; Nueva función para game over
   538                                  game_lost:
   539                                      ; Limpiar la pantalla
   540                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   541                                      
   542                                      ; Mostrar mensaje de derrota
   543                                      section .data
   544 0000180A C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   544 00001813 6469646F210A0D     
   545                                          lost_msg_len: equ $ - lost_msg
   546                                      section .text
   547                                      
   548                                      ; Imprimir mensaje de derrota
   549                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [0A18000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   550                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [3818000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   551                                      
   552                                      ; Mostrar puntaje final
   553 00000347 488B05(42150000)            mov rax, [current_score]
   554 0000034E 48BF-                       mov rdi, number_buffer
   554 00000350 [4B15000000000000] 
   555 00000358 E8EF0A0000                  call number_to_string
   556                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4B15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   557                                      
   558                                      ; Esperar un momento antes de salir
   559 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   559 00000381 0000               
   560 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   560 0000038C 0000               
   561                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   562                                      
   563 000003A1 E995120000                  jmp exit
   564                                  
   565                                  
   566                                  ; Función para registrar una nueva letra en el mapa
   567                                  ; Entrada:
   568                                  ;   al - letra a registrar
   569                                  ;   r8b - posición x
   570                                  ;   r9b - posición y
   571                                  register_letter:
   572 000003A6 55                          push rbp
   573 000003A7 4889E5                      mov rbp, rsp
   574 000003AA 53                          push rbx
   575 000003AB 51                          push rcx
   576                                      
   577 000003AC 3C20                        cmp al, ' '
   578 000003AE 7438                        je .end
   579                                  
   580                                      ; Encontrar un espacio libre en el mapa
   581 000003B0 4831C9                      xor rcx, rcx
   582 000003B3 480FB615(D0170000)          movzx rdx, byte [letters_count]
   583                                      
   584                                      .find_slot:
   585 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   586 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   587                                          
   588 000003C1 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   589 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   590 000003CD 7405                            je .found_slot
   591                                          
   592 000003CF 48FFC1                          inc rcx
   593 000003D2 EBE7                            jmp .find_slot
   594                                          
   595                                      .found_slot:
   596                                          ; Guardar la información de la letra
   597 000003D4 448803                          mov [rbx], r8b           ; x
   598 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   599 000003DB 884302                          mov [rbx + 2], al        ; letra
   600 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   601                                          
   602 000003E2 FE05(D0170000)                  inc byte [letters_count]
   603                                          
   604                                      .end:
   605 000003E8 59                              pop rcx
   606 000003E9 5B                              pop rbx
   607 000003EA 5D                              pop rbp
   608 000003EB C3                              ret
   609                                  
   610                                  ; Función para imprimir todas las letras registradas
   611                                  print_letters:
   612 000003EC 55                          push rbp
   613 000003ED 4889E5                      mov rbp, rsp
   614 000003F0 53                          push rbx
   615 000003F1 51                          push rcx
   616                                      
   617 000003F2 4831C9                      xor rcx, rcx
   618                                      
   619                                      .print_loop:
   620 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   621 000003F9 7D37                            jge .end
   622                                          
   623                                          ; Obtener puntero a la letra actual
   624 000003FB 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   625                                          
   626                                          ; Verificar si está activa
   627 00000403 807B0300                        cmp byte [rbx + 3], 0
   628 00000407 7424                            je .next_letter
   629                                          
   630                                          ; Calcular posición en el tablero
   631 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   632 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   633                                          
   634                                          ; Calcular offset en el tablero
   635 00000412 B84E000000                      mov rax, column_cells
   636 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   637 0000041B 49F7E1                          mul r9
   638 0000041E 4C01C0                          add rax, r8
   639 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   640                                          
   641                                          ; Imprimir la letra
   642 00000428 8A4302                          mov al, [rbx + 2]
   643 0000042B 8807                            mov [rdi], al
   644                                          
   645                                      .next_letter:
   646 0000042D 48FFC1                          inc rcx
   647 00000430 EBC3                            jmp .print_loop
   648                                          
   649                                      .end:
   650 00000432 59                              pop rcx
   651 00000433 5B                              pop rbx
   652 00000434 5D                              pop rbp
   653 00000435 C3                              ret
   654                                  
   655                                  ; Función para borrar una letra específica
   656                                  ; Entrada:
   657                                  ;   r8b - posición x
   658                                  ;   r9b - posición y
   659                                  remove_letter:
   660 00000436 55                          push rbp
   661 00000437 4889E5                      mov rbp, rsp
   662 0000043A 53                          push rbx
   663 0000043B 51                          push rcx
   664                                      
   665 0000043C 4831C9                      xor rcx, rcx
   666                                      
   667                                      .find_loop:
   668 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   669 00000443 7D2E                            jge .end
   670                                          
   671 00000445 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   672                                          
   673                                          ; Verificar si está activa y coincide la posición
   674 0000044D 807B0300                        cmp byte [rbx + 3], 0
   675 00000451 741B                            je .next_letter
   676                                          
   677 00000453 8A03                            mov al, [rbx]
   678 00000455 4438C0                          cmp al, r8b
   679 00000458 7514                            jne .next_letter
   680                                          
   681 0000045A 8A4301                          mov al, [rbx + 1]
   682 0000045D 4438C8                          cmp al, r9b
   683 00000460 750C                            jne .next_letter
   684                                          
   685                                          ; Encontrada la letra, desactivarla
   686 00000462 C6430300                        mov byte [rbx + 3], 0
   687 00000466 FE0D(D0170000)                  dec byte [letters_count]
   688 0000046C EB05                            jmp .end
   689                                          
   690                                      .next_letter:
   691 0000046E 48FFC1                          inc rcx
   692 00000471 EBCC                            jmp .find_loop
   693                                          
   694                                      .end:
   695 00000473 59                              pop rcx
   696 00000474 5B                              pop rbx
   697 00000475 5D                              pop rbp
   698 00000476 C3                              ret
   699                                  ; Función para mover las letras hacia abajo
   700                                  move_letters:
   701 00000477 55                          push rbp
   702 00000478 4889E5                      mov rbp, rsp
   703 0000047B 53                          push rbx
   704 0000047C 57                          push rdi
   705 0000047D 56                          push rsi
   706 0000047E 4150                        push r8
   707 00000480 4151                        push r9
   708 00000482 4152                        push r10
   709 00000484 4153                        push r11
   710                                  
   711 00000486 4831C9                      xor rcx, rcx
   712                                  
   713                                      .move_loop:
   714 00000489 4883F964                        cmp rcx, 100
   715 0000048D 0F8D79010000                    jge .print_last_letter
   716                                          
   717 00000493 488D1C8D[40160000]              lea rbx, [letters_map + rcx * 4]
   718 0000049B 807B0300                        cmp byte [rbx + 3], 0
   719 0000049F 0F845F010000                    je .next_letter
   720                                  
   721 000004A5 4C0FB603                        movzx r8, byte [rbx]
   722 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   723                                  
   724 000004AE B84E000000                      mov rax, column_cells
   725 000004B3 4883C002                        add rax, 2
   726 000004B7 49F7E1                          mul r9
   727 000004BA 4C01C0                          add rax, r8
   728 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   729 000004C4 C60720                          mov byte [rdi], ' '
   730                                  
   731 000004C7 FE4301                          inc byte [rbx + 1]
   732 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   733                                  
   734 000004CF 4983F91F                        cmp r9, row_cells - 1
   735 000004D3 7C09                            jl .check_pallet_collision
   736                                  
   737 000004D5 C6430300                        mov byte [rbx + 3], 0
   738 000004D9 E926010000                      jmp .next_letter
   739                                  
   740                                          .check_pallet_collision:
   741 000004DE B84E000000                          mov rax, column_cells
   742 000004E3 4883C002                            add rax, 2
   743 000004E7 49F7E1                              mul r9
   744 000004EA 4C01C0                              add rax, r8
   745 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   746                                  
   747 000004F4 8A07                                mov al, [rdi]
   748 000004F6 3C20                                cmp al, ' '
   749 000004F8 0F8406010000                        je .next_letter
   750 000004FE 3C3D                                cmp al, char_equal
   751 00000500 740A                                je .capture_letter
   752                                  
   753 00000502 8A4302                              mov al, [rbx + 2]
   754 00000505 8807                                mov [rdi], al
   755 00000507 E9F8000000                          jmp .next_letter
   756                                  
   757                                          .capture_letter:
   758                                              ; Obtener la nueva letra
   759 0000050C 8A4302                              mov al, [rbx + 2]
   760                                              
   761                                              ; Comparar con la última letra
   762 0000050F 3A05(D1170000)                      cmp al, [last_letter]
   763 00000515 7407                                je .same_letter
   764                                              
   765                                              ; Es una letra diferente, resetear el procesamiento
   766 00000517 C605(E5170000)00                    mov byte [current_power_processed], 0
   767                                              
   768                                              .same_letter:
   769                                              ; Guardar la nueva letra
   770 0000051E 8805(D1170000)                      mov [last_letter], al
   771                                              
   772                                              ; Verificar si es 'E' para extender la paleta
   773 00000524 3C45                                cmp al, 'E'
   774 00000526 7439                                je .extend_pallet
   775                                              
   776                                              ; Verificar si es 'P' para añadir vida
   777 00000528 3C50                                cmp al, 'P'
   778 0000052A 7457                                je .check_add_life
   779                                  
   780 0000052C 3C53                                cmp al, 'S'
   781 0000052E 0F8488000000                        je .slow_ball
   782                                  
   783 00000534 3C43                                cmp al, 'C'
   784 00000536 0F84A2000000                        je .activate_catch
   785                                              
   786                                              ; Si no es ningún power-up, restaurar tamaño normal
   787 0000053C 488B05(4F140000)                    mov rax, [default_pallet_size]
   788 00000543 488905(47140000)                    mov [pallet_size], rax
   789 0000054A 48C705(E7170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   789 00000552 000000             
   790 00000555 C605(FF170000)00                    mov byte [catch_power_active], 0
   791 0000055C E99F000000                          jmp .finish_capture
   792                                  
   793                                              .extend_pallet:
   794 00000561 C605(FF170000)00                        mov byte [catch_power_active], 0
   795 00000568 48C705(E7170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   795 00000570 000000             
   796 00000573 488B05(57140000)                        mov rax, [extended_pallet_size]
   797 0000057A 488905(47140000)                        mov [pallet_size], rax
   798 00000581 EB7D                                    jmp .finish_capture
   799                                  
   800                                              .check_add_life:
   801 00000583 C605(FF170000)00                        mov byte [catch_power_active], 0
   802 0000058A 488B05(4F140000)                        mov rax, [default_pallet_size]
   803 00000591 488905(47140000)                        mov [pallet_size], rax
   804 00000598 48C705(E7170000)01-                     mov qword [ball_speed], 1 
   804 000005A0 000000             
   805                                                  ; Verificar si ya procesamos este power-up
   806 000005A3 803D(E5170000)00                        cmp byte [current_power_processed], 0
   807 000005AA 7554                                    jne .finish_capture
   808                                                  
   809                                                  ; Preservar registros importantes
   810 000005AC 51                                      push rcx
   811 000005AD 53                                      push rbx
   812                                                  
   813                                                  ; Marcar como procesado
   814 000005AE C605(E5170000)01                        mov byte [current_power_processed], 1
   815                                                  
   816                                                  ; Añadir una vida
   817 000005B5 E8A1000000                              call add_life
   818                                                  
   819                                                  ; Restaurar registros
   820 000005BA 5B                                      pop rbx
   821 000005BB 59                                      pop rcx
   822                                                  
   823                                              .slow_ball:
   824 000005BC C605(FF170000)00                        mov byte [catch_power_active], 0                
   825 000005C3 488B05(4F140000)                        mov rax, [default_pallet_size]
   826 000005CA 488905(47140000)                        mov [pallet_size], rax
   827 000005D1 48C705(E7170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   827 000005D9 000000             
   828 000005DC EB22                                    jmp .finish_capture
   829                                  
   830                                              .activate_catch:
   831 000005DE 488B05(4F140000)                        mov rax, [default_pallet_size]
   832 000005E5 488905(47140000)                        mov [pallet_size], rax
   833 000005EC 48C705(E7170000)01-                     mov qword [ball_speed], 1
   833 000005F4 000000             
   834 000005F7 C605(FF170000)01                        mov byte [catch_power_active], 1
   835 000005FE EB00                                    jmp .finish_capture
   836                                  
   837                                              .finish_capture:
   838 00000600 C6430300                                mov byte [rbx + 3], 0
   839                                  
   840                                          .next_letter:
   841 00000604 48FFC1                              inc rcx
   842 00000607 E97DFEFFFF                          jmp .move_loop
   843                                  
   844                                      .print_last_letter:
   845                                          print last_letter_msg, last_letter_msg_len - 3
    82 0000060C B801000000          <1>  mov eax, sys_write
    83 00000611 BF01000000          <1>  mov edi, 1
    84 00000616 48BE-               <1>  mov rsi, %1
    84 00000618 [D217000000000000]  <1>
    85 00000620 BA10000000          <1>  mov edx, %2
    86 00000625 0F05                <1>  syscall
   846 00000627 8A05(D1170000)                  mov al, [last_letter]
   847 0000062D 8805(E1170000)                  mov [last_letter_msg + 15], al
   848                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000633 B801000000          <1>  mov eax, sys_write
    83 00000638 BF01000000          <1>  mov edi, 1
    84 0000063D 48BE-               <1>  mov rsi, %1
    84 0000063F [E217000000000000]  <1>
    85 00000647 BA03000000          <1>  mov edx, %2
    86 0000064C 0F05                <1>  syscall
   849                                  
   850                                      .end:
   851 0000064E 415B                            pop r11
   852 00000650 415A                            pop r10
   853 00000652 4159                            pop r9
   854 00000654 4158                            pop r8
   855 00000656 5E                              pop rsi
   856 00000657 5F                              pop rdi
   857 00000658 5B                              pop rbx
   858 00000659 5D                              pop rbp
   859 0000065A C3                              ret
   860                                  
   861                                  add_life:
   862 0000065B 55                          push rbp
   863 0000065C 4889E5                      mov rbp, rsp
   864 0000065F 53                          push rbx
   865 00000660 51                          push rcx
   866 00000661 57                          push rdi
   867 00000662 56                          push rsi
   868 00000663 4150                        push r8
   869 00000665 4151                        push r9
   870                                      
   871                                      ; Verificar si ya tenemos el máximo de vidas
   872 00000667 480FB605(3F160000)          movzx rax, byte [current_lives]
   873 0000066F 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
   874 00000673 7D2C                        jge .end
   875                                      
   876                                      ; Incrementar el contador de vidas
   877 00000675 FE05(3F160000)              inc byte [current_lives]
   878                                      
   879                                      ; Encontrar la siguiente vida inactiva
   880 0000067B 4831C9                      xor rcx, rcx
   881                                      
   882                                      .find_inactive:
   883 0000067E 4883F907                        cmp rcx, lives_count
   884 00000682 7D1D                            jge .end
   885                                          
   886                                          ; Calcular offset de la vida actual
   887 00000684 4889C8                          mov rax, rcx
   888 00000687 486BC003                        imul rax, 3
   889 0000068B 488DB0[29160000]                lea rsi, [lives_data + rax]
   890                                          
   891                                          ; Verificar si está inactiva
   892 00000692 807E0200                        cmp byte [rsi + 2], 0
   893 00000696 7405                            je .activate_life
   894                                          
   895 00000698 48FFC1                          inc rcx
   896 0000069B EBE1                            jmp .find_inactive
   897                                          
   898                                      .activate_life:
   899                                          ; Activar la vida
   900 0000069D C6460201                        mov byte [rsi + 2], 1
   901                                          
   902                                      .end:
   903 000006A1 4159                            pop r9
   904 000006A3 4158                            pop r8
   905 000006A5 5E                              pop rsi
   906 000006A6 5F                              pop rdi
   907 000006A7 59                              pop rcx
   908 000006A8 5B                              pop rbx
   909 000006A9 5D                              pop rbp
   910 000006AA C3                              ret
   911                                  
   912                                  
   913                                  print_ball:
   914 000006AB 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   915 000006B2 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   916 000006B9 4981C0[000A0000]        	add r8, board
   917                                  
   918 000006C0 4C89C9                  	mov rcx, r9
   919 000006C3 B850000000              	mov rax, column_cells + 2
   920 000006C8 48F7E9                  	imul rcx
   921                                  	
   922 000006CB 4901C0                  	add r8, rax
   923 000006CE 41C6004F                	mov byte [r8], char_O
   924 000006D2 C3                      	ret
   925                                  
   926                                  	
   927                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   928                                  	
   929                                  print_pallet:
   930                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   931 000006D3 4C8B05(3F140000)            mov r8, [pallet_position]
   932 000006DA 488B0D(57140000)            mov rcx, [extended_pallet_size]
   933                                      .clear_pallet:
   934 000006E1 41C60020                        mov byte [r8], char_space
   935 000006E5 49FFC0                          inc r8
   936 000006E8 48FFC9                          dec rcx
   937 000006EB 75F4                            jnz .clear_pallet
   938                                  
   939                                      ; Luego dibujar la nueva paleta con el tamaño actual
   940 000006ED 4C8B05(3F140000)            mov r8, [pallet_position]
   941 000006F4 488B0D(47140000)            mov rcx, [pallet_size]
   942                                      .write_pallet:
   943 000006FB 41C6003D                        mov byte [r8], char_equal
   944 000006FF 49FFC0                          inc r8
   945 00000702 48FFC9                          dec rcx
   946 00000705 75F4                            jnz .write_pallet
   947                                  
   948 00000707 C3                          ret
   949                                  
   950                                  move_pallet:
   951                                      
   952 00000708 803D(7F140000)00            cmp byte [ball_moving], 0
   953 0000070F 7507                        jne .continue_movement
   954 00000711 C605(7F140000)01            mov byte [ball_moving], 1
   955                                  
   956                                      .continue_movement:
   957 00000718 4883FFFF                        cmp rdi, left_direction
   958 0000071C 7531                            jne .move_right
   959                                  
   960                                          .move_left:
   961                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   962 0000071E 4C8B05(3F140000)                    mov r8, [pallet_position]
   963 00000725 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   964 00000728 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   965 0000072B 3C58                                cmp al, 'X'        ; Comparar si es una X
   966 0000072D 744E                                je .end            ; Si es X, no mover
   967                                              
   968 0000072F 4C8B05(3F140000)                    mov r8, [pallet_position]
   969 00000736 4C8B0D(47140000)                    mov r9, [pallet_size]
   970 0000073D 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   971 00000743 49FFC8                              dec r8
   972 00000746 4C8905(3F140000)                    mov [pallet_position], r8
   973 0000074D EB2E                                jmp .end
   974                                              
   975                                          .move_right:
   976                                              ; Verificar si la siguiente posición después de la paleta sería una X
   977 0000074F 4C8B05(3F140000)                    mov r8, [pallet_position]
   978 00000756 4C8B0D(47140000)                    mov r9, [pallet_size]
   979 0000075D 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   980 00000760 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
   981 00000764 3C58                                cmp al, 'X'        ; Comparar si es una X
   982 00000766 7415                                je .end            ; Si es X, no mover
   983                                              
   984 00000768 4C8B05(3F140000)                    mov r8, [pallet_position]
   985 0000076F 41C60020                            mov byte [r8], char_space
   986 00000773 49FFC0                              inc r8
   987 00000776 4C8905(3F140000)                    mov [pallet_position], r8
   988                                          .end:
   989 0000077D C3                                  ret
   990                                  
   991                                  
   992                                  
   993                                              
   994                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
   995                                  update_caught_ball_position:
   996 0000077E 55                          push rbp
   997 0000077F 4889E5                      mov rbp, rsp
   998                                      
   999                                      ; Calcular la nueva posición de la bola basada en la paleta
  1000 00000782 4C8B05(3F140000)            mov r8, [pallet_position]
  1001 00000789 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1002 00000790 B850000000                  mov rax, column_cells + 2
  1003 00000795 4831D2                      xor rdx, rdx
  1004 00000798 48F7F0                      div rax                ; División para obtener X,Y
  1005                                      
  1006                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1007 0000079B 4989C1                      mov r9, rax            ; Y de la paleta
  1008 0000079E 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1009                                      
  1010                                      ; Añadir el offset guardado a la posición X
  1011 000007A1 4889D0                      mov rax, rdx
  1012 000007A4 480305(01180000)            add rax, [ball_catch_offset]
  1013 000007AB 488905(5F140000)            mov [ball_x_pos], rax
  1014 000007B2 4C890D(67140000)            mov [ball_y_pos], r9
  1015                                      
  1016 000007B9 5D                          pop rbp
  1017 000007BA C3                          ret
  1018                                  move_ball:
  1019                                  
  1020 000007BB 803D(00180000)01            cmp byte [ball_caught], 1
  1021 000007C2 0F849D000000                je .move_with_pallet
  1022                                  
  1023 000007C8 803D(7F140000)00            cmp byte [ball_moving], 0
  1024 000007CF 0F84B8010000                je .end
  1025                                  
  1026                                      ; Incrementar contador de velocidad
  1027 000007D5 48FF05(F7170000)            inc qword [speed_counter]
  1028                                      
  1029                                      ; Verificar si debemos mover la bola en este ciclo
  1030 000007DC 488B05(F7170000)            mov rax, [speed_counter]
  1031 000007E3 483B05(E7170000)            cmp rax, [ball_speed]
  1032 000007EA 0F8C9D010000                jl .end
  1033                                      
  1034                                      ; Resetear contador de velocidad
  1035 000007F0 48C705(F7170000)00-         mov qword [speed_counter], 0
  1035 000007F8 000000             
  1036                                  
  1037                                      ; Borrar la posición actual de la bola
  1038 000007FB 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1039 00000802 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1040 00000809 4981C0[000A0000]            add r8, board
  1041 00000810 4C89C9                      mov rcx, r9
  1042 00000813 B850000000                  mov rax, column_cells + 2
  1043 00000818 48F7E9                      imul rcx
  1044 0000081B 4901C0                      add r8, rax
  1045 0000081E 41C60020                    mov byte [r8], char_space
  1046                                  
  1047                                      ; Calcular siguiente posición X
  1048 00000822 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1049 00000829 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1050 00000830 488B05(6F140000)            mov rax, [ball_direction_x]
  1051 00000837 4901C0                      add r8, rax               ; Nueva posición X
  1052                                  
  1053                                      ; Calcular la dirección de memoria para la siguiente posición
  1054 0000083A 4D89C2                      mov r10, r8
  1055 0000083D 4981C2[000A0000]            add r10, board
  1056 00000844 4C89C9                      mov rcx, r9
  1057 00000847 B850000000                  mov rax, column_cells + 2
  1058 0000084C 48F7E9                      imul rcx
  1059 0000084F 4901C2                      add r10, rax
  1060                                  
  1061                                      ; Verificar si hay una X en la siguiente posición X
  1062 00000852 418A02                      mov al, [r10]
  1063 00000855 3C58                        cmp al, 'X'
  1064 00000857 7565                        jne .check_block_x
  1065 00000859 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1066 00000860 E928010000                  jmp .end
  1067                                  
  1068                                      .move_with_pallet:
  1069                                          ; Borrar la posición actual de la bola
  1070 00000865 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1071 0000086C 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1072 00000873 4D89C2                          mov r10, r8
  1073 00000876 4981C2[000A0000]                add r10, board
  1074 0000087D 4C89C9                          mov rcx, r9
  1075 00000880 B850000000                      mov rax, column_cells + 2
  1076 00000885 48F7E9                          imul rcx
  1077 00000888 4901C2                          add r10, rax
  1078 0000088B 41C60220                        mov byte [r10], char_space
  1079                                  
  1080                                          ; Actualizar posición X basada en la paleta
  1081 0000088F 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1082 00000896 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1083 0000089D 4C0305(01180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1084 000008A4 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1085                                  
  1086                                          ; Mantener la bola una posición arriba de la paleta
  1087 000008AB 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1088 000008B2 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1089                                  
  1090 000008B9 E9CF000000                      jmp .end
  1091                                  
  1092                                  
  1093                                      .check_block_x:
  1094                                          ; Verificar colisión con bloques en X
  1095 000008BE 4150                            push r8     ; Guardar registros que usa check_block_collision
  1096 000008C0 4151                            push r9
  1097 000008C2 4152                            push r10
  1098 000008C4 E8DB060000                      call check_block_collision
  1099 000008C9 415A                            pop r10
  1100 000008CB 4159                            pop r9
  1101 000008CD 4158                            pop r8
  1102 000008CF 4885C0                          test rax, rax
  1103 000008D2 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1104 000008D4 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1105 000008DB E9AD000000                      jmp .end
  1106                                  
  1107                                      .check_paddle_x:
  1108                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1109 000008E0 41803A3D                        cmp byte [r10], char_equal
  1110 000008E4 750C                            jne .check_y_movement
  1111 000008E6 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1112 000008ED E99B000000                      jmp .end
  1113                                  
  1114                                      .check_y_movement:
  1115                                          ; Calcular siguiente posición Y
  1116 000008F2 488B05(77140000)                mov rax, [ball_direction_y]
  1117 000008F9 4901C1                          add r9, rax                  ; Nueva posición Y
  1118                                  
  1119                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1120 000008FC 4D89C2                          mov r10, r8
  1121 000008FF 4981C2[000A0000]                add r10, board
  1122 00000906 4C89C9                          mov rcx, r9
  1123 00000909 B850000000                      mov rax, column_cells + 2
  1124 0000090E 48F7E9                          imul rcx
  1125 00000911 4901C2                          add r10, rax
  1126                                  
  1127                                          ; Verificar si hay una X en la siguiente posición Y
  1128 00000914 418A02                          mov al, [r10]
  1129 00000917 3C58                            cmp al, 'X'
  1130 00000919 7509                            jne .check_block_y
  1131 0000091B 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1132 00000922 EB69                            jmp .end
  1133                                  
  1134                                      .check_block_y:
  1135                                          ; Verificar colisión con bloques en Y
  1136 00000924 4150                            push r8     ; Guardar registros que usa check_block_collision
  1137 00000926 4151                            push r9
  1138 00000928 4152                            push r10
  1139 0000092A E875060000                      call check_block_collision
  1140 0000092F 415A                            pop r10
  1141 00000931 4159                            pop r9
  1142 00000933 4158                            pop r8
  1143 00000935 4885C0                          test rax, rax
  1144 00000938 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1145 0000093A 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1146 00000941 EB4A                            jmp .end
  1147                                  
  1148                                      .check_paddle_y:
  1149                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1150 00000943 41803A3D                        cmp byte [r10], char_equal
  1151 00000947 7536                            jne .update_position
  1152                                  
  1153                                          ; Verificar si el poder catch está activo
  1154 00000949 803D(FF170000)01                cmp byte [catch_power_active], 1
  1155 00000950 7524                            jne .normal_bounce
  1156                                  
  1157                                          ; Activar el modo "atrapado"
  1158 00000952 C605(00180000)01                mov byte [ball_caught], 1
  1159                                          
  1160                                          ; Guardar la posición X actual de la bola como offset
  1161 00000959 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1162 00000960 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1163 00000967 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1164 0000096D 488905(01180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1165                                          
  1166 00000974 EB17                            jmp .end
  1167                                  
  1168                                      .normal_bounce:
  1169 00000976 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1170 0000097D EB0E                            jmp .end
  1171                                  
  1172                                  
  1173                                      .update_position:
  1174 0000097F 4C8905(5F140000)                mov [ball_x_pos], r8
  1175 00000986 4C890D(67140000)                mov [ball_y_pos], r9
  1176                                  
  1177                                      .end:
  1178 0000098D C3                              ret
  1179                                  
  1180                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1181                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1182                                  process_catch_release:
  1183 0000098E 55                          push rbp
  1184 0000098F 4889E5                      mov rbp, rsp
  1185                                  
  1186                                      ; Verificar si la bola está atrapada
  1187 00000992 803D(00180000)00            cmp byte [ball_caught], 0
  1188 00000999 7436                        je .end
  1189                                  
  1190                                      ; Verificar si el poder catch está activo
  1191 0000099B 803D(FF170000)01            cmp byte [catch_power_active], 1
  1192 000009A2 752D                        jne .end
  1193                                  
  1194                                      ; Verificar si se presionó la tecla 'c'
  1195 000009A4 803D(09180000)63            cmp byte [last_key], 'c'
  1196 000009AB 7524                        jne .end
  1197                                  
  1198                                      ; Liberar la bola y asignar dirección inicial
  1199 000009AD C605(00180000)00            mov byte [ball_caught], 0
  1200 000009B4 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1200 000009BC 000000             
  1201 000009BF 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1201 000009C7 FFFFFF             
  1202                                  
  1203                                      ; Limpiar la tecla procesada
  1204 000009CA C605(09180000)00            mov byte [last_key], 0
  1205                                  
  1206                                      .end:
  1207 000009D1 5D                              pop rbp
  1208 000009D2 C3                              ret
  1209                                  
  1210                                  
  1211                                  display_level_number:
  1212 000009D3 55                          push rbp
  1213 000009D4 4889E5                      mov rbp, rsp
  1214                                      
  1215                                      ; Limpiar la pantalla primero
  1216                                      print clear, clear_length
    82 000009D7 B801000000          <1>  mov eax, sys_write
    83 000009DC BF01000000          <1>  mov edi, 1
    84 000009E1 48BE-               <1>  mov rsi, %1
    84 000009E3 [1000000000000000]  <1>
    85 000009EB BA07000000          <1>  mov edx, %2
    86 000009F0 0F05                <1>  syscall
  1217                                      
  1218                                      ; Calcular la posición central para el mensaje
  1219                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1220 000009F2 B84E000000                  mov rax, column_cells
  1221 000009F7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1222 000009FB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1223                                      
  1224                                      ; Calcular la fila central
  1225 000009FE BB20000000                  mov rbx, row_cells
  1226 00000A03 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1227                                      
  1228                                      ; Calcular el offset en el buffer
  1229 00000A06 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1230 00000A0B 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1231 00000A0E 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1232                                      
  1233                                      ; Escribir "NIVEL " en la posición calculada
  1234 00000A11 488DB8[000A0000]            lea rdi, [board + rax]
  1235 00000A18 48BE-                       mov rsi, level_msg
  1235 00000A1A [2414000000000000] 
  1236 00000A22 B906000000                  mov rcx, level_msg_len
  1237 00000A27 F3A4                        rep movsb
  1238                                      
  1239                                      ; Escribir el número del nivel
  1240 00000A29 8A05(B4140000)              mov al, [current_level]
  1241 00000A2F 0430                        add al, '0'                 ; convertir a ASCII
  1242 00000A31 8807                        mov [rdi], al
  1243                                      
  1244                                      ; Mostrar el board con el mensaje
  1245                                      print board, board_size
    82 00000A33 B801000000          <1>  mov eax, sys_write
    83 00000A38 BF01000000          <1>  mov edi, 1
    84 00000A3D 48BE-               <1>  mov rsi, %1
    84 00000A3F [000A000000000000]  <1>
    85 00000A47 BA000A0000          <1>  mov edx, %2
    86 00000A4C 0F05                <1>  syscall
  1246                                      
  1247                                      ; Esperar un segundo
  1248 00000A4E B823000000                  mov rax, sys_nanosleep
  1249 00000A53 48BF-                       mov rdi, level_display_time
  1249 00000A55 [2F14000000000000] 
  1250 00000A5D 4831F6                      xor rsi, rsi
  1251 00000A60 0F05                        syscall
  1252                                      
  1253 00000A62 5D                          pop rbp
  1254 00000A63 C3                          ret
  1255                                  
  1256                                  ; Función para inicializar un tablero vacío
  1257                                  init_empty_board:
  1258 00000A64 56                          push rsi
  1259 00000A65 57                          push rdi
  1260 00000A66 51                          push rcx
  1261 00000A67 50                          push rax
  1262                                  
  1263 00000A68 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1264 00000A6F 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1265 00000A76 B9000A0000                  mov rcx, board_template_size
  1266 00000A7B F3A4                        rep movsb                   ; Copiar el tablero
  1267                                  
  1268 00000A7D 58                          pop rax
  1269 00000A7E 59                          pop rcx
  1270 00000A7F 5F                          pop rdi
  1271 00000A80 5E                          pop rsi
  1272 00000A81 C3                          ret
  1273                                  
  1274                                  
  1275                                  init_level:
  1276                                  
  1277 00000A82 488B05(4F140000)            mov rax, [default_pallet_size]
  1278 00000A89 488905(47140000)            mov [pallet_size], rax
  1279 00000A90 48C705(E7170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1279 00000A98 000000             
  1280                                  
  1281                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1282                                          ; Reiniciar letras activas
  1283 00000A9B 488D3D(40160000)            lea rdi, [letters_map]
  1284 00000AA2 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1285 00000AA7 4831C0                      xor rax, rax
  1286 00000AAA F3AA                        rep stosb                    ; Llenar con ceros
  1287                                      
  1288                                      ; Inicializar dirección de la bola (derecha y arriba)
  1289 00000AAC 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1289 00000AB4 000000             
  1290 00000AB7 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1290 00000ABF FFFFFF             
  1291                                  
  1292                                  
  1293                                      ; Reiniciar contador de letras activas
  1294 00000AC2 4831C0                      xor rax, rax
  1295 00000AC5 8805(D0170000)              mov [letters_count], al
  1296                                  
  1297                                      ; Reiniciar última letra capturada
  1298 00000ACB C605(D1170000)20            mov byte [last_letter], ' '
  1299 00000AD2 C605(4A150000)00            mov byte [destroyed_blocks], 0 
  1300 00000AD9 E886FFFFFF                  call init_empty_board
  1301 00000ADE E8F0FEFFFF                  call display_level_number
  1302 00000AE3 E8E5050000                  call init_enemies
  1303                                      
  1304 00000AE8 56                          push rsi
  1305 00000AE9 57                          push rdi
  1306 00000AEA 51                          push rcx
  1307 00000AEB 50                          push rax
  1308                                  
  1309 00000AEC 488D35(00000000)            lea rsi, [board_template]
  1310 00000AF3 488D3D(000A0000)            lea rdi, [board]
  1311 00000AFA B9000A0000                  mov rcx, board_template_size
  1312 00000AFF F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1313                                  
  1314 00000B01 58                          pop rax
  1315 00000B02 59                          pop rcx
  1316 00000B03 5F                          pop rdi
  1317 00000B04 5E                          pop rsi
  1318                                  
  1319 00000B05 B90A000000                  mov rcx, 10
  1320 00000B0A 4831C0                      xor rax, rax
  1321 00000B0D 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  1322 00000B14 F3AA                        rep stosb      
  1323                                  
  1324                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1325 00000B16 803D(B4140000)01            cmp byte [current_level], 1
  1326 00000B1D 7431                        je .level1
  1327 00000B1F 803D(B4140000)02            cmp byte [current_level], 2
  1328 00000B26 7454                        je .level2
  1329 00000B28 803D(B4140000)03            cmp byte [current_level], 3
  1330 00000B2F 7477                        je .level3
  1331 00000B31 803D(B4140000)04            cmp byte [current_level], 4
  1332 00000B38 0F8492000000                je .level4
  1333 00000B3E 803D(B4140000)05            cmp byte [current_level], 5
  1334 00000B45 0F84AD000000                je .level5
  1335 00000B4B E9D0000000                  jmp .done
  1336                                  
  1337                                  
  1338                                  
  1339                                      .level1:
  1340 00000B50 C605(B5140000)04                mov byte [blocks_remaining], level1_blocks_count
  1341 00000B57 4831C9                          xor rcx, rcx             
  1342                                          .init_loop1:
  1343 00000B5A 4883F904                            cmp rcx, level1_blocks_count
  1344 00000B5E 0F8DBC000000                        jge .done
  1345 00000B64 4889C8                              mov rax, rcx         
  1346 00000B67 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1347 00000B6B 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1348 00000B71 8891[DE140000]                      mov byte [block_states + rcx], dl
  1349 00000B77 48FFC1                              inc rcx
  1350 00000B7A EBDE                                jmp .init_loop1
  1351                                  
  1352                                      .level2:
  1353 00000B7C C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1354 00000B83 4831C9                          xor rcx, rcx             
  1355                                          .init_loop2:
  1356 00000B86 4883F901                            cmp rcx, level2_blocks_count
  1357 00000B8A 0F8D90000000                        jge .done
  1358 00000B90 4889C8                              mov rax, rcx         
  1359 00000B93 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1360 00000B97 8A90[CD140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1361 00000B9D 8891[DE140000]                      mov byte [block_states + rcx], dl
  1362 00000BA3 48FFC1                              inc rcx
  1363 00000BA6 EBDE                                jmp .init_loop2
  1364                                      .level3:
  1365 00000BA8 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1366 00000BAF 4831C9                          xor rcx, rcx             
  1367                                          .init_loop3:
  1368 00000BB2 4883F901                            cmp rcx, level3_blocks_count
  1369 00000BB6 7D68                                jge .done
  1370 00000BB8 4889C8                              mov rax, rcx         
  1371 00000BBB 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1372 00000BBF 8A90[D2140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1373 00000BC5 8891[DE140000]                      mov byte [block_states + rcx], dl
  1374 00000BCB 48FFC1                              inc rcx
  1375 00000BCE EBE2                                jmp .init_loop3
  1376                                  
  1377                                      .level4:
  1378 00000BD0 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1379 00000BD7 4831C9                          xor rcx, rcx             
  1380                                          .init_loop4:
  1381 00000BDA 4883F901                            cmp rcx, level4_blocks_count
  1382 00000BDE 7D40                                jge .done
  1383 00000BE0 4889C8                              mov rax, rcx         
  1384 00000BE3 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1385 00000BE7 8A90[D7140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1386 00000BED 8891[DE140000]                      mov byte [block_states + rcx], dl
  1387 00000BF3 48FFC1                              inc rcx
  1388 00000BF6 EBE2                                jmp .init_loop4
  1389                                  
  1390                                      .level5:
  1391 00000BF8 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1392 00000BFF 4831C9                          xor rcx, rcx             
  1393                                          .init_loop5:
  1394 00000C02 4883F901                            cmp rcx, level5_blocks_count
  1395 00000C06 7D18                                jge .done
  1396 00000C08 4889C8                              mov rax, rcx         
  1397 00000C0B 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1398 00000C0F 8A90[DC140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1399 00000C15 8891[DE140000]                      mov byte [block_states + rcx], dl
  1400 00000C1B 48FFC1                              inc rcx
  1401 00000C1E EBE2                                jmp .init_loop5
  1402                                      .done:
  1403 00000C20 C3                              ret
  1404                                  
  1405                                  
  1406                                  ; Función para verificar y manejar la transición de nivel
  1407                                  check_level_complete:
  1408                                      ; Verificar si quedan bloques
  1409 00000C21 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1410 00000C28 753C                        jne .not_complete
  1411                                      
  1412                                      ; Incrementar el nivel
  1413 00000C2A FE05(B4140000)              inc byte [current_level]
  1414                                      
  1415                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1416 00000C30 803D(B4140000)06            cmp byte [current_level], 6
  1417 00000C37 742E                        je game_win
  1418                                      
  1419                                      ; Reinicializar el juego para el siguiente nivel
  1420 00000C39 E844FEFFFF                  call init_level
  1421                                      
  1422                                      ; Reinicializar la posición de la bola y la paleta
  1423 00000C3E 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1423 00000C46 000000             
  1424 00000C49 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1424 00000C51 000000             
  1425 00000C54 C605(7F140000)00            mov byte [ball_moving], 0
  1426 00000C5B 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1426 00000C62 [36130000]         
  1427                                      
  1428                                      .not_complete:
  1429 00000C66 C3                              ret
  1430                                  
  1431                                      ; Nueva función para manejar la victoria del juego
  1432                                  game_win:
  1433                                      ; Limpiar la pantalla primero
  1434                                      print clear, clear_length
    82 00000C67 B801000000          <1>  mov eax, sys_write
    83 00000C6C BF01000000          <1>  mov edi, 1
    84 00000C71 48BE-               <1>  mov rsi, %1
    84 00000C73 [1000000000000000]  <1>
    85 00000C7B BA07000000          <1>  mov edx, %2
    86 00000C80 0F05                <1>  syscall
  1435                                      
  1436                                      ; Mensaje de victoria
  1437 00000C82 488B05(42150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1438 00000C89 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1438 00000C8B [4B15000000000000] 
  1439 00000C93 E8B4010000                  call number_to_string
  1440                                      
  1441                                      ; Definir mensaje de victoria
  1442                                      section .data
  1443 0000181A C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1443 00001823 616465732120C2A148-
  1443 0000182C 61732067616E61646F-
  1443 00001835 210A0D             
  1444                                          win_msg_len: equ $ - win_msg
  1445 00001838 50756E74616A652066-             score_msg: db "Puntaje final: "
  1445 00001841 696E616C3A20       
  1446                                          score_msg_len: equ $ - score_msg
  1447                                      section .text
  1448                                      
  1449                                      ; Imprimir mensajes
  1450                                      print win_msg, win_msg_len
    82 00000C98 B801000000          <1>  mov eax, sys_write
    83 00000C9D BF01000000          <1>  mov edi, 1
    84 00000CA2 48BE-               <1>  mov rsi, %1
    84 00000CA4 [1A18000000000000]  <1>
    85 00000CAC BA1E000000          <1>  mov edx, %2
    86 00000CB1 0F05                <1>  syscall
  1451                                      print score_msg, score_msg_len
    82 00000CB3 B801000000          <1>  mov eax, sys_write
    83 00000CB8 BF01000000          <1>  mov edi, 1
    84 00000CBD 48BE-               <1>  mov rsi, %1
    84 00000CBF [3818000000000000]  <1>
    85 00000CC7 BA0F000000          <1>  mov edx, %2
    86 00000CCC 0F05                <1>  syscall
  1452                                      print number_buffer, 20
    82 00000CCE B801000000          <1>  mov eax, sys_write
    83 00000CD3 BF01000000          <1>  mov edi, 1
    84 00000CD8 48BE-               <1>  mov rsi, %1
    84 00000CDA [4B15000000000000]  <1>
    85 00000CE2 BA14000000          <1>  mov edx, %2
    86 00000CE7 0F05                <1>  syscall
  1453                                      
  1454                                      ; Esperar un momento antes de salir
  1455 00000CE9 48C7050CF3FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1455 00000CF2 0000               
  1456 00000CF4 48C70509F3FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1456 00000CFD 0000               
  1457                                      sleeptime
    98 00000CFF B823000000          <1>  mov eax, sys_nanosleep
    99 00000D04 48BF-               <1>  mov rdi, timespec
    99 00000D06 [0000000000000000]  <1>
   100 00000D0E 31F6                <1>  xor esi, esi
   101 00000D10 0F05                <1>  syscall
  1458                                      
  1459 00000D12 E924090000                  jmp exit
  1460                                  
  1461                                  ; Función para imprimir los bloques
  1462                                  ; Función modificada para imprimir bloques
  1463                                  
  1464                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1465                                  get_current_level_blocks:
  1466 00000D17 803D(B4140000)01            cmp byte [current_level], 1
  1467 00000D1E 7428                        je .level1
  1468 00000D20 803D(B4140000)02            cmp byte [current_level], 2
  1469 00000D27 7427                        je .level2
  1470 00000D29 803D(B4140000)03            cmp byte [current_level], 3
  1471 00000D30 7426                        je .level3
  1472 00000D32 803D(B4140000)04            cmp byte [current_level], 4
  1473 00000D39 7425                        je .level4
  1474 00000D3B 803D(B4140000)05            cmp byte [current_level], 5
  1475 00000D42 7424                        je .level5
  1476                                      ; Si llegamos aquí, hay un error en el nivel
  1477 00000D44 4831C0                      xor rax, rax
  1478 00000D47 C3                          ret
  1479                                  
  1480                                      .level1:
  1481 00000D48 488D05(B6140000)                lea rax, [level1_blocks]
  1482 00000D4F C3                              ret
  1483                                      .level2:
  1484 00000D50 488D05(CA140000)                lea rax, [level2_blocks]
  1485 00000D57 C3                              ret
  1486                                      .level3:
  1487 00000D58 488D05(CF140000)                lea rax, [level3_blocks]
  1488 00000D5F C3                              ret
  1489                                      .level4:
  1490 00000D60 488D05(D4140000)                lea rax, [level4_blocks]
  1491 00000D67 C3                              ret
  1492                                      .level5:
  1493 00000D68 488D05(D9140000)                lea rax, [level5_blocks]
  1494 00000D6F C3                              ret
  1495                                  ; Función para obtener la cantidad de bloques del nivel actual
  1496                                  get_current_level_count:
  1497 00000D70 803D(B4140000)01            cmp byte [current_level], 1
  1498 00000D77 7428                        je .level1
  1499 00000D79 803D(B4140000)02            cmp byte [current_level], 2
  1500 00000D80 7425                        je .level2
  1501 00000D82 803D(B4140000)03            cmp byte [current_level], 3
  1502 00000D89 7422                        je .level3
  1503 00000D8B 803D(B4140000)04            cmp byte [current_level], 4
  1504 00000D92 741F                        je .level4
  1505 00000D94 803D(B4140000)05            cmp byte [current_level], 5
  1506 00000D9B 741C                        je .level5
  1507                                      ; Si llegamos aquí, hay un error en el nivel
  1508 00000D9D 4831C0                      xor rax, rax
  1509 00000DA0 C3                          ret
  1510                                  
  1511                                      .level1:
  1512 00000DA1 B804000000                      mov rax, level1_blocks_count
  1513 00000DA6 C3                              ret
  1514                                      .level2:
  1515 00000DA7 B801000000                      mov rax, level2_blocks_count
  1516 00000DAC C3                              ret
  1517                                      .level3:
  1518 00000DAD B801000000                      mov rax, level3_blocks_count
  1519 00000DB2 C3                              ret
  1520                                      .level4:
  1521 00000DB3 B801000000                      mov rax, level4_blocks_count
  1522 00000DB8 C3                              ret
  1523                                      .level5:
  1524 00000DB9 B801000000                      mov rax, level5_blocks_count
  1525 00000DBE C3                              ret
  1526                                  
  1527                                  
  1528                                  print_blocks:
  1529 00000DBF 55                          push rbp
  1530 00000DC0 4889E5                      mov rbp, rsp
  1531                                      
  1532                                      ; Obtener puntero a los bloques del nivel actual
  1533 00000DC3 E84FFFFFFF                  call get_current_level_blocks
  1534 00000DC8 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1535                                      
  1536                                      ; Obtener cantidad de bloques del nivel actual
  1537 00000DCB E8A0FFFFFF                  call get_current_level_count
  1538 00000DD0 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1539                                      
  1540 00000DD3 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1541                                      
  1542                                      .print_loop:
  1543 00000DD6 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1544 00000DD9 7D6F                            jge .end
  1545                                          
  1546                                          ; Verificar si el bloque está activo
  1547 00000DDB 490FB68424-                     movzx rax, byte [block_states + r12]
  1547 00000DE0 [DE140000]         
  1548 00000DE4 4885C0                          test rax, rax
  1549 00000DE7 745C                            jz .next_block
  1550                                          
  1551                                          ; Obtener posición y tipo del bloque usando r13
  1552 00000DE9 4C89E0                          mov rax, r12
  1553 00000DEC 486BC005                        imul rax, 5
  1554 00000DF0 4C01E8                          add rax, r13
  1555 00000DF3 448A00                          mov r8b, [rax]        ; X position
  1556 00000DF6 448A4801                        mov r9b, [rax + 1]    ; Y position
  1557 00000DFA 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1558                                  
  1559                                          ; El resto de la lógica de impresión permanece igual
  1560 00000DFE 4D0FB6C0                        movzx r8, r8b
  1561 00000E02 4D0FB6C9                        movzx r9, r9b
  1562 00000E06 4981C0[000A0000]                add r8, board
  1563 00000E0D B850000000                      mov rax, column_cells + 2
  1564 00000E12 49F7E1                          mul r9
  1565 00000E15 4901C0                          add r8, rax
  1566                                          
  1567 00000E18 B906000000                      mov rcx, block_length
  1568 00000E1D 48BE-                           mov rsi, block_type_1
  1568 00000E1F [9014000000000000] 
  1569 00000E27 490FB6C2                        movzx rax, r10b
  1570 00000E2B 48FFC8                          dec rax
  1571 00000E2E 486BC006                        imul rax, block_length
  1572 00000E32 4801C6                          add rsi, rax
  1573                                          
  1574                                      .print_block_chars:
  1575 00000E35 8A06                            mov al, [rsi]
  1576 00000E37 418800                          mov [r8], al
  1577 00000E3A 48FFC6                          inc rsi
  1578 00000E3D 49FFC0                          inc r8
  1579 00000E40 48FFC9                          dec rcx
  1580 00000E43 75F0                            jnz .print_block_chars
  1581                                          
  1582                                      .next_block:
  1583 00000E45 49FFC4                          inc r12
  1584 00000E48 EB8C                            jmp .print_loop
  1585                                          
  1586                                      .end:
  1587 00000E4A 5D                              pop rbp
  1588 00000E4B C3                              ret
  1589                                  
  1590                                  ; Función para convertir número a string
  1591                                  ; Input: RAX = número a convertir
  1592                                  ; RDI = buffer donde escribir el string
  1593                                  number_to_string:
  1594 00000E4C 53                          push rbx
  1595 00000E4D 52                          push rdx
  1596 00000E4E 56                          push rsi
  1597 00000E4F BB0A000000                  mov rbx, 10          ; Divisor
  1598 00000E54 B900000000                  mov rcx, 0          ; Contador de dígitos
  1599                                      
  1600                                      ; Si el número es 0, manejarlo especialmente
  1601 00000E59 4885C0                      test rax, rax
  1602 00000E5C 7509                        jnz .convert_loop
  1603 00000E5E C60730                      mov byte [rdi], '0'
  1604 00000E61 C6470100                    mov byte [rdi + 1], 0
  1605 00000E65 EB20                        jmp .end
  1606                                      
  1607                                      .convert_loop:
  1608 00000E67 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1609 00000E6A 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1610 00000E6D 80C230                          add dl, '0'     ; Convertir a ASCII
  1611 00000E70 52                              push rdx        ; Guardar el dígito
  1612 00000E71 48FFC1                          inc rcx         ; Incrementar contador
  1613 00000E74 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1614 00000E77 75EE                            jnz .convert_loop
  1615                                          
  1616                                      .write_loop:
  1617 00000E79 5A                              pop rdx         ; Obtener dígito
  1618 00000E7A 8817                            mov [rdi], dl   ; Escribir al buffer
  1619 00000E7C 48FFC7                          inc rdi         ; Siguiente posición
  1620 00000E7F 48FFC9                          dec rcx         ; Decrementar contador
  1621 00000E82 75F5                            jnz .write_loop
  1622                                          
  1623 00000E84 C60700                      mov byte [rdi], 0   ; Null terminator
  1624                                      
  1625                                      .end:
  1626 00000E87 5E                          pop rsi
  1627 00000E88 5A                          pop rdx
  1628 00000E89 5B                          pop rbx
  1629 00000E8A C3                          ret
  1630                                  
  1631                                  ; Función para imprimir los labels
  1632                                  print_labels:
  1633 00000E8B 55                          push rbp
  1634 00000E8C 4889E5                      mov rbp, rsp
  1635                                  
  1636                                      ; Crear buffer temporal
  1637 00000E8F 4883EC20                    sub rsp, 32
  1638                                  
  1639                                      ; Copiar labels a buffer temporal
  1640 00000E93 4889E7                      mov rdi, rsp
  1641 00000E96 488D35(F7150000)            lea rsi, [score_label]
  1642 00000E9D B917000000                  mov rcx, score_label_len
  1643 00000EA2 F3A4                        rep movsb
  1644                                  
  1645                                      ; Convertir score a string
  1646 00000EA4 488B05(42150000)            mov rax, [current_score]
  1647 00000EAB 48BF-                       mov rdi, number_buffer
  1647 00000EAD [4B15000000000000] 
  1648 00000EB5 E892FFFFFF                  call number_to_string
  1649                                  
  1650                                      ; Calcular longitud del número
  1651 00000EBA B900000000                  mov rcx, 0
  1652 00000EBF 48BF-                       mov rdi, number_buffer
  1652 00000EC1 [4B15000000000000] 
  1653                                      .count_loop:
  1654 00000EC9 803C0F00                        cmp byte [rdi + rcx], 0
  1655 00000ECD 7405                            je .count_done
  1656 00000ECF 48FFC1                          inc rcx
  1657 00000ED2 EBF5                            jmp .count_loop
  1658                                      .count_done:
  1659                                  
  1660                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1661 00000ED4 4889E7                      mov rdi, rsp
  1662 00000ED7 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1663 00000EDB BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1664 00000EE0 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1665                                      .pad_loop:
  1666 00000EE3 4885F6                          test rsi, rsi
  1667 00000EE6 740B                            jz .pad_done
  1668 00000EE8 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1669 00000EEB 48FFC7                          inc rdi
  1670 00000EEE 48FFCE                          dec rsi
  1671 00000EF1 EBF0                            jmp .pad_loop
  1672                                      .pad_done:
  1673                                  
  1674                                      ; Copiar el número
  1675 00000EF3 48BE-                       mov rsi, number_buffer
  1675 00000EF5 [4B15000000000000] 
  1676 00000EFD F3A4                        rep movsb
  1677                                  
  1678                                      ; Imprimir el buffer completo
  1679                                      print rsp, score_label_len
    82 00000EFF B801000000          <1>  mov eax, sys_write
    83 00000F04 BF01000000          <1>  mov edi, 1
    84 00000F09 4889E6              <1>  mov rsi, %1
    85 00000F0C BA17000000          <1>  mov edx, %2
    86 00000F11 0F05                <1>  syscall
  1680                                  
  1681                                      ; Repetir proceso para bloques destruidos
  1682 00000F13 4889E7                      mov rdi, rsp
  1683 00000F16 488D35(0E160000)            lea rsi, [blocks_label]
  1684 00000F1D B91B000000                  mov rcx, blocks_label_len
  1685 00000F22 F3A4                        rep movsb
  1686                                  
  1687                                      ; Verificar que el `[` esté en su posición correcta
  1688 00000F24 4889E7                      mov rdi, rsp
  1689 00000F27 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1690 00000F2B C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1691                                  
  1692                                      ; Convertir bloques destruidos a string
  1693 00000F2E 480FB605(4A150000)          movzx rax, byte [destroyed_blocks]
  1694 00000F36 48BF-                       mov rdi, number_buffer
  1694 00000F38 [4B15000000000000] 
  1695 00000F40 E807FFFFFF                  call number_to_string
  1696                                  
  1697                                      ; Calcular longitud del número
  1698 00000F45 B900000000                  mov rcx, 0
  1699 00000F4A 48BF-                       mov rdi, number_buffer
  1699 00000F4C [4B15000000000000] 
  1700                                      .count_loop2:
  1701 00000F54 803C0F00                        cmp byte [rdi + rcx], 0
  1702 00000F58 7405                            je .count_done2
  1703 00000F5A 48FFC1                          inc rcx
  1704 00000F5D EBF5                            jmp .count_loop2
  1705                                      .count_done2:
  1706                                  
  1707                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1708 00000F5F 4889E7                      mov rdi, rsp
  1709 00000F62 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1710 00000F66 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1711 00000F6B 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1712                                      .pad_loop2:
  1713 00000F6E 4885F6                          test rsi, rsi
  1714 00000F71 740B                            jz .pad_done2
  1715 00000F73 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1716 00000F76 48FFC7                          inc rdi
  1717 00000F79 48FFCE                          dec rsi
  1718 00000F7C EBF0                            jmp .pad_loop2
  1719                                      .pad_done2:
  1720                                  
  1721                                      ; Copiar el número
  1722 00000F7E 48BE-                       mov rsi, number_buffer
  1722 00000F80 [4B15000000000000] 
  1723 00000F88 F3A4                        rep movsb
  1724                                  
  1725                                      ; Imprimir el buffer completo
  1726                                      print rsp, blocks_label_len
    82 00000F8A B801000000          <1>  mov eax, sys_write
    83 00000F8F BF01000000          <1>  mov edi, 1
    84 00000F94 4889E6              <1>  mov rsi, %1
    85 00000F97 BA1B000000          <1>  mov edx, %2
    86 00000F9C 0F05                <1>  syscall
  1727                                  
  1728                                      ; Restaurar stack
  1729 00000F9E 4883C420                    add rsp, 32
  1730 00000FA2 5D                          pop rbp
  1731 00000FA3 C3                          ret
  1732                                  
  1733                                  
  1734                                  
  1735                                  check_block_collision:
  1736 00000FA4 55                          push rbp
  1737 00000FA5 4889E5                      mov rbp, rsp
  1738                                  
  1739                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1740 00000FA8 418A02                      mov al, [r10]
  1741                                  
  1742                                      ; Verificar si el carácter es un bloque
  1743 00000FAB 3C55                        cmp al, 'U'  
  1744 00000FAD 7419                        je .possible
  1745 00000FAF 3C4F                        cmp al, 'O'  
  1746 00000FB1 7415                        je .possible
  1747 00000FB3 3C44                        cmp al, 'D'  
  1748 00000FB5 7411                        je .possible
  1749 00000FB7 3C4C                        cmp al, 'L'  
  1750 00000FB9 740D                        je .possible
  1751 00000FBB 3C56                        cmp al, 'V'  
  1752 00000FBD 7409                        je .possible
  1753 00000FBF 3C38                        cmp al, '8'  
  1754 00000FC1 7405                        je .possible
  1755                                  
  1756                                      ; No es bloque, salir
  1757 00000FC3 4831C0                      xor rax, rax
  1758 00000FC6 5D                          pop rbp
  1759 00000FC7 C3                          ret
  1760                                  
  1761                                  .possible:
  1762 00000FC8 53                          push rbx
  1763 00000FC9 57                          push rdi
  1764 00000FCA 56                          push rsi
  1765 00000FCB 4154                        push r12
  1766 00000FCD 4155                        push r13
  1767 00000FCF 4156                        push r14
  1768 00000FD1 4157                        push r15
  1769                                  
  1770                                      ; 1) Obtener base de los bloques del nivel actual
  1771 00000FD3 E83FFDFFFF                  call get_current_level_blocks
  1772 00000FD8 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1773                                  
  1774                                      ; 2) Obtener la cantidad de bloques
  1775 00000FDB E890FDFFFF                  call get_current_level_count
  1776 00000FE0 4989C6                      mov r14, rax
  1777                                  
  1778 00000FE3 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1779                                  
  1780                                  .find_block_loop:
  1781 00000FE6 4D39F4                      cmp r12, r14
  1782 00000FE9 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1783                                  
  1784                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1785 00000FEF 4C89E0                      mov rax, r12
  1786 00000FF2 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1787 00000FF6 4C01E8                      add rax, r13
  1788 00000FF9 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1789                                  
  1790                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1791 00000FFC 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1791 00001001 [DE140000]         
  1792 00001005 4885DB                      test rbx, rbx
  1793 00001008 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1794                                  
  1795                                      ; Obtener coordenadas
  1796 0000100E 418A17                      mov dl, [r15]         ; x
  1797 00001011 418A4F01                    mov cl, [r15 + 1]     ; y
  1798                                  
  1799                                      ; Calcular posición en el board
  1800 00001015 488D3D(000A0000)            lea rdi, [board]
  1801 0000101C 4831C0                      xor rax, rax
  1802 0000101F B84E000000                  mov rax, column_cells
  1803 00001024 4883C002                    add rax, 2
  1804 00001028 480FB6C9                    movzx rcx, cl         ; y
  1805 0000102C 480FAFC1                    imul rax, rcx
  1806 00001030 4801C7                      add rdi, rax
  1807 00001033 480FB6C2                    movzx rax, dl         ; x
  1808 00001037 4801C7                      add rdi, rax
  1809                                  
  1810                                      ; Guardar la posición base del bloque
  1811 0000103A 57                          push rdi
  1812                                  
  1813                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1814 0000103B 4939FA                      cmp r10, rdi
  1815 0000103E 7274                        jb .skip_collision
  1816 00001040 488D5F06                    lea rbx, [rdi + block_length]
  1817 00001044 4939DA                      cmp r10, rbx
  1818 00001047 736B                        jae .skip_collision
  1819                                  
  1820                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1821 00001049 41FE8C24[DE140000]          dec byte [block_states + r12]
  1822                                      ; Volver a cargar durabilidad
  1823 00001051 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1823 00001056 [DE140000]         
  1824 0000105A 4885DB                      test rbx, rbx
  1825 0000105D 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1826                                  
  1827                                      ; >>> Llegó a 0 => Bloque destruido
  1828 0000105F 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1829 00001060 B906000000                  mov rcx, block_length
  1830                                  .clear_loop:
  1831 00001065 C60720                      mov byte [rdi], ' '
  1832 00001068 48FFC7                      inc rdi
  1833 0000106B E2F8                        loop .clear_loop
  1834                                  
  1835                                      ; Dibujar letra del bloque destruido
  1836 0000106D 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1837 00001071 4883EF06                    sub rdi, block_length
  1838 00001075 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1839                                      ; Después de escribir la letra en el tablero
  1840 00001077 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1841 0000107B 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1842 0000107F 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1843 00001084 E81DF3FFFF                  call register_letter
  1844                                      ; Actualizar contadores globales
  1845 00001089 FE0D(B5140000)              dec byte [blocks_remaining]
  1846 0000108F FE05(4A150000)              inc byte [destroyed_blocks]
  1847                                  
  1848                                      ; Sumar puntos según el tipo
  1849 00001095 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1850 0000109A 486BC00A                    imul rax, 10
  1851 0000109E 480105(42150000)            add [current_score], rax
  1852                                  
  1853 000010A5 B801000000                  mov rax, 1  ; colisión con destrucción
  1854 000010AA EB14                        jmp .end_pop
  1855                                  
  1856                                  .update_display:
  1857                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1858 000010AC B801000000                  mov rax, 1  ; colisión con "rebote"  
  1859 000010B1 5F                          pop rdi     ; pop que quedó pendiente
  1860 000010B2 EB0C                        jmp .end_pop
  1861                                  
  1862                                  .skip_collision:
  1863 000010B4 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1864                                  .next_block:
  1865 000010B5 49FFC4                      inc r12
  1866 000010B8 E929FFFFFF                  jmp .find_block_loop
  1867                                  
  1868                                  .no_block_found:
  1869 000010BD 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1870                                  
  1871                                  .end_pop:
  1872 000010C0 415F                        pop r15
  1873 000010C2 415E                        pop r14
  1874 000010C4 415D                        pop r13
  1875 000010C6 415C                        pop r12
  1876 000010C8 5E                          pop rsi
  1877 000010C9 5F                          pop rdi
  1878 000010CA 5B                          pop rbx
  1879 000010CB 5D                          pop rbp
  1880 000010CC C3                          ret
  1881                                  
  1882                                  
  1883                                  
  1884                                  init_enemies:
  1885 000010CD 55                          push rbp
  1886 000010CE 4889E5                      mov rbp, rsp
  1887                                      ; Reiniciar contadores de movimiento
  1888 000010D1 C605(8D150000)00            mov byte [enemy_move_total], 0
  1889 000010D8 C605(8E150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1890                                      ; Limpiar estado previo de enemigos
  1891 000010DF B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1892 000010E4 488D3D(64150000)            lea rdi, [enemies]
  1893 000010EB 30C0                        xor al, al
  1894 000010ED F3AA                        rep stosb ; Limpiar datos de enemigos
  1895                                      
  1896                                      ; Marcar todos los enemigos como inactivos
  1897 000010EF 488D3D(ED150000)            lea rdi, [enemy_spawns_triggered]
  1898 000010F6 30C0                        xor al, al
  1899 000010F8 B90A000000                  mov rcx, 10
  1900 000010FD F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1901                                  
  1902 000010FF 5D                          pop rbp
  1903 00001100 C3                          ret
  1904                                  
  1905                                  
  1906                                  ; Función para mover enemigos
  1907                                  move_enemies:
  1908 00001101 55                          push rbp
  1909 00001102 4889E5                      mov rbp, rsp
  1910                                      
  1911                                      ; Incrementar contador de movimiento
  1912 00001105 FE05(8B150000)              inc byte [enemy_move_counter]
  1913 0000110B 480FB605(8B150000)          movzx rax, byte [enemy_move_counter]
  1914 00001113 3A05(8C150000)              cmp al, [enemy_move_delay]
  1915 00001119 0F85AA010000                jne .end
  1916                                      
  1917                                      ; Resetear contador
  1918 0000111F C605(8B150000)00            mov byte [enemy_move_counter], 0
  1919                                      
  1920 00001126 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1921                                      
  1922                                      .enemy_loop:
  1923 00001129 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1924 0000112D 0F8D96010000                    jge .end
  1925                                          
  1926                                          ; Calcular offset del enemigo actual
  1927 00001133 4C89E0                          mov rax, r12
  1928 00001136 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1929 0000113A 488DB0[64150000]                lea rsi, [enemies + rax]
  1930                                          
  1931                                          ; Verificar si el enemigo está activo
  1932 00001141 807E0201                        cmp byte [rsi + 2], 1
  1933 00001145 0F8576010000                    jne .next_enemy
  1934                                          
  1935                                          ; Obtener posición actual
  1936 0000114B 4C0FB606                        movzx r8, byte [rsi]            ; X
  1937 0000114F 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1938                                          
  1939                                          ; Limpiar posición actual antes de mover
  1940 00001154 4150                            push r8
  1941 00001156 4151                            push r9
  1942 00001158 B84E000000                      mov rax, column_cells
  1943 0000115D 4883C002                        add rax, 2
  1944 00001161 49F7E1                          mul r9
  1945 00001164 4C01C0                          add rax, r8
  1946 00001167 488DB8[000A0000]                lea rdi, [board + rax]
  1947 0000116E C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1948 00001171 4159                            pop r9
  1949 00001173 4158                            pop r8
  1950                                  
  1951                                          ; Determinar comportamiento basado en índice
  1952 00001175 4C89E0                          mov rax, r12
  1953 00001178 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1954 0000117C 4885C0                          test rax, rax
  1955 0000117F 7402                            jz .chase_ball
  1956 00001181 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1957                                          
  1958                                          ; Perseguir bola (comportamiento original)
  1959                                      .chase_ball:
  1960 00001183 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1961 0000118A 4D39D0                          cmp r8, r10
  1962 0000118D 0F8F96000000                    jg .move_left
  1963 00001193 0F8C95000000                    jl .move_right
  1964                                          
  1965 00001199 4C8B15(67140000)                mov r10, [ball_y_pos]
  1966 000011A0 4D39D1                          cmp r9, r10
  1967 000011A3 0F8F8A000000                    jg .move_up
  1968 000011A9 0F8C89000000                    jl .move_down
  1969 000011AF E9A5000000                      jmp .check_collision
  1970                                          
  1971                                      .chase_paddle:
  1972                                          ; Obtener la posición X actual de la paleta
  1973 000011B4 4C8B15(3F140000)                mov r10, [pallet_position]
  1974 000011BB 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1975                                          
  1976                                          ; Calcular la posición X real de la paleta
  1977 000011C2 4C89D0                          mov rax, r10
  1978 000011C5 BB4E000000                      mov rbx, column_cells
  1979 000011CA 4883C302                        add rbx, 2                  ; Añadir newline chars
  1980 000011CE 4831D2                          xor rdx, rdx
  1981 000011D1 48F7F3                          div rbx                     ; rax = y, rdx = x
  1982                                          
  1983                                          ; rdx ahora contiene la posición X de la paleta
  1984                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1985 000011D4 488B0D(47140000)                mov rcx, [pallet_size]
  1986 000011DB 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1987 000011DE 4801CA                          add rdx, rcx
  1988                                          
  1989                                          ; Comparar con posición X del enemigo y mover gradualmente
  1990 000011E1 4939D0                          cmp r8, rdx
  1991 000011E4 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1992 000011E6 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1993 000011E8 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1994                                  
  1995                                      .check_y_paddle:
  1996                                          ; La Y de la paleta siempre es row_cells - 2
  1997 000011EA 41BA20000000                    mov r10, row_cells
  1998 000011F0 4983EA02                        sub r10, 2
  1999                                          
  2000                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2001 000011F4 4D39D1                          cmp r9, r10
  2002 000011F7 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2003 000011F9 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2004 000011FB 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2005                                          
  2006                                      .no_movement:
  2007 000011FD EB5A                            jmp .check_collision
  2008                                  
  2009                                      ; También agregar una nueva sección para el movimiento suave
  2010                                      .smooth_transition:
  2011                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2012 000011FF 8A05(8E150000)                  mov al, [enemy_target]
  2013 00001205 84C0                            test al, al
  2014 00001207 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2015                                          
  2016                                          ; Verificar distancia en X
  2017 00001209 4989D2                          mov r10, rdx              ; Posición X objetivo
  2018 0000120C 4D29C2                          sub r10, r8               ; Calcular diferencia
  2019 0000120F 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2020 00001213 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2021 00001215 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2022 00001219 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2023 0000121B EB3C                            jmp .check_collision
  2024                                          
  2025                                      .limit_right_movement:
  2026 0000121D 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2027 00001221 EB36                            jmp .check_collision
  2028                                          
  2029                                      .limit_left_movement:
  2030 00001223 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2031 00001227 EB30                            jmp .check_collision
  2032                                      .move_left:
  2033 00001229 49FFC8                          dec r8
  2034 0000122C EB0F                            jmp .check_vertical
  2035                                          
  2036                                      .move_right:
  2037 0000122E 49FFC0                          inc r8
  2038 00001231 EB0A                            jmp .check_vertical
  2039                                          
  2040                                      .move_up:
  2041 00001233 49FFC9                          dec r9
  2042 00001236 EB21                            jmp .check_collision
  2043                                          
  2044                                      .move_down:
  2045 00001238 49FFC1                          inc r9
  2046 0000123B EB1C                            jmp .check_collision
  2047                                          
  2048                                      .check_vertical:
  2049 0000123D 8A05(8E150000)                  mov al, [enemy_target]
  2050 00001243 84C0                            test al, al
  2051 00001245 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2052 0000124B 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2053 00001252 4D39D1                          cmp r9, r10
  2054 00001255 7FDC                            jg .move_up
  2055 00001257 7CDF                            jl .move_down
  2056                                          
  2057                                      .check_collision:
  2058                                          ; Verificar colisión con bordes
  2059 00001259 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2060 0000125D 7E62                            jle .next_enemy
  2061 0000125F 4983F84E                        cmp r8, column_cells
  2062 00001263 7D5C                            jge .next_enemy
  2063 00001265 4983F901                        cmp r9, 1                       ; Borde superior
  2064 00001269 7E56                            jle .next_enemy
  2065 0000126B 4983F920                        cmp r9, row_cells
  2066 0000126F 7D50                            jge .next_enemy
  2067                                          
  2068                                          ; Verificar colisión con bloques antes de moverse
  2069 00001271 4150                            push r8
  2070 00001273 4151                            push r9
  2071 00001275 4152                            push r10
  2072                                          
  2073                                          ; Calcular posición en el tablero para verificar
  2074 00001277 B84E000000                      mov rax, column_cells
  2075 0000127C 4883C002                        add rax, 2
  2076 00001280 49F7E1                          mul r9
  2077 00001283 4C01C0                          add rax, r8
  2078 00001286 4C8D90[000A0000]                lea r10, [board + rax]
  2079                                          
  2080                                          ; Verificar si hay un bloque en la nueva posición
  2081 0000128D 418A02                          mov al, [r10]
  2082 00001290 3C55                            cmp al, 'U'
  2083 00001292 7427                            je .invalid_move
  2084 00001294 3C4F                            cmp al, 'O'
  2085 00001296 7423                            je .invalid_move
  2086 00001298 3C44                            cmp al, 'D'
  2087 0000129A 741F                            je .invalid_move
  2088 0000129C 3C4C                            cmp al, 'L'
  2089 0000129E 741B                            je .invalid_move
  2090 000012A0 3C56                            cmp al, 'V'
  2091 000012A2 7417                            je .invalid_move
  2092 000012A4 3C38                            cmp al, '8'
  2093 000012A6 7413                            je .invalid_move
  2094 000012A8 3C58                            cmp al, 'X'
  2095 000012AA 740F                            je .invalid_move
  2096                                          
  2097 000012AC 415A                            pop r10
  2098 000012AE 4159                            pop r9
  2099 000012B0 4158                            pop r8
  2100                                          
  2101                                          ; Guardar nueva posición si es válida
  2102 000012B2 448806                          mov [rsi], r8b
  2103 000012B5 44884E01                        mov [rsi + 1], r9b
  2104 000012B9 EB06                            jmp .next_enemy
  2105                                          
  2106                                      .invalid_move:
  2107 000012BB 415A                            pop r10
  2108 000012BD 4159                            pop r9
  2109 000012BF 4158                            pop r8
  2110                                          
  2111                                      .next_enemy:
  2112 000012C1 49FFC4                          inc r12
  2113 000012C4 E960FEFFFF                      jmp .enemy_loop
  2114                                          
  2115                                      .end:
  2116 000012C9 5D                              pop rbp
  2117 000012CA C3                              ret
  2118                                  
  2119                                  get_current_spawn_points:
  2120 000012CB 55                          push rbp
  2121 000012CC 4889E5                      mov rbp, rsp
  2122                                      
  2123 000012CF 480FB605(B4140000)          movzx rax, byte [current_level]
  2124 000012D7 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2125 000012DA 488B04C5[C2150000]          mov rax, [spawn_points_table + rax * 8]
  2126                                      
  2127 000012E2 5D                          pop rbp
  2128 000012E3 C3                          ret
  2129                                  
  2130                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2131                                  check_enemy_spawn:
  2132 000012E4 55                          push rbp
  2133 000012E5 4889E5                      mov rbp, rsp
  2134                                      
  2135                                      ; Obtener spawn points del nivel actual
  2136 000012E8 E8DEFFFFFF                  call get_current_spawn_points
  2137 000012ED 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2138                                      
  2139                                      ; Obtener cantidad de bloques destruidos
  2140 000012F0 4C0FB62D(4A150000)          movzx r13, byte [destroyed_blocks]
  2141                                      
  2142                                      ; Verificar cada punto de spawn
  2143 000012F8 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2144                                      
  2145                                      .check_loop:
  2146 000012FB 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2147 000012FF 7D4B                            jge .end
  2148                                          
  2149                                          ; Verificar si este spawn point ya fue usado
  2150 00001301 80B9[ED150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2151 00001308 743D                            je .next_enemy
  2152                                          
  2153                                          ; Verificar si este enemigo ya está activo
  2154 0000130A 4889C8                          mov rax, rcx
  2155 0000130D 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2156 00001311 488DB0[64150000]                lea rsi, [enemies + rax]
  2157 00001318 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2158 0000131C 7429                            je .next_enemy
  2159                                          
  2160                                          ; Verificar si debemos spawnear este enemigo
  2161 0000131E 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2162 00001323 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2163 00001326 751F                            jne .next_enemy
  2164                                          
  2165                                          ; Marcar este spawn point como usado
  2166 00001328 C681[ED150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2167                                          
  2168                                          ; Spawner nuevo enemigo
  2169 0000132F C60628                          mov byte [rsi], 40             ; X inicial
  2170 00001332 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2171 00001336 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2172                                          
  2173                                          ; Inicializar comportamiento
  2174 0000133A 4889C8                          mov rax, rcx
  2175 0000133D 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2176 00001341 8805(EC150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2177                                          
  2178                                      .next_enemy:
  2179 00001347 48FFC1                          inc rcx
  2180 0000134A EBAF                            jmp .check_loop
  2181                                          
  2182                                      .end:
  2183 0000134C 5D                              pop rbp
  2184 0000134D C3                              ret
  2185                                  
  2186                                  
  2187                                  ; Función para dibujar enemigos
  2188                                  print_enemies:
  2189 0000134E 55                          push rbp
  2190 0000134F 4889E5                      mov rbp, rsp
  2191                                      
  2192 00001352 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2193                                      
  2194                                      .print_loop:
  2195 00001355 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2196 00001359 7D4B                            jge .end
  2197                                          
  2198                                          ; Calcular offset del enemigo actual
  2199 0000135B 4C89E0                          mov rax, r12
  2200 0000135E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2201 00001362 488DB0[64150000]                lea rsi, [enemies + rax]
  2202                                          
  2203                                          ; Verificar si el enemigo está activo
  2204 00001369 807E0201                        cmp byte [rsi + 2], 1
  2205 0000136D 7532                            jne .next_enemy
  2206                                          
  2207                                          ; Calcular posición en el tablero
  2208 0000136F 4C0FB606                        movzx r8, byte [rsi]            ; X
  2209 00001373 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2210                                          
  2211                                          ; Calcular offset en el tablero
  2212 00001378 B84E000000                      mov rax, column_cells
  2213 0000137D 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2214 00001381 49F7E1                          mul r9
  2215 00001384 4C01C0                          add rax, r8
  2216 00001387 488DB8[000A0000]                lea rdi, [board + rax]
  2217                                          
  2218                                          ; Obtener carácter del enemigo según el nivel
  2219 0000138E 480FB605(B4140000)              movzx rax, byte [current_level]
  2220 00001396 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2221 00001399 8A80[5F150000]                  mov al, [enemy_chars + rax]
  2222                                          
  2223                                          ; Dibujar enemigo
  2224 0000139F 8807                            mov [rdi], al
  2225                                          
  2226                                      .next_enemy:
  2227 000013A1 49FFC4                          inc r12
  2228 000013A4 EBAF                            jmp .print_loop
  2229                                          
  2230                                      .end:
  2231 000013A6 5D                              pop rbp
  2232 000013A7 C3                              ret
  2233                                  
  2234                                  ; Función para verificar colisión con enemigos
  2235                                  ; Función para verificar colisión con enemigos
  2236                                  check_enemy_collision:
  2237 000013A8 55                          push rbp
  2238 000013A9 4889E5                      mov rbp, rsp
  2239                                      
  2240 000013AC 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2241 000013AF 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2242                                      
  2243                                      .check_loop:
  2244 000013B2 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2245 000013B6 0F8DE9000000                    jge .end
  2246                                          
  2247                                          ; Calcular offset del enemigo actual
  2248 000013BC 4C89E1                          mov rcx, r12
  2249 000013BF 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2250 000013C3 488DB1[64150000]                lea rsi, [enemies + rcx]
  2251                                          
  2252                                          ; Verificar si el enemigo está activo
  2253 000013CA 807E0201                        cmp byte [rsi + 2], 1
  2254 000013CE 0F85C9000000                    jne .next_enemy
  2255                                          
  2256                                          ; Verificar colisión con la bola
  2257 000013D4 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2258 000013D8 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2259                                          
  2260                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2261 000013DD 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2262 000013E4 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2263                                          
  2264                                          ; Comprobar colisión vertical (misma columna)
  2265 000013EB 4D39C2                          cmp r10, r8
  2266 000013EE 7525                            jne .check_horizontal
  2267 000013F0 4D29CB                          sub r11, r9
  2268 000013F3 4983FB01                        cmp r11, 1
  2269 000013F7 7F1C                            jg .check_horizontal
  2270 000013F9 4983FBFF                        cmp r11, -1
  2271 000013FD 7C16                            jl .check_horizontal
  2272                                          
  2273                                          ; Colisión vertical detectada
  2274 000013FF E8A3000000                      call destroy_enemy
  2275 00001404 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2276 0000140B B801000000                      mov rax, 1
  2277 00001410 E990000000                      jmp .end
  2278                                          
  2279                                      .check_horizontal:
  2280                                          ; Comprobar colisión horizontal (misma fila)
  2281 00001415 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2282 0000141C 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2283 00001423 4D39CB                          cmp r11, r9
  2284 00001426 7522                            jne .check_paddle
  2285 00001428 4D29C2                          sub r10, r8
  2286 0000142B 4983FA01                        cmp r10, 1
  2287 0000142F 7F19                            jg .check_paddle
  2288 00001431 4983FAFF                        cmp r10, -1
  2289 00001435 7C13                            jl .check_paddle
  2290                                          
  2291                                          ; Colisión horizontal detectada
  2292 00001437 E86B000000                      call destroy_enemy
  2293 0000143C 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2294 00001443 B801000000                      mov rax, 1
  2295 00001448 EB5B                            jmp .end
  2296                                          
  2297                                      .check_paddle:
  2298                                          ; Verificar colisión con la paleta
  2299 0000144A 4C8B15(3F140000)                mov r10, [pallet_position]
  2300 00001451 4981EA[000A0000]                sub r10, board
  2301 00001458 4C89D0                          mov rax, r10
  2302 0000145B 41BB4E000000                    mov r11, column_cells
  2303 00001461 4983C302                        add r11, 2
  2304 00001465 4831D2                          xor rdx, rdx
  2305 00001468 49F7F3                          div r11                     ; División para obtener la posición Y
  2306 0000146B 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2307                                          
  2308 0000146E 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2309                                          
  2310                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2311 00001475 41BD20000000                    mov r13, row_cells
  2312 0000147B 4983ED02                        sub r13, 2                 ; Y de la paleta
  2313 0000147F 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2314 00001482 7519                            jne .next_enemy
  2315                                          
  2316                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2317 00001484 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2318 00001487 7C14                            jl .next_enemy
  2319                                          
  2320 00001489 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2321 0000148C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2322 0000148F 7F0C                            jg .next_enemy
  2323                                          
  2324                                          ; Si llegamos aquí, hay colisión con la paleta
  2325 00001491 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2326 00001496 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2327 0000149B EB08                            jmp .end
  2328                                          
  2329                                      .next_enemy:
  2330 0000149D 49FFC4                          inc r12
  2331 000014A0 E90DFFFFFF                      jmp .check_loop
  2332                                          
  2333                                      .end:
  2334 000014A5 5D                              pop rbp
  2335 000014A6 C3                              ret
  2336                                  
  2337                                  ; Función para destruir un enemigo
  2338                                  destroy_enemy:
  2339                                      ; Desactivar enemigo
  2340 000014A7 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2341                                  
  2342                                      ; Sumar puntos por destruir enemigo
  2343 000014AB 488B05(83150000)            mov rax, [enemy_points]
  2344 000014B2 480105(42150000)            add [current_score], rax
  2345                                  
  2346                                      ; No tocar bloques destruidos aquí
  2347 000014B9 C3                          ret
  2348                                  
  2349                                  
  2350                                  _start:
  2351 000014BA E86CECFFFF              	call canonical_off
  2352 000014BF E804010000              	call start_screen
  2353 000014C4 E8B9F5FFFF                  call init_level
  2354 000014C9 E8FFFBFFFF                  call init_enemies
  2355 000014CE EB00                    	jmp .main_loop
  2356                                  	
  2357                                  
  2358                                  	.main_loop:
  2359 000014D0 E8B6F9FFFF                      call print_labels
  2360 000014D5 E8E5F8FFFF                      call print_blocks
  2361 000014DA E898EFFFFF                      call move_letters
  2362 000014DF E808EFFFFF                      call print_letters
  2363 000014E4 E8EAF1FFFF              		call print_pallet
  2364 000014E9 E8CDF2FFFF                      call move_ball
  2365 000014EE E8EBEDFFFF                      call check_bottom_collision
  2366 000014F3 E8E5ECFFFF                      call print_lives
  2367 000014F8 E824F7FFFF                      call check_level_complete
  2368 000014FD E8E2FDFFFF                      call check_enemy_spawn
  2369 00001502 E8FAFBFFFF                      call move_enemies
  2370 00001507 E89CFEFFFF                      call check_enemy_collision
  2371 0000150C E83DFEFFFF                      call print_enemies
  2372 00001511 E895F1FFFF              		call print_ball
  2373                                  		print board, board_size				
    82 00001516 B801000000          <1>  mov eax, sys_write
    83 0000151B BF01000000          <1>  mov edi, 1
    84 00001520 48BE-               <1>  mov rsi, %1
    84 00001522 [000A000000000000]  <1>
    85 0000152A BA000A0000          <1>  mov edx, %2
    86 0000152F 0F05                <1>  syscall
  2374                                  		;setnonblocking	
  2375                                  	.read_more:	
  2376                                  	    getchar	
    90 00001531 B800000000          <1>  mov rax, sys_read
    91 00001536 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000153B 48BE-               <1>  mov rsi, input_char
    92 0000153D [0000000000000000]  <1>
    93 00001545 BA01000000          <1>  mov rdx, 1
    94 0000154A 0F05                <1>  syscall
  2377 0000154C 4883F801                	    cmp rax, 1
  2378 00001550 7543                    	    jne .done
  2379                                  	
  2380 00001552 8A05(00000000)          	    mov al, [input_char]
  2381 00001558 8805(09180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2382                                  	
  2383 0000155E 3C61                    	    cmp al, 'a'
  2384 00001560 750E                    	    jne .not_left
  2385 00001562 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2386 00001569 E89AF1FFFF              	    call move_pallet
  2387 0000156E EB25                    	    jmp .done
  2388                                  	
  2389                                      .not_left:
  2390 00001570 3C64                    	    cmp al, 'd'
  2391 00001572 750C                    	    jne .not_right
  2392 00001574 BF01000000              	    mov rdi, right_direction
  2393 00001579 E88AF1FFFF              	    call move_pallet
  2394 0000157E EB15                    	    jmp .done
  2395                                  	
  2396                                      .not_right:
  2397 00001580 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2398 00001582 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2399                                  	
  2400 00001584 3C71                    	    cmp al, 'q' 
  2401 00001586 0F84AF000000            	    je exit
  2402 0000158C EBA3                    	    jmp .read_more
  2403                                  	
  2404                                      .release_ball:
  2405 0000158E E8FBF3FFFF              	    call process_catch_release
  2406 00001593 EB00                    	    jmp .done
  2407                                  	
  2408                                      .done:
  2409                                  	    sleeptime
    98 00001595 B823000000          <1>  mov eax, sys_nanosleep
    99 0000159A 48BF-               <1>  mov rdi, timespec
    99 0000159C [0000000000000000]  <1>
   100 000015A4 31F6                <1>  xor esi, esi
   101 000015A6 0F05                <1>  syscall
  2410                                  	    print clear, clear_length
    82 000015A8 B801000000          <1>  mov eax, sys_write
    83 000015AD BF01000000          <1>  mov edi, 1
    84 000015B2 48BE-               <1>  mov rsi, %1
    84 000015B4 [1000000000000000]  <1>
    85 000015BC BA07000000          <1>  mov edx, %2
    86 000015C1 0F05                <1>  syscall
  2411 000015C3 E908FFFFFF              	    jmp .main_loop
  2412                                  
  2413                                  
  2414                                  
  2415                                  
  2416                                  start_screen:
  2417                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000015C8 B801000000          <1>  mov eax, sys_write
    83 000015CD BF01000000          <1>  mov edi, 1
    84 000015D2 48BE-               <1>  mov rsi, %1
    84 000015D4 [1000000000000000]  <1>
    85 000015DC BA07000000          <1>  mov edx, %2
    86 000015E1 0F05                <1>  syscall
  2418                                      print msg1, msg1_length
    82 000015E3 B801000000          <1>  mov eax, sys_write
    83 000015E8 BF01000000          <1>  mov edi, 1
    84 000015ED 48BE-               <1>  mov rsi, %1
    84 000015EF [1700000000000000]  <1>
    85 000015F7 BA14010000          <1>  mov edx, %2
    86 000015FC 0F05                <1>  syscall
  2419                                      
  2420                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2421                                          getchar                 ; Esperamos una tecla
    90 000015FE B800000000          <1>  mov rax, sys_read
    91 00001603 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001608 48BE-               <1>  mov rsi, input_char
    92 0000160A [0000000000000000]  <1>
    93 00001612 BA01000000          <1>  mov rdx, 1
    94 00001617 0F05                <1>  syscall
  2422 00001619 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2423 0000161D 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2424                                          
  2425                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000161F B801000000          <1>  mov eax, sys_write
    83 00001624 BF01000000          <1>  mov edi, 1
    84 00001629 48BE-               <1>  mov rsi, %1
    84 0000162B [1000000000000000]  <1>
    85 00001633 BA07000000          <1>  mov edx, %2
    86 00001638 0F05                <1>  syscall
  2426 0000163A C3                          ret
  2427                                  
  2428                                  exit: 
  2429 0000163B E82DEBFFFF              	call canonical_on
  2430 00001640 B83C000000              	mov    rax, 60
  2431 00001645 BF00000000                  mov    rdi, 0
  2432 0000164A 0F05                        syscall
  2433                                  
