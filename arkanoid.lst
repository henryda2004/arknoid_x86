     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000        	pallet_size dq 5
   249                                  
   250 0000144F 2800000000000000        	ball_x_pos: dq 40
   251 00001457 1C00000000000000        	ball_y_pos: dq 28
   252 0000145F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   253 00001467 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   254 0000146F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   255                                  
   256                                  ; Definir los límites de la pantalla o área de juego
   257                                      board_top_left_x equ 1
   258                                      board_top_left_y equ 1
   259                                      board_bottom_right_x equ column_cells - 1
   260                                      board_bottom_right_y equ row_cells
   261                                  
   262                                      ; Limites laterales
   263                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   264                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   265                                  
   266                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   267 00001470 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   268 00001478 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   269                                  
   270                                      ; Definición de tipos de bloques
   271 00001480 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   272 00001486 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   273 0000148C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   274 00001492 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   275 00001498 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   276 0000149E 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   277                                      block_length: equ 6        ; Longitud de cada bloque
   278                                  
   279                                      ; Estructura para el nivel actual
   280 000014A4 01                          current_level db 1
   281 000014A5 00                          blocks_remaining db 0
   282                                  
   283                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   284                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   285                                      level1_blocks:
   286                                          ; Tercera fila (tipo 3)
   287 000014A6 3807030153                      db 56, 7, 3, 1, 'S'    ; Bloque 7
   288 000014AB 3B09030153                      db 59, 9, 3, 1, 'S'    ; Bloque 7
   289 000014B0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   290                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   291                                  
   292                                      ; Nivel 2: Bloques de prueba
   293                                      level2_blocks:
   294 000014B5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   295                                      level2_blocks_count equ 1
   296                                  
   297                                      ; Nivel 3
   298                                      level3_blocks:
   299 000014BA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   300                                  
   301                                      level3_blocks_count equ 1
   302                                  
   303                                      ; Nivel 4
   304                                      level4_blocks:
   305 000014BF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   306                                      level4_blocks_count equ 1
   307                                  
   308                                      ; Nivel 5
   309                                      level5_blocks:
   310 000014C4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   311                                      level5_blocks_count equ 1
   312                                  
   313                                      ; Array para mantener el estado de los bloques
   314 000014C9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   315                                  
   316                                      
   317                                      ; Variables para almacenar los valores
   318 0000152D 0000000000000000            current_score dq 0          ; Score actual
   319 00001535 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   320                                      
   321                                      ; Buffer para convertir números a string
   322 00001536 00<rep 14h>                 number_buffer: times 20 db 0
   323                                  
   324 0000154A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   325                                      
   326                                      ; Estructura para los enemigos (x, y, activo)
   327 0000154F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   328 0000156D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   329                                      
   330 0000156E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   331 00001576 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   332 00001577 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   333 00001578 00                          enemy_move_total db 0      ; Contador total de movimientos
   334 00001579 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   335 0000157A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   336                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   337                                      ; Añade esto en la sección .dataa
   338 0000157B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   338 00001584 12                 
   339 00001585 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   339 0000158E 13                 
   340 0000158F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   340 00001598 1B                 
   341 00001599 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   341 000015A2 1C                 
   342 000015A3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   342 000015AC 2D                 
   343                                          ; Arreglo de punteros a los spawn points de cada nivel
   344                                      spawn_points_table:
   345 000015AD [7B15000000000000]              dq level1_spawn_points
   346 000015B5 [8515000000000000]              dq level2_spawn_points
   347 000015BD [8F15000000000000]              dq level3_spawn_points
   348 000015C5 [9915000000000000]              dq level4_spawn_points
   349 000015CD [A315000000000000]              dq level5_spawn_points
   350                                  
   351                                      ; Variables para el comportamiento de enemigos
   352 000015D5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   353 000015D6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   354 000015D7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   355 000015D8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   356                                  
   357 000015E2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   357 000015EB 5B2020202020202020-
   357 000015F4 20205D0A0D         
   358                                      score_label_len: equ $ - score_label
   359 000015F9 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   359 00001602 657374727569646F73-
   359 0000160B 3A205B2020205D0A0D 
   360                                      blocks_label_len: equ $ - blocks_label
   361                                      
   362                                      ; Posición donde insertar los números en los labels
   363                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   364                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   365                                      
   366                                      ; Definición de las vidas (x, y, estado)
   367                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   368                                      lives_data: 
   369 00001614 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   370 00001617 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   371 0000161A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   372 0000161D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   373 00001620 0A1E01                          db 10, 30, 1    ; Vida 5 (inactiva)
   374 00001623 0C1E01                          db 12, 30, 1    ; Vida 6 (inactiva)
   375 00001626 0E1E01                          db 14, 30, 1    ; Vida 7 (inactiva)
   376                                      lives_count equ 7    ; Total de vidas
   377 00001629 5E                          life_char db "^"    
   378 0000162A 07                          current_lives db 7   ; Contador de vidas activas actual
   379                                  
   380                                  section .text
   381                                  
   382                                  ;	Function: print_ball
   383                                  ; This function displays the position of the ball
   384                                  ; Arguments: none
   385                                  ;
   386                                  ; Return:
   387                                  ;	Void
   388                                  
   389                                  ; Función para imprimir las vidas
   390                                  ; Función modificada para imprimir las vidas
   391                                  print_lives:
   392 000001DD 55                          push rbp
   393 000001DE 4889E5                      mov rbp, rsp
   394                                      
   395 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   396                                      
   397                                      .print_loop:
   398 000001E4 4983FC07                        cmp r12, lives_count
   399 000001E8 7D45                            jge .end
   400                                          
   401                                          ; Calcular offset de la vida actual
   402 000001EA 4C89E0                          mov rax, r12
   403 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   404 000001F1 488DB0[14160000]                lea rsi, [lives_data + rax]
   405                                          
   406                                          ; Calcular posición en el tablero
   407 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   408 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   409                                          
   410                                          ; Calcular offset en el tablero
   411 00000201 B84E000000                      mov rax, column_cells
   412 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   413 0000020A 49F7E1                          mul r9
   414 0000020D 4C01C0                          add rax, r8
   415 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   416                                          
   417                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   418 00000217 807E0201                        cmp byte [rsi + 2], 1
   419 0000021B 7405                            je .draw_active
   420                                          
   421                                          ; Si está inactiva, dibujar espacio
   422 0000021D C60720                          mov byte [rdi], ' '
   423 00000220 EB08                            jmp .next_life
   424                                          
   425                                      .draw_active:
   426                                          ; Si está activa, dibujar el símbolo de vida
   427 00000222 8A05(29160000)                  mov al, [life_char]
   428 00000228 8807                            mov [rdi], al
   429                                          
   430                                      .next_life:
   431 0000022A 49FFC4                          inc r12
   432 0000022D EBB5                            jmp .print_loop
   433                                          
   434                                      .end:
   435 0000022F 5D                              pop rbp
   436 00000230 C3                              ret
   437                                  
   438                                  ; Función para desactivar una vida
   439                                  ; Función modificada para perder una vida
   440                                  lose_life:
   441 00000231 55                          push rbp
   442 00000232 4889E5                      mov rbp, rsp
   443                                      
   444                                      ; Verificar si aún quedan vidas
   445 00000235 803D(2A160000)00            cmp byte [current_lives], 0
   446 0000023C 0F8493000000                je .game_lost
   447                                      
   448                                      ; Encontrar la última vida activa
   449 00000242 B907000000                  mov rcx, lives_count
   450 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   451                                      
   452                                      .find_active_life:
   453 0000024A 4889C8                          mov rax, rcx
   454 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   455 00000251 488DB0[14160000]                lea rsi, [lives_data + rax]
   456 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   457 0000025C 7407                            je .deactivate_life
   458 0000025E 48FFC9                          dec rcx
   459 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   460 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   461                                          
   462                                      .deactivate_life:
   463                                          ; Calcular posición correcta en el tablero para borrar la vida
   464 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   465 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   466                                          
   467                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   468 0000026E B84E000000                      mov rax, column_cells
   469 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   470 00000277 49F7E1                          mul r9
   471 0000027A 4C01C0                          add rax, r8
   472 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   473                                          
   474                                          ; Borrar visualmente la vida
   475 00000284 C60720                          mov byte [rdi], ' '             
   476                                          
   477                                          ; Desactivar la vida en los datos
   478 00000287 C6460200                        mov byte [rsi + 2], 0          
   479 0000028B FE0D(2A160000)                  dec byte [current_lives]
   480                                          
   481                                          ; Borrar visualmente la paleta anterior
   482 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   483 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   484                                          .erase_pallet_loop:
   485 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   486 000002A3 49FFC0                              inc r8
   487 000002A6 48FFC9                              dec rcx
   488 000002A9 75F4                                jnz .erase_pallet_loop
   489                                          
   490                                  
   491                                          ; Reiniciar posición de la bola y la paleta
   492 000002AB 48C705(4F140000)28-             mov qword [ball_x_pos], 40
   492 000002B3 000000             
   493 000002B6 48C705(57140000)1C-             mov qword [ball_y_pos], 28
   493 000002BE 000000             
   494 000002C1 C605(6F140000)00                mov byte [ball_moving], 0
   495 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   495 000002CF [36130000]         
   496                                          
   497 000002D3 EB07                            jmp .end
   498                                          
   499                                      .game_lost:
   500 000002D5 E81C000000                      call game_lost
   501 000002DA EB00                            jmp .end
   502                                          
   503                                      .end:
   504 000002DC 5D                              pop rbp
   505 000002DD C3                              ret
   506                                  ; Función modificada para verificar colisión con el borde inferior
   507                                  check_bottom_collision:
   508 000002DE 55                          push rbp
   509 000002DF 4889E5                      mov rbp, rsp
   510                                      
   511                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   512 000002E2 488B05(57140000)            mov rax, [ball_y_pos]
   513 000002E9 4883F81E                    cmp rax, row_cells - 2
   514 000002ED 7505                        jne .no_collision
   515                                      
   516                                      ; Si hay colisión, perder una vida
   517 000002EF E83DFFFFFF                  call lose_life
   518                                      
   519                                      .no_collision:
   520 000002F4 5D                              pop rbp
   521 000002F5 C3                              ret
   522                                  
   523                                  ; Nueva función para game over
   524                                  game_lost:
   525                                      ; Limpiar la pantalla
   526                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   527                                      
   528                                      ; Mostrar mensaje de derrota
   529                                      section .data
   530 0000162B C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   530 00001634 6469646F210A0D     
   531                                          lost_msg_len: equ $ - lost_msg
   532                                      section .text
   533                                      
   534                                      ; Imprimir mensaje de derrota
   535                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [2B16000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   536                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [5916000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   537                                      
   538                                      ; Mostrar puntaje final
   539 00000347 488B05(2D150000)            mov rax, [current_score]
   540 0000034E 48BF-                       mov rdi, number_buffer
   540 00000350 [3615000000000000] 
   541 00000358 E83E060000                  call number_to_string
   542                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [3615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   543                                      
   544                                      ; Esperar un momento antes de salir
   545 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   545 00000381 0000               
   546 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   546 0000038C 0000               
   547                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   548                                      
   549 000003A1 E9B70D0000                  jmp exit
   550                                  
   551                                  
   552                                  print_ball:
   553 000003A6 4C8B05(4F140000)        	mov r8, [ball_x_pos]
   554 000003AD 4C8B0D(57140000)        	mov r9, [ball_y_pos]
   555 000003B4 4981C0[000A0000]        	add r8, board
   556                                  
   557 000003BB 4C89C9                  	mov rcx, r9
   558 000003BE B850000000              	mov rax, column_cells + 2
   559 000003C3 48F7E9                  	imul rcx
   560                                  	
   561 000003C6 4901C0                  	add r8, rax
   562 000003C9 41C6004F                	mov byte [r8], char_O
   563 000003CD C3                      	ret
   564                                  
   565                                  	
   566                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   567                                  	
   568                                  
   569                                  
   570                                  
   571                                  ;	Function: print_pallet
   572                                  ; This function moves the pallet in the game
   573                                  ; Arguments: none
   574                                  ;
   575                                  ; Return;
   576                                  ;	void
   577                                  print_pallet:
   578 000003CE 4C8B05(3F140000)        	mov r8, [pallet_position]
   579 000003D5 488B0D(47140000)        	mov rcx, [pallet_size]
   580                                  	.write_pallet:
   581 000003DC 41C6003D                		mov byte [r8], char_equal
   582 000003E0 49FFC0                  		inc r8
   583 000003E3 48FFC9                  		dec rcx
   584 000003E6 75F4                    		jnz .write_pallet
   585                                  
   586 000003E8 C3                      	ret
   587                                  	
   588                                  ;	Function: move_pallet
   589                                  ; This function is in charge of moving the pallet in a given direction
   590                                  ; Arguments:
   591                                  ;	rdi: left direction or right direction
   592                                  ;
   593                                  ; Return:
   594                                  ;	void
   595                                  move_pallet:
   596                                      
   597 000003E9 803D(6F140000)00            cmp byte [ball_moving], 0
   598 000003F0 7507                        jne .continue_movement
   599 000003F2 C605(6F140000)01            mov byte [ball_moving], 1
   600                                  
   601                                      .continue_movement:
   602 000003F9 4883FFFF                        cmp rdi, left_direction
   603 000003FD 7531                            jne .move_right
   604                                  
   605                                          .move_left:
   606                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   607 000003FF 4C8B05(3F140000)                    mov r8, [pallet_position]
   608 00000406 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   609 00000409 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   610 0000040C 3C58                                cmp al, 'X'        ; Comparar si es una X
   611 0000040E 744D                                je .end            ; Si es X, no mover
   612                                              
   613 00000410 4C8B05(3F140000)                    mov r8, [pallet_position]
   614 00000417 4C8B0D(47140000)                    mov r9, [pallet_size]
   615 0000041E 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   616 00000424 49FFC8                              dec r8
   617 00000427 4C8905(3F140000)                    mov [pallet_position], r8
   618 0000042E EB2D                                jmp .end
   619                                              
   620                                          .move_right:
   621                                              ; Verificar si la siguiente posición después de la paleta sería una X
   622 00000430 4C8B05(3F140000)                    mov r8, [pallet_position]
   623 00000437 4C8B0D(47140000)                    mov r9, [pallet_size]
   624 0000043E 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   625 00000441 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   626 00000444 3C58                                cmp al, 'X'        ; Comparar si es una X
   627 00000446 7415                                je .end            ; Si es X, no mover
   628                                              
   629 00000448 4C8B05(3F140000)                    mov r8, [pallet_position]
   630 0000044F 41C60020                            mov byte [r8], char_space
   631 00000453 49FFC0                              inc r8
   632 00000456 4C8905(3F140000)                    mov [pallet_position], r8
   633                                          .end:
   634 0000045D C3                                  ret
   635                                  
   636                                  move_ball:
   637                                      ; Si la bola no está en movimiento, no hacer nada
   638 0000045E 803D(6F140000)00            cmp byte [ball_moving], 0
   639 00000465 0F8406010000                je .end
   640                                  
   641                                      ; Borrar la posición actual de la bola
   642 0000046B 4C8B05(4F140000)            mov r8, [ball_x_pos]
   643 00000472 4C8B0D(57140000)            mov r9, [ball_y_pos]
   644 00000479 4981C0[000A0000]            add r8, board
   645 00000480 4C89C9                      mov rcx, r9
   646 00000483 B850000000                  mov rax, column_cells + 2
   647 00000488 48F7E9                      imul rcx
   648 0000048B 4901C0                      add r8, rax
   649 0000048E 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   650                                  
   651                                      ; Calcular siguiente posición X
   652 00000492 4C8B05(4F140000)            mov r8, [ball_x_pos]
   653 00000499 4C8B0D(57140000)            mov r9, [ball_y_pos]
   654 000004A0 488B05(5F140000)            mov rax, [ball_direction_x]
   655 000004A7 4901C0                      add r8, rax                  ; Nueva posición X
   656                                  
   657                                      ; Calcular la dirección de memoria para la siguiente posición
   658 000004AA 4D89C2                      mov r10, r8
   659 000004AD 4981C2[000A0000]            add r10, board
   660 000004B4 4C89C9                      mov rcx, r9
   661 000004B7 B850000000                  mov rax, column_cells + 2
   662 000004BC 48F7E9                      imul rcx
   663 000004BF 4901C2                      add r10, rax
   664                                  
   665                                      ; Verificar si hay una X en la siguiente posición X
   666 000004C2 418A02                      mov al, [r10]
   667 000004C5 3C58                        cmp al, 'X'
   668 000004C7 750C                        jne .check_block_x
   669 000004C9 48F71D(5F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   670 000004D0 E99C000000                  jmp .end
   671                                  
   672                                      .check_block_x:
   673                                          ; Verificar colisión con bloques en X
   674 000004D5 4150                            push r8     ; Guardar registros que usa check_block_collision
   675 000004D7 4151                            push r9
   676 000004D9 4152                            push r10
   677 000004DB E813060000                      call check_block_collision
   678 000004E0 415A                            pop r10
   679 000004E2 4159                            pop r9
   680 000004E4 4158                            pop r8
   681 000004E6 4885C0                          test rax, rax
   682 000004E9 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   683 000004EB 48F71D(5F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   684 000004F2 EB7D                            jmp .end
   685                                  
   686                                      .check_paddle_x:
   687                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   688 000004F4 41803A3D                        cmp byte [r10], char_equal
   689 000004F8 7509                            jne .check_y_movement
   690 000004FA 48F71D(5F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   691 00000501 EB6E                            jmp .end
   692                                  
   693                                      .check_y_movement:
   694                                          ; Calcular siguiente posición Y
   695 00000503 488B05(67140000)                mov rax, [ball_direction_y]
   696 0000050A 4901C1                          add r9, rax                  ; Nueva posición Y
   697                                  
   698                                          ; Calcular la dirección de memoria para la siguiente posición Y
   699 0000050D 4D89C2                          mov r10, r8
   700 00000510 4981C2[000A0000]                add r10, board
   701 00000517 4C89C9                          mov rcx, r9
   702 0000051A B850000000                      mov rax, column_cells + 2
   703 0000051F 48F7E9                          imul rcx
   704 00000522 4901C2                          add r10, rax
   705                                  
   706                                          ; Verificar si hay una X en la siguiente posición Y
   707 00000525 418A02                          mov al, [r10]
   708 00000528 3C58                            cmp al, 'X'
   709 0000052A 7509                            jne .check_block_y
   710 0000052C 48F71D(67140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   711 00000533 EB3C                            jmp .end
   712                                  
   713                                      .check_block_y:
   714                                          ; Verificar colisión con bloques en Y
   715 00000535 4150                            push r8     ; Guardar registros que usa check_block_collision
   716 00000537 4151                            push r9
   717 00000539 4152                            push r10
   718 0000053B E8B3050000                      call check_block_collision
   719 00000540 415A                            pop r10
   720 00000542 4159                            pop r9
   721 00000544 4158                            pop r8
   722 00000546 4885C0                          test rax, rax
   723 00000549 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   724 0000054B 48F71D(67140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   725 00000552 EB1D                            jmp .end
   726                                  
   727                                      .check_paddle_y:
   728                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   729 00000554 41803A3D                    cmp byte [r10], char_equal
   730 00000558 7509                        jne .update_position
   731 0000055A 48F71D(67140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   732 00000561 EB0E                        jmp .end
   733                                  
   734                                  
   735                                      .update_position:
   736 00000563 4C8905(4F140000)                mov [ball_x_pos], r8
   737 0000056A 4C890D(57140000)                mov [ball_y_pos], r9
   738                                  
   739                                      .end:
   740 00000571 C3                              ret
   741                                  
   742                                  ; Función para inicializar el nivel
   743                                  ; Función para inicializar el nivel
   744                                  ; Función para mostrar el número de nivel
   745                                  display_level_number:
   746 00000572 55                          push rbp
   747 00000573 4889E5                      mov rbp, rsp
   748                                      
   749                                      ; Limpiar la pantalla primero
   750                                      print clear, clear_length
    82 00000576 B801000000          <1>  mov eax, sys_write
    83 0000057B BF01000000          <1>  mov edi, 1
    84 00000580 48BE-               <1>  mov rsi, %1
    84 00000582 [1000000000000000]  <1>
    85 0000058A BA07000000          <1>  mov edx, %2
    86 0000058F 0F05                <1>  syscall
   751                                      
   752                                      ; Calcular la posición central para el mensaje
   753                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
   754 00000591 B84E000000                  mov rax, column_cells
   755 00000596 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
   756 0000059A 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
   757                                      
   758                                      ; Calcular la fila central
   759 0000059D BB20000000                  mov rbx, row_cells
   760 000005A2 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
   761                                      
   762                                      ; Calcular el offset en el buffer
   763 000005A5 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
   764 000005AA 48F7E3                      mul rbx                     ; multiplicar por la fila central
   765 000005AD 4801D8                      add rax, rbx                ; añadir el offset horizontal
   766                                      
   767                                      ; Escribir "NIVEL " en la posición calculada
   768 000005B0 488DB8[000A0000]            lea rdi, [board + rax]
   769 000005B7 48BE-                       mov rsi, level_msg
   769 000005B9 [2414000000000000] 
   770 000005C1 B906000000                  mov rcx, level_msg_len
   771 000005C6 F3A4                        rep movsb
   772                                      
   773                                      ; Escribir el número del nivel
   774 000005C8 8A05(A4140000)              mov al, [current_level]
   775 000005CE 0430                        add al, '0'                 ; convertir a ASCII
   776 000005D0 8807                        mov [rdi], al
   777                                      
   778                                      ; Mostrar el board con el mensaje
   779                                      print board, board_size
    82 000005D2 B801000000          <1>  mov eax, sys_write
    83 000005D7 BF01000000          <1>  mov edi, 1
    84 000005DC 48BE-               <1>  mov rsi, %1
    84 000005DE [000A000000000000]  <1>
    85 000005E6 BA000A0000          <1>  mov edx, %2
    86 000005EB 0F05                <1>  syscall
   780                                      
   781                                      ; Esperar un segundo
   782 000005ED B823000000                  mov rax, sys_nanosleep
   783 000005F2 48BF-                       mov rdi, level_display_time
   783 000005F4 [2F14000000000000] 
   784 000005FC 4831F6                      xor rsi, rsi
   785 000005FF 0F05                        syscall
   786                                      
   787 00000601 5D                          pop rbp
   788 00000602 C3                          ret
   789                                  
   790                                  ; Función para inicializar un tablero vacío
   791                                  init_empty_board:
   792 00000603 56                          push rsi
   793 00000604 57                          push rdi
   794 00000605 51                          push rcx
   795 00000606 50                          push rax
   796                                  
   797 00000607 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
   798 0000060E 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
   799 00000615 B9000A0000                  mov rcx, board_template_size
   800 0000061A F3A4                        rep movsb                   ; Copiar el tablero
   801                                  
   802 0000061C 58                          pop rax
   803 0000061D 59                          pop rcx
   804 0000061E 5F                          pop rdi
   805 0000061F 5E                          pop rsi
   806 00000620 C3                          ret
   807                                  
   808                                  
   809                                  init_level:
   810                                      ; 1) Copiamos board_template en board para que quede "virgen"
   811 00000621 C605(35150000)00            mov byte [destroyed_blocks], 0 
   812 00000628 E8D6FFFFFF                  call init_empty_board
   813 0000062D E840FFFFFF                  call display_level_number
   814 00000632 E8D3050000                  call init_enemies
   815                                      
   816 00000637 56                          push rsi
   817 00000638 57                          push rdi
   818 00000639 51                          push rcx
   819 0000063A 50                          push rax
   820                                  
   821 0000063B 488D35(00000000)            lea rsi, [board_template]
   822 00000642 488D3D(000A0000)            lea rdi, [board]
   823 00000649 B9000A0000                  mov rcx, board_template_size
   824 0000064E F3A4                        rep movsb                 ; Copiamos la plantilla a board
   825                                  
   826 00000650 58                          pop rax
   827 00000651 59                          pop rcx
   828 00000652 5F                          pop rdi
   829 00000653 5E                          pop rsi
   830                                  
   831 00000654 B90A000000                  mov rcx, 10
   832 00000659 4831C0                      xor rax, rax
   833 0000065C 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
   834 00000663 F3AA                        rep stosb      
   835                                  
   836                                      ; Verificar el nivel actual y cargar los bloques correspondientes
   837 00000665 803D(A4140000)01            cmp byte [current_level], 1
   838 0000066C 7431                        je .level1
   839 0000066E 803D(A4140000)02            cmp byte [current_level], 2
   840 00000675 7454                        je .level2
   841 00000677 803D(A4140000)03            cmp byte [current_level], 3
   842 0000067E 7477                        je .level3
   843 00000680 803D(A4140000)04            cmp byte [current_level], 4
   844 00000687 0F8492000000                je .level4
   845 0000068D 803D(A4140000)05            cmp byte [current_level], 5
   846 00000694 0F84AD000000                je .level5
   847 0000069A E9D0000000                  jmp .done
   848                                  
   849                                  
   850                                  
   851                                      .level1:
   852 0000069F C605(A5140000)03                mov byte [blocks_remaining], level1_blocks_count
   853 000006A6 4831C9                          xor rcx, rcx             
   854                                          .init_loop1:
   855 000006A9 4883F903                            cmp rcx, level1_blocks_count
   856 000006AD 0F8DBC000000                        jge .done
   857 000006B3 4889C8                              mov rax, rcx         
   858 000006B6 486BC005                            imul rax, 5         ; en vez de shl rax,2
   859 000006BA 8A90[A9140000]                      mov dl, byte [level1_blocks + rax + 3]  
   860 000006C0 8891[C9140000]                      mov byte [block_states + rcx], dl
   861 000006C6 48FFC1                              inc rcx
   862 000006C9 EBDE                                jmp .init_loop1
   863                                  
   864                                      .level2:
   865 000006CB C605(A5140000)01                mov byte [blocks_remaining], level2_blocks_count
   866 000006D2 4831C9                          xor rcx, rcx             
   867                                          .init_loop2:
   868 000006D5 4883F901                            cmp rcx, level2_blocks_count
   869 000006D9 0F8D90000000                        jge .done
   870 000006DF 4889C8                              mov rax, rcx         
   871 000006E2 486BC005                            imul rax, 5         ; en vez de shl rax,2
   872 000006E6 8A90[B8140000]                      mov dl, byte [level2_blocks + rax + 3]  
   873 000006EC 8891[C9140000]                      mov byte [block_states + rcx], dl
   874 000006F2 48FFC1                              inc rcx
   875 000006F5 EBDE                                jmp .init_loop2
   876                                      .level3:
   877 000006F7 C605(A5140000)01                mov byte [blocks_remaining], level3_blocks_count
   878 000006FE 4831C9                          xor rcx, rcx             
   879                                          .init_loop3:
   880 00000701 4883F901                            cmp rcx, level3_blocks_count
   881 00000705 7D68                                jge .done
   882 00000707 4889C8                              mov rax, rcx         
   883 0000070A 486BC005                            imul rax, 5         ; en vez de shl rax,2
   884 0000070E 8A90[BD140000]                      mov dl, byte [level3_blocks + rax + 3]  
   885 00000714 8891[C9140000]                      mov byte [block_states + rcx], dl
   886 0000071A 48FFC1                              inc rcx
   887 0000071D EBE2                                jmp .init_loop3
   888                                  
   889                                      .level4:
   890 0000071F C605(A5140000)01                mov byte [blocks_remaining], level4_blocks_count
   891 00000726 4831C9                          xor rcx, rcx             
   892                                          .init_loop4:
   893 00000729 4883F901                            cmp rcx, level4_blocks_count
   894 0000072D 7D40                                jge .done
   895 0000072F 4889C8                              mov rax, rcx         
   896 00000732 486BC005                            imul rax, 5         ; en vez de shl rax,2
   897 00000736 8A90[C2140000]                      mov dl, byte [level4_blocks + rax + 3]  
   898 0000073C 8891[C9140000]                      mov byte [block_states + rcx], dl
   899 00000742 48FFC1                              inc rcx
   900 00000745 EBE2                                jmp .init_loop4
   901                                  
   902                                      .level5:
   903 00000747 C605(A5140000)01                mov byte [blocks_remaining], level5_blocks_count
   904 0000074E 4831C9                          xor rcx, rcx             
   905                                          .init_loop5:
   906 00000751 4883F901                            cmp rcx, level5_blocks_count
   907 00000755 7D18                                jge .done
   908 00000757 4889C8                              mov rax, rcx         
   909 0000075A 486BC005                            imul rax, 5         ; en vez de shl rax,2
   910 0000075E 8A90[C7140000]                      mov dl, byte [level5_blocks + rax + 3]  
   911 00000764 8891[C9140000]                      mov byte [block_states + rcx], dl
   912 0000076A 48FFC1                              inc rcx
   913 0000076D EBE2                                jmp .init_loop5
   914                                      .done:
   915 0000076F C3                              ret
   916                                  
   917                                  
   918                                  ; Función para verificar y manejar la transición de nivel
   919                                  check_level_complete:
   920                                      ; Verificar si quedan bloques
   921 00000770 803D(A5140000)00            cmp byte [blocks_remaining], 0
   922 00000777 753C                        jne .not_complete
   923                                      
   924                                      ; Incrementar el nivel
   925 00000779 FE05(A4140000)              inc byte [current_level]
   926                                      
   927                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
   928 0000077F 803D(A4140000)06            cmp byte [current_level], 6
   929 00000786 742E                        je game_win
   930                                      
   931                                      ; Reinicializar el juego para el siguiente nivel
   932 00000788 E894FEFFFF                  call init_level
   933                                      
   934                                      ; Reinicializar la posición de la bola y la paleta
   935 0000078D 48C705(4F140000)28-         mov qword [ball_x_pos], 40
   935 00000795 000000             
   936 00000798 48C705(57140000)1C-         mov qword [ball_y_pos], 28
   936 000007A0 000000             
   937 000007A3 C605(6F140000)00            mov byte [ball_moving], 0
   938 000007AA 48C705(3F140000)-           mov qword [pallet_position], board + 40 + 29 * (column_cells + 2)
   938 000007B1 [38130000]         
   939                                      
   940                                      .not_complete:
   941 000007B5 C3                              ret
   942                                  
   943                                      ; Nueva función para manejar la victoria del juego
   944                                  game_win:
   945                                      ; Limpiar la pantalla primero
   946                                      print clear, clear_length
    82 000007B6 B801000000          <1>  mov eax, sys_write
    83 000007BB BF01000000          <1>  mov edi, 1
    84 000007C0 48BE-               <1>  mov rsi, %1
    84 000007C2 [1000000000000000]  <1>
    85 000007CA BA07000000          <1>  mov edx, %2
    86 000007CF 0F05                <1>  syscall
   947                                      
   948                                      ; Mensaje de victoria
   949 000007D1 488B05(2D150000)            mov rax, [current_score]    ; Obtener el puntaje final
   950 000007D8 48BF-                       mov rdi, number_buffer      ; Convertir a string
   950 000007DA [3615000000000000] 
   951 000007E2 E8B4010000                  call number_to_string
   952                                      
   953                                      ; Definir mensaje de victoria
   954                                      section .data
   955 0000163B C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
   955 00001644 616465732120C2A148-
   955 0000164D 61732067616E61646F-
   955 00001656 210A0D             
   956                                          win_msg_len: equ $ - win_msg
   957 00001659 50756E74616A652066-             score_msg: db "Puntaje final: "
   957 00001662 696E616C3A20       
   958                                          score_msg_len: equ $ - score_msg
   959                                      section .text
   960                                      
   961                                      ; Imprimir mensajes
   962                                      print win_msg, win_msg_len
    82 000007E7 B801000000          <1>  mov eax, sys_write
    83 000007EC BF01000000          <1>  mov edi, 1
    84 000007F1 48BE-               <1>  mov rsi, %1
    84 000007F3 [3B16000000000000]  <1>
    85 000007FB BA1E000000          <1>  mov edx, %2
    86 00000800 0F05                <1>  syscall
   963                                      print score_msg, score_msg_len
    82 00000802 B801000000          <1>  mov eax, sys_write
    83 00000807 BF01000000          <1>  mov edi, 1
    84 0000080C 48BE-               <1>  mov rsi, %1
    84 0000080E [5916000000000000]  <1>
    85 00000816 BA0F000000          <1>  mov edx, %2
    86 0000081B 0F05                <1>  syscall
   964                                      print number_buffer, 20
    82 0000081D B801000000          <1>  mov eax, sys_write
    83 00000822 BF01000000          <1>  mov edi, 1
    84 00000827 48BE-               <1>  mov rsi, %1
    84 00000829 [3615000000000000]  <1>
    85 00000831 BA14000000          <1>  mov edx, %2
    86 00000836 0F05                <1>  syscall
   965                                      
   966                                      ; Esperar un momento antes de salir
   967 00000838 48C705BDF7FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   967 00000841 0000               
   968 00000843 48C705BAF7FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   968 0000084C 0000               
   969                                      sleeptime
    98 0000084E B823000000          <1>  mov eax, sys_nanosleep
    99 00000853 48BF-               <1>  mov rdi, timespec
    99 00000855 [0000000000000000]  <1>
   100 0000085D 31F6                <1>  xor esi, esi
   101 0000085F 0F05                <1>  syscall
   970                                      
   971 00000861 E9F7080000                  jmp exit
   972                                  
   973                                  ; Función para imprimir los bloques
   974                                  ; Función modificada para imprimir bloques
   975                                  
   976                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
   977                                  get_current_level_blocks:
   978 00000866 803D(A4140000)01            cmp byte [current_level], 1
   979 0000086D 7428                        je .level1
   980 0000086F 803D(A4140000)02            cmp byte [current_level], 2
   981 00000876 7427                        je .level2
   982 00000878 803D(A4140000)03            cmp byte [current_level], 3
   983 0000087F 7426                        je .level3
   984 00000881 803D(A4140000)04            cmp byte [current_level], 4
   985 00000888 7425                        je .level4
   986 0000088A 803D(A4140000)05            cmp byte [current_level], 5
   987 00000891 7424                        je .level5
   988                                      ; Si llegamos aquí, hay un error en el nivel
   989 00000893 4831C0                      xor rax, rax
   990 00000896 C3                          ret
   991                                  
   992                                      .level1:
   993 00000897 488D05(A6140000)                lea rax, [level1_blocks]
   994 0000089E C3                              ret
   995                                      .level2:
   996 0000089F 488D05(B5140000)                lea rax, [level2_blocks]
   997 000008A6 C3                              ret
   998                                      .level3:
   999 000008A7 488D05(BA140000)                lea rax, [level3_blocks]
  1000 000008AE C3                              ret
  1001                                      .level4:
  1002 000008AF 488D05(BF140000)                lea rax, [level4_blocks]
  1003 000008B6 C3                              ret
  1004                                      .level5:
  1005 000008B7 488D05(C4140000)                lea rax, [level5_blocks]
  1006 000008BE C3                              ret
  1007                                  ; Función para obtener la cantidad de bloques del nivel actual
  1008                                  get_current_level_count:
  1009 000008BF 803D(A4140000)01            cmp byte [current_level], 1
  1010 000008C6 7428                        je .level1
  1011 000008C8 803D(A4140000)02            cmp byte [current_level], 2
  1012 000008CF 7425                        je .level2
  1013 000008D1 803D(A4140000)03            cmp byte [current_level], 3
  1014 000008D8 7422                        je .level3
  1015 000008DA 803D(A4140000)04            cmp byte [current_level], 4
  1016 000008E1 741F                        je .level4
  1017 000008E3 803D(A4140000)05            cmp byte [current_level], 5
  1018 000008EA 741C                        je .level5
  1019                                      ; Si llegamos aquí, hay un error en el nivel
  1020 000008EC 4831C0                      xor rax, rax
  1021 000008EF C3                          ret
  1022                                  
  1023                                      .level1:
  1024 000008F0 B803000000                      mov rax, level1_blocks_count
  1025 000008F5 C3                              ret
  1026                                      .level2:
  1027 000008F6 B801000000                      mov rax, level2_blocks_count
  1028 000008FB C3                              ret
  1029                                      .level3:
  1030 000008FC B801000000                      mov rax, level3_blocks_count
  1031 00000901 C3                              ret
  1032                                      .level4:
  1033 00000902 B801000000                      mov rax, level4_blocks_count
  1034 00000907 C3                              ret
  1035                                      .level5:
  1036 00000908 B801000000                      mov rax, level5_blocks_count
  1037 0000090D C3                              ret
  1038                                  
  1039                                  
  1040                                  print_blocks:
  1041 0000090E 55                          push rbp
  1042 0000090F 4889E5                      mov rbp, rsp
  1043                                      
  1044                                      ; Obtener puntero a los bloques del nivel actual
  1045 00000912 E84FFFFFFF                  call get_current_level_blocks
  1046 00000917 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1047                                      
  1048                                      ; Obtener cantidad de bloques del nivel actual
  1049 0000091A E8A0FFFFFF                  call get_current_level_count
  1050 0000091F 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1051                                      
  1052 00000922 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1053                                      
  1054                                      .print_loop:
  1055 00000925 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1056 00000928 7D6F                            jge .end
  1057                                          
  1058                                          ; Verificar si el bloque está activo
  1059 0000092A 490FB68424-                     movzx rax, byte [block_states + r12]
  1059 0000092F [C9140000]         
  1060 00000933 4885C0                          test rax, rax
  1061 00000936 745C                            jz .next_block
  1062                                          
  1063                                          ; Obtener posición y tipo del bloque usando r13
  1064 00000938 4C89E0                          mov rax, r12
  1065 0000093B 486BC005                        imul rax, 5
  1066 0000093F 4C01E8                          add rax, r13
  1067 00000942 448A00                          mov r8b, [rax]        ; X position
  1068 00000945 448A4801                        mov r9b, [rax + 1]    ; Y position
  1069 00000949 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1070                                  
  1071                                          ; El resto de la lógica de impresión permanece igual
  1072 0000094D 4D0FB6C0                        movzx r8, r8b
  1073 00000951 4D0FB6C9                        movzx r9, r9b
  1074 00000955 4981C0[000A0000]                add r8, board
  1075 0000095C B850000000                      mov rax, column_cells + 2
  1076 00000961 49F7E1                          mul r9
  1077 00000964 4901C0                          add r8, rax
  1078                                          
  1079 00000967 B906000000                      mov rcx, block_length
  1080 0000096C 48BE-                           mov rsi, block_type_1
  1080 0000096E [8014000000000000] 
  1081 00000976 490FB6C2                        movzx rax, r10b
  1082 0000097A 48FFC8                          dec rax
  1083 0000097D 486BC006                        imul rax, block_length
  1084 00000981 4801C6                          add rsi, rax
  1085                                          
  1086                                      .print_block_chars:
  1087 00000984 8A06                            mov al, [rsi]
  1088 00000986 418800                          mov [r8], al
  1089 00000989 48FFC6                          inc rsi
  1090 0000098C 49FFC0                          inc r8
  1091 0000098F 48FFC9                          dec rcx
  1092 00000992 75F0                            jnz .print_block_chars
  1093                                          
  1094                                      .next_block:
  1095 00000994 49FFC4                          inc r12
  1096 00000997 EB8C                            jmp .print_loop
  1097                                          
  1098                                      .end:
  1099 00000999 5D                              pop rbp
  1100 0000099A C3                              ret
  1101                                  
  1102                                  ; Función para convertir número a string
  1103                                  ; Input: RAX = número a convertir
  1104                                  ; RDI = buffer donde escribir el string
  1105                                  number_to_string:
  1106 0000099B 53                          push rbx
  1107 0000099C 52                          push rdx
  1108 0000099D 56                          push rsi
  1109 0000099E BB0A000000                  mov rbx, 10          ; Divisor
  1110 000009A3 B900000000                  mov rcx, 0          ; Contador de dígitos
  1111                                      
  1112                                      ; Si el número es 0, manejarlo especialmente
  1113 000009A8 4885C0                      test rax, rax
  1114 000009AB 7509                        jnz .convert_loop
  1115 000009AD C60730                      mov byte [rdi], '0'
  1116 000009B0 C6470100                    mov byte [rdi + 1], 0
  1117 000009B4 EB20                        jmp .end
  1118                                      
  1119                                      .convert_loop:
  1120 000009B6 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1121 000009B9 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1122 000009BC 80C230                          add dl, '0'     ; Convertir a ASCII
  1123 000009BF 52                              push rdx        ; Guardar el dígito
  1124 000009C0 48FFC1                          inc rcx         ; Incrementar contador
  1125 000009C3 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1126 000009C6 75EE                            jnz .convert_loop
  1127                                          
  1128                                      .write_loop:
  1129 000009C8 5A                              pop rdx         ; Obtener dígito
  1130 000009C9 8817                            mov [rdi], dl   ; Escribir al buffer
  1131 000009CB 48FFC7                          inc rdi         ; Siguiente posición
  1132 000009CE 48FFC9                          dec rcx         ; Decrementar contador
  1133 000009D1 75F5                            jnz .write_loop
  1134                                          
  1135 000009D3 C60700                      mov byte [rdi], 0   ; Null terminator
  1136                                      
  1137                                      .end:
  1138 000009D6 5E                          pop rsi
  1139 000009D7 5A                          pop rdx
  1140 000009D8 5B                          pop rbx
  1141 000009D9 C3                          ret
  1142                                  
  1143                                  ; Función para imprimir los labels
  1144                                  print_labels:
  1145 000009DA 55                          push rbp
  1146 000009DB 4889E5                      mov rbp, rsp
  1147                                  
  1148                                      ; Crear buffer temporal
  1149 000009DE 4883EC20                    sub rsp, 32
  1150                                  
  1151                                      ; Copiar labels a buffer temporal
  1152 000009E2 4889E7                      mov rdi, rsp
  1153 000009E5 488D35(E2150000)            lea rsi, [score_label]
  1154 000009EC B917000000                  mov rcx, score_label_len
  1155 000009F1 F3A4                        rep movsb
  1156                                  
  1157                                      ; Convertir score a string
  1158 000009F3 488B05(2D150000)            mov rax, [current_score]
  1159 000009FA 48BF-                       mov rdi, number_buffer
  1159 000009FC [3615000000000000] 
  1160 00000A04 E892FFFFFF                  call number_to_string
  1161                                  
  1162                                      ; Calcular longitud del número
  1163 00000A09 B900000000                  mov rcx, 0
  1164 00000A0E 48BF-                       mov rdi, number_buffer
  1164 00000A10 [3615000000000000] 
  1165                                      .count_loop:
  1166 00000A18 803C0F00                        cmp byte [rdi + rcx], 0
  1167 00000A1C 7405                            je .count_done
  1168 00000A1E 48FFC1                          inc rcx
  1169 00000A21 EBF5                            jmp .count_loop
  1170                                      .count_done:
  1171                                  
  1172                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1173 00000A23 4889E7                      mov rdi, rsp
  1174 00000A26 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1175 00000A2A BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1176 00000A2F 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1177                                      .pad_loop:
  1178 00000A32 4885F6                          test rsi, rsi
  1179 00000A35 740B                            jz .pad_done
  1180 00000A37 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1181 00000A3A 48FFC7                          inc rdi
  1182 00000A3D 48FFCE                          dec rsi
  1183 00000A40 EBF0                            jmp .pad_loop
  1184                                      .pad_done:
  1185                                  
  1186                                      ; Copiar el número
  1187 00000A42 48BE-                       mov rsi, number_buffer
  1187 00000A44 [3615000000000000] 
  1188 00000A4C F3A4                        rep movsb
  1189                                  
  1190                                      ; Imprimir el buffer completo
  1191                                      print rsp, score_label_len
    82 00000A4E B801000000          <1>  mov eax, sys_write
    83 00000A53 BF01000000          <1>  mov edi, 1
    84 00000A58 4889E6              <1>  mov rsi, %1
    85 00000A5B BA17000000          <1>  mov edx, %2
    86 00000A60 0F05                <1>  syscall
  1192                                  
  1193                                      ; Repetir proceso para bloques destruidos
  1194 00000A62 4889E7                      mov rdi, rsp
  1195 00000A65 488D35(F9150000)            lea rsi, [blocks_label]
  1196 00000A6C B91B000000                  mov rcx, blocks_label_len
  1197 00000A71 F3A4                        rep movsb
  1198                                  
  1199                                      ; Verificar que el `[` esté en su posición correcta
  1200 00000A73 4889E7                      mov rdi, rsp
  1201 00000A76 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1202 00000A7A C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1203                                  
  1204                                      ; Convertir bloques destruidos a string
  1205 00000A7D 480FB605(35150000)          movzx rax, byte [destroyed_blocks]
  1206 00000A85 48BF-                       mov rdi, number_buffer
  1206 00000A87 [3615000000000000] 
  1207 00000A8F E807FFFFFF                  call number_to_string
  1208                                  
  1209                                      ; Calcular longitud del número
  1210 00000A94 B900000000                  mov rcx, 0
  1211 00000A99 48BF-                       mov rdi, number_buffer
  1211 00000A9B [3615000000000000] 
  1212                                      .count_loop2:
  1213 00000AA3 803C0F00                        cmp byte [rdi + rcx], 0
  1214 00000AA7 7405                            je .count_done2
  1215 00000AA9 48FFC1                          inc rcx
  1216 00000AAC EBF5                            jmp .count_loop2
  1217                                      .count_done2:
  1218                                  
  1219                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1220 00000AAE 4889E7                      mov rdi, rsp
  1221 00000AB1 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1222 00000AB5 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1223 00000ABA 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1224                                      .pad_loop2:
  1225 00000ABD 4885F6                          test rsi, rsi
  1226 00000AC0 740B                            jz .pad_done2
  1227 00000AC2 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1228 00000AC5 48FFC7                          inc rdi
  1229 00000AC8 48FFCE                          dec rsi
  1230 00000ACB EBF0                            jmp .pad_loop2
  1231                                      .pad_done2:
  1232                                  
  1233                                      ; Copiar el número
  1234 00000ACD 48BE-                       mov rsi, number_buffer
  1234 00000ACF [3615000000000000] 
  1235 00000AD7 F3A4                        rep movsb
  1236                                  
  1237                                      ; Imprimir el buffer completo
  1238                                      print rsp, blocks_label_len
    82 00000AD9 B801000000          <1>  mov eax, sys_write
    83 00000ADE BF01000000          <1>  mov edi, 1
    84 00000AE3 4889E6              <1>  mov rsi, %1
    85 00000AE6 BA1B000000          <1>  mov edx, %2
    86 00000AEB 0F05                <1>  syscall
  1239                                  
  1240                                      ; Restaurar stack
  1241 00000AED 4883C420                    add rsp, 32
  1242 00000AF1 5D                          pop rbp
  1243 00000AF2 C3                          ret
  1244                                  
  1245                                  
  1246                                  ; Función modificada para detectar colisión
  1247                                  ; Función mejorada para detectar colisión y manejar la física
  1248                                  ; Función corregida para manejar colisiones con bloques completos
  1249                                  ;---------------------------------------------------------
  1250                                  ; check_block_collision:
  1251                                  ;   Detecta si en la posición r10 (que apunta a board[])
  1252                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
  1253                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
  1254                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
  1255                                  ;   retorna 0.
  1256                                  ;---------------------------------------------------------
  1257                                  ;--------------------------------------
  1258                                  ; check_block_collision
  1259                                  ;--------------------------------------
  1260                                  ; Actualizar check_block_collision para usar el nivel actual
  1261                                  check_block_collision:
  1262 00000AF3 55                          push rbp
  1263 00000AF4 4889E5                      mov rbp, rsp
  1264                                  
  1265                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1266 00000AF7 418A02                      mov al, [r10]
  1267                                  
  1268                                      ; Verificar si el carácter es un bloque
  1269 00000AFA 3C55                        cmp al, 'U'  
  1270 00000AFC 7419                        je .possible
  1271 00000AFE 3C4F                        cmp al, 'O'  
  1272 00000B00 7415                        je .possible
  1273 00000B02 3C44                        cmp al, 'D'  
  1274 00000B04 7411                        je .possible
  1275 00000B06 3C4C                        cmp al, 'L'  
  1276 00000B08 740D                        je .possible
  1277 00000B0A 3C56                        cmp al, 'V'  
  1278 00000B0C 7409                        je .possible
  1279 00000B0E 3C38                        cmp al, '8'  
  1280 00000B10 7405                        je .possible
  1281                                  
  1282                                      ; No es bloque, salir
  1283 00000B12 4831C0                      xor rax, rax
  1284 00000B15 5D                          pop rbp
  1285 00000B16 C3                          ret
  1286                                  
  1287                                  .possible:
  1288 00000B17 53                          push rbx
  1289 00000B18 57                          push rdi
  1290 00000B19 56                          push rsi
  1291 00000B1A 4154                        push r12
  1292 00000B1C 4155                        push r13
  1293 00000B1E 4156                        push r14
  1294 00000B20 4157                        push r15
  1295                                  
  1296                                      ; 1) Obtener base de los bloques del nivel actual
  1297 00000B22 E83FFDFFFF                  call get_current_level_blocks
  1298 00000B27 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1299                                  
  1300                                      ; 2) Obtener la cantidad de bloques
  1301 00000B2A E890FDFFFF                  call get_current_level_count
  1302 00000B2F 4989C6                      mov r14, rax
  1303                                  
  1304 00000B32 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1305                                  
  1306                                  .find_block_loop:
  1307 00000B35 4D39F4                      cmp r12, r14
  1308 00000B38 0F8DBC000000                jge .no_block_found  ; Se acabaron los bloques
  1309                                  
  1310                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1311 00000B3E 4C89E0                      mov rax, r12
  1312 00000B41 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1313 00000B45 4C01E8                      add rax, r13
  1314 00000B48 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1315                                  
  1316                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1317 00000B4B 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1317 00000B50 [C9140000]         
  1318 00000B54 4885DB                      test rbx, rbx
  1319 00000B57 0F8495000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1320                                  
  1321                                      ; Obtener coordenadas
  1322 00000B5D 418A17                      mov dl, [r15]         ; x
  1323 00000B60 418A4F01                    mov cl, [r15 + 1]     ; y
  1324                                  
  1325                                      ; Calcular posición en el board
  1326 00000B64 488D3D(000A0000)            lea rdi, [board]
  1327 00000B6B 4831C0                      xor rax, rax
  1328 00000B6E B84E000000                  mov rax, column_cells
  1329 00000B73 4883C002                    add rax, 2
  1330 00000B77 480FB6C9                    movzx rcx, cl         ; y
  1331 00000B7B 480FAFC1                    imul rax, rcx
  1332 00000B7F 4801C7                      add rdi, rax
  1333 00000B82 480FB6C2                    movzx rax, dl         ; x
  1334 00000B86 4801C7                      add rdi, rax
  1335                                  
  1336                                      ; Guardar la posición base del bloque
  1337 00000B89 57                          push rdi
  1338                                  
  1339                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1340 00000B8A 4939FA                      cmp r10, rdi
  1341 00000B8D 7262                        jb .skip_collision
  1342 00000B8F 488D5F06                    lea rbx, [rdi + block_length]
  1343 00000B93 4939DA                      cmp r10, rbx
  1344 00000B96 7359                        jae .skip_collision
  1345                                  
  1346                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1347 00000B98 41FE8C24[C9140000]          dec byte [block_states + r12]
  1348                                      ; Volver a cargar durabilidad
  1349 00000BA0 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1349 00000BA5 [C9140000]         
  1350 00000BA9 4885DB                      test rbx, rbx
  1351 00000BAC 753B                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1352                                  
  1353                                      ; >>> Llegó a 0 => Bloque destruido
  1354 00000BAE 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1355 00000BAF B906000000                  mov rcx, block_length
  1356                                  .clear_loop:
  1357 00000BB4 C60720                      mov byte [rdi], ' '
  1358 00000BB7 48FFC7                      inc rdi
  1359 00000BBA E2F8                        loop .clear_loop
  1360                                  
  1361                                      ; Dibujar letra del bloque destruido
  1362 00000BBC 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1363 00000BC0 4883EF06                    sub rdi, block_length
  1364 00000BC4 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1365                                  
  1366                                      ; Actualizar contadores globales
  1367 00000BC6 FE0D(A5140000)              dec byte [blocks_remaining]
  1368 00000BCC FE05(35150000)              inc byte [destroyed_blocks]
  1369                                  
  1370                                      ; Sumar puntos según el tipo
  1371 00000BD2 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1372 00000BD7 486BC00A                    imul rax, 10
  1373 00000BDB 480105(2D150000)            add [current_score], rax
  1374                                  
  1375 00000BE2 B801000000                  mov rax, 1  ; colisión con destrucción
  1376 00000BE7 EB14                        jmp .end_pop
  1377                                  
  1378                                  .update_display:
  1379                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1380 00000BE9 B801000000                  mov rax, 1  ; colisión con "rebote"  
  1381 00000BEE 5F                          pop rdi     ; pop que quedó pendiente
  1382 00000BEF EB0C                        jmp .end_pop
  1383                                  
  1384                                  .skip_collision:
  1385 00000BF1 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1386                                  .next_block:
  1387 00000BF2 49FFC4                      inc r12
  1388 00000BF5 E93BFFFFFF                  jmp .find_block_loop
  1389                                  
  1390                                  .no_block_found:
  1391 00000BFA 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1392                                  
  1393                                  .end_pop:
  1394 00000BFD 415F                        pop r15
  1395 00000BFF 415E                        pop r14
  1396 00000C01 415D                        pop r13
  1397 00000C03 415C                        pop r12
  1398 00000C05 5E                          pop rsi
  1399 00000C06 5F                          pop rdi
  1400 00000C07 5B                          pop rbx
  1401 00000C08 5D                          pop rbp
  1402 00000C09 C3                          ret
  1403                                  
  1404                                  
  1405                                  
  1406                                  init_enemies:
  1407 00000C0A 55                          push rbp
  1408 00000C0B 4889E5                      mov rbp, rsp
  1409                                      ; Reiniciar contadores de movimiento
  1410 00000C0E C605(78150000)00            mov byte [enemy_move_total], 0
  1411 00000C15 C605(79150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1412                                      ; Limpiar estado previo de enemigos
  1413 00000C1C B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1414 00000C21 488D3D(4F150000)            lea rdi, [enemies]
  1415 00000C28 30C0                        xor al, al
  1416 00000C2A F3AA                        rep stosb ; Limpiar datos de enemigos
  1417                                      
  1418                                      ; Marcar todos los enemigos como inactivos
  1419 00000C2C 488D3D(D8150000)            lea rdi, [enemy_spawns_triggered]
  1420 00000C33 30C0                        xor al, al
  1421 00000C35 B90A000000                  mov rcx, 10
  1422 00000C3A F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1423                                  
  1424 00000C3C 5D                          pop rbp
  1425 00000C3D C3                          ret
  1426                                  
  1427                                  
  1428                                  ; Función para mover enemigos
  1429                                  move_enemies:
  1430 00000C3E 55                          push rbp
  1431 00000C3F 4889E5                      mov rbp, rsp
  1432                                      
  1433                                      ; Incrementar contador de movimiento
  1434 00000C42 FE05(76150000)              inc byte [enemy_move_counter]
  1435 00000C48 480FB605(76150000)          movzx rax, byte [enemy_move_counter]
  1436 00000C50 3A05(77150000)              cmp al, [enemy_move_delay]
  1437 00000C56 0F85AA010000                jne .end
  1438                                      
  1439                                      ; Resetear contador
  1440 00000C5C C605(76150000)00            mov byte [enemy_move_counter], 0
  1441                                      
  1442 00000C63 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1443                                      
  1444                                      .enemy_loop:
  1445 00000C66 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1446 00000C6A 0F8D96010000                    jge .end
  1447                                          
  1448                                          ; Calcular offset del enemigo actual
  1449 00000C70 4C89E0                          mov rax, r12
  1450 00000C73 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1451 00000C77 488DB0[4F150000]                lea rsi, [enemies + rax]
  1452                                          
  1453                                          ; Verificar si el enemigo está activo
  1454 00000C7E 807E0201                        cmp byte [rsi + 2], 1
  1455 00000C82 0F8576010000                    jne .next_enemy
  1456                                          
  1457                                          ; Obtener posición actual
  1458 00000C88 4C0FB606                        movzx r8, byte [rsi]            ; X
  1459 00000C8C 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1460                                          
  1461                                          ; Limpiar posición actual antes de mover
  1462 00000C91 4150                            push r8
  1463 00000C93 4151                            push r9
  1464 00000C95 B84E000000                      mov rax, column_cells
  1465 00000C9A 4883C002                        add rax, 2
  1466 00000C9E 49F7E1                          mul r9
  1467 00000CA1 4C01C0                          add rax, r8
  1468 00000CA4 488DB8[000A0000]                lea rdi, [board + rax]
  1469 00000CAB C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1470 00000CAE 4159                            pop r9
  1471 00000CB0 4158                            pop r8
  1472                                  
  1473                                          ; Determinar comportamiento basado en índice
  1474 00000CB2 4C89E0                          mov rax, r12
  1475 00000CB5 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1476 00000CB9 4885C0                          test rax, rax
  1477 00000CBC 7402                            jz .chase_ball
  1478 00000CBE EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1479                                          
  1480                                          ; Perseguir bola (comportamiento original)
  1481                                      .chase_ball:
  1482 00000CC0 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1483 00000CC7 4D39D0                          cmp r8, r10
  1484 00000CCA 0F8F96000000                    jg .move_left
  1485 00000CD0 0F8C95000000                    jl .move_right
  1486                                          
  1487 00000CD6 4C8B15(57140000)                mov r10, [ball_y_pos]
  1488 00000CDD 4D39D1                          cmp r9, r10
  1489 00000CE0 0F8F8A000000                    jg .move_up
  1490 00000CE6 0F8C89000000                    jl .move_down
  1491 00000CEC E9A5000000                      jmp .check_collision
  1492                                          
  1493                                      .chase_paddle:
  1494                                          ; Obtener la posición X actual de la paleta
  1495 00000CF1 4C8B15(3F140000)                mov r10, [pallet_position]
  1496 00000CF8 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1497                                          
  1498                                          ; Calcular la posición X real de la paleta
  1499 00000CFF 4C89D0                          mov rax, r10
  1500 00000D02 BB4E000000                      mov rbx, column_cells
  1501 00000D07 4883C302                        add rbx, 2                  ; Añadir newline chars
  1502 00000D0B 4831D2                          xor rdx, rdx
  1503 00000D0E 48F7F3                          div rbx                     ; rax = y, rdx = x
  1504                                          
  1505                                          ; rdx ahora contiene la posición X de la paleta
  1506                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1507 00000D11 488B0D(47140000)                mov rcx, [pallet_size]
  1508 00000D18 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1509 00000D1B 4801CA                          add rdx, rcx
  1510                                          
  1511                                          ; Comparar con posición X del enemigo y mover gradualmente
  1512 00000D1E 4939D0                          cmp r8, rdx
  1513 00000D21 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1514 00000D23 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1515 00000D25 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1516                                  
  1517                                      .check_y_paddle:
  1518                                          ; La Y de la paleta siempre es row_cells - 2
  1519 00000D27 41BA20000000                    mov r10, row_cells
  1520 00000D2D 4983EA02                        sub r10, 2
  1521                                          
  1522                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1523 00000D31 4D39D1                          cmp r9, r10
  1524 00000D34 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1525 00000D36 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1526 00000D38 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1527                                          
  1528                                      .no_movement:
  1529 00000D3A EB5A                            jmp .check_collision
  1530                                  
  1531                                      ; También agregar una nueva sección para el movimiento suave
  1532                                      .smooth_transition:
  1533                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1534 00000D3C 8A05(79150000)                  mov al, [enemy_target]
  1535 00000D42 84C0                            test al, al
  1536 00000D44 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1537                                          
  1538                                          ; Verificar distancia en X
  1539 00000D46 4989D2                          mov r10, rdx              ; Posición X objetivo
  1540 00000D49 4D29C2                          sub r10, r8               ; Calcular diferencia
  1541 00000D4C 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1542 00000D50 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1543 00000D52 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1544 00000D56 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1545 00000D58 EB3C                            jmp .check_collision
  1546                                          
  1547                                      .limit_right_movement:
  1548 00000D5A 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1549 00000D5E EB36                            jmp .check_collision
  1550                                          
  1551                                      .limit_left_movement:
  1552 00000D60 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1553 00000D64 EB30                            jmp .check_collision
  1554                                      .move_left:
  1555 00000D66 49FFC8                          dec r8
  1556 00000D69 EB0F                            jmp .check_vertical
  1557                                          
  1558                                      .move_right:
  1559 00000D6B 49FFC0                          inc r8
  1560 00000D6E EB0A                            jmp .check_vertical
  1561                                          
  1562                                      .move_up:
  1563 00000D70 49FFC9                          dec r9
  1564 00000D73 EB21                            jmp .check_collision
  1565                                          
  1566                                      .move_down:
  1567 00000D75 49FFC1                          inc r9
  1568 00000D78 EB1C                            jmp .check_collision
  1569                                          
  1570                                      .check_vertical:
  1571 00000D7A 8A05(79150000)                  mov al, [enemy_target]
  1572 00000D80 84C0                            test al, al
  1573 00000D82 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1574 00000D88 4C8B15(57140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1575 00000D8F 4D39D1                          cmp r9, r10
  1576 00000D92 7FDC                            jg .move_up
  1577 00000D94 7CDF                            jl .move_down
  1578                                          
  1579                                      .check_collision:
  1580                                          ; Verificar colisión con bordes
  1581 00000D96 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1582 00000D9A 7E62                            jle .next_enemy
  1583 00000D9C 4983F84E                        cmp r8, column_cells
  1584 00000DA0 7D5C                            jge .next_enemy
  1585 00000DA2 4983F901                        cmp r9, 1                       ; Borde superior
  1586 00000DA6 7E56                            jle .next_enemy
  1587 00000DA8 4983F920                        cmp r9, row_cells
  1588 00000DAC 7D50                            jge .next_enemy
  1589                                          
  1590                                          ; Verificar colisión con bloques antes de moverse
  1591 00000DAE 4150                            push r8
  1592 00000DB0 4151                            push r9
  1593 00000DB2 4152                            push r10
  1594                                          
  1595                                          ; Calcular posición en el tablero para verificar
  1596 00000DB4 B84E000000                      mov rax, column_cells
  1597 00000DB9 4883C002                        add rax, 2
  1598 00000DBD 49F7E1                          mul r9
  1599 00000DC0 4C01C0                          add rax, r8
  1600 00000DC3 4C8D90[000A0000]                lea r10, [board + rax]
  1601                                          
  1602                                          ; Verificar si hay un bloque en la nueva posición
  1603 00000DCA 418A02                          mov al, [r10]
  1604 00000DCD 3C55                            cmp al, 'U'
  1605 00000DCF 7427                            je .invalid_move
  1606 00000DD1 3C4F                            cmp al, 'O'
  1607 00000DD3 7423                            je .invalid_move
  1608 00000DD5 3C44                            cmp al, 'D'
  1609 00000DD7 741F                            je .invalid_move
  1610 00000DD9 3C4C                            cmp al, 'L'
  1611 00000DDB 741B                            je .invalid_move
  1612 00000DDD 3C56                            cmp al, 'V'
  1613 00000DDF 7417                            je .invalid_move
  1614 00000DE1 3C38                            cmp al, '8'
  1615 00000DE3 7413                            je .invalid_move
  1616 00000DE5 3C58                            cmp al, 'X'
  1617 00000DE7 740F                            je .invalid_move
  1618                                          
  1619 00000DE9 415A                            pop r10
  1620 00000DEB 4159                            pop r9
  1621 00000DED 4158                            pop r8
  1622                                          
  1623                                          ; Guardar nueva posición si es válida
  1624 00000DEF 448806                          mov [rsi], r8b
  1625 00000DF2 44884E01                        mov [rsi + 1], r9b
  1626 00000DF6 EB06                            jmp .next_enemy
  1627                                          
  1628                                      .invalid_move:
  1629 00000DF8 415A                            pop r10
  1630 00000DFA 4159                            pop r9
  1631 00000DFC 4158                            pop r8
  1632                                          
  1633                                      .next_enemy:
  1634 00000DFE 49FFC4                          inc r12
  1635 00000E01 E960FEFFFF                      jmp .enemy_loop
  1636                                          
  1637                                      .end:
  1638 00000E06 5D                              pop rbp
  1639 00000E07 C3                              ret
  1640                                  
  1641                                  get_current_spawn_points:
  1642 00000E08 55                          push rbp
  1643 00000E09 4889E5                      mov rbp, rsp
  1644                                      
  1645 00000E0C 480FB605(A4140000)          movzx rax, byte [current_level]
  1646 00000E14 48FFC8                      dec rax                         ; Ajustar para índice base 0
  1647 00000E17 488B04C5[AD150000]          mov rax, [spawn_points_table + rax * 8]
  1648                                      
  1649 00000E1F 5D                          pop rbp
  1650 00000E20 C3                          ret
  1651                                  
  1652                                  ; Función para verificar si debe aparecer un nuevo enemigo
  1653                                  check_enemy_spawn:
  1654 00000E21 55                          push rbp
  1655 00000E22 4889E5                      mov rbp, rsp
  1656                                      
  1657                                      ; Obtener spawn points del nivel actual
  1658 00000E25 E8DEFFFFFF                  call get_current_spawn_points
  1659 00000E2A 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  1660                                      
  1661                                      ; Obtener cantidad de bloques destruidos
  1662 00000E2D 4C0FB62D(35150000)          movzx r13, byte [destroyed_blocks]
  1663                                      
  1664                                      ; Verificar cada punto de spawn
  1665 00000E35 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  1666                                      
  1667                                      .check_loop:
  1668 00000E38 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  1669 00000E3C 7D4B                            jge .end
  1670                                          
  1671                                          ; Verificar si este spawn point ya fue usado
  1672 00000E3E 80B9[D8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  1673 00000E45 743D                            je .next_enemy
  1674                                          
  1675                                          ; Verificar si este enemigo ya está activo
  1676 00000E47 4889C8                          mov rax, rcx
  1677 00000E4A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1678 00000E4E 488DB0[4F150000]                lea rsi, [enemies + rax]
  1679 00000E55 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  1680 00000E59 7429                            je .next_enemy
  1681                                          
  1682                                          ; Verificar si debemos spawnear este enemigo
  1683 00000E5B 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  1684 00000E60 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  1685 00000E63 751F                            jne .next_enemy
  1686                                          
  1687                                          ; Marcar este spawn point como usado
  1688 00000E65 C681[D8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  1689                                          
  1690                                          ; Spawner nuevo enemigo
  1691 00000E6C C60628                          mov byte [rsi], 40             ; X inicial
  1692 00000E6F C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  1693 00000E73 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  1694                                          
  1695                                          ; Inicializar comportamiento
  1696 00000E77 4889C8                          mov rax, rcx
  1697 00000E7A 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  1698 00000E7E 8805(D7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  1699                                          
  1700                                      .next_enemy:
  1701 00000E84 48FFC1                          inc rcx
  1702 00000E87 EBAF                            jmp .check_loop
  1703                                          
  1704                                      .end:
  1705 00000E89 5D                              pop rbp
  1706 00000E8A C3                              ret
  1707                                  
  1708                                  
  1709                                  ; Función para dibujar enemigos
  1710                                  print_enemies:
  1711 00000E8B 55                          push rbp
  1712 00000E8C 4889E5                      mov rbp, rsp
  1713                                      
  1714 00000E8F 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1715                                      
  1716                                      .print_loop:
  1717 00000E92 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  1718 00000E96 7D4B                            jge .end
  1719                                          
  1720                                          ; Calcular offset del enemigo actual
  1721 00000E98 4C89E0                          mov rax, r12
  1722 00000E9B 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1723 00000E9F 488DB0[4F150000]                lea rsi, [enemies + rax]
  1724                                          
  1725                                          ; Verificar si el enemigo está activo
  1726 00000EA6 807E0201                        cmp byte [rsi + 2], 1
  1727 00000EAA 7532                            jne .next_enemy
  1728                                          
  1729                                          ; Calcular posición en el tablero
  1730 00000EAC 4C0FB606                        movzx r8, byte [rsi]            ; X
  1731 00000EB0 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1732                                          
  1733                                          ; Calcular offset en el tablero
  1734 00000EB5 B84E000000                      mov rax, column_cells
  1735 00000EBA 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  1736 00000EBE 49F7E1                          mul r9
  1737 00000EC1 4C01C0                          add rax, r8
  1738 00000EC4 488DB8[000A0000]                lea rdi, [board + rax]
  1739                                          
  1740                                          ; Obtener carácter del enemigo según el nivel
  1741 00000ECB 480FB605(A4140000)              movzx rax, byte [current_level]
  1742 00000ED3 48FFC8                          dec rax                         ; Ajustar para índice base 0
  1743 00000ED6 8A80[4A150000]                  mov al, [enemy_chars + rax]
  1744                                          
  1745                                          ; Dibujar enemigo
  1746 00000EDC 8807                            mov [rdi], al
  1747                                          
  1748                                      .next_enemy:
  1749 00000EDE 49FFC4                          inc r12
  1750 00000EE1 EBAF                            jmp .print_loop
  1751                                          
  1752                                      .end:
  1753 00000EE3 5D                              pop rbp
  1754 00000EE4 C3                              ret
  1755                                  
  1756                                  ; Función para verificar colisión con enemigos
  1757                                  ; Función para verificar colisión con enemigos
  1758                                  check_enemy_collision:
  1759 00000EE5 55                          push rbp
  1760 00000EE6 4889E5                      mov rbp, rsp
  1761                                      
  1762 00000EE9 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1763 00000EEC 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  1764                                      
  1765                                      .check_loop:
  1766 00000EEF 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  1767 00000EF3 0F8DE9000000                    jge .end
  1768                                          
  1769                                          ; Calcular offset del enemigo actual
  1770 00000EF9 4C89E1                          mov rcx, r12
  1771 00000EFC 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  1772 00000F00 488DB1[4F150000]                lea rsi, [enemies + rcx]
  1773                                          
  1774                                          ; Verificar si el enemigo está activo
  1775 00000F07 807E0201                        cmp byte [rsi + 2], 1
  1776 00000F0B 0F85C9000000                    jne .next_enemy
  1777                                          
  1778                                          ; Verificar colisión con la bola
  1779 00000F11 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  1780 00000F15 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  1781                                          
  1782                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  1783 00000F1A 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1784 00000F21 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1785                                          
  1786                                          ; Comprobar colisión vertical (misma columna)
  1787 00000F28 4D39C2                          cmp r10, r8
  1788 00000F2B 7525                            jne .check_horizontal
  1789 00000F2D 4D29CB                          sub r11, r9
  1790 00000F30 4983FB01                        cmp r11, 1
  1791 00000F34 7F1C                            jg .check_horizontal
  1792 00000F36 4983FBFF                        cmp r11, -1
  1793 00000F3A 7C16                            jl .check_horizontal
  1794                                          
  1795                                          ; Colisión vertical detectada
  1796 00000F3C E8A3000000                      call destroy_enemy
  1797 00000F41 48F71D(67140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  1798 00000F48 B801000000                      mov rax, 1
  1799 00000F4D E990000000                      jmp .end
  1800                                          
  1801                                      .check_horizontal:
  1802                                          ; Comprobar colisión horizontal (misma fila)
  1803 00000F52 4C8B15(4F140000)                mov r10, [ball_x_pos]
  1804 00000F59 4C8B1D(57140000)                mov r11, [ball_y_pos]
  1805 00000F60 4D39CB                          cmp r11, r9
  1806 00000F63 7522                            jne .check_paddle
  1807 00000F65 4D29C2                          sub r10, r8
  1808 00000F68 4983FA01                        cmp r10, 1
  1809 00000F6C 7F19                            jg .check_paddle
  1810 00000F6E 4983FAFF                        cmp r10, -1
  1811 00000F72 7C13                            jl .check_paddle
  1812                                          
  1813                                          ; Colisión horizontal detectada
  1814 00000F74 E86B000000                      call destroy_enemy
  1815 00000F79 48F71D(5F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  1816 00000F80 B801000000                      mov rax, 1
  1817 00000F85 EB5B                            jmp .end
  1818                                          
  1819                                      .check_paddle:
  1820                                          ; Verificar colisión con la paleta
  1821 00000F87 4C8B15(3F140000)                mov r10, [pallet_position]
  1822 00000F8E 4981EA[000A0000]                sub r10, board
  1823 00000F95 4C89D0                          mov rax, r10
  1824 00000F98 41BB4E000000                    mov r11, column_cells
  1825 00000F9E 4983C302                        add r11, 2
  1826 00000FA2 4831D2                          xor rdx, rdx
  1827 00000FA5 49F7F3                          div r11                     ; División para obtener la posición Y
  1828 00000FA8 4989D3                          mov r11, rdx               ; X de la paleta en r11
  1829                                          
  1830 00000FAB 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  1831                                          
  1832                                          ; Verificar si el enemigo está en la misma fila que la paleta
  1833 00000FB2 41BD20000000                    mov r13, row_cells
  1834 00000FB8 4983ED02                        sub r13, 2                 ; Y de la paleta
  1835 00000FBC 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  1836 00000FBF 7519                            jne .next_enemy
  1837                                          
  1838                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  1839 00000FC1 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  1840 00000FC4 7C14                            jl .next_enemy
  1841                                          
  1842 00000FC6 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  1843 00000FC9 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  1844 00000FCC 7F0C                            jg .next_enemy
  1845                                          
  1846                                          ; Si llegamos aquí, hay colisión con la paleta
  1847 00000FCE E811000000                      call destroy_enemy        ; Destruir el enemigo
  1848 00000FD3 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  1849 00000FD8 EB08                            jmp .end
  1850                                          
  1851                                      .next_enemy:
  1852 00000FDA 49FFC4                          inc r12
  1853 00000FDD E90DFFFFFF                      jmp .check_loop
  1854                                          
  1855                                      .end:
  1856 00000FE2 5D                              pop rbp
  1857 00000FE3 C3                              ret
  1858                                  
  1859                                  ; Función para destruir un enemigo
  1860                                  destroy_enemy:
  1861                                      ; Desactivar enemigo
  1862 00000FE4 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  1863                                  
  1864                                      ; Sumar puntos por destruir enemigo
  1865 00000FE8 488B05(6E150000)            mov rax, [enemy_points]
  1866 00000FEF 480105(2D150000)            add [current_score], rax
  1867                                  
  1868                                      ; No tocar bloques destruidos aquí
  1869 00000FF6 C3                          ret
  1870                                  
  1871                                  
  1872                                  _start:
  1873 00000FF7 E82FF1FFFF              	call canonical_off
  1874 00000FFC E8E9000000              	call start_screen
  1875 00001001 E81BF6FFFF                  call init_level
  1876 00001006 E8FFFBFFFF                  call init_enemies
  1877 0000100B EB00                    	jmp .main_loop
  1878                                  	
  1879                                  
  1880                                  	.main_loop:
  1881 0000100D E8C8F9FFFF                      call print_labels
  1882 00001012 E8B7F3FFFF              		call print_pallet
  1883 00001017 E842F4FFFF                      call move_ball
  1884 0000101C E8BDF2FFFF                      call check_bottom_collision
  1885 00001021 E8E8F8FFFF                      call print_blocks
  1886 00001026 E8B2F1FFFF                      call print_lives
  1887 0000102B E840F7FFFF                      call check_level_complete
  1888 00001030 E8ECFDFFFF                      call check_enemy_spawn
  1889 00001035 E804FCFFFF                      call move_enemies
  1890 0000103A E8A6FEFFFF                      call check_enemy_collision
  1891 0000103F E847FEFFFF                      call print_enemies
  1892 00001044 E85DF3FFFF              		call print_ball
  1893                                  		print board, board_size				
    82 00001049 B801000000          <1>  mov eax, sys_write
    83 0000104E BF01000000          <1>  mov edi, 1
    84 00001053 48BE-               <1>  mov rsi, %1
    84 00001055 [000A000000000000]  <1>
    85 0000105D BA000A0000          <1>  mov edx, %2
    86 00001062 0F05                <1>  syscall
  1894                                  		;setnonblocking	
  1895                                  	.read_more:	
  1896                                  		getchar	
    90 00001064 B800000000          <1>  mov rax, sys_read
    91 00001069 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000106E 48BE-               <1>  mov rsi, input_char
    92 00001070 [0000000000000000]  <1>
    93 00001078 BA01000000          <1>  mov rdx, 1
    94 0000107D 0F05                <1>  syscall
  1897                                  		
  1898 0000107F 4883F801                		cmp rax, 1
  1899 00001083 7532                        	jne .done
  1900                                  		
  1901 00001085 8A05(00000000)          		mov al,[input_char]
  1902                                  
  1903 0000108B 3C61                    		cmp al, 'a'
  1904 0000108D 750E                    	    jne .not_left
  1905 0000108F 48C7C7FFFFFFFF          	    mov rdi, left_direction
  1906 00001096 E84EF3FFFF              		call move_pallet
  1907 0000109B EB1A                    	    jmp .done
  1908                                  		
  1909                                  		.not_left:
  1910 0000109D 3C64                    		 	cmp al, 'd'
  1911 0000109F 750C                    	    	jne .not_right
  1912 000010A1 BF01000000              			mov rdi, right_direction
  1913 000010A6 E83EF3FFFF              	    	call move_pallet
  1914 000010AB EB0A                        		jmp .done		
  1915                                  
  1916                                  		.not_right:
  1917                                  
  1918 000010AD 3C71                        		cmp al, 'q'
  1919 000010AF 0F84A8000000                		je exit
  1920                                  
  1921 000010B5 EBAD                    			jmp .read_more
  1922                                  		
  1923                                  		.done:	
  1924                                  			;unsetnonblocking		
  1925                                  			sleeptime	
    98 000010B7 B823000000          <1>  mov eax, sys_nanosleep
    99 000010BC 48BF-               <1>  mov rdi, timespec
    99 000010BE [0000000000000000]  <1>
   100 000010C6 31F6                <1>  xor esi, esi
   101 000010C8 0F05                <1>  syscall
  1926                                  			print clear, clear_length
    82 000010CA B801000000          <1>  mov eax, sys_write
    83 000010CF BF01000000          <1>  mov edi, 1
    84 000010D4 48BE-               <1>  mov rsi, %1
    84 000010D6 [1000000000000000]  <1>
    85 000010DE BA07000000          <1>  mov edx, %2
    86 000010E3 0F05                <1>  syscall
  1927 000010E5 E923FFFFFF                  		jmp .main_loop
  1928                                  
  1929                                  
  1930                                  
  1931                                  start_screen:
  1932                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000010EA B801000000          <1>  mov eax, sys_write
    83 000010EF BF01000000          <1>  mov edi, 1
    84 000010F4 48BE-               <1>  mov rsi, %1
    84 000010F6 [1000000000000000]  <1>
    85 000010FE BA07000000          <1>  mov edx, %2
    86 00001103 0F05                <1>  syscall
  1933                                      print msg1, msg1_length
    82 00001105 B801000000          <1>  mov eax, sys_write
    83 0000110A BF01000000          <1>  mov edi, 1
    84 0000110F 48BE-               <1>  mov rsi, %1
    84 00001111 [1700000000000000]  <1>
    85 00001119 BA14010000          <1>  mov edx, %2
    86 0000111E 0F05                <1>  syscall
  1934                                      
  1935                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  1936                                          getchar                 ; Esperamos una tecla
    90 00001120 B800000000          <1>  mov rax, sys_read
    91 00001125 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000112A 48BE-               <1>  mov rsi, input_char
    92 0000112C [0000000000000000]  <1>
    93 00001134 BA01000000          <1>  mov rdx, 1
    94 00001139 0F05                <1>  syscall
  1937 0000113B 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  1938 0000113F 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  1939                                          
  1940                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001141 B801000000          <1>  mov eax, sys_write
    83 00001146 BF01000000          <1>  mov edi, 1
    84 0000114B 48BE-               <1>  mov rsi, %1
    84 0000114D [1000000000000000]  <1>
    85 00001155 BA07000000          <1>  mov edx, %2
    86 0000115A 0F05                <1>  syscall
  1941 0000115C C3                          ret
  1942                                  
  1943                                  exit: 
  1944 0000115D E80BF0FFFF              	call canonical_on
  1945 00001162 B83C000000              	mov    rax, 60
  1946 00001167 BF00000000                  mov    rdi, 0
  1947 0000116C 0F05                        syscall
  1948                                  
