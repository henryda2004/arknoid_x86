     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030153                      db 58, 7, 3, 1, 'S'    ; Bloque 7
   290 000014BB 3D09030145                      db 61, 9, 3, 1, 'E'    ; Bloque 7
   291 000014C0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   292                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   293                                  
   294                                      ; Nivel 2: Bloques de prueba
   295                                      level2_blocks:
   296 000014C5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   297                                      level2_blocks_count equ 1
   298                                  
   299                                      ; Nivel 3
   300                                      level3_blocks:
   301 000014CA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   302                                  
   303                                      level3_blocks_count equ 1
   304                                  
   305                                      ; Nivel 4
   306                                      level4_blocks:
   307 000014CF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   308                                      level4_blocks_count equ 1
   309                                  
   310                                      ; Nivel 5
   311                                      level5_blocks:
   312 000014D4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   313                                      level5_blocks_count equ 1
   314                                  
   315                                      ; Array para mantener el estado de los bloques
   316 000014D9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   317                                  
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153D 0000000000000000            current_score dq 0          ; Score actual
   321 00001545 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001546 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 0000155A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000157D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   331                                      
   332 0000157E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001586 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001587 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   335 00001588 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001589 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 0000158A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   339                                      ; Añade esto en la sección .dataa
   340 0000158B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   340 00001594 12                 
   341 00001595 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   341 0000159E 13                 
   342 0000159F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   342 000015A8 1B                 
   343 000015A9 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   343 000015B2 1C                 
   344 000015B3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   344 000015BC 2D                 
   345                                          ; Arreglo de punteros a los spawn points de cada nivel
   346                                      spawn_points_table:
   347 000015BD [8B15000000000000]              dq level1_spawn_points
   348 000015C5 [9515000000000000]              dq level2_spawn_points
   349 000015CD [9F15000000000000]              dq level3_spawn_points
   350 000015D5 [A915000000000000]              dq level4_spawn_points
   351 000015DD [B315000000000000]              dq level5_spawn_points
   352                                  
   353                                      ; Variables para el comportamiento de enemigos
   354 000015E5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   355 000015E6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   356 000015E7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   357 000015E8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   358                                  
   359 000015F2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   359 000015FB 5B2020202020202020-
   359 00001604 20205D0A0D         
   360                                      score_label_len: equ $ - score_label
   361 00001609 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   361 00001612 657374727569646F73-
   361 0000161B 3A205B2020205D0A0D 
   362                                      blocks_label_len: equ $ - blocks_label
   363                                      
   364                                      ; Posición donde insertar los números en los labels
   365                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   366                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   367                                      
   368                                      ; Definición de las vidas (x, y, estado)
   369                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   370                                      lives_data: 
   371 00001624 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   372 00001627 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   373 0000162A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   374 0000162D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   375 00001630 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   376 00001633 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   377 00001636 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   378                                      lives_count equ 7    ; Total de vidas
   379 00001639 5E                          life_char db "^"    
   380 0000163A 04                          current_lives db 4   ; Contador de vidas activas actual
   381                                  
   382                                  ; Estructura para almacenar las letras y sus posiciones
   383                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   384 0000163B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   385 000017CB 00                          letters_count db 0   
   386 000017CC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   387 000017CD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   387 000017D6 75616C3A205B205D0A-
   387 000017DF 0D                 
   388                                      last_letter_msg_len equ $ - last_letter_msg
   389 000017E0 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   390 000017E1 07                          max_lives db 7              ; Máximo número de vidas permitidas
   391 000017E2 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   392 000017EA 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   393 000017F2 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   394                                  
   395                                  
   396                                  
   397                                  section .text
   398                                  
   399                                  
   400                                  print_lives:
   401 000001DD 55                          push rbp
   402 000001DE 4889E5                      mov rbp, rsp
   403                                      
   404 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   405                                      
   406                                      .print_loop:
   407 000001E4 4983FC07                        cmp r12, lives_count
   408 000001E8 7D45                            jge .end
   409                                          
   410                                          ; Calcular offset de la vida actual
   411 000001EA 4C89E0                          mov rax, r12
   412 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   413 000001F1 488DB0[24160000]                lea rsi, [lives_data + rax]
   414                                          
   415                                          ; Calcular posición en el tablero
   416 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   417 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   418                                          
   419                                          ; Calcular offset en el tablero
   420 00000201 B84E000000                      mov rax, column_cells
   421 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   422 0000020A 49F7E1                          mul r9
   423 0000020D 4C01C0                          add rax, r8
   424 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   425                                          
   426                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   427 00000217 807E0201                        cmp byte [rsi + 2], 1
   428 0000021B 7405                            je .draw_active
   429                                          
   430                                          ; Si está inactiva, dibujar espacio
   431 0000021D C60720                          mov byte [rdi], ' '
   432 00000220 EB08                            jmp .next_life
   433                                          
   434                                      .draw_active:
   435                                          ; Si está activa, dibujar el símbolo de vida
   436 00000222 8A05(39160000)                  mov al, [life_char]
   437 00000228 8807                            mov [rdi], al
   438                                          
   439                                      .next_life:
   440 0000022A 49FFC4                          inc r12
   441 0000022D EBB5                            jmp .print_loop
   442                                          
   443                                      .end:
   444 0000022F 5D                              pop rbp
   445 00000230 C3                              ret
   446                                  
   447                                  ; Función para desactivar una vida
   448                                  ; Función modificada para perder una vida
   449                                  lose_life:
   450 00000231 55                          push rbp
   451 00000232 4889E5                      mov rbp, rsp
   452                                      
   453                                      ; Verificar si aún quedan vidas
   454 00000235 803D(3A160000)00            cmp byte [current_lives], 0
   455 0000023C 0F8493000000                je .game_lost
   456                                      
   457                                      ; Encontrar la última vida activa
   458 00000242 B907000000                  mov rcx, lives_count
   459 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   460                                      
   461                                      .find_active_life:
   462 0000024A 4889C8                          mov rax, rcx
   463 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   464 00000251 488DB0[24160000]                lea rsi, [lives_data + rax]
   465 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   466 0000025C 7407                            je .deactivate_life
   467 0000025E 48FFC9                          dec rcx
   468 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   469 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   470                                          
   471                                      .deactivate_life:
   472                                          ; Calcular posición correcta en el tablero para borrar la vida
   473 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   474 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   475                                          
   476                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   477 0000026E B84E000000                      mov rax, column_cells
   478 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   479 00000277 49F7E1                          mul r9
   480 0000027A 4C01C0                          add rax, r8
   481 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   482                                          
   483                                          ; Borrar visualmente la vida
   484 00000284 C60720                          mov byte [rdi], ' '             
   485                                          
   486                                          ; Desactivar la vida en los datos
   487 00000287 C6460200                        mov byte [rsi + 2], 0          
   488 0000028B FE0D(3A160000)                  dec byte [current_lives]
   489                                          
   490                                          ; Borrar visualmente la paleta anterior
   491 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   492 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   493                                          .erase_pallet_loop:
   494 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   495 000002A3 49FFC0                              inc r8
   496 000002A6 48FFC9                              dec rcx
   497 000002A9 75F4                                jnz .erase_pallet_loop
   498                                          
   499                                  
   500                                          ; Reiniciar posición de la bola y la paleta
   501 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   501 000002B3 000000             
   502 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   502 000002BE 000000             
   503 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   504 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   504 000002CF [36130000]         
   505                                          
   506 000002D3 EB07                            jmp .end
   507                                          
   508                                      .game_lost:
   509 000002D5 E81C000000                      call game_lost
   510 000002DA EB00                            jmp .end
   511                                          
   512                                      .end:
   513 000002DC 5D                              pop rbp
   514 000002DD C3                              ret
   515                                  ; Función modificada para verificar colisión con el borde inferior
   516                                  check_bottom_collision:
   517 000002DE 55                          push rbp
   518 000002DF 4889E5                      mov rbp, rsp
   519                                      
   520                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   521 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   522 000002E9 4883F81E                    cmp rax, row_cells - 2
   523 000002ED 7505                        jne .no_collision
   524                                      
   525                                      ; Si hay colisión, perder una vida
   526 000002EF E83DFFFFFF                  call lose_life
   527                                      
   528                                      .no_collision:
   529 000002F4 5D                              pop rbp
   530 000002F5 C3                              ret
   531                                  
   532                                  ; Nueva función para game over
   533                                  game_lost:
   534                                      ; Limpiar la pantalla
   535                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   536                                      
   537                                      ; Mostrar mensaje de derrota
   538                                      section .data
   539 000017FA C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   539 00001803 6469646F210A0D     
   540                                          lost_msg_len: equ $ - lost_msg
   541                                      section .text
   542                                      
   543                                      ; Imprimir mensaje de derrota
   544                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [FA17000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   545                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [2818000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   546                                      
   547                                      ; Mostrar puntaje final
   548 00000347 488B05(3D150000)            mov rax, [current_score]
   549 0000034E 48BF-                       mov rdi, number_buffer
   549 00000350 [4615000000000000] 
   550 00000358 E862090000                  call number_to_string
   551                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   552                                      
   553                                      ; Esperar un momento antes de salir
   554 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   554 00000381 0000               
   555 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   555 0000038C 0000               
   556                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   557                                      
   558 000003A1 E9F7100000                  jmp exit
   559                                  
   560                                  
   561                                  ; Función para registrar una nueva letra en el mapa
   562                                  ; Entrada:
   563                                  ;   al - letra a registrar
   564                                  ;   r8b - posición x
   565                                  ;   r9b - posición y
   566                                  register_letter:
   567 000003A6 55                          push rbp
   568 000003A7 4889E5                      mov rbp, rsp
   569 000003AA 53                          push rbx
   570 000003AB 51                          push rcx
   571                                      
   572 000003AC 3C20                        cmp al, ' '
   573 000003AE 7438                        je .end
   574                                  
   575                                      ; Encontrar un espacio libre en el mapa
   576 000003B0 4831C9                      xor rcx, rcx
   577 000003B3 480FB615(CB170000)          movzx rdx, byte [letters_count]
   578                                      
   579                                      .find_slot:
   580 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   581 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   582                                          
   583 000003C1 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   584 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   585 000003CD 7405                            je .found_slot
   586                                          
   587 000003CF 48FFC1                          inc rcx
   588 000003D2 EBE7                            jmp .find_slot
   589                                          
   590                                      .found_slot:
   591                                          ; Guardar la información de la letra
   592 000003D4 448803                          mov [rbx], r8b           ; x
   593 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   594 000003DB 884302                          mov [rbx + 2], al        ; letra
   595 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   596                                          
   597 000003E2 FE05(CB170000)                  inc byte [letters_count]
   598                                          
   599                                      .end:
   600 000003E8 59                              pop rcx
   601 000003E9 5B                              pop rbx
   602 000003EA 5D                              pop rbp
   603 000003EB C3                              ret
   604                                  
   605                                  ; Función para imprimir todas las letras registradas
   606                                  print_letters:
   607 000003EC 55                          push rbp
   608 000003ED 4889E5                      mov rbp, rsp
   609 000003F0 53                          push rbx
   610 000003F1 51                          push rcx
   611                                      
   612 000003F2 4831C9                      xor rcx, rcx
   613                                      
   614                                      .print_loop:
   615 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   616 000003F9 7D37                            jge .end
   617                                          
   618                                          ; Obtener puntero a la letra actual
   619 000003FB 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   620                                          
   621                                          ; Verificar si está activa
   622 00000403 807B0300                        cmp byte [rbx + 3], 0
   623 00000407 7424                            je .next_letter
   624                                          
   625                                          ; Calcular posición en el tablero
   626 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   627 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   628                                          
   629                                          ; Calcular offset en el tablero
   630 00000412 B84E000000                      mov rax, column_cells
   631 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   632 0000041B 49F7E1                          mul r9
   633 0000041E 4C01C0                          add rax, r8
   634 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   635                                          
   636                                          ; Imprimir la letra
   637 00000428 8A4302                          mov al, [rbx + 2]
   638 0000042B 8807                            mov [rdi], al
   639                                          
   640                                      .next_letter:
   641 0000042D 48FFC1                          inc rcx
   642 00000430 EBC3                            jmp .print_loop
   643                                          
   644                                      .end:
   645 00000432 59                              pop rcx
   646 00000433 5B                              pop rbx
   647 00000434 5D                              pop rbp
   648 00000435 C3                              ret
   649                                  
   650                                  ; Función para borrar una letra específica
   651                                  ; Entrada:
   652                                  ;   r8b - posición x
   653                                  ;   r9b - posición y
   654                                  remove_letter:
   655 00000436 55                          push rbp
   656 00000437 4889E5                      mov rbp, rsp
   657 0000043A 53                          push rbx
   658 0000043B 51                          push rcx
   659                                      
   660 0000043C 4831C9                      xor rcx, rcx
   661                                      
   662                                      .find_loop:
   663 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   664 00000443 7D2E                            jge .end
   665                                          
   666 00000445 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   667                                          
   668                                          ; Verificar si está activa y coincide la posición
   669 0000044D 807B0300                        cmp byte [rbx + 3], 0
   670 00000451 741B                            je .next_letter
   671                                          
   672 00000453 8A03                            mov al, [rbx]
   673 00000455 4438C0                          cmp al, r8b
   674 00000458 7514                            jne .next_letter
   675                                          
   676 0000045A 8A4301                          mov al, [rbx + 1]
   677 0000045D 4438C8                          cmp al, r9b
   678 00000460 750C                            jne .next_letter
   679                                          
   680                                          ; Encontrada la letra, desactivarla
   681 00000462 C6430300                        mov byte [rbx + 3], 0
   682 00000466 FE0D(CB170000)                  dec byte [letters_count]
   683 0000046C EB05                            jmp .end
   684                                          
   685                                      .next_letter:
   686 0000046E 48FFC1                          inc rcx
   687 00000471 EBCC                            jmp .find_loop
   688                                          
   689                                      .end:
   690 00000473 59                              pop rcx
   691 00000474 5B                              pop rbx
   692 00000475 5D                              pop rbp
   693 00000476 C3                              ret
   694                                  ; Función para mover las letras hacia abajo
   695                                  move_letters:
   696 00000477 55                          push rbp
   697 00000478 4889E5                      mov rbp, rsp
   698 0000047B 53                          push rbx
   699 0000047C 57                          push rdi
   700 0000047D 56                          push rsi
   701 0000047E 4150                        push r8
   702 00000480 4151                        push r9
   703 00000482 4152                        push r10
   704 00000484 4153                        push r11
   705                                  
   706 00000486 4831C9                      xor rcx, rcx
   707                                  
   708                                      .move_loop:
   709 00000489 4883F964                        cmp rcx, 100
   710 0000048D 0F8D08010000                    jge .print_last_letter
   711                                          
   712 00000493 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   713 0000049B 807B0300                        cmp byte [rbx + 3], 0
   714 0000049F 0F84EE000000                    je .next_letter
   715                                  
   716 000004A5 4C0FB603                        movzx r8, byte [rbx]
   717 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   718                                  
   719 000004AE B84E000000                      mov rax, column_cells
   720 000004B3 4883C002                        add rax, 2
   721 000004B7 49F7E1                          mul r9
   722 000004BA 4C01C0                          add rax, r8
   723 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   724 000004C4 C60720                          mov byte [rdi], ' '
   725                                  
   726 000004C7 FE4301                          inc byte [rbx + 1]
   727 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   728                                  
   729 000004CF 4983F91F                        cmp r9, row_cells - 1
   730 000004D3 7C09                            jl .check_pallet_collision
   731                                  
   732 000004D5 C6430300                        mov byte [rbx + 3], 0
   733 000004D9 E9B5000000                      jmp .next_letter
   734                                  
   735                                          .check_pallet_collision:
   736 000004DE B84E000000                          mov rax, column_cells
   737 000004E3 4883C002                            add rax, 2
   738 000004E7 49F7E1                              mul r9
   739 000004EA 4C01C0                              add rax, r8
   740 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   741                                  
   742 000004F4 8A07                                mov al, [rdi]
   743 000004F6 3C20                                cmp al, ' '
   744 000004F8 0F8495000000                        je .next_letter
   745 000004FE 3C3D                                cmp al, char_equal
   746 00000500 740A                                je .capture_letter
   747                                  
   748 00000502 8A4302                              mov al, [rbx + 2]
   749 00000505 8807                                mov [rdi], al
   750 00000507 E987000000                          jmp .next_letter
   751                                  
   752                                          .capture_letter:
   753                                              ; Obtener la nueva letra
   754 0000050C 8A4302                              mov al, [rbx + 2]
   755                                              
   756                                              ; Comparar con la última letra
   757 0000050F 3A05(CC170000)                      cmp al, [last_letter]
   758 00000515 7407                                je .same_letter
   759                                              
   760                                              ; Es una letra diferente, resetear el procesamiento
   761 00000517 C605(E0170000)00                    mov byte [current_power_processed], 0
   762                                              
   763                                              .same_letter:
   764                                              ; Guardar la nueva letra
   765 0000051E 8805(CC170000)                      mov [last_letter], al
   766                                              
   767                                              ; Verificar si es 'E' para extender la paleta
   768 00000524 3C45                                cmp al, 'E'
   769 00000526 7423                                je .extend_pallet
   770                                              
   771                                              ; Verificar si es 'P' para añadir vida
   772 00000528 3C50                                cmp al, 'P'
   773 0000052A 742F                                je .check_add_life
   774                                  
   775 0000052C 3C53                                cmp al, 'S'
   776 0000052E 7444                                je .slow_ball
   777                                              
   778                                              ; Si no es ningún power-up, restaurar tamaño normal
   779 00000530 488B05(4F140000)                    mov rax, [default_pallet_size]
   780 00000537 488905(47140000)                    mov [pallet_size], rax
   781 0000053E 48C705(E2170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   781 00000546 000000             
   782 00000549 EB44                                jmp .finish_capture
   783                                  
   784                                              .extend_pallet:
   785 0000054B 488B05(57140000)                        mov rax, [extended_pallet_size]
   786 00000552 488905(47140000)                        mov [pallet_size], rax
   787 00000559 EB34                                    jmp .finish_capture
   788                                  
   789                                              .check_add_life:
   790                                                  ; Verificar si ya procesamos este power-up
   791 0000055B 803D(E0170000)00                        cmp byte [current_power_processed], 0
   792 00000562 752B                                    jne .finish_capture
   793                                                  
   794                                                  ; Preservar registros importantes
   795 00000564 51                                      push rcx
   796 00000565 53                                      push rbx
   797                                                  
   798                                                  ; Marcar como procesado
   799 00000566 C605(E0170000)01                        mov byte [current_power_processed], 1
   800                                                  
   801                                                  ; Añadir una vida
   802 0000056D E878000000                              call add_life
   803                                                  
   804                                                  ; Restaurar registros
   805 00000572 5B                                      pop rbx
   806 00000573 59                                      pop rcx
   807                                                  
   808                                              .slow_ball:
   809 00000574 488B05(4F140000)                        mov rax, [default_pallet_size]
   810 0000057B 488905(47140000)                        mov [pallet_size], rax
   811 00000582 48C705(E2170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   811 0000058A 000000             
   812 0000058D EB00                                    jmp .finish_capture
   813                                  
   814                                              .finish_capture:
   815 0000058F C6430300                                mov byte [rbx + 3], 0
   816                                  
   817                                          .next_letter:
   818 00000593 48FFC1                              inc rcx
   819 00000596 E9EEFEFFFF                          jmp .move_loop
   820                                  
   821                                      .print_last_letter:
   822                                          print last_letter_msg, last_letter_msg_len - 3
    82 0000059B B801000000          <1>  mov eax, sys_write
    83 000005A0 BF01000000          <1>  mov edi, 1
    84 000005A5 48BE-               <1>  mov rsi, %1
    84 000005A7 [CD17000000000000]  <1>
    85 000005AF BA10000000          <1>  mov edx, %2
    86 000005B4 0F05                <1>  syscall
   823 000005B6 8A05(CC170000)                  mov al, [last_letter]
   824 000005BC 8805(DC170000)                  mov [last_letter_msg + 15], al
   825                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 000005C2 B801000000          <1>  mov eax, sys_write
    83 000005C7 BF01000000          <1>  mov edi, 1
    84 000005CC 48BE-               <1>  mov rsi, %1
    84 000005CE [DD17000000000000]  <1>
    85 000005D6 BA03000000          <1>  mov edx, %2
    86 000005DB 0F05                <1>  syscall
   826                                  
   827                                      .end:
   828 000005DD 415B                            pop r11
   829 000005DF 415A                            pop r10
   830 000005E1 4159                            pop r9
   831 000005E3 4158                            pop r8
   832 000005E5 5E                              pop rsi
   833 000005E6 5F                              pop rdi
   834 000005E7 5B                              pop rbx
   835 000005E8 5D                              pop rbp
   836 000005E9 C3                              ret
   837                                  
   838                                  add_life:
   839 000005EA 55                          push rbp
   840 000005EB 4889E5                      mov rbp, rsp
   841 000005EE 53                          push rbx
   842 000005EF 51                          push rcx
   843 000005F0 57                          push rdi
   844 000005F1 56                          push rsi
   845 000005F2 4150                        push r8
   846 000005F4 4151                        push r9
   847                                      
   848                                      ; Verificar si ya tenemos el máximo de vidas
   849 000005F6 480FB605(3A160000)          movzx rax, byte [current_lives]
   850 000005FE 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
   851 00000602 7D2C                        jge .end
   852                                      
   853                                      ; Incrementar el contador de vidas
   854 00000604 FE05(3A160000)              inc byte [current_lives]
   855                                      
   856                                      ; Encontrar la siguiente vida inactiva
   857 0000060A 4831C9                      xor rcx, rcx
   858                                      
   859                                      .find_inactive:
   860 0000060D 4883F907                        cmp rcx, lives_count
   861 00000611 7D1D                            jge .end
   862                                          
   863                                          ; Calcular offset de la vida actual
   864 00000613 4889C8                          mov rax, rcx
   865 00000616 486BC003                        imul rax, 3
   866 0000061A 488DB0[24160000]                lea rsi, [lives_data + rax]
   867                                          
   868                                          ; Verificar si está inactiva
   869 00000621 807E0200                        cmp byte [rsi + 2], 0
   870 00000625 7405                            je .activate_life
   871                                          
   872 00000627 48FFC1                          inc rcx
   873 0000062A EBE1                            jmp .find_inactive
   874                                          
   875                                      .activate_life:
   876                                          ; Activar la vida
   877 0000062C C6460201                        mov byte [rsi + 2], 1
   878                                          
   879                                      .end:
   880 00000630 4159                            pop r9
   881 00000632 4158                            pop r8
   882 00000634 5E                              pop rsi
   883 00000635 5F                              pop rdi
   884 00000636 59                              pop rcx
   885 00000637 5B                              pop rbx
   886 00000638 5D                              pop rbp
   887 00000639 C3                              ret
   888                                  
   889                                  
   890                                  print_ball:
   891 0000063A 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   892 00000641 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   893 00000648 4981C0[000A0000]        	add r8, board
   894                                  
   895 0000064F 4C89C9                  	mov rcx, r9
   896 00000652 B850000000              	mov rax, column_cells + 2
   897 00000657 48F7E9                  	imul rcx
   898                                  	
   899 0000065A 4901C0                  	add r8, rax
   900 0000065D 41C6004F                	mov byte [r8], char_O
   901 00000661 C3                      	ret
   902                                  
   903                                  	
   904                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   905                                  	
   906                                  print_pallet:
   907                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   908 00000662 4C8B05(3F140000)            mov r8, [pallet_position]
   909 00000669 488B0D(57140000)            mov rcx, [extended_pallet_size]
   910                                      .clear_pallet:
   911 00000670 41C60020                        mov byte [r8], char_space
   912 00000674 49FFC0                          inc r8
   913 00000677 48FFC9                          dec rcx
   914 0000067A 75F4                            jnz .clear_pallet
   915                                  
   916                                      ; Luego dibujar la nueva paleta con el tamaño actual
   917 0000067C 4C8B05(3F140000)            mov r8, [pallet_position]
   918 00000683 488B0D(47140000)            mov rcx, [pallet_size]
   919                                      .write_pallet:
   920 0000068A 41C6003D                        mov byte [r8], char_equal
   921 0000068E 49FFC0                          inc r8
   922 00000691 48FFC9                          dec rcx
   923 00000694 75F4                            jnz .write_pallet
   924                                  
   925 00000696 C3                          ret
   926                                  
   927                                  move_pallet:
   928                                      
   929 00000697 803D(7F140000)00            cmp byte [ball_moving], 0
   930 0000069E 7507                        jne .continue_movement
   931 000006A0 C605(7F140000)01            mov byte [ball_moving], 1
   932                                  
   933                                      .continue_movement:
   934 000006A7 4883FFFF                        cmp rdi, left_direction
   935 000006AB 7531                            jne .move_right
   936                                  
   937                                          .move_left:
   938                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   939 000006AD 4C8B05(3F140000)                    mov r8, [pallet_position]
   940 000006B4 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   941 000006B7 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   942 000006BA 3C58                                cmp al, 'X'        ; Comparar si es una X
   943 000006BC 744D                                je .end            ; Si es X, no mover
   944                                              
   945 000006BE 4C8B05(3F140000)                    mov r8, [pallet_position]
   946 000006C5 4C8B0D(47140000)                    mov r9, [pallet_size]
   947 000006CC 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   948 000006D2 49FFC8                              dec r8
   949 000006D5 4C8905(3F140000)                    mov [pallet_position], r8
   950 000006DC EB2D                                jmp .end
   951                                              
   952                                          .move_right:
   953                                              ; Verificar si la siguiente posición después de la paleta sería una X
   954 000006DE 4C8B05(3F140000)                    mov r8, [pallet_position]
   955 000006E5 4C8B0D(47140000)                    mov r9, [pallet_size]
   956 000006EC 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   957 000006EF 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   958 000006F2 3C58                                cmp al, 'X'        ; Comparar si es una X
   959 000006F4 7415                                je .end            ; Si es X, no mover
   960                                              
   961 000006F6 4C8B05(3F140000)                    mov r8, [pallet_position]
   962 000006FD 41C60020                            mov byte [r8], char_space
   963 00000701 49FFC0                              inc r8
   964 00000704 4C8905(3F140000)                    mov [pallet_position], r8
   965                                          .end:
   966 0000070B C3                                  ret
   967                                  
   968                                  move_ball:
   969                                      ; Si la bola no está en movimiento, no hacer nada
   970 0000070C 803D(7F140000)00            cmp byte [ball_moving], 0
   971 00000713 0F842C010000                je .end
   972                                  
   973                                      ; Incrementar contador de velocidad
   974 00000719 48FF05(F2170000)            inc qword [speed_counter]
   975                                      
   976                                      ; Verificar si debemos mover la bola en este ciclo
   977 00000720 488B05(F2170000)            mov rax, [speed_counter]
   978 00000727 483B05(E2170000)            cmp rax, [ball_speed]
   979 0000072E 0F8C11010000                jl .end
   980                                      
   981                                      ; Resetear contador de velocidad
   982 00000734 48C705(F2170000)00-         mov qword [speed_counter], 0
   982 0000073C 000000             
   983                                  
   984                                      ; Borrar la posición actual de la bola
   985 0000073F 4C8B05(5F140000)            mov r8, [ball_x_pos]
   986 00000746 4C8B0D(67140000)            mov r9, [ball_y_pos]
   987 0000074D 4981C0[000A0000]            add r8, board
   988 00000754 4C89C9                      mov rcx, r9
   989 00000757 B850000000                  mov rax, column_cells + 2
   990 0000075C 48F7E9                      imul rcx
   991 0000075F 4901C0                      add r8, rax
   992 00000762 41C60020                    mov byte [r8], char_space
   993                                  
   994                                      ; Calcular siguiente posición X
   995 00000766 4C8B05(5F140000)            mov r8, [ball_x_pos]
   996 0000076D 4C8B0D(67140000)            mov r9, [ball_y_pos]
   997 00000774 488B05(6F140000)            mov rax, [ball_direction_x]
   998 0000077B 4901C0                      add r8, rax               ; Nueva posición X
   999                                  
  1000                                      ; Calcular la dirección de memoria para la siguiente posición
  1001 0000077E 4D89C2                      mov r10, r8
  1002 00000781 4981C2[000A0000]            add r10, board
  1003 00000788 4C89C9                      mov rcx, r9
  1004 0000078B B850000000                  mov rax, column_cells + 2
  1005 00000790 48F7E9                      imul rcx
  1006 00000793 4901C2                      add r10, rax
  1007                                  
  1008                                      ; Verificar si hay una X en la siguiente posición X
  1009 00000796 418A02                      mov al, [r10]
  1010 00000799 3C58                        cmp al, 'X'
  1011 0000079B 750C                        jne .check_block_x
  1012 0000079D 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1013 000007A4 E99C000000                  jmp .end
  1014                                  
  1015                                      .check_block_x:
  1016                                          ; Verificar colisión con bloques en X
  1017 000007A9 4150                            push r8     ; Guardar registros que usa check_block_collision
  1018 000007AB 4151                            push r9
  1019 000007AD 4152                            push r10
  1020 000007AF E863060000                      call check_block_collision
  1021 000007B4 415A                            pop r10
  1022 000007B6 4159                            pop r9
  1023 000007B8 4158                            pop r8
  1024 000007BA 4885C0                          test rax, rax
  1025 000007BD 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1026 000007BF 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1027 000007C6 EB7D                            jmp .end
  1028                                  
  1029                                      .check_paddle_x:
  1030                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1031 000007C8 41803A3D                        cmp byte [r10], char_equal
  1032 000007CC 7509                            jne .check_y_movement
  1033 000007CE 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1034 000007D5 EB6E                            jmp .end
  1035                                  
  1036                                      .check_y_movement:
  1037                                          ; Calcular siguiente posición Y
  1038 000007D7 488B05(77140000)                mov rax, [ball_direction_y]
  1039 000007DE 4901C1                          add r9, rax                  ; Nueva posición Y
  1040                                  
  1041                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1042 000007E1 4D89C2                          mov r10, r8
  1043 000007E4 4981C2[000A0000]                add r10, board
  1044 000007EB 4C89C9                          mov rcx, r9
  1045 000007EE B850000000                      mov rax, column_cells + 2
  1046 000007F3 48F7E9                          imul rcx
  1047 000007F6 4901C2                          add r10, rax
  1048                                  
  1049                                          ; Verificar si hay una X en la siguiente posición Y
  1050 000007F9 418A02                          mov al, [r10]
  1051 000007FC 3C58                            cmp al, 'X'
  1052 000007FE 7509                            jne .check_block_y
  1053 00000800 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1054 00000807 EB3C                            jmp .end
  1055                                  
  1056                                      .check_block_y:
  1057                                          ; Verificar colisión con bloques en Y
  1058 00000809 4150                            push r8     ; Guardar registros que usa check_block_collision
  1059 0000080B 4151                            push r9
  1060 0000080D 4152                            push r10
  1061 0000080F E803060000                      call check_block_collision
  1062 00000814 415A                            pop r10
  1063 00000816 4159                            pop r9
  1064 00000818 4158                            pop r8
  1065 0000081A 4885C0                          test rax, rax
  1066 0000081D 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1067 0000081F 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1068 00000826 EB1D                            jmp .end
  1069                                  
  1070                                      .check_paddle_y:
  1071                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
  1072 00000828 41803A3D                    cmp byte [r10], char_equal
  1073 0000082C 7509                        jne .update_position
  1074 0000082E 48F71D(77140000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1075 00000835 EB0E                        jmp .end
  1076                                  
  1077                                  
  1078                                      .update_position:
  1079 00000837 4C8905(5F140000)                mov [ball_x_pos], r8
  1080 0000083E 4C890D(67140000)                mov [ball_y_pos], r9
  1081                                  
  1082                                      .end:
  1083 00000845 C3                              ret
  1084                                  
  1085                                  ; Función para inicializar el nivel
  1086                                  ; Función para inicializar el nivel
  1087                                  ; Función para mostrar el número de nivel
  1088                                  display_level_number:
  1089 00000846 55                          push rbp
  1090 00000847 4889E5                      mov rbp, rsp
  1091                                      
  1092                                      ; Limpiar la pantalla primero
  1093                                      print clear, clear_length
    82 0000084A B801000000          <1>  mov eax, sys_write
    83 0000084F BF01000000          <1>  mov edi, 1
    84 00000854 48BE-               <1>  mov rsi, %1
    84 00000856 [1000000000000000]  <1>
    85 0000085E BA07000000          <1>  mov edx, %2
    86 00000863 0F05                <1>  syscall
  1094                                      
  1095                                      ; Calcular la posición central para el mensaje
  1096                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1097 00000865 B84E000000                  mov rax, column_cells
  1098 0000086A 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1099 0000086E 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1100                                      
  1101                                      ; Calcular la fila central
  1102 00000871 BB20000000                  mov rbx, row_cells
  1103 00000876 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1104                                      
  1105                                      ; Calcular el offset en el buffer
  1106 00000879 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1107 0000087E 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1108 00000881 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1109                                      
  1110                                      ; Escribir "NIVEL " en la posición calculada
  1111 00000884 488DB8[000A0000]            lea rdi, [board + rax]
  1112 0000088B 48BE-                       mov rsi, level_msg
  1112 0000088D [2414000000000000] 
  1113 00000895 B906000000                  mov rcx, level_msg_len
  1114 0000089A F3A4                        rep movsb
  1115                                      
  1116                                      ; Escribir el número del nivel
  1117 0000089C 8A05(B4140000)              mov al, [current_level]
  1118 000008A2 0430                        add al, '0'                 ; convertir a ASCII
  1119 000008A4 8807                        mov [rdi], al
  1120                                      
  1121                                      ; Mostrar el board con el mensaje
  1122                                      print board, board_size
    82 000008A6 B801000000          <1>  mov eax, sys_write
    83 000008AB BF01000000          <1>  mov edi, 1
    84 000008B0 48BE-               <1>  mov rsi, %1
    84 000008B2 [000A000000000000]  <1>
    85 000008BA BA000A0000          <1>  mov edx, %2
    86 000008BF 0F05                <1>  syscall
  1123                                      
  1124                                      ; Esperar un segundo
  1125 000008C1 B823000000                  mov rax, sys_nanosleep
  1126 000008C6 48BF-                       mov rdi, level_display_time
  1126 000008C8 [2F14000000000000] 
  1127 000008D0 4831F6                      xor rsi, rsi
  1128 000008D3 0F05                        syscall
  1129                                      
  1130 000008D5 5D                          pop rbp
  1131 000008D6 C3                          ret
  1132                                  
  1133                                  ; Función para inicializar un tablero vacío
  1134                                  init_empty_board:
  1135 000008D7 56                          push rsi
  1136 000008D8 57                          push rdi
  1137 000008D9 51                          push rcx
  1138 000008DA 50                          push rax
  1139                                  
  1140 000008DB 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1141 000008E2 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1142 000008E9 B9000A0000                  mov rcx, board_template_size
  1143 000008EE F3A4                        rep movsb                   ; Copiar el tablero
  1144                                  
  1145 000008F0 58                          pop rax
  1146 000008F1 59                          pop rcx
  1147 000008F2 5F                          pop rdi
  1148 000008F3 5E                          pop rsi
  1149 000008F4 C3                          ret
  1150                                  
  1151                                  
  1152                                  init_level:
  1153                                  
  1154 000008F5 488B05(4F140000)            mov rax, [default_pallet_size]
  1155 000008FC 488905(47140000)            mov [pallet_size], rax
  1156 00000903 48C705(E2170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1156 0000090B 000000             
  1157                                  
  1158                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1159                                          ; Reiniciar letras activas
  1160 0000090E 488D3D(3B160000)            lea rdi, [letters_map]
  1161 00000915 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1162 0000091A 4831C0                      xor rax, rax
  1163 0000091D F3AA                        rep stosb                    ; Llenar con ceros
  1164                                      
  1165                                      ; Inicializar dirección de la bola (derecha y arriba)
  1166 0000091F 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1166 00000927 000000             
  1167 0000092A 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1167 00000932 FFFFFF             
  1168                                  
  1169                                  
  1170                                      ; Reiniciar contador de letras activas
  1171 00000935 4831C0                      xor rax, rax
  1172 00000938 8805(CB170000)              mov [letters_count], al
  1173                                  
  1174                                      ; Reiniciar última letra capturada
  1175 0000093E C605(CC170000)20            mov byte [last_letter], ' '
  1176 00000945 C605(45150000)00            mov byte [destroyed_blocks], 0 
  1177 0000094C E886FFFFFF                  call init_empty_board
  1178 00000951 E8F0FEFFFF                  call display_level_number
  1179 00000956 E8E5050000                  call init_enemies
  1180                                      
  1181 0000095B 56                          push rsi
  1182 0000095C 57                          push rdi
  1183 0000095D 51                          push rcx
  1184 0000095E 50                          push rax
  1185                                  
  1186 0000095F 488D35(00000000)            lea rsi, [board_template]
  1187 00000966 488D3D(000A0000)            lea rdi, [board]
  1188 0000096D B9000A0000                  mov rcx, board_template_size
  1189 00000972 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1190                                  
  1191 00000974 58                          pop rax
  1192 00000975 59                          pop rcx
  1193 00000976 5F                          pop rdi
  1194 00000977 5E                          pop rsi
  1195                                  
  1196 00000978 B90A000000                  mov rcx, 10
  1197 0000097D 4831C0                      xor rax, rax
  1198 00000980 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1199 00000987 F3AA                        rep stosb      
  1200                                  
  1201                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1202 00000989 803D(B4140000)01            cmp byte [current_level], 1
  1203 00000990 7431                        je .level1
  1204 00000992 803D(B4140000)02            cmp byte [current_level], 2
  1205 00000999 7454                        je .level2
  1206 0000099B 803D(B4140000)03            cmp byte [current_level], 3
  1207 000009A2 7477                        je .level3
  1208 000009A4 803D(B4140000)04            cmp byte [current_level], 4
  1209 000009AB 0F8492000000                je .level4
  1210 000009B1 803D(B4140000)05            cmp byte [current_level], 5
  1211 000009B8 0F84AD000000                je .level5
  1212 000009BE E9D0000000                  jmp .done
  1213                                  
  1214                                  
  1215                                  
  1216                                      .level1:
  1217 000009C3 C605(B5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1218 000009CA 4831C9                          xor rcx, rcx             
  1219                                          .init_loop1:
  1220 000009CD 4883F903                            cmp rcx, level1_blocks_count
  1221 000009D1 0F8DBC000000                        jge .done
  1222 000009D7 4889C8                              mov rax, rcx         
  1223 000009DA 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1224 000009DE 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1225 000009E4 8891[D9140000]                      mov byte [block_states + rcx], dl
  1226 000009EA 48FFC1                              inc rcx
  1227 000009ED EBDE                                jmp .init_loop1
  1228                                  
  1229                                      .level2:
  1230 000009EF C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1231 000009F6 4831C9                          xor rcx, rcx             
  1232                                          .init_loop2:
  1233 000009F9 4883F901                            cmp rcx, level2_blocks_count
  1234 000009FD 0F8D90000000                        jge .done
  1235 00000A03 4889C8                              mov rax, rcx         
  1236 00000A06 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1237 00000A0A 8A90[C8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1238 00000A10 8891[D9140000]                      mov byte [block_states + rcx], dl
  1239 00000A16 48FFC1                              inc rcx
  1240 00000A19 EBDE                                jmp .init_loop2
  1241                                      .level3:
  1242 00000A1B C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1243 00000A22 4831C9                          xor rcx, rcx             
  1244                                          .init_loop3:
  1245 00000A25 4883F901                            cmp rcx, level3_blocks_count
  1246 00000A29 7D68                                jge .done
  1247 00000A2B 4889C8                              mov rax, rcx         
  1248 00000A2E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1249 00000A32 8A90[CD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1250 00000A38 8891[D9140000]                      mov byte [block_states + rcx], dl
  1251 00000A3E 48FFC1                              inc rcx
  1252 00000A41 EBE2                                jmp .init_loop3
  1253                                  
  1254                                      .level4:
  1255 00000A43 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1256 00000A4A 4831C9                          xor rcx, rcx             
  1257                                          .init_loop4:
  1258 00000A4D 4883F901                            cmp rcx, level4_blocks_count
  1259 00000A51 7D40                                jge .done
  1260 00000A53 4889C8                              mov rax, rcx         
  1261 00000A56 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1262 00000A5A 8A90[D2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1263 00000A60 8891[D9140000]                      mov byte [block_states + rcx], dl
  1264 00000A66 48FFC1                              inc rcx
  1265 00000A69 EBE2                                jmp .init_loop4
  1266                                  
  1267                                      .level5:
  1268 00000A6B C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1269 00000A72 4831C9                          xor rcx, rcx             
  1270                                          .init_loop5:
  1271 00000A75 4883F901                            cmp rcx, level5_blocks_count
  1272 00000A79 7D18                                jge .done
  1273 00000A7B 4889C8                              mov rax, rcx         
  1274 00000A7E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1275 00000A82 8A90[D7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1276 00000A88 8891[D9140000]                      mov byte [block_states + rcx], dl
  1277 00000A8E 48FFC1                              inc rcx
  1278 00000A91 EBE2                                jmp .init_loop5
  1279                                      .done:
  1280 00000A93 C3                              ret
  1281                                  
  1282                                  
  1283                                  ; Función para verificar y manejar la transición de nivel
  1284                                  check_level_complete:
  1285                                      ; Verificar si quedan bloques
  1286 00000A94 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1287 00000A9B 753C                        jne .not_complete
  1288                                      
  1289                                      ; Incrementar el nivel
  1290 00000A9D FE05(B4140000)              inc byte [current_level]
  1291                                      
  1292                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1293 00000AA3 803D(B4140000)06            cmp byte [current_level], 6
  1294 00000AAA 742E                        je game_win
  1295                                      
  1296                                      ; Reinicializar el juego para el siguiente nivel
  1297 00000AAC E844FEFFFF                  call init_level
  1298                                      
  1299                                      ; Reinicializar la posición de la bola y la paleta
  1300 00000AB1 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1300 00000AB9 000000             
  1301 00000ABC 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1301 00000AC4 000000             
  1302 00000AC7 C605(7F140000)00            mov byte [ball_moving], 0
  1303 00000ACE 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1303 00000AD5 [36130000]         
  1304                                      
  1305                                      .not_complete:
  1306 00000AD9 C3                              ret
  1307                                  
  1308                                      ; Nueva función para manejar la victoria del juego
  1309                                  game_win:
  1310                                      ; Limpiar la pantalla primero
  1311                                      print clear, clear_length
    82 00000ADA B801000000          <1>  mov eax, sys_write
    83 00000ADF BF01000000          <1>  mov edi, 1
    84 00000AE4 48BE-               <1>  mov rsi, %1
    84 00000AE6 [1000000000000000]  <1>
    85 00000AEE BA07000000          <1>  mov edx, %2
    86 00000AF3 0F05                <1>  syscall
  1312                                      
  1313                                      ; Mensaje de victoria
  1314 00000AF5 488B05(3D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1315 00000AFC 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1315 00000AFE [4615000000000000] 
  1316 00000B06 E8B4010000                  call number_to_string
  1317                                      
  1318                                      ; Definir mensaje de victoria
  1319                                      section .data
  1320 0000180A C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1320 00001813 616465732120C2A148-
  1320 0000181C 61732067616E61646F-
  1320 00001825 210A0D             
  1321                                          win_msg_len: equ $ - win_msg
  1322 00001828 50756E74616A652066-             score_msg: db "Puntaje final: "
  1322 00001831 696E616C3A20       
  1323                                          score_msg_len: equ $ - score_msg
  1324                                      section .text
  1325                                      
  1326                                      ; Imprimir mensajes
  1327                                      print win_msg, win_msg_len
    82 00000B0B B801000000          <1>  mov eax, sys_write
    83 00000B10 BF01000000          <1>  mov edi, 1
    84 00000B15 48BE-               <1>  mov rsi, %1
    84 00000B17 [0A18000000000000]  <1>
    85 00000B1F BA1E000000          <1>  mov edx, %2
    86 00000B24 0F05                <1>  syscall
  1328                                      print score_msg, score_msg_len
    82 00000B26 B801000000          <1>  mov eax, sys_write
    83 00000B2B BF01000000          <1>  mov edi, 1
    84 00000B30 48BE-               <1>  mov rsi, %1
    84 00000B32 [2818000000000000]  <1>
    85 00000B3A BA0F000000          <1>  mov edx, %2
    86 00000B3F 0F05                <1>  syscall
  1329                                      print number_buffer, 20
    82 00000B41 B801000000          <1>  mov eax, sys_write
    83 00000B46 BF01000000          <1>  mov edi, 1
    84 00000B4B 48BE-               <1>  mov rsi, %1
    84 00000B4D [4615000000000000]  <1>
    85 00000B55 BA14000000          <1>  mov edx, %2
    86 00000B5A 0F05                <1>  syscall
  1330                                      
  1331                                      ; Esperar un momento antes de salir
  1332 00000B5C 48C70599F4FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1332 00000B65 0000               
  1333 00000B67 48C70596F4FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1333 00000B70 0000               
  1334                                      sleeptime
    98 00000B72 B823000000          <1>  mov eax, sys_nanosleep
    99 00000B77 48BF-               <1>  mov rdi, timespec
    99 00000B79 [0000000000000000]  <1>
   100 00000B81 31F6                <1>  xor esi, esi
   101 00000B83 0F05                <1>  syscall
  1335                                      
  1336 00000B85 E913090000                  jmp exit
  1337                                  
  1338                                  ; Función para imprimir los bloques
  1339                                  ; Función modificada para imprimir bloques
  1340                                  
  1341                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1342                                  get_current_level_blocks:
  1343 00000B8A 803D(B4140000)01            cmp byte [current_level], 1
  1344 00000B91 7428                        je .level1
  1345 00000B93 803D(B4140000)02            cmp byte [current_level], 2
  1346 00000B9A 7427                        je .level2
  1347 00000B9C 803D(B4140000)03            cmp byte [current_level], 3
  1348 00000BA3 7426                        je .level3
  1349 00000BA5 803D(B4140000)04            cmp byte [current_level], 4
  1350 00000BAC 7425                        je .level4
  1351 00000BAE 803D(B4140000)05            cmp byte [current_level], 5
  1352 00000BB5 7424                        je .level5
  1353                                      ; Si llegamos aquí, hay un error en el nivel
  1354 00000BB7 4831C0                      xor rax, rax
  1355 00000BBA C3                          ret
  1356                                  
  1357                                      .level1:
  1358 00000BBB 488D05(B6140000)                lea rax, [level1_blocks]
  1359 00000BC2 C3                              ret
  1360                                      .level2:
  1361 00000BC3 488D05(C5140000)                lea rax, [level2_blocks]
  1362 00000BCA C3                              ret
  1363                                      .level3:
  1364 00000BCB 488D05(CA140000)                lea rax, [level3_blocks]
  1365 00000BD2 C3                              ret
  1366                                      .level4:
  1367 00000BD3 488D05(CF140000)                lea rax, [level4_blocks]
  1368 00000BDA C3                              ret
  1369                                      .level5:
  1370 00000BDB 488D05(D4140000)                lea rax, [level5_blocks]
  1371 00000BE2 C3                              ret
  1372                                  ; Función para obtener la cantidad de bloques del nivel actual
  1373                                  get_current_level_count:
  1374 00000BE3 803D(B4140000)01            cmp byte [current_level], 1
  1375 00000BEA 7428                        je .level1
  1376 00000BEC 803D(B4140000)02            cmp byte [current_level], 2
  1377 00000BF3 7425                        je .level2
  1378 00000BF5 803D(B4140000)03            cmp byte [current_level], 3
  1379 00000BFC 7422                        je .level3
  1380 00000BFE 803D(B4140000)04            cmp byte [current_level], 4
  1381 00000C05 741F                        je .level4
  1382 00000C07 803D(B4140000)05            cmp byte [current_level], 5
  1383 00000C0E 741C                        je .level5
  1384                                      ; Si llegamos aquí, hay un error en el nivel
  1385 00000C10 4831C0                      xor rax, rax
  1386 00000C13 C3                          ret
  1387                                  
  1388                                      .level1:
  1389 00000C14 B803000000                      mov rax, level1_blocks_count
  1390 00000C19 C3                              ret
  1391                                      .level2:
  1392 00000C1A B801000000                      mov rax, level2_blocks_count
  1393 00000C1F C3                              ret
  1394                                      .level3:
  1395 00000C20 B801000000                      mov rax, level3_blocks_count
  1396 00000C25 C3                              ret
  1397                                      .level4:
  1398 00000C26 B801000000                      mov rax, level4_blocks_count
  1399 00000C2B C3                              ret
  1400                                      .level5:
  1401 00000C2C B801000000                      mov rax, level5_blocks_count
  1402 00000C31 C3                              ret
  1403                                  
  1404                                  
  1405                                  print_blocks:
  1406 00000C32 55                          push rbp
  1407 00000C33 4889E5                      mov rbp, rsp
  1408                                      
  1409                                      ; Obtener puntero a los bloques del nivel actual
  1410 00000C36 E84FFFFFFF                  call get_current_level_blocks
  1411 00000C3B 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1412                                      
  1413                                      ; Obtener cantidad de bloques del nivel actual
  1414 00000C3E E8A0FFFFFF                  call get_current_level_count
  1415 00000C43 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1416                                      
  1417 00000C46 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1418                                      
  1419                                      .print_loop:
  1420 00000C49 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1421 00000C4C 7D6F                            jge .end
  1422                                          
  1423                                          ; Verificar si el bloque está activo
  1424 00000C4E 490FB68424-                     movzx rax, byte [block_states + r12]
  1424 00000C53 [D9140000]         
  1425 00000C57 4885C0                          test rax, rax
  1426 00000C5A 745C                            jz .next_block
  1427                                          
  1428                                          ; Obtener posición y tipo del bloque usando r13
  1429 00000C5C 4C89E0                          mov rax, r12
  1430 00000C5F 486BC005                        imul rax, 5
  1431 00000C63 4C01E8                          add rax, r13
  1432 00000C66 448A00                          mov r8b, [rax]        ; X position
  1433 00000C69 448A4801                        mov r9b, [rax + 1]    ; Y position
  1434 00000C6D 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1435                                  
  1436                                          ; El resto de la lógica de impresión permanece igual
  1437 00000C71 4D0FB6C0                        movzx r8, r8b
  1438 00000C75 4D0FB6C9                        movzx r9, r9b
  1439 00000C79 4981C0[000A0000]                add r8, board
  1440 00000C80 B850000000                      mov rax, column_cells + 2
  1441 00000C85 49F7E1                          mul r9
  1442 00000C88 4901C0                          add r8, rax
  1443                                          
  1444 00000C8B B906000000                      mov rcx, block_length
  1445 00000C90 48BE-                           mov rsi, block_type_1
  1445 00000C92 [9014000000000000] 
  1446 00000C9A 490FB6C2                        movzx rax, r10b
  1447 00000C9E 48FFC8                          dec rax
  1448 00000CA1 486BC006                        imul rax, block_length
  1449 00000CA5 4801C6                          add rsi, rax
  1450                                          
  1451                                      .print_block_chars:
  1452 00000CA8 8A06                            mov al, [rsi]
  1453 00000CAA 418800                          mov [r8], al
  1454 00000CAD 48FFC6                          inc rsi
  1455 00000CB0 49FFC0                          inc r8
  1456 00000CB3 48FFC9                          dec rcx
  1457 00000CB6 75F0                            jnz .print_block_chars
  1458                                          
  1459                                      .next_block:
  1460 00000CB8 49FFC4                          inc r12
  1461 00000CBB EB8C                            jmp .print_loop
  1462                                          
  1463                                      .end:
  1464 00000CBD 5D                              pop rbp
  1465 00000CBE C3                              ret
  1466                                  
  1467                                  ; Función para convertir número a string
  1468                                  ; Input: RAX = número a convertir
  1469                                  ; RDI = buffer donde escribir el string
  1470                                  number_to_string:
  1471 00000CBF 53                          push rbx
  1472 00000CC0 52                          push rdx
  1473 00000CC1 56                          push rsi
  1474 00000CC2 BB0A000000                  mov rbx, 10          ; Divisor
  1475 00000CC7 B900000000                  mov rcx, 0          ; Contador de dígitos
  1476                                      
  1477                                      ; Si el número es 0, manejarlo especialmente
  1478 00000CCC 4885C0                      test rax, rax
  1479 00000CCF 7509                        jnz .convert_loop
  1480 00000CD1 C60730                      mov byte [rdi], '0'
  1481 00000CD4 C6470100                    mov byte [rdi + 1], 0
  1482 00000CD8 EB20                        jmp .end
  1483                                      
  1484                                      .convert_loop:
  1485 00000CDA 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1486 00000CDD 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1487 00000CE0 80C230                          add dl, '0'     ; Convertir a ASCII
  1488 00000CE3 52                              push rdx        ; Guardar el dígito
  1489 00000CE4 48FFC1                          inc rcx         ; Incrementar contador
  1490 00000CE7 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1491 00000CEA 75EE                            jnz .convert_loop
  1492                                          
  1493                                      .write_loop:
  1494 00000CEC 5A                              pop rdx         ; Obtener dígito
  1495 00000CED 8817                            mov [rdi], dl   ; Escribir al buffer
  1496 00000CEF 48FFC7                          inc rdi         ; Siguiente posición
  1497 00000CF2 48FFC9                          dec rcx         ; Decrementar contador
  1498 00000CF5 75F5                            jnz .write_loop
  1499                                          
  1500 00000CF7 C60700                      mov byte [rdi], 0   ; Null terminator
  1501                                      
  1502                                      .end:
  1503 00000CFA 5E                          pop rsi
  1504 00000CFB 5A                          pop rdx
  1505 00000CFC 5B                          pop rbx
  1506 00000CFD C3                          ret
  1507                                  
  1508                                  ; Función para imprimir los labels
  1509                                  print_labels:
  1510 00000CFE 55                          push rbp
  1511 00000CFF 4889E5                      mov rbp, rsp
  1512                                  
  1513                                      ; Crear buffer temporal
  1514 00000D02 4883EC20                    sub rsp, 32
  1515                                  
  1516                                      ; Copiar labels a buffer temporal
  1517 00000D06 4889E7                      mov rdi, rsp
  1518 00000D09 488D35(F2150000)            lea rsi, [score_label]
  1519 00000D10 B917000000                  mov rcx, score_label_len
  1520 00000D15 F3A4                        rep movsb
  1521                                  
  1522                                      ; Convertir score a string
  1523 00000D17 488B05(3D150000)            mov rax, [current_score]
  1524 00000D1E 48BF-                       mov rdi, number_buffer
  1524 00000D20 [4615000000000000] 
  1525 00000D28 E892FFFFFF                  call number_to_string
  1526                                  
  1527                                      ; Calcular longitud del número
  1528 00000D2D B900000000                  mov rcx, 0
  1529 00000D32 48BF-                       mov rdi, number_buffer
  1529 00000D34 [4615000000000000] 
  1530                                      .count_loop:
  1531 00000D3C 803C0F00                        cmp byte [rdi + rcx], 0
  1532 00000D40 7405                            je .count_done
  1533 00000D42 48FFC1                          inc rcx
  1534 00000D45 EBF5                            jmp .count_loop
  1535                                      .count_done:
  1536                                  
  1537                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1538 00000D47 4889E7                      mov rdi, rsp
  1539 00000D4A 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1540 00000D4E BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1541 00000D53 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1542                                      .pad_loop:
  1543 00000D56 4885F6                          test rsi, rsi
  1544 00000D59 740B                            jz .pad_done
  1545 00000D5B C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1546 00000D5E 48FFC7                          inc rdi
  1547 00000D61 48FFCE                          dec rsi
  1548 00000D64 EBF0                            jmp .pad_loop
  1549                                      .pad_done:
  1550                                  
  1551                                      ; Copiar el número
  1552 00000D66 48BE-                       mov rsi, number_buffer
  1552 00000D68 [4615000000000000] 
  1553 00000D70 F3A4                        rep movsb
  1554                                  
  1555                                      ; Imprimir el buffer completo
  1556                                      print rsp, score_label_len
    82 00000D72 B801000000          <1>  mov eax, sys_write
    83 00000D77 BF01000000          <1>  mov edi, 1
    84 00000D7C 4889E6              <1>  mov rsi, %1
    85 00000D7F BA17000000          <1>  mov edx, %2
    86 00000D84 0F05                <1>  syscall
  1557                                  
  1558                                      ; Repetir proceso para bloques destruidos
  1559 00000D86 4889E7                      mov rdi, rsp
  1560 00000D89 488D35(09160000)            lea rsi, [blocks_label]
  1561 00000D90 B91B000000                  mov rcx, blocks_label_len
  1562 00000D95 F3A4                        rep movsb
  1563                                  
  1564                                      ; Verificar que el `[` esté en su posición correcta
  1565 00000D97 4889E7                      mov rdi, rsp
  1566 00000D9A 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1567 00000D9E C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1568                                  
  1569                                      ; Convertir bloques destruidos a string
  1570 00000DA1 480FB605(45150000)          movzx rax, byte [destroyed_blocks]
  1571 00000DA9 48BF-                       mov rdi, number_buffer
  1571 00000DAB [4615000000000000] 
  1572 00000DB3 E807FFFFFF                  call number_to_string
  1573                                  
  1574                                      ; Calcular longitud del número
  1575 00000DB8 B900000000                  mov rcx, 0
  1576 00000DBD 48BF-                       mov rdi, number_buffer
  1576 00000DBF [4615000000000000] 
  1577                                      .count_loop2:
  1578 00000DC7 803C0F00                        cmp byte [rdi + rcx], 0
  1579 00000DCB 7405                            je .count_done2
  1580 00000DCD 48FFC1                          inc rcx
  1581 00000DD0 EBF5                            jmp .count_loop2
  1582                                      .count_done2:
  1583                                  
  1584                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1585 00000DD2 4889E7                      mov rdi, rsp
  1586 00000DD5 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1587 00000DD9 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1588 00000DDE 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1589                                      .pad_loop2:
  1590 00000DE1 4885F6                          test rsi, rsi
  1591 00000DE4 740B                            jz .pad_done2
  1592 00000DE6 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1593 00000DE9 48FFC7                          inc rdi
  1594 00000DEC 48FFCE                          dec rsi
  1595 00000DEF EBF0                            jmp .pad_loop2
  1596                                      .pad_done2:
  1597                                  
  1598                                      ; Copiar el número
  1599 00000DF1 48BE-                       mov rsi, number_buffer
  1599 00000DF3 [4615000000000000] 
  1600 00000DFB F3A4                        rep movsb
  1601                                  
  1602                                      ; Imprimir el buffer completo
  1603                                      print rsp, blocks_label_len
    82 00000DFD B801000000          <1>  mov eax, sys_write
    83 00000E02 BF01000000          <1>  mov edi, 1
    84 00000E07 4889E6              <1>  mov rsi, %1
    85 00000E0A BA1B000000          <1>  mov edx, %2
    86 00000E0F 0F05                <1>  syscall
  1604                                  
  1605                                      ; Restaurar stack
  1606 00000E11 4883C420                    add rsp, 32
  1607 00000E15 5D                          pop rbp
  1608 00000E16 C3                          ret
  1609                                  
  1610                                  
  1611                                  
  1612                                  check_block_collision:
  1613 00000E17 55                          push rbp
  1614 00000E18 4889E5                      mov rbp, rsp
  1615                                  
  1616                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1617 00000E1B 418A02                      mov al, [r10]
  1618                                  
  1619                                      ; Verificar si el carácter es un bloque
  1620 00000E1E 3C55                        cmp al, 'U'  
  1621 00000E20 7419                        je .possible
  1622 00000E22 3C4F                        cmp al, 'O'  
  1623 00000E24 7415                        je .possible
  1624 00000E26 3C44                        cmp al, 'D'  
  1625 00000E28 7411                        je .possible
  1626 00000E2A 3C4C                        cmp al, 'L'  
  1627 00000E2C 740D                        je .possible
  1628 00000E2E 3C56                        cmp al, 'V'  
  1629 00000E30 7409                        je .possible
  1630 00000E32 3C38                        cmp al, '8'  
  1631 00000E34 7405                        je .possible
  1632                                  
  1633                                      ; No es bloque, salir
  1634 00000E36 4831C0                      xor rax, rax
  1635 00000E39 5D                          pop rbp
  1636 00000E3A C3                          ret
  1637                                  
  1638                                  .possible:
  1639 00000E3B 53                          push rbx
  1640 00000E3C 57                          push rdi
  1641 00000E3D 56                          push rsi
  1642 00000E3E 4154                        push r12
  1643 00000E40 4155                        push r13
  1644 00000E42 4156                        push r14
  1645 00000E44 4157                        push r15
  1646                                  
  1647                                      ; 1) Obtener base de los bloques del nivel actual
  1648 00000E46 E83FFDFFFF                  call get_current_level_blocks
  1649 00000E4B 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1650                                  
  1651                                      ; 2) Obtener la cantidad de bloques
  1652 00000E4E E890FDFFFF                  call get_current_level_count
  1653 00000E53 4989C6                      mov r14, rax
  1654                                  
  1655 00000E56 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1656                                  
  1657                                  .find_block_loop:
  1658 00000E59 4D39F4                      cmp r12, r14
  1659 00000E5C 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1660                                  
  1661                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1662 00000E62 4C89E0                      mov rax, r12
  1663 00000E65 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1664 00000E69 4C01E8                      add rax, r13
  1665 00000E6C 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1666                                  
  1667                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1668 00000E6F 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1668 00000E74 [D9140000]         
  1669 00000E78 4885DB                      test rbx, rbx
  1670 00000E7B 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1671                                  
  1672                                      ; Obtener coordenadas
  1673 00000E81 418A17                      mov dl, [r15]         ; x
  1674 00000E84 418A4F01                    mov cl, [r15 + 1]     ; y
  1675                                  
  1676                                      ; Calcular posición en el board
  1677 00000E88 488D3D(000A0000)            lea rdi, [board]
  1678 00000E8F 4831C0                      xor rax, rax
  1679 00000E92 B84E000000                  mov rax, column_cells
  1680 00000E97 4883C002                    add rax, 2
  1681 00000E9B 480FB6C9                    movzx rcx, cl         ; y
  1682 00000E9F 480FAFC1                    imul rax, rcx
  1683 00000EA3 4801C7                      add rdi, rax
  1684 00000EA6 480FB6C2                    movzx rax, dl         ; x
  1685 00000EAA 4801C7                      add rdi, rax
  1686                                  
  1687                                      ; Guardar la posición base del bloque
  1688 00000EAD 57                          push rdi
  1689                                  
  1690                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1691 00000EAE 4939FA                      cmp r10, rdi
  1692 00000EB1 7274                        jb .skip_collision
  1693 00000EB3 488D5F06                    lea rbx, [rdi + block_length]
  1694 00000EB7 4939DA                      cmp r10, rbx
  1695 00000EBA 736B                        jae .skip_collision
  1696                                  
  1697                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1698 00000EBC 41FE8C24[D9140000]          dec byte [block_states + r12]
  1699                                      ; Volver a cargar durabilidad
  1700 00000EC4 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1700 00000EC9 [D9140000]         
  1701 00000ECD 4885DB                      test rbx, rbx
  1702 00000ED0 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1703                                  
  1704                                      ; >>> Llegó a 0 => Bloque destruido
  1705 00000ED2 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1706 00000ED3 B906000000                  mov rcx, block_length
  1707                                  .clear_loop:
  1708 00000ED8 C60720                      mov byte [rdi], ' '
  1709 00000EDB 48FFC7                      inc rdi
  1710 00000EDE E2F8                        loop .clear_loop
  1711                                  
  1712                                      ; Dibujar letra del bloque destruido
  1713 00000EE0 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1714 00000EE4 4883EF06                    sub rdi, block_length
  1715 00000EE8 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1716                                      ; Después de escribir la letra en el tablero
  1717 00000EEA 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1718 00000EEE 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1719 00000EF2 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1720 00000EF7 E8AAF4FFFF                  call register_letter
  1721                                      ; Actualizar contadores globales
  1722 00000EFC FE0D(B5140000)              dec byte [blocks_remaining]
  1723 00000F02 FE05(45150000)              inc byte [destroyed_blocks]
  1724                                  
  1725                                      ; Sumar puntos según el tipo
  1726 00000F08 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1727 00000F0D 486BC00A                    imul rax, 10
  1728 00000F11 480105(3D150000)            add [current_score], rax
  1729                                  
  1730 00000F18 B801000000                  mov rax, 1  ; colisión con destrucción
  1731 00000F1D EB14                        jmp .end_pop
  1732                                  
  1733                                  .update_display:
  1734                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1735 00000F1F B801000000                  mov rax, 1  ; colisión con "rebote"  
  1736 00000F24 5F                          pop rdi     ; pop que quedó pendiente
  1737 00000F25 EB0C                        jmp .end_pop
  1738                                  
  1739                                  .skip_collision:
  1740 00000F27 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1741                                  .next_block:
  1742 00000F28 49FFC4                      inc r12
  1743 00000F2B E929FFFFFF                  jmp .find_block_loop
  1744                                  
  1745                                  .no_block_found:
  1746 00000F30 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1747                                  
  1748                                  .end_pop:
  1749 00000F33 415F                        pop r15
  1750 00000F35 415E                        pop r14
  1751 00000F37 415D                        pop r13
  1752 00000F39 415C                        pop r12
  1753 00000F3B 5E                          pop rsi
  1754 00000F3C 5F                          pop rdi
  1755 00000F3D 5B                          pop rbx
  1756 00000F3E 5D                          pop rbp
  1757 00000F3F C3                          ret
  1758                                  
  1759                                  
  1760                                  
  1761                                  init_enemies:
  1762 00000F40 55                          push rbp
  1763 00000F41 4889E5                      mov rbp, rsp
  1764                                      ; Reiniciar contadores de movimiento
  1765 00000F44 C605(88150000)00            mov byte [enemy_move_total], 0
  1766 00000F4B C605(89150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1767                                      ; Limpiar estado previo de enemigos
  1768 00000F52 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1769 00000F57 488D3D(5F150000)            lea rdi, [enemies]
  1770 00000F5E 30C0                        xor al, al
  1771 00000F60 F3AA                        rep stosb ; Limpiar datos de enemigos
  1772                                      
  1773                                      ; Marcar todos los enemigos como inactivos
  1774 00000F62 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1775 00000F69 30C0                        xor al, al
  1776 00000F6B B90A000000                  mov rcx, 10
  1777 00000F70 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1778                                  
  1779 00000F72 5D                          pop rbp
  1780 00000F73 C3                          ret
  1781                                  
  1782                                  
  1783                                  ; Función para mover enemigos
  1784                                  move_enemies:
  1785 00000F74 55                          push rbp
  1786 00000F75 4889E5                      mov rbp, rsp
  1787                                      
  1788                                      ; Incrementar contador de movimiento
  1789 00000F78 FE05(86150000)              inc byte [enemy_move_counter]
  1790 00000F7E 480FB605(86150000)          movzx rax, byte [enemy_move_counter]
  1791 00000F86 3A05(87150000)              cmp al, [enemy_move_delay]
  1792 00000F8C 0F85AA010000                jne .end
  1793                                      
  1794                                      ; Resetear contador
  1795 00000F92 C605(86150000)00            mov byte [enemy_move_counter], 0
  1796                                      
  1797 00000F99 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1798                                      
  1799                                      .enemy_loop:
  1800 00000F9C 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1801 00000FA0 0F8D96010000                    jge .end
  1802                                          
  1803                                          ; Calcular offset del enemigo actual
  1804 00000FA6 4C89E0                          mov rax, r12
  1805 00000FA9 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1806 00000FAD 488DB0[5F150000]                lea rsi, [enemies + rax]
  1807                                          
  1808                                          ; Verificar si el enemigo está activo
  1809 00000FB4 807E0201                        cmp byte [rsi + 2], 1
  1810 00000FB8 0F8576010000                    jne .next_enemy
  1811                                          
  1812                                          ; Obtener posición actual
  1813 00000FBE 4C0FB606                        movzx r8, byte [rsi]            ; X
  1814 00000FC2 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1815                                          
  1816                                          ; Limpiar posición actual antes de mover
  1817 00000FC7 4150                            push r8
  1818 00000FC9 4151                            push r9
  1819 00000FCB B84E000000                      mov rax, column_cells
  1820 00000FD0 4883C002                        add rax, 2
  1821 00000FD4 49F7E1                          mul r9
  1822 00000FD7 4C01C0                          add rax, r8
  1823 00000FDA 488DB8[000A0000]                lea rdi, [board + rax]
  1824 00000FE1 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1825 00000FE4 4159                            pop r9
  1826 00000FE6 4158                            pop r8
  1827                                  
  1828                                          ; Determinar comportamiento basado en índice
  1829 00000FE8 4C89E0                          mov rax, r12
  1830 00000FEB 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1831 00000FEF 4885C0                          test rax, rax
  1832 00000FF2 7402                            jz .chase_ball
  1833 00000FF4 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1834                                          
  1835                                          ; Perseguir bola (comportamiento original)
  1836                                      .chase_ball:
  1837 00000FF6 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1838 00000FFD 4D39D0                          cmp r8, r10
  1839 00001000 0F8F96000000                    jg .move_left
  1840 00001006 0F8C95000000                    jl .move_right
  1841                                          
  1842 0000100C 4C8B15(67140000)                mov r10, [ball_y_pos]
  1843 00001013 4D39D1                          cmp r9, r10
  1844 00001016 0F8F8A000000                    jg .move_up
  1845 0000101C 0F8C89000000                    jl .move_down
  1846 00001022 E9A5000000                      jmp .check_collision
  1847                                          
  1848                                      .chase_paddle:
  1849                                          ; Obtener la posición X actual de la paleta
  1850 00001027 4C8B15(3F140000)                mov r10, [pallet_position]
  1851 0000102E 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1852                                          
  1853                                          ; Calcular la posición X real de la paleta
  1854 00001035 4C89D0                          mov rax, r10
  1855 00001038 BB4E000000                      mov rbx, column_cells
  1856 0000103D 4883C302                        add rbx, 2                  ; Añadir newline chars
  1857 00001041 4831D2                          xor rdx, rdx
  1858 00001044 48F7F3                          div rbx                     ; rax = y, rdx = x
  1859                                          
  1860                                          ; rdx ahora contiene la posición X de la paleta
  1861                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1862 00001047 488B0D(47140000)                mov rcx, [pallet_size]
  1863 0000104E 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1864 00001051 4801CA                          add rdx, rcx
  1865                                          
  1866                                          ; Comparar con posición X del enemigo y mover gradualmente
  1867 00001054 4939D0                          cmp r8, rdx
  1868 00001057 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1869 00001059 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1870 0000105B 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1871                                  
  1872                                      .check_y_paddle:
  1873                                          ; La Y de la paleta siempre es row_cells - 2
  1874 0000105D 41BA20000000                    mov r10, row_cells
  1875 00001063 4983EA02                        sub r10, 2
  1876                                          
  1877                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1878 00001067 4D39D1                          cmp r9, r10
  1879 0000106A 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1880 0000106C 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1881 0000106E 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1882                                          
  1883                                      .no_movement:
  1884 00001070 EB5A                            jmp .check_collision
  1885                                  
  1886                                      ; También agregar una nueva sección para el movimiento suave
  1887                                      .smooth_transition:
  1888                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1889 00001072 8A05(89150000)                  mov al, [enemy_target]
  1890 00001078 84C0                            test al, al
  1891 0000107A 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  1892                                          
  1893                                          ; Verificar distancia en X
  1894 0000107C 4989D2                          mov r10, rdx              ; Posición X objetivo
  1895 0000107F 4D29C2                          sub r10, r8               ; Calcular diferencia
  1896 00001082 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  1897 00001086 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  1898 00001088 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  1899 0000108C 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  1900 0000108E EB3C                            jmp .check_collision
  1901                                          
  1902                                      .limit_right_movement:
  1903 00001090 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  1904 00001094 EB36                            jmp .check_collision
  1905                                          
  1906                                      .limit_left_movement:
  1907 00001096 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  1908 0000109A EB30                            jmp .check_collision
  1909                                      .move_left:
  1910 0000109C 49FFC8                          dec r8
  1911 0000109F EB0F                            jmp .check_vertical
  1912                                          
  1913                                      .move_right:
  1914 000010A1 49FFC0                          inc r8
  1915 000010A4 EB0A                            jmp .check_vertical
  1916                                          
  1917                                      .move_up:
  1918 000010A6 49FFC9                          dec r9
  1919 000010A9 EB21                            jmp .check_collision
  1920                                          
  1921                                      .move_down:
  1922 000010AB 49FFC1                          inc r9
  1923 000010AE EB1C                            jmp .check_collision
  1924                                          
  1925                                      .check_vertical:
  1926 000010B0 8A05(89150000)                  mov al, [enemy_target]
  1927 000010B6 84C0                            test al, al
  1928 000010B8 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  1929 000010BE 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  1930 000010C5 4D39D1                          cmp r9, r10
  1931 000010C8 7FDC                            jg .move_up
  1932 000010CA 7CDF                            jl .move_down
  1933                                          
  1934                                      .check_collision:
  1935                                          ; Verificar colisión con bordes
  1936 000010CC 4983F801                        cmp r8, 1                       ; Borde izquierdo
  1937 000010D0 7E62                            jle .next_enemy
  1938 000010D2 4983F84E                        cmp r8, column_cells
  1939 000010D6 7D5C                            jge .next_enemy
  1940 000010D8 4983F901                        cmp r9, 1                       ; Borde superior
  1941 000010DC 7E56                            jle .next_enemy
  1942 000010DE 4983F920                        cmp r9, row_cells
  1943 000010E2 7D50                            jge .next_enemy
  1944                                          
  1945                                          ; Verificar colisión con bloques antes de moverse
  1946 000010E4 4150                            push r8
  1947 000010E6 4151                            push r9
  1948 000010E8 4152                            push r10
  1949                                          
  1950                                          ; Calcular posición en el tablero para verificar
  1951 000010EA B84E000000                      mov rax, column_cells
  1952 000010EF 4883C002                        add rax, 2
  1953 000010F3 49F7E1                          mul r9
  1954 000010F6 4C01C0                          add rax, r8
  1955 000010F9 4C8D90[000A0000]                lea r10, [board + rax]
  1956                                          
  1957                                          ; Verificar si hay un bloque en la nueva posición
  1958 00001100 418A02                          mov al, [r10]
  1959 00001103 3C55                            cmp al, 'U'
  1960 00001105 7427                            je .invalid_move
  1961 00001107 3C4F                            cmp al, 'O'
  1962 00001109 7423                            je .invalid_move
  1963 0000110B 3C44                            cmp al, 'D'
  1964 0000110D 741F                            je .invalid_move
  1965 0000110F 3C4C                            cmp al, 'L'
  1966 00001111 741B                            je .invalid_move
  1967 00001113 3C56                            cmp al, 'V'
  1968 00001115 7417                            je .invalid_move
  1969 00001117 3C38                            cmp al, '8'
  1970 00001119 7413                            je .invalid_move
  1971 0000111B 3C58                            cmp al, 'X'
  1972 0000111D 740F                            je .invalid_move
  1973                                          
  1974 0000111F 415A                            pop r10
  1975 00001121 4159                            pop r9
  1976 00001123 4158                            pop r8
  1977                                          
  1978                                          ; Guardar nueva posición si es válida
  1979 00001125 448806                          mov [rsi], r8b
  1980 00001128 44884E01                        mov [rsi + 1], r9b
  1981 0000112C EB06                            jmp .next_enemy
  1982                                          
  1983                                      .invalid_move:
  1984 0000112E 415A                            pop r10
  1985 00001130 4159                            pop r9
  1986 00001132 4158                            pop r8
  1987                                          
  1988                                      .next_enemy:
  1989 00001134 49FFC4                          inc r12
  1990 00001137 E960FEFFFF                      jmp .enemy_loop
  1991                                          
  1992                                      .end:
  1993 0000113C 5D                              pop rbp
  1994 0000113D C3                              ret
  1995                                  
  1996                                  get_current_spawn_points:
  1997 0000113E 55                          push rbp
  1998 0000113F 4889E5                      mov rbp, rsp
  1999                                      
  2000 00001142 480FB605(B4140000)          movzx rax, byte [current_level]
  2001 0000114A 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2002 0000114D 488B04C5[BD150000]          mov rax, [spawn_points_table + rax * 8]
  2003                                      
  2004 00001155 5D                          pop rbp
  2005 00001156 C3                          ret
  2006                                  
  2007                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2008                                  check_enemy_spawn:
  2009 00001157 55                          push rbp
  2010 00001158 4889E5                      mov rbp, rsp
  2011                                      
  2012                                      ; Obtener spawn points del nivel actual
  2013 0000115B E8DEFFFFFF                  call get_current_spawn_points
  2014 00001160 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2015                                      
  2016                                      ; Obtener cantidad de bloques destruidos
  2017 00001163 4C0FB62D(45150000)          movzx r13, byte [destroyed_blocks]
  2018                                      
  2019                                      ; Verificar cada punto de spawn
  2020 0000116B 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2021                                      
  2022                                      .check_loop:
  2023 0000116E 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2024 00001172 7D4B                            jge .end
  2025                                          
  2026                                          ; Verificar si este spawn point ya fue usado
  2027 00001174 80B9[E8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2028 0000117B 743D                            je .next_enemy
  2029                                          
  2030                                          ; Verificar si este enemigo ya está activo
  2031 0000117D 4889C8                          mov rax, rcx
  2032 00001180 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2033 00001184 488DB0[5F150000]                lea rsi, [enemies + rax]
  2034 0000118B 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2035 0000118F 7429                            je .next_enemy
  2036                                          
  2037                                          ; Verificar si debemos spawnear este enemigo
  2038 00001191 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2039 00001196 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2040 00001199 751F                            jne .next_enemy
  2041                                          
  2042                                          ; Marcar este spawn point como usado
  2043 0000119B C681[E8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2044                                          
  2045                                          ; Spawner nuevo enemigo
  2046 000011A2 C60628                          mov byte [rsi], 40             ; X inicial
  2047 000011A5 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2048 000011A9 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2049                                          
  2050                                          ; Inicializar comportamiento
  2051 000011AD 4889C8                          mov rax, rcx
  2052 000011B0 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2053 000011B4 8805(E7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2054                                          
  2055                                      .next_enemy:
  2056 000011BA 48FFC1                          inc rcx
  2057 000011BD EBAF                            jmp .check_loop
  2058                                          
  2059                                      .end:
  2060 000011BF 5D                              pop rbp
  2061 000011C0 C3                              ret
  2062                                  
  2063                                  
  2064                                  ; Función para dibujar enemigos
  2065                                  print_enemies:
  2066 000011C1 55                          push rbp
  2067 000011C2 4889E5                      mov rbp, rsp
  2068                                      
  2069 000011C5 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2070                                      
  2071                                      .print_loop:
  2072 000011C8 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2073 000011CC 7D4B                            jge .end
  2074                                          
  2075                                          ; Calcular offset del enemigo actual
  2076 000011CE 4C89E0                          mov rax, r12
  2077 000011D1 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2078 000011D5 488DB0[5F150000]                lea rsi, [enemies + rax]
  2079                                          
  2080                                          ; Verificar si el enemigo está activo
  2081 000011DC 807E0201                        cmp byte [rsi + 2], 1
  2082 000011E0 7532                            jne .next_enemy
  2083                                          
  2084                                          ; Calcular posición en el tablero
  2085 000011E2 4C0FB606                        movzx r8, byte [rsi]            ; X
  2086 000011E6 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2087                                          
  2088                                          ; Calcular offset en el tablero
  2089 000011EB B84E000000                      mov rax, column_cells
  2090 000011F0 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2091 000011F4 49F7E1                          mul r9
  2092 000011F7 4C01C0                          add rax, r8
  2093 000011FA 488DB8[000A0000]                lea rdi, [board + rax]
  2094                                          
  2095                                          ; Obtener carácter del enemigo según el nivel
  2096 00001201 480FB605(B4140000)              movzx rax, byte [current_level]
  2097 00001209 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2098 0000120C 8A80[5A150000]                  mov al, [enemy_chars + rax]
  2099                                          
  2100                                          ; Dibujar enemigo
  2101 00001212 8807                            mov [rdi], al
  2102                                          
  2103                                      .next_enemy:
  2104 00001214 49FFC4                          inc r12
  2105 00001217 EBAF                            jmp .print_loop
  2106                                          
  2107                                      .end:
  2108 00001219 5D                              pop rbp
  2109 0000121A C3                              ret
  2110                                  
  2111                                  ; Función para verificar colisión con enemigos
  2112                                  ; Función para verificar colisión con enemigos
  2113                                  check_enemy_collision:
  2114 0000121B 55                          push rbp
  2115 0000121C 4889E5                      mov rbp, rsp
  2116                                      
  2117 0000121F 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2118 00001222 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2119                                      
  2120                                      .check_loop:
  2121 00001225 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2122 00001229 0F8DE9000000                    jge .end
  2123                                          
  2124                                          ; Calcular offset del enemigo actual
  2125 0000122F 4C89E1                          mov rcx, r12
  2126 00001232 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2127 00001236 488DB1[5F150000]                lea rsi, [enemies + rcx]
  2128                                          
  2129                                          ; Verificar si el enemigo está activo
  2130 0000123D 807E0201                        cmp byte [rsi + 2], 1
  2131 00001241 0F85C9000000                    jne .next_enemy
  2132                                          
  2133                                          ; Verificar colisión con la bola
  2134 00001247 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2135 0000124B 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2136                                          
  2137                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2138 00001250 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2139 00001257 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2140                                          
  2141                                          ; Comprobar colisión vertical (misma columna)
  2142 0000125E 4D39C2                          cmp r10, r8
  2143 00001261 7525                            jne .check_horizontal
  2144 00001263 4D29CB                          sub r11, r9
  2145 00001266 4983FB01                        cmp r11, 1
  2146 0000126A 7F1C                            jg .check_horizontal
  2147 0000126C 4983FBFF                        cmp r11, -1
  2148 00001270 7C16                            jl .check_horizontal
  2149                                          
  2150                                          ; Colisión vertical detectada
  2151 00001272 E8A3000000                      call destroy_enemy
  2152 00001277 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2153 0000127E B801000000                      mov rax, 1
  2154 00001283 E990000000                      jmp .end
  2155                                          
  2156                                      .check_horizontal:
  2157                                          ; Comprobar colisión horizontal (misma fila)
  2158 00001288 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2159 0000128F 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2160 00001296 4D39CB                          cmp r11, r9
  2161 00001299 7522                            jne .check_paddle
  2162 0000129B 4D29C2                          sub r10, r8
  2163 0000129E 4983FA01                        cmp r10, 1
  2164 000012A2 7F19                            jg .check_paddle
  2165 000012A4 4983FAFF                        cmp r10, -1
  2166 000012A8 7C13                            jl .check_paddle
  2167                                          
  2168                                          ; Colisión horizontal detectada
  2169 000012AA E86B000000                      call destroy_enemy
  2170 000012AF 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2171 000012B6 B801000000                      mov rax, 1
  2172 000012BB EB5B                            jmp .end
  2173                                          
  2174                                      .check_paddle:
  2175                                          ; Verificar colisión con la paleta
  2176 000012BD 4C8B15(3F140000)                mov r10, [pallet_position]
  2177 000012C4 4981EA[000A0000]                sub r10, board
  2178 000012CB 4C89D0                          mov rax, r10
  2179 000012CE 41BB4E000000                    mov r11, column_cells
  2180 000012D4 4983C302                        add r11, 2
  2181 000012D8 4831D2                          xor rdx, rdx
  2182 000012DB 49F7F3                          div r11                     ; División para obtener la posición Y
  2183 000012DE 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2184                                          
  2185 000012E1 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2186                                          
  2187                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2188 000012E8 41BD20000000                    mov r13, row_cells
  2189 000012EE 4983ED02                        sub r13, 2                 ; Y de la paleta
  2190 000012F2 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2191 000012F5 7519                            jne .next_enemy
  2192                                          
  2193                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2194 000012F7 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2195 000012FA 7C14                            jl .next_enemy
  2196                                          
  2197 000012FC 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2198 000012FF 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2199 00001302 7F0C                            jg .next_enemy
  2200                                          
  2201                                          ; Si llegamos aquí, hay colisión con la paleta
  2202 00001304 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2203 00001309 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2204 0000130E EB08                            jmp .end
  2205                                          
  2206                                      .next_enemy:
  2207 00001310 49FFC4                          inc r12
  2208 00001313 E90DFFFFFF                      jmp .check_loop
  2209                                          
  2210                                      .end:
  2211 00001318 5D                              pop rbp
  2212 00001319 C3                              ret
  2213                                  
  2214                                  ; Función para destruir un enemigo
  2215                                  destroy_enemy:
  2216                                      ; Desactivar enemigo
  2217 0000131A C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2218                                  
  2219                                      ; Sumar puntos por destruir enemigo
  2220 0000131E 488B05(7E150000)            mov rax, [enemy_points]
  2221 00001325 480105(3D150000)            add [current_score], rax
  2222                                  
  2223                                      ; No tocar bloques destruidos aquí
  2224 0000132C C3                          ret
  2225                                  
  2226                                  
  2227                                  _start:
  2228 0000132D E8F9EDFFFF              	call canonical_off
  2229 00001332 E8F3000000              	call start_screen
  2230 00001337 E8B9F5FFFF                  call init_level
  2231 0000133C E8FFFBFFFF                  call init_enemies
  2232 00001341 EB00                    	jmp .main_loop
  2233                                  	
  2234                                  
  2235                                  	.main_loop:
  2236 00001343 E8B6F9FFFF                      call print_labels
  2237 00001348 E8E5F8FFFF                      call print_blocks
  2238 0000134D E825F1FFFF                      call move_letters
  2239 00001352 E895F0FFFF                      call print_letters
  2240 00001357 E806F3FFFF              		call print_pallet
  2241 0000135C E8ABF3FFFF                      call move_ball
  2242 00001361 E878EFFFFF                      call check_bottom_collision
  2243 00001366 E872EEFFFF                      call print_lives
  2244 0000136B E824F7FFFF                      call check_level_complete
  2245 00001370 E8E2FDFFFF                      call check_enemy_spawn
  2246 00001375 E8FAFBFFFF                      call move_enemies
  2247 0000137A E89CFEFFFF                      call check_enemy_collision
  2248 0000137F E83DFEFFFF                      call print_enemies
  2249 00001384 E8B1F2FFFF              		call print_ball
  2250                                  		print board, board_size				
    82 00001389 B801000000          <1>  mov eax, sys_write
    83 0000138E BF01000000          <1>  mov edi, 1
    84 00001393 48BE-               <1>  mov rsi, %1
    84 00001395 [000A000000000000]  <1>
    85 0000139D BA000A0000          <1>  mov edx, %2
    86 000013A2 0F05                <1>  syscall
  2251                                  		;setnonblocking	
  2252                                  	.read_more:	
  2253                                  		getchar	
    90 000013A4 B800000000          <1>  mov rax, sys_read
    91 000013A9 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000013AE 48BE-               <1>  mov rsi, input_char
    92 000013B0 [0000000000000000]  <1>
    93 000013B8 BA01000000          <1>  mov rdx, 1
    94 000013BD 0F05                <1>  syscall
  2254                                  		
  2255 000013BF 4883F801                		cmp rax, 1
  2256 000013C3 7532                        	jne .done
  2257                                  		
  2258 000013C5 8A05(00000000)          		mov al,[input_char]
  2259                                  
  2260 000013CB 3C61                    		cmp al, 'a'
  2261 000013CD 750E                    	    jne .not_left
  2262 000013CF 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2263 000013D6 E8BCF2FFFF              		call move_pallet
  2264 000013DB EB1A                    	    jmp .done
  2265                                  		
  2266                                  		.not_left:
  2267 000013DD 3C64                    		 	cmp al, 'd'
  2268 000013DF 750C                    	    	jne .not_right
  2269 000013E1 BF01000000              			mov rdi, right_direction
  2270 000013E6 E8ACF2FFFF              	    	call move_pallet
  2271 000013EB EB0A                        		jmp .done		
  2272                                  
  2273                                  		.not_right:
  2274                                  
  2275 000013ED 3C71                        		cmp al, 'q'
  2276 000013EF 0F84A8000000                		je exit
  2277                                  
  2278 000013F5 EBAD                    			jmp .read_more
  2279                                  		
  2280                                  		.done:	
  2281                                  			;unsetnonblocking		
  2282                                  			sleeptime	
    98 000013F7 B823000000          <1>  mov eax, sys_nanosleep
    99 000013FC 48BF-               <1>  mov rdi, timespec
    99 000013FE [0000000000000000]  <1>
   100 00001406 31F6                <1>  xor esi, esi
   101 00001408 0F05                <1>  syscall
  2283                                  			print clear, clear_length
    82 0000140A B801000000          <1>  mov eax, sys_write
    83 0000140F BF01000000          <1>  mov edi, 1
    84 00001414 48BE-               <1>  mov rsi, %1
    84 00001416 [1000000000000000]  <1>
    85 0000141E BA07000000          <1>  mov edx, %2
    86 00001423 0F05                <1>  syscall
  2284 00001425 E919FFFFFF                  		jmp .main_loop
  2285                                  
  2286                                  
  2287                                  
  2288                                  start_screen:
  2289                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 0000142A B801000000          <1>  mov eax, sys_write
    83 0000142F BF01000000          <1>  mov edi, 1
    84 00001434 48BE-               <1>  mov rsi, %1
    84 00001436 [1000000000000000]  <1>
    85 0000143E BA07000000          <1>  mov edx, %2
    86 00001443 0F05                <1>  syscall
  2290                                      print msg1, msg1_length
    82 00001445 B801000000          <1>  mov eax, sys_write
    83 0000144A BF01000000          <1>  mov edi, 1
    84 0000144F 48BE-               <1>  mov rsi, %1
    84 00001451 [1700000000000000]  <1>
    85 00001459 BA14010000          <1>  mov edx, %2
    86 0000145E 0F05                <1>  syscall
  2291                                      
  2292                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2293                                          getchar                 ; Esperamos una tecla
    90 00001460 B800000000          <1>  mov rax, sys_read
    91 00001465 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000146A 48BE-               <1>  mov rsi, input_char
    92 0000146C [0000000000000000]  <1>
    93 00001474 BA01000000          <1>  mov rdx, 1
    94 00001479 0F05                <1>  syscall
  2294 0000147B 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2295 0000147F 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2296                                          
  2297                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001481 B801000000          <1>  mov eax, sys_write
    83 00001486 BF01000000          <1>  mov edi, 1
    84 0000148B 48BE-               <1>  mov rsi, %1
    84 0000148D [1000000000000000]  <1>
    85 00001495 BA07000000          <1>  mov edx, %2
    86 0000149A 0F05                <1>  syscall
  2298 0000149C C3                          ret
  2299                                  
  2300                                  exit: 
  2301 0000149D E8CBECFFFF              	call canonical_on
  2302 000014A2 B83C000000              	mov    rax, 60
  2303 000014A7 BF00000000                  mov    rdi, 0
  2304 000014AC 0F05                        syscall
  2305                                  
