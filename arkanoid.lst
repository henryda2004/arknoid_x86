     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030143                      db 58, 7, 3, 1, 'C'    ; Bloque 7
   290 000014BB 3D09030153                      db 61, 9, 3, 1, 'S'    ; Bloque 7
   291 000014C0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   292                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   293                                  
   294                                      ; Nivel 2: Bloques de prueba
   295                                      level2_blocks:
   296 000014C5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   297                                      level2_blocks_count equ 1
   298                                  
   299                                      ; Nivel 3
   300                                      level3_blocks:
   301 000014CA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   302                                  
   303                                      level3_blocks_count equ 1
   304                                  
   305                                      ; Nivel 4
   306                                      level4_blocks:
   307 000014CF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   308                                      level4_blocks_count equ 1
   309                                  
   310                                      ; Nivel 5
   311                                      level5_blocks:
   312 000014D4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   313                                      level5_blocks_count equ 1
   314                                  
   315                                      ; Array para mantener el estado de los bloques
   316 000014D9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   317                                  
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153D 0000000000000000            current_score dq 0          ; Score actual
   321 00001545 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001546 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 0000155A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000157D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   331                                      
   332 0000157E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001586 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001587 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   335 00001588 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001589 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 0000158A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   339                                      ; Añade esto en la sección .dataa
   340 0000158B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   340 00001594 12                 
   341 00001595 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   341 0000159E 13                 
   342 0000159F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   342 000015A8 1B                 
   343 000015A9 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   343 000015B2 1C                 
   344 000015B3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   344 000015BC 2D                 
   345                                          ; Arreglo de punteros a los spawn points de cada nivel
   346                                      spawn_points_table:
   347 000015BD [8B15000000000000]              dq level1_spawn_points
   348 000015C5 [9515000000000000]              dq level2_spawn_points
   349 000015CD [9F15000000000000]              dq level3_spawn_points
   350 000015D5 [A915000000000000]              dq level4_spawn_points
   351 000015DD [B315000000000000]              dq level5_spawn_points
   352                                  
   353                                      ; Variables para el comportamiento de enemigos
   354 000015E5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   355 000015E6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   356 000015E7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   357 000015E8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   358                                  
   359 000015F2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   359 000015FB 5B2020202020202020-
   359 00001604 20205D0A0D         
   360                                      score_label_len: equ $ - score_label
   361 00001609 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   361 00001612 657374727569646F73-
   361 0000161B 3A205B2020205D0A0D 
   362                                      blocks_label_len: equ $ - blocks_label
   363                                      
   364                                      ; Posición donde insertar los números en los labels
   365                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   366                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   367                                      
   368                                      ; Definición de las vidas (x, y, estado)
   369                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   370                                      lives_data: 
   371 00001624 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   372 00001627 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   373 0000162A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   374 0000162D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   375 00001630 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   376 00001633 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   377 00001636 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   378                                      lives_count equ 7    ; Total de vidas
   379 00001639 5E                          life_char db "^"    
   380 0000163A 04                          current_lives db 4   ; Contador de vidas activas actual
   381                                  
   382                                  ; Estructura para almacenar las letras y sus posiciones
   383                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   384 0000163B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   385 000017CB 00                          letters_count db 0   
   386 000017CC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   387 000017CD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   387 000017D6 75616C3A205B205D0A-
   387 000017DF 0D                 
   388                                      last_letter_msg_len equ $ - last_letter_msg
   389 000017E0 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   390 000017E1 07                          max_lives db 7              ; Máximo número de vidas permitidas
   391 000017E2 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   392 000017EA 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   393 000017F2 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   394                                  
   395 000017FA 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   396 000017FB 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   397 000017FC 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   398 00001804 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   399                                  
   400                                  
   401                                  section .text
   402                                  
   403                                  
   404                                  print_lives:
   405 000001DD 55                          push rbp
   406 000001DE 4889E5                      mov rbp, rsp
   407                                      
   408 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   409                                      
   410                                      .print_loop:
   411 000001E4 4983FC07                        cmp r12, lives_count
   412 000001E8 7D45                            jge .end
   413                                          
   414                                          ; Calcular offset de la vida actual
   415 000001EA 4C89E0                          mov rax, r12
   416 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   417 000001F1 488DB0[24160000]                lea rsi, [lives_data + rax]
   418                                          
   419                                          ; Calcular posición en el tablero
   420 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   421 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   422                                          
   423                                          ; Calcular offset en el tablero
   424 00000201 B84E000000                      mov rax, column_cells
   425 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   426 0000020A 49F7E1                          mul r9
   427 0000020D 4C01C0                          add rax, r8
   428 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   429                                          
   430                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   431 00000217 807E0201                        cmp byte [rsi + 2], 1
   432 0000021B 7405                            je .draw_active
   433                                          
   434                                          ; Si está inactiva, dibujar espacio
   435 0000021D C60720                          mov byte [rdi], ' '
   436 00000220 EB08                            jmp .next_life
   437                                          
   438                                      .draw_active:
   439                                          ; Si está activa, dibujar el símbolo de vida
   440 00000222 8A05(39160000)                  mov al, [life_char]
   441 00000228 8807                            mov [rdi], al
   442                                          
   443                                      .next_life:
   444 0000022A 49FFC4                          inc r12
   445 0000022D EBB5                            jmp .print_loop
   446                                          
   447                                      .end:
   448 0000022F 5D                              pop rbp
   449 00000230 C3                              ret
   450                                  
   451                                  ; Función para desactivar una vida
   452                                  ; Función modificada para perder una vida
   453                                  lose_life:
   454 00000231 55                          push rbp
   455 00000232 4889E5                      mov rbp, rsp
   456                                      
   457                                      ; Verificar si aún quedan vidas
   458 00000235 803D(3A160000)00            cmp byte [current_lives], 0
   459 0000023C 0F8493000000                je .game_lost
   460                                      
   461                                      ; Encontrar la última vida activa
   462 00000242 B907000000                  mov rcx, lives_count
   463 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   464                                      
   465                                      .find_active_life:
   466 0000024A 4889C8                          mov rax, rcx
   467 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   468 00000251 488DB0[24160000]                lea rsi, [lives_data + rax]
   469 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   470 0000025C 7407                            je .deactivate_life
   471 0000025E 48FFC9                          dec rcx
   472 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   473 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   474                                          
   475                                      .deactivate_life:
   476                                          ; Calcular posición correcta en el tablero para borrar la vida
   477 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   478 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   479                                          
   480                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   481 0000026E B84E000000                      mov rax, column_cells
   482 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   483 00000277 49F7E1                          mul r9
   484 0000027A 4C01C0                          add rax, r8
   485 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   486                                          
   487                                          ; Borrar visualmente la vida
   488 00000284 C60720                          mov byte [rdi], ' '             
   489                                          
   490                                          ; Desactivar la vida en los datos
   491 00000287 C6460200                        mov byte [rsi + 2], 0          
   492 0000028B FE0D(3A160000)                  dec byte [current_lives]
   493                                          
   494                                          ; Borrar visualmente la paleta anterior
   495 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   496 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   497                                          .erase_pallet_loop:
   498 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   499 000002A3 49FFC0                              inc r8
   500 000002A6 48FFC9                              dec rcx
   501 000002A9 75F4                                jnz .erase_pallet_loop
   502                                          
   503                                  
   504                                          ; Reiniciar posición de la bola y la paleta
   505 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   505 000002B3 000000             
   506 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   506 000002BE 000000             
   507 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   508 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   508 000002CF [36130000]         
   509                                          
   510 000002D3 EB07                            jmp .end
   511                                          
   512                                      .game_lost:
   513 000002D5 E81C000000                      call game_lost
   514 000002DA EB00                            jmp .end
   515                                          
   516                                      .end:
   517 000002DC 5D                              pop rbp
   518 000002DD C3                              ret
   519                                  ; Función modificada para verificar colisión con el borde inferior
   520                                  check_bottom_collision:
   521 000002DE 55                          push rbp
   522 000002DF 4889E5                      mov rbp, rsp
   523                                      
   524                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   525 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   526 000002E9 4883F81E                    cmp rax, row_cells - 2
   527 000002ED 7505                        jne .no_collision
   528                                      
   529                                      ; Si hay colisión, perder una vida
   530 000002EF E83DFFFFFF                  call lose_life
   531                                      
   532                                      .no_collision:
   533 000002F4 5D                              pop rbp
   534 000002F5 C3                              ret
   535                                  
   536                                  ; Nueva función para game over
   537                                  game_lost:
   538                                      ; Limpiar la pantalla
   539                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   540                                      
   541                                      ; Mostrar mensaje de derrota
   542                                      section .data
   543 00001805 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   543 0000180E 6469646F210A0D     
   544                                          lost_msg_len: equ $ - lost_msg
   545                                      section .text
   546                                      
   547                                      ; Imprimir mensaje de derrota
   548                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [0518000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   549                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [3318000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   550                                      
   551                                      ; Mostrar puntaje final
   552 00000347 488B05(3D150000)            mov rax, [current_score]
   553 0000034E 48BF-                       mov rdi, number_buffer
   553 00000350 [4615000000000000] 
   554 00000358 E8AF0A0000                  call number_to_string
   555                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   556                                      
   557                                      ; Esperar un momento antes de salir
   558 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   558 00000381 0000               
   559 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   559 0000038C 0000               
   560                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   561                                      
   562 000003A1 E955120000                  jmp exit
   563                                  
   564                                  
   565                                  ; Función para registrar una nueva letra en el mapa
   566                                  ; Entrada:
   567                                  ;   al - letra a registrar
   568                                  ;   r8b - posición x
   569                                  ;   r9b - posición y
   570                                  register_letter:
   571 000003A6 55                          push rbp
   572 000003A7 4889E5                      mov rbp, rsp
   573 000003AA 53                          push rbx
   574 000003AB 51                          push rcx
   575                                      
   576 000003AC 3C20                        cmp al, ' '
   577 000003AE 7438                        je .end
   578                                  
   579                                      ; Encontrar un espacio libre en el mapa
   580 000003B0 4831C9                      xor rcx, rcx
   581 000003B3 480FB615(CB170000)          movzx rdx, byte [letters_count]
   582                                      
   583                                      .find_slot:
   584 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   585 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   586                                          
   587 000003C1 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   588 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   589 000003CD 7405                            je .found_slot
   590                                          
   591 000003CF 48FFC1                          inc rcx
   592 000003D2 EBE7                            jmp .find_slot
   593                                          
   594                                      .found_slot:
   595                                          ; Guardar la información de la letra
   596 000003D4 448803                          mov [rbx], r8b           ; x
   597 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   598 000003DB 884302                          mov [rbx + 2], al        ; letra
   599 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   600                                          
   601 000003E2 FE05(CB170000)                  inc byte [letters_count]
   602                                          
   603                                      .end:
   604 000003E8 59                              pop rcx
   605 000003E9 5B                              pop rbx
   606 000003EA 5D                              pop rbp
   607 000003EB C3                              ret
   608                                  
   609                                  ; Función para imprimir todas las letras registradas
   610                                  print_letters:
   611 000003EC 55                          push rbp
   612 000003ED 4889E5                      mov rbp, rsp
   613 000003F0 53                          push rbx
   614 000003F1 51                          push rcx
   615                                      
   616 000003F2 4831C9                      xor rcx, rcx
   617                                      
   618                                      .print_loop:
   619 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   620 000003F9 7D37                            jge .end
   621                                          
   622                                          ; Obtener puntero a la letra actual
   623 000003FB 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   624                                          
   625                                          ; Verificar si está activa
   626 00000403 807B0300                        cmp byte [rbx + 3], 0
   627 00000407 7424                            je .next_letter
   628                                          
   629                                          ; Calcular posición en el tablero
   630 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   631 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   632                                          
   633                                          ; Calcular offset en el tablero
   634 00000412 B84E000000                      mov rax, column_cells
   635 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   636 0000041B 49F7E1                          mul r9
   637 0000041E 4C01C0                          add rax, r8
   638 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   639                                          
   640                                          ; Imprimir la letra
   641 00000428 8A4302                          mov al, [rbx + 2]
   642 0000042B 8807                            mov [rdi], al
   643                                          
   644                                      .next_letter:
   645 0000042D 48FFC1                          inc rcx
   646 00000430 EBC3                            jmp .print_loop
   647                                          
   648                                      .end:
   649 00000432 59                              pop rcx
   650 00000433 5B                              pop rbx
   651 00000434 5D                              pop rbp
   652 00000435 C3                              ret
   653                                  
   654                                  ; Función para borrar una letra específica
   655                                  ; Entrada:
   656                                  ;   r8b - posición x
   657                                  ;   r9b - posición y
   658                                  remove_letter:
   659 00000436 55                          push rbp
   660 00000437 4889E5                      mov rbp, rsp
   661 0000043A 53                          push rbx
   662 0000043B 51                          push rcx
   663                                      
   664 0000043C 4831C9                      xor rcx, rcx
   665                                      
   666                                      .find_loop:
   667 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   668 00000443 7D2E                            jge .end
   669                                          
   670 00000445 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   671                                          
   672                                          ; Verificar si está activa y coincide la posición
   673 0000044D 807B0300                        cmp byte [rbx + 3], 0
   674 00000451 741B                            je .next_letter
   675                                          
   676 00000453 8A03                            mov al, [rbx]
   677 00000455 4438C0                          cmp al, r8b
   678 00000458 7514                            jne .next_letter
   679                                          
   680 0000045A 8A4301                          mov al, [rbx + 1]
   681 0000045D 4438C8                          cmp al, r9b
   682 00000460 750C                            jne .next_letter
   683                                          
   684                                          ; Encontrada la letra, desactivarla
   685 00000462 C6430300                        mov byte [rbx + 3], 0
   686 00000466 FE0D(CB170000)                  dec byte [letters_count]
   687 0000046C EB05                            jmp .end
   688                                          
   689                                      .next_letter:
   690 0000046E 48FFC1                          inc rcx
   691 00000471 EBCC                            jmp .find_loop
   692                                          
   693                                      .end:
   694 00000473 59                              pop rcx
   695 00000474 5B                              pop rbx
   696 00000475 5D                              pop rbp
   697 00000476 C3                              ret
   698                                  ; Función para mover las letras hacia abajo
   699                                  move_letters:
   700 00000477 55                          push rbp
   701 00000478 4889E5                      mov rbp, rsp
   702 0000047B 53                          push rbx
   703 0000047C 57                          push rdi
   704 0000047D 56                          push rsi
   705 0000047E 4150                        push r8
   706 00000480 4151                        push r9
   707 00000482 4152                        push r10
   708 00000484 4153                        push r11
   709                                  
   710 00000486 4831C9                      xor rcx, rcx
   711                                  
   712                                      .move_loop:
   713 00000489 4883F964                        cmp rcx, 100
   714 0000048D 0F8D44010000                    jge .print_last_letter
   715                                          
   716 00000493 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   717 0000049B 807B0300                        cmp byte [rbx + 3], 0
   718 0000049F 0F842A010000                    je .next_letter
   719                                  
   720 000004A5 4C0FB603                        movzx r8, byte [rbx]
   721 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   722                                  
   723 000004AE B84E000000                      mov rax, column_cells
   724 000004B3 4883C002                        add rax, 2
   725 000004B7 49F7E1                          mul r9
   726 000004BA 4C01C0                          add rax, r8
   727 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   728 000004C4 C60720                          mov byte [rdi], ' '
   729                                  
   730 000004C7 FE4301                          inc byte [rbx + 1]
   731 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   732                                  
   733 000004CF 4983F91F                        cmp r9, row_cells - 1
   734 000004D3 7C09                            jl .check_pallet_collision
   735                                  
   736 000004D5 C6430300                        mov byte [rbx + 3], 0
   737 000004D9 E9F1000000                      jmp .next_letter
   738                                  
   739                                          .check_pallet_collision:
   740 000004DE B84E000000                          mov rax, column_cells
   741 000004E3 4883C002                            add rax, 2
   742 000004E7 49F7E1                              mul r9
   743 000004EA 4C01C0                              add rax, r8
   744 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   745                                  
   746 000004F4 8A07                                mov al, [rdi]
   747 000004F6 3C20                                cmp al, ' '
   748 000004F8 0F84D1000000                        je .next_letter
   749 000004FE 3C3D                                cmp al, char_equal
   750 00000500 740A                                je .capture_letter
   751                                  
   752 00000502 8A4302                              mov al, [rbx + 2]
   753 00000505 8807                                mov [rdi], al
   754 00000507 E9C3000000                          jmp .next_letter
   755                                  
   756                                          .capture_letter:
   757                                              ; Obtener la nueva letra
   758 0000050C 8A4302                              mov al, [rbx + 2]
   759                                              
   760                                              ; Comparar con la última letra
   761 0000050F 3A05(CC170000)                      cmp al, [last_letter]
   762 00000515 7407                                je .same_letter
   763                                              
   764                                              ; Es una letra diferente, resetear el procesamiento
   765 00000517 C605(E0170000)00                    mov byte [current_power_processed], 0
   766                                              
   767                                              .same_letter:
   768                                              ; Guardar la nueva letra
   769 0000051E 8805(CC170000)                      mov [last_letter], al
   770                                              
   771                                              ; Verificar si es 'E' para extender la paleta
   772 00000524 3C45                                cmp al, 'E'
   773 00000526 7432                                je .extend_pallet
   774                                              
   775                                              ; Verificar si es 'P' para añadir vida
   776 00000528 3C50                                cmp al, 'P'
   777 0000052A 7449                                je .check_add_life
   778                                  
   779 0000052C 3C53                                cmp al, 'S'
   780 0000052E 7477                                je .slow_ball
   781                                  
   782 00000530 3C43                                cmp al, 'C'
   783 00000532 0F848A000000                        je .activate_catch
   784                                              
   785                                              ; Si no es ningún power-up, restaurar tamaño normal
   786 00000538 488B05(4F140000)                    mov rax, [default_pallet_size]
   787 0000053F 488905(47140000)                    mov [pallet_size], rax
   788 00000546 48C705(E2170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   788 0000054E 000000             
   789 00000551 C605(FA170000)00                    mov byte [catch_power_active], 0
   790 00000558 EB71                                jmp .finish_capture
   791                                  
   792                                              .extend_pallet:
   793 0000055A 48C705(E2170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   793 00000562 000000             
   794 00000565 488B05(57140000)                        mov rax, [extended_pallet_size]
   795 0000056C 488905(47140000)                        mov [pallet_size], rax
   796 00000573 EB56                                    jmp .finish_capture
   797                                  
   798                                              .check_add_life:
   799 00000575 488B05(4F140000)                        mov rax, [default_pallet_size]
   800 0000057C 488905(47140000)                        mov [pallet_size], rax
   801 00000583 48C705(E2170000)01-                     mov qword [ball_speed], 1 
   801 0000058B 000000             
   802                                                  ; Verificar si ya procesamos este power-up
   803 0000058E 803D(E0170000)00                        cmp byte [current_power_processed], 0
   804 00000595 7534                                    jne .finish_capture
   805                                                  
   806                                                  ; Preservar registros importantes
   807 00000597 51                                      push rcx
   808 00000598 53                                      push rbx
   809                                                  
   810                                                  ; Marcar como procesado
   811 00000599 C605(E0170000)01                        mov byte [current_power_processed], 1
   812                                                  
   813                                                  ; Añadir una vida
   814 000005A0 E881000000                              call add_life
   815                                                  
   816                                                  ; Restaurar registros
   817 000005A5 5B                                      pop rbx
   818 000005A6 59                                      pop rcx
   819                                                  
   820                                              .slow_ball:
   821 000005A7 488B05(4F140000)                        mov rax, [default_pallet_size]
   822 000005AE 488905(47140000)                        mov [pallet_size], rax
   823 000005B5 48C705(E2170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   823 000005BD 000000             
   824 000005C0 EB09                                    jmp .finish_capture
   825                                  
   826                                              .activate_catch:
   827 000005C2 C605(FA170000)01                        mov byte [catch_power_active], 1
   828 000005C9 EB00                                    jmp .finish_capture
   829                                  
   830                                              .finish_capture:
   831 000005CB C6430300                                mov byte [rbx + 3], 0
   832                                  
   833                                          .next_letter:
   834 000005CF 48FFC1                              inc rcx
   835 000005D2 E9B2FEFFFF                          jmp .move_loop
   836                                  
   837                                      .print_last_letter:
   838                                          print last_letter_msg, last_letter_msg_len - 3
    82 000005D7 B801000000          <1>  mov eax, sys_write
    83 000005DC BF01000000          <1>  mov edi, 1
    84 000005E1 48BE-               <1>  mov rsi, %1
    84 000005E3 [CD17000000000000]  <1>
    85 000005EB BA10000000          <1>  mov edx, %2
    86 000005F0 0F05                <1>  syscall
   839 000005F2 8A05(CC170000)                  mov al, [last_letter]
   840 000005F8 8805(DC170000)                  mov [last_letter_msg + 15], al
   841                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 000005FE B801000000          <1>  mov eax, sys_write
    83 00000603 BF01000000          <1>  mov edi, 1
    84 00000608 48BE-               <1>  mov rsi, %1
    84 0000060A [DD17000000000000]  <1>
    85 00000612 BA03000000          <1>  mov edx, %2
    86 00000617 0F05                <1>  syscall
   842                                  
   843                                      .end:
   844 00000619 415B                            pop r11
   845 0000061B 415A                            pop r10
   846 0000061D 4159                            pop r9
   847 0000061F 4158                            pop r8
   848 00000621 5E                              pop rsi
   849 00000622 5F                              pop rdi
   850 00000623 5B                              pop rbx
   851 00000624 5D                              pop rbp
   852 00000625 C3                              ret
   853                                  
   854                                  add_life:
   855 00000626 55                          push rbp
   856 00000627 4889E5                      mov rbp, rsp
   857 0000062A 53                          push rbx
   858 0000062B 51                          push rcx
   859 0000062C 57                          push rdi
   860 0000062D 56                          push rsi
   861 0000062E 4150                        push r8
   862 00000630 4151                        push r9
   863                                      
   864                                      ; Verificar si ya tenemos el máximo de vidas
   865 00000632 480FB605(3A160000)          movzx rax, byte [current_lives]
   866 0000063A 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
   867 0000063E 7D2C                        jge .end
   868                                      
   869                                      ; Incrementar el contador de vidas
   870 00000640 FE05(3A160000)              inc byte [current_lives]
   871                                      
   872                                      ; Encontrar la siguiente vida inactiva
   873 00000646 4831C9                      xor rcx, rcx
   874                                      
   875                                      .find_inactive:
   876 00000649 4883F907                        cmp rcx, lives_count
   877 0000064D 7D1D                            jge .end
   878                                          
   879                                          ; Calcular offset de la vida actual
   880 0000064F 4889C8                          mov rax, rcx
   881 00000652 486BC003                        imul rax, 3
   882 00000656 488DB0[24160000]                lea rsi, [lives_data + rax]
   883                                          
   884                                          ; Verificar si está inactiva
   885 0000065D 807E0200                        cmp byte [rsi + 2], 0
   886 00000661 7405                            je .activate_life
   887                                          
   888 00000663 48FFC1                          inc rcx
   889 00000666 EBE1                            jmp .find_inactive
   890                                          
   891                                      .activate_life:
   892                                          ; Activar la vida
   893 00000668 C6460201                        mov byte [rsi + 2], 1
   894                                          
   895                                      .end:
   896 0000066C 4159                            pop r9
   897 0000066E 4158                            pop r8
   898 00000670 5E                              pop rsi
   899 00000671 5F                              pop rdi
   900 00000672 59                              pop rcx
   901 00000673 5B                              pop rbx
   902 00000674 5D                              pop rbp
   903 00000675 C3                              ret
   904                                  
   905                                  
   906                                  print_ball:
   907 00000676 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   908 0000067D 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   909 00000684 4981C0[000A0000]        	add r8, board
   910                                  
   911 0000068B 4C89C9                  	mov rcx, r9
   912 0000068E B850000000              	mov rax, column_cells + 2
   913 00000693 48F7E9                  	imul rcx
   914                                  	
   915 00000696 4901C0                  	add r8, rax
   916 00000699 41C6004F                	mov byte [r8], char_O
   917 0000069D C3                      	ret
   918                                  
   919                                  	
   920                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   921                                  	
   922                                  print_pallet:
   923                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   924 0000069E 4C8B05(3F140000)            mov r8, [pallet_position]
   925 000006A5 488B0D(57140000)            mov rcx, [extended_pallet_size]
   926                                      .clear_pallet:
   927 000006AC 41C60020                        mov byte [r8], char_space
   928 000006B0 49FFC0                          inc r8
   929 000006B3 48FFC9                          dec rcx
   930 000006B6 75F4                            jnz .clear_pallet
   931                                  
   932                                      ; Luego dibujar la nueva paleta con el tamaño actual
   933 000006B8 4C8B05(3F140000)            mov r8, [pallet_position]
   934 000006BF 488B0D(47140000)            mov rcx, [pallet_size]
   935                                      .write_pallet:
   936 000006C6 41C6003D                        mov byte [r8], char_equal
   937 000006CA 49FFC0                          inc r8
   938 000006CD 48FFC9                          dec rcx
   939 000006D0 75F4                            jnz .write_pallet
   940                                  
   941 000006D2 C3                          ret
   942                                  
   943                                  move_pallet:
   944 000006D3 803D(7F140000)00            cmp byte [ball_moving], 0
   945 000006DA 7507                        jne .continue_movement
   946 000006DC C605(7F140000)01            mov byte [ball_moving], 1
   947                                  
   948                                      .continue_movement:
   949 000006E3 4883FFFF                        cmp rdi, left_direction
   950 000006E7 752C                            jne .move_right
   951                                  
   952                                          .move_left:
   953 000006E9 4C8B05(3F140000)                    mov r8, [pallet_position]
   954 000006F0 418A40FF                            mov al, [r8 - 1]       ; Revisar la siguiente posición antes de mover
   955 000006F4 3C58                                cmp al, 'X'        
   956 000006F6 7445                                je .end            
   957                                              
   958 000006F8 4C8B05(3F140000)                    mov r8, [pallet_position]
   959 000006FF 4C8B0D(47140000)                    mov r9, [pallet_size]
   960 00000706 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter
   961 0000070C 48FF0D(3F140000)                    dec qword [pallet_position]         ; Decrementar la posición directamente en memoria
   962 00000713 EB28                                jmp .end
   963                                              
   964                                          .move_right:
   965 00000715 4C8B05(3F140000)                    mov r8, [pallet_position]
   966 0000071C 4C8B0D(47140000)                    mov r9, [pallet_size]
   967 00000723 438A0408                            mov al, [r8 + r9]      ; Revisar la siguiente posición antes de mover
   968 00000727 3C58                                cmp al, 'X'       
   969 00000729 7412                                je .end           
   970                                              
   971 0000072B 4C8B05(3F140000)                    mov r8, [pallet_position]
   972 00000732 41C60020                            mov byte [r8], char_space          ; Borrar primer carácter
   973 00000736 48FF05(3F140000)                    inc qword [pallet_position]        ; Incrementar la posición directamente en memoria
   974                                              
   975                                          .end:
   976 0000073D C3                                  ret
   977                                  
   978                                              
   979                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
   980                                  update_caught_ball_position:
   981 0000073E 55                          push rbp
   982 0000073F 4889E5                      mov rbp, rsp
   983                                      
   984                                      ; Calcular la nueva posición de la bola basada en la paleta
   985 00000742 4C8B05(3F140000)            mov r8, [pallet_position]
   986 00000749 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
   987 00000750 B850000000                  mov rax, column_cells + 2
   988 00000755 4831D2                      xor rdx, rdx
   989 00000758 48F7F0                      div rax                ; División para obtener X,Y
   990                                      
   991                                      ; rdx contiene X (resto), rax contiene Y (cociente)
   992 0000075B 4989C1                      mov r9, rax            ; Y de la paleta
   993 0000075E 49FFC9                      dec r9                 ; Una posición arriba de la paleta
   994                                      
   995                                      ; Añadir el offset guardado a la posición X
   996 00000761 4889D0                      mov rax, rdx
   997 00000764 480305(FC170000)            add rax, [ball_catch_offset]
   998 0000076B 488905(5F140000)            mov [ball_x_pos], rax
   999 00000772 4C890D(67140000)            mov [ball_y_pos], r9
  1000                                      
  1001 00000779 5D                          pop rbp
  1002 0000077A C3                          ret
  1003                                  move_ball:
  1004                                  
  1005 0000077B 803D(FB170000)01            cmp byte [ball_caught], 1
  1006 00000782 0F849D000000                je .move_with_pallet
  1007                                  
  1008 00000788 803D(7F140000)00            cmp byte [ball_moving], 0
  1009 0000078F 0F84B8010000                je .end
  1010                                  
  1011                                      ; Incrementar contador de velocidad
  1012 00000795 48FF05(F2170000)            inc qword [speed_counter]
  1013                                      
  1014                                      ; Verificar si debemos mover la bola en este ciclo
  1015 0000079C 488B05(F2170000)            mov rax, [speed_counter]
  1016 000007A3 483B05(E2170000)            cmp rax, [ball_speed]
  1017 000007AA 0F8C9D010000                jl .end
  1018                                      
  1019                                      ; Resetear contador de velocidad
  1020 000007B0 48C705(F2170000)00-         mov qword [speed_counter], 0
  1020 000007B8 000000             
  1021                                  
  1022                                      ; Borrar la posición actual de la bola
  1023 000007BB 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1024 000007C2 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1025 000007C9 4981C0[000A0000]            add r8, board
  1026 000007D0 4C89C9                      mov rcx, r9
  1027 000007D3 B850000000                  mov rax, column_cells + 2
  1028 000007D8 48F7E9                      imul rcx
  1029 000007DB 4901C0                      add r8, rax
  1030 000007DE 41C60020                    mov byte [r8], char_space
  1031                                  
  1032                                      ; Calcular siguiente posición X
  1033 000007E2 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1034 000007E9 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1035 000007F0 488B05(6F140000)            mov rax, [ball_direction_x]
  1036 000007F7 4901C0                      add r8, rax               ; Nueva posición X
  1037                                  
  1038                                      ; Calcular la dirección de memoria para la siguiente posición
  1039 000007FA 4D89C2                      mov r10, r8
  1040 000007FD 4981C2[000A0000]            add r10, board
  1041 00000804 4C89C9                      mov rcx, r9
  1042 00000807 B850000000                  mov rax, column_cells + 2
  1043 0000080C 48F7E9                      imul rcx
  1044 0000080F 4901C2                      add r10, rax
  1045                                  
  1046                                      ; Verificar si hay una X en la siguiente posición X
  1047 00000812 418A02                      mov al, [r10]
  1048 00000815 3C58                        cmp al, 'X'
  1049 00000817 7565                        jne .check_block_x
  1050 00000819 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1051 00000820 E928010000                  jmp .end
  1052                                  
  1053                                      .move_with_pallet:
  1054                                          ; Borrar la posición actual de la bola
  1055 00000825 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1056 0000082C 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1057 00000833 4D89C2                          mov r10, r8
  1058 00000836 4981C2[000A0000]                add r10, board
  1059 0000083D 4C89C9                          mov rcx, r9
  1060 00000840 B850000000                      mov rax, column_cells + 2
  1061 00000845 48F7E9                          imul rcx
  1062 00000848 4901C2                          add r10, rax
  1063 0000084B 41C60220                        mov byte [r10], char_space
  1064                                  
  1065                                          ; Actualizar posición X basada en la paleta
  1066 0000084F 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1067 00000856 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1068 0000085D 4C0305(FC170000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1069 00000864 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1070                                  
  1071                                          ; Mantener la bola una posición arriba de la paleta
  1072 0000086B 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1073 00000872 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1074                                  
  1075 00000879 E9CF000000                      jmp .end
  1076                                  
  1077                                  
  1078                                      .check_block_x:
  1079                                          ; Verificar colisión con bloques en X
  1080 0000087E 4150                            push r8     ; Guardar registros que usa check_block_collision
  1081 00000880 4151                            push r9
  1082 00000882 4152                            push r10
  1083 00000884 E8DB060000                      call check_block_collision
  1084 00000889 415A                            pop r10
  1085 0000088B 4159                            pop r9
  1086 0000088D 4158                            pop r8
  1087 0000088F 4885C0                          test rax, rax
  1088 00000892 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1089 00000894 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1090 0000089B E9AD000000                      jmp .end
  1091                                  
  1092                                      .check_paddle_x:
  1093                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1094 000008A0 41803A3D                        cmp byte [r10], char_equal
  1095 000008A4 750C                            jne .check_y_movement
  1096 000008A6 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1097 000008AD E99B000000                      jmp .end
  1098                                  
  1099                                      .check_y_movement:
  1100                                          ; Calcular siguiente posición Y
  1101 000008B2 488B05(77140000)                mov rax, [ball_direction_y]
  1102 000008B9 4901C1                          add r9, rax                  ; Nueva posición Y
  1103                                  
  1104                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1105 000008BC 4D89C2                          mov r10, r8
  1106 000008BF 4981C2[000A0000]                add r10, board
  1107 000008C6 4C89C9                          mov rcx, r9
  1108 000008C9 B850000000                      mov rax, column_cells + 2
  1109 000008CE 48F7E9                          imul rcx
  1110 000008D1 4901C2                          add r10, rax
  1111                                  
  1112                                          ; Verificar si hay una X en la siguiente posición Y
  1113 000008D4 418A02                          mov al, [r10]
  1114 000008D7 3C58                            cmp al, 'X'
  1115 000008D9 7509                            jne .check_block_y
  1116 000008DB 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1117 000008E2 EB69                            jmp .end
  1118                                  
  1119                                      .check_block_y:
  1120                                          ; Verificar colisión con bloques en Y
  1121 000008E4 4150                            push r8     ; Guardar registros que usa check_block_collision
  1122 000008E6 4151                            push r9
  1123 000008E8 4152                            push r10
  1124 000008EA E875060000                      call check_block_collision
  1125 000008EF 415A                            pop r10
  1126 000008F1 4159                            pop r9
  1127 000008F3 4158                            pop r8
  1128 000008F5 4885C0                          test rax, rax
  1129 000008F8 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1130 000008FA 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1131 00000901 EB4A                            jmp .end
  1132                                  
  1133                                      .check_paddle_y:
  1134                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1135 00000903 41803A3D                        cmp byte [r10], char_equal
  1136 00000907 7536                            jne .update_position
  1137                                  
  1138                                          ; Verificar si el poder catch está activo
  1139 00000909 803D(FA170000)01                cmp byte [catch_power_active], 1
  1140 00000910 7524                            jne .normal_bounce
  1141                                  
  1142                                          ; Activar el modo "atrapado"
  1143 00000912 C605(FB170000)01                mov byte [ball_caught], 1
  1144                                          
  1145                                          ; Guardar la posición X actual de la bola como offset
  1146 00000919 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1147 00000920 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1148 00000927 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1149 0000092D 488905(FC170000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1150                                          
  1151 00000934 EB17                            jmp .end
  1152                                  
  1153                                      .normal_bounce:
  1154 00000936 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1155 0000093D EB0E                            jmp .end
  1156                                  
  1157                                  
  1158                                      .update_position:
  1159 0000093F 4C8905(5F140000)                mov [ball_x_pos], r8
  1160 00000946 4C890D(67140000)                mov [ball_y_pos], r9
  1161                                  
  1162                                      .end:
  1163 0000094D C3                              ret
  1164                                  
  1165                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1166                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1167                                  process_catch_release:
  1168 0000094E 55                          push rbp
  1169 0000094F 4889E5                      mov rbp, rsp
  1170                                  
  1171                                      ; Verificar si la bola está atrapada
  1172 00000952 803D(FB170000)00            cmp byte [ball_caught], 0
  1173 00000959 7436                        je .end
  1174                                  
  1175                                      ; Verificar si el poder catch está activo
  1176 0000095B 803D(FA170000)01            cmp byte [catch_power_active], 1
  1177 00000962 752D                        jne .end
  1178                                  
  1179                                      ; Verificar si se presionó la tecla 'c'
  1180 00000964 803D(04180000)63            cmp byte [last_key], 'c'
  1181 0000096B 7524                        jne .end
  1182                                  
  1183                                      ; Liberar la bola y asignar dirección inicial
  1184 0000096D C605(FB170000)00            mov byte [ball_caught], 0
  1185 00000974 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1185 0000097C 000000             
  1186 0000097F 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1186 00000987 FFFFFF             
  1187                                  
  1188                                      ; Limpiar la tecla procesada
  1189 0000098A C605(04180000)00            mov byte [last_key], 0
  1190                                  
  1191                                      .end:
  1192 00000991 5D                              pop rbp
  1193 00000992 C3                              ret
  1194                                  
  1195                                  
  1196                                  display_level_number:
  1197 00000993 55                          push rbp
  1198 00000994 4889E5                      mov rbp, rsp
  1199                                      
  1200                                      ; Limpiar la pantalla primero
  1201                                      print clear, clear_length
    82 00000997 B801000000          <1>  mov eax, sys_write
    83 0000099C BF01000000          <1>  mov edi, 1
    84 000009A1 48BE-               <1>  mov rsi, %1
    84 000009A3 [1000000000000000]  <1>
    85 000009AB BA07000000          <1>  mov edx, %2
    86 000009B0 0F05                <1>  syscall
  1202                                      
  1203                                      ; Calcular la posición central para el mensaje
  1204                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1205 000009B2 B84E000000                  mov rax, column_cells
  1206 000009B7 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1207 000009BB 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1208                                      
  1209                                      ; Calcular la fila central
  1210 000009BE BB20000000                  mov rbx, row_cells
  1211 000009C3 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1212                                      
  1213                                      ; Calcular el offset en el buffer
  1214 000009C6 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1215 000009CB 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1216 000009CE 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1217                                      
  1218                                      ; Escribir "NIVEL " en la posición calculada
  1219 000009D1 488DB8[000A0000]            lea rdi, [board + rax]
  1220 000009D8 48BE-                       mov rsi, level_msg
  1220 000009DA [2414000000000000] 
  1221 000009E2 B906000000                  mov rcx, level_msg_len
  1222 000009E7 F3A4                        rep movsb
  1223                                      
  1224                                      ; Escribir el número del nivel
  1225 000009E9 8A05(B4140000)              mov al, [current_level]
  1226 000009EF 0430                        add al, '0'                 ; convertir a ASCII
  1227 000009F1 8807                        mov [rdi], al
  1228                                      
  1229                                      ; Mostrar el board con el mensaje
  1230                                      print board, board_size
    82 000009F3 B801000000          <1>  mov eax, sys_write
    83 000009F8 BF01000000          <1>  mov edi, 1
    84 000009FD 48BE-               <1>  mov rsi, %1
    84 000009FF [000A000000000000]  <1>
    85 00000A07 BA000A0000          <1>  mov edx, %2
    86 00000A0C 0F05                <1>  syscall
  1231                                      
  1232                                      ; Esperar un segundo
  1233 00000A0E B823000000                  mov rax, sys_nanosleep
  1234 00000A13 48BF-                       mov rdi, level_display_time
  1234 00000A15 [2F14000000000000] 
  1235 00000A1D 4831F6                      xor rsi, rsi
  1236 00000A20 0F05                        syscall
  1237                                      
  1238 00000A22 5D                          pop rbp
  1239 00000A23 C3                          ret
  1240                                  
  1241                                  ; Función para inicializar un tablero vacío
  1242                                  init_empty_board:
  1243 00000A24 56                          push rsi
  1244 00000A25 57                          push rdi
  1245 00000A26 51                          push rcx
  1246 00000A27 50                          push rax
  1247                                  
  1248 00000A28 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1249 00000A2F 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1250 00000A36 B9000A0000                  mov rcx, board_template_size
  1251 00000A3B F3A4                        rep movsb                   ; Copiar el tablero
  1252                                  
  1253 00000A3D 58                          pop rax
  1254 00000A3E 59                          pop rcx
  1255 00000A3F 5F                          pop rdi
  1256 00000A40 5E                          pop rsi
  1257 00000A41 C3                          ret
  1258                                  
  1259                                  
  1260                                  init_level:
  1261                                  
  1262 00000A42 488B05(4F140000)            mov rax, [default_pallet_size]
  1263 00000A49 488905(47140000)            mov [pallet_size], rax
  1264 00000A50 48C705(E2170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1264 00000A58 000000             
  1265                                  
  1266                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1267                                          ; Reiniciar letras activas
  1268 00000A5B 488D3D(3B160000)            lea rdi, [letters_map]
  1269 00000A62 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1270 00000A67 4831C0                      xor rax, rax
  1271 00000A6A F3AA                        rep stosb                    ; Llenar con ceros
  1272                                      
  1273                                      ; Inicializar dirección de la bola (derecha y arriba)
  1274 00000A6C 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1274 00000A74 000000             
  1275 00000A77 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1275 00000A7F FFFFFF             
  1276                                  
  1277                                  
  1278                                      ; Reiniciar contador de letras activas
  1279 00000A82 4831C0                      xor rax, rax
  1280 00000A85 8805(CB170000)              mov [letters_count], al
  1281                                  
  1282                                      ; Reiniciar última letra capturada
  1283 00000A8B C605(CC170000)20            mov byte [last_letter], ' '
  1284 00000A92 C605(45150000)00            mov byte [destroyed_blocks], 0 
  1285 00000A99 E886FFFFFF                  call init_empty_board
  1286 00000A9E E8F0FEFFFF                  call display_level_number
  1287 00000AA3 E8E5050000                  call init_enemies
  1288                                      
  1289 00000AA8 56                          push rsi
  1290 00000AA9 57                          push rdi
  1291 00000AAA 51                          push rcx
  1292 00000AAB 50                          push rax
  1293                                  
  1294 00000AAC 488D35(00000000)            lea rsi, [board_template]
  1295 00000AB3 488D3D(000A0000)            lea rdi, [board]
  1296 00000ABA B9000A0000                  mov rcx, board_template_size
  1297 00000ABF F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1298                                  
  1299 00000AC1 58                          pop rax
  1300 00000AC2 59                          pop rcx
  1301 00000AC3 5F                          pop rdi
  1302 00000AC4 5E                          pop rsi
  1303                                  
  1304 00000AC5 B90A000000                  mov rcx, 10
  1305 00000ACA 4831C0                      xor rax, rax
  1306 00000ACD 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1307 00000AD4 F3AA                        rep stosb      
  1308                                  
  1309                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1310 00000AD6 803D(B4140000)01            cmp byte [current_level], 1
  1311 00000ADD 7431                        je .level1
  1312 00000ADF 803D(B4140000)02            cmp byte [current_level], 2
  1313 00000AE6 7454                        je .level2
  1314 00000AE8 803D(B4140000)03            cmp byte [current_level], 3
  1315 00000AEF 7477                        je .level3
  1316 00000AF1 803D(B4140000)04            cmp byte [current_level], 4
  1317 00000AF8 0F8492000000                je .level4
  1318 00000AFE 803D(B4140000)05            cmp byte [current_level], 5
  1319 00000B05 0F84AD000000                je .level5
  1320 00000B0B E9D0000000                  jmp .done
  1321                                  
  1322                                  
  1323                                  
  1324                                      .level1:
  1325 00000B10 C605(B5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1326 00000B17 4831C9                          xor rcx, rcx             
  1327                                          .init_loop1:
  1328 00000B1A 4883F903                            cmp rcx, level1_blocks_count
  1329 00000B1E 0F8DBC000000                        jge .done
  1330 00000B24 4889C8                              mov rax, rcx         
  1331 00000B27 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1332 00000B2B 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1333 00000B31 8891[D9140000]                      mov byte [block_states + rcx], dl
  1334 00000B37 48FFC1                              inc rcx
  1335 00000B3A EBDE                                jmp .init_loop1
  1336                                  
  1337                                      .level2:
  1338 00000B3C C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1339 00000B43 4831C9                          xor rcx, rcx             
  1340                                          .init_loop2:
  1341 00000B46 4883F901                            cmp rcx, level2_blocks_count
  1342 00000B4A 0F8D90000000                        jge .done
  1343 00000B50 4889C8                              mov rax, rcx         
  1344 00000B53 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1345 00000B57 8A90[C8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1346 00000B5D 8891[D9140000]                      mov byte [block_states + rcx], dl
  1347 00000B63 48FFC1                              inc rcx
  1348 00000B66 EBDE                                jmp .init_loop2
  1349                                      .level3:
  1350 00000B68 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1351 00000B6F 4831C9                          xor rcx, rcx             
  1352                                          .init_loop3:
  1353 00000B72 4883F901                            cmp rcx, level3_blocks_count
  1354 00000B76 7D68                                jge .done
  1355 00000B78 4889C8                              mov rax, rcx         
  1356 00000B7B 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1357 00000B7F 8A90[CD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1358 00000B85 8891[D9140000]                      mov byte [block_states + rcx], dl
  1359 00000B8B 48FFC1                              inc rcx
  1360 00000B8E EBE2                                jmp .init_loop3
  1361                                  
  1362                                      .level4:
  1363 00000B90 C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1364 00000B97 4831C9                          xor rcx, rcx             
  1365                                          .init_loop4:
  1366 00000B9A 4883F901                            cmp rcx, level4_blocks_count
  1367 00000B9E 7D40                                jge .done
  1368 00000BA0 4889C8                              mov rax, rcx         
  1369 00000BA3 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1370 00000BA7 8A90[D2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1371 00000BAD 8891[D9140000]                      mov byte [block_states + rcx], dl
  1372 00000BB3 48FFC1                              inc rcx
  1373 00000BB6 EBE2                                jmp .init_loop4
  1374                                  
  1375                                      .level5:
  1376 00000BB8 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1377 00000BBF 4831C9                          xor rcx, rcx             
  1378                                          .init_loop5:
  1379 00000BC2 4883F901                            cmp rcx, level5_blocks_count
  1380 00000BC6 7D18                                jge .done
  1381 00000BC8 4889C8                              mov rax, rcx         
  1382 00000BCB 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1383 00000BCF 8A90[D7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1384 00000BD5 8891[D9140000]                      mov byte [block_states + rcx], dl
  1385 00000BDB 48FFC1                              inc rcx
  1386 00000BDE EBE2                                jmp .init_loop5
  1387                                      .done:
  1388 00000BE0 C3                              ret
  1389                                  
  1390                                  
  1391                                  ; Función para verificar y manejar la transición de nivel
  1392                                  check_level_complete:
  1393                                      ; Verificar si quedan bloques
  1394 00000BE1 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1395 00000BE8 753C                        jne .not_complete
  1396                                      
  1397                                      ; Incrementar el nivel
  1398 00000BEA FE05(B4140000)              inc byte [current_level]
  1399                                      
  1400                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1401 00000BF0 803D(B4140000)06            cmp byte [current_level], 6
  1402 00000BF7 742E                        je game_win
  1403                                      
  1404                                      ; Reinicializar el juego para el siguiente nivel
  1405 00000BF9 E844FEFFFF                  call init_level
  1406                                      
  1407                                      ; Reinicializar la posición de la bola y la paleta
  1408 00000BFE 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1408 00000C06 000000             
  1409 00000C09 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1409 00000C11 000000             
  1410 00000C14 C605(7F140000)00            mov byte [ball_moving], 0
  1411 00000C1B 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1411 00000C22 [36130000]         
  1412                                      
  1413                                      .not_complete:
  1414 00000C26 C3                              ret
  1415                                  
  1416                                      ; Nueva función para manejar la victoria del juego
  1417                                  game_win:
  1418                                      ; Limpiar la pantalla primero
  1419                                      print clear, clear_length
    82 00000C27 B801000000          <1>  mov eax, sys_write
    83 00000C2C BF01000000          <1>  mov edi, 1
    84 00000C31 48BE-               <1>  mov rsi, %1
    84 00000C33 [1000000000000000]  <1>
    85 00000C3B BA07000000          <1>  mov edx, %2
    86 00000C40 0F05                <1>  syscall
  1420                                      
  1421                                      ; Mensaje de victoria
  1422 00000C42 488B05(3D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1423 00000C49 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1423 00000C4B [4615000000000000] 
  1424 00000C53 E8B4010000                  call number_to_string
  1425                                      
  1426                                      ; Definir mensaje de victoria
  1427                                      section .data
  1428 00001815 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1428 0000181E 616465732120C2A148-
  1428 00001827 61732067616E61646F-
  1428 00001830 210A0D             
  1429                                          win_msg_len: equ $ - win_msg
  1430 00001833 50756E74616A652066-             score_msg: db "Puntaje final: "
  1430 0000183C 696E616C3A20       
  1431                                          score_msg_len: equ $ - score_msg
  1432                                      section .text
  1433                                      
  1434                                      ; Imprimir mensajes
  1435                                      print win_msg, win_msg_len
    82 00000C58 B801000000          <1>  mov eax, sys_write
    83 00000C5D BF01000000          <1>  mov edi, 1
    84 00000C62 48BE-               <1>  mov rsi, %1
    84 00000C64 [1518000000000000]  <1>
    85 00000C6C BA1E000000          <1>  mov edx, %2
    86 00000C71 0F05                <1>  syscall
  1436                                      print score_msg, score_msg_len
    82 00000C73 B801000000          <1>  mov eax, sys_write
    83 00000C78 BF01000000          <1>  mov edi, 1
    84 00000C7D 48BE-               <1>  mov rsi, %1
    84 00000C7F [3318000000000000]  <1>
    85 00000C87 BA0F000000          <1>  mov edx, %2
    86 00000C8C 0F05                <1>  syscall
  1437                                      print number_buffer, 20
    82 00000C8E B801000000          <1>  mov eax, sys_write
    83 00000C93 BF01000000          <1>  mov edi, 1
    84 00000C98 48BE-               <1>  mov rsi, %1
    84 00000C9A [4615000000000000]  <1>
    85 00000CA2 BA14000000          <1>  mov edx, %2
    86 00000CA7 0F05                <1>  syscall
  1438                                      
  1439                                      ; Esperar un momento antes de salir
  1440 00000CA9 48C7054CF3FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1440 00000CB2 0000               
  1441 00000CB4 48C70549F3FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1441 00000CBD 0000               
  1442                                      sleeptime
    98 00000CBF B823000000          <1>  mov eax, sys_nanosleep
    99 00000CC4 48BF-               <1>  mov rdi, timespec
    99 00000CC6 [0000000000000000]  <1>
   100 00000CCE 31F6                <1>  xor esi, esi
   101 00000CD0 0F05                <1>  syscall
  1443                                      
  1444 00000CD2 E924090000                  jmp exit
  1445                                  
  1446                                  ; Función para imprimir los bloques
  1447                                  ; Función modificada para imprimir bloques
  1448                                  
  1449                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1450                                  get_current_level_blocks:
  1451 00000CD7 803D(B4140000)01            cmp byte [current_level], 1
  1452 00000CDE 7428                        je .level1
  1453 00000CE0 803D(B4140000)02            cmp byte [current_level], 2
  1454 00000CE7 7427                        je .level2
  1455 00000CE9 803D(B4140000)03            cmp byte [current_level], 3
  1456 00000CF0 7426                        je .level3
  1457 00000CF2 803D(B4140000)04            cmp byte [current_level], 4
  1458 00000CF9 7425                        je .level4
  1459 00000CFB 803D(B4140000)05            cmp byte [current_level], 5
  1460 00000D02 7424                        je .level5
  1461                                      ; Si llegamos aquí, hay un error en el nivel
  1462 00000D04 4831C0                      xor rax, rax
  1463 00000D07 C3                          ret
  1464                                  
  1465                                      .level1:
  1466 00000D08 488D05(B6140000)                lea rax, [level1_blocks]
  1467 00000D0F C3                              ret
  1468                                      .level2:
  1469 00000D10 488D05(C5140000)                lea rax, [level2_blocks]
  1470 00000D17 C3                              ret
  1471                                      .level3:
  1472 00000D18 488D05(CA140000)                lea rax, [level3_blocks]
  1473 00000D1F C3                              ret
  1474                                      .level4:
  1475 00000D20 488D05(CF140000)                lea rax, [level4_blocks]
  1476 00000D27 C3                              ret
  1477                                      .level5:
  1478 00000D28 488D05(D4140000)                lea rax, [level5_blocks]
  1479 00000D2F C3                              ret
  1480                                  ; Función para obtener la cantidad de bloques del nivel actual
  1481                                  get_current_level_count:
  1482 00000D30 803D(B4140000)01            cmp byte [current_level], 1
  1483 00000D37 7428                        je .level1
  1484 00000D39 803D(B4140000)02            cmp byte [current_level], 2
  1485 00000D40 7425                        je .level2
  1486 00000D42 803D(B4140000)03            cmp byte [current_level], 3
  1487 00000D49 7422                        je .level3
  1488 00000D4B 803D(B4140000)04            cmp byte [current_level], 4
  1489 00000D52 741F                        je .level4
  1490 00000D54 803D(B4140000)05            cmp byte [current_level], 5
  1491 00000D5B 741C                        je .level5
  1492                                      ; Si llegamos aquí, hay un error en el nivel
  1493 00000D5D 4831C0                      xor rax, rax
  1494 00000D60 C3                          ret
  1495                                  
  1496                                      .level1:
  1497 00000D61 B803000000                      mov rax, level1_blocks_count
  1498 00000D66 C3                              ret
  1499                                      .level2:
  1500 00000D67 B801000000                      mov rax, level2_blocks_count
  1501 00000D6C C3                              ret
  1502                                      .level3:
  1503 00000D6D B801000000                      mov rax, level3_blocks_count
  1504 00000D72 C3                              ret
  1505                                      .level4:
  1506 00000D73 B801000000                      mov rax, level4_blocks_count
  1507 00000D78 C3                              ret
  1508                                      .level5:
  1509 00000D79 B801000000                      mov rax, level5_blocks_count
  1510 00000D7E C3                              ret
  1511                                  
  1512                                  
  1513                                  print_blocks:
  1514 00000D7F 55                          push rbp
  1515 00000D80 4889E5                      mov rbp, rsp
  1516                                      
  1517                                      ; Obtener puntero a los bloques del nivel actual
  1518 00000D83 E84FFFFFFF                  call get_current_level_blocks
  1519 00000D88 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1520                                      
  1521                                      ; Obtener cantidad de bloques del nivel actual
  1522 00000D8B E8A0FFFFFF                  call get_current_level_count
  1523 00000D90 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1524                                      
  1525 00000D93 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1526                                      
  1527                                      .print_loop:
  1528 00000D96 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1529 00000D99 7D6F                            jge .end
  1530                                          
  1531                                          ; Verificar si el bloque está activo
  1532 00000D9B 490FB68424-                     movzx rax, byte [block_states + r12]
  1532 00000DA0 [D9140000]         
  1533 00000DA4 4885C0                          test rax, rax
  1534 00000DA7 745C                            jz .next_block
  1535                                          
  1536                                          ; Obtener posición y tipo del bloque usando r13
  1537 00000DA9 4C89E0                          mov rax, r12
  1538 00000DAC 486BC005                        imul rax, 5
  1539 00000DB0 4C01E8                          add rax, r13
  1540 00000DB3 448A00                          mov r8b, [rax]        ; X position
  1541 00000DB6 448A4801                        mov r9b, [rax + 1]    ; Y position
  1542 00000DBA 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1543                                  
  1544                                          ; El resto de la lógica de impresión permanece igual
  1545 00000DBE 4D0FB6C0                        movzx r8, r8b
  1546 00000DC2 4D0FB6C9                        movzx r9, r9b
  1547 00000DC6 4981C0[000A0000]                add r8, board
  1548 00000DCD B850000000                      mov rax, column_cells + 2
  1549 00000DD2 49F7E1                          mul r9
  1550 00000DD5 4901C0                          add r8, rax
  1551                                          
  1552 00000DD8 B906000000                      mov rcx, block_length
  1553 00000DDD 48BE-                           mov rsi, block_type_1
  1553 00000DDF [9014000000000000] 
  1554 00000DE7 490FB6C2                        movzx rax, r10b
  1555 00000DEB 48FFC8                          dec rax
  1556 00000DEE 486BC006                        imul rax, block_length
  1557 00000DF2 4801C6                          add rsi, rax
  1558                                          
  1559                                      .print_block_chars:
  1560 00000DF5 8A06                            mov al, [rsi]
  1561 00000DF7 418800                          mov [r8], al
  1562 00000DFA 48FFC6                          inc rsi
  1563 00000DFD 49FFC0                          inc r8
  1564 00000E00 48FFC9                          dec rcx
  1565 00000E03 75F0                            jnz .print_block_chars
  1566                                          
  1567                                      .next_block:
  1568 00000E05 49FFC4                          inc r12
  1569 00000E08 EB8C                            jmp .print_loop
  1570                                          
  1571                                      .end:
  1572 00000E0A 5D                              pop rbp
  1573 00000E0B C3                              ret
  1574                                  
  1575                                  ; Función para convertir número a string
  1576                                  ; Input: RAX = número a convertir
  1577                                  ; RDI = buffer donde escribir el string
  1578                                  number_to_string:
  1579 00000E0C 53                          push rbx
  1580 00000E0D 52                          push rdx
  1581 00000E0E 56                          push rsi
  1582 00000E0F BB0A000000                  mov rbx, 10          ; Divisor
  1583 00000E14 B900000000                  mov rcx, 0          ; Contador de dígitos
  1584                                      
  1585                                      ; Si el número es 0, manejarlo especialmente
  1586 00000E19 4885C0                      test rax, rax
  1587 00000E1C 7509                        jnz .convert_loop
  1588 00000E1E C60730                      mov byte [rdi], '0'
  1589 00000E21 C6470100                    mov byte [rdi + 1], 0
  1590 00000E25 EB20                        jmp .end
  1591                                      
  1592                                      .convert_loop:
  1593 00000E27 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1594 00000E2A 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1595 00000E2D 80C230                          add dl, '0'     ; Convertir a ASCII
  1596 00000E30 52                              push rdx        ; Guardar el dígito
  1597 00000E31 48FFC1                          inc rcx         ; Incrementar contador
  1598 00000E34 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1599 00000E37 75EE                            jnz .convert_loop
  1600                                          
  1601                                      .write_loop:
  1602 00000E39 5A                              pop rdx         ; Obtener dígito
  1603 00000E3A 8817                            mov [rdi], dl   ; Escribir al buffer
  1604 00000E3C 48FFC7                          inc rdi         ; Siguiente posición
  1605 00000E3F 48FFC9                          dec rcx         ; Decrementar contador
  1606 00000E42 75F5                            jnz .write_loop
  1607                                          
  1608 00000E44 C60700                      mov byte [rdi], 0   ; Null terminator
  1609                                      
  1610                                      .end:
  1611 00000E47 5E                          pop rsi
  1612 00000E48 5A                          pop rdx
  1613 00000E49 5B                          pop rbx
  1614 00000E4A C3                          ret
  1615                                  
  1616                                  ; Función para imprimir los labels
  1617                                  print_labels:
  1618 00000E4B 55                          push rbp
  1619 00000E4C 4889E5                      mov rbp, rsp
  1620                                  
  1621                                      ; Crear buffer temporal
  1622 00000E4F 4883EC20                    sub rsp, 32
  1623                                  
  1624                                      ; Copiar labels a buffer temporal
  1625 00000E53 4889E7                      mov rdi, rsp
  1626 00000E56 488D35(F2150000)            lea rsi, [score_label]
  1627 00000E5D B917000000                  mov rcx, score_label_len
  1628 00000E62 F3A4                        rep movsb
  1629                                  
  1630                                      ; Convertir score a string
  1631 00000E64 488B05(3D150000)            mov rax, [current_score]
  1632 00000E6B 48BF-                       mov rdi, number_buffer
  1632 00000E6D [4615000000000000] 
  1633 00000E75 E892FFFFFF                  call number_to_string
  1634                                  
  1635                                      ; Calcular longitud del número
  1636 00000E7A B900000000                  mov rcx, 0
  1637 00000E7F 48BF-                       mov rdi, number_buffer
  1637 00000E81 [4615000000000000] 
  1638                                      .count_loop:
  1639 00000E89 803C0F00                        cmp byte [rdi + rcx], 0
  1640 00000E8D 7405                            je .count_done
  1641 00000E8F 48FFC1                          inc rcx
  1642 00000E92 EBF5                            jmp .count_loop
  1643                                      .count_done:
  1644                                  
  1645                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1646 00000E94 4889E7                      mov rdi, rsp
  1647 00000E97 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1648 00000E9B BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1649 00000EA0 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1650                                      .pad_loop:
  1651 00000EA3 4885F6                          test rsi, rsi
  1652 00000EA6 740B                            jz .pad_done
  1653 00000EA8 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1654 00000EAB 48FFC7                          inc rdi
  1655 00000EAE 48FFCE                          dec rsi
  1656 00000EB1 EBF0                            jmp .pad_loop
  1657                                      .pad_done:
  1658                                  
  1659                                      ; Copiar el número
  1660 00000EB3 48BE-                       mov rsi, number_buffer
  1660 00000EB5 [4615000000000000] 
  1661 00000EBD F3A4                        rep movsb
  1662                                  
  1663                                      ; Imprimir el buffer completo
  1664                                      print rsp, score_label_len
    82 00000EBF B801000000          <1>  mov eax, sys_write
    83 00000EC4 BF01000000          <1>  mov edi, 1
    84 00000EC9 4889E6              <1>  mov rsi, %1
    85 00000ECC BA17000000          <1>  mov edx, %2
    86 00000ED1 0F05                <1>  syscall
  1665                                  
  1666                                      ; Repetir proceso para bloques destruidos
  1667 00000ED3 4889E7                      mov rdi, rsp
  1668 00000ED6 488D35(09160000)            lea rsi, [blocks_label]
  1669 00000EDD B91B000000                  mov rcx, blocks_label_len
  1670 00000EE2 F3A4                        rep movsb
  1671                                  
  1672                                      ; Verificar que el `[` esté en su posición correcta
  1673 00000EE4 4889E7                      mov rdi, rsp
  1674 00000EE7 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1675 00000EEB C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1676                                  
  1677                                      ; Convertir bloques destruidos a string
  1678 00000EEE 480FB605(45150000)          movzx rax, byte [destroyed_blocks]
  1679 00000EF6 48BF-                       mov rdi, number_buffer
  1679 00000EF8 [4615000000000000] 
  1680 00000F00 E807FFFFFF                  call number_to_string
  1681                                  
  1682                                      ; Calcular longitud del número
  1683 00000F05 B900000000                  mov rcx, 0
  1684 00000F0A 48BF-                       mov rdi, number_buffer
  1684 00000F0C [4615000000000000] 
  1685                                      .count_loop2:
  1686 00000F14 803C0F00                        cmp byte [rdi + rcx], 0
  1687 00000F18 7405                            je .count_done2
  1688 00000F1A 48FFC1                          inc rcx
  1689 00000F1D EBF5                            jmp .count_loop2
  1690                                      .count_done2:
  1691                                  
  1692                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1693 00000F1F 4889E7                      mov rdi, rsp
  1694 00000F22 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1695 00000F26 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1696 00000F2B 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1697                                      .pad_loop2:
  1698 00000F2E 4885F6                          test rsi, rsi
  1699 00000F31 740B                            jz .pad_done2
  1700 00000F33 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1701 00000F36 48FFC7                          inc rdi
  1702 00000F39 48FFCE                          dec rsi
  1703 00000F3C EBF0                            jmp .pad_loop2
  1704                                      .pad_done2:
  1705                                  
  1706                                      ; Copiar el número
  1707 00000F3E 48BE-                       mov rsi, number_buffer
  1707 00000F40 [4615000000000000] 
  1708 00000F48 F3A4                        rep movsb
  1709                                  
  1710                                      ; Imprimir el buffer completo
  1711                                      print rsp, blocks_label_len
    82 00000F4A B801000000          <1>  mov eax, sys_write
    83 00000F4F BF01000000          <1>  mov edi, 1
    84 00000F54 4889E6              <1>  mov rsi, %1
    85 00000F57 BA1B000000          <1>  mov edx, %2
    86 00000F5C 0F05                <1>  syscall
  1712                                  
  1713                                      ; Restaurar stack
  1714 00000F5E 4883C420                    add rsp, 32
  1715 00000F62 5D                          pop rbp
  1716 00000F63 C3                          ret
  1717                                  
  1718                                  
  1719                                  
  1720                                  check_block_collision:
  1721 00000F64 55                          push rbp
  1722 00000F65 4889E5                      mov rbp, rsp
  1723                                  
  1724                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1725 00000F68 418A02                      mov al, [r10]
  1726                                  
  1727                                      ; Verificar si el carácter es un bloque
  1728 00000F6B 3C55                        cmp al, 'U'  
  1729 00000F6D 7419                        je .possible
  1730 00000F6F 3C4F                        cmp al, 'O'  
  1731 00000F71 7415                        je .possible
  1732 00000F73 3C44                        cmp al, 'D'  
  1733 00000F75 7411                        je .possible
  1734 00000F77 3C4C                        cmp al, 'L'  
  1735 00000F79 740D                        je .possible
  1736 00000F7B 3C56                        cmp al, 'V'  
  1737 00000F7D 7409                        je .possible
  1738 00000F7F 3C38                        cmp al, '8'  
  1739 00000F81 7405                        je .possible
  1740                                  
  1741                                      ; No es bloque, salir
  1742 00000F83 4831C0                      xor rax, rax
  1743 00000F86 5D                          pop rbp
  1744 00000F87 C3                          ret
  1745                                  
  1746                                  .possible:
  1747 00000F88 53                          push rbx
  1748 00000F89 57                          push rdi
  1749 00000F8A 56                          push rsi
  1750 00000F8B 4154                        push r12
  1751 00000F8D 4155                        push r13
  1752 00000F8F 4156                        push r14
  1753 00000F91 4157                        push r15
  1754                                  
  1755                                      ; 1) Obtener base de los bloques del nivel actual
  1756 00000F93 E83FFDFFFF                  call get_current_level_blocks
  1757 00000F98 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1758                                  
  1759                                      ; 2) Obtener la cantidad de bloques
  1760 00000F9B E890FDFFFF                  call get_current_level_count
  1761 00000FA0 4989C6                      mov r14, rax
  1762                                  
  1763 00000FA3 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1764                                  
  1765                                  .find_block_loop:
  1766 00000FA6 4D39F4                      cmp r12, r14
  1767 00000FA9 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1768                                  
  1769                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1770 00000FAF 4C89E0                      mov rax, r12
  1771 00000FB2 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1772 00000FB6 4C01E8                      add rax, r13
  1773 00000FB9 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1774                                  
  1775                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1776 00000FBC 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1776 00000FC1 [D9140000]         
  1777 00000FC5 4885DB                      test rbx, rbx
  1778 00000FC8 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1779                                  
  1780                                      ; Obtener coordenadas
  1781 00000FCE 418A17                      mov dl, [r15]         ; x
  1782 00000FD1 418A4F01                    mov cl, [r15 + 1]     ; y
  1783                                  
  1784                                      ; Calcular posición en el board
  1785 00000FD5 488D3D(000A0000)            lea rdi, [board]
  1786 00000FDC 4831C0                      xor rax, rax
  1787 00000FDF B84E000000                  mov rax, column_cells
  1788 00000FE4 4883C002                    add rax, 2
  1789 00000FE8 480FB6C9                    movzx rcx, cl         ; y
  1790 00000FEC 480FAFC1                    imul rax, rcx
  1791 00000FF0 4801C7                      add rdi, rax
  1792 00000FF3 480FB6C2                    movzx rax, dl         ; x
  1793 00000FF7 4801C7                      add rdi, rax
  1794                                  
  1795                                      ; Guardar la posición base del bloque
  1796 00000FFA 57                          push rdi
  1797                                  
  1798                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1799 00000FFB 4939FA                      cmp r10, rdi
  1800 00000FFE 7274                        jb .skip_collision
  1801 00001000 488D5F06                    lea rbx, [rdi + block_length]
  1802 00001004 4939DA                      cmp r10, rbx
  1803 00001007 736B                        jae .skip_collision
  1804                                  
  1805                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1806 00001009 41FE8C24[D9140000]          dec byte [block_states + r12]
  1807                                      ; Volver a cargar durabilidad
  1808 00001011 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1808 00001016 [D9140000]         
  1809 0000101A 4885DB                      test rbx, rbx
  1810 0000101D 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1811                                  
  1812                                      ; >>> Llegó a 0 => Bloque destruido
  1813 0000101F 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1814 00001020 B906000000                  mov rcx, block_length
  1815                                  .clear_loop:
  1816 00001025 C60720                      mov byte [rdi], ' '
  1817 00001028 48FFC7                      inc rdi
  1818 0000102B E2F8                        loop .clear_loop
  1819                                  
  1820                                      ; Dibujar letra del bloque destruido
  1821 0000102D 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1822 00001031 4883EF06                    sub rdi, block_length
  1823 00001035 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1824                                      ; Después de escribir la letra en el tablero
  1825 00001037 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1826 0000103B 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1827 0000103F 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1828 00001044 E85DF3FFFF                  call register_letter
  1829                                      ; Actualizar contadores globales
  1830 00001049 FE0D(B5140000)              dec byte [blocks_remaining]
  1831 0000104F FE05(45150000)              inc byte [destroyed_blocks]
  1832                                  
  1833                                      ; Sumar puntos según el tipo
  1834 00001055 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1835 0000105A 486BC00A                    imul rax, 10
  1836 0000105E 480105(3D150000)            add [current_score], rax
  1837                                  
  1838 00001065 B801000000                  mov rax, 1  ; colisión con destrucción
  1839 0000106A EB14                        jmp .end_pop
  1840                                  
  1841                                  .update_display:
  1842                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1843 0000106C B801000000                  mov rax, 1  ; colisión con "rebote"  
  1844 00001071 5F                          pop rdi     ; pop que quedó pendiente
  1845 00001072 EB0C                        jmp .end_pop
  1846                                  
  1847                                  .skip_collision:
  1848 00001074 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1849                                  .next_block:
  1850 00001075 49FFC4                      inc r12
  1851 00001078 E929FFFFFF                  jmp .find_block_loop
  1852                                  
  1853                                  .no_block_found:
  1854 0000107D 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1855                                  
  1856                                  .end_pop:
  1857 00001080 415F                        pop r15
  1858 00001082 415E                        pop r14
  1859 00001084 415D                        pop r13
  1860 00001086 415C                        pop r12
  1861 00001088 5E                          pop rsi
  1862 00001089 5F                          pop rdi
  1863 0000108A 5B                          pop rbx
  1864 0000108B 5D                          pop rbp
  1865 0000108C C3                          ret
  1866                                  
  1867                                  
  1868                                  
  1869                                  init_enemies:
  1870 0000108D 55                          push rbp
  1871 0000108E 4889E5                      mov rbp, rsp
  1872                                      ; Reiniciar contadores de movimiento
  1873 00001091 C605(88150000)00            mov byte [enemy_move_total], 0
  1874 00001098 C605(89150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1875                                      ; Limpiar estado previo de enemigos
  1876 0000109F B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1877 000010A4 488D3D(5F150000)            lea rdi, [enemies]
  1878 000010AB 30C0                        xor al, al
  1879 000010AD F3AA                        rep stosb ; Limpiar datos de enemigos
  1880                                      
  1881                                      ; Marcar todos los enemigos como inactivos
  1882 000010AF 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1883 000010B6 30C0                        xor al, al
  1884 000010B8 B90A000000                  mov rcx, 10
  1885 000010BD F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1886                                  
  1887 000010BF 5D                          pop rbp
  1888 000010C0 C3                          ret
  1889                                  
  1890                                  
  1891                                  ; Función para mover enemigos
  1892                                  move_enemies:
  1893 000010C1 55                          push rbp
  1894 000010C2 4889E5                      mov rbp, rsp
  1895                                      
  1896                                      ; Incrementar contador de movimiento
  1897 000010C5 FE05(86150000)              inc byte [enemy_move_counter]
  1898 000010CB 480FB605(86150000)          movzx rax, byte [enemy_move_counter]
  1899 000010D3 3A05(87150000)              cmp al, [enemy_move_delay]
  1900 000010D9 0F85AA010000                jne .end
  1901                                      
  1902                                      ; Resetear contador
  1903 000010DF C605(86150000)00            mov byte [enemy_move_counter], 0
  1904                                      
  1905 000010E6 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1906                                      
  1907                                      .enemy_loop:
  1908 000010E9 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1909 000010ED 0F8D96010000                    jge .end
  1910                                          
  1911                                          ; Calcular offset del enemigo actual
  1912 000010F3 4C89E0                          mov rax, r12
  1913 000010F6 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1914 000010FA 488DB0[5F150000]                lea rsi, [enemies + rax]
  1915                                          
  1916                                          ; Verificar si el enemigo está activo
  1917 00001101 807E0201                        cmp byte [rsi + 2], 1
  1918 00001105 0F8576010000                    jne .next_enemy
  1919                                          
  1920                                          ; Obtener posición actual
  1921 0000110B 4C0FB606                        movzx r8, byte [rsi]            ; X
  1922 0000110F 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1923                                          
  1924                                          ; Limpiar posición actual antes de mover
  1925 00001114 4150                            push r8
  1926 00001116 4151                            push r9
  1927 00001118 B84E000000                      mov rax, column_cells
  1928 0000111D 4883C002                        add rax, 2
  1929 00001121 49F7E1                          mul r9
  1930 00001124 4C01C0                          add rax, r8
  1931 00001127 488DB8[000A0000]                lea rdi, [board + rax]
  1932 0000112E C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1933 00001131 4159                            pop r9
  1934 00001133 4158                            pop r8
  1935                                  
  1936                                          ; Determinar comportamiento basado en índice
  1937 00001135 4C89E0                          mov rax, r12
  1938 00001138 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1939 0000113C 4885C0                          test rax, rax
  1940 0000113F 7402                            jz .chase_ball
  1941 00001141 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1942                                          
  1943                                          ; Perseguir bola (comportamiento original)
  1944                                      .chase_ball:
  1945 00001143 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1946 0000114A 4D39D0                          cmp r8, r10
  1947 0000114D 0F8F96000000                    jg .move_left
  1948 00001153 0F8C95000000                    jl .move_right
  1949                                          
  1950 00001159 4C8B15(67140000)                mov r10, [ball_y_pos]
  1951 00001160 4D39D1                          cmp r9, r10
  1952 00001163 0F8F8A000000                    jg .move_up
  1953 00001169 0F8C89000000                    jl .move_down
  1954 0000116F E9A5000000                      jmp .check_collision
  1955                                          
  1956                                      .chase_paddle:
  1957                                          ; Obtener la posición X actual de la paleta
  1958 00001174 4C8B15(3F140000)                mov r10, [pallet_position]
  1959 0000117B 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  1960                                          
  1961                                          ; Calcular la posición X real de la paleta
  1962 00001182 4C89D0                          mov rax, r10
  1963 00001185 BB4E000000                      mov rbx, column_cells
  1964 0000118A 4883C302                        add rbx, 2                  ; Añadir newline chars
  1965 0000118E 4831D2                          xor rdx, rdx
  1966 00001191 48F7F3                          div rbx                     ; rax = y, rdx = x
  1967                                          
  1968                                          ; rdx ahora contiene la posición X de la paleta
  1969                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  1970 00001194 488B0D(47140000)                mov rcx, [pallet_size]
  1971 0000119B 48D1E9                          shr rcx, 1                  ; Dividir por 2
  1972 0000119E 4801CA                          add rdx, rcx
  1973                                          
  1974                                          ; Comparar con posición X del enemigo y mover gradualmente
  1975 000011A1 4939D0                          cmp r8, rdx
  1976 000011A4 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  1977 000011A6 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  1978 000011A8 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  1979                                  
  1980                                      .check_y_paddle:
  1981                                          ; La Y de la paleta siempre es row_cells - 2
  1982 000011AA 41BA20000000                    mov r10, row_cells
  1983 000011B0 4983EA02                        sub r10, 2
  1984                                          
  1985                                          ; Comparar con posición Y del enemigo y mover gradualmente
  1986 000011B4 4D39D1                          cmp r9, r10
  1987 000011B7 7404                            je .no_movement            ; Si está en la misma Y, no mover
  1988 000011B9 7F38                            jg .move_up               ; Si está abajo, mover arriba
  1989 000011BB 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  1990                                          
  1991                                      .no_movement:
  1992 000011BD EB5A                            jmp .check_collision
  1993                                  
  1994                                      ; También agregar una nueva sección para el movimiento suave
  1995                                      .smooth_transition:
  1996                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  1997 000011BF 8A05(89150000)                  mov al, [enemy_target]
  1998 000011C5 84C0                            test al, al
  1999 000011C7 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2000                                          
  2001                                          ; Verificar distancia en X
  2002 000011C9 4989D2                          mov r10, rdx              ; Posición X objetivo
  2003 000011CC 4D29C2                          sub r10, r8               ; Calcular diferencia
  2004 000011CF 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2005 000011D3 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2006 000011D5 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2007 000011D9 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2008 000011DB EB3C                            jmp .check_collision
  2009                                          
  2010                                      .limit_right_movement:
  2011 000011DD 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2012 000011E1 EB36                            jmp .check_collision
  2013                                          
  2014                                      .limit_left_movement:
  2015 000011E3 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2016 000011E7 EB30                            jmp .check_collision
  2017                                      .move_left:
  2018 000011E9 49FFC8                          dec r8
  2019 000011EC EB0F                            jmp .check_vertical
  2020                                          
  2021                                      .move_right:
  2022 000011EE 49FFC0                          inc r8
  2023 000011F1 EB0A                            jmp .check_vertical
  2024                                          
  2025                                      .move_up:
  2026 000011F3 49FFC9                          dec r9
  2027 000011F6 EB21                            jmp .check_collision
  2028                                          
  2029                                      .move_down:
  2030 000011F8 49FFC1                          inc r9
  2031 000011FB EB1C                            jmp .check_collision
  2032                                          
  2033                                      .check_vertical:
  2034 000011FD 8A05(89150000)                  mov al, [enemy_target]
  2035 00001203 84C0                            test al, al
  2036 00001205 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2037 0000120B 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2038 00001212 4D39D1                          cmp r9, r10
  2039 00001215 7FDC                            jg .move_up
  2040 00001217 7CDF                            jl .move_down
  2041                                          
  2042                                      .check_collision:
  2043                                          ; Verificar colisión con bordes
  2044 00001219 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2045 0000121D 7E62                            jle .next_enemy
  2046 0000121F 4983F84E                        cmp r8, column_cells
  2047 00001223 7D5C                            jge .next_enemy
  2048 00001225 4983F901                        cmp r9, 1                       ; Borde superior
  2049 00001229 7E56                            jle .next_enemy
  2050 0000122B 4983F920                        cmp r9, row_cells
  2051 0000122F 7D50                            jge .next_enemy
  2052                                          
  2053                                          ; Verificar colisión con bloques antes de moverse
  2054 00001231 4150                            push r8
  2055 00001233 4151                            push r9
  2056 00001235 4152                            push r10
  2057                                          
  2058                                          ; Calcular posición en el tablero para verificar
  2059 00001237 B84E000000                      mov rax, column_cells
  2060 0000123C 4883C002                        add rax, 2
  2061 00001240 49F7E1                          mul r9
  2062 00001243 4C01C0                          add rax, r8
  2063 00001246 4C8D90[000A0000]                lea r10, [board + rax]
  2064                                          
  2065                                          ; Verificar si hay un bloque en la nueva posición
  2066 0000124D 418A02                          mov al, [r10]
  2067 00001250 3C55                            cmp al, 'U'
  2068 00001252 7427                            je .invalid_move
  2069 00001254 3C4F                            cmp al, 'O'
  2070 00001256 7423                            je .invalid_move
  2071 00001258 3C44                            cmp al, 'D'
  2072 0000125A 741F                            je .invalid_move
  2073 0000125C 3C4C                            cmp al, 'L'
  2074 0000125E 741B                            je .invalid_move
  2075 00001260 3C56                            cmp al, 'V'
  2076 00001262 7417                            je .invalid_move
  2077 00001264 3C38                            cmp al, '8'
  2078 00001266 7413                            je .invalid_move
  2079 00001268 3C58                            cmp al, 'X'
  2080 0000126A 740F                            je .invalid_move
  2081                                          
  2082 0000126C 415A                            pop r10
  2083 0000126E 4159                            pop r9
  2084 00001270 4158                            pop r8
  2085                                          
  2086                                          ; Guardar nueva posición si es válida
  2087 00001272 448806                          mov [rsi], r8b
  2088 00001275 44884E01                        mov [rsi + 1], r9b
  2089 00001279 EB06                            jmp .next_enemy
  2090                                          
  2091                                      .invalid_move:
  2092 0000127B 415A                            pop r10
  2093 0000127D 4159                            pop r9
  2094 0000127F 4158                            pop r8
  2095                                          
  2096                                      .next_enemy:
  2097 00001281 49FFC4                          inc r12
  2098 00001284 E960FEFFFF                      jmp .enemy_loop
  2099                                          
  2100                                      .end:
  2101 00001289 5D                              pop rbp
  2102 0000128A C3                              ret
  2103                                  
  2104                                  get_current_spawn_points:
  2105 0000128B 55                          push rbp
  2106 0000128C 4889E5                      mov rbp, rsp
  2107                                      
  2108 0000128F 480FB605(B4140000)          movzx rax, byte [current_level]
  2109 00001297 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2110 0000129A 488B04C5[BD150000]          mov rax, [spawn_points_table + rax * 8]
  2111                                      
  2112 000012A2 5D                          pop rbp
  2113 000012A3 C3                          ret
  2114                                  
  2115                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2116                                  check_enemy_spawn:
  2117 000012A4 55                          push rbp
  2118 000012A5 4889E5                      mov rbp, rsp
  2119                                      
  2120                                      ; Obtener spawn points del nivel actual
  2121 000012A8 E8DEFFFFFF                  call get_current_spawn_points
  2122 000012AD 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2123                                      
  2124                                      ; Obtener cantidad de bloques destruidos
  2125 000012B0 4C0FB62D(45150000)          movzx r13, byte [destroyed_blocks]
  2126                                      
  2127                                      ; Verificar cada punto de spawn
  2128 000012B8 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2129                                      
  2130                                      .check_loop:
  2131 000012BB 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2132 000012BF 7D4B                            jge .end
  2133                                          
  2134                                          ; Verificar si este spawn point ya fue usado
  2135 000012C1 80B9[E8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2136 000012C8 743D                            je .next_enemy
  2137                                          
  2138                                          ; Verificar si este enemigo ya está activo
  2139 000012CA 4889C8                          mov rax, rcx
  2140 000012CD 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2141 000012D1 488DB0[5F150000]                lea rsi, [enemies + rax]
  2142 000012D8 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2143 000012DC 7429                            je .next_enemy
  2144                                          
  2145                                          ; Verificar si debemos spawnear este enemigo
  2146 000012DE 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2147 000012E3 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2148 000012E6 751F                            jne .next_enemy
  2149                                          
  2150                                          ; Marcar este spawn point como usado
  2151 000012E8 C681[E8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2152                                          
  2153                                          ; Spawner nuevo enemigo
  2154 000012EF C60628                          mov byte [rsi], 40             ; X inicial
  2155 000012F2 C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2156 000012F6 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2157                                          
  2158                                          ; Inicializar comportamiento
  2159 000012FA 4889C8                          mov rax, rcx
  2160 000012FD 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2161 00001301 8805(E7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2162                                          
  2163                                      .next_enemy:
  2164 00001307 48FFC1                          inc rcx
  2165 0000130A EBAF                            jmp .check_loop
  2166                                          
  2167                                      .end:
  2168 0000130C 5D                              pop rbp
  2169 0000130D C3                              ret
  2170                                  
  2171                                  
  2172                                  ; Función para dibujar enemigos
  2173                                  print_enemies:
  2174 0000130E 55                          push rbp
  2175 0000130F 4889E5                      mov rbp, rsp
  2176                                      
  2177 00001312 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2178                                      
  2179                                      .print_loop:
  2180 00001315 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2181 00001319 7D4B                            jge .end
  2182                                          
  2183                                          ; Calcular offset del enemigo actual
  2184 0000131B 4C89E0                          mov rax, r12
  2185 0000131E 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2186 00001322 488DB0[5F150000]                lea rsi, [enemies + rax]
  2187                                          
  2188                                          ; Verificar si el enemigo está activo
  2189 00001329 807E0201                        cmp byte [rsi + 2], 1
  2190 0000132D 7532                            jne .next_enemy
  2191                                          
  2192                                          ; Calcular posición en el tablero
  2193 0000132F 4C0FB606                        movzx r8, byte [rsi]            ; X
  2194 00001333 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2195                                          
  2196                                          ; Calcular offset en el tablero
  2197 00001338 B84E000000                      mov rax, column_cells
  2198 0000133D 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2199 00001341 49F7E1                          mul r9
  2200 00001344 4C01C0                          add rax, r8
  2201 00001347 488DB8[000A0000]                lea rdi, [board + rax]
  2202                                          
  2203                                          ; Obtener carácter del enemigo según el nivel
  2204 0000134E 480FB605(B4140000)              movzx rax, byte [current_level]
  2205 00001356 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2206 00001359 8A80[5A150000]                  mov al, [enemy_chars + rax]
  2207                                          
  2208                                          ; Dibujar enemigo
  2209 0000135F 8807                            mov [rdi], al
  2210                                          
  2211                                      .next_enemy:
  2212 00001361 49FFC4                          inc r12
  2213 00001364 EBAF                            jmp .print_loop
  2214                                          
  2215                                      .end:
  2216 00001366 5D                              pop rbp
  2217 00001367 C3                              ret
  2218                                  
  2219                                  ; Función para verificar colisión con enemigos
  2220                                  ; Función para verificar colisión con enemigos
  2221                                  check_enemy_collision:
  2222 00001368 55                          push rbp
  2223 00001369 4889E5                      mov rbp, rsp
  2224                                      
  2225 0000136C 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2226 0000136F 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2227                                      
  2228                                      .check_loop:
  2229 00001372 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2230 00001376 0F8DE9000000                    jge .end
  2231                                          
  2232                                          ; Calcular offset del enemigo actual
  2233 0000137C 4C89E1                          mov rcx, r12
  2234 0000137F 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2235 00001383 488DB1[5F150000]                lea rsi, [enemies + rcx]
  2236                                          
  2237                                          ; Verificar si el enemigo está activo
  2238 0000138A 807E0201                        cmp byte [rsi + 2], 1
  2239 0000138E 0F85C9000000                    jne .next_enemy
  2240                                          
  2241                                          ; Verificar colisión con la bola
  2242 00001394 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2243 00001398 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2244                                          
  2245                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2246 0000139D 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2247 000013A4 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2248                                          
  2249                                          ; Comprobar colisión vertical (misma columna)
  2250 000013AB 4D39C2                          cmp r10, r8
  2251 000013AE 7525                            jne .check_horizontal
  2252 000013B0 4D29CB                          sub r11, r9
  2253 000013B3 4983FB01                        cmp r11, 1
  2254 000013B7 7F1C                            jg .check_horizontal
  2255 000013B9 4983FBFF                        cmp r11, -1
  2256 000013BD 7C16                            jl .check_horizontal
  2257                                          
  2258                                          ; Colisión vertical detectada
  2259 000013BF E8A3000000                      call destroy_enemy
  2260 000013C4 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2261 000013CB B801000000                      mov rax, 1
  2262 000013D0 E990000000                      jmp .end
  2263                                          
  2264                                      .check_horizontal:
  2265                                          ; Comprobar colisión horizontal (misma fila)
  2266 000013D5 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2267 000013DC 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2268 000013E3 4D39CB                          cmp r11, r9
  2269 000013E6 7522                            jne .check_paddle
  2270 000013E8 4D29C2                          sub r10, r8
  2271 000013EB 4983FA01                        cmp r10, 1
  2272 000013EF 7F19                            jg .check_paddle
  2273 000013F1 4983FAFF                        cmp r10, -1
  2274 000013F5 7C13                            jl .check_paddle
  2275                                          
  2276                                          ; Colisión horizontal detectada
  2277 000013F7 E86B000000                      call destroy_enemy
  2278 000013FC 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2279 00001403 B801000000                      mov rax, 1
  2280 00001408 EB5B                            jmp .end
  2281                                          
  2282                                      .check_paddle:
  2283                                          ; Verificar colisión con la paleta
  2284 0000140A 4C8B15(3F140000)                mov r10, [pallet_position]
  2285 00001411 4981EA[000A0000]                sub r10, board
  2286 00001418 4C89D0                          mov rax, r10
  2287 0000141B 41BB4E000000                    mov r11, column_cells
  2288 00001421 4983C302                        add r11, 2
  2289 00001425 4831D2                          xor rdx, rdx
  2290 00001428 49F7F3                          div r11                     ; División para obtener la posición Y
  2291 0000142B 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2292                                          
  2293 0000142E 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2294                                          
  2295                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2296 00001435 41BD20000000                    mov r13, row_cells
  2297 0000143B 4983ED02                        sub r13, 2                 ; Y de la paleta
  2298 0000143F 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2299 00001442 7519                            jne .next_enemy
  2300                                          
  2301                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2302 00001444 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2303 00001447 7C14                            jl .next_enemy
  2304                                          
  2305 00001449 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2306 0000144C 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2307 0000144F 7F0C                            jg .next_enemy
  2308                                          
  2309                                          ; Si llegamos aquí, hay colisión con la paleta
  2310 00001451 E811000000                      call destroy_enemy        ; Destruir el enemigo
  2311 00001456 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2312 0000145B EB08                            jmp .end
  2313                                          
  2314                                      .next_enemy:
  2315 0000145D 49FFC4                          inc r12
  2316 00001460 E90DFFFFFF                      jmp .check_loop
  2317                                          
  2318                                      .end:
  2319 00001465 5D                              pop rbp
  2320 00001466 C3                              ret
  2321                                  
  2322                                  ; Función para destruir un enemigo
  2323                                  destroy_enemy:
  2324                                      ; Desactivar enemigo
  2325 00001467 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2326                                  
  2327                                      ; Sumar puntos por destruir enemigo
  2328 0000146B 488B05(7E150000)            mov rax, [enemy_points]
  2329 00001472 480105(3D150000)            add [current_score], rax
  2330                                  
  2331                                      ; No tocar bloques destruidos aquí
  2332 00001479 C3                          ret
  2333                                  
  2334                                  
  2335                                  _start:
  2336 0000147A E8ACECFFFF              	call canonical_off
  2337 0000147F E804010000              	call start_screen
  2338 00001484 E8B9F5FFFF                  call init_level
  2339 00001489 E8FFFBFFFF                  call init_enemies
  2340 0000148E EB00                    	jmp .main_loop
  2341                                  	
  2342                                  
  2343                                  	.main_loop:
  2344 00001490 E8B6F9FFFF                      call print_labels
  2345 00001495 E8E5F8FFFF                      call print_blocks
  2346 0000149A E8D8EFFFFF                      call move_letters
  2347 0000149F E848EFFFFF                      call print_letters
  2348 000014A4 E8F5F1FFFF              		call print_pallet
  2349 000014A9 E8CDF2FFFF                      call move_ball
  2350 000014AE E82BEEFFFF                      call check_bottom_collision
  2351 000014B3 E825EDFFFF                      call print_lives
  2352 000014B8 E824F7FFFF                      call check_level_complete
  2353 000014BD E8E2FDFFFF                      call check_enemy_spawn
  2354 000014C2 E8FAFBFFFF                      call move_enemies
  2355 000014C7 E89CFEFFFF                      call check_enemy_collision
  2356 000014CC E83DFEFFFF                      call print_enemies
  2357 000014D1 E8A0F1FFFF              		call print_ball
  2358                                  		print board, board_size				
    82 000014D6 B801000000          <1>  mov eax, sys_write
    83 000014DB BF01000000          <1>  mov edi, 1
    84 000014E0 48BE-               <1>  mov rsi, %1
    84 000014E2 [000A000000000000]  <1>
    85 000014EA BA000A0000          <1>  mov edx, %2
    86 000014EF 0F05                <1>  syscall
  2359                                  		;setnonblocking	
  2360                                  	.read_more:	
  2361                                  	    getchar	
    90 000014F1 B800000000          <1>  mov rax, sys_read
    91 000014F6 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000014FB 48BE-               <1>  mov rsi, input_char
    92 000014FD [0000000000000000]  <1>
    93 00001505 BA01000000          <1>  mov rdx, 1
    94 0000150A 0F05                <1>  syscall
  2362 0000150C 4883F801                	    cmp rax, 1
  2363 00001510 7543                    	    jne .done
  2364                                  	
  2365 00001512 8A05(00000000)          	    mov al, [input_char]
  2366 00001518 8805(04180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2367                                  	
  2368 0000151E 3C61                    	    cmp al, 'a'
  2369 00001520 750E                    	    jne .not_left
  2370 00001522 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2371 00001529 E8A5F1FFFF              	    call move_pallet
  2372 0000152E EB25                    	    jmp .done
  2373                                  	
  2374                                      .not_left:
  2375 00001530 3C64                    	    cmp al, 'd'
  2376 00001532 750C                    	    jne .not_right
  2377 00001534 BF01000000              	    mov rdi, right_direction
  2378 00001539 E895F1FFFF              	    call move_pallet
  2379 0000153E EB15                    	    jmp .done
  2380                                  	
  2381                                      .not_right:
  2382 00001540 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2383 00001542 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2384                                  	
  2385 00001544 3C71                    	    cmp al, 'q' 
  2386 00001546 0F84AF000000            	    je exit
  2387 0000154C EBA3                    	    jmp .read_more
  2388                                  	
  2389                                      .release_ball:
  2390 0000154E E8FBF3FFFF              	    call process_catch_release
  2391 00001553 EB00                    	    jmp .done
  2392                                  	
  2393                                      .done:
  2394                                  	    sleeptime
    98 00001555 B823000000          <1>  mov eax, sys_nanosleep
    99 0000155A 48BF-               <1>  mov rdi, timespec
    99 0000155C [0000000000000000]  <1>
   100 00001564 31F6                <1>  xor esi, esi
   101 00001566 0F05                <1>  syscall
  2395                                  	    print clear, clear_length
    82 00001568 B801000000          <1>  mov eax, sys_write
    83 0000156D BF01000000          <1>  mov edi, 1
    84 00001572 48BE-               <1>  mov rsi, %1
    84 00001574 [1000000000000000]  <1>
    85 0000157C BA07000000          <1>  mov edx, %2
    86 00001581 0F05                <1>  syscall
  2396 00001583 E908FFFFFF              	    jmp .main_loop
  2397                                  
  2398                                  
  2399                                  
  2400                                  
  2401                                  start_screen:
  2402                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001588 B801000000          <1>  mov eax, sys_write
    83 0000158D BF01000000          <1>  mov edi, 1
    84 00001592 48BE-               <1>  mov rsi, %1
    84 00001594 [1000000000000000]  <1>
    85 0000159C BA07000000          <1>  mov edx, %2
    86 000015A1 0F05                <1>  syscall
  2403                                      print msg1, msg1_length
    82 000015A3 B801000000          <1>  mov eax, sys_write
    83 000015A8 BF01000000          <1>  mov edi, 1
    84 000015AD 48BE-               <1>  mov rsi, %1
    84 000015AF [1700000000000000]  <1>
    85 000015B7 BA14010000          <1>  mov edx, %2
    86 000015BC 0F05                <1>  syscall
  2404                                      
  2405                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2406                                          getchar                 ; Esperamos una tecla
    90 000015BE B800000000          <1>  mov rax, sys_read
    91 000015C3 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000015C8 48BE-               <1>  mov rsi, input_char
    92 000015CA [0000000000000000]  <1>
    93 000015D2 BA01000000          <1>  mov rdx, 1
    94 000015D7 0F05                <1>  syscall
  2407 000015D9 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2408 000015DD 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2409                                          
  2410                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000015DF B801000000          <1>  mov eax, sys_write
    83 000015E4 BF01000000          <1>  mov edi, 1
    84 000015E9 48BE-               <1>  mov rsi, %1
    84 000015EB [1000000000000000]  <1>
    85 000015F3 BA07000000          <1>  mov edx, %2
    86 000015F8 0F05                <1>  syscall
  2411 000015FA C3                          ret
  2412                                  
  2413                                  exit: 
  2414 000015FB E86DEBFFFF              	call canonical_on
  2415 00001600 B83C000000              	mov    rax, 60
  2416 00001605 BF00000000                  mov    rdi, 0
  2417 0000160A 0F05                        syscall
  2418                                  
