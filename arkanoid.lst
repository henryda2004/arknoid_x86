     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 80 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	board:
   115                                  		full_line
    70 00000000 58<rep 50h>         <1>  times column_cells db "X"
    71 00000050 0A0D                <1>  db 0x0a, 0xD
   116                                          %rep 30
   117                                          hollow_line
   118                                          %endrep
   117                              <1>  hollow_line
    75 00000052 58                  <2>  db "X"
    76 00000053 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000A1 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000000A4 58                  <2>  db "X"
    76 000000A5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000000F3 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000000F6 58                  <2>  db "X"
    76 000000F7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000145 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000148 58                  <2>  db "X"
    76 00000149 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000197 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000019A 58                  <2>  db "X"
    76 0000019B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000001E9 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000001EC 58                  <2>  db "X"
    76 000001ED 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000023B 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000023E 58                  <2>  db "X"
    76 0000023F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000028D 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000290 58                  <2>  db "X"
    76 00000291 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000002DF 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000002E2 58                  <2>  db "X"
    76 000002E3 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000331 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000334 58                  <2>  db "X"
    76 00000335 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000383 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000386 58                  <2>  db "X"
    76 00000387 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000003D5 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000003D8 58                  <2>  db "X"
    76 000003D9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000427 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000042A 58                  <2>  db "X"
    76 0000042B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000479 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000047C 58                  <2>  db "X"
    76 0000047D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000004CB 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000004CE 58                  <2>  db "X"
    76 000004CF 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000051D 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000520 58                  <2>  db "X"
    76 00000521 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000056F 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000572 58                  <2>  db "X"
    76 00000573 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000005C1 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000005C4 58                  <2>  db "X"
    76 000005C5 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000613 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000616 58                  <2>  db "X"
    76 00000617 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000665 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000668 58                  <2>  db "X"
    76 00000669 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000006B7 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000006BA 58                  <2>  db "X"
    76 000006BB 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000709 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000070C 58                  <2>  db "X"
    76 0000070D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 0000075B 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000075E 58                  <2>  db "X"
    76 0000075F 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007AD 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000007B0 58                  <2>  db "X"
    76 000007B1 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000007FF 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000802 58                  <2>  db "X"
    76 00000803 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000851 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 00000854 58                  <2>  db "X"
    76 00000855 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008A3 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000008A6 58                  <2>  db "X"
    76 000008A7 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000008F5 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 000008F8 58                  <2>  db "X"
    76 000008F9 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000947 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000094A 58                  <2>  db "X"
    76 0000094B 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 00000999 580A0D              <2>  db "X", 0x0a, 0xD
   117                              <1>  hollow_line
    75 0000099C 58                  <2>  db "X"
    76 0000099D 20<rep 4Eh>         <2>  times column_cells-2 db " "
    77 000009EB 580A0D              <2>  db "X", 0x0a, 0xD
   119                                          full_line
    70 000009EE 58<rep 50h>         <1>  times column_cells db "X"
    71 00000A3E 0A0D                <1>  db 0x0a, 0xD
   120                                  	board_size:   equ   $ - board
   121                                  
   122                                  	; Added for the terminal issue
   123 00000A40 00<rep 24h>             	termios:        times 36 db 0
   124                                  	stdin:          equ 0
   125                                  	ICANON:         equ 1<<1
   126                                  	ECHO:           equ 1<<3
   127                                  	VTIME: 			equ 5
   128                                  	VMIN:			equ 6
   129                                  	CC_C:			equ 18
   130                                  
   131                                  section .text
   132                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   133                                  canonical_off:
   134 0000012B E86F000000                      call read_stdin_termios
   135                                  
   136                                          ; clear canonical bit in local mode flags
   137 00000130 50                              push rax
   138 00000131 B802000000                      mov eax, ICANON
   139 00000136 F7D0                            not eax
   140 00000138 2105(4C0A0000)                  and [termios+12], eax
   141 0000013E C605(570A0000)00        		mov byte[termios+CC_C+VTIME], 0
   142 00000145 C605(580A0000)00        		mov byte[termios+CC_C+VMIN], 0
   143 0000014C 58                              pop rax
   144                                  
   145 0000014D E86C000000                      call write_stdin_termios
   146 00000152 C3                              ret
   147                                  
   148                                  echo_off:
   149 00000153 E847000000                      call read_stdin_termios
   150                                  
   151                                          ; clear echo bit in local mode flags
   152 00000158 50                              push rax
   153 00000159 B808000000                      mov eax, ECHO
   154 0000015E F7D0                            not eax
   155 00000160 2105(4C0A0000)                  and [termios+12], eax
   156 00000166 58                              pop rax
   157                                  
   158 00000167 E852000000                      call write_stdin_termios
   159 0000016C C3                              ret
   160                                  
   161                                  canonical_on:
   162 0000016D E82D000000                      call read_stdin_termios
   163                                  
   164                                          ; set canonical bit in local mode flags
   165 00000172 830D(4C0A0000)02                or dword [termios+12], ICANON
   166 00000179 C605(570A0000)00        		mov byte[termios+CC_C+VTIME], 0
   167 00000180 C605(580A0000)01        		mov byte[termios+CC_C+VMIN], 1
   168 00000187 E832000000                      call write_stdin_termios
   169 0000018C C3                              ret
   170                                  
   171                                  echo_on:
   172 0000018D E80D000000                      call read_stdin_termios
   173                                  
   174                                          ; set echo bit in local mode flags
   175 00000192 830D(4C0A0000)08                or dword [termios+12], ECHO
   176                                  
   177 00000199 E820000000                      call write_stdin_termios
   178 0000019E C3                              ret
   179                                  
   180                                  read_stdin_termios:
   181 0000019F 50                              push rax
   182 000001A0 53                              push rbx
   183 000001A1 51                              push rcx
   184 000001A2 52                              push rdx
   185                                  
   186 000001A3 B836000000                      mov eax, 36h
   187 000001A8 BB00000000                      mov ebx, stdin
   188 000001AD B901540000                      mov ecx, 5401h
   189 000001B2 BA[400A0000]                    mov edx, termios
   190 000001B7 CD80                            int 80h
   191                                  
   192 000001B9 5A                              pop rdx
   193 000001BA 59                              pop rcx
   194 000001BB 5B                              pop rbx
   195 000001BC 58                              pop rax
   196 000001BD C3                              ret
   197                                  
   198                                  write_stdin_termios:
   199 000001BE 50                              push rax
   200 000001BF 53                              push rbx
   201 000001C0 51                              push rcx
   202 000001C1 52                              push rdx
   203                                  
   204 000001C2 B836000000                      mov eax, 36h
   205 000001C7 BB00000000                      mov ebx, stdin
   206 000001CC B902540000                      mov ecx, 5402h
   207 000001D1 BA[400A0000]                    mov edx, termios
   208 000001D6 CD80                            int 80h
   209                                  
   210 000001D8 5A                              pop rdx
   211 000001D9 59                              pop rcx
   212 000001DA 5B                              pop rbx
   213 000001DB 58                              pop rax
   214 000001DC C3                              ret
   215                                  
   216                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   217                                  
   218                                  char_equal: equ 61
   219                                  char_space: equ 32
   220                                  char_O: equ 79
   221                                  left_direction: equ -1
   222                                  right_direction: equ 1
   223                                  
   224                                  
   225                                  section .data
   226 00000A64 [7209000000000000]      	pallet_position dq board + 40 + 29 * (column_cells +2)
   227 00000A6C 0300000000000000        	pallet_size dq 3
   228                                  
   229 00000A74 2800000000000000        	ball_x_pos: dq 40
   230 00000A7C 1C00000000000000        	ball_y_pos: dq 28
   231 00000A84 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   232 00000A8C FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   233 00000A94 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   234                                  
   235                                  ; Definir los límites de la pantalla o área de juego
   236                                      board_top_left_x equ 1
   237                                      board_top_left_y equ 1
   238                                      board_bottom_right_x equ column_cells - 1
   239                                      board_bottom_right_y equ row_cells
   240                                  
   241                                      ; Limites laterales
   242                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   243                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   244                                  
   245                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   246 00000A95 [5200000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   247 00000A9D [A000000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   248                                  
   249                                      ; Definición de tipos de bloques
   250 00000AA5 55555555                    block_type_1: db "UUUU"    ; Durabilidad 1
   251 00000AA9 4F4F4F4F                    block_type_2: db "OOOO"    ; Durabilidad 2
   252 00000AAD 44444444                    block_type_3: db "DDDD"    ; Durabilidad 3
   253 00000AB1 4C4C4C4C                    block_type_4: db "LLLL"    ; Durabilidad 4
   254 00000AB5 56565656                    block_type_5: db "VVVV"    ; Durabilidad 5
   255 00000AB9 38383838                    block_type_6: db "8888"    ; Durabilidad 6
   256                                      block_length: equ 4        ; Longitud de cada bloque
   257                                  
   258                                      ; Estructura para el nivel actual
   259 00000ABD 01                          current_level db 1
   260 00000ABE 00                          blocks_remaining db 0
   261                                  
   262                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)
   263                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   264                                      level1_blocks:
   265                                          ; Primera fila (tipo 1)
   266 00000ABF 3C030101                        db 60, 3, 1, 1    ; Bloque 1
   267 00000AC3 41030101                        db 65, 3, 1, 1    ; Bloque 2
   268 00000AC7 46030101                        db 70, 3, 1, 1    ; Bloque 3
   269                                          
   270                                          ; Segunda fila (tipo 2)
   271 00000ACB 3C050201                        db 60, 5, 2, 1    ; Bloque 4
   272 00000ACF 41050201                        db 65, 5, 2, 1    ; Bloque 5
   273 00000AD3 46050201                        db 70, 5, 2, 1    ; Bloque 6
   274                                          
   275                                          ; Tercera fila (tipo 3)
   276 00000AD7 3C070302                        db 60, 7, 3, 2    ; Bloque 7
   277 00000ADB 41070302                        db 65, 7, 3, 2    ; Bloque 8
   278 00000ADF 46070302                        db 70, 7, 3, 2    ; Bloque 9
   279                                      level1_blocks_count equ 9   ; Cantidad total de bloques
   280                                  
   281                                      ; Array para mantener el estado de los bloques
   282 00000AE3 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   283                                  
   284                                  section .text
   285                                  
   286                                  ;	Function: print_ball
   287                                  ; This function displays the position of the ball
   288                                  ; Arguments: none
   289                                  ;
   290                                  ; Return:
   291                                  ;	Void
   292                                  print_ball:
   293 000001DD 4C8B05(740A0000)        	mov r8, [ball_x_pos]
   294 000001E4 4C8B0D(7C0A0000)        	mov r9, [ball_y_pos]
   295 000001EB 4981C0[00000000]        	add r8, board
   296                                  
   297 000001F2 4C89C9                  	mov rcx, r9
   298 000001F5 B852000000              	mov rax, column_cells + 2
   299 000001FA 48F7E9                  	imul rcx
   300                                  	
   301 000001FD 4901C0                  	add r8, rax
   302 00000200 41C6004F                	mov byte [r8], char_O
   303 00000204 C3                      	ret
   304                                  
   305                                  	
   306                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   307                                  	
   308                                  
   309                                  
   310                                  
   311                                  ;	Function: print_pallet
   312                                  ; This function moves the pallet in the game
   313                                  ; Arguments: none
   314                                  ;
   315                                  ; Return;
   316                                  ;	void
   317                                  print_pallet:
   318 00000205 4C8B05(640A0000)        	mov r8, [pallet_position]
   319 0000020C 488B0D(6C0A0000)        	mov rcx, [pallet_size]
   320                                  	.write_pallet:
   321 00000213 41C6003D                		mov byte [r8], char_equal
   322 00000217 49FFC0                  		inc r8
   323 0000021A 48FFC9                  		dec rcx
   324 0000021D 75F4                    		jnz .write_pallet
   325                                  
   326 0000021F C3                      	ret
   327                                  	
   328                                  ;	Function: move_pallet
   329                                  ; This function is in charge of moving the pallet in a given direction
   330                                  ; Arguments:
   331                                  ;	rdi: left direction or right direction
   332                                  ;
   333                                  ; Return:
   334                                  ;	void
   335                                  move_pallet:
   336                                      
   337 00000220 803D(940A0000)00            cmp byte [ball_moving], 0
   338 00000227 7507                        jne .continue_movement
   339 00000229 C605(940A0000)01            mov byte [ball_moving], 1
   340                                  
   341                                      .continue_movement:
   342 00000230 4883FFFF                        cmp rdi, left_direction
   343 00000234 7531                            jne .move_right
   344                                  
   345                                          .move_left:
   346                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
   347 00000236 4C8B05(640A0000)                    mov r8, [pallet_position]
   348 0000023D 49FFC8                              dec r8              ; Verificar la posición a la izquierda
   349 00000240 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   350 00000243 3C58                                cmp al, 'X'        ; Comparar si es una X
   351 00000245 744D                                je .end            ; Si es X, no mover
   352                                              
   353 00000247 4C8B05(640A0000)                    mov r8, [pallet_position]
   354 0000024E 4C8B0D(6C0A0000)                    mov r9, [pallet_size]
   355 00000255 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
   356 0000025B 49FFC8                              dec r8
   357 0000025E 4C8905(640A0000)                    mov [pallet_position], r8
   358 00000265 EB2D                                jmp .end
   359                                              
   360                                          .move_right:
   361                                              ; Verificar si la siguiente posición después de la paleta sería una X
   362 00000267 4C8B05(640A0000)                    mov r8, [pallet_position]
   363 0000026E 4C8B0D(6C0A0000)                    mov r9, [pallet_size]
   364 00000275 4D01C8                              add r8, r9         ; Moverse al final de la paleta
   365 00000278 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
   366 0000027B 3C58                                cmp al, 'X'        ; Comparar si es una X
   367 0000027D 7415                                je .end            ; Si es X, no mover
   368                                              
   369 0000027F 4C8B05(640A0000)                    mov r8, [pallet_position]
   370 00000286 41C60020                            mov byte [r8], char_space
   371 0000028A 49FFC0                              inc r8
   372 0000028D 4C8905(640A0000)                    mov [pallet_position], r8
   373                                          .end:
   374 00000294 C3                                  ret
   375                                  
   376                                  move_ball:
   377                                      ; Si la bola no está en movimiento, no hacer nada
   378 00000295 803D(940A0000)00            cmp byte [ball_moving], 0
   379 0000029C 0F8406010000                je .end
   380                                  
   381                                      ; Borrar la posición actual de la bola
   382 000002A2 4C8B05(740A0000)            mov r8, [ball_x_pos]
   383 000002A9 4C8B0D(7C0A0000)            mov r9, [ball_y_pos]
   384 000002B0 4981C0[00000000]            add r8, board
   385 000002B7 4C89C9                      mov rcx, r9
   386 000002BA B852000000                  mov rax, column_cells + 2
   387 000002BF 48F7E9                      imul rcx
   388 000002C2 4901C0                      add r8, rax
   389 000002C5 41C60020                    mov byte [r8], char_space    ; Borrar la bola actual
   390                                  
   391                                      ; Calcular siguiente posición X
   392 000002C9 4C8B05(740A0000)            mov r8, [ball_x_pos]
   393 000002D0 4C8B0D(7C0A0000)            mov r9, [ball_y_pos]
   394 000002D7 488B05(840A0000)            mov rax, [ball_direction_x]
   395 000002DE 4901C0                      add r8, rax                  ; Nueva posición X
   396                                  
   397                                      ; Calcular la dirección de memoria para la siguiente posición
   398 000002E1 4D89C2                      mov r10, r8
   399 000002E4 4981C2[00000000]            add r10, board
   400 000002EB 4C89C9                      mov rcx, r9
   401 000002EE B852000000                  mov rax, column_cells + 2
   402 000002F3 48F7E9                      imul rcx
   403 000002F6 4901C2                      add r10, rax
   404                                  
   405                                      ; Verificar si hay una X en la siguiente posición X
   406 000002F9 418A02                      mov al, [r10]
   407 000002FC 3C58                        cmp al, 'X'
   408 000002FE 750C                        jne .check_block_x
   409 00000300 48F71D(840A0000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
   410 00000307 E99C000000                  jmp .end
   411                                  
   412                                      .check_block_x:
   413                                          ; Verificar colisión con bloques en X
   414 0000030C 4150                            push r8     ; Guardar registros que usa check_block_collision
   415 0000030E 4151                            push r9
   416 00000310 4152                            push r10
   417 00000312 E82A010000                      call check_block_collision
   418 00000317 415A                            pop r10
   419 00000319 4159                            pop r9
   420 0000031B 4158                            pop r8
   421 0000031D 4885C0                          test rax, rax
   422 00000320 7409                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
   423 00000322 48F71D(840A0000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
   424 00000329 EB7D                            jmp .end
   425                                  
   426                                      .check_paddle_x:
   427                                          ; Verificar si hay una paleta (=) en la siguiente posición X
   428 0000032B 41803A3D                        cmp byte [r10], char_equal
   429 0000032F 7509                            jne .check_y_movement
   430 00000331 48F71D(840A0000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
   431 00000338 EB6E                            jmp .end
   432                                  
   433                                      .check_y_movement:
   434                                          ; Calcular siguiente posición Y
   435 0000033A 488B05(8C0A0000)                mov rax, [ball_direction_y]
   436 00000341 4901C1                          add r9, rax                  ; Nueva posición Y
   437                                  
   438                                          ; Calcular la dirección de memoria para la siguiente posición Y
   439 00000344 4D89C2                          mov r10, r8
   440 00000347 4981C2[00000000]                add r10, board
   441 0000034E 4C89C9                          mov rcx, r9
   442 00000351 B852000000                      mov rax, column_cells + 2
   443 00000356 48F7E9                          imul rcx
   444 00000359 4901C2                          add r10, rax
   445                                  
   446                                          ; Verificar si hay una X en la siguiente posición Y
   447 0000035C 418A02                          mov al, [r10]
   448 0000035F 3C58                            cmp al, 'X'
   449 00000361 7509                            jne .check_block_y
   450 00000363 48F71D(8C0A0000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
   451 0000036A EB3C                            jmp .end
   452                                  
   453                                      .check_block_y:
   454                                          ; Verificar colisión con bloques en Y
   455 0000036C 4150                            push r8     ; Guardar registros que usa check_block_collision
   456 0000036E 4151                            push r9
   457 00000370 4152                            push r10
   458 00000372 E8CA000000                      call check_block_collision
   459 00000377 415A                            pop r10
   460 00000379 4159                            pop r9
   461 0000037B 4158                            pop r8
   462 0000037D 4885C0                          test rax, rax
   463 00000380 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
   464 00000382 48F71D(8C0A0000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
   465 00000389 EB1D                            jmp .end
   466                                  
   467                                      .check_paddle_y:
   468                                      ; Verificar si hay una paleta (=) en la siguiente posición Y
   469 0000038B 41803A3D                    cmp byte [r10], char_equal
   470 0000038F 7509                        jne .update_position
   471 00000391 48F71D(8C0A0000)            neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
   472 00000398 EB0E                        jmp .end
   473                                  
   474                                  
   475                                      .update_position:
   476 0000039A 4C8905(740A0000)                mov [ball_x_pos], r8
   477 000003A1 4C890D(7C0A0000)                mov [ball_y_pos], r9
   478                                  
   479                                      .end:
   480 000003A8 C3                              ret
   481                                  
   482                                  ; Función para inicializar el nivel
   483                                  init_level:
   484                                      ; Establecer la cantidad de bloques restantes
   485 000003A9 B009                        mov al, level1_blocks_count
   486 000003AB 8805(BE0A0000)              mov [blocks_remaining], al
   487                                      
   488                                      ; Inicializar estados de los bloques
   489 000003B1 B909000000                  mov rcx, level1_blocks_count
   490 000003B6 48BF-                       mov rdi, block_states
   490 000003B8 [E30A000000000000] 
   491 000003C0 B001                        mov al, 1
   492 000003C2 F3AA                        rep stosb                   ; Establecer todos los bloques como activos
   493 000003C4 C3                          ret
   494                                  
   495                                  ; Función para imprimir los bloques
   496                                  ; Función modificada para imprimir bloques
   497                                  print_blocks:
   498 000003C5 4D31E4                      xor r12, r12               ; Índice del bloque actual
   499                                      
   500                                      .print_loop:
   501 000003C8 4983FC09                        cmp r12, level1_blocks_count
   502 000003CC 7D72                            jge .end
   503                                          
   504                                          ; Verificar si el bloque está activo
   505 000003CE 490FB68424-                     movzx rax, byte [block_states + r12]
   505 000003D3 [E30A0000]         
   506 000003D7 4885C0                          test rax, rax
   507 000003DA 745F                            jz .next_block             ; Si durabilidad es 0, bloque destruido
   508                                          
   509                                          ; Obtener posición y tipo del bloque
   510 000003DC 468A04A5[BF0A0000]              mov r8b, [level1_blocks + r12 * 4]     ; X position
   511 000003E4 468A0CA5[C00A0000]              mov r9b, [level1_blocks + r12 * 4 + 1] ; Y position
   512 000003EC 468A14A5[C10A0000]              mov r10b, [level1_blocks + r12 * 4 + 2]; Tipo de bloque
   513                                          
   514                                          ; Calcular posición en el tablero
   515 000003F4 4D0FB6C0                        movzx r8, r8b
   516 000003F8 4D0FB6C9                        movzx r9, r9b
   517 000003FC 4981C0[00000000]                add r8, board
   518 00000403 B852000000                      mov rax, column_cells + 2
   519 00000408 49F7E1                          mul r9
   520 0000040B 4901C0                          add r8, rax
   521                                          
   522                                          ; Imprimir el bloque según su tipo
   523 0000040E B904000000                      mov rcx, block_length      ; Longitud del bloque (4 caracteres)
   524 00000413 48BE-                           mov rsi, block_type_1      ; Dirección base de los tipos de bloques
   524 00000415 [A50A000000000000] 
   525 0000041D 490FB6C2                        movzx rax, r10b
   526 00000421 48FFC8                          dec rax                    ; Ajustar índice (tipos empiezan en 1)
   527 00000424 486BC004                        imul rax, block_length     ; Calcular offset al tipo correcto
   528 00000428 4801C6                          add rsi, rax               ; rsi apunta al tipo de bloque correcto
   529                                          
   530                                      .print_block_chars:
   531 0000042B 8A06                            mov al, [rsi]             ; Obtener carácter del bloque
   532 0000042D 418800                          mov [r8], al              ; Colocarlo en el tablero
   533 00000430 48FFC6                          inc rsi
   534 00000433 49FFC0                          inc r8
   535 00000436 48FFC9                          dec rcx
   536 00000439 75F0                            jnz .print_block_chars
   537                                          
   538                                      .next_block:
   539 0000043B 49FFC4                          inc r12
   540 0000043E EB88                            jmp .print_loop
   541                                          
   542                                      .end:
   543 00000440 C3                              ret
   544                                  
   545                                  ; Función modificada para detectar colisión
   546                                  ; Función mejorada para detectar colisión y manejar la física
   547                                  ; Función corregida para manejar colisiones con bloques completos
   548                                  ;---------------------------------------------------------
   549                                  ; check_block_collision:
   550                                  ;   Detecta si en la posición r10 (que apunta a board[])
   551                                  ;   hay un bloque ("UUUU","OOOO","DDDD","LLLL","VVVV","8888").
   552                                  ;   De ser así, localiza qué bloque es, lo "destruye" y
   553                                  ;   retorna 1 para indicar colisión. Si no encuentra bloque,
   554                                  ;   retorna 0.
   555                                  ;---------------------------------------------------------
   556                                  check_block_collision:
   557 00000441 55                          push rbp
   558 00000442 4889E5                      mov rbp, rsp
   559                                  
   560                                      ;--------------------------------------
   561                                      ; 1. Leer el carácter en r10
   562                                      ;--------------------------------------
   563 00000445 418A02                      mov al, [r10]
   564                                  
   565                                      ;--------------------------------------
   566                                      ; 2. Comprobar si es uno de U,O,D,L,V,8
   567                                      ;   (cualquiera de los caracteres de los
   568                                      ;   bloques que dibujas)
   569                                      ;--------------------------------------
   570 00000448 3C55                        cmp al, 'U'
   571 0000044A 7419                        je .possible
   572 0000044C 3C4F                        cmp al, 'O'
   573 0000044E 7415                        je .possible
   574 00000450 3C44                        cmp al, 'D'
   575 00000452 7411                        je .possible
   576 00000454 3C4C                        cmp al, 'L'
   577 00000456 740D                        je .possible
   578 00000458 3C56                        cmp al, 'V'
   579 0000045A 7409                        je .possible
   580 0000045C 3C38                        cmp al, '8'
   581 0000045E 7405                        je .possible
   582                                  
   583                                      ;--------------------------------------
   584                                      ; No es un bloque
   585                                      ;--------------------------------------
   586 00000460 4831C0                      xor rax, rax
   587 00000463 5D                          pop rbp
   588 00000464 C3                          ret
   589                                  
   590                                      .possible:
   591                                          ;--------------------------------------
   592                                          ; 3. Si es un carácter de bloque, hay
   593                                          ;    que buscar cuál de los 9 (o n)
   594                                          ;    es, para borrarlo.
   595                                          ;--------------------------------------
   596 00000465 53                              push rbx
   597 00000466 57                              push rdi
   598 00000467 56                              push rsi
   599 00000468 4154                            push r12
   600                                  
   601 0000046A 4D31E4                          xor r12, r12          ; r12 = índice en level1_blocks
   602                                      .find_block_loop:
   603 0000046D 4983FC09                        cmp r12, level1_blocks_count
   604 00000471 0F8D82000000                    jge .not_found_block   ; no hallamos un bloque que coincida
   605                                  
   606                                          ;--------------------------------------
   607                                          ; Ver si block_states[r12] está activo
   608                                          ; (es 1). Si es 0, está destruido
   609                                          ;--------------------------------------
   610 00000477 418A9C24[E30A0000]              mov bl, [block_states + r12]
   611 0000047F 84DB                            test bl, bl
   612 00000481 746E                            jz .next_block
   613                                  
   614                                          ;--------------------------------------
   615                                          ; Leer x_pos, y_pos de level1_blocks[r12].
   616                                          ; Cada bloque = 4 bytes: x, y, tipo, durab
   617                                          ;--------------------------------------
   618 00000483 48B8-                           mov rax, level1_blocks
   618 00000485 [BF0A000000000000] 
   619 0000048D 4D6BE404                        imul r12, 4
   620 00000491 4C01E0                          add rax, r12
   621                                          ; rax apunta al primer byte del bloque
   622                                          ; x_pos  -> [rax + 0]
   623                                          ; y_pos  -> [rax + 1]
   624                                          ; tipo   -> [rax + 2]
   625                                          ; durab  -> [rax + 3] (no lo usas,
   626                                          ;                    pues block_states[] ya controla la "vida")
   627 00000494 8A10                            mov dl, [rax]      ; dl = x_pos
   628 00000496 8A4801                          mov cl, [rax+1]    ; cl = y_pos
   629                                  
   630                                          ; Regresar r12 a su valor (deshacer imul).
   631                                          ; O si prefieres, hazlo con un registro
   632                                          ; auxiliar, p.e. no modifiques r12. 
   633                                          ; Pero si tu asm ya funciona así, lo dejamos:
   634 00000499 4D89E4                          mov r12, r12
   635 0000049C 49C1EC02                        shr r12, 2
   636                                  
   637                                          ;--------------------------------------
   638                                          ; Calcular la dirección base del bloque
   639                                          ;   base_dir = board + y_pos*(column_cells+2) + x_pos
   640                                          ;--------------------------------------
   641 000004A0 4831FF                          xor rdi, rdi
   642 000004A3 488D3D(00000000)                lea rdi, [board]    ; rdi = dirección base de board
   643                                  
   644 000004AA B852000000                      mov rax, column_cells+2
   645 000004AF 480FB6C9                        movzx rcx, cl   ; rcx = y_pos
   646 000004B3 480FAFC1                        imul rax, rcx
   647 000004B7 4801C7                          add rdi, rax
   648 000004BA 480FB6C2                        movzx rax, dl   ; rax = x_pos
   649 000004BE 4801C7                          add rdi, rax    ; rdi = base_dir
   650                                  
   651                                          ;--------------------------------------
   652                                          ; Saber si r10 está en [rdi..rdi+3]
   653                                          ;--------------------------------------
   654 000004C1 4939FA                          cmp r10, rdi
   655 000004C4 722B                            jb .next_block
   656 000004C6 488D5F04                        lea rbx, [rdi+4]
   657 000004CA 4939DA                          cmp r10, rbx
   658 000004CD 7322                            jae .next_block
   659                                  
   660                                          ;--------------------------------------
   661                                          ; Si llegamos aquí, r10 está dentro de
   662                                          ; las 4 letras del bloque r12
   663                                          ; => destruirlo
   664                                          ;--------------------------------------
   665                                  
   666                                          ; 1) Poner block_states[r12] = 0
   667 000004CF 41C68424[E30A0000]-             mov byte [block_states + r12], 0
   667 000004D7 00                 
   668                                  
   669                                          ; 2) Borrar los 4 caracteres en board
   670 000004D8 B904000000                      mov rcx, 4
   671                                      .erase_block_chars:
   672 000004DD C60720                          mov byte [rdi], char_space   ; ' '
   673 000004E0 48FFC7                          inc rdi
   674 000004E3 E2F8                            loop .erase_block_chars
   675                                  
   676                                          ; 3) Retornar 1 => colisión detectada
   677 000004E5 B801000000                      mov rax, 1
   678                                  
   679                                          ; Limpieza de stack
   680 000004EA 415C                            pop r12
   681 000004EC 5E                              pop rsi
   682 000004ED 5F                              pop rdi
   683 000004EE 5B                              pop rbx
   684 000004EF 5D                              pop rbp
   685 000004F0 C3                              ret
   686                                  
   687                                      .next_block:
   688 000004F1 49FFC4                          inc r12
   689 000004F4 E974FFFFFF                      jmp .find_block_loop
   690                                  
   691                                      .not_found_block:
   692                                          ; En teoría no debería pasar, si
   693                                          ; se detectó un 'U','O','...' 
   694                                          ; pero por seguridad:
   695 000004F9 4831C0                          xor rax, rax
   696                                  
   697 000004FC 415C                            pop r12
   698 000004FE 5E                              pop rsi
   699 000004FF 5F                              pop rdi
   700 00000500 5B                              pop rbx
   701 00000501 5D                              pop rbp
   702 00000502 C3                              ret
   703                                  
   704                                  
   705                                  _start:
   706 00000503 E823FCFFFF              	call canonical_off
   707 00000508 E8D9000000              	call start_screen
   708 0000050D E897FEFFFF                  call init_level
   709 00000512 EB00                    	jmp .main_loop
   710                                  	
   711                                  
   712                                  	.main_loop:
   713 00000514 E8ECFCFFFF              		call print_pallet
   714 00000519 E877FDFFFF                      call move_ball
   715 0000051E E8A2FEFFFF                      call print_blocks
   716 00000523 E8B5FCFFFF              		call print_ball
   717                                  		print board, board_size				
    82 00000528 B801000000          <1>  mov eax, sys_write
    83 0000052D BF01000000          <1>  mov edi, 1
    84 00000532 48BE-               <1>  mov rsi, %1
    84 00000534 [0000000000000000]  <1>
    85 0000053C BA400A0000          <1>  mov edx, %2
    86 00000541 0F05                <1>  syscall
   718                                  		;setnonblocking	
   719                                  	.read_more:	
   720                                  		getchar	
    90 00000543 B800000000          <1>  mov rax, sys_read
    91 00000548 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 0000054D 48BE-               <1>  mov rsi, input_char
    92 0000054F [0000000000000000]  <1>
    93 00000557 BA01000000          <1>  mov rdx, 1
    94 0000055C 0F05                <1>  syscall
   721                                  		
   722 0000055E 4883F801                		cmp rax, 1
   723 00000562 7532                        	jne .done
   724                                  		
   725 00000564 8A05(00000000)          		mov al,[input_char]
   726                                  
   727 0000056A 3C61                    		cmp al, 'a'
   728 0000056C 750E                    	    jne .not_left
   729 0000056E 48C7C7FFFFFFFF          	    mov rdi, left_direction
   730 00000575 E8A6FCFFFF              		call move_pallet
   731 0000057A EB1A                    	    jmp .done
   732                                  		
   733                                  		.not_left:
   734 0000057C 3C64                    		 	cmp al, 'd'
   735 0000057E 750C                    	    	jne .not_right
   736 00000580 BF01000000              			mov rdi, right_direction
   737 00000585 E896FCFFFF              	    	call move_pallet
   738 0000058A EB0A                        		jmp .done		
   739                                  
   740                                  		.not_right:
   741                                  
   742 0000058C 3C71                        		cmp al, 'q'
   743 0000058E 0F84C5000000                		je exit
   744                                  
   745 00000594 EBAD                    			jmp .read_more
   746                                  		
   747                                  		.done:	
   748                                  			;unsetnonblocking		
   749                                  			sleeptime	
    98 00000596 B823000000          <1>  mov eax, sys_nanosleep
    99 0000059B 48BF-               <1>  mov rdi, timespec
    99 0000059D [0000000000000000]  <1>
   100 000005A5 31F6                <1>  xor esi, esi
   101 000005A7 0F05                <1>  syscall
   750                                  			print clear, clear_length
    82 000005A9 B801000000          <1>  mov eax, sys_write
    83 000005AE BF01000000          <1>  mov edi, 1
    84 000005B3 48BE-               <1>  mov rsi, %1
    84 000005B5 [1000000000000000]  <1>
    85 000005BD BA07000000          <1>  mov edx, %2
    86 000005C2 0F05                <1>  syscall
   751 000005C4 E94BFFFFFF                  		jmp .main_loop
   752                                  
   753                                  		print clear, clear_length
    82 000005C9 B801000000          <1>  mov eax, sys_write
    83 000005CE BF01000000          <1>  mov edi, 1
    84 000005D3 48BE-               <1>  mov rsi, %1
    84 000005D5 [1000000000000000]  <1>
    85 000005DD BA07000000          <1>  mov edx, %2
    86 000005E2 0F05                <1>  syscall
   754                                  		
   755 000005E4 EB73                    		jmp exit
   756                                  
   757                                  
   758                                  start_screen:
   759                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 000005E6 B801000000          <1>  mov eax, sys_write
    83 000005EB BF01000000          <1>  mov edi, 1
    84 000005F0 48BE-               <1>  mov rsi, %1
    84 000005F2 [1000000000000000]  <1>
    85 000005FA BA07000000          <1>  mov edx, %2
    86 000005FF 0F05                <1>  syscall
   760                                      print msg1, msg1_length
    82 00000601 B801000000          <1>  mov eax, sys_write
    83 00000606 BF01000000          <1>  mov edi, 1
    84 0000060B 48BE-               <1>  mov rsi, %1
    84 0000060D [1700000000000000]  <1>
    85 00000615 BA14010000          <1>  mov edx, %2
    86 0000061A 0F05                <1>  syscall
   761                                      
   762                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
   763                                          getchar                 ; Esperamos una tecla
    90 0000061C B800000000          <1>  mov rax, sys_read
    91 00000621 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00000626 48BE-               <1>  mov rsi, input_char
    92 00000628 [0000000000000000]  <1>
    93 00000630 BA01000000          <1>  mov rdx, 1
    94 00000635 0F05                <1>  syscall
   764 00000637 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
   765 0000063B 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
   766                                          
   767                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000063D B801000000          <1>  mov eax, sys_write
    83 00000642 BF01000000          <1>  mov edi, 1
    84 00000647 48BE-               <1>  mov rsi, %1
    84 00000649 [1000000000000000]  <1>
    85 00000651 BA07000000          <1>  mov edx, %2
    86 00000656 0F05                <1>  syscall
   768 00000658 C3                          ret
   769                                  
   770                                  exit: 
   771 00000659 E80FFBFFFF              	call canonical_on
   772 0000065E B83C000000              	mov    rax, 60
   773 00000663 BF00000000                  mov    rdi, 0
   774 00000668 0F05                        syscall
   775                                  
