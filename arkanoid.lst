     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257 00001480 00                          ball_active db 0
   258                                  
   259 00001481 0000000000000000            ball2_x_pos:        dq 0
   260 00001489 0000000000000000            ball2_y_pos:        dq 0
   261 00001491 0000000000000000            ball2_direction_x:  dq 0
   262 00001499 0000000000000000            ball2_direction_y:  dq 0
   263 000014A1 00                          ball2_moving:       db 0    ; 0 = estática, 1 = en movimiento
   264 000014A2 00                          ball2_active:       db 0    ; 0 = inactiva, 1 = activa
   265                                  
   266                                      ; -- Pelota 3 --
   267 000014A3 0000000000000000            ball3_x_pos:        dq 0
   268 000014AB 0000000000000000            ball3_y_pos:        dq 0
   269 000014B3 0000000000000000            ball3_direction_x:  dq 0
   270 000014BB 0000000000000000            ball3_direction_y:  dq 0
   271 000014C3 00                          ball3_moving:       db 0
   272 000014C4 00                          ball3_active:       db 0
   273                                  
   274                                  
   275                                  ; Definir los límites de la pantalla o área de juego
   276                                      board_top_left_x equ 1
   277                                      board_top_left_y equ 1
   278                                      board_bottom_right_x equ column_cells - 1
   279                                      board_bottom_right_y equ row_cells
   280                                  
   281                                      ; Limites laterales
   282                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   283                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   284                                  
   285                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   286 000014C5 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   287 000014CD [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   288                                  
   289                                      ; Definición de tipos de bloques
   290 000014D5 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   291 000014DB 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   292 000014E1 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   293 000014E7 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   294 000014ED 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   295 000014F3 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   296                                      block_length: equ 6        ; Longitud de cada bloque
   297                                  
   298                                      ; Estructura para el nivel actual
   299 000014F9 01                          current_level db 1
   300 000014FA 00                          blocks_remaining db 0
   301                                  
   302                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   303                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   304                                      level1_blocks:
   305                                          ; Tercera fila (tipo 3)
   306 000014FB 3A07030153                      db 58, 7, 3, 1, 'S'    ; Bloque 7
   307 00001500 3D09030144                      db 61, 9, 3, 1, 'D'    ; Bloque 7
   308 00001505 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   309 0000150A 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   310 0000150F 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   311 00001514 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   312 00001519 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   313 0000151E 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   314                                  
   315                                  
   316                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   317                                  
   318                                      ; Nivel 2: Bloques de prueba
   319                                      level2_blocks:
   320 00001523 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   321                                      level2_blocks_count equ 1
   322                                  
   323                                      ; Nivel 3
   324                                      level3_blocks:
   325 00001528 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   326                                  
   327                                      level3_blocks_count equ 1
   328                                  
   329                                      ; Nivel 4
   330                                      level4_blocks:
   331 0000152D 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   332                                      level4_blocks_count equ 1
   333                                  
   334                                      ; Nivel 5
   335                                      level5_blocks:
   336 00001532 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   337                                      level5_blocks_count equ 1
   338                                  
   339                                      ; Array para mantener el estado de los bloques
   340 00001537 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   341                                  
   342                                      
   343                                      ; Variables para almacenar los valores
   344 0000159B 0000000000000000            current_score dq 0          ; Score actual
   345 000015A3 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   346                                      
   347                                      ; Buffer para convertir números a string
   348 000015A4 00<rep 14h>                 number_buffer: times 20 db 0
   349                                  
   350 000015B8 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   351                                      
   352                                      ; Estructura para los enemigos (x, y, activo)
   353 000015BD 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   354 000015DB 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   355                                      
   356 000015DC 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   357 000015E4 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   358 000015E5 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   359 000015E6 00                          enemy_move_total db 0      ; Contador total de movimientos
   360 000015E7 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   361 000015E8 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   362                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   363                                      ; Añade esto en la sección .dataa
   364 000015E9 00000006080A0C0E10-         level1_spawn_points: db 0, 0, 0, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   364 000015F2 12                 
   365 000015F3 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   365 000015FC 13                 
   366 000015FD 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   366 00001606 1B                 
   367 00001607 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   367 00001610 1C                 
   368 00001611 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   368 0000161A 2D                 
   369                                          ; Arreglo de punteros a los spawn points de cada nivel
   370                                      spawn_points_table:
   371 0000161B [E915000000000000]              dq level1_spawn_points
   372 00001623 [F315000000000000]              dq level2_spawn_points
   373 0000162B [FD15000000000000]              dq level3_spawn_points
   374 00001633 [0716000000000000]              dq level4_spawn_points
   375 0000163B [1116000000000000]              dq level5_spawn_points
   376                                  
   377                                      ; Variables para el comportamiento de enemigos
   378 00001643 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   379 00001644 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   380 00001645 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   381 00001646 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   382                                  
   383 00001650 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   383 00001659 5B2020202020202020-
   383 00001662 20205D0A0D         
   384                                      score_label_len: equ $ - score_label
   385 00001667 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   385 00001670 657374727569646F73-
   385 00001679 3A205B2020205D0A0D 
   386                                      blocks_label_len: equ $ - blocks_label
   387                                      
   388                                      ; Posición donde insertar los números en los labels
   389                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   390                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   391                                      
   392                                      ; Definición de las vidas (x, y, estado)
   393                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   394                                      lives_data: 
   395 00001682 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   396 00001685 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   397 00001688 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   398 0000168B 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   399 0000168E 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   400 00001691 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   401 00001694 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   402                                      lives_count equ 7    ; Total de vidas
   403 00001697 5E                          life_char db "^"    
   404 00001698 04                          current_lives db 4   ; Contador de vidas activas actual
   405                                  
   406                                  ; Estructura para almacenar las letras y sus posiciones
   407                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   408 00001699 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   409 00001829 00                          letters_count db 0   
   410 0000182A 20                          last_letter db ' '    ; Variable para almacenar la última letra
   411 0000182B 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   411 00001834 75616C3A205B205D0A-
   411 0000183D 0D                 
   412                                      last_letter_msg_len equ $ - last_letter_msg
   413 0000183E 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   414 0000183F 07                          max_lives db 7              ; Máximo número de vidas permitidas
   415 00001840 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   416 00001848 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   417 00001850 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   418                                  
   419 00001858 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   420 00001859 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   421 0000185A 00                          ball_caught_2 db 0           ; 0 = no atrapada, 1 = atrapada
   422 0000185B 00                          ball_caught_3 db 0           ; 0 = no atrapada, 1 = atrapada
   423                                  
   424 0000185C 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   425 00001864 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   426                                  
   427 00001865 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   428 00001866 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   429 00001867 00                          laser_count: db 0                ; Contador de láseres activos
   430 00001868 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   431 00001930 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   432                                  
   433                                      balls_data:     ; Array para almacenar hasta 3 bolas
   434                                          ; Bola 1 (principal)
   435 00001938 0000000000000000                dq 0        ; x_pos
   436 00001940 0000000000000000                dq 0        ; y_pos
   437 00001948 0100000000000000                dq 1        ; direction_x
   438 00001950 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   439 00001958 01                              db 1        ; active
   440                                          ; Bola 2
   441 00001959 0000000000000000                dq 0        ; x_pos
   442 00001961 0000000000000000                dq 0        ; y_pos
   443 00001969 FFFFFFFFFFFFFFFF                dq -1       ; direction_x
   444 00001971 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   445 00001979 00                              db 0        ; active
   446                                          ; Bola 3
   447 0000197A 0000000000000000                dq 0        ; x_pos
   448 00001982 0000000000000000                dq 0        ; y_pos
   449 0000198A 0000000000000000                dq 0        ; direction_x
   450 00001992 FFFFFFFFFFFFFFFF                dq -1       ; direction_y
   451 0000199A 00                              db 0        ; active
   452                                      
   453 0000199B 01                          balls_count db 1     ; Contador de bolas activas
   454                                      BALL_STRUCT_SIZE equ 33  ; Tamaño de cada estructura de bola (8*4 + 1)
   455                                  
   456                                  
   457                                  section .text
   458                                  
   459                                  
   460                                  print_lives:
   461 000001DD 55                          push rbp
   462 000001DE 4889E5                      mov rbp, rsp
   463                                      
   464 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   465                                      
   466                                      .print_loop:
   467 000001E4 4983FC07                        cmp r12, lives_count
   468 000001E8 7D45                            jge .end
   469                                          
   470                                          ; Calcular offset de la vida actual
   471 000001EA 4C89E0                          mov rax, r12
   472 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   473 000001F1 488DB0[82160000]                lea rsi, [lives_data + rax]
   474                                          
   475                                          ; Calcular posición en el tablero
   476 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   477 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   478                                          
   479                                          ; Calcular offset en el tablero
   480 00000201 B84E000000                      mov rax, column_cells
   481 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   482 0000020A 49F7E1                          mul r9
   483 0000020D 4C01C0                          add rax, r8
   484 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   485                                          
   486                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   487 00000217 807E0201                        cmp byte [rsi + 2], 1
   488 0000021B 7405                            je .draw_active
   489                                          
   490                                          ; Si está inactiva, dibujar espacio
   491 0000021D C60720                          mov byte [rdi], ' '
   492 00000220 EB08                            jmp .next_life
   493                                          
   494                                      .draw_active:
   495                                          ; Si está activa, dibujar el símbolo de vida
   496 00000222 8A05(97160000)                  mov al, [life_char]
   497 00000228 8807                            mov [rdi], al
   498                                          
   499                                      .next_life:
   500 0000022A 49FFC4                          inc r12
   501 0000022D EBB5                            jmp .print_loop
   502                                          
   503                                      .end:
   504 0000022F 5D                              pop rbp
   505 00000230 C3                              ret
   506                                  
   507                                  ; Función para desactivar una vida
   508                                  ; Función modificada para perder una vida
   509                                  ; Modificar lose_life para reiniciar solo la bola principal
   510                                  lose_life:
   511 00000231 55                          push rbp
   512 00000232 4889E5                      mov rbp, rsp
   513                                      
   514                                      ; Verificar si aún quedan vidas
   515 00000235 803D(98160000)00            cmp byte [current_lives], 0
   516 0000023C 0F84AB000000                je .game_lost
   517                                      
   518                                      ; Encontrar la última vida activa
   519 00000242 B907000000                  mov rcx, lives_count
   520 00000247 48FFC9                      dec rcx
   521                                      
   522                                      .find_active_life:
   523 0000024A 4889C8                          mov rax, rcx
   524 0000024D 486BC003                        imul rax, 3
   525 00000251 488DB0[82160000]                lea rsi, [lives_data + rax]
   526 00000258 807E0201                        cmp byte [rsi + 2], 1
   527 0000025C 740A                            je .deactivate_life
   528 0000025E 48FFC9                          dec rcx
   529 00000261 79E7                            jns .find_active_life
   530 00000263 E985000000                      jmp .game_lost
   531                                          
   532                                      .deactivate_life:
   533                                          ; Borrar vida visualmente y en datos
   534 00000268 4C0FB606                        movzx r8, byte [rsi]
   535 0000026C 4C0FB64E01                      movzx r9, byte [rsi + 1]
   536 00000271 B84E000000                      mov rax, column_cells
   537 00000276 4883C002                        add rax, 2
   538 0000027A 49F7E1                          mul r9
   539 0000027D 4C01C0                          add rax, r8
   540 00000280 488DB8[000A0000]                lea rdi, [board + rax]
   541 00000287 C60720                          mov byte [rdi], ' '
   542 0000028A C6460200                        mov byte [rsi + 2], 0
   543 0000028E FE0D(98160000)                  dec byte [current_lives]
   544                                          
   545                                          ; Borrar paleta anterior
   546 00000294 4C8B05(3F140000)                mov r8, [pallet_position]
   547 0000029B 488B0D(47140000)                mov rcx, [pallet_size]
   548                                          .erase_pallet_loop:
   549 000002A2 41C60020                            mov byte [r8], ' '
   550 000002A6 49FFC0                              inc r8
   551 000002A9 48FFC9                              dec rcx
   552 000002AC 75F4                                jnz .erase_pallet_loop
   553                                          
   554                                          ; Reiniciar solo la bola principal
   555 000002AE 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   555 000002B6 000000             
   556 000002B9 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   556 000002C1 000000             
   557 000002C4 C605(7F140000)00                mov byte [ball_moving], 0
   558 000002CB C605(80140000)01                mov byte [ball_active], 1       ; Activar bola principal
   559 000002D2 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   559 000002D9 [36130000]         
   560                                          
   561                                          ; Asegurarse que las otras bolas están desactivadas
   562 000002DD C605(A2140000)00                mov byte [ball2_active], 0
   563 000002E4 C605(C4140000)00                mov byte [ball3_active], 0
   564                                          
   565 000002EB EB07                            jmp .end
   566                                          
   567                                      .game_lost:
   568 000002ED E8C7000000                      call game_lost
   569 000002F2 EB00                            jmp .end
   570                                          
   571                                      .end:
   572 000002F4 5D                              pop rbp
   573 000002F5 C3                              ret
   574                                  ; Función modificada para verificar colisión con el borde inferior
   575                                  check_bottom_collision:
   576 000002F6 55                          push rbp
   577 000002F7 4889E5                      mov rbp, rsp
   578                                      
   579                                      ; Verificar bola principal
   580 000002FA 803D(80140000)01            cmp byte [ball_active], 1
   581 00000301 7542                        jne .check_ball2
   582 00000303 488B05(67140000)            mov rax, [ball_y_pos]
   583 0000030A 4883F81E                    cmp rax, row_cells - 2
   584 0000030E 7535                        jne .check_ball2
   585                                      
   586                                      ; Borrar visualmente la bola principal
   587 00000310 4C8B05(5F140000)            mov r8, [ball_x_pos]
   588 00000317 4C8B0D(67140000)            mov r9, [ball_y_pos]
   589 0000031E 4981C0[000A0000]            add r8, board
   590 00000325 4C89C9                      mov rcx, r9
   591 00000328 B850000000                  mov rax, column_cells + 2
   592 0000032D 48F7E9                      imul rcx
   593 00000330 4901C0                      add r8, rax
   594 00000333 41C60020                    mov byte [r8], char_space    ; Borrar la bola del tablero
   595                                      
   596 00000337 C605(80140000)00            mov byte [ball_active], 0
   597 0000033E C605(7F140000)00            mov byte [ball_moving], 0
   598                                  
   599                                  .check_ball2:
   600 00000345 803D(A2140000)01            cmp byte [ball2_active], 1
   601 0000034C 751B                        jne .check_ball3
   602 0000034E 488B05(89140000)            mov rax, [ball2_y_pos]
   603 00000355 4883F81E                    cmp rax, row_cells - 2
   604 00000359 750E                        jne .check_ball3
   605 0000035B C605(A2140000)00            mov byte [ball2_active], 0
   606 00000362 C605(A1140000)00            mov byte [ball2_moving], 0
   607                                  
   608                                  .check_ball3:
   609 00000369 803D(C4140000)01            cmp byte [ball3_active], 1
   610 00000370 751B                        jne .check_active_balls
   611 00000372 488B05(AB140000)            mov rax, [ball3_y_pos]
   612 00000379 4883F81E                    cmp rax, row_cells - 2
   613 0000037D 750E                        jne .check_active_balls
   614 0000037F C605(C4140000)00            mov byte [ball3_active], 0
   615 00000386 C605(C3140000)00            mov byte [ball3_moving], 0
   616                                  
   617                                  .check_active_balls:
   618                                      ; Verificar si quedan bolas activas
   619 0000038D 4831C9                      xor rcx, rcx
   620 00000390 803D(80140000)01            cmp byte [ball_active], 1
   621 00000397 741E                        je .balls_remain
   622 00000399 803D(A2140000)01            cmp byte [ball2_active], 1
   623 000003A0 7415                        je .balls_remain
   624 000003A2 803D(C4140000)01            cmp byte [ball3_active], 1
   625 000003A9 740C                        je .balls_remain
   626                                      
   627                                      ; Si no quedan bolas activas, perder una vida y reiniciar
   628 000003AB E881FEFFFF                  call lose_life
   629 000003B0 C605(80140000)01            mov byte [ball_active], 1    ; Reactivar bola principal
   630                                      
   631                                  .balls_remain:
   632 000003B7 5D                          pop rbp
   633 000003B8 C3                          ret
   634                                  
   635                                  
   636                                  
   637                                  ; Nueva función para game over
   638                                  game_lost:
   639                                      ; Limpiar la pantalla
   640                                      print clear, clear_length
    82 000003B9 B801000000          <1>  mov eax, sys_write
    83 000003BE BF01000000          <1>  mov edi, 1
    84 000003C3 48BE-               <1>  mov rsi, %1
    84 000003C5 [1000000000000000]  <1>
    85 000003CD BA07000000          <1>  mov edx, %2
    86 000003D2 0F05                <1>  syscall
   641                                      
   642                                      ; Mostrar mensaje de derrota
   643                                      section .data
   644 0000199C C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   644 000019A5 6469646F210A0D     
   645                                          lost_msg_len: equ $ - lost_msg
   646                                      section .text
   647                                      
   648                                      ; Imprimir mensaje de derrota
   649                                      print lost_msg, lost_msg_len
    82 000003D4 B801000000          <1>  mov eax, sys_write
    83 000003D9 BF01000000          <1>  mov edi, 1
    84 000003DE 48BE-               <1>  mov rsi, %1
    84 000003E0 [9C19000000000000]  <1>
    85 000003E8 BA10000000          <1>  mov edx, %2
    86 000003ED 0F05                <1>  syscall
   650                                      print score_msg, score_msg_len
    82 000003EF B801000000          <1>  mov eax, sys_write
    83 000003F4 BF01000000          <1>  mov edi, 1
    84 000003F9 48BE-               <1>  mov rsi, %1
    84 000003FB [CA19000000000000]  <1>
    85 00000403 BA0F000000          <1>  mov edx, %2
    86 00000408 0F05                <1>  syscall
   651                                      
   652                                      ; Mostrar puntaje final
   653 0000040A 488B05(9B150000)            mov rax, [current_score]
   654 00000411 48BF-                       mov rdi, number_buffer
   654 00000413 [A415000000000000] 
   655 0000041B E80E130000                  call number_to_string
   656                                      print number_buffer, 20
    82 00000420 B801000000          <1>  mov eax, sys_write
    83 00000425 BF01000000          <1>  mov edi, 1
    84 0000042A 48BE-               <1>  mov rsi, %1
    84 0000042C [A415000000000000]  <1>
    85 00000434 BA14000000          <1>  mov edx, %2
    86 00000439 0F05                <1>  syscall
   657                                      
   658                                      ; Esperar un momento antes de salir
   659 0000043B 48C705BAFBFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   659 00000444 0000               
   660 00000446 48C705B7FBFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   660 0000044F 0000               
   661                                      sleeptime
    98 00000451 B823000000          <1>  mov eax, sys_nanosleep
    99 00000456 48BF-               <1>  mov rdi, timespec
    99 00000458 [0000000000000000]  <1>
   100 00000460 31F6                <1>  xor esi, esi
   101 00000462 0F05                <1>  syscall
   662                                      
   663 00000464 E9061B0000                  jmp exit
   664                                  
   665                                  
   666                                  ; Función para registrar una nueva letra en el mapa
   667                                  ; Entrada:
   668                                  ;   al - letra a registrar
   669                                  ;   r8b - posición x
   670                                  ;   r9b - posición y
   671                                  register_letter:
   672 00000469 55                          push rbp
   673 0000046A 4889E5                      mov rbp, rsp
   674 0000046D 53                          push rbx
   675 0000046E 51                          push rcx
   676                                      
   677 0000046F 3C20                        cmp al, ' '
   678 00000471 7438                        je .end
   679                                  
   680                                      ; Encontrar un espacio libre en el mapa
   681 00000473 4831C9                      xor rcx, rcx
   682 00000476 480FB615(29180000)          movzx rdx, byte [letters_count]
   683                                      
   684                                      .find_slot:
   685 0000047E 4883F964                        cmp rcx, 100              ; Máximo de letras
   686 00000482 7D27                            jge .end                  ; Si no hay espacio, salir
   687                                          
   688 00000484 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   689 0000048C 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   690 00000490 7405                            je .found_slot
   691                                          
   692 00000492 48FFC1                          inc rcx
   693 00000495 EBE7                            jmp .find_slot
   694                                          
   695                                      .found_slot:
   696                                          ; Guardar la información de la letra
   697 00000497 448803                          mov [rbx], r8b           ; x
   698 0000049A 44884B01                        mov [rbx + 1], r9b       ; y
   699 0000049E 884302                          mov [rbx + 2], al        ; letra
   700 000004A1 C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   701                                          
   702 000004A5 FE05(29180000)                  inc byte [letters_count]
   703                                          
   704                                      .end:
   705 000004AB 59                              pop rcx
   706 000004AC 5B                              pop rbx
   707 000004AD 5D                              pop rbp
   708 000004AE C3                              ret
   709                                  
   710                                  ; Función para imprimir todas las letras registradas
   711                                  print_letters:
   712 000004AF 55                          push rbp
   713 000004B0 4889E5                      mov rbp, rsp
   714 000004B3 53                          push rbx
   715 000004B4 51                          push rcx
   716                                      
   717 000004B5 4831C9                      xor rcx, rcx
   718                                      
   719                                      .print_loop:
   720 000004B8 4883F964                        cmp rcx, 100              ; Máximo de letras
   721 000004BC 7D37                            jge .end
   722                                          
   723                                          ; Obtener puntero a la letra actual
   724 000004BE 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   725                                          
   726                                          ; Verificar si está activa
   727 000004C6 807B0300                        cmp byte [rbx + 3], 0
   728 000004CA 7424                            je .next_letter
   729                                          
   730                                          ; Calcular posición en el tablero
   731 000004CC 4C0FB603                        movzx r8, byte [rbx]      ; x
   732 000004D0 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   733                                          
   734                                          ; Calcular offset en el tablero
   735 000004D5 B84E000000                      mov rax, column_cells
   736 000004DA 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   737 000004DE 49F7E1                          mul r9
   738 000004E1 4C01C0                          add rax, r8
   739 000004E4 488DB8[000A0000]                lea rdi, [board + rax]
   740                                          
   741                                          ; Imprimir la letra
   742 000004EB 8A4302                          mov al, [rbx + 2]
   743 000004EE 8807                            mov [rdi], al
   744                                          
   745                                      .next_letter:
   746 000004F0 48FFC1                          inc rcx
   747 000004F3 EBC3                            jmp .print_loop
   748                                          
   749                                      .end:
   750 000004F5 59                              pop rcx
   751 000004F6 5B                              pop rbx
   752 000004F7 5D                              pop rbp
   753 000004F8 C3                              ret
   754                                  
   755                                  ; Función para borrar una letra específica
   756                                  ; Entrada:
   757                                  ;   r8b - posición x
   758                                  ;   r9b - posición y
   759                                  remove_letter:
   760 000004F9 55                          push rbp
   761 000004FA 4889E5                      mov rbp, rsp
   762 000004FD 53                          push rbx
   763 000004FE 51                          push rcx
   764                                      
   765 000004FF 4831C9                      xor rcx, rcx
   766                                      
   767                                      .find_loop:
   768 00000502 4883F964                        cmp rcx, 100              ; Máximo de letras
   769 00000506 7D2E                            jge .end
   770                                          
   771 00000508 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   772                                          
   773                                          ; Verificar si está activa y coincide la posición
   774 00000510 807B0300                        cmp byte [rbx + 3], 0
   775 00000514 741B                            je .next_letter
   776                                          
   777 00000516 8A03                            mov al, [rbx]
   778 00000518 4438C0                          cmp al, r8b
   779 0000051B 7514                            jne .next_letter
   780                                          
   781 0000051D 8A4301                          mov al, [rbx + 1]
   782 00000520 4438C8                          cmp al, r9b
   783 00000523 750C                            jne .next_letter
   784                                          
   785                                          ; Encontrada la letra, desactivarla
   786 00000525 C6430300                        mov byte [rbx + 3], 0
   787 00000529 FE0D(29180000)                  dec byte [letters_count]
   788 0000052F EB05                            jmp .end
   789                                          
   790                                      .next_letter:
   791 00000531 48FFC1                          inc rcx
   792 00000534 EBCC                            jmp .find_loop
   793                                          
   794                                      .end:
   795 00000536 59                              pop rcx
   796 00000537 5B                              pop rbx
   797 00000538 5D                              pop rbp
   798 00000539 C3                              ret
   799                                  ; Función para mover las letras hacia abajo
   800                                  move_letters:
   801 0000053A 55                          push rbp
   802 0000053B 4889E5                      mov rbp, rsp
   803 0000053E 53                          push rbx
   804 0000053F 57                          push rdi
   805 00000540 56                          push rsi
   806 00000541 4150                        push r8
   807 00000543 4151                        push r9
   808 00000545 4152                        push r10
   809 00000547 4153                        push r11
   810                                  
   811 00000549 4831C9                      xor rcx, rcx
   812                                  
   813                                      .move_loop:
   814 0000054C 4883F964                        cmp rcx, 100
   815 00000550 0F8DE3010000                    jge .print_last_letter
   816                                          
   817 00000556 488D1C8D[99160000]              lea rbx, [letters_map + rcx * 4]
   818 0000055E 807B0300                        cmp byte [rbx + 3], 0
   819 00000562 0F84C9010000                    je .next_letter
   820                                  
   821 00000568 4C0FB603                        movzx r8, byte [rbx]
   822 0000056C 4C0FB64B01                      movzx r9, byte [rbx + 1]
   823                                  
   824 00000571 B84E000000                      mov rax, column_cells
   825 00000576 4883C002                        add rax, 2
   826 0000057A 49F7E1                          mul r9
   827 0000057D 4C01C0                          add rax, r8
   828 00000580 488DB8[000A0000]                lea rdi, [board + rax]
   829 00000587 C60720                          mov byte [rdi], ' '
   830                                  
   831 0000058A FE4301                          inc byte [rbx + 1]
   832 0000058D 4C0FB64B01                      movzx r9, byte [rbx + 1]
   833                                  
   834 00000592 4983F91F                        cmp r9, row_cells - 1
   835 00000596 7C09                            jl .check_pallet_collision
   836                                  
   837 00000598 C6430300                        mov byte [rbx + 3], 0
   838 0000059C E990010000                      jmp .next_letter
   839                                  
   840                                          .check_pallet_collision:
   841 000005A1 B84E000000                          mov rax, column_cells
   842 000005A6 4883C002                            add rax, 2
   843 000005AA 49F7E1                              mul r9
   844 000005AD 4C01C0                              add rax, r8
   845 000005B0 488DB8[000A0000]                    lea rdi, [board + rax]
   846                                  
   847 000005B7 8A07                                mov al, [rdi]
   848 000005B9 3C20                                cmp al, ' '
   849 000005BB 0F8470010000                        je .next_letter
   850 000005C1 3C3D                                cmp al, char_equal
   851 000005C3 740A                                je .capture_letter
   852                                  
   853 000005C5 8A4302                              mov al, [rbx + 2]
   854 000005C8 8807                                mov [rdi], al
   855 000005CA E962010000                          jmp .next_letter
   856                                  
   857                                          .capture_letter:
   858                                              ; Obtener la nueva letra
   859 000005CF 8A4302                              mov al, [rbx + 2]
   860                                              
   861                                              ; Comparar con la última letra
   862 000005D2 3A05(2A180000)                      cmp al, [last_letter]
   863 000005D8 7407                                je .same_letter
   864                                              
   865                                              ; Es una letra diferente, resetear el procesamiento
   866 000005DA C605(3E180000)00                    mov byte [current_power_processed], 0
   867                                              
   868                                              .same_letter:
   869                                              ; Guardar la nueva letra
   870 000005E1 8805(2A180000)                      mov [last_letter], al
   871                                              
   872                                              ; Verificar si es 'E' para extender la paleta
   873 000005E7 3C45                                cmp al, 'E'
   874 000005E9 7450                                je .extend_pallet
   875                                              
   876                                              ; Verificar si es 'P' para añadir vida
   877 000005EB 3C50                                cmp al, 'P'
   878 000005ED 7478                                je .check_add_life
   879                                  
   880 000005EF 3C53                                cmp al, 'S'
   881 000005F1 0F84B4000000                        je .slow_ball
   882                                  
   883 000005F7 3C43                                cmp al, 'C'
   884 000005F9 0F84D5000000                        je .activate_catch
   885                                              
   886 000005FF 3C4C                                cmp al, 'L'
   887 00000601 0F84F6000000                        je .activate_laser
   888                                  
   889 00000607 3C44                                cmp al, 'D'
   890 00000609 0F8417010000                        je .activate_split
   891                                  
   892                                              ; Si no es ningún power-up, restaurar tamaño normal
   893 0000060F 488B05(4F140000)                    mov rax, [default_pallet_size]
   894 00000616 488905(47140000)                    mov [pallet_size], rax
   895 0000061D 48C705(40180000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   895 00000625 000000             
   896 00000628 C605(58180000)00                    mov byte [catch_power_active], 0
   897 0000062F C605(65180000)00                    mov byte [laser_power_active], 0
   898 00000636 E9F2000000                          jmp .finish_capture
   899                                  
   900                                              .extend_pallet:
   901 0000063B C605(65180000)00                        mov byte [laser_power_active], 0
   902 00000642 C605(58180000)00                        mov byte [catch_power_active], 0
   903 00000649 48C705(40180000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   903 00000651 000000             
   904 00000654 488B05(57140000)                        mov rax, [extended_pallet_size]
   905 0000065B 488905(47140000)                        mov [pallet_size], rax
   906 00000662 E9C6000000                              jmp .finish_capture
   907                                  
   908                                              .check_add_life:
   909 00000667 C605(65180000)00                        mov byte [laser_power_active], 0
   910 0000066E C605(58180000)00                        mov byte [catch_power_active], 0
   911 00000675 488B05(4F140000)                        mov rax, [default_pallet_size]
   912 0000067C 488905(47140000)                        mov [pallet_size], rax
   913 00000683 48C705(40180000)01-                     mov qword [ball_speed], 1 
   913 0000068B 000000             
   914                                                  ; Verificar si ya procesamos este power-up
   915 0000068E 803D(3E180000)00                        cmp byte [current_power_processed], 0
   916 00000695 0F8592000000                            jne .finish_capture
   917                                                  
   918                                                  ; Preservar registros importantes
   919 0000069B 51                                      push rcx
   920 0000069C 53                                      push rbx
   921                                                  
   922                                                  ; Marcar como procesado
   923 0000069D C605(3E180000)01                        mov byte [current_power_processed], 1
   924                                                  
   925                                                  ; Añadir una vida
   926 000006A4 E80E040000                              call add_life
   927                                                  
   928                                                  ; Restaurar registros
   929 000006A9 5B                                      pop rbx
   930 000006AA 59                                      pop rcx
   931                                                  
   932                                              .slow_ball:
   933 000006AB C605(65180000)00                        mov byte [laser_power_active], 0
   934 000006B2 C605(58180000)00                        mov byte [catch_power_active], 0                
   935 000006B9 488B05(4F140000)                        mov rax, [default_pallet_size]
   936 000006C0 488905(47140000)                        mov [pallet_size], rax
   937 000006C7 48C705(40180000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   937 000006CF 000000             
   938 000006D2 EB59                                    jmp .finish_capture
   939                                  
   940                                              .activate_catch:
   941 000006D4 C605(65180000)00                        mov byte [laser_power_active], 0
   942 000006DB 488B05(4F140000)                        mov rax, [default_pallet_size]
   943 000006E2 488905(47140000)                        mov [pallet_size], rax
   944 000006E9 48C705(40180000)01-                     mov qword [ball_speed], 1
   944 000006F1 000000             
   945 000006F4 C605(58180000)01                        mov byte [catch_power_active], 1
   946 000006FB EB30                                    jmp .finish_capture
   947                                  
   948                                              .activate_laser:
   949 000006FD C605(58180000)00                        mov byte [catch_power_active], 0
   950 00000704 488B05(4F140000)                        mov rax, [default_pallet_size]
   951 0000070B 488905(47140000)                        mov [pallet_size], rax
   952 00000712 48C705(40180000)01-                     mov qword [ball_speed], 1
   952 0000071A 000000             
   953 0000071D C605(65180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   954 00000724 EB07                                    jmp .finish_capture
   955                                  
   956                                              .activate_split:
   957 00000726 E8D2000000                              call activate_split_power
   958 0000072B EB00                                    jmp .finish_capture
   959                                  
   960                                              .finish_capture:
   961 0000072D C6430300                                mov byte [rbx + 3], 0
   962                                  
   963                                          .next_letter:
   964 00000731 48FFC1                              inc rcx
   965 00000734 E913FEFFFF                          jmp .move_loop
   966                                  
   967                                      .print_last_letter:
   968                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000739 B801000000          <1>  mov eax, sys_write
    83 0000073E BF01000000          <1>  mov edi, 1
    84 00000743 48BE-               <1>  mov rsi, %1
    84 00000745 [2B18000000000000]  <1>
    85 0000074D BA10000000          <1>  mov edx, %2
    86 00000752 0F05                <1>  syscall
   969 00000754 8A05(2A180000)                  mov al, [last_letter]
   970 0000075A 8805(3A180000)                  mov [last_letter_msg + 15], al
   971                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000760 B801000000          <1>  mov eax, sys_write
    83 00000765 BF01000000          <1>  mov edi, 1
    84 0000076A 48BE-               <1>  mov rsi, %1
    84 0000076C [3B18000000000000]  <1>
    85 00000774 BA03000000          <1>  mov edx, %2
    86 00000779 0F05                <1>  syscall
   972                                  
   973                                      .end:
   974 0000077B 415B                            pop r11
   975 0000077D 415A                            pop r10
   976 0000077F 4159                            pop r9
   977 00000781 4158                            pop r8
   978 00000783 5E                              pop rsi
   979 00000784 5F                              pop rdi
   980 00000785 5B                              pop rbx
   981 00000786 5D                              pop rbp
   982 00000787 C3                              ret
   983                                  
   984                                  
   985                                  clear_lasers:
   986 00000788 55                          push rbp
   987 00000789 4889E5                      mov  rbp, rsp
   988                                  
   989                                      ; Recorrer el array de láseres
   990 0000078C 4831C9                      xor rcx, rcx                ; Índice del láser
   991 0000078F 480FB61D(67180000)          movzx rbx, byte [laser_count]  ; Cantidad de láseres activos
   992                                  
   993                                      .clear_loop:
   994 00000797 4839D9                          cmp rcx, rbx
   995 0000079A 7D2F                            jge .done                ; Salir si no quedan láseres
   996                                  
   997                                          ; Obtener posición del láser actual
   998 0000079C 488DB409[68180000]              lea rsi, [lasers + rcx * 2]
   999 000007A4 4C0FB606                        movzx r8, byte [rsi]     ; X
  1000 000007A8 4C0FB64E01                      movzx r9, byte [rsi + 1] ; Y
  1001                                  
  1002                                          ; Calcular posición en el tablero
  1003 000007AD B84E000000                      mov rax, column_cells
  1004 000007B2 4883C002                        add rax, 2
  1005 000007B6 49F7E1                          mul r9
  1006 000007B9 4C01C0                          add rax, r8
  1007 000007BC 488DB8[000A0000]                lea rdi, [board + rax]
  1008                                  
  1009                                          ; Borrar el láser visualmente
  1010 000007C3 C60720                          mov byte [rdi], ' '
  1011                                  
  1012                                          ; Pasar al siguiente láser
  1013 000007C6 48FFC1                          inc rcx
  1014 000007C9 EBCC                            jmp .clear_loop
  1015                                  
  1016                                      .done:
  1017                                          ; Resetear contador de láseres
  1018 000007CB C605(67180000)00                mov byte [laser_count], 0
  1019                                  
  1020 000007D2 5D                              pop rbp
  1021 000007D3 C3                              ret
  1022                                  
  1023                                  
  1024                                  ; Nueva función para actualizar los láseres
  1025                                  update_lasers:
  1026 000007D4 55                          push rbp
  1027 000007D5 4889E5                      mov rbp, rsp
  1028                                      
  1029                                      ; Verificar si el poder láser está activo
  1030 000007D8 803D(65180000)00            cmp byte [laser_power_active], 0
  1031 000007DF 741A                        je .end
  1032                                      
  1033                                      ; Verificar si se presionó la tecla de espacio
  1034 000007E1 803D(64180000)20            cmp byte [last_key], ' '
  1035 000007E8 750C                        jne .skip_shooting
  1036                                      
  1037                                      ; Disparar nuevos láseres
  1038 000007EA E89A000000                  call shoot_lasers
  1039 000007EF C605(64180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
  1040                                      
  1041                                      .skip_shooting:
  1042                                      ; Mover los láseres existentes
  1043 000007F6 E828010000                  call move_lasers
  1044                                      
  1045                                      .end:
  1046 000007FB 5D                              pop rbp
  1047 000007FC C3                              ret
  1048                                  
  1049                                  activate_split_power:
  1050 000007FD 55                          push rbp
  1051 000007FE 4889E5                      mov rbp, rsp
  1052                                      
  1053                                      ; Verificar si la bola2 y bola3 ya están activas
  1054 00000801 803D(A2140000)01            cmp byte [ball2_active], 1
  1055 00000808 750B                        jne .enable_balls
  1056 0000080A 803D(C4140000)01            cmp byte [ball3_active], 1
  1057 00000811 7502                        jne .enable_balls
  1058                                      
  1059                                      ; Si ambas ya están activas, no hacemos nada.
  1060 00000813 EB72                        jmp .end
  1061                                  
  1062                                  .enable_balls:
  1063                                      ; Copiamos la posición de la bola principal
  1064 00000815 488B05(5F140000)            mov rax, [ball_x_pos]
  1065 0000081C 488905(81140000)            mov [ball2_x_pos], rax
  1066 00000823 488905(A3140000)            mov [ball3_x_pos], rax
  1067                                  
  1068 0000082A 488B05(67140000)            mov rax, [ball_y_pos]
  1069 00000831 488905(89140000)            mov [ball2_y_pos], rax
  1070 00000838 488905(AB140000)            mov [ball3_y_pos], rax
  1071                                  
  1072                                      ; Activamos bola2 y bola3 con direcciones diferentes
  1073                                      ; Por ejemplo: una va diagonal izq-arriba, otra diagonal der-arriba
  1074 0000083F 48C705(91140000)FF-         mov qword [ball2_direction_x], -1
  1074 00000847 FFFFFF             
  1075 0000084A 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  1075 00000852 FFFFFF             
  1076 00000855 C605(A1140000)01            mov byte [ball2_moving], 1
  1077 0000085C C605(A2140000)01            mov byte [ball2_active], 1
  1078                                  
  1079 00000863 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  1079 0000086B 000000             
  1080 0000086E 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  1080 00000876 FFFFFF             
  1081 00000879 C605(C3140000)01            mov byte [ball3_moving], 1
  1082 00000880 C605(C4140000)01            mov byte [ball3_active], 1
  1083                                  
  1084                                  .end:
  1085 00000887 5D                          pop rbp
  1086 00000888 C3                          ret
  1087                                  
  1088                                  
  1089                                  shoot_lasers:
  1090 00000889 55                          push rbp
  1091 0000088A 4889E5                      mov rbp, rsp
  1092 0000088D 53                          push rbx
  1093                                      
  1094                                      ; Verificar si hay espacio para más láseres
  1095 0000088E 480FB605(67180000)          movzx rax, byte [laser_count]
  1096 00000896 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
  1097 0000089A 0F8D80000000                jge .end
  1098                                      
  1099                                      ; Obtener posición de la paleta
  1100 000008A0 4C8B05(3F140000)            mov r8, [pallet_position]
  1101 000008A7 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
  1102                                      
  1103                                      ; Calcular coordenadas x,y
  1104 000008AE 4C89C0                      mov rax, r8
  1105 000008B1 41B94E000000                mov r9, column_cells
  1106 000008B7 4983C102                    add r9, 2                     ; Ancho total de línea
  1107 000008BB 4831D2                      xor rdx, rdx
  1108 000008BE 49F7F1                      div r9                        ; rax = y, rdx = x
  1109                                      
  1110                                      ; Guardar coordenadas
  1111 000008C1 4989C2                      mov r10, rax                  ; Y en r10
  1112 000008C4 4989D3                      mov r11, rdx                  ; X en r11
  1113                                      
  1114                                      ; Validar coordenadas
  1115 000008C7 4983FA00                    cmp r10, 0
  1116 000008CB 7C53                        jl .end
  1117 000008CD 4983FA20                    cmp r10, row_cells
  1118 000008D1 7D4D                        jge .end
  1119 000008D3 4983FB00                    cmp r11, 0
  1120 000008D7 7C47                        jl .end
  1121 000008D9 4983FB4E                    cmp r11, column_cells
  1122 000008DD 7D41                        jge .end
  1123                                      
  1124                                      ; Calcular índice para el primer láser
  1125 000008DF 480FB61D(67180000)          movzx rbx, byte [laser_count]
  1126 000008E7 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
  1127                                      
  1128                                      ; Primer láser (izquierda)
  1129 000008EB 488DBB[68180000]            lea rdi, [lasers + rbx]
  1130 000008F2 44881F                      mov [rdi], r11b              ; X
  1131 000008F5 4488D0                      mov al, r10b
  1132 000008F8 FEC8                        dec al                       ; Y - 1
  1133 000008FA 884701                      mov [rdi + 1], al           ; Y
  1134                                      
  1135                                      ; Segundo láser (derecha)
  1136 000008FD 4488D8                      mov al, r11b
  1137 00000900 0205(47140000)              add al, byte [pallet_size]
  1138 00000906 FEC8                        dec al                       ; Ajustar para el último carácter
  1139 00000908 488DBB[6A180000]            lea rdi, [lasers + rbx + 2]
  1140 0000090F 8807                        mov [rdi], al               ; X
  1141 00000911 4488D0                      mov al, r10b
  1142 00000914 FEC8                        dec al                      ; Y - 1
  1143 00000916 884701                      mov [rdi + 1], al          ; Y
  1144                                      
  1145                                      ; Incrementar contador de láseres
  1146 00000919 8005(67180000)02            add byte [laser_count], 2
  1147                                      
  1148                                      
  1149                                      .end:
  1150 00000920 5B                              pop rbx
  1151 00000921 5D                              pop rbp
  1152 00000922 C3                              ret
  1153                                  
  1154                                  ; Función corregida para mover láseres
  1155                                  ; Función corregida para mover láseres
  1156                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
  1157                                  
  1158                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
  1159                                  ; ============================================================
  1160                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
  1161                                  ; ============================================================
  1162                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
  1163                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
  1164                                  ; ============================================================
  1165                                  move_lasers:
  1166 00000923 55                          push rbp
  1167 00000924 4889E5                      mov  rbp, rsp
  1168 00000927 53                          push rbx
  1169 00000928 57                          push rdi
  1170 00000929 56                          push rsi
  1171 0000092A 4154                        push r12
  1172 0000092C 4155                        push r13
  1173 0000092E 4156                        push r14
  1174 00000930 4157                        push r15
  1175                                  
  1176                                      ; 1) Tomamos la cantidad de láseres
  1177 00000932 480FB60D(67180000)          movzx rcx, byte [laser_count]
  1178 0000093A 4885C9                      test rcx, rcx
  1179 0000093D 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1180                                  
  1181                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1182 00000943 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1183                                  
  1184                                  .loop_lasers:
  1185                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1186 00000946 488DB409[68180000]          lea rsi, [lasers + rcx*2]
  1187                                  
  1188                                      ; 2) Cargar x,y actuales del láser
  1189 0000094E 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1190 00000952 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1191                                  
  1192                                      ; 3) Borrar el láser de su posición actual en pantalla
  1193                                      ;    (por si en el ciclo anterior se había dibujado)
  1194 00000957 B84E000000                  mov rax, column_cells
  1195 0000095C 4883C002                    add rax, 2
  1196 00000960 49F7E1                      mul r9
  1197 00000963 4C01C0                      add rax, r8
  1198 00000966 488DB8[000A0000]            lea rdi, [board + rax]
  1199 0000096D C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1200                                  
  1201                                      ; 4) Mover el láser hacia arriba (y - 1)
  1202 00000970 49FFC9                      dec r9
  1203                                  
  1204                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1205 00000973 4983F901                    cmp r9, 1
  1206 00000977 7C57                        jl .delete_laser
  1207                                  
  1208                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1209 00000979 44884E01                    mov byte [rsi + 1], r9b
  1210                                  
  1211                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1212                                      ;    - Primero colisión con bloques
  1213                                      ; ---------------------------------------------------------
  1214                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1215 0000097D B84E000000                  mov rax, column_cells
  1216 00000982 4883C002                    add rax, 2
  1217 00000986 49F7E1                      mul r9
  1218 00000989 4C01C0                      add rax, r8
  1219 0000098C 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1220                                  
  1221                                      ; Revisar si hay bloque
  1222 00000993 51                          push rcx
  1223 00000994 56                          push rsi
  1224 00000995 57                          push rdi
  1225 00000996 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1226 00000999 E8E80E0000                  call check_block_collision
  1227 0000099E 5F                          pop rdi
  1228 0000099F 5E                          pop rsi
  1229 000009A0 59                          pop rcx
  1230                                  
  1231 000009A1 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1232 000009A4 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1233                                  
  1234                                      ;    - Luego colisión con enemigos
  1235                                      ; ---------------------------------------------------------
  1236 000009A6 51                          push rcx
  1237 000009A7 56                          push rsi
  1238 000009A8 57                          push rdi
  1239                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1240                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1241                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1242                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1243                                      ;
  1244                                      ; Hacemos algo como:
  1245 000009A9 4989FA                      mov r10, rdi
  1246 000009AC E85A000000                  call check_laser_enemy_collision
  1247 000009B1 5F                          pop rdi
  1248 000009B2 5E                          pop rsi
  1249 000009B3 59                          pop rcx
  1250                                  
  1251 000009B4 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1252 000009B7 7517                        jnz .delete_laser
  1253                                  
  1254                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1255 000009B9 8A05(66180000)              mov al, [laser_symbol]
  1256 000009BF 8807                        mov [rdi], al
  1257                                  
  1258                                  .next_laser:
  1259                                      ; Pasamos al láser anterior en el array
  1260 000009C1 48FFC9                      dec rcx
  1261 000009C4 4883F9FF                    cmp rcx, -1
  1262 000009C8 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1263 000009CE EB2E                        jmp .fin
  1264                                  
  1265                                  ; -----------------------------------------------------------------
  1266                                  ; Subrutina interna: .delete_laser
  1267                                  ; -----------------------------------------------------------------
  1268                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1269                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1270                                  .delete_laser:
  1271 000009D0 4C0FB625(67180000)          movzx r12, byte [laser_count]
  1272 000009D8 49FFCC                      dec r12                    ; r12 = índice del último láser
  1273 000009DB 4939CC                      cmp r12, rcx
  1274 000009DE 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1275                                  
  1276                                      ; Copiamos el último láser a la posición actual
  1277 000009E0 488DBC09[68180000]          lea rdi, [lasers + rcx*2]
  1278 000009E8 4B8DB424[68180000]          lea rsi, [lasers + r12*2]
  1279 000009F0 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1280 000009F3 668907                      mov [rdi], ax             ; copiamos X,Y
  1281                                  
  1282                                  .just_decrement:
  1283 000009F6 FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1284 000009FC EBC3                        jmp .next_laser
  1285                                  
  1286                                  .fin:
  1287 000009FE 415F                        pop r15
  1288 00000A00 415E                        pop r14
  1289 00000A02 415D                        pop r13
  1290 00000A04 415C                        pop r12
  1291 00000A06 5E                          pop rsi
  1292 00000A07 5F                          pop rdi
  1293 00000A08 5B                          pop rbx
  1294 00000A09 5D                          pop rbp
  1295 00000A0A C3                          ret
  1296                                  
  1297                                  
  1298                                  ; Nueva función para verificar colisión entre láser y enemigos
  1299                                  ; ==========================================================
  1300                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1301                                  ; ==========================================================
  1302                                  check_laser_enemy_collision:
  1303 00000A0B 55                          push rbp
  1304 00000A0C 4889E5                      mov  rbp, rsp
  1305                                      
  1306 00000A0F 4D31ED                      xor r13, r13            ; Índice del enemigo
  1307 00000A12 4831C0                      xor rax, rax            ; 0 = no colisión
  1308                                  
  1309                                  .loop_enemies:
  1310 00000A15 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1311 00000A19 7D64                        jge .end
  1312                                  
  1313                                      ; r13 * 3 => offset del enemigo i
  1314 00000A1B 4C89E9                      mov rcx, r13
  1315 00000A1E 486BC903                    imul rcx, 3
  1316 00000A22 488DB1[BD150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1317                                  
  1318                                      ; Verificar si está activo
  1319 00000A29 807E0201                    cmp byte [rsi+2], 1
  1320 00000A2D 754B                        jne .next_enemy
  1321                                  
  1322                                      ; Cargar posición X/Y del enemigo
  1323 00000A2F 4C0FB636                    movzx r14, byte [rsi]      ; X
  1324 00000A33 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1325                                  
  1326                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1327 00000A38 4D39F0                      cmp r8, r14
  1328 00000A3B 753D                        jne .next_enemy
  1329 00000A3D 4D39F9                      cmp r9, r15
  1330 00000A40 7538                        jne .next_enemy
  1331                                  
  1332                                      ; ==== Colisión detectada con láser ====
  1333                                  
  1334                                      ; 1) Desactivar enemigo
  1335 00000A42 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1336                                  
  1337                                      ; 2) Sumar puntos
  1338 00000A46 488B05(DC150000)            mov rax, [enemy_points]
  1339 00000A4D 480105(9B150000)            add [current_score], rax
  1340                                  
  1341                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1342                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1343 00000A54 4983FF1E                    cmp r15, row_cells - 2
  1344 00000A58 7419                        je .skip_erase
  1345                                  
  1346                                      ; Borrar visualmente del board
  1347 00000A5A B84E000000                  mov rax, column_cells
  1348 00000A5F 4883C002                    add rax, 2
  1349 00000A63 49F7E7                      mul r15
  1350 00000A66 4C01F0                      add rax, r14
  1351 00000A69 488DB8[000A0000]            lea rdi, [board + rax]
  1352 00000A70 C60720                      mov byte [rdi], ' '
  1353                                  
  1354                                  .skip_erase:
  1355                                  
  1356                                      ; 4) Devolver rax=1 => colisión con enemigo
  1357 00000A73 B801000000                  mov rax, 1
  1358 00000A78 EB05                        jmp .end
  1359                                  
  1360                                  .next_enemy:
  1361 00000A7A 49FFC5                      inc r13
  1362 00000A7D EB96                        jmp .loop_enemies
  1363                                  
  1364                                  .end:
  1365 00000A7F 5D                          pop rbp
  1366 00000A80 C3                          ret
  1367                                  
  1368                                  
  1369                                  ; Función auxiliar para eliminar un láser específico
  1370                                  remove_laser:
  1371 00000A81 55                          push rbp
  1372 00000A82 4889E5                      mov rbp, rsp
  1373                                  
  1374                                      ; Borrar el láser del tablero
  1375 00000A85 41C60220                    mov byte [r10], ' '
  1376                                  
  1377                                      ; Mover el último láser a esta posición si no es el último
  1378 00000A89 480FB605(67180000)          movzx rax, byte [laser_count]
  1379 00000A91 48FFC8                      dec rax                    ; Índice del último láser
  1380 00000A94 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1381 00000A97 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1382                                  
  1383                                      ; Copiar último láser a la posición actual
  1384 00000A99 4B8DBC24[68180000]          lea rdi, [lasers + r12*2]
  1385 00000AA1 488DB400[68180000]          lea rsi, [lasers + rax*2]
  1386 00000AA9 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1387 00000AAC 668917                      mov [rdi], dx
  1388                                  
  1389                                  .just_decrease:
  1390 00000AAF FE0D(67180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1391                                  
  1392 00000AB5 5D                          pop rbp
  1393 00000AB6 C3                          ret
  1394                                  
  1395                                  add_life:
  1396 00000AB7 55                          push rbp
  1397 00000AB8 4889E5                      mov rbp, rsp
  1398 00000ABB 53                          push rbx
  1399 00000ABC 51                          push rcx
  1400 00000ABD 57                          push rdi
  1401 00000ABE 56                          push rsi
  1402 00000ABF 4150                        push r8
  1403 00000AC1 4151                        push r9
  1404                                      
  1405                                      ; Verificar si ya tenemos el máximo de vidas
  1406 00000AC3 480FB605(98160000)          movzx rax, byte [current_lives]
  1407 00000ACB 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1408 00000ACF 7D2C                        jge .end
  1409                                      
  1410                                      ; Incrementar el contador de vidas
  1411 00000AD1 FE05(98160000)              inc byte [current_lives]
  1412                                      
  1413                                      ; Encontrar la siguiente vida inactiva
  1414 00000AD7 4831C9                      xor rcx, rcx
  1415                                      
  1416                                      .find_inactive:
  1417 00000ADA 4883F907                        cmp rcx, lives_count
  1418 00000ADE 7D1D                            jge .end
  1419                                          
  1420                                          ; Calcular offset de la vida actual
  1421 00000AE0 4889C8                          mov rax, rcx
  1422 00000AE3 486BC003                        imul rax, 3
  1423 00000AE7 488DB0[82160000]                lea rsi, [lives_data + rax]
  1424                                          
  1425                                          ; Verificar si está inactiva
  1426 00000AEE 807E0200                        cmp byte [rsi + 2], 0
  1427 00000AF2 7405                            je .activate_life
  1428                                          
  1429 00000AF4 48FFC1                          inc rcx
  1430 00000AF7 EBE1                            jmp .find_inactive
  1431                                          
  1432                                      .activate_life:
  1433                                          ; Activar la vida
  1434 00000AF9 C6460201                        mov byte [rsi + 2], 1
  1435                                          
  1436                                      .end:
  1437 00000AFD 4159                            pop r9
  1438 00000AFF 4158                            pop r8
  1439 00000B01 5E                              pop rsi
  1440 00000B02 5F                              pop rdi
  1441 00000B03 59                              pop rcx
  1442 00000B04 5B                              pop rbx
  1443 00000B05 5D                              pop rbp
  1444 00000B06 C3                              ret
  1445                                  
  1446                                  
  1447                                  print_ball:
  1448 00000B07 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1449 00000B0E 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1450 00000B15 4981C0[000A0000]        	add r8, board
  1451                                  
  1452 00000B1C 4C89C9                  	mov rcx, r9
  1453 00000B1F B850000000              	mov rax, column_cells + 2
  1454 00000B24 48F7E9                  	imul rcx
  1455                                  	
  1456 00000B27 4901C0                  	add r8, rax
  1457 00000B2A 41C6004F                	mov byte [r8], char_O
  1458 00000B2E C3                      	ret
  1459                                  
  1460                                  print_ball_2:
  1461 00000B2F 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1462 00000B36 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1463 00000B3D 4981C0[000A0000]            add r8, board
  1464 00000B44 4C89C9                      mov rcx, r9
  1465 00000B47 B850000000                  mov rax, column_cells + 2
  1466 00000B4C 48F7E9                      imul rcx
  1467 00000B4F 4901C0                      add r8, rax
  1468 00000B52 41C6004F                    mov byte [r8], char_O
  1469 00000B56 C3                          ret
  1470                                  
  1471                                  print_ball_3:
  1472 00000B57 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1473 00000B5E 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1474 00000B65 4981C0[000A0000]            add r8, board
  1475 00000B6C 4C89C9                      mov rcx, r9
  1476 00000B6F B850000000                  mov rax, column_cells + 2
  1477 00000B74 48F7E9                      imul rcx
  1478 00000B77 4901C0                      add r8, rax
  1479 00000B7A 41C6004F                    mov byte [r8], char_O
  1480 00000B7E C3                          ret
  1481                                  
  1482                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1483                                  	
  1484                                  print_pallet:
  1485                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1486 00000B7F 4C8B05(3F140000)            mov r8, [pallet_position]
  1487 00000B86 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1488                                      .clear_pallet:
  1489 00000B8D 41C60020                        mov byte [r8], char_space
  1490 00000B91 49FFC0                          inc r8
  1491 00000B94 48FFC9                          dec rcx
  1492 00000B97 75F4                            jnz .clear_pallet
  1493                                  
  1494                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1495 00000B99 4C8B05(3F140000)            mov r8, [pallet_position]
  1496 00000BA0 488B0D(47140000)            mov rcx, [pallet_size]
  1497                                      .write_pallet:
  1498 00000BA7 41C6003D                        mov byte [r8], char_equal
  1499 00000BAB 49FFC0                          inc r8
  1500 00000BAE 48FFC9                          dec rcx
  1501 00000BB1 75F4                            jnz .write_pallet
  1502                                  
  1503 00000BB3 C3                          ret
  1504                                  
  1505                                  move_pallet:
  1506                                      
  1507 00000BB4 803D(7F140000)00            cmp byte [ball_moving], 0
  1508 00000BBB 7507                        jne .continue_movement
  1509 00000BBD C605(7F140000)01            mov byte [ball_moving], 1
  1510                                  
  1511                                      .continue_movement:
  1512 00000BC4 4883FFFF                        cmp rdi, left_direction
  1513 00000BC8 7531                            jne .move_right
  1514                                  
  1515                                          .move_left:
  1516                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1517 00000BCA 4C8B05(3F140000)                    mov r8, [pallet_position]
  1518 00000BD1 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1519 00000BD4 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1520 00000BD7 3C58                                cmp al, 'X'        ; Comparar si es una X
  1521 00000BD9 744E                                je .end            ; Si es X, no mover
  1522                                              
  1523 00000BDB 4C8B05(3F140000)                    mov r8, [pallet_position]
  1524 00000BE2 4C8B0D(47140000)                    mov r9, [pallet_size]
  1525 00000BE9 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1526 00000BEF 49FFC8                              dec r8
  1527 00000BF2 4C8905(3F140000)                    mov [pallet_position], r8
  1528 00000BF9 EB2E                                jmp .end
  1529                                              
  1530                                          .move_right:
  1531                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1532 00000BFB 4C8B05(3F140000)                    mov r8, [pallet_position]
  1533 00000C02 4C8B0D(47140000)                    mov r9, [pallet_size]
  1534 00000C09 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1535 00000C0C 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1536 00000C10 3C58                                cmp al, 'X'        ; Comparar si es una X
  1537 00000C12 7415                                je .end            ; Si es X, no mover
  1538                                              
  1539 00000C14 4C8B05(3F140000)                    mov r8, [pallet_position]
  1540 00000C1B 41C60020                            mov byte [r8], char_space
  1541 00000C1F 49FFC0                              inc r8
  1542 00000C22 4C8905(3F140000)                    mov [pallet_position], r8
  1543                                          .end:
  1544 00000C29 C3                                  ret
  1545                                  
  1546                                  
  1547                                  
  1548                                              
  1549                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1550                                  update_caught_ball_position:
  1551 00000C2A 55                          push rbp
  1552 00000C2B 4889E5                      mov rbp, rsp
  1553                                      
  1554                                      ; Calcular la nueva posición de la bola basada en la paleta
  1555 00000C2E 4C8B05(3F140000)            mov r8, [pallet_position]
  1556 00000C35 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1557 00000C3C B850000000                  mov rax, column_cells + 2
  1558 00000C41 4831D2                      xor rdx, rdx
  1559 00000C44 48F7F0                      div rax                ; División para obtener X,Y
  1560                                      
  1561                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1562 00000C47 4989C1                      mov r9, rax            ; Y de la paleta
  1563 00000C4A 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1564                                      
  1565                                      ; Añadir el offset guardado a la posición X
  1566 00000C4D 4889D0                      mov rax, rdx
  1567 00000C50 480305(5C180000)            add rax, [ball_catch_offset]
  1568 00000C57 488905(5F140000)            mov [ball_x_pos], rax
  1569 00000C5E 4C890D(67140000)            mov [ball_y_pos], r9
  1570                                      
  1571 00000C65 5D                          pop rbp
  1572 00000C66 C3                          ret
  1573                                  
  1574                                  
  1575                                  move_all_balls:
  1576 00000C67 55                          push rbp
  1577 00000C68 4889E5                      mov rbp, rsp
  1578 00000C6B 53                          push rbx
  1579                                      
  1580                                      ; Inicializar contador de bolas
  1581 00000C6C 4831DB                      xor rbx, rbx
  1582                                      
  1583                                  .loop_balls:
  1584                                      ; Verificar si hemos procesado todas las bolas
  1585 00000C6F 3A1D(9B190000)              cmp bl, byte [balls_count]
  1586 00000C75 7D1D                        jge .end
  1587                                      
  1588                                      ; Calcular offset de la bola actual
  1589 00000C77 B821000000                  mov rax, BALL_STRUCT_SIZE
  1590 00000C7C 48F7E3                      mul rbx
  1591                                      
  1592                                      ; Verificar si la bola está activa
  1593 00000C7F 80B8[58190000]01            cmp byte [balls_data + rax + 32], 1
  1594 00000C86 7507                        jne .next_ball
  1595                                      
  1596                                      ; Guardar offset en la pila
  1597 00000C88 50                          push rax
  1598                                      
  1599                                      ; Llamar a move_ball con los parámetros de esta bola
  1600 00000C89 E809000000                  call move_ball
  1601                                      
  1602                                      ; Restaurar offset
  1603 00000C8E 58                          pop rax
  1604                                      
  1605                                  .next_ball:
  1606 00000C8F 48FFC3                      inc rbx
  1607 00000C92 EBDB                        jmp .loop_balls
  1608                                      
  1609                                  .end:
  1610 00000C94 5B                          pop rbx
  1611 00000C95 5D                          pop rbp
  1612 00000C96 C3                          ret
  1613                                  
  1614                                  move_ball:
  1615                                  
  1616 00000C97 803D(59180000)01            cmp byte [ball_caught], 1
  1617 00000C9E 0F849D000000                je .move_with_pallet
  1618                                  
  1619 00000CA4 803D(7F140000)00            cmp byte [ball_moving], 0
  1620 00000CAB 0F84B8010000                je .end
  1621                                  
  1622                                      ; Incrementar contador de velocidad
  1623 00000CB1 48FF05(50180000)            inc qword [speed_counter]
  1624                                      
  1625                                      ; Verificar si debemos mover la bola en este ciclo
  1626 00000CB8 488B05(50180000)            mov rax, [speed_counter]
  1627 00000CBF 483B05(40180000)            cmp rax, [ball_speed]
  1628 00000CC6 0F8C9D010000                jl .end
  1629                                      
  1630                                      ; Resetear contador de velocidad
  1631 00000CCC 48C705(50180000)00-         mov qword [speed_counter], 0
  1631 00000CD4 000000             
  1632                                  
  1633                                      ; Borrar la posición actual de la bola
  1634 00000CD7 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1635 00000CDE 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1636 00000CE5 4981C0[000A0000]            add r8, board
  1637 00000CEC 4C89C9                      mov rcx, r9
  1638 00000CEF B850000000                  mov rax, column_cells + 2
  1639 00000CF4 48F7E9                      imul rcx
  1640 00000CF7 4901C0                      add r8, rax
  1641 00000CFA 41C60020                    mov byte [r8], char_space
  1642                                  
  1643                                      ; Calcular siguiente posición X
  1644 00000CFE 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1645 00000D05 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1646 00000D0C 488B05(6F140000)            mov rax, [ball_direction_x]
  1647 00000D13 4901C0                      add r8, rax               ; Nueva posición X
  1648                                  
  1649                                      ; Calcular la dirección de memoria para la siguiente posición
  1650 00000D16 4D89C2                      mov r10, r8
  1651 00000D19 4981C2[000A0000]            add r10, board
  1652 00000D20 4C89C9                      mov rcx, r9
  1653 00000D23 B850000000                  mov rax, column_cells + 2
  1654 00000D28 48F7E9                      imul rcx
  1655 00000D2B 4901C2                      add r10, rax
  1656                                  
  1657                                      ; Verificar si hay una X en la siguiente posición X
  1658 00000D2E 418A02                      mov al, [r10]
  1659 00000D31 3C58                        cmp al, 'X'
  1660 00000D33 7565                        jne .check_block_x
  1661 00000D35 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1662 00000D3C E928010000                  jmp .end
  1663                                  
  1664                                      .move_with_pallet:
  1665                                          ; Borrar la posición actual de la bola
  1666 00000D41 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1667 00000D48 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1668 00000D4F 4D89C2                          mov r10, r8
  1669 00000D52 4981C2[000A0000]                add r10, board
  1670 00000D59 4C89C9                          mov rcx, r9
  1671 00000D5C B850000000                      mov rax, column_cells + 2
  1672 00000D61 48F7E9                          imul rcx
  1673 00000D64 4901C2                          add r10, rax
  1674 00000D67 41C60220                        mov byte [r10], char_space
  1675                                  
  1676                                          ; Actualizar posición X basada en la paleta
  1677 00000D6B 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1678 00000D72 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1679 00000D79 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1680 00000D80 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1681                                  
  1682                                          ; Mantener la bola una posición arriba de la paleta
  1683 00000D87 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1684 00000D8E 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1685                                  
  1686 00000D95 E9CF000000                      jmp .end
  1687                                  
  1688                                  
  1689                                      .check_block_x:
  1690                                          ; Verificar colisión con bloques en X
  1691 00000D9A 4150                            push r8     ; Guardar registros que usa check_block_collision
  1692 00000D9C 4151                            push r9
  1693 00000D9E 4152                            push r10
  1694 00000DA0 E8E10A0000                      call check_block_collision
  1695 00000DA5 415A                            pop r10
  1696 00000DA7 4159                            pop r9
  1697 00000DA9 4158                            pop r8
  1698 00000DAB 4885C0                          test rax, rax
  1699 00000DAE 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1700 00000DB0 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1701 00000DB7 E9AD000000                      jmp .end
  1702                                  
  1703                                      .check_paddle_x:
  1704                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1705 00000DBC 41803A3D                        cmp byte [r10], char_equal
  1706 00000DC0 750C                            jne .check_y_movement
  1707 00000DC2 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1708 00000DC9 E99B000000                      jmp .end
  1709                                  
  1710                                      .check_y_movement:
  1711                                          ; Calcular siguiente posición Y
  1712 00000DCE 488B05(77140000)                mov rax, [ball_direction_y]
  1713 00000DD5 4901C1                          add r9, rax                  ; Nueva posición Y
  1714                                  
  1715                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1716 00000DD8 4D89C2                          mov r10, r8
  1717 00000DDB 4981C2[000A0000]                add r10, board
  1718 00000DE2 4C89C9                          mov rcx, r9
  1719 00000DE5 B850000000                      mov rax, column_cells + 2
  1720 00000DEA 48F7E9                          imul rcx
  1721 00000DED 4901C2                          add r10, rax
  1722                                  
  1723                                          ; Verificar si hay una X en la siguiente posición Y
  1724 00000DF0 418A02                          mov al, [r10]
  1725 00000DF3 3C58                            cmp al, 'X'
  1726 00000DF5 7509                            jne .check_block_y
  1727 00000DF7 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1728 00000DFE EB69                            jmp .end
  1729                                  
  1730                                      .check_block_y:
  1731                                          ; Verificar colisión con bloques en Y
  1732 00000E00 4150                            push r8     ; Guardar registros que usa check_block_collision
  1733 00000E02 4151                            push r9
  1734 00000E04 4152                            push r10
  1735 00000E06 E87B0A0000                      call check_block_collision
  1736 00000E0B 415A                            pop r10
  1737 00000E0D 4159                            pop r9
  1738 00000E0F 4158                            pop r8
  1739 00000E11 4885C0                          test rax, rax
  1740 00000E14 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1741 00000E16 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1742 00000E1D EB4A                            jmp .end
  1743                                  
  1744                                      .check_paddle_y:
  1745                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1746 00000E1F 41803A3D                        cmp byte [r10], char_equal
  1747 00000E23 7536                            jne .update_position
  1748                                  
  1749                                          ; Verificar si el poder catch está activo
  1750 00000E25 803D(58180000)01                cmp byte [catch_power_active], 1
  1751 00000E2C 7524                            jne .normal_bounce
  1752                                  
  1753                                          ; Activar el modo "atrapado"
  1754 00000E2E C605(59180000)01                mov byte [ball_caught], 1
  1755                                          
  1756                                          ; Guardar la posición X actual de la bola como offset
  1757 00000E35 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1758 00000E3C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1759 00000E43 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1760 00000E49 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1761                                          
  1762 00000E50 EB17                            jmp .end
  1763                                  
  1764                                      .normal_bounce:
  1765 00000E52 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1766 00000E59 EB0E                            jmp .end
  1767                                  
  1768                                  
  1769                                      .update_position:
  1770 00000E5B 4C8905(5F140000)                mov [ball_x_pos], r8
  1771 00000E62 4C890D(67140000)                mov [ball_y_pos], r9
  1772                                  
  1773                                      .end:
  1774 00000E69 C3                              ret
  1775                                  
  1776                                  
  1777                                  move_ball_2:
  1778                                  
  1779 00000E6A 803D(5A180000)01            cmp byte [ball_caught_2], 1
  1780 00000E71 0F849D000000                je .move_with_pallet
  1781                                  
  1782 00000E77 803D(A1140000)00            cmp byte [ball2_moving], 0
  1783 00000E7E 0F84B8010000                je .end
  1784                                  
  1785                                      ; Incrementar contador de velocidad
  1786 00000E84 48FF05(50180000)            inc qword [speed_counter]
  1787                                      
  1788                                      ; Verificar si debemos mover la bola en este ciclo
  1789 00000E8B 488B05(50180000)            mov rax, [speed_counter]
  1790 00000E92 483B05(40180000)            cmp rax, [ball_speed]
  1791 00000E99 0F8C9D010000                jl .end
  1792                                      
  1793                                      ; Resetear contador de velocidad
  1794 00000E9F 48C705(50180000)00-         mov qword [speed_counter], 0
  1794 00000EA7 000000             
  1795                                  
  1796                                      ; Borrar la posición actual de la bola
  1797 00000EAA 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1798 00000EB1 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1799 00000EB8 4981C0[000A0000]            add r8, board
  1800 00000EBF 4C89C9                      mov rcx, r9
  1801 00000EC2 B850000000                  mov rax, column_cells + 2
  1802 00000EC7 48F7E9                      imul rcx
  1803 00000ECA 4901C0                      add r8, rax
  1804 00000ECD 41C60020                    mov byte [r8], char_space
  1805                                  
  1806                                      ; Calcular siguiente posición X
  1807 00000ED1 4C8B05(81140000)            mov r8, [ball2_x_pos]
  1808 00000ED8 4C8B0D(89140000)            mov r9, [ball2_y_pos]
  1809 00000EDF 488B05(91140000)            mov rax, [ball2_direction_x]
  1810 00000EE6 4901C0                      add r8, rax               ; Nueva posición X
  1811                                  
  1812                                      ; Calcular la dirección de memoria para la siguiente posición
  1813 00000EE9 4D89C2                      mov r10, r8
  1814 00000EEC 4981C2[000A0000]            add r10, board
  1815 00000EF3 4C89C9                      mov rcx, r9
  1816 00000EF6 B850000000                  mov rax, column_cells + 2
  1817 00000EFB 48F7E9                      imul rcx
  1818 00000EFE 4901C2                      add r10, rax
  1819                                  
  1820                                      ; Verificar si hay una X en la siguiente posición X
  1821 00000F01 418A02                      mov al, [r10]
  1822 00000F04 3C58                        cmp al, 'X'
  1823 00000F06 7565                        jne .check_block_x
  1824 00000F08 48F71D(91140000)            neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una X
  1825 00000F0F E928010000                  jmp .end
  1826                                  
  1827                                      .move_with_pallet:
  1828                                          ; Borrar la posición actual de la bola
  1829 00000F14 4C8B05(81140000)                mov r8, [ball2_x_pos]
  1830 00000F1B 4C8B0D(89140000)                mov r9, [ball2_y_pos]
  1831 00000F22 4D89C2                          mov r10, r8
  1832 00000F25 4981C2[000A0000]                add r10, board
  1833 00000F2C 4C89C9                          mov rcx, r9
  1834 00000F2F B850000000                      mov rax, column_cells + 2
  1835 00000F34 48F7E9                          imul rcx
  1836 00000F37 4901C2                          add r10, rax
  1837 00000F3A 41C60220                        mov byte [r10], char_space
  1838                                  
  1839                                          ; Actualizar posición X basada en la paleta
  1840 00000F3E 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1841 00000F45 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1842 00000F4C 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1843 00000F53 4C8905(81140000)                mov [ball2_x_pos], r8          ; Guardar nueva posición X
  1844                                  
  1845                                          ; Mantener la bola una posición arriba de la paleta
  1846 00000F5A 4C8B0D(89140000)                mov r9, [ball2_y_pos]          ; Mantener la misma altura
  1847 00000F61 4C890D(89140000)                mov [ball2_y_pos], r9          ; Actualizar posición Y
  1848                                  
  1849 00000F68 E9CF000000                      jmp .end
  1850                                  
  1851                                  
  1852                                      .check_block_x:
  1853                                          ; Verificar colisión con bloques en X
  1854 00000F6D 4150                            push r8     ; Guardar registros que usa check_block_collision
  1855 00000F6F 4151                            push r9
  1856 00000F71 4152                            push r10
  1857 00000F73 E80E090000                      call check_block_collision
  1858 00000F78 415A                            pop r10
  1859 00000F7A 4159                            pop r9
  1860 00000F7C 4158                            pop r8
  1861 00000F7E 4885C0                          test rax, rax
  1862 00000F81 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1863 00000F83 48F71D(91140000)                neg qword [ball2_direction_x]  ; Si hay colisión, rebotar
  1864 00000F8A E9AD000000                      jmp .end
  1865                                  
  1866                                      .check_paddle_x:
  1867                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1868 00000F8F 41803A3D                        cmp byte [r10], char_equal
  1869 00000F93 750C                            jne .check_y_movement
  1870 00000F95 48F71D(91140000)                neg qword [ball2_direction_x]  ; Cambiar dirección X si hay una paleta
  1871 00000F9C E99B000000                      jmp .end
  1872                                  
  1873                                      .check_y_movement:
  1874                                          ; Calcular siguiente posición Y
  1875 00000FA1 488B05(99140000)                mov rax, [ball2_direction_y]
  1876 00000FA8 4901C1                          add r9, rax                  ; Nueva posición Y
  1877                                  
  1878                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1879 00000FAB 4D89C2                          mov r10, r8
  1880 00000FAE 4981C2[000A0000]                add r10, board
  1881 00000FB5 4C89C9                          mov rcx, r9
  1882 00000FB8 B850000000                      mov rax, column_cells + 2
  1883 00000FBD 48F7E9                          imul rcx
  1884 00000FC0 4901C2                          add r10, rax
  1885                                  
  1886                                          ; Verificar si hay una X en la siguiente posición Y
  1887 00000FC3 418A02                          mov al, [r10]
  1888 00000FC6 3C58                            cmp al, 'X'
  1889 00000FC8 7509                            jne .check_block_y
  1890 00000FCA 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una X
  1891 00000FD1 EB69                            jmp .end
  1892                                  
  1893                                      .check_block_y:
  1894                                          ; Verificar colisión con bloques en Y
  1895 00000FD3 4150                            push r8     ; Guardar registros que usa check_block_collision
  1896 00000FD5 4151                            push r9
  1897 00000FD7 4152                            push r10
  1898 00000FD9 E8A8080000                      call check_block_collision
  1899 00000FDE 415A                            pop r10
  1900 00000FE0 4159                            pop r9
  1901 00000FE2 4158                            pop r8
  1902 00000FE4 4885C0                          test rax, rax
  1903 00000FE7 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1904 00000FE9 48F71D(99140000)                neg qword [ball2_direction_y]  ; Si hay colisión, rebotar
  1905 00000FF0 EB4A                            jmp .end
  1906                                  
  1907                                      .check_paddle_y:
  1908                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1909 00000FF2 41803A3D                        cmp byte [r10], char_equal
  1910 00000FF6 7536                            jne .update_position
  1911                                  
  1912                                          ; Verificar si el poder catch está activo
  1913 00000FF8 803D(58180000)01                cmp byte [catch_power_active], 1
  1914 00000FFF 7524                            jne .normal_bounce
  1915                                  
  1916                                          ; Activar el modo "atrapado"
  1917 00001001 C605(5A180000)01                mov byte [ball_caught_2], 1
  1918                                          
  1919                                          ; Guardar la posición X actual de la bola como offset
  1920 00001008 488B05(81140000)                mov rax, [ball2_x_pos]           ; Posición X actual de la bola
  1921 0000100F 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1922 00001016 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1923 0000101C 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1924                                          
  1925 00001023 EB17                            jmp .end
  1926                                  
  1927                                      .normal_bounce:
  1928 00001025 48F71D(99140000)                neg qword [ball2_direction_y]  ; Cambiar dirección Y si hay una paleta
  1929 0000102C EB0E                            jmp .end
  1930                                  
  1931                                  
  1932                                      .update_position:
  1933 0000102E 4C8905(81140000)                mov [ball2_x_pos], r8
  1934 00001035 4C890D(89140000)                mov [ball2_y_pos], r9
  1935                                  
  1936                                      .end:
  1937 0000103C C3                              ret
  1938                                  
  1939                                  move_ball_3:
  1940                                  
  1941 0000103D 803D(5B180000)01            cmp byte [ball_caught_3], 1
  1942 00001044 0F849D000000                je .move_with_pallet
  1943                                  
  1944 0000104A 803D(C3140000)00            cmp byte [ball3_moving], 0
  1945 00001051 0F84B8010000                je .end
  1946                                  
  1947                                      ; Incrementar contador de velocidad
  1948 00001057 48FF05(50180000)            inc qword [speed_counter]
  1949                                      
  1950                                      ; Verificar si debemos mover la bola en este ciclo
  1951 0000105E 488B05(50180000)            mov rax, [speed_counter]
  1952 00001065 483B05(40180000)            cmp rax, [ball_speed]
  1953 0000106C 0F8C9D010000                jl .end
  1954                                      
  1955                                      ; Resetear contador de velocidad
  1956 00001072 48C705(50180000)00-         mov qword [speed_counter], 0
  1956 0000107A 000000             
  1957                                  
  1958                                      ; Borrar la posición actual de la bola
  1959 0000107D 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1960 00001084 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1961 0000108B 4981C0[000A0000]            add r8, board
  1962 00001092 4C89C9                      mov rcx, r9
  1963 00001095 B850000000                  mov rax, column_cells + 2
  1964 0000109A 48F7E9                      imul rcx
  1965 0000109D 4901C0                      add r8, rax
  1966 000010A0 41C60020                    mov byte [r8], char_space
  1967                                  
  1968                                      ; Calcular siguiente posición X
  1969 000010A4 4C8B05(A3140000)            mov r8, [ball3_x_pos]
  1970 000010AB 4C8B0D(AB140000)            mov r9, [ball3_y_pos]
  1971 000010B2 488B05(B3140000)            mov rax, [ball3_direction_x]
  1972 000010B9 4901C0                      add r8, rax               ; Nueva posición X
  1973                                  
  1974                                      ; Calcular la dirección de memoria para la siguiente posición
  1975 000010BC 4D89C2                      mov r10, r8
  1976 000010BF 4981C2[000A0000]            add r10, board
  1977 000010C6 4C89C9                      mov rcx, r9
  1978 000010C9 B850000000                  mov rax, column_cells + 2
  1979 000010CE 48F7E9                      imul rcx
  1980 000010D1 4901C2                      add r10, rax
  1981                                  
  1982                                      ; Verificar si hay una X en la siguiente posición X
  1983 000010D4 418A02                      mov al, [r10]
  1984 000010D7 3C58                        cmp al, 'X'
  1985 000010D9 7565                        jne .check_block_x
  1986 000010DB 48F71D(B3140000)            neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una X
  1987 000010E2 E928010000                  jmp .end
  1988                                  
  1989                                      .move_with_pallet:
  1990                                          ; Borrar la posición actual de la bola
  1991 000010E7 4C8B05(A3140000)                mov r8, [ball3_x_pos]
  1992 000010EE 4C8B0D(AB140000)                mov r9, [ball3_y_pos]
  1993 000010F5 4D89C2                          mov r10, r8
  1994 000010F8 4981C2[000A0000]                add r10, board
  1995 000010FF 4C89C9                          mov rcx, r9
  1996 00001102 B850000000                      mov rax, column_cells + 2
  1997 00001107 48F7E9                          imul rcx
  1998 0000110A 4901C2                          add r10, rax
  1999 0000110D 41C60220                        mov byte [r10], char_space
  2000                                  
  2001                                          ; Actualizar posición X basada en la paleta
  2002 00001111 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  2003 00001118 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  2004 0000111F 4C0305(5C180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  2005 00001126 4C8905(A3140000)                mov [ball3_x_pos], r8          ; Guardar nueva posición X
  2006                                  
  2007                                          ; Mantener la bola una posición arriba de la paleta
  2008 0000112D 4C8B0D(AB140000)                mov r9, [ball3_y_pos]          ; Mantener la misma altura
  2009 00001134 4C890D(AB140000)                mov [ball3_y_pos], r9          ; Actualizar posición Y
  2010                                  
  2011 0000113B E9CF000000                      jmp .end
  2012                                  
  2013                                  
  2014                                      .check_block_x:
  2015                                          ; Verificar colisión con bloques en X
  2016 00001140 4150                            push r8     ; Guardar registros que usa check_block_collision
  2017 00001142 4151                            push r9
  2018 00001144 4152                            push r10
  2019 00001146 E83B070000                      call check_block_collision
  2020 0000114B 415A                            pop r10
  2021 0000114D 4159                            pop r9
  2022 0000114F 4158                            pop r8
  2023 00001151 4885C0                          test rax, rax
  2024 00001154 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  2025 00001156 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Si hay colisión, rebotar
  2026 0000115D E9AD000000                      jmp .end
  2027                                  
  2028                                      .check_paddle_x:
  2029                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  2030 00001162 41803A3D                        cmp byte [r10], char_equal
  2031 00001166 750C                            jne .check_y_movement
  2032 00001168 48F71D(B3140000)                neg qword [ball3_direction_x]  ; Cambiar dirección X si hay una paleta
  2033 0000116F E99B000000                      jmp .end
  2034                                  
  2035                                      .check_y_movement:
  2036                                          ; Calcular siguiente posición Y
  2037 00001174 488B05(BB140000)                mov rax, [ball3_direction_y]
  2038 0000117B 4901C1                          add r9, rax                  ; Nueva posición Y
  2039                                  
  2040                                          ; Calcular la dirección de memoria para la siguiente posición Y
  2041 0000117E 4D89C2                          mov r10, r8
  2042 00001181 4981C2[000A0000]                add r10, board
  2043 00001188 4C89C9                          mov rcx, r9
  2044 0000118B B850000000                      mov rax, column_cells + 2
  2045 00001190 48F7E9                          imul rcx
  2046 00001193 4901C2                          add r10, rax
  2047                                  
  2048                                          ; Verificar si hay una X en la siguiente posición Y
  2049 00001196 418A02                          mov al, [r10]
  2050 00001199 3C58                            cmp al, 'X'
  2051 0000119B 7509                            jne .check_block_y
  2052 0000119D 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una X
  2053 000011A4 EB69                            jmp .end
  2054                                  
  2055                                      .check_block_y:
  2056                                          ; Verificar colisión con bloques en Y
  2057 000011A6 4150                            push r8     ; Guardar registros que usa check_block_collision
  2058 000011A8 4151                            push r9
  2059 000011AA 4152                            push r10
  2060 000011AC E8D5060000                      call check_block_collision
  2061 000011B1 415A                            pop r10
  2062 000011B3 4159                            pop r9
  2063 000011B5 4158                            pop r8
  2064 000011B7 4885C0                          test rax, rax
  2065 000011BA 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  2066 000011BC 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Si hay colisión, rebotar
  2067 000011C3 EB4A                            jmp .end
  2068                                  
  2069                                      .check_paddle_y:
  2070                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  2071 000011C5 41803A3D                        cmp byte [r10], char_equal
  2072 000011C9 7536                            jne .update_position
  2073                                  
  2074                                          ; Verificar si el poder catch está activo
  2075 000011CB 803D(58180000)01                cmp byte [catch_power_active], 1
  2076 000011D2 7524                            jne .normal_bounce
  2077                                  
  2078                                          ; Activar el modo "atrapado"
  2079 000011D4 C605(5B180000)01                mov byte [ball_caught_3], 1
  2080                                          
  2081                                          ; Guardar la posición X actual de la bola como offset
  2082 000011DB 488B05(A3140000)                mov rax, [ball3_x_pos]           ; Posición X actual de la bola
  2083 000011E2 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  2084 000011E9 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  2085 000011EF 488905(5C180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  2086                                          
  2087 000011F6 EB17                            jmp .end
  2088                                  
  2089                                      .normal_bounce:
  2090 000011F8 48F71D(BB140000)                neg qword [ball3_direction_y]  ; Cambiar dirección Y si hay una paleta
  2091 000011FF EB0E                            jmp .end
  2092                                  
  2093                                  
  2094                                      .update_position:
  2095 00001201 4C8905(A3140000)                mov [ball3_x_pos], r8
  2096 00001208 4C890D(AB140000)                mov [ball3_y_pos], r9
  2097                                  
  2098                                      .end:
  2099 0000120F C3                              ret
  2100                                  
  2101                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  2102                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  2103                                  process_catch_release:
  2104 00001210 55                          push rbp
  2105 00001211 4889E5                      mov  rbp, rsp
  2106                                  
  2107                                      ; Verificar si el poder está activo
  2108 00001214 803D(58180000)01            cmp byte [catch_power_active], 1
  2109 0000121B 0F8586000000                jne .no_catch_power
  2110                                  
  2111                                      ; Verificar si se presionó 'c'
  2112 00001221 803D(64180000)63            cmp byte [last_key], 'c'
  2113 00001228 757D                        jne .no_catch_power
  2114                                  
  2115                                      ; Ahora revisamos bola 1
  2116 0000122A 803D(59180000)01            cmp byte [ball_caught], 1
  2117 00001231 751F                        jne .check_ball2
  2118                                      ; Suelta la bola 1
  2119 00001233 C605(59180000)00            mov byte [ball_caught], 0
  2120 0000123A 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  2120 00001242 000000             
  2121 00001245 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  2121 0000124D FFFFFF             
  2122 00001250 EB4E                        jmp .finish
  2123                                  
  2124                                  .check_ball2:
  2125 00001252 803D(5A180000)01            cmp byte [ball_caught_2], 1
  2126 00001259 751F                        jne .check_ball3
  2127                                      ; Suelta la bola 2
  2128 0000125B C605(5A180000)00            mov byte [ball_caught_2], 0
  2129 00001262 48C705(91140000)01-         mov qword [ball2_direction_x], 1
  2129 0000126A 000000             
  2130 0000126D 48C705(99140000)FF-         mov qword [ball2_direction_y], -1
  2130 00001275 FFFFFF             
  2131 00001278 EB26                        jmp .finish
  2132                                  
  2133                                  .check_ball3:
  2134 0000127A 803D(5B180000)01            cmp byte [ball_caught_3], 1
  2135 00001281 751D                        jne .finish
  2136                                      ; Suelta la bola 3
  2137 00001283 C605(5B180000)00            mov byte [ball_caught_3], 0
  2138 0000128A 48C705(B3140000)01-         mov qword [ball3_direction_x], 1
  2138 00001292 000000             
  2139 00001295 48C705(BB140000)FF-         mov qword [ball3_direction_y], -1
  2139 0000129D FFFFFF             
  2140                                  
  2141                                  .finish:
  2142                                      ; Limpiar la tecla
  2143 000012A0 C605(64180000)00            mov byte [last_key], 0
  2144                                  
  2145                                  .no_catch_power:
  2146 000012A7 5D                          pop rbp
  2147 000012A8 C3                          ret
  2148                                  
  2149                                  
  2150                                  
  2151                                  display_level_number:
  2152 000012A9 55                          push rbp
  2153 000012AA 4889E5                      mov rbp, rsp
  2154                                      
  2155                                      ; Limpiar la pantalla primero
  2156                                      print clear, clear_length
    82 000012AD B801000000          <1>  mov eax, sys_write
    83 000012B2 BF01000000          <1>  mov edi, 1
    84 000012B7 48BE-               <1>  mov rsi, %1
    84 000012B9 [1000000000000000]  <1>
    85 000012C1 BA07000000          <1>  mov edx, %2
    86 000012C6 0F05                <1>  syscall
  2157                                      
  2158                                      ; Calcular la posición central para el mensaje
  2159                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  2160 000012C8 B84E000000                  mov rax, column_cells
  2161 000012CD 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  2162 000012D1 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  2163                                      
  2164                                      ; Calcular la fila central
  2165 000012D4 BB20000000                  mov rbx, row_cells
  2166 000012D9 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  2167                                      
  2168                                      ; Calcular el offset en el buffer
  2169 000012DC B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  2170 000012E1 48F7E3                      mul rbx                     ; multiplicar por la fila central
  2171 000012E4 4801D8                      add rax, rbx                ; añadir el offset horizontal
  2172                                      
  2173                                      ; Escribir "NIVEL " en la posición calculada
  2174 000012E7 488DB8[000A0000]            lea rdi, [board + rax]
  2175 000012EE 48BE-                       mov rsi, level_msg
  2175 000012F0 [2414000000000000] 
  2176 000012F8 B906000000                  mov rcx, level_msg_len
  2177 000012FD F3A4                        rep movsb
  2178                                      
  2179                                      ; Escribir el número del nivel
  2180 000012FF 8A05(F9140000)              mov al, [current_level]
  2181 00001305 0430                        add al, '0'                 ; convertir a ASCII
  2182 00001307 8807                        mov [rdi], al
  2183                                      
  2184                                      ; Mostrar el board con el mensaje
  2185                                      print board, board_size
    82 00001309 B801000000          <1>  mov eax, sys_write
    83 0000130E BF01000000          <1>  mov edi, 1
    84 00001313 48BE-               <1>  mov rsi, %1
    84 00001315 [000A000000000000]  <1>
    85 0000131D BA000A0000          <1>  mov edx, %2
    86 00001322 0F05                <1>  syscall
  2186                                      
  2187                                      ; Esperar un segundo
  2188 00001324 B823000000                  mov rax, sys_nanosleep
  2189 00001329 48BF-                       mov rdi, level_display_time
  2189 0000132B [2F14000000000000] 
  2190 00001333 4831F6                      xor rsi, rsi
  2191 00001336 0F05                        syscall
  2192                                      
  2193 00001338 5D                          pop rbp
  2194 00001339 C3                          ret
  2195                                  
  2196                                  ; Función para inicializar un tablero vacío
  2197                                  init_empty_board:
  2198 0000133A 56                          push rsi
  2199 0000133B 57                          push rdi
  2200 0000133C 51                          push rcx
  2201 0000133D 50                          push rax
  2202                                  
  2203 0000133E 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  2204 00001345 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  2205 0000134C B9000A0000                  mov rcx, board_template_size
  2206 00001351 F3A4                        rep movsb                   ; Copiar el tablero
  2207                                  
  2208 00001353 58                          pop rax
  2209 00001354 59                          pop rcx
  2210 00001355 5F                          pop rdi
  2211 00001356 5E                          pop rsi
  2212 00001357 C3                          ret
  2213                                  
  2214                                  
  2215                                  init_level:
  2216 00001358 C605(65180000)00            mov byte [laser_power_active], 0
  2217 0000135F E824F4FFFF                  call clear_lasers
  2218 00001364 488B05(4F140000)            mov rax, [default_pallet_size]
  2219 0000136B 488905(47140000)            mov [pallet_size], rax
  2220 00001372 48C705(40180000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  2220 0000137A 000000             
  2221                                  
  2222                                      ; 1) Copiamos board_template en board para que quede "virgen"
  2223                                          ; Reiniciar letras activas
  2224 0000137D 488D3D(99160000)            lea rdi, [letters_map]
  2225 00001384 B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  2226 00001389 4831C0                      xor rax, rax
  2227 0000138C F3AA                        rep stosb                    ; Llenar con ceros
  2228                                      
  2229                                      ; Inicializar dirección de la bola (derecha y arriba)
  2230 0000138E 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  2230 00001396 000000             
  2231 00001399 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  2231 000013A1 FFFFFF             
  2232                                  
  2233                                  
  2234                                      ; Reiniciar contador de letras activas
  2235 000013A4 4831C0                      xor rax, rax
  2236 000013A7 8805(29180000)              mov [letters_count], al
  2237                                  
  2238                                      ; Reiniciar última letra capturada
  2239 000013AD C605(2A180000)20            mov byte [last_letter], ' '
  2240 000013B4 C605(A3150000)00            mov byte [destroyed_blocks], 0 
  2241 000013BB E87AFFFFFF                  call init_empty_board
  2242 000013C0 E8E4FEFFFF                  call display_level_number
  2243 000013C5 E8E5050000                  call init_enemies
  2244                                      
  2245 000013CA 56                          push rsi
  2246 000013CB 57                          push rdi
  2247 000013CC 51                          push rcx
  2248 000013CD 50                          push rax
  2249                                  
  2250 000013CE 488D35(00000000)            lea rsi, [board_template]
  2251 000013D5 488D3D(000A0000)            lea rdi, [board]
  2252 000013DC B9000A0000                  mov rcx, board_template_size
  2253 000013E1 F3A4                        rep movsb                 ; Copiamos la plantilla a board
  2254                                  
  2255 000013E3 58                          pop rax
  2256 000013E4 59                          pop rcx
  2257 000013E5 5F                          pop rdi
  2258 000013E6 5E                          pop rsi
  2259                                  
  2260 000013E7 B90A000000                  mov rcx, 10
  2261 000013EC 4831C0                      xor rax, rax
  2262 000013EF 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2263 000013F6 F3AA                        rep stosb      
  2264                                  
  2265                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  2266 000013F8 803D(F9140000)01            cmp byte [current_level], 1
  2267 000013FF 7431                        je .level1
  2268 00001401 803D(F9140000)02            cmp byte [current_level], 2
  2269 00001408 7454                        je .level2
  2270 0000140A 803D(F9140000)03            cmp byte [current_level], 3
  2271 00001411 7477                        je .level3
  2272 00001413 803D(F9140000)04            cmp byte [current_level], 4
  2273 0000141A 0F8492000000                je .level4
  2274 00001420 803D(F9140000)05            cmp byte [current_level], 5
  2275 00001427 0F84AD000000                je .level5
  2276 0000142D E9D0000000                  jmp .done
  2277                                  
  2278                                  
  2279                                  
  2280                                      .level1:
  2281 00001432 C605(FA140000)08                mov byte [blocks_remaining], level1_blocks_count
  2282 00001439 4831C9                          xor rcx, rcx             
  2283                                          .init_loop1:
  2284 0000143C 4883F908                            cmp rcx, level1_blocks_count
  2285 00001440 0F8DBC000000                        jge .done
  2286 00001446 4889C8                              mov rax, rcx         
  2287 00001449 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2288 0000144D 8A90[FE140000]                      mov dl, byte [level1_blocks + rax + 3]  
  2289 00001453 8891[37150000]                      mov byte [block_states + rcx], dl
  2290 00001459 48FFC1                              inc rcx
  2291 0000145C EBDE                                jmp .init_loop1
  2292                                  
  2293                                      .level2:
  2294 0000145E C605(FA140000)01                mov byte [blocks_remaining], level2_blocks_count
  2295 00001465 4831C9                          xor rcx, rcx             
  2296                                          .init_loop2:
  2297 00001468 4883F901                            cmp rcx, level2_blocks_count
  2298 0000146C 0F8D90000000                        jge .done
  2299 00001472 4889C8                              mov rax, rcx         
  2300 00001475 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2301 00001479 8A90[26150000]                      mov dl, byte [level2_blocks + rax + 3]  
  2302 0000147F 8891[37150000]                      mov byte [block_states + rcx], dl
  2303 00001485 48FFC1                              inc rcx
  2304 00001488 EBDE                                jmp .init_loop2
  2305                                      .level3:
  2306 0000148A C605(FA140000)01                mov byte [blocks_remaining], level3_blocks_count
  2307 00001491 4831C9                          xor rcx, rcx             
  2308                                          .init_loop3:
  2309 00001494 4883F901                            cmp rcx, level3_blocks_count
  2310 00001498 7D68                                jge .done
  2311 0000149A 4889C8                              mov rax, rcx         
  2312 0000149D 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2313 000014A1 8A90[2B150000]                      mov dl, byte [level3_blocks + rax + 3]  
  2314 000014A7 8891[37150000]                      mov byte [block_states + rcx], dl
  2315 000014AD 48FFC1                              inc rcx
  2316 000014B0 EBE2                                jmp .init_loop3
  2317                                  
  2318                                      .level4:
  2319 000014B2 C605(FA140000)01                mov byte [blocks_remaining], level4_blocks_count
  2320 000014B9 4831C9                          xor rcx, rcx             
  2321                                          .init_loop4:
  2322 000014BC 4883F901                            cmp rcx, level4_blocks_count
  2323 000014C0 7D40                                jge .done
  2324 000014C2 4889C8                              mov rax, rcx         
  2325 000014C5 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2326 000014C9 8A90[30150000]                      mov dl, byte [level4_blocks + rax + 3]  
  2327 000014CF 8891[37150000]                      mov byte [block_states + rcx], dl
  2328 000014D5 48FFC1                              inc rcx
  2329 000014D8 EBE2                                jmp .init_loop4
  2330                                  
  2331                                      .level5:
  2332 000014DA C605(FA140000)01                mov byte [blocks_remaining], level5_blocks_count
  2333 000014E1 4831C9                          xor rcx, rcx             
  2334                                          .init_loop5:
  2335 000014E4 4883F901                            cmp rcx, level5_blocks_count
  2336 000014E8 7D18                                jge .done
  2337 000014EA 4889C8                              mov rax, rcx         
  2338 000014ED 486BC005                            imul rax, 5         ; en vez de shl rax,2
  2339 000014F1 8A90[35150000]                      mov dl, byte [level5_blocks + rax + 3]  
  2340 000014F7 8891[37150000]                      mov byte [block_states + rcx], dl
  2341 000014FD 48FFC1                              inc rcx
  2342 00001500 EBE2                                jmp .init_loop5
  2343                                      .done:
  2344 00001502 C3                              ret
  2345                                  
  2346                                  
  2347                                  ; Función para verificar y manejar la transición de nivel
  2348                                  check_level_complete:
  2349                                      ; Verificar si quedan bloques
  2350 00001503 803D(FA140000)00            cmp byte [blocks_remaining], 0
  2351 0000150A 753C                        jne .not_complete
  2352                                      
  2353                                      ; Incrementar el nivel
  2354 0000150C FE05(F9140000)              inc byte [current_level]
  2355                                      
  2356                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  2357 00001512 803D(F9140000)06            cmp byte [current_level], 6
  2358 00001519 742E                        je game_win
  2359                                      
  2360                                      ; Reinicializar el juego para el siguiente nivel
  2361 0000151B E838FEFFFF                  call init_level
  2362                                      
  2363                                      ; Reinicializar la posición de la bola y la paleta
  2364 00001520 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  2364 00001528 000000             
  2365 0000152B 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  2365 00001533 000000             
  2366 00001536 C605(7F140000)00            mov byte [ball_moving], 0
  2367 0000153D 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  2367 00001544 [36130000]         
  2368                                      
  2369                                      .not_complete:
  2370 00001548 C3                              ret
  2371                                  
  2372                                      ; Nueva función para manejar la victoria del juego
  2373                                  game_win:
  2374                                      ; Limpiar la pantalla primero
  2375                                      print clear, clear_length
    82 00001549 B801000000          <1>  mov eax, sys_write
    83 0000154E BF01000000          <1>  mov edi, 1
    84 00001553 48BE-               <1>  mov rsi, %1
    84 00001555 [1000000000000000]  <1>
    85 0000155D BA07000000          <1>  mov edx, %2
    86 00001562 0F05                <1>  syscall
  2376                                      
  2377                                      ; Mensaje de victoria
  2378 00001564 488B05(9B150000)            mov rax, [current_score]    ; Obtener el puntaje final
  2379 0000156B 48BF-                       mov rdi, number_buffer      ; Convertir a string
  2379 0000156D [A415000000000000] 
  2380 00001575 E8B4010000                  call number_to_string
  2381                                      
  2382                                      ; Definir mensaje de victoria
  2383                                      section .data
  2384 000019AC C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  2384 000019B5 616465732120C2A148-
  2384 000019BE 61732067616E61646F-
  2384 000019C7 210A0D             
  2385                                          win_msg_len: equ $ - win_msg
  2386 000019CA 50756E74616A652066-             score_msg: db "Puntaje final: "
  2386 000019D3 696E616C3A20       
  2387                                          score_msg_len: equ $ - score_msg
  2388                                      section .text
  2389                                      
  2390                                      ; Imprimir mensajes
  2391                                      print win_msg, win_msg_len
    82 0000157A B801000000          <1>  mov eax, sys_write
    83 0000157F BF01000000          <1>  mov edi, 1
    84 00001584 48BE-               <1>  mov rsi, %1
    84 00001586 [AC19000000000000]  <1>
    85 0000158E BA1E000000          <1>  mov edx, %2
    86 00001593 0F05                <1>  syscall
  2392                                      print score_msg, score_msg_len
    82 00001595 B801000000          <1>  mov eax, sys_write
    83 0000159A BF01000000          <1>  mov edi, 1
    84 0000159F 48BE-               <1>  mov rsi, %1
    84 000015A1 [CA19000000000000]  <1>
    85 000015A9 BA0F000000          <1>  mov edx, %2
    86 000015AE 0F05                <1>  syscall
  2393                                      print number_buffer, 20
    82 000015B0 B801000000          <1>  mov eax, sys_write
    83 000015B5 BF01000000          <1>  mov edi, 1
    84 000015BA 48BE-               <1>  mov rsi, %1
    84 000015BC [A415000000000000]  <1>
    85 000015C4 BA14000000          <1>  mov edx, %2
    86 000015C9 0F05                <1>  syscall
  2394                                      
  2395                                      ; Esperar un momento antes de salir
  2396 000015CB 48C7052AEAFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  2396 000015D4 0000               
  2397 000015D6 48C70527EAFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  2397 000015DF 0000               
  2398                                      sleeptime
    98 000015E1 B823000000          <1>  mov eax, sys_nanosleep
    99 000015E6 48BF-               <1>  mov rdi, timespec
    99 000015E8 [0000000000000000]  <1>
   100 000015F0 31F6                <1>  xor esi, esi
   101 000015F2 0F05                <1>  syscall
  2399                                      
  2400 000015F4 E976090000                  jmp exit
  2401                                  
  2402                                  ; Función para imprimir los bloques
  2403                                  ; Función modificada para imprimir bloques
  2404                                  
  2405                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  2406                                  get_current_level_blocks:
  2407 000015F9 803D(F9140000)01            cmp byte [current_level], 1
  2408 00001600 7428                        je .level1
  2409 00001602 803D(F9140000)02            cmp byte [current_level], 2
  2410 00001609 7427                        je .level2
  2411 0000160B 803D(F9140000)03            cmp byte [current_level], 3
  2412 00001612 7426                        je .level3
  2413 00001614 803D(F9140000)04            cmp byte [current_level], 4
  2414 0000161B 7425                        je .level4
  2415 0000161D 803D(F9140000)05            cmp byte [current_level], 5
  2416 00001624 7424                        je .level5
  2417                                      ; Si llegamos aquí, hay un error en el nivel
  2418 00001626 4831C0                      xor rax, rax
  2419 00001629 C3                          ret
  2420                                  
  2421                                      .level1:
  2422 0000162A 488D05(FB140000)                lea rax, [level1_blocks]
  2423 00001631 C3                              ret
  2424                                      .level2:
  2425 00001632 488D05(23150000)                lea rax, [level2_blocks]
  2426 00001639 C3                              ret
  2427                                      .level3:
  2428 0000163A 488D05(28150000)                lea rax, [level3_blocks]
  2429 00001641 C3                              ret
  2430                                      .level4:
  2431 00001642 488D05(2D150000)                lea rax, [level4_blocks]
  2432 00001649 C3                              ret
  2433                                      .level5:
  2434 0000164A 488D05(32150000)                lea rax, [level5_blocks]
  2435 00001651 C3                              ret
  2436                                  ; Función para obtener la cantidad de bloques del nivel actual
  2437                                  get_current_level_count:
  2438 00001652 803D(F9140000)01            cmp byte [current_level], 1
  2439 00001659 7428                        je .level1
  2440 0000165B 803D(F9140000)02            cmp byte [current_level], 2
  2441 00001662 7425                        je .level2
  2442 00001664 803D(F9140000)03            cmp byte [current_level], 3
  2443 0000166B 7422                        je .level3
  2444 0000166D 803D(F9140000)04            cmp byte [current_level], 4
  2445 00001674 741F                        je .level4
  2446 00001676 803D(F9140000)05            cmp byte [current_level], 5
  2447 0000167D 741C                        je .level5
  2448                                      ; Si llegamos aquí, hay un error en el nivel
  2449 0000167F 4831C0                      xor rax, rax
  2450 00001682 C3                          ret
  2451                                  
  2452                                      .level1:
  2453 00001683 B808000000                      mov rax, level1_blocks_count
  2454 00001688 C3                              ret
  2455                                      .level2:
  2456 00001689 B801000000                      mov rax, level2_blocks_count
  2457 0000168E C3                              ret
  2458                                      .level3:
  2459 0000168F B801000000                      mov rax, level3_blocks_count
  2460 00001694 C3                              ret
  2461                                      .level4:
  2462 00001695 B801000000                      mov rax, level4_blocks_count
  2463 0000169A C3                              ret
  2464                                      .level5:
  2465 0000169B B801000000                      mov rax, level5_blocks_count
  2466 000016A0 C3                              ret
  2467                                  
  2468                                  
  2469                                  print_blocks:
  2470 000016A1 55                          push rbp
  2471 000016A2 4889E5                      mov rbp, rsp
  2472                                      
  2473                                      ; Obtener puntero a los bloques del nivel actual
  2474 000016A5 E84FFFFFFF                  call get_current_level_blocks
  2475 000016AA 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  2476                                      
  2477                                      ; Obtener cantidad de bloques del nivel actual
  2478 000016AD E8A0FFFFFF                  call get_current_level_count
  2479 000016B2 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  2480                                      
  2481 000016B5 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  2482                                      
  2483                                      .print_loop:
  2484 000016B8 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  2485 000016BB 7D6F                            jge .end
  2486                                          
  2487                                          ; Verificar si el bloque está activo
  2488 000016BD 490FB68424-                     movzx rax, byte [block_states + r12]
  2488 000016C2 [37150000]         
  2489 000016C6 4885C0                          test rax, rax
  2490 000016C9 745C                            jz .next_block
  2491                                          
  2492                                          ; Obtener posición y tipo del bloque usando r13
  2493 000016CB 4C89E0                          mov rax, r12
  2494 000016CE 486BC005                        imul rax, 5
  2495 000016D2 4C01E8                          add rax, r13
  2496 000016D5 448A00                          mov r8b, [rax]        ; X position
  2497 000016D8 448A4801                        mov r9b, [rax + 1]    ; Y position
  2498 000016DC 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  2499                                  
  2500                                          ; El resto de la lógica de impresión permanece igual
  2501 000016E0 4D0FB6C0                        movzx r8, r8b
  2502 000016E4 4D0FB6C9                        movzx r9, r9b
  2503 000016E8 4981C0[000A0000]                add r8, board
  2504 000016EF B850000000                      mov rax, column_cells + 2
  2505 000016F4 49F7E1                          mul r9
  2506 000016F7 4901C0                          add r8, rax
  2507                                          
  2508 000016FA B906000000                      mov rcx, block_length
  2509 000016FF 48BE-                           mov rsi, block_type_1
  2509 00001701 [D514000000000000] 
  2510 00001709 490FB6C2                        movzx rax, r10b
  2511 0000170D 48FFC8                          dec rax
  2512 00001710 486BC006                        imul rax, block_length
  2513 00001714 4801C6                          add rsi, rax
  2514                                          
  2515                                      .print_block_chars:
  2516 00001717 8A06                            mov al, [rsi]
  2517 00001719 418800                          mov [r8], al
  2518 0000171C 48FFC6                          inc rsi
  2519 0000171F 49FFC0                          inc r8
  2520 00001722 48FFC9                          dec rcx
  2521 00001725 75F0                            jnz .print_block_chars
  2522                                          
  2523                                      .next_block:
  2524 00001727 49FFC4                          inc r12
  2525 0000172A EB8C                            jmp .print_loop
  2526                                          
  2527                                      .end:
  2528 0000172C 5D                              pop rbp
  2529 0000172D C3                              ret
  2530                                  
  2531                                  ; Función para convertir número a string
  2532                                  ; Input: RAX = número a convertir
  2533                                  ; RDI = buffer donde escribir el string
  2534                                  number_to_string:
  2535 0000172E 53                          push rbx
  2536 0000172F 52                          push rdx
  2537 00001730 56                          push rsi
  2538 00001731 BB0A000000                  mov rbx, 10          ; Divisor
  2539 00001736 B900000000                  mov rcx, 0          ; Contador de dígitos
  2540                                      
  2541                                      ; Si el número es 0, manejarlo especialmente
  2542 0000173B 4885C0                      test rax, rax
  2543 0000173E 7509                        jnz .convert_loop
  2544 00001740 C60730                      mov byte [rdi], '0'
  2545 00001743 C6470100                    mov byte [rdi + 1], 0
  2546 00001747 EB20                        jmp .end
  2547                                      
  2548                                      .convert_loop:
  2549 00001749 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  2550 0000174C 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  2551 0000174F 80C230                          add dl, '0'     ; Convertir a ASCII
  2552 00001752 52                              push rdx        ; Guardar el dígito
  2553 00001753 48FFC1                          inc rcx         ; Incrementar contador
  2554 00001756 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  2555 00001759 75EE                            jnz .convert_loop
  2556                                          
  2557                                      .write_loop:
  2558 0000175B 5A                              pop rdx         ; Obtener dígito
  2559 0000175C 8817                            mov [rdi], dl   ; Escribir al buffer
  2560 0000175E 48FFC7                          inc rdi         ; Siguiente posición
  2561 00001761 48FFC9                          dec rcx         ; Decrementar contador
  2562 00001764 75F5                            jnz .write_loop
  2563                                          
  2564 00001766 C60700                      mov byte [rdi], 0   ; Null terminator
  2565                                      
  2566                                      .end:
  2567 00001769 5E                          pop rsi
  2568 0000176A 5A                          pop rdx
  2569 0000176B 5B                          pop rbx
  2570 0000176C C3                          ret
  2571                                  
  2572                                  ; Función para imprimir los labels
  2573                                  print_labels:
  2574 0000176D 55                          push rbp
  2575 0000176E 4889E5                      mov rbp, rsp
  2576                                  
  2577                                      ; Crear buffer temporal
  2578 00001771 4883EC20                    sub rsp, 32
  2579                                  
  2580                                      ; Copiar labels a buffer temporal
  2581 00001775 4889E7                      mov rdi, rsp
  2582 00001778 488D35(50160000)            lea rsi, [score_label]
  2583 0000177F B917000000                  mov rcx, score_label_len
  2584 00001784 F3A4                        rep movsb
  2585                                  
  2586                                      ; Convertir score a string
  2587 00001786 488B05(9B150000)            mov rax, [current_score]
  2588 0000178D 48BF-                       mov rdi, number_buffer
  2588 0000178F [A415000000000000] 
  2589 00001797 E892FFFFFF                  call number_to_string
  2590                                  
  2591                                      ; Calcular longitud del número
  2592 0000179C B900000000                  mov rcx, 0
  2593 000017A1 48BF-                       mov rdi, number_buffer
  2593 000017A3 [A415000000000000] 
  2594                                      .count_loop:
  2595 000017AB 803C0F00                        cmp byte [rdi + rcx], 0
  2596 000017AF 7405                            je .count_done
  2597 000017B1 48FFC1                          inc rcx
  2598 000017B4 EBF5                            jmp .count_loop
  2599                                      .count_done:
  2600                                  
  2601                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2602 000017B6 4889E7                      mov rdi, rsp
  2603 000017B9 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2604 000017BD BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2605 000017C2 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2606                                      .pad_loop:
  2607 000017C5 4885F6                          test rsi, rsi
  2608 000017C8 740B                            jz .pad_done
  2609 000017CA C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2610 000017CD 48FFC7                          inc rdi
  2611 000017D0 48FFCE                          dec rsi
  2612 000017D3 EBF0                            jmp .pad_loop
  2613                                      .pad_done:
  2614                                  
  2615                                      ; Copiar el número
  2616 000017D5 48BE-                       mov rsi, number_buffer
  2616 000017D7 [A415000000000000] 
  2617 000017DF F3A4                        rep movsb
  2618                                  
  2619                                      ; Imprimir el buffer completo
  2620                                      print rsp, score_label_len
    82 000017E1 B801000000          <1>  mov eax, sys_write
    83 000017E6 BF01000000          <1>  mov edi, 1
    84 000017EB 4889E6              <1>  mov rsi, %1
    85 000017EE BA17000000          <1>  mov edx, %2
    86 000017F3 0F05                <1>  syscall
  2621                                  
  2622                                      ; Repetir proceso para bloques destruidos
  2623 000017F5 4889E7                      mov rdi, rsp
  2624 000017F8 488D35(67160000)            lea rsi, [blocks_label]
  2625 000017FF B91B000000                  mov rcx, blocks_label_len
  2626 00001804 F3A4                        rep movsb
  2627                                  
  2628                                      ; Verificar que el `[` esté en su posición correcta
  2629 00001806 4889E7                      mov rdi, rsp
  2630 00001809 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2631 0000180D C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2632                                  
  2633                                      ; Convertir bloques destruidos a string
  2634 00001810 480FB605(A3150000)          movzx rax, byte [destroyed_blocks]
  2635 00001818 48BF-                       mov rdi, number_buffer
  2635 0000181A [A415000000000000] 
  2636 00001822 E807FFFFFF                  call number_to_string
  2637                                  
  2638                                      ; Calcular longitud del número
  2639 00001827 B900000000                  mov rcx, 0
  2640 0000182C 48BF-                       mov rdi, number_buffer
  2640 0000182E [A415000000000000] 
  2641                                      .count_loop2:
  2642 00001836 803C0F00                        cmp byte [rdi + rcx], 0
  2643 0000183A 7405                            je .count_done2
  2644 0000183C 48FFC1                          inc rcx
  2645 0000183F EBF5                            jmp .count_loop2
  2646                                      .count_done2:
  2647                                  
  2648                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2649 00001841 4889E7                      mov rdi, rsp
  2650 00001844 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2651 00001848 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2652 0000184D 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2653                                      .pad_loop2:
  2654 00001850 4885F6                          test rsi, rsi
  2655 00001853 740B                            jz .pad_done2
  2656 00001855 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2657 00001858 48FFC7                          inc rdi
  2658 0000185B 48FFCE                          dec rsi
  2659 0000185E EBF0                            jmp .pad_loop2
  2660                                      .pad_done2:
  2661                                  
  2662                                      ; Copiar el número
  2663 00001860 48BE-                       mov rsi, number_buffer
  2663 00001862 [A415000000000000] 
  2664 0000186A F3A4                        rep movsb
  2665                                  
  2666                                      ; Imprimir el buffer completo
  2667                                      print rsp, blocks_label_len
    82 0000186C B801000000          <1>  mov eax, sys_write
    83 00001871 BF01000000          <1>  mov edi, 1
    84 00001876 4889E6              <1>  mov rsi, %1
    85 00001879 BA1B000000          <1>  mov edx, %2
    86 0000187E 0F05                <1>  syscall
  2668                                  
  2669                                      ; Restaurar stack
  2670 00001880 4883C420                    add rsp, 32
  2671 00001884 5D                          pop rbp
  2672 00001885 C3                          ret
  2673                                  
  2674                                  
  2675                                  
  2676                                  check_block_collision:
  2677 00001886 55                          push rbp
  2678 00001887 4889E5                      mov rbp, rsp
  2679                                  
  2680                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2681 0000188A 418A02                      mov al, [r10]
  2682                                  
  2683                                      ; Verificar si el carácter es un bloque
  2684 0000188D 3C55                        cmp al, 'U'  
  2685 0000188F 7419                        je .possible
  2686 00001891 3C4F                        cmp al, 'O'  
  2687 00001893 7415                        je .possible
  2688 00001895 3C44                        cmp al, 'D'  
  2689 00001897 7411                        je .possible
  2690 00001899 3C4C                        cmp al, 'L'  
  2691 0000189B 740D                        je .possible
  2692 0000189D 3C56                        cmp al, 'V'  
  2693 0000189F 7409                        je .possible
  2694 000018A1 3C38                        cmp al, '8'  
  2695 000018A3 7405                        je .possible
  2696                                  
  2697                                      ; No es bloque, salir
  2698 000018A5 4831C0                      xor rax, rax
  2699 000018A8 5D                          pop rbp
  2700 000018A9 C3                          ret
  2701                                  
  2702                                  .possible:
  2703 000018AA 53                          push rbx
  2704 000018AB 57                          push rdi
  2705 000018AC 56                          push rsi
  2706 000018AD 4154                        push r12
  2707 000018AF 4155                        push r13
  2708 000018B1 4156                        push r14
  2709 000018B3 4157                        push r15
  2710                                  
  2711                                      ; 1) Obtener base de los bloques del nivel actual
  2712 000018B5 E83FFDFFFF                  call get_current_level_blocks
  2713 000018BA 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2714                                  
  2715                                      ; 2) Obtener la cantidad de bloques
  2716 000018BD E890FDFFFF                  call get_current_level_count
  2717 000018C2 4989C6                      mov r14, rax
  2718                                  
  2719 000018C5 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2720                                  
  2721                                  .find_block_loop:
  2722 000018C8 4D39F4                      cmp r12, r14
  2723 000018CB 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2724                                  
  2725                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2726 000018D1 4C89E0                      mov rax, r12
  2727 000018D4 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2728 000018D8 4C01E8                      add rax, r13
  2729 000018DB 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2730                                  
  2731                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2732 000018DE 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2732 000018E3 [37150000]         
  2733 000018E7 4885DB                      test rbx, rbx
  2734 000018EA 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2735                                  
  2736                                      ; Obtener coordenadas
  2737 000018F0 418A17                      mov dl, [r15]         ; x
  2738 000018F3 418A4F01                    mov cl, [r15 + 1]     ; y
  2739                                  
  2740                                      ; Calcular posición en el board
  2741 000018F7 488D3D(000A0000)            lea rdi, [board]
  2742 000018FE 4831C0                      xor rax, rax
  2743 00001901 B84E000000                  mov rax, column_cells
  2744 00001906 4883C002                    add rax, 2
  2745 0000190A 480FB6C9                    movzx rcx, cl         ; y
  2746 0000190E 480FAFC1                    imul rax, rcx
  2747 00001912 4801C7                      add rdi, rax
  2748 00001915 480FB6C2                    movzx rax, dl         ; x
  2749 00001919 4801C7                      add rdi, rax
  2750                                  
  2751                                      ; Guardar la posición base del bloque
  2752 0000191C 57                          push rdi
  2753                                  
  2754                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2755 0000191D 4939FA                      cmp r10, rdi
  2756 00001920 7274                        jb .skip_collision
  2757 00001922 488D5F06                    lea rbx, [rdi + block_length]
  2758 00001926 4939DA                      cmp r10, rbx
  2759 00001929 736B                        jae .skip_collision
  2760                                  
  2761                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2762 0000192B 41FE8C24[37150000]          dec byte [block_states + r12]
  2763                                      ; Volver a cargar durabilidad
  2764 00001933 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2764 00001938 [37150000]         
  2765 0000193C 4885DB                      test rbx, rbx
  2766 0000193F 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2767                                  
  2768                                      ; >>> Llegó a 0 => Bloque destruido
  2769 00001941 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2770 00001942 B906000000                  mov rcx, block_length
  2771                                  .clear_loop:
  2772 00001947 C60720                      mov byte [rdi], ' '
  2773 0000194A 48FFC7                      inc rdi
  2774 0000194D E2F8                        loop .clear_loop
  2775                                  
  2776                                      ; Dibujar letra del bloque destruido
  2777 0000194F 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2778 00001953 4883EF06                    sub rdi, block_length
  2779 00001957 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2780                                      ; Después de escribir la letra en el tablero
  2781 00001959 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2782 0000195D 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2783 00001961 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2784 00001966 E8FEEAFFFF                  call register_letter
  2785                                      ; Actualizar contadores globales
  2786 0000196B FE0D(FA140000)              dec byte [blocks_remaining]
  2787 00001971 FE05(A3150000)              inc byte [destroyed_blocks]
  2788                                  
  2789                                      ; Sumar puntos según el tipo
  2790 00001977 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2791 0000197C 486BC00A                    imul rax, 10
  2792 00001980 480105(9B150000)            add [current_score], rax
  2793                                  
  2794 00001987 B801000000                  mov rax, 1  ; colisión con destrucción
  2795 0000198C EB14                        jmp .end_pop
  2796                                  
  2797                                  .update_display:
  2798                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2799 0000198E B801000000                  mov rax, 1  ; colisión con "rebote"  
  2800 00001993 5F                          pop rdi     ; pop que quedó pendiente
  2801 00001994 EB0C                        jmp .end_pop
  2802                                  
  2803                                  .skip_collision:
  2804 00001996 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2805                                  .next_block:
  2806 00001997 49FFC4                      inc r12
  2807 0000199A E929FFFFFF                  jmp .find_block_loop
  2808                                  
  2809                                  .no_block_found:
  2810 0000199F 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2811                                  
  2812                                  .end_pop:
  2813 000019A2 415F                        pop r15
  2814 000019A4 415E                        pop r14
  2815 000019A6 415D                        pop r13
  2816 000019A8 415C                        pop r12
  2817 000019AA 5E                          pop rsi
  2818 000019AB 5F                          pop rdi
  2819 000019AC 5B                          pop rbx
  2820 000019AD 5D                          pop rbp
  2821 000019AE C3                          ret
  2822                                  
  2823                                  
  2824                                  
  2825                                  init_enemies:
  2826 000019AF 55                          push rbp
  2827 000019B0 4889E5                      mov rbp, rsp
  2828                                      ; Reiniciar contadores de movimiento
  2829 000019B3 C605(E6150000)00            mov byte [enemy_move_total], 0
  2830 000019BA C605(E7150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2831                                      ; Limpiar estado previo de enemigos
  2832 000019C1 B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2833 000019C6 488D3D(BD150000)            lea rdi, [enemies]
  2834 000019CD 30C0                        xor al, al
  2835 000019CF F3AA                        rep stosb ; Limpiar datos de enemigos
  2836                                      
  2837                                      ; Marcar todos los enemigos como inactivos
  2838 000019D1 488D3D(46160000)            lea rdi, [enemy_spawns_triggered]
  2839 000019D8 30C0                        xor al, al
  2840 000019DA B90A000000                  mov rcx, 10
  2841 000019DF F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2842                                  
  2843 000019E1 5D                          pop rbp
  2844 000019E2 C3                          ret
  2845                                  
  2846                                  
  2847                                  ; Función para mover enemigos
  2848                                  move_enemies:
  2849 000019E3 55                          push rbp
  2850 000019E4 4889E5                      mov rbp, rsp
  2851                                      
  2852                                      ; Incrementar contador de movimiento
  2853 000019E7 FE05(E4150000)              inc byte [enemy_move_counter]
  2854 000019ED 480FB605(E4150000)          movzx rax, byte [enemy_move_counter]
  2855 000019F5 3A05(E5150000)              cmp al, [enemy_move_delay]
  2856 000019FB 0F85AA010000                jne .end
  2857                                      
  2858                                      ; Resetear contador
  2859 00001A01 C605(E4150000)00            mov byte [enemy_move_counter], 0
  2860                                      
  2861 00001A08 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2862                                      
  2863                                      .enemy_loop:
  2864 00001A0B 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2865 00001A0F 0F8D96010000                    jge .end
  2866                                          
  2867                                          ; Calcular offset del enemigo actual
  2868 00001A15 4C89E0                          mov rax, r12
  2869 00001A18 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2870 00001A1C 488DB0[BD150000]                lea rsi, [enemies + rax]
  2871                                          
  2872                                          ; Verificar si el enemigo está activo
  2873 00001A23 807E0201                        cmp byte [rsi + 2], 1
  2874 00001A27 0F8576010000                    jne .next_enemy
  2875                                          
  2876                                          ; Obtener posición actual
  2877 00001A2D 4C0FB606                        movzx r8, byte [rsi]            ; X
  2878 00001A31 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2879                                          
  2880                                          ; Limpiar posición actual antes de mover
  2881 00001A36 4150                            push r8
  2882 00001A38 4151                            push r9
  2883 00001A3A B84E000000                      mov rax, column_cells
  2884 00001A3F 4883C002                        add rax, 2
  2885 00001A43 49F7E1                          mul r9
  2886 00001A46 4C01C0                          add rax, r8
  2887 00001A49 488DB8[000A0000]                lea rdi, [board + rax]
  2888 00001A50 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2889 00001A53 4159                            pop r9
  2890 00001A55 4158                            pop r8
  2891                                  
  2892                                          ; Determinar comportamiento basado en índice
  2893 00001A57 4C89E0                          mov rax, r12
  2894 00001A5A 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2895 00001A5E 4885C0                          test rax, rax
  2896 00001A61 7402                            jz .chase_ball
  2897 00001A63 EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2898                                          
  2899                                          ; Perseguir bola (comportamiento original)
  2900                                      .chase_ball:
  2901 00001A65 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2902 00001A6C 4D39D0                          cmp r8, r10
  2903 00001A6F 0F8F96000000                    jg .move_left
  2904 00001A75 0F8C95000000                    jl .move_right
  2905                                          
  2906 00001A7B 4C8B15(67140000)                mov r10, [ball_y_pos]
  2907 00001A82 4D39D1                          cmp r9, r10
  2908 00001A85 0F8F8A000000                    jg .move_up
  2909 00001A8B 0F8C89000000                    jl .move_down
  2910 00001A91 E9A5000000                      jmp .check_collision
  2911                                          
  2912                                      .chase_paddle:
  2913                                          ; Obtener la posición X actual de la paleta
  2914 00001A96 4C8B15(3F140000)                mov r10, [pallet_position]
  2915 00001A9D 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2916                                          
  2917                                          ; Calcular la posición X real de la paleta
  2918 00001AA4 4C89D0                          mov rax, r10
  2919 00001AA7 BB4E000000                      mov rbx, column_cells
  2920 00001AAC 4883C302                        add rbx, 2                  ; Añadir newline chars
  2921 00001AB0 4831D2                          xor rdx, rdx
  2922 00001AB3 48F7F3                          div rbx                     ; rax = y, rdx = x
  2923                                          
  2924                                          ; rdx ahora contiene la posición X de la paleta
  2925                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2926 00001AB6 488B0D(47140000)                mov rcx, [pallet_size]
  2927 00001ABD 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2928 00001AC0 4801CA                          add rdx, rcx
  2929                                          
  2930                                          ; Comparar con posición X del enemigo y mover gradualmente
  2931 00001AC3 4939D0                          cmp r8, rdx
  2932 00001AC6 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2933 00001AC8 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2934 00001ACA 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2935                                  
  2936                                      .check_y_paddle:
  2937                                          ; La Y de la paleta siempre es row_cells - 2
  2938 00001ACC 41BA20000000                    mov r10, row_cells
  2939 00001AD2 4983EA02                        sub r10, 2
  2940                                          
  2941                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2942 00001AD6 4D39D1                          cmp r9, r10
  2943 00001AD9 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2944 00001ADB 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2945 00001ADD 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2946                                          
  2947                                      .no_movement:
  2948 00001ADF EB5A                            jmp .check_collision
  2949                                  
  2950                                      ; También agregar una nueva sección para el movimiento suave
  2951                                      .smooth_transition:
  2952                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2953 00001AE1 8A05(E7150000)                  mov al, [enemy_target]
  2954 00001AE7 84C0                            test al, al
  2955 00001AE9 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2956                                          
  2957                                          ; Verificar distancia en X
  2958 00001AEB 4989D2                          mov r10, rdx              ; Posición X objetivo
  2959 00001AEE 4D29C2                          sub r10, r8               ; Calcular diferencia
  2960 00001AF1 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2961 00001AF5 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2962 00001AF7 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2963 00001AFB 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2964 00001AFD EB3C                            jmp .check_collision
  2965                                          
  2966                                      .limit_right_movement:
  2967 00001AFF 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2968 00001B03 EB36                            jmp .check_collision
  2969                                          
  2970                                      .limit_left_movement:
  2971 00001B05 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2972 00001B09 EB30                            jmp .check_collision
  2973                                      .move_left:
  2974 00001B0B 49FFC8                          dec r8
  2975 00001B0E EB0F                            jmp .check_vertical
  2976                                          
  2977                                      .move_right:
  2978 00001B10 49FFC0                          inc r8
  2979 00001B13 EB0A                            jmp .check_vertical
  2980                                          
  2981                                      .move_up:
  2982 00001B15 49FFC9                          dec r9
  2983 00001B18 EB21                            jmp .check_collision
  2984                                          
  2985                                      .move_down:
  2986 00001B1A 49FFC1                          inc r9
  2987 00001B1D EB1C                            jmp .check_collision
  2988                                          
  2989                                      .check_vertical:
  2990 00001B1F 8A05(E7150000)                  mov al, [enemy_target]
  2991 00001B25 84C0                            test al, al
  2992 00001B27 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2993 00001B2D 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2994 00001B34 4D39D1                          cmp r9, r10
  2995 00001B37 7FDC                            jg .move_up
  2996 00001B39 7CDF                            jl .move_down
  2997                                          
  2998                                      .check_collision:
  2999                                          ; Verificar colisión con bordes
  3000 00001B3B 4983F801                        cmp r8, 1                       ; Borde izquierdo
  3001 00001B3F 7E62                            jle .next_enemy
  3002 00001B41 4983F84E                        cmp r8, column_cells
  3003 00001B45 7D5C                            jge .next_enemy
  3004 00001B47 4983F901                        cmp r9, 1                       ; Borde superior
  3005 00001B4B 7E56                            jle .next_enemy
  3006 00001B4D 4983F920                        cmp r9, row_cells
  3007 00001B51 7D50                            jge .next_enemy
  3008                                          
  3009                                          ; Verificar colisión con bloques antes de moverse
  3010 00001B53 4150                            push r8
  3011 00001B55 4151                            push r9
  3012 00001B57 4152                            push r10
  3013                                          
  3014                                          ; Calcular posición en el tablero para verificar
  3015 00001B59 B84E000000                      mov rax, column_cells
  3016 00001B5E 4883C002                        add rax, 2
  3017 00001B62 49F7E1                          mul r9
  3018 00001B65 4C01C0                          add rax, r8
  3019 00001B68 4C8D90[000A0000]                lea r10, [board + rax]
  3020                                          
  3021                                          ; Verificar si hay un bloque en la nueva posición
  3022 00001B6F 418A02                          mov al, [r10]
  3023 00001B72 3C55                            cmp al, 'U'
  3024 00001B74 7427                            je .invalid_move
  3025 00001B76 3C4F                            cmp al, 'O'
  3026 00001B78 7423                            je .invalid_move
  3027 00001B7A 3C44                            cmp al, 'D'
  3028 00001B7C 741F                            je .invalid_move
  3029 00001B7E 3C4C                            cmp al, 'L'
  3030 00001B80 741B                            je .invalid_move
  3031 00001B82 3C56                            cmp al, 'V'
  3032 00001B84 7417                            je .invalid_move
  3033 00001B86 3C38                            cmp al, '8'
  3034 00001B88 7413                            je .invalid_move
  3035 00001B8A 3C58                            cmp al, 'X'
  3036 00001B8C 740F                            je .invalid_move
  3037                                          
  3038 00001B8E 415A                            pop r10
  3039 00001B90 4159                            pop r9
  3040 00001B92 4158                            pop r8
  3041                                          
  3042                                          ; Guardar nueva posición si es válida
  3043 00001B94 448806                          mov [rsi], r8b
  3044 00001B97 44884E01                        mov [rsi + 1], r9b
  3045 00001B9B EB06                            jmp .next_enemy
  3046                                          
  3047                                      .invalid_move:
  3048 00001B9D 415A                            pop r10
  3049 00001B9F 4159                            pop r9
  3050 00001BA1 4158                            pop r8
  3051                                          
  3052                                      .next_enemy:
  3053 00001BA3 49FFC4                          inc r12
  3054 00001BA6 E960FEFFFF                      jmp .enemy_loop
  3055                                          
  3056                                      .end:
  3057 00001BAB 5D                              pop rbp
  3058 00001BAC C3                              ret
  3059                                  
  3060                                  get_current_spawn_points:
  3061 00001BAD 55                          push rbp
  3062 00001BAE 4889E5                      mov rbp, rsp
  3063                                      
  3064 00001BB1 480FB605(F9140000)          movzx rax, byte [current_level]
  3065 00001BB9 48FFC8                      dec rax                         ; Ajustar para índice base 0
  3066 00001BBC 488B04C5[1B160000]          mov rax, [spawn_points_table + rax * 8]
  3067                                      
  3068 00001BC4 5D                          pop rbp
  3069 00001BC5 C3                          ret
  3070                                  
  3071                                  ; Función para verificar si debe aparecer un nuevo enemigo
  3072                                  check_enemy_spawn:
  3073 00001BC6 55                          push rbp
  3074 00001BC7 4889E5                      mov rbp, rsp
  3075                                      
  3076                                      ; Obtener spawn points del nivel actual
  3077 00001BCA E8DEFFFFFF                  call get_current_spawn_points
  3078 00001BCF 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  3079                                      
  3080                                      ; Obtener cantidad de bloques destruidos
  3081 00001BD2 4C0FB62D(A3150000)          movzx r13, byte [destroyed_blocks]
  3082                                      
  3083                                      ; Verificar cada punto de spawn
  3084 00001BDA 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  3085                                      
  3086                                      .check_loop:
  3087 00001BDD 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  3088 00001BE1 7D4E                            jge .end
  3089                                          
  3090                                          ; Verificar si este spawn point ya fue usado
  3091 00001BE3 80B9[46160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  3092 00001BEA 7440                            je .next_enemy
  3093                                          
  3094                                          ; Verificar si este enemigo ya está activo
  3095 00001BEC 4889C8                          mov rax, rcx
  3096 00001BEF 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3097 00001BF3 488DB0[BD150000]                lea rsi, [enemies + rax]
  3098 00001BFA 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  3099 00001BFE 742C                            je .next_enemy
  3100                                          
  3101                                          ; Verificar si debemos spawnear este enemigo
  3102 00001C00 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  3103 00001C05 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  3104 00001C08 7522                            jne .next_enemy
  3105                                          
  3106                                          ; Marcar este spawn point como usado
  3107 00001C0A C681[46160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  3108                                          
  3109                                          ; Spawner nuevo enemigo
  3110 00001C11 B004                            mov al, 4
  3111 00001C13 00C8                            add al, cl       ; con 'rcx' como índice
  3112 00001C15 8806                            mov [rsi], al
  3113 00001C17 C6460102                        mov byte [rsi+1], 2
  3114 00001C1B C6460201                        mov byte [rsi+2], 1
  3115                                  
  3116                                          ; Inicializar comportamiento
  3117 00001C1F 4889C8                          mov rax, rcx
  3118 00001C22 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  3119 00001C26 8805(45160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  3120                                          
  3121                                      .next_enemy:
  3122 00001C2C 48FFC1                          inc rcx
  3123 00001C2F EBAC                            jmp .check_loop
  3124                                          
  3125                                      .end:
  3126 00001C31 5D                              pop rbp
  3127 00001C32 C3                              ret
  3128                                  
  3129                                  
  3130                                  ; Función para dibujar enemigos
  3131                                  print_enemies:
  3132 00001C33 55                          push rbp
  3133 00001C34 4889E5                      mov rbp, rsp
  3134                                      
  3135 00001C37 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3136                                      
  3137                                      .print_loop:
  3138 00001C3A 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  3139 00001C3E 7D4B                            jge .end
  3140                                          
  3141                                          ; Calcular offset del enemigo actual
  3142 00001C40 4C89E0                          mov rax, r12
  3143 00001C43 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  3144 00001C47 488DB0[BD150000]                lea rsi, [enemies + rax]
  3145                                          
  3146                                          ; Verificar si el enemigo está activo
  3147 00001C4E 807E0201                        cmp byte [rsi + 2], 1
  3148 00001C52 7532                            jne .next_enemy
  3149                                          
  3150                                          ; Calcular posición en el tablero
  3151 00001C54 4C0FB606                        movzx r8, byte [rsi]            ; X
  3152 00001C58 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  3153                                          
  3154                                          ; Calcular offset en el tablero
  3155 00001C5D B84E000000                      mov rax, column_cells
  3156 00001C62 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  3157 00001C66 49F7E1                          mul r9
  3158 00001C69 4C01C0                          add rax, r8
  3159 00001C6C 488DB8[000A0000]                lea rdi, [board + rax]
  3160                                          
  3161                                          ; Obtener carácter del enemigo según el nivel
  3162 00001C73 480FB605(F9140000)              movzx rax, byte [current_level]
  3163 00001C7B 48FFC8                          dec rax                         ; Ajustar para índice base 0
  3164 00001C7E 8A80[B8150000]                  mov al, [enemy_chars + rax]
  3165                                          
  3166                                          ; Dibujar enemigo
  3167 00001C84 8807                            mov [rdi], al
  3168                                          
  3169                                      .next_enemy:
  3170 00001C86 49FFC4                          inc r12
  3171 00001C89 EBAF                            jmp .print_loop
  3172                                          
  3173                                      .end:
  3174 00001C8B 5D                              pop rbp
  3175 00001C8C C3                              ret
  3176                                  
  3177                                  ; Función para verificar colisión con enemigos
  3178                                  ; Función para verificar colisión con enemigos
  3179                                  check_enemy_collision:
  3180 00001C8D 55                          push rbp
  3181 00001C8E 4889E5                      mov rbp, rsp
  3182                                      
  3183 00001C91 4D31E4                      xor r12, r12                    ; Índice del enemigo
  3184 00001C94 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  3185                                      
  3186                                      .check_loop:
  3187 00001C97 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  3188 00001C9B 0F8DE9000000                    jge .end
  3189                                          
  3190                                          ; Calcular offset del enemigo actual
  3191 00001CA1 4C89E1                          mov rcx, r12
  3192 00001CA4 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  3193 00001CA8 488DB1[BD150000]                lea rsi, [enemies + rcx]
  3194                                          
  3195                                          ; Verificar si el enemigo está activo
  3196 00001CAF 807E0201                        cmp byte [rsi + 2], 1
  3197 00001CB3 0F85C9000000                    jne .next_enemy
  3198                                          
  3199                                          ; Verificar colisión con la bola
  3200 00001CB9 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  3201 00001CBD 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  3202                                          
  3203                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  3204 00001CC2 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3205 00001CC9 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3206                                          
  3207                                          ; Comprobar colisión vertical (misma columna)
  3208 00001CD0 4D39C2                          cmp r10, r8
  3209 00001CD3 7525                            jne .check_horizontal
  3210 00001CD5 4D29CB                          sub r11, r9
  3211 00001CD8 4983FB01                        cmp r11, 1
  3212 00001CDC 7F1C                            jg .check_horizontal
  3213 00001CDE 4983FBFF                        cmp r11, -1
  3214 00001CE2 7C16                            jl .check_horizontal
  3215                                          
  3216                                          ; Colisión vertical detectada
  3217 00001CE4 E8A3000000                      call destroy_enemy
  3218 00001CE9 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  3219 00001CF0 B801000000                      mov rax, 1
  3220 00001CF5 E990000000                      jmp .end
  3221                                          
  3222                                      .check_horizontal:
  3223                                          ; Comprobar colisión horizontal (misma fila)
  3224 00001CFA 4C8B15(5F140000)                mov r10, [ball_x_pos]
  3225 00001D01 4C8B1D(67140000)                mov r11, [ball_y_pos]
  3226 00001D08 4D39CB                          cmp r11, r9
  3227 00001D0B 7522                            jne .check_paddle
  3228 00001D0D 4D29C2                          sub r10, r8
  3229 00001D10 4983FA01                        cmp r10, 1
  3230 00001D14 7F19                            jg .check_paddle
  3231 00001D16 4983FAFF                        cmp r10, -1
  3232 00001D1A 7C13                            jl .check_paddle
  3233                                          
  3234                                          ; Colisión horizontal detectada
  3235 00001D1C E86B000000                      call destroy_enemy
  3236 00001D21 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  3237 00001D28 B801000000                      mov rax, 1
  3238 00001D2D EB5B                            jmp .end
  3239                                          
  3240                                      .check_paddle:
  3241                                          ; Verificar colisión con la paleta
  3242 00001D2F 4C8B15(3F140000)                mov r10, [pallet_position]
  3243 00001D36 4981EA[000A0000]                sub r10, board
  3244 00001D3D 4C89D0                          mov rax, r10
  3245 00001D40 41BB4E000000                    mov r11, column_cells
  3246 00001D46 4983C302                        add r11, 2
  3247 00001D4A 4831D2                          xor rdx, rdx
  3248 00001D4D 49F7F3                          div r11                     ; División para obtener la posición Y
  3249 00001D50 4989D3                          mov r11, rdx               ; X de la paleta en r11
  3250                                          
  3251 00001D53 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  3252                                          
  3253                                          ; Verificar si el enemigo está en la misma fila que la paleta
  3254 00001D5A 41BD20000000                    mov r13, row_cells
  3255 00001D60 4983ED02                        sub r13, 2                 ; Y de la paleta
  3256 00001D64 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  3257 00001D67 7519                            jne .next_enemy
  3258                                          
  3259                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  3260 00001D69 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  3261 00001D6C 7C14                            jl .next_enemy
  3262                                          
  3263 00001D6E 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  3264 00001D71 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  3265 00001D74 7F0C                            jg .next_enemy
  3266                                          
  3267                                          ; Si llegamos aquí, hay colisión con la paleta
  3268 00001D76 E811000000                      call destroy_enemy        ; Destruir el enemigo
  3269 00001D7B B801000000                      mov rax, 1                ; Indicar que hubo colisión
  3270 00001D80 EB08                            jmp .end
  3271                                          
  3272                                      .next_enemy:
  3273 00001D82 49FFC4                          inc r12
  3274 00001D85 E90DFFFFFF                      jmp .check_loop
  3275                                          
  3276                                      .end:
  3277 00001D8A 5D                              pop rbp
  3278 00001D8B C3                              ret
  3279                                  
  3280                                  ; Función para destruir un enemigo
  3281                                  destroy_enemy:
  3282                                      ; Desactivar enemigo
  3283 00001D8C C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  3284                                  
  3285                                      ; Sumar puntos por destruir enemigo
  3286 00001D90 488B05(DC150000)            mov rax, [enemy_points]
  3287 00001D97 480105(9B150000)            add [current_score], rax
  3288                                  
  3289                                      ; No tocar bloques destruidos aquí
  3290 00001D9E C3                          ret
  3291                                  
  3292                                  
  3293                                  _start:
  3294 00001D9F E887E3FFFF              	call canonical_off
  3295 00001DA4 E853010000              	call start_screen
  3296 00001DA9 E8AAF5FFFF                  call init_level
  3297 00001DAE E8FCFBFFFF                  call init_enemies
  3298 00001DB3 EB00                    	jmp .main_loop
  3299                                  	
  3300                                  
  3301                                      .main_loop:
  3302 00001DB5 E8B3F9FFFF                      call print_labels
  3303 00001DBA E8E2F8FFFF                      call print_blocks
  3304 00001DBF E876E7FFFF                      call move_letters
  3305 00001DC4 E80BEAFFFF                      call update_lasers
  3306 00001DC9 E8E1E6FFFF                      call print_letters
  3307 00001DCE E8ACEDFFFF                      call print_pallet
  3308                                          
  3309                                          ; Mover bola principal solo si está activa
  3310 00001DD3 803D(80140000)01                cmp byte [ball_active], 1
  3311 00001DDA 7505                            jne .skip_ball1
  3312 00001DDC E8B6EEFFFF                          call move_ball
  3313                                          .skip_ball1:
  3314                                  
  3315                                          ; Mover bola 2 si está activa
  3316 00001DE1 803D(A2140000)01                cmp byte [ball2_active], 1
  3317 00001DE8 7505                            jne .skip_ball2
  3318 00001DEA E87BF0FFFF                          call move_ball_2
  3319                                          .skip_ball2:
  3320                                  
  3321                                          ; Mover bola 3 si está activa
  3322 00001DEF 803D(C4140000)01                cmp byte [ball3_active], 1
  3323 00001DF6 7505                            jne .skip_ball3
  3324 00001DF8 E840F2FFFF                          call move_ball_3
  3325                                          .skip_ball3:
  3326                                  
  3327 00001DFD E8F4E4FFFF                      call check_bottom_collision    ; Nueva función que maneja todas las bolas
  3328 00001E02 E8D6E3FFFF                      call print_lives
  3329                                  
  3330                                          ; Imprimir solo las bolas activas
  3331 00001E07 803D(80140000)01                cmp byte [ball_active], 1
  3332 00001E0E 7505                            jne .no_pb1
  3333 00001E10 E8F2ECFFFF                          call print_ball
  3334                                          .no_pb1:
  3335                                  
  3336 00001E15 803D(A2140000)01                cmp byte [ball2_active], 1
  3337 00001E1C 7505                            jne .no_pb2
  3338 00001E1E E80CEDFFFF                          call print_ball_2
  3339                                          .no_pb2:
  3340                                  
  3341 00001E23 803D(C4140000)01                cmp byte [ball3_active], 1
  3342 00001E2A 7505                            jne .no_pb3
  3343 00001E2C E826EDFFFF                          call print_ball_3
  3344                                          .no_pb3:
  3345                                  
  3346 00001E31 E8CDF6FFFF                      call check_level_complete
  3347 00001E36 E88BFDFFFF                      call check_enemy_spawn
  3348 00001E3B E8A3FBFFFF                      call move_enemies
  3349 00001E40 E848FEFFFF                      call check_enemy_collision
  3350 00001E45 E8E9FDFFFF                      call print_enemies
  3351                                  		print board, board_size				
    82 00001E4A B801000000          <1>  mov eax, sys_write
    83 00001E4F BF01000000          <1>  mov edi, 1
    84 00001E54 48BE-               <1>  mov rsi, %1
    84 00001E56 [000A000000000000]  <1>
    85 00001E5E BA000A0000          <1>  mov edx, %2
    86 00001E63 0F05                <1>  syscall
  3352                                  		;setnonblocking	
  3353                                  	.read_more:	
  3354                                  	    getchar	
    90 00001E65 B800000000          <1>  mov rax, sys_read
    91 00001E6A BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001E6F 48BE-               <1>  mov rsi, input_char
    92 00001E71 [0000000000000000]  <1>
    93 00001E79 BA01000000          <1>  mov rdx, 1
    94 00001E7E 0F05                <1>  syscall
  3355 00001E80 4883F801                	    cmp rax, 1
  3356 00001E84 7543                    	    jne .done
  3357                                  	
  3358 00001E86 8A05(00000000)          	    mov al, [input_char]
  3359 00001E8C 8805(64180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  3360                                  	
  3361 00001E92 3C61                    	    cmp al, 'a'
  3362 00001E94 750E                    	    jne .not_left
  3363 00001E96 48C7C7FFFFFFFF          	    mov rdi, left_direction
  3364 00001E9D E812EDFFFF              	    call move_pallet
  3365 00001EA2 EB25                    	    jmp .done
  3366                                  	
  3367                                      .not_left:
  3368 00001EA4 3C64                    	    cmp al, 'd'
  3369 00001EA6 750C                    	    jne .not_right
  3370 00001EA8 BF01000000              	    mov rdi, right_direction
  3371 00001EAD E802EDFFFF              	    call move_pallet
  3372 00001EB2 EB15                    	    jmp .done
  3373                                  	
  3374                                      .not_right:
  3375 00001EB4 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  3376 00001EB6 740A                    	    je .release_ball        ; Si sí, liberar la bola
  3377                                  	
  3378 00001EB8 3C71                    	    cmp al, 'q' 
  3379 00001EBA 0F84AF000000            	    je exit
  3380 00001EC0 EBA3                    	    jmp .read_more
  3381                                  	
  3382                                      .release_ball:
  3383 00001EC2 E849F3FFFF              	    call process_catch_release
  3384 00001EC7 EB00                    	    jmp .done
  3385                                  	
  3386                                      .done:
  3387                                  	    sleeptime
    98 00001EC9 B823000000          <1>  mov eax, sys_nanosleep
    99 00001ECE 48BF-               <1>  mov rdi, timespec
    99 00001ED0 [0000000000000000]  <1>
   100 00001ED8 31F6                <1>  xor esi, esi
   101 00001EDA 0F05                <1>  syscall
  3388                                  	    print clear, clear_length
    82 00001EDC B801000000          <1>  mov eax, sys_write
    83 00001EE1 BF01000000          <1>  mov edi, 1
    84 00001EE6 48BE-               <1>  mov rsi, %1
    84 00001EE8 [1000000000000000]  <1>
    85 00001EF0 BA07000000          <1>  mov edx, %2
    86 00001EF5 0F05                <1>  syscall
  3389 00001EF7 E9B9FEFFFF              	    jmp .main_loop
  3390                                  
  3391                                  
  3392                                  
  3393                                  
  3394                                  start_screen:
  3395                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001EFC B801000000          <1>  mov eax, sys_write
    83 00001F01 BF01000000          <1>  mov edi, 1
    84 00001F06 48BE-               <1>  mov rsi, %1
    84 00001F08 [1000000000000000]  <1>
    85 00001F10 BA07000000          <1>  mov edx, %2
    86 00001F15 0F05                <1>  syscall
  3396                                      print msg1, msg1_length
    82 00001F17 B801000000          <1>  mov eax, sys_write
    83 00001F1C BF01000000          <1>  mov edi, 1
    84 00001F21 48BE-               <1>  mov rsi, %1
    84 00001F23 [1700000000000000]  <1>
    85 00001F2B BA14010000          <1>  mov edx, %2
    86 00001F30 0F05                <1>  syscall
  3397                                      
  3398                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  3399                                          getchar                 ; Esperamos una tecla
    90 00001F32 B800000000          <1>  mov rax, sys_read
    91 00001F37 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001F3C 48BE-               <1>  mov rsi, input_char
    92 00001F3E [0000000000000000]  <1>
    93 00001F46 BA01000000          <1>  mov rdx, 1
    94 00001F4B 0F05                <1>  syscall
  3400 00001F4D 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  3401 00001F51 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  3402                                          
  3403                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 00001F53 B801000000          <1>  mov eax, sys_write
    83 00001F58 BF01000000          <1>  mov edi, 1
    84 00001F5D 48BE-               <1>  mov rsi, %1
    84 00001F5F [1000000000000000]  <1>
    85 00001F67 BA07000000          <1>  mov edx, %2
    86 00001F6C 0F05                <1>  syscall
  3404 00001F6E C3                          ret
  3405                                  
  3406                                  exit: 
  3407 00001F6F E8F9E1FFFF              	call canonical_on
  3408 00001F74 B83C000000              	mov    rax, 60
  3409 00001F79 BF00000000                  mov    rdi, 0
  3410 00001F7E 0F05                        syscall
  3411                                  
