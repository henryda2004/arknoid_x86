     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A0703014C                      db 58, 7, 3, 1, 'L'    ; Bloque 7
   290 000014BB 3D09030143                      db 61, 9, 3, 1, 'C'    ; Bloque 7
   291 000014C0 2309030143                      db 35, 9, 3, 1, 'C'    ; Bloque 7
   292 000014C5 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   293 000014CA 1208030253                      db 18, 8, 3, 2, 'S'    ; Bloque 7
   294 000014CF 120A040120                      db 18, 10, 4, 1, ' '    ; Bloque 7
   295 000014D4 1E0A040120                      db 30, 10, 4, 1, ' '    ; Bloque 7
   296 000014D9 120E040120                      db 18, 14, 4, 1, ' '    ; Bloque 7
   297                                  
   298                                  
   299                                      level1_blocks_count equ 8   ; Cantidad total de bloques
   300                                  
   301                                      ; Nivel 2: Bloques de prueba
   302                                      level2_blocks:
   303 000014DE 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   304                                      level2_blocks_count equ 1
   305                                  
   306                                      ; Nivel 3
   307                                      level3_blocks:
   308 000014E3 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   309                                  
   310                                      level3_blocks_count equ 1
   311                                  
   312                                      ; Nivel 4
   313                                      level4_blocks:
   314 000014E8 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   315                                      level4_blocks_count equ 1
   316                                  
   317                                      ; Nivel 5
   318                                      level5_blocks:
   319 000014ED 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   320                                      level5_blocks_count equ 1
   321                                  
   322                                      ; Array para mantener el estado de los bloques
   323 000014F2 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   324                                  
   325                                      
   326                                      ; Variables para almacenar los valores
   327 00001556 0000000000000000            current_score dq 0          ; Score actual
   328 0000155E 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   329                                      
   330                                      ; Buffer para convertir números a string
   331 0000155F 00<rep 14h>                 number_buffer: times 20 db 0
   332                                  
   333 00001573 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   334                                      
   335                                      ; Estructura para los enemigos (x, y, activo)
   336 00001578 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   337 00001596 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   338                                      
   339 00001597 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   340 0000159F 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   341 000015A0 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   342 000015A1 00                          enemy_move_total db 0      ; Contador total de movimientos
   343 000015A2 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   344 000015A3 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   345                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   346                                      ; Añade esto en la sección .dataa
   347 000015A4 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   347 000015AD 12                 
   348 000015AE 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   348 000015B7 13                 
   349 000015B8 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   349 000015C1 1B                 
   350 000015C2 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   350 000015CB 1C                 
   351 000015CC 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   351 000015D5 2D                 
   352                                          ; Arreglo de punteros a los spawn points de cada nivel
   353                                      spawn_points_table:
   354 000015D6 [A415000000000000]              dq level1_spawn_points
   355 000015DE [AE15000000000000]              dq level2_spawn_points
   356 000015E6 [B815000000000000]              dq level3_spawn_points
   357 000015EE [C215000000000000]              dq level4_spawn_points
   358 000015F6 [CC15000000000000]              dq level5_spawn_points
   359                                  
   360                                      ; Variables para el comportamiento de enemigos
   361 000015FE 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   362 000015FF 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   363 00001600 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   364 00001601 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   365                                  
   366 0000160B 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   366 00001614 5B2020202020202020-
   366 0000161D 20205D0A0D         
   367                                      score_label_len: equ $ - score_label
   368 00001622 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   368 0000162B 657374727569646F73-
   368 00001634 3A205B2020205D0A0D 
   369                                      blocks_label_len: equ $ - blocks_label
   370                                      
   371                                      ; Posición donde insertar los números en los labels
   372                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   373                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   374                                      
   375                                      ; Definición de las vidas (x, y, estado)
   376                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   377                                      lives_data: 
   378 0000163D 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   379 00001640 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   380 00001643 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   381 00001646 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   382 00001649 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   383 0000164C 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   384 0000164F 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   385                                      lives_count equ 7    ; Total de vidas
   386 00001652 5E                          life_char db "^"    
   387 00001653 04                          current_lives db 4   ; Contador de vidas activas actual
   388                                  
   389                                  ; Estructura para almacenar las letras y sus posiciones
   390                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   391 00001654 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   392 000017E4 00                          letters_count db 0   
   393 000017E5 20                          last_letter db ' '    ; Variable para almacenar la última letra
   394 000017E6 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   394 000017EF 75616C3A205B205D0A-
   394 000017F8 0D                 
   395                                      last_letter_msg_len equ $ - last_letter_msg
   396 000017F9 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   397 000017FA 07                          max_lives db 7              ; Máximo número de vidas permitidas
   398 000017FB 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   399 00001803 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   400 0000180B 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   401                                  
   402 00001813 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   403 00001814 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   404 00001815 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   405 0000181D 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   406                                  
   407 0000181E 00                          laser_power_active: db 0         ; Flag para indicar si el poder láser está activo
   408 0000181F 7C                          laser_symbol: db '|'             ; Símbolo para representar el láser
   409 00001820 00                          laser_count: db 0                ; Contador de láseres activos
   410 00001821 00<rep C8h>                 lasers: times 200 db 0           ; Array para almacenar posiciones de láseres (x,y)
   411 000018E9 0100000000000000            laser_speed: dq 1                ; Velocidad del láser
   412                                  
   413                                  section .text
   414                                  
   415                                  
   416                                  print_lives:
   417 000001DD 55                          push rbp
   418 000001DE 4889E5                      mov rbp, rsp
   419                                      
   420 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   421                                      
   422                                      .print_loop:
   423 000001E4 4983FC07                        cmp r12, lives_count
   424 000001E8 7D45                            jge .end
   425                                          
   426                                          ; Calcular offset de la vida actual
   427 000001EA 4C89E0                          mov rax, r12
   428 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   429 000001F1 488DB0[3D160000]                lea rsi, [lives_data + rax]
   430                                          
   431                                          ; Calcular posición en el tablero
   432 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   433 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   434                                          
   435                                          ; Calcular offset en el tablero
   436 00000201 B84E000000                      mov rax, column_cells
   437 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   438 0000020A 49F7E1                          mul r9
   439 0000020D 4C01C0                          add rax, r8
   440 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   441                                          
   442                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   443 00000217 807E0201                        cmp byte [rsi + 2], 1
   444 0000021B 7405                            je .draw_active
   445                                          
   446                                          ; Si está inactiva, dibujar espacio
   447 0000021D C60720                          mov byte [rdi], ' '
   448 00000220 EB08                            jmp .next_life
   449                                          
   450                                      .draw_active:
   451                                          ; Si está activa, dibujar el símbolo de vida
   452 00000222 8A05(52160000)                  mov al, [life_char]
   453 00000228 8807                            mov [rdi], al
   454                                          
   455                                      .next_life:
   456 0000022A 49FFC4                          inc r12
   457 0000022D EBB5                            jmp .print_loop
   458                                          
   459                                      .end:
   460 0000022F 5D                              pop rbp
   461 00000230 C3                              ret
   462                                  
   463                                  ; Función para desactivar una vida
   464                                  ; Función modificada para perder una vida
   465                                  lose_life:
   466 00000231 55                          push rbp
   467 00000232 4889E5                      mov rbp, rsp
   468                                      
   469                                      ; Verificar si aún quedan vidas
   470 00000235 803D(53160000)00            cmp byte [current_lives], 0
   471 0000023C 0F8493000000                je .game_lost
   472                                      
   473                                      ; Encontrar la última vida activa
   474 00000242 B907000000                  mov rcx, lives_count
   475 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   476                                      
   477                                      .find_active_life:
   478 0000024A 4889C8                          mov rax, rcx
   479 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   480 00000251 488DB0[3D160000]                lea rsi, [lives_data + rax]
   481 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   482 0000025C 7407                            je .deactivate_life
   483 0000025E 48FFC9                          dec rcx
   484 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   485 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   486                                          
   487                                      .deactivate_life:
   488                                          ; Calcular posición correcta en el tablero para borrar la vida
   489 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   490 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   491                                          
   492                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   493 0000026E B84E000000                      mov rax, column_cells
   494 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   495 00000277 49F7E1                          mul r9
   496 0000027A 4C01C0                          add rax, r8
   497 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   498                                          
   499                                          ; Borrar visualmente la vida
   500 00000284 C60720                          mov byte [rdi], ' '             
   501                                          
   502                                          ; Desactivar la vida en los datos
   503 00000287 C6460200                        mov byte [rsi + 2], 0          
   504 0000028B FE0D(53160000)                  dec byte [current_lives]
   505                                          
   506                                          ; Borrar visualmente la paleta anterior
   507 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   508 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   509                                          .erase_pallet_loop:
   510 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   511 000002A3 49FFC0                              inc r8
   512 000002A6 48FFC9                              dec rcx
   513 000002A9 75F4                                jnz .erase_pallet_loop
   514                                          
   515                                  
   516                                          ; Reiniciar posición de la bola y la paleta
   517 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   517 000002B3 000000             
   518 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   518 000002BE 000000             
   519 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   520 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   520 000002CF [36130000]         
   521                                          
   522 000002D3 EB07                            jmp .end
   523                                          
   524                                      .game_lost:
   525 000002D5 E81C000000                      call game_lost
   526 000002DA EB00                            jmp .end
   527                                          
   528                                      .end:
   529 000002DC 5D                              pop rbp
   530 000002DD C3                              ret
   531                                  ; Función modificada para verificar colisión con el borde inferior
   532                                  check_bottom_collision:
   533 000002DE 55                          push rbp
   534 000002DF 4889E5                      mov rbp, rsp
   535                                      
   536                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   537 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   538 000002E9 4883F81E                    cmp rax, row_cells - 2
   539 000002ED 7505                        jne .no_collision
   540                                      
   541                                      ; Si hay colisión, perder una vida
   542 000002EF E83DFFFFFF                  call lose_life
   543                                      
   544                                      .no_collision:
   545 000002F4 5D                              pop rbp
   546 000002F5 C3                              ret
   547                                  
   548                                  ; Nueva función para game over
   549                                  game_lost:
   550                                      ; Limpiar la pantalla
   551                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   552                                      
   553                                      ; Mostrar mensaje de derrota
   554                                      section .data
   555 000018F1 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   555 000018FA 6469646F210A0D     
   556                                          lost_msg_len: equ $ - lost_msg
   557                                      section .text
   558                                      
   559                                      ; Imprimir mensaje de derrota
   560                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [F118000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   561                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [1F19000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   562                                      
   563                                      ; Mostrar puntaje final
   564 00000347 488B05(56150000)            mov rax, [current_score]
   565 0000034E 48BF-                       mov rdi, number_buffer
   565 00000350 [5F15000000000000] 
   566 00000358 E87A0D0000                  call number_to_string
   567                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [5F15000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   568                                      
   569                                      ; Esperar un momento antes de salir
   570 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   570 00000381 0000               
   571 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   571 0000038C 0000               
   572                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   573                                      
   574 000003A1 E925150000                  jmp exit
   575                                  
   576                                  
   577                                  ; Función para registrar una nueva letra en el mapa
   578                                  ; Entrada:
   579                                  ;   al - letra a registrar
   580                                  ;   r8b - posición x
   581                                  ;   r9b - posición y
   582                                  register_letter:
   583 000003A6 55                          push rbp
   584 000003A7 4889E5                      mov rbp, rsp
   585 000003AA 53                          push rbx
   586 000003AB 51                          push rcx
   587                                      
   588 000003AC 3C20                        cmp al, ' '
   589 000003AE 7438                        je .end
   590                                  
   591                                      ; Encontrar un espacio libre en el mapa
   592 000003B0 4831C9                      xor rcx, rcx
   593 000003B3 480FB615(E4170000)          movzx rdx, byte [letters_count]
   594                                      
   595                                      .find_slot:
   596 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   597 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   598                                          
   599 000003C1 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   600 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   601 000003CD 7405                            je .found_slot
   602                                          
   603 000003CF 48FFC1                          inc rcx
   604 000003D2 EBE7                            jmp .find_slot
   605                                          
   606                                      .found_slot:
   607                                          ; Guardar la información de la letra
   608 000003D4 448803                          mov [rbx], r8b           ; x
   609 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   610 000003DB 884302                          mov [rbx + 2], al        ; letra
   611 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   612                                          
   613 000003E2 FE05(E4170000)                  inc byte [letters_count]
   614                                          
   615                                      .end:
   616 000003E8 59                              pop rcx
   617 000003E9 5B                              pop rbx
   618 000003EA 5D                              pop rbp
   619 000003EB C3                              ret
   620                                  
   621                                  ; Función para imprimir todas las letras registradas
   622                                  print_letters:
   623 000003EC 55                          push rbp
   624 000003ED 4889E5                      mov rbp, rsp
   625 000003F0 53                          push rbx
   626 000003F1 51                          push rcx
   627                                      
   628 000003F2 4831C9                      xor rcx, rcx
   629                                      
   630                                      .print_loop:
   631 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   632 000003F9 7D37                            jge .end
   633                                          
   634                                          ; Obtener puntero a la letra actual
   635 000003FB 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   636                                          
   637                                          ; Verificar si está activa
   638 00000403 807B0300                        cmp byte [rbx + 3], 0
   639 00000407 7424                            je .next_letter
   640                                          
   641                                          ; Calcular posición en el tablero
   642 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   643 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   644                                          
   645                                          ; Calcular offset en el tablero
   646 00000412 B84E000000                      mov rax, column_cells
   647 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   648 0000041B 49F7E1                          mul r9
   649 0000041E 4C01C0                          add rax, r8
   650 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   651                                          
   652                                          ; Imprimir la letra
   653 00000428 8A4302                          mov al, [rbx + 2]
   654 0000042B 8807                            mov [rdi], al
   655                                          
   656                                      .next_letter:
   657 0000042D 48FFC1                          inc rcx
   658 00000430 EBC3                            jmp .print_loop
   659                                          
   660                                      .end:
   661 00000432 59                              pop rcx
   662 00000433 5B                              pop rbx
   663 00000434 5D                              pop rbp
   664 00000435 C3                              ret
   665                                  
   666                                  ; Función para borrar una letra específica
   667                                  ; Entrada:
   668                                  ;   r8b - posición x
   669                                  ;   r9b - posición y
   670                                  remove_letter:
   671 00000436 55                          push rbp
   672 00000437 4889E5                      mov rbp, rsp
   673 0000043A 53                          push rbx
   674 0000043B 51                          push rcx
   675                                      
   676 0000043C 4831C9                      xor rcx, rcx
   677                                      
   678                                      .find_loop:
   679 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   680 00000443 7D2E                            jge .end
   681                                          
   682 00000445 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   683                                          
   684                                          ; Verificar si está activa y coincide la posición
   685 0000044D 807B0300                        cmp byte [rbx + 3], 0
   686 00000451 741B                            je .next_letter
   687                                          
   688 00000453 8A03                            mov al, [rbx]
   689 00000455 4438C0                          cmp al, r8b
   690 00000458 7514                            jne .next_letter
   691                                          
   692 0000045A 8A4301                          mov al, [rbx + 1]
   693 0000045D 4438C8                          cmp al, r9b
   694 00000460 750C                            jne .next_letter
   695                                          
   696                                          ; Encontrada la letra, desactivarla
   697 00000462 C6430300                        mov byte [rbx + 3], 0
   698 00000466 FE0D(E4170000)                  dec byte [letters_count]
   699 0000046C EB05                            jmp .end
   700                                          
   701                                      .next_letter:
   702 0000046E 48FFC1                          inc rcx
   703 00000471 EBCC                            jmp .find_loop
   704                                          
   705                                      .end:
   706 00000473 59                              pop rcx
   707 00000474 5B                              pop rbx
   708 00000475 5D                              pop rbp
   709 00000476 C3                              ret
   710                                  ; Función para mover las letras hacia abajo
   711                                  move_letters:
   712 00000477 55                          push rbp
   713 00000478 4889E5                      mov rbp, rsp
   714 0000047B 53                          push rbx
   715 0000047C 57                          push rdi
   716 0000047D 56                          push rsi
   717 0000047E 4150                        push r8
   718 00000480 4151                        push r9
   719 00000482 4152                        push r10
   720 00000484 4153                        push r11
   721                                  
   722 00000486 4831C9                      xor rcx, rcx
   723                                  
   724                                      .move_loop:
   725 00000489 4883F964                        cmp rcx, 100
   726 0000048D 0F8DAD010000                    jge .print_last_letter
   727                                          
   728 00000493 488D1C8D[54160000]              lea rbx, [letters_map + rcx * 4]
   729 0000049B 807B0300                        cmp byte [rbx + 3], 0
   730 0000049F 0F8493010000                    je .next_letter
   731                                  
   732 000004A5 4C0FB603                        movzx r8, byte [rbx]
   733 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   734                                  
   735 000004AE B84E000000                      mov rax, column_cells
   736 000004B3 4883C002                        add rax, 2
   737 000004B7 49F7E1                          mul r9
   738 000004BA 4C01C0                          add rax, r8
   739 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   740 000004C4 C60720                          mov byte [rdi], ' '
   741                                  
   742 000004C7 FE4301                          inc byte [rbx + 1]
   743 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   744                                  
   745 000004CF 4983F91F                        cmp r9, row_cells - 1
   746 000004D3 7C09                            jl .check_pallet_collision
   747                                  
   748 000004D5 C6430300                        mov byte [rbx + 3], 0
   749 000004D9 E95A010000                      jmp .next_letter
   750                                  
   751                                          .check_pallet_collision:
   752 000004DE B84E000000                          mov rax, column_cells
   753 000004E3 4883C002                            add rax, 2
   754 000004E7 49F7E1                              mul r9
   755 000004EA 4C01C0                              add rax, r8
   756 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   757                                  
   758 000004F4 8A07                                mov al, [rdi]
   759 000004F6 3C20                                cmp al, ' '
   760 000004F8 0F843A010000                        je .next_letter
   761 000004FE 3C3D                                cmp al, char_equal
   762 00000500 740A                                je .capture_letter
   763                                  
   764 00000502 8A4302                              mov al, [rbx + 2]
   765 00000505 8807                                mov [rdi], al
   766 00000507 E92C010000                          jmp .next_letter
   767                                  
   768                                          .capture_letter:
   769                                              ; Obtener la nueva letra
   770 0000050C 8A4302                              mov al, [rbx + 2]
   771                                              
   772                                              ; Comparar con la última letra
   773 0000050F 3A05(E5170000)                      cmp al, [last_letter]
   774 00000515 7407                                je .same_letter
   775                                              
   776                                              ; Es una letra diferente, resetear el procesamiento
   777 00000517 C605(F9170000)00                    mov byte [current_power_processed], 0
   778                                              
   779                                              .same_letter:
   780                                              ; Guardar la nueva letra
   781 0000051E 8805(E5170000)                      mov [last_letter], al
   782                                              
   783                                              ; Verificar si es 'E' para extender la paleta
   784 00000524 3C45                                cmp al, 'E'
   785 00000526 7441                                je .extend_pallet
   786                                              
   787                                              ; Verificar si es 'P' para añadir vida
   788 00000528 3C50                                cmp al, 'P'
   789 0000052A 7462                                je .check_add_life
   790                                  
   791 0000052C 3C53                                cmp al, 'S'
   792 0000052E 0F8493000000                        je .slow_ball
   793                                  
   794 00000534 3C43                                cmp al, 'C'
   795 00000536 0F84AD000000                        je .activate_catch
   796                                              
   797 0000053C 3C4C                                cmp al, 'L'
   798 0000053E 0F84C7000000                        je .activate_laser
   799                                  
   800                                              ; Si no es ningún power-up, restaurar tamaño normal
   801 00000544 488B05(4F140000)                    mov rax, [default_pallet_size]
   802 0000054B 488905(47140000)                    mov [pallet_size], rax
   803 00000552 48C705(FB170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   803 0000055A 000000             
   804 0000055D C605(13180000)00                    mov byte [catch_power_active], 0
   805 00000564 E9CB000000                          jmp .finish_capture
   806                                  
   807                                              .extend_pallet:
   808 00000569 C605(13180000)00                        mov byte [catch_power_active], 0
   809 00000570 48C705(FB170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   809 00000578 000000             
   810 0000057B 488B05(57140000)                        mov rax, [extended_pallet_size]
   811 00000582 488905(47140000)                        mov [pallet_size], rax
   812 00000589 E9A6000000                              jmp .finish_capture
   813                                  
   814                                              .check_add_life:
   815 0000058E C605(13180000)00                        mov byte [catch_power_active], 0
   816 00000595 488B05(4F140000)                        mov rax, [default_pallet_size]
   817 0000059C 488905(47140000)                        mov [pallet_size], rax
   818 000005A3 48C705(FB170000)01-                     mov qword [ball_speed], 1 
   818 000005AB 000000             
   819                                                  ; Verificar si ya procesamos este power-up
   820 000005AE 803D(F9170000)00                        cmp byte [current_power_processed], 0
   821 000005B5 757D                                    jne .finish_capture
   822                                                  
   823                                                  ; Preservar registros importantes
   824 000005B7 51                                      push rcx
   825 000005B8 53                                      push rbx
   826                                                  
   827                                                  ; Marcar como procesado
   828 000005B9 C605(F9170000)01                        mov byte [current_power_processed], 1
   829                                                  
   830                                                  ; Añadir una vida
   831 000005C0 E821030000                              call add_life
   832                                                  
   833                                                  ; Restaurar registros
   834 000005C5 5B                                      pop rbx
   835 000005C6 59                                      pop rcx
   836                                                  
   837                                              .slow_ball:
   838 000005C7 C605(13180000)00                        mov byte [catch_power_active], 0                
   839 000005CE 488B05(4F140000)                        mov rax, [default_pallet_size]
   840 000005D5 488905(47140000)                        mov [pallet_size], rax
   841 000005DC 48C705(FB170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   841 000005E4 000000             
   842 000005E7 EB4B                                    jmp .finish_capture
   843                                  
   844                                              .activate_catch:
   845 000005E9 488B05(4F140000)                        mov rax, [default_pallet_size]
   846 000005F0 488905(47140000)                        mov [pallet_size], rax
   847 000005F7 48C705(FB170000)01-                     mov qword [ball_speed], 1
   847 000005FF 000000             
   848 00000602 C605(13180000)01                        mov byte [catch_power_active], 1
   849 00000609 EB29                                    jmp .finish_capture
   850                                  
   851                                              .activate_laser:
   852 0000060B C605(13180000)00                        mov byte [catch_power_active], 0
   853 00000612 488B05(4F140000)                        mov rax, [default_pallet_size]
   854 00000619 488905(47140000)                        mov [pallet_size], rax
   855 00000620 48C705(FB170000)01-                     mov qword [ball_speed], 1
   855 00000628 000000             
   856 0000062B C605(1E180000)01                        mov byte [laser_power_active], 1    ; Activar el poder láser
   857 00000632 EB00                                    jmp .finish_capture
   858                                  
   859                                              .finish_capture:
   860 00000634 C6430300                                mov byte [rbx + 3], 0
   861                                  
   862                                          .next_letter:
   863 00000638 48FFC1                              inc rcx
   864 0000063B E949FEFFFF                          jmp .move_loop
   865                                  
   866                                      .print_last_letter:
   867                                          print last_letter_msg, last_letter_msg_len - 3
    82 00000640 B801000000          <1>  mov eax, sys_write
    83 00000645 BF01000000          <1>  mov edi, 1
    84 0000064A 48BE-               <1>  mov rsi, %1
    84 0000064C [E617000000000000]  <1>
    85 00000654 BA10000000          <1>  mov edx, %2
    86 00000659 0F05                <1>  syscall
   868 0000065B 8A05(E5170000)                  mov al, [last_letter]
   869 00000661 8805(F5170000)                  mov [last_letter_msg + 15], al
   870                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 00000667 B801000000          <1>  mov eax, sys_write
    83 0000066C BF01000000          <1>  mov edi, 1
    84 00000671 48BE-               <1>  mov rsi, %1
    84 00000673 [F617000000000000]  <1>
    85 0000067B BA03000000          <1>  mov edx, %2
    86 00000680 0F05                <1>  syscall
   871                                  
   872                                      .end:
   873 00000682 415B                            pop r11
   874 00000684 415A                            pop r10
   875 00000686 4159                            pop r9
   876 00000688 4158                            pop r8
   877 0000068A 5E                              pop rsi
   878 0000068B 5F                              pop rdi
   879 0000068C 5B                              pop rbx
   880 0000068D 5D                              pop rbp
   881 0000068E C3                              ret
   882                                  
   883                                  
   884                                  
   885                                  ; Nueva función para actualizar los láseres
   886                                  update_lasers:
   887 0000068F 55                          push rbp
   888 00000690 4889E5                      mov rbp, rsp
   889                                      
   890                                      ; Verificar si el poder láser está activo
   891 00000693 803D(1E180000)00            cmp byte [laser_power_active], 0
   892 0000069A 741A                        je .end
   893                                      
   894                                      ; Verificar si se presionó la tecla de espacio
   895 0000069C 803D(1D180000)20            cmp byte [last_key], ' '
   896 000006A3 750C                        jne .skip_shooting
   897                                      
   898                                      ; Disparar nuevos láseres
   899 000006A5 E80E000000                  call shoot_lasers
   900 000006AA C605(1D180000)00            mov byte [last_key], 0    ; Limpiar la tecla procesada
   901                                      
   902                                      .skip_shooting:
   903                                      ; Mover los láseres existentes
   904 000006B1 E89C000000                  call move_lasers
   905                                      
   906                                      .end:
   907 000006B6 5D                              pop rbp
   908 000006B7 C3                              ret
   909                                  
   910                                  shoot_lasers:
   911 000006B8 55                          push rbp
   912 000006B9 4889E5                      mov rbp, rsp
   913 000006BC 53                          push rbx
   914                                      
   915                                      ; Verificar si hay espacio para más láseres
   916 000006BD 480FB605(20180000)          movzx rax, byte [laser_count]
   917 000006C5 4883F862                    cmp rax, 98  ; Asegurar que hay espacio para 2 láseres
   918 000006C9 0F8D80000000                jge .end
   919                                      
   920                                      ; Obtener posición de la paleta
   921 000006CF 4C8B05(3F140000)            mov r8, [pallet_position]
   922 000006D6 4981E8[000A0000]            sub r8, board                  ; Offset relativo de la paleta
   923                                      
   924                                      ; Calcular coordenadas x,y
   925 000006DD 4C89C0                      mov rax, r8
   926 000006E0 41B94E000000                mov r9, column_cells
   927 000006E6 4983C102                    add r9, 2                     ; Ancho total de línea
   928 000006EA 4831D2                      xor rdx, rdx
   929 000006ED 49F7F1                      div r9                        ; rax = y, rdx = x
   930                                      
   931                                      ; Guardar coordenadas
   932 000006F0 4989C2                      mov r10, rax                  ; Y en r10
   933 000006F3 4989D3                      mov r11, rdx                  ; X en r11
   934                                      
   935                                      ; Validar coordenadas
   936 000006F6 4983FA00                    cmp r10, 0
   937 000006FA 7C53                        jl .end
   938 000006FC 4983FA20                    cmp r10, row_cells
   939 00000700 7D4D                        jge .end
   940 00000702 4983FB00                    cmp r11, 0
   941 00000706 7C47                        jl .end
   942 00000708 4983FB4E                    cmp r11, column_cells
   943 0000070C 7D41                        jge .end
   944                                      
   945                                      ; Calcular índice para el primer láser
   946 0000070E 480FB61D(20180000)          movzx rbx, byte [laser_count]
   947 00000716 486BDB02                    imul rbx, 2                   ; Cada láser usa 2 bytes
   948                                      
   949                                      ; Primer láser (izquierda)
   950 0000071A 488DBB[21180000]            lea rdi, [lasers + rbx]
   951 00000721 44881F                      mov [rdi], r11b              ; X
   952 00000724 4488D0                      mov al, r10b
   953 00000727 FEC8                        dec al                       ; Y - 1
   954 00000729 884701                      mov [rdi + 1], al           ; Y
   955                                      
   956                                      ; Segundo láser (derecha)
   957 0000072C 4488D8                      mov al, r11b
   958 0000072F 0205(47140000)              add al, byte [pallet_size]
   959 00000735 FEC8                        dec al                       ; Ajustar para el último carácter
   960 00000737 488DBB[23180000]            lea rdi, [lasers + rbx + 2]
   961 0000073E 8807                        mov [rdi], al               ; X
   962 00000740 4488D0                      mov al, r10b
   963 00000743 FEC8                        dec al                      ; Y - 1
   964 00000745 884701                      mov [rdi + 1], al          ; Y
   965                                      
   966                                      ; Incrementar contador de láseres
   967 00000748 8005(20180000)02            add byte [laser_count], 2
   968                                      
   969                                      
   970                                      .end:
   971 0000074F 5B                              pop rbx
   972 00000750 5D                              pop rbp
   973 00000751 C3                              ret
   974                                  
   975                                  ; Función corregida para mover láseres
   976                                  ; Función corregida para mover láseres
   977                                  ; Esta es la parte clave para recorrer los láseres de atrás hacia adelante.
   978                                  
   979                                  ; Actualizar la función move_lasers para incluir verificación de colisiones
   980                                  ; ============================================================
   981                                  ; NUEVA FUNCIÓN move_lasers (todo-en-uno)
   982                                  ; ============================================================
   983                                  ; Mueve cada láser hacia arriba, verifica colisiones (bloques/enemigos)
   984                                  ; y lo elimina inmediatamente si choca, de lo contrario lo dibuja.
   985                                  ; ============================================================
   986                                  move_lasers:
   987 00000752 55                          push rbp
   988 00000753 4889E5                      mov  rbp, rsp
   989 00000756 53                          push rbx
   990 00000757 57                          push rdi
   991 00000758 56                          push rsi
   992 00000759 4154                        push r12
   993 0000075B 4155                        push r13
   994 0000075D 4156                        push r14
   995 0000075F 4157                        push r15
   996                                  
   997                                      ; 1) Tomamos la cantidad de láseres
   998 00000761 480FB60D(20180000)          movzx rcx, byte [laser_count]
   999 00000769 4885C9                      test rcx, rcx
  1000 0000076C 0F84BB000000                jz .fin              ; Si es cero, no hay láseres => salir
  1001                                  
  1002                                      ; Ajustamos RCX para que sea el último índice (laser_count - 1)
  1003 00000772 48FFC9                      dec rcx              ; Empezamos desde el último láser
  1004                                  
  1005                                  .loop_lasers:
  1006                                      ; RSI apunta a lasers + (rcx * 2) => (x, y) del láser
  1007 00000775 488DB409[21180000]          lea rsi, [lasers + rcx*2]
  1008                                  
  1009                                      ; 2) Cargar x,y actuales del láser
  1010 0000077D 4C0FB606                    movzx r8,  byte [rsi]      ; X
  1011 00000781 4C0FB64E01                  movzx r9,  byte [rsi + 1]  ; Y
  1012                                  
  1013                                      ; 3) Borrar el láser de su posición actual en pantalla
  1014                                      ;    (por si en el ciclo anterior se había dibujado)
  1015 00000786 B84E000000                  mov rax, column_cells
  1016 0000078B 4883C002                    add rax, 2
  1017 0000078F 49F7E1                      mul r9
  1018 00000792 4C01C0                      add rax, r8
  1019 00000795 488DB8[000A0000]            lea rdi, [board + rax]
  1020 0000079C C60720                      mov byte [rdi], ' '        ; Borramos el símbolo anterior (láser)
  1021                                  
  1022                                      ; 4) Mover el láser hacia arriba (y - 1)
  1023 0000079F 49FFC9                      dec r9
  1024                                  
  1025                                      ; Si y < 1, está fuera de pantalla => eliminarlo
  1026 000007A2 4983F901                    cmp r9, 1
  1027 000007A6 7C57                        jl .delete_laser
  1028                                  
  1029                                      ; Guardamos la posición nueva en el array (aún no lo dibujamos)
  1030 000007A8 44884E01                    mov byte [rsi + 1], r9b
  1031                                  
  1032                                      ; 5) Verificamos colisión inmediata con bloques o enemigos
  1033                                      ;    - Primero colisión con bloques
  1034                                      ; ---------------------------------------------------------
  1035                                      ; Calculamos la nueva dirección de memoria para esa posición (r9,r8)
  1036 000007AC B84E000000                  mov rax, column_cells
  1037 000007B1 4883C002                    add rax, 2
  1038 000007B5 49F7E1                      mul r9
  1039 000007B8 4C01C0                      add rax, r8
  1040 000007BB 488DB8[000A0000]            lea rdi, [board + rax]   ; rdi apunta a la celda donde estaría el láser
  1041                                  
  1042                                      ; Revisar si hay bloque
  1043 000007C2 51                          push rcx
  1044 000007C3 56                          push rsi
  1045 000007C4 57                          push rdi
  1046 000007C5 4989FA                      mov r10, rdi    ; En check_block_collision, r10 = posición en board
  1047 000007C8 E8620A0000                  call check_block_collision
  1048 000007CD 5F                          pop rdi
  1049 000007CE 5E                          pop rsi
  1050 000007CF 59                          pop rcx
  1051                                  
  1052 000007D0 4885C0                      test rax, rax          ; rax=1 => hubo colisión con bloque
  1053 000007D3 752A                        jnz .delete_laser      ; si chocó, eliminar ya el láser
  1054                                  
  1055                                      ;    - Luego colisión con enemigos
  1056                                      ; ---------------------------------------------------------
  1057 000007D5 51                          push rcx
  1058 000007D6 56                          push rsi
  1059 000007D7 57                          push rdi
  1060                                      ; Pasamos (r8=X, r9=Y, r10=punteroEnBoard) a la función
  1061                                      ; o podemos crear una versión inlined. A modo de ejemplo:
  1062                                      ; Llamamos a check_laser_enemy_collision, que retorna
  1063                                      ; rax=1 si hubo colisión con enemigo, 0 si no.
  1064                                      ;
  1065                                      ; Hacemos algo como:
  1066 000007D8 4989FA                      mov r10, rdi
  1067 000007DB E85A000000                  call check_laser_enemy_collision
  1068 000007E0 5F                          pop rdi
  1069 000007E1 5E                          pop rsi
  1070 000007E2 59                          pop rcx
  1071                                  
  1072 000007E3 4885C0                      test rax, rax          ; rax=1 => colisión con un enemigo
  1073 000007E6 7517                        jnz .delete_laser
  1074                                  
  1075                                      ; 6) Si NO hubo colisión, dibujamos el láser en la nueva posición
  1076 000007E8 8A05(1F180000)              mov al, [laser_symbol]
  1077 000007EE 8807                        mov [rdi], al
  1078                                  
  1079                                  .next_laser:
  1080                                      ; Pasamos al láser anterior en el array
  1081 000007F0 48FFC9                      dec rcx
  1082 000007F3 4883F9FF                    cmp rcx, -1
  1083 000007F7 0F8F78FFFFFF                jg .loop_lasers   ; Mientras rcx >= 0, seguir iterando
  1084 000007FD EB2E                        jmp .fin
  1085                                  
  1086                                  ; -----------------------------------------------------------------
  1087                                  ; Subrutina interna: .delete_laser
  1088                                  ; -----------------------------------------------------------------
  1089                                  ; Elimina el láser actual del array 'lasers' moviendo el último
  1090                                  ; láser a su posición (si no es el último). Decrementa laser_count.
  1091                                  .delete_laser:
  1092 000007FF 4C0FB625(20180000)          movzx r12, byte [laser_count]
  1093 00000807 49FFCC                      dec r12                    ; r12 = índice del último láser
  1094 0000080A 4939CC                      cmp r12, rcx
  1095 0000080D 7616                        jbe .just_decrement        ; Si rcx ya apunta al último, no copiamos
  1096                                  
  1097                                      ; Copiamos el último láser a la posición actual
  1098 0000080F 488DBC09[21180000]          lea rdi, [lasers + rcx*2]
  1099 00000817 4B8DB424[21180000]          lea rsi, [lasers + r12*2]
  1100 0000081F 668B06                      mov ax, [rsi]             ; lee 2 bytes (X,Y) del último láser
  1101 00000822 668907                      mov [rdi], ax             ; copiamos X,Y
  1102                                  
  1103                                  .just_decrement:
  1104 00000825 FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1105 0000082B EBC3                        jmp .next_laser
  1106                                  
  1107                                  .fin:
  1108 0000082D 415F                        pop r15
  1109 0000082F 415E                        pop r14
  1110 00000831 415D                        pop r13
  1111 00000833 415C                        pop r12
  1112 00000835 5E                          pop rsi
  1113 00000836 5F                          pop rdi
  1114 00000837 5B                          pop rbx
  1115 00000838 5D                          pop rbp
  1116 00000839 C3                          ret
  1117                                  
  1118                                  
  1119                                  ; Nueva función para verificar colisión entre láser y enemigos
  1120                                  ; ==========================================================
  1121                                  ; NUEVA check_laser_enemy_collision - inlined destroy
  1122                                  ; ==========================================================
  1123                                  check_laser_enemy_collision:
  1124 0000083A 55                          push rbp
  1125 0000083B 4889E5                      mov  rbp, rsp
  1126                                      
  1127 0000083E 4D31ED                      xor r13, r13            ; Índice del enemigo
  1128 00000841 4831C0                      xor rax, rax            ; 0 = no colisión
  1129                                  
  1130                                  .loop_enemies:
  1131 00000844 4983FD05                    cmp r13, 5              ; Máximo 5 enemigos
  1132 00000848 7D64                        jge .end
  1133                                  
  1134                                      ; r13 * 3 => offset del enemigo i
  1135 0000084A 4C89E9                      mov rcx, r13
  1136 0000084D 486BC903                    imul rcx, 3
  1137 00000851 488DB1[78150000]            lea rsi, [enemies + rcx]   ; rsi => &enemies[i]
  1138                                  
  1139                                      ; Verificar si está activo
  1140 00000858 807E0201                    cmp byte [rsi+2], 1
  1141 0000085C 754B                        jne .next_enemy
  1142                                  
  1143                                      ; Cargar posición X/Y del enemigo
  1144 0000085E 4C0FB636                    movzx r14, byte [rsi]      ; X
  1145 00000862 4C0FB67E01                  movzx r15, byte [rsi+1]    ; Y
  1146                                  
  1147                                      ; Comparar con posición del láser (r8=X, r9=Y)
  1148 00000867 4D39F0                      cmp r8, r14
  1149 0000086A 753D                        jne .next_enemy
  1150 0000086C 4D39F9                      cmp r9, r15
  1151 0000086F 7538                        jne .next_enemy
  1152                                  
  1153                                      ; ==== Colisión detectada con láser ====
  1154                                  
  1155                                      ; 1) Desactivar enemigo
  1156 00000871 C6460200                    mov byte [rsi+2], 0     ; (activo=0)
  1157                                  
  1158                                      ; 2) Sumar puntos
  1159 00000875 488B05(97150000)            mov rax, [enemy_points]
  1160 0000087C 480105(56150000)            add [current_score], rax
  1161                                  
  1162                                      ; 3) (Opcional) Borrar del board, SOLO si no coincide con la paleta
  1163                                      ;    Evita crasheos en la fila de la paleta (row_cells - 2).
  1164 00000883 4983FF1E                    cmp r15, row_cells - 2
  1165 00000887 7419                        je .skip_erase
  1166                                  
  1167                                      ; Borrar visualmente del board
  1168 00000889 B84E000000                  mov rax, column_cells
  1169 0000088E 4883C002                    add rax, 2
  1170 00000892 49F7E7                      mul r15
  1171 00000895 4C01F0                      add rax, r14
  1172 00000898 488DB8[000A0000]            lea rdi, [board + rax]
  1173 0000089F C60720                      mov byte [rdi], ' '
  1174                                  
  1175                                  .skip_erase:
  1176                                  
  1177                                      ; 4) Devolver rax=1 => colisión con enemigo
  1178 000008A2 B801000000                  mov rax, 1
  1179 000008A7 EB05                        jmp .end
  1180                                  
  1181                                  .next_enemy:
  1182 000008A9 49FFC5                      inc r13
  1183 000008AC EB96                        jmp .loop_enemies
  1184                                  
  1185                                  .end:
  1186 000008AE 5D                          pop rbp
  1187 000008AF C3                          ret
  1188                                  
  1189                                  
  1190                                  ; Función auxiliar para eliminar un láser específico
  1191                                  remove_laser:
  1192 000008B0 55                          push rbp
  1193 000008B1 4889E5                      mov rbp, rsp
  1194                                  
  1195                                      ; Borrar el láser del tablero
  1196 000008B4 41C60220                    mov byte [r10], ' '
  1197                                  
  1198                                      ; Mover el último láser a esta posición si no es el último
  1199 000008B8 480FB605(20180000)          movzx rax, byte [laser_count]
  1200 000008C0 48FFC8                      dec rax                    ; Índice del último láser
  1201 000008C3 4939C4                      cmp r12, rax              ; Comparar con láser actual
  1202 000008C6 7416                        je .just_decrease         ; Si es el último, solo decrementar contador
  1203                                  
  1204                                      ; Copiar último láser a la posición actual
  1205 000008C8 4B8DBC24[21180000]          lea rdi, [lasers + r12*2]
  1206 000008D0 488DB400[21180000]          lea rsi, [lasers + rax*2]
  1207 000008D8 668B16                      mov dx, [rsi]             ; Copiar X,Y del último láser
  1208 000008DB 668917                      mov [rdi], dx
  1209                                  
  1210                                  .just_decrease:
  1211 000008DE FE0D(20180000)              dec byte [laser_count]    ; Decrementar contador de láseres
  1212                                  
  1213 000008E4 5D                          pop rbp
  1214 000008E5 C3                          ret
  1215                                  
  1216                                  add_life:
  1217 000008E6 55                          push rbp
  1218 000008E7 4889E5                      mov rbp, rsp
  1219 000008EA 53                          push rbx
  1220 000008EB 51                          push rcx
  1221 000008EC 57                          push rdi
  1222 000008ED 56                          push rsi
  1223 000008EE 4150                        push r8
  1224 000008F0 4151                        push r9
  1225                                      
  1226                                      ; Verificar si ya tenemos el máximo de vidas
  1227 000008F2 480FB605(53160000)          movzx rax, byte [current_lives]
  1228 000008FA 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
  1229 000008FE 7D2C                        jge .end
  1230                                      
  1231                                      ; Incrementar el contador de vidas
  1232 00000900 FE05(53160000)              inc byte [current_lives]
  1233                                      
  1234                                      ; Encontrar la siguiente vida inactiva
  1235 00000906 4831C9                      xor rcx, rcx
  1236                                      
  1237                                      .find_inactive:
  1238 00000909 4883F907                        cmp rcx, lives_count
  1239 0000090D 7D1D                            jge .end
  1240                                          
  1241                                          ; Calcular offset de la vida actual
  1242 0000090F 4889C8                          mov rax, rcx
  1243 00000912 486BC003                        imul rax, 3
  1244 00000916 488DB0[3D160000]                lea rsi, [lives_data + rax]
  1245                                          
  1246                                          ; Verificar si está inactiva
  1247 0000091D 807E0200                        cmp byte [rsi + 2], 0
  1248 00000921 7405                            je .activate_life
  1249                                          
  1250 00000923 48FFC1                          inc rcx
  1251 00000926 EBE1                            jmp .find_inactive
  1252                                          
  1253                                      .activate_life:
  1254                                          ; Activar la vida
  1255 00000928 C6460201                        mov byte [rsi + 2], 1
  1256                                          
  1257                                      .end:
  1258 0000092C 4159                            pop r9
  1259 0000092E 4158                            pop r8
  1260 00000930 5E                              pop rsi
  1261 00000931 5F                              pop rdi
  1262 00000932 59                              pop rcx
  1263 00000933 5B                              pop rbx
  1264 00000934 5D                              pop rbp
  1265 00000935 C3                              ret
  1266                                  
  1267                                  
  1268                                  print_ball:
  1269 00000936 4C8B05(5F140000)        	mov r8, [ball_x_pos]
  1270 0000093D 4C8B0D(67140000)        	mov r9, [ball_y_pos]
  1271 00000944 4981C0[000A0000]        	add r8, board
  1272                                  
  1273 0000094B 4C89C9                  	mov rcx, r9
  1274 0000094E B850000000              	mov rax, column_cells + 2
  1275 00000953 48F7E9                  	imul rcx
  1276                                  	
  1277 00000956 4901C0                  	add r8, rax
  1278 00000959 41C6004F                	mov byte [r8], char_O
  1279 0000095D C3                      	ret
  1280                                  
  1281                                  	
  1282                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
  1283                                  	
  1284                                  print_pallet:
  1285                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
  1286 0000095E 4C8B05(3F140000)            mov r8, [pallet_position]
  1287 00000965 488B0D(57140000)            mov rcx, [extended_pallet_size]
  1288                                      .clear_pallet:
  1289 0000096C 41C60020                        mov byte [r8], char_space
  1290 00000970 49FFC0                          inc r8
  1291 00000973 48FFC9                          dec rcx
  1292 00000976 75F4                            jnz .clear_pallet
  1293                                  
  1294                                      ; Luego dibujar la nueva paleta con el tamaño actual
  1295 00000978 4C8B05(3F140000)            mov r8, [pallet_position]
  1296 0000097F 488B0D(47140000)            mov rcx, [pallet_size]
  1297                                      .write_pallet:
  1298 00000986 41C6003D                        mov byte [r8], char_equal
  1299 0000098A 49FFC0                          inc r8
  1300 0000098D 48FFC9                          dec rcx
  1301 00000990 75F4                            jnz .write_pallet
  1302                                  
  1303 00000992 C3                          ret
  1304                                  
  1305                                  move_pallet:
  1306                                      
  1307 00000993 803D(7F140000)00            cmp byte [ball_moving], 0
  1308 0000099A 7507                        jne .continue_movement
  1309 0000099C C605(7F140000)01            mov byte [ball_moving], 1
  1310                                  
  1311                                      .continue_movement:
  1312 000009A3 4883FFFF                        cmp rdi, left_direction
  1313 000009A7 7531                            jne .move_right
  1314                                  
  1315                                          .move_left:
  1316                                              ; Verificar si la siguiente posición sería una X (borde izquierdo)
  1317 000009A9 4C8B05(3F140000)                    mov r8, [pallet_position]
  1318 000009B0 49FFC8                              dec r8              ; Verificar la posición a la izquierda
  1319 000009B3 418A00                              mov al, [r8]       ; Cargar el carácter en esa posición
  1320 000009B6 3C58                                cmp al, 'X'        ; Comparar si es una X
  1321 000009B8 744E                                je .end            ; Si es X, no mover
  1322                                              
  1323 000009BA 4C8B05(3F140000)                    mov r8, [pallet_position]
  1324 000009C1 4C8B0D(47140000)                    mov r9, [pallet_size]
  1325 000009C8 43C64408FF20                        mov byte [r8 + r9 - 1], char_space  ; Borrar último carácter de la paleta
  1326 000009CE 49FFC8                              dec r8
  1327 000009D1 4C8905(3F140000)                    mov [pallet_position], r8
  1328 000009D8 EB2E                                jmp .end
  1329                                              
  1330                                          .move_right:
  1331                                              ; Verificar si la siguiente posición después de la paleta sería una X
  1332 000009DA 4C8B05(3F140000)                    mov r8, [pallet_position]
  1333 000009E1 4C8B0D(47140000)                    mov r9, [pallet_size]
  1334 000009E8 4D01C8                              add r8, r9         ; Moverse al final de la paleta
  1335 000009EB 418A4002                            mov al, [r8+2]       ; Cargar el carácter en esa posición
  1336 000009EF 3C58                                cmp al, 'X'        ; Comparar si es una X
  1337 000009F1 7415                                je .end            ; Si es X, no mover
  1338                                              
  1339 000009F3 4C8B05(3F140000)                    mov r8, [pallet_position]
  1340 000009FA 41C60020                            mov byte [r8], char_space
  1341 000009FE 49FFC0                              inc r8
  1342 00000A01 4C8905(3F140000)                    mov [pallet_position], r8
  1343                                          .end:
  1344 00000A08 C3                                  ret
  1345                                  
  1346                                  
  1347                                  
  1348                                              
  1349                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1350                                  update_caught_ball_position:
  1351 00000A09 55                          push rbp
  1352 00000A0A 4889E5                      mov rbp, rsp
  1353                                      
  1354                                      ; Calcular la nueva posición de la bola basada en la paleta
  1355 00000A0D 4C8B05(3F140000)            mov r8, [pallet_position]
  1356 00000A14 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1357 00000A1B B850000000                  mov rax, column_cells + 2
  1358 00000A20 4831D2                      xor rdx, rdx
  1359 00000A23 48F7F0                      div rax                ; División para obtener X,Y
  1360                                      
  1361                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1362 00000A26 4989C1                      mov r9, rax            ; Y de la paleta
  1363 00000A29 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1364                                      
  1365                                      ; Añadir el offset guardado a la posición X
  1366 00000A2C 4889D0                      mov rax, rdx
  1367 00000A2F 480305(15180000)            add rax, [ball_catch_offset]
  1368 00000A36 488905(5F140000)            mov [ball_x_pos], rax
  1369 00000A3D 4C890D(67140000)            mov [ball_y_pos], r9
  1370                                      
  1371 00000A44 5D                          pop rbp
  1372 00000A45 C3                          ret
  1373                                  move_ball:
  1374                                  
  1375 00000A46 803D(14180000)01            cmp byte [ball_caught], 1
  1376 00000A4D 0F849D000000                je .move_with_pallet
  1377                                  
  1378 00000A53 803D(7F140000)00            cmp byte [ball_moving], 0
  1379 00000A5A 0F84B8010000                je .end
  1380                                  
  1381                                      ; Incrementar contador de velocidad
  1382 00000A60 48FF05(0B180000)            inc qword [speed_counter]
  1383                                      
  1384                                      ; Verificar si debemos mover la bola en este ciclo
  1385 00000A67 488B05(0B180000)            mov rax, [speed_counter]
  1386 00000A6E 483B05(FB170000)            cmp rax, [ball_speed]
  1387 00000A75 0F8C9D010000                jl .end
  1388                                      
  1389                                      ; Resetear contador de velocidad
  1390 00000A7B 48C705(0B180000)00-         mov qword [speed_counter], 0
  1390 00000A83 000000             
  1391                                  
  1392                                      ; Borrar la posición actual de la bola
  1393 00000A86 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1394 00000A8D 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1395 00000A94 4981C0[000A0000]            add r8, board
  1396 00000A9B 4C89C9                      mov rcx, r9
  1397 00000A9E B850000000                  mov rax, column_cells + 2
  1398 00000AA3 48F7E9                      imul rcx
  1399 00000AA6 4901C0                      add r8, rax
  1400 00000AA9 41C60020                    mov byte [r8], char_space
  1401                                  
  1402                                      ; Calcular siguiente posición X
  1403 00000AAD 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1404 00000AB4 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1405 00000ABB 488B05(6F140000)            mov rax, [ball_direction_x]
  1406 00000AC2 4901C0                      add r8, rax               ; Nueva posición X
  1407                                  
  1408                                      ; Calcular la dirección de memoria para la siguiente posición
  1409 00000AC5 4D89C2                      mov r10, r8
  1410 00000AC8 4981C2[000A0000]            add r10, board
  1411 00000ACF 4C89C9                      mov rcx, r9
  1412 00000AD2 B850000000                  mov rax, column_cells + 2
  1413 00000AD7 48F7E9                      imul rcx
  1414 00000ADA 4901C2                      add r10, rax
  1415                                  
  1416                                      ; Verificar si hay una X en la siguiente posición X
  1417 00000ADD 418A02                      mov al, [r10]
  1418 00000AE0 3C58                        cmp al, 'X'
  1419 00000AE2 7565                        jne .check_block_x
  1420 00000AE4 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1421 00000AEB E928010000                  jmp .end
  1422                                  
  1423                                      .move_with_pallet:
  1424                                          ; Borrar la posición actual de la bola
  1425 00000AF0 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1426 00000AF7 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1427 00000AFE 4D89C2                          mov r10, r8
  1428 00000B01 4981C2[000A0000]                add r10, board
  1429 00000B08 4C89C9                          mov rcx, r9
  1430 00000B0B B850000000                      mov rax, column_cells + 2
  1431 00000B10 48F7E9                          imul rcx
  1432 00000B13 4901C2                          add r10, rax
  1433 00000B16 41C60220                        mov byte [r10], char_space
  1434                                  
  1435                                          ; Actualizar posición X basada en la paleta
  1436 00000B1A 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1437 00000B21 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1438 00000B28 4C0305(15180000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1439 00000B2F 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1440                                  
  1441                                          ; Mantener la bola una posición arriba de la paleta
  1442 00000B36 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1443 00000B3D 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1444                                  
  1445 00000B44 E9CF000000                      jmp .end
  1446                                  
  1447                                  
  1448                                      .check_block_x:
  1449                                          ; Verificar colisión con bloques en X
  1450 00000B49 4150                            push r8     ; Guardar registros que usa check_block_collision
  1451 00000B4B 4151                            push r9
  1452 00000B4D 4152                            push r10
  1453 00000B4F E8DB060000                      call check_block_collision
  1454 00000B54 415A                            pop r10
  1455 00000B56 4159                            pop r9
  1456 00000B58 4158                            pop r8
  1457 00000B5A 4885C0                          test rax, rax
  1458 00000B5D 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1459 00000B5F 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1460 00000B66 E9AD000000                      jmp .end
  1461                                  
  1462                                      .check_paddle_x:
  1463                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1464 00000B6B 41803A3D                        cmp byte [r10], char_equal
  1465 00000B6F 750C                            jne .check_y_movement
  1466 00000B71 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1467 00000B78 E99B000000                      jmp .end
  1468                                  
  1469                                      .check_y_movement:
  1470                                          ; Calcular siguiente posición Y
  1471 00000B7D 488B05(77140000)                mov rax, [ball_direction_y]
  1472 00000B84 4901C1                          add r9, rax                  ; Nueva posición Y
  1473                                  
  1474                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1475 00000B87 4D89C2                          mov r10, r8
  1476 00000B8A 4981C2[000A0000]                add r10, board
  1477 00000B91 4C89C9                          mov rcx, r9
  1478 00000B94 B850000000                      mov rax, column_cells + 2
  1479 00000B99 48F7E9                          imul rcx
  1480 00000B9C 4901C2                          add r10, rax
  1481                                  
  1482                                          ; Verificar si hay una X en la siguiente posición Y
  1483 00000B9F 418A02                          mov al, [r10]
  1484 00000BA2 3C58                            cmp al, 'X'
  1485 00000BA4 7509                            jne .check_block_y
  1486 00000BA6 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1487 00000BAD EB69                            jmp .end
  1488                                  
  1489                                      .check_block_y:
  1490                                          ; Verificar colisión con bloques en Y
  1491 00000BAF 4150                            push r8     ; Guardar registros que usa check_block_collision
  1492 00000BB1 4151                            push r9
  1493 00000BB3 4152                            push r10
  1494 00000BB5 E875060000                      call check_block_collision
  1495 00000BBA 415A                            pop r10
  1496 00000BBC 4159                            pop r9
  1497 00000BBE 4158                            pop r8
  1498 00000BC0 4885C0                          test rax, rax
  1499 00000BC3 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1500 00000BC5 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1501 00000BCC EB4A                            jmp .end
  1502                                  
  1503                                      .check_paddle_y:
  1504                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1505 00000BCE 41803A3D                        cmp byte [r10], char_equal
  1506 00000BD2 7536                            jne .update_position
  1507                                  
  1508                                          ; Verificar si el poder catch está activo
  1509 00000BD4 803D(13180000)01                cmp byte [catch_power_active], 1
  1510 00000BDB 7524                            jne .normal_bounce
  1511                                  
  1512                                          ; Activar el modo "atrapado"
  1513 00000BDD C605(14180000)01                mov byte [ball_caught], 1
  1514                                          
  1515                                          ; Guardar la posición X actual de la bola como offset
  1516 00000BE4 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1517 00000BEB 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1518 00000BF2 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1519 00000BF8 488905(15180000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1520                                          
  1521 00000BFF EB17                            jmp .end
  1522                                  
  1523                                      .normal_bounce:
  1524 00000C01 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1525 00000C08 EB0E                            jmp .end
  1526                                  
  1527                                  
  1528                                      .update_position:
  1529 00000C0A 4C8905(5F140000)                mov [ball_x_pos], r8
  1530 00000C11 4C890D(67140000)                mov [ball_y_pos], r9
  1531                                  
  1532                                      .end:
  1533 00000C18 C3                              ret
  1534                                  
  1535                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1536                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1537                                  process_catch_release:
  1538 00000C19 55                          push rbp
  1539 00000C1A 4889E5                      mov rbp, rsp
  1540                                  
  1541                                      ; Verificar si la bola está atrapada
  1542 00000C1D 803D(14180000)00            cmp byte [ball_caught], 0
  1543 00000C24 7436                        je .end
  1544                                  
  1545                                      ; Verificar si el poder catch está activo
  1546 00000C26 803D(13180000)01            cmp byte [catch_power_active], 1
  1547 00000C2D 752D                        jne .end
  1548                                  
  1549                                      ; Verificar si se presionó la tecla 'c'
  1550 00000C2F 803D(1D180000)63            cmp byte [last_key], 'c'
  1551 00000C36 7524                        jne .end
  1552                                  
  1553                                      ; Liberar la bola y asignar dirección inicial
  1554 00000C38 C605(14180000)00            mov byte [ball_caught], 0
  1555 00000C3F 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1555 00000C47 000000             
  1556 00000C4A 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1556 00000C52 FFFFFF             
  1557                                  
  1558                                      ; Limpiar la tecla procesada
  1559 00000C55 C605(1D180000)00            mov byte [last_key], 0
  1560                                  
  1561                                      .end:
  1562 00000C5C 5D                              pop rbp
  1563 00000C5D C3                              ret
  1564                                  
  1565                                  
  1566                                  display_level_number:
  1567 00000C5E 55                          push rbp
  1568 00000C5F 4889E5                      mov rbp, rsp
  1569                                      
  1570                                      ; Limpiar la pantalla primero
  1571                                      print clear, clear_length
    82 00000C62 B801000000          <1>  mov eax, sys_write
    83 00000C67 BF01000000          <1>  mov edi, 1
    84 00000C6C 48BE-               <1>  mov rsi, %1
    84 00000C6E [1000000000000000]  <1>
    85 00000C76 BA07000000          <1>  mov edx, %2
    86 00000C7B 0F05                <1>  syscall
  1572                                      
  1573                                      ; Calcular la posición central para el mensaje
  1574                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1575 00000C7D B84E000000                  mov rax, column_cells
  1576 00000C82 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1577 00000C86 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1578                                      
  1579                                      ; Calcular la fila central
  1580 00000C89 BB20000000                  mov rbx, row_cells
  1581 00000C8E 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1582                                      
  1583                                      ; Calcular el offset en el buffer
  1584 00000C91 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1585 00000C96 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1586 00000C99 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1587                                      
  1588                                      ; Escribir "NIVEL " en la posición calculada
  1589 00000C9C 488DB8[000A0000]            lea rdi, [board + rax]
  1590 00000CA3 48BE-                       mov rsi, level_msg
  1590 00000CA5 [2414000000000000] 
  1591 00000CAD B906000000                  mov rcx, level_msg_len
  1592 00000CB2 F3A4                        rep movsb
  1593                                      
  1594                                      ; Escribir el número del nivel
  1595 00000CB4 8A05(B4140000)              mov al, [current_level]
  1596 00000CBA 0430                        add al, '0'                 ; convertir a ASCII
  1597 00000CBC 8807                        mov [rdi], al
  1598                                      
  1599                                      ; Mostrar el board con el mensaje
  1600                                      print board, board_size
    82 00000CBE B801000000          <1>  mov eax, sys_write
    83 00000CC3 BF01000000          <1>  mov edi, 1
    84 00000CC8 48BE-               <1>  mov rsi, %1
    84 00000CCA [000A000000000000]  <1>
    85 00000CD2 BA000A0000          <1>  mov edx, %2
    86 00000CD7 0F05                <1>  syscall
  1601                                      
  1602                                      ; Esperar un segundo
  1603 00000CD9 B823000000                  mov rax, sys_nanosleep
  1604 00000CDE 48BF-                       mov rdi, level_display_time
  1604 00000CE0 [2F14000000000000] 
  1605 00000CE8 4831F6                      xor rsi, rsi
  1606 00000CEB 0F05                        syscall
  1607                                      
  1608 00000CED 5D                          pop rbp
  1609 00000CEE C3                          ret
  1610                                  
  1611                                  ; Función para inicializar un tablero vacío
  1612                                  init_empty_board:
  1613 00000CEF 56                          push rsi
  1614 00000CF0 57                          push rdi
  1615 00000CF1 51                          push rcx
  1616 00000CF2 50                          push rax
  1617                                  
  1618 00000CF3 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1619 00000CFA 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1620 00000D01 B9000A0000                  mov rcx, board_template_size
  1621 00000D06 F3A4                        rep movsb                   ; Copiar el tablero
  1622                                  
  1623 00000D08 58                          pop rax
  1624 00000D09 59                          pop rcx
  1625 00000D0A 5F                          pop rdi
  1626 00000D0B 5E                          pop rsi
  1627 00000D0C C3                          ret
  1628                                  
  1629                                  
  1630                                  init_level:
  1631                                  
  1632 00000D0D 488B05(4F140000)            mov rax, [default_pallet_size]
  1633 00000D14 488905(47140000)            mov [pallet_size], rax
  1634 00000D1B 48C705(FB170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1634 00000D23 000000             
  1635                                  
  1636                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1637                                          ; Reiniciar letras activas
  1638 00000D26 488D3D(54160000)            lea rdi, [letters_map]
  1639 00000D2D B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1640 00000D32 4831C0                      xor rax, rax
  1641 00000D35 F3AA                        rep stosb                    ; Llenar con ceros
  1642                                      
  1643                                      ; Inicializar dirección de la bola (derecha y arriba)
  1644 00000D37 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1644 00000D3F 000000             
  1645 00000D42 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1645 00000D4A FFFFFF             
  1646                                  
  1647                                  
  1648                                      ; Reiniciar contador de letras activas
  1649 00000D4D 4831C0                      xor rax, rax
  1650 00000D50 8805(E4170000)              mov [letters_count], al
  1651                                  
  1652                                      ; Reiniciar última letra capturada
  1653 00000D56 C605(E5170000)20            mov byte [last_letter], ' '
  1654 00000D5D C605(5E150000)00            mov byte [destroyed_blocks], 0 
  1655 00000D64 E886FFFFFF                  call init_empty_board
  1656 00000D69 E8F0FEFFFF                  call display_level_number
  1657 00000D6E E8E5050000                  call init_enemies
  1658                                      
  1659 00000D73 56                          push rsi
  1660 00000D74 57                          push rdi
  1661 00000D75 51                          push rcx
  1662 00000D76 50                          push rax
  1663                                  
  1664 00000D77 488D35(00000000)            lea rsi, [board_template]
  1665 00000D7E 488D3D(000A0000)            lea rdi, [board]
  1666 00000D85 B9000A0000                  mov rcx, board_template_size
  1667 00000D8A F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1668                                  
  1669 00000D8C 58                          pop rax
  1670 00000D8D 59                          pop rcx
  1671 00000D8E 5F                          pop rdi
  1672 00000D8F 5E                          pop rsi
  1673                                  
  1674 00000D90 B90A000000                  mov rcx, 10
  1675 00000D95 4831C0                      xor rax, rax
  1676 00000D98 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  1677 00000D9F F3AA                        rep stosb      
  1678                                  
  1679                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1680 00000DA1 803D(B4140000)01            cmp byte [current_level], 1
  1681 00000DA8 7431                        je .level1
  1682 00000DAA 803D(B4140000)02            cmp byte [current_level], 2
  1683 00000DB1 7454                        je .level2
  1684 00000DB3 803D(B4140000)03            cmp byte [current_level], 3
  1685 00000DBA 7477                        je .level3
  1686 00000DBC 803D(B4140000)04            cmp byte [current_level], 4
  1687 00000DC3 0F8492000000                je .level4
  1688 00000DC9 803D(B4140000)05            cmp byte [current_level], 5
  1689 00000DD0 0F84AD000000                je .level5
  1690 00000DD6 E9D0000000                  jmp .done
  1691                                  
  1692                                  
  1693                                  
  1694                                      .level1:
  1695 00000DDB C605(B5140000)08                mov byte [blocks_remaining], level1_blocks_count
  1696 00000DE2 4831C9                          xor rcx, rcx             
  1697                                          .init_loop1:
  1698 00000DE5 4883F908                            cmp rcx, level1_blocks_count
  1699 00000DE9 0F8DBC000000                        jge .done
  1700 00000DEF 4889C8                              mov rax, rcx         
  1701 00000DF2 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1702 00000DF6 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1703 00000DFC 8891[F2140000]                      mov byte [block_states + rcx], dl
  1704 00000E02 48FFC1                              inc rcx
  1705 00000E05 EBDE                                jmp .init_loop1
  1706                                  
  1707                                      .level2:
  1708 00000E07 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1709 00000E0E 4831C9                          xor rcx, rcx             
  1710                                          .init_loop2:
  1711 00000E11 4883F901                            cmp rcx, level2_blocks_count
  1712 00000E15 0F8D90000000                        jge .done
  1713 00000E1B 4889C8                              mov rax, rcx         
  1714 00000E1E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1715 00000E22 8A90[E1140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1716 00000E28 8891[F2140000]                      mov byte [block_states + rcx], dl
  1717 00000E2E 48FFC1                              inc rcx
  1718 00000E31 EBDE                                jmp .init_loop2
  1719                                      .level3:
  1720 00000E33 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1721 00000E3A 4831C9                          xor rcx, rcx             
  1722                                          .init_loop3:
  1723 00000E3D 4883F901                            cmp rcx, level3_blocks_count
  1724 00000E41 7D68                                jge .done
  1725 00000E43 4889C8                              mov rax, rcx         
  1726 00000E46 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1727 00000E4A 8A90[E6140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1728 00000E50 8891[F2140000]                      mov byte [block_states + rcx], dl
  1729 00000E56 48FFC1                              inc rcx
  1730 00000E59 EBE2                                jmp .init_loop3
  1731                                  
  1732                                      .level4:
  1733 00000E5B C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1734 00000E62 4831C9                          xor rcx, rcx             
  1735                                          .init_loop4:
  1736 00000E65 4883F901                            cmp rcx, level4_blocks_count
  1737 00000E69 7D40                                jge .done
  1738 00000E6B 4889C8                              mov rax, rcx         
  1739 00000E6E 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1740 00000E72 8A90[EB140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1741 00000E78 8891[F2140000]                      mov byte [block_states + rcx], dl
  1742 00000E7E 48FFC1                              inc rcx
  1743 00000E81 EBE2                                jmp .init_loop4
  1744                                  
  1745                                      .level5:
  1746 00000E83 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1747 00000E8A 4831C9                          xor rcx, rcx             
  1748                                          .init_loop5:
  1749 00000E8D 4883F901                            cmp rcx, level5_blocks_count
  1750 00000E91 7D18                                jge .done
  1751 00000E93 4889C8                              mov rax, rcx         
  1752 00000E96 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1753 00000E9A 8A90[F0140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1754 00000EA0 8891[F2140000]                      mov byte [block_states + rcx], dl
  1755 00000EA6 48FFC1                              inc rcx
  1756 00000EA9 EBE2                                jmp .init_loop5
  1757                                      .done:
  1758 00000EAB C3                              ret
  1759                                  
  1760                                  
  1761                                  ; Función para verificar y manejar la transición de nivel
  1762                                  check_level_complete:
  1763                                      ; Verificar si quedan bloques
  1764 00000EAC 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1765 00000EB3 753C                        jne .not_complete
  1766                                      
  1767                                      ; Incrementar el nivel
  1768 00000EB5 FE05(B4140000)              inc byte [current_level]
  1769                                      
  1770                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1771 00000EBB 803D(B4140000)06            cmp byte [current_level], 6
  1772 00000EC2 742E                        je game_win
  1773                                      
  1774                                      ; Reinicializar el juego para el siguiente nivel
  1775 00000EC4 E844FEFFFF                  call init_level
  1776                                      
  1777                                      ; Reinicializar la posición de la bola y la paleta
  1778 00000EC9 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1778 00000ED1 000000             
  1779 00000ED4 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1779 00000EDC 000000             
  1780 00000EDF C605(7F140000)00            mov byte [ball_moving], 0
  1781 00000EE6 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1781 00000EED [36130000]         
  1782                                      
  1783                                      .not_complete:
  1784 00000EF1 C3                              ret
  1785                                  
  1786                                      ; Nueva función para manejar la victoria del juego
  1787                                  game_win:
  1788                                      ; Limpiar la pantalla primero
  1789                                      print clear, clear_length
    82 00000EF2 B801000000          <1>  mov eax, sys_write
    83 00000EF7 BF01000000          <1>  mov edi, 1
    84 00000EFC 48BE-               <1>  mov rsi, %1
    84 00000EFE [1000000000000000]  <1>
    85 00000F06 BA07000000          <1>  mov edx, %2
    86 00000F0B 0F05                <1>  syscall
  1790                                      
  1791                                      ; Mensaje de victoria
  1792 00000F0D 488B05(56150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1793 00000F14 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1793 00000F16 [5F15000000000000] 
  1794 00000F1E E8B4010000                  call number_to_string
  1795                                      
  1796                                      ; Definir mensaje de victoria
  1797                                      section .data
  1798 00001901 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1798 0000190A 616465732120C2A148-
  1798 00001913 61732067616E61646F-
  1798 0000191C 210A0D             
  1799                                          win_msg_len: equ $ - win_msg
  1800 0000191F 50756E74616A652066-             score_msg: db "Puntaje final: "
  1800 00001928 696E616C3A20       
  1801                                          score_msg_len: equ $ - score_msg
  1802                                      section .text
  1803                                      
  1804                                      ; Imprimir mensajes
  1805                                      print win_msg, win_msg_len
    82 00000F23 B801000000          <1>  mov eax, sys_write
    83 00000F28 BF01000000          <1>  mov edi, 1
    84 00000F2D 48BE-               <1>  mov rsi, %1
    84 00000F2F [0119000000000000]  <1>
    85 00000F37 BA1E000000          <1>  mov edx, %2
    86 00000F3C 0F05                <1>  syscall
  1806                                      print score_msg, score_msg_len
    82 00000F3E B801000000          <1>  mov eax, sys_write
    83 00000F43 BF01000000          <1>  mov edi, 1
    84 00000F48 48BE-               <1>  mov rsi, %1
    84 00000F4A [1F19000000000000]  <1>
    85 00000F52 BA0F000000          <1>  mov edx, %2
    86 00000F57 0F05                <1>  syscall
  1807                                      print number_buffer, 20
    82 00000F59 B801000000          <1>  mov eax, sys_write
    83 00000F5E BF01000000          <1>  mov edi, 1
    84 00000F63 48BE-               <1>  mov rsi, %1
    84 00000F65 [5F15000000000000]  <1>
    85 00000F6D BA14000000          <1>  mov edx, %2
    86 00000F72 0F05                <1>  syscall
  1808                                      
  1809                                      ; Esperar un momento antes de salir
  1810 00000F74 48C70581F0FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1810 00000F7D 0000               
  1811 00000F7F 48C7057EF0FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1811 00000F88 0000               
  1812                                      sleeptime
    98 00000F8A B823000000          <1>  mov eax, sys_nanosleep
    99 00000F8F 48BF-               <1>  mov rdi, timespec
    99 00000F91 [0000000000000000]  <1>
   100 00000F99 31F6                <1>  xor esi, esi
   101 00000F9B 0F05                <1>  syscall
  1813                                      
  1814 00000F9D E929090000                  jmp exit
  1815                                  
  1816                                  ; Función para imprimir los bloques
  1817                                  ; Función modificada para imprimir bloques
  1818                                  
  1819                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1820                                  get_current_level_blocks:
  1821 00000FA2 803D(B4140000)01            cmp byte [current_level], 1
  1822 00000FA9 7428                        je .level1
  1823 00000FAB 803D(B4140000)02            cmp byte [current_level], 2
  1824 00000FB2 7427                        je .level2
  1825 00000FB4 803D(B4140000)03            cmp byte [current_level], 3
  1826 00000FBB 7426                        je .level3
  1827 00000FBD 803D(B4140000)04            cmp byte [current_level], 4
  1828 00000FC4 7425                        je .level4
  1829 00000FC6 803D(B4140000)05            cmp byte [current_level], 5
  1830 00000FCD 7424                        je .level5
  1831                                      ; Si llegamos aquí, hay un error en el nivel
  1832 00000FCF 4831C0                      xor rax, rax
  1833 00000FD2 C3                          ret
  1834                                  
  1835                                      .level1:
  1836 00000FD3 488D05(B6140000)                lea rax, [level1_blocks]
  1837 00000FDA C3                              ret
  1838                                      .level2:
  1839 00000FDB 488D05(DE140000)                lea rax, [level2_blocks]
  1840 00000FE2 C3                              ret
  1841                                      .level3:
  1842 00000FE3 488D05(E3140000)                lea rax, [level3_blocks]
  1843 00000FEA C3                              ret
  1844                                      .level4:
  1845 00000FEB 488D05(E8140000)                lea rax, [level4_blocks]
  1846 00000FF2 C3                              ret
  1847                                      .level5:
  1848 00000FF3 488D05(ED140000)                lea rax, [level5_blocks]
  1849 00000FFA C3                              ret
  1850                                  ; Función para obtener la cantidad de bloques del nivel actual
  1851                                  get_current_level_count:
  1852 00000FFB 803D(B4140000)01            cmp byte [current_level], 1
  1853 00001002 7428                        je .level1
  1854 00001004 803D(B4140000)02            cmp byte [current_level], 2
  1855 0000100B 7425                        je .level2
  1856 0000100D 803D(B4140000)03            cmp byte [current_level], 3
  1857 00001014 7422                        je .level3
  1858 00001016 803D(B4140000)04            cmp byte [current_level], 4
  1859 0000101D 741F                        je .level4
  1860 0000101F 803D(B4140000)05            cmp byte [current_level], 5
  1861 00001026 741C                        je .level5
  1862                                      ; Si llegamos aquí, hay un error en el nivel
  1863 00001028 4831C0                      xor rax, rax
  1864 0000102B C3                          ret
  1865                                  
  1866                                      .level1:
  1867 0000102C B808000000                      mov rax, level1_blocks_count
  1868 00001031 C3                              ret
  1869                                      .level2:
  1870 00001032 B801000000                      mov rax, level2_blocks_count
  1871 00001037 C3                              ret
  1872                                      .level3:
  1873 00001038 B801000000                      mov rax, level3_blocks_count
  1874 0000103D C3                              ret
  1875                                      .level4:
  1876 0000103E B801000000                      mov rax, level4_blocks_count
  1877 00001043 C3                              ret
  1878                                      .level5:
  1879 00001044 B801000000                      mov rax, level5_blocks_count
  1880 00001049 C3                              ret
  1881                                  
  1882                                  
  1883                                  print_blocks:
  1884 0000104A 55                          push rbp
  1885 0000104B 4889E5                      mov rbp, rsp
  1886                                      
  1887                                      ; Obtener puntero a los bloques del nivel actual
  1888 0000104E E84FFFFFFF                  call get_current_level_blocks
  1889 00001053 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1890                                      
  1891                                      ; Obtener cantidad de bloques del nivel actual
  1892 00001056 E8A0FFFFFF                  call get_current_level_count
  1893 0000105B 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1894                                      
  1895 0000105E 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1896                                      
  1897                                      .print_loop:
  1898 00001061 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1899 00001064 7D6F                            jge .end
  1900                                          
  1901                                          ; Verificar si el bloque está activo
  1902 00001066 490FB68424-                     movzx rax, byte [block_states + r12]
  1902 0000106B [F2140000]         
  1903 0000106F 4885C0                          test rax, rax
  1904 00001072 745C                            jz .next_block
  1905                                          
  1906                                          ; Obtener posición y tipo del bloque usando r13
  1907 00001074 4C89E0                          mov rax, r12
  1908 00001077 486BC005                        imul rax, 5
  1909 0000107B 4C01E8                          add rax, r13
  1910 0000107E 448A00                          mov r8b, [rax]        ; X position
  1911 00001081 448A4801                        mov r9b, [rax + 1]    ; Y position
  1912 00001085 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1913                                  
  1914                                          ; El resto de la lógica de impresión permanece igual
  1915 00001089 4D0FB6C0                        movzx r8, r8b
  1916 0000108D 4D0FB6C9                        movzx r9, r9b
  1917 00001091 4981C0[000A0000]                add r8, board
  1918 00001098 B850000000                      mov rax, column_cells + 2
  1919 0000109D 49F7E1                          mul r9
  1920 000010A0 4901C0                          add r8, rax
  1921                                          
  1922 000010A3 B906000000                      mov rcx, block_length
  1923 000010A8 48BE-                           mov rsi, block_type_1
  1923 000010AA [9014000000000000] 
  1924 000010B2 490FB6C2                        movzx rax, r10b
  1925 000010B6 48FFC8                          dec rax
  1926 000010B9 486BC006                        imul rax, block_length
  1927 000010BD 4801C6                          add rsi, rax
  1928                                          
  1929                                      .print_block_chars:
  1930 000010C0 8A06                            mov al, [rsi]
  1931 000010C2 418800                          mov [r8], al
  1932 000010C5 48FFC6                          inc rsi
  1933 000010C8 49FFC0                          inc r8
  1934 000010CB 48FFC9                          dec rcx
  1935 000010CE 75F0                            jnz .print_block_chars
  1936                                          
  1937                                      .next_block:
  1938 000010D0 49FFC4                          inc r12
  1939 000010D3 EB8C                            jmp .print_loop
  1940                                          
  1941                                      .end:
  1942 000010D5 5D                              pop rbp
  1943 000010D6 C3                              ret
  1944                                  
  1945                                  ; Función para convertir número a string
  1946                                  ; Input: RAX = número a convertir
  1947                                  ; RDI = buffer donde escribir el string
  1948                                  number_to_string:
  1949 000010D7 53                          push rbx
  1950 000010D8 52                          push rdx
  1951 000010D9 56                          push rsi
  1952 000010DA BB0A000000                  mov rbx, 10          ; Divisor
  1953 000010DF B900000000                  mov rcx, 0          ; Contador de dígitos
  1954                                      
  1955                                      ; Si el número es 0, manejarlo especialmente
  1956 000010E4 4885C0                      test rax, rax
  1957 000010E7 7509                        jnz .convert_loop
  1958 000010E9 C60730                      mov byte [rdi], '0'
  1959 000010EC C6470100                    mov byte [rdi + 1], 0
  1960 000010F0 EB20                        jmp .end
  1961                                      
  1962                                      .convert_loop:
  1963 000010F2 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1964 000010F5 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1965 000010F8 80C230                          add dl, '0'     ; Convertir a ASCII
  1966 000010FB 52                              push rdx        ; Guardar el dígito
  1967 000010FC 48FFC1                          inc rcx         ; Incrementar contador
  1968 000010FF 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1969 00001102 75EE                            jnz .convert_loop
  1970                                          
  1971                                      .write_loop:
  1972 00001104 5A                              pop rdx         ; Obtener dígito
  1973 00001105 8817                            mov [rdi], dl   ; Escribir al buffer
  1974 00001107 48FFC7                          inc rdi         ; Siguiente posición
  1975 0000110A 48FFC9                          dec rcx         ; Decrementar contador
  1976 0000110D 75F5                            jnz .write_loop
  1977                                          
  1978 0000110F C60700                      mov byte [rdi], 0   ; Null terminator
  1979                                      
  1980                                      .end:
  1981 00001112 5E                          pop rsi
  1982 00001113 5A                          pop rdx
  1983 00001114 5B                          pop rbx
  1984 00001115 C3                          ret
  1985                                  
  1986                                  ; Función para imprimir los labels
  1987                                  print_labels:
  1988 00001116 55                          push rbp
  1989 00001117 4889E5                      mov rbp, rsp
  1990                                  
  1991                                      ; Crear buffer temporal
  1992 0000111A 4883EC20                    sub rsp, 32
  1993                                  
  1994                                      ; Copiar labels a buffer temporal
  1995 0000111E 4889E7                      mov rdi, rsp
  1996 00001121 488D35(0B160000)            lea rsi, [score_label]
  1997 00001128 B917000000                  mov rcx, score_label_len
  1998 0000112D F3A4                        rep movsb
  1999                                  
  2000                                      ; Convertir score a string
  2001 0000112F 488B05(56150000)            mov rax, [current_score]
  2002 00001136 48BF-                       mov rdi, number_buffer
  2002 00001138 [5F15000000000000] 
  2003 00001140 E892FFFFFF                  call number_to_string
  2004                                  
  2005                                      ; Calcular longitud del número
  2006 00001145 B900000000                  mov rcx, 0
  2007 0000114A 48BF-                       mov rdi, number_buffer
  2007 0000114C [5F15000000000000] 
  2008                                      .count_loop:
  2009 00001154 803C0F00                        cmp byte [rdi + rcx], 0
  2010 00001158 7405                            je .count_done
  2011 0000115A 48FFC1                          inc rcx
  2012 0000115D EBF5                            jmp .count_loop
  2013                                      .count_done:
  2014                                  
  2015                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2016 0000115F 4889E7                      mov rdi, rsp
  2017 00001162 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  2018 00001166 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  2019 0000116B 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  2020                                      .pad_loop:
  2021 0000116E 4885F6                          test rsi, rsi
  2022 00001171 740B                            jz .pad_done
  2023 00001173 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2024 00001176 48FFC7                          inc rdi
  2025 00001179 48FFCE                          dec rsi
  2026 0000117C EBF0                            jmp .pad_loop
  2027                                      .pad_done:
  2028                                  
  2029                                      ; Copiar el número
  2030 0000117E 48BE-                       mov rsi, number_buffer
  2030 00001180 [5F15000000000000] 
  2031 00001188 F3A4                        rep movsb
  2032                                  
  2033                                      ; Imprimir el buffer completo
  2034                                      print rsp, score_label_len
    82 0000118A B801000000          <1>  mov eax, sys_write
    83 0000118F BF01000000          <1>  mov edi, 1
    84 00001194 4889E6              <1>  mov rsi, %1
    85 00001197 BA17000000          <1>  mov edx, %2
    86 0000119C 0F05                <1>  syscall
  2035                                  
  2036                                      ; Repetir proceso para bloques destruidos
  2037 0000119E 4889E7                      mov rdi, rsp
  2038 000011A1 488D35(22160000)            lea rsi, [blocks_label]
  2039 000011A8 B91B000000                  mov rcx, blocks_label_len
  2040 000011AD F3A4                        rep movsb
  2041                                  
  2042                                      ; Verificar que el `[` esté en su posición correcta
  2043 000011AF 4889E7                      mov rdi, rsp
  2044 000011B2 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  2045 000011B6 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  2046                                  
  2047                                      ; Convertir bloques destruidos a string
  2048 000011B9 480FB605(5E150000)          movzx rax, byte [destroyed_blocks]
  2049 000011C1 48BF-                       mov rdi, number_buffer
  2049 000011C3 [5F15000000000000] 
  2050 000011CB E807FFFFFF                  call number_to_string
  2051                                  
  2052                                      ; Calcular longitud del número
  2053 000011D0 B900000000                  mov rcx, 0
  2054 000011D5 48BF-                       mov rdi, number_buffer
  2054 000011D7 [5F15000000000000] 
  2055                                      .count_loop2:
  2056 000011DF 803C0F00                        cmp byte [rdi + rcx], 0
  2057 000011E3 7405                            je .count_done2
  2058 000011E5 48FFC1                          inc rcx
  2059 000011E8 EBF5                            jmp .count_loop2
  2060                                      .count_done2:
  2061                                  
  2062                                      ; Insertar el número en la posición correcta, alineado a la derecha
  2063 000011EA 4889E7                      mov rdi, rsp
  2064 000011ED 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  2065 000011F1 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  2066 000011F6 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  2067                                      .pad_loop2:
  2068 000011F9 4885F6                          test rsi, rsi
  2069 000011FC 740B                            jz .pad_done2
  2070 000011FE C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  2071 00001201 48FFC7                          inc rdi
  2072 00001204 48FFCE                          dec rsi
  2073 00001207 EBF0                            jmp .pad_loop2
  2074                                      .pad_done2:
  2075                                  
  2076                                      ; Copiar el número
  2077 00001209 48BE-                       mov rsi, number_buffer
  2077 0000120B [5F15000000000000] 
  2078 00001213 F3A4                        rep movsb
  2079                                  
  2080                                      ; Imprimir el buffer completo
  2081                                      print rsp, blocks_label_len
    82 00001215 B801000000          <1>  mov eax, sys_write
    83 0000121A BF01000000          <1>  mov edi, 1
    84 0000121F 4889E6              <1>  mov rsi, %1
    85 00001222 BA1B000000          <1>  mov edx, %2
    86 00001227 0F05                <1>  syscall
  2082                                  
  2083                                      ; Restaurar stack
  2084 00001229 4883C420                    add rsp, 32
  2085 0000122D 5D                          pop rbp
  2086 0000122E C3                          ret
  2087                                  
  2088                                  
  2089                                  
  2090                                  check_block_collision:
  2091 0000122F 55                          push rbp
  2092 00001230 4889E5                      mov rbp, rsp
  2093                                  
  2094                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  2095 00001233 418A02                      mov al, [r10]
  2096                                  
  2097                                      ; Verificar si el carácter es un bloque
  2098 00001236 3C55                        cmp al, 'U'  
  2099 00001238 7419                        je .possible
  2100 0000123A 3C4F                        cmp al, 'O'  
  2101 0000123C 7415                        je .possible
  2102 0000123E 3C44                        cmp al, 'D'  
  2103 00001240 7411                        je .possible
  2104 00001242 3C4C                        cmp al, 'L'  
  2105 00001244 740D                        je .possible
  2106 00001246 3C56                        cmp al, 'V'  
  2107 00001248 7409                        je .possible
  2108 0000124A 3C38                        cmp al, '8'  
  2109 0000124C 7405                        je .possible
  2110                                  
  2111                                      ; No es bloque, salir
  2112 0000124E 4831C0                      xor rax, rax
  2113 00001251 5D                          pop rbp
  2114 00001252 C3                          ret
  2115                                  
  2116                                  .possible:
  2117 00001253 53                          push rbx
  2118 00001254 57                          push rdi
  2119 00001255 56                          push rsi
  2120 00001256 4154                        push r12
  2121 00001258 4155                        push r13
  2122 0000125A 4156                        push r14
  2123 0000125C 4157                        push r15
  2124                                  
  2125                                      ; 1) Obtener base de los bloques del nivel actual
  2126 0000125E E83FFDFFFF                  call get_current_level_blocks
  2127 00001263 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  2128                                  
  2129                                      ; 2) Obtener la cantidad de bloques
  2130 00001266 E890FDFFFF                  call get_current_level_count
  2131 0000126B 4989C6                      mov r14, rax
  2132                                  
  2133 0000126E 4D31E4                      xor r12, r12  ; Índice del bloque actual
  2134                                  
  2135                                  .find_block_loop:
  2136 00001271 4D39F4                      cmp r12, r14
  2137 00001274 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  2138                                  
  2139                                      ; Calcular puntero base del bloque actual en levelX_blocks
  2140 0000127A 4C89E0                      mov rax, r12
  2141 0000127D 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  2142 00001281 4C01E8                      add rax, r13
  2143 00001284 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  2144                                  
  2145                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  2146 00001287 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  2146 0000128C [F2140000]         
  2147 00001290 4885DB                      test rbx, rbx
  2148 00001293 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  2149                                  
  2150                                      ; Obtener coordenadas
  2151 00001299 418A17                      mov dl, [r15]         ; x
  2152 0000129C 418A4F01                    mov cl, [r15 + 1]     ; y
  2153                                  
  2154                                      ; Calcular posición en el board
  2155 000012A0 488D3D(000A0000)            lea rdi, [board]
  2156 000012A7 4831C0                      xor rax, rax
  2157 000012AA B84E000000                  mov rax, column_cells
  2158 000012AF 4883C002                    add rax, 2
  2159 000012B3 480FB6C9                    movzx rcx, cl         ; y
  2160 000012B7 480FAFC1                    imul rax, rcx
  2161 000012BB 4801C7                      add rdi, rax
  2162 000012BE 480FB6C2                    movzx rax, dl         ; x
  2163 000012C2 4801C7                      add rdi, rax
  2164                                  
  2165                                      ; Guardar la posición base del bloque
  2166 000012C5 57                          push rdi
  2167                                  
  2168                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  2169 000012C6 4939FA                      cmp r10, rdi
  2170 000012C9 7274                        jb .skip_collision
  2171 000012CB 488D5F06                    lea rbx, [rdi + block_length]
  2172 000012CF 4939DA                      cmp r10, rbx
  2173 000012D2 736B                        jae .skip_collision
  2174                                  
  2175                                      ; ------- Hay colisión, reducir durabilidad en block_states
  2176 000012D4 41FE8C24[F2140000]          dec byte [block_states + r12]
  2177                                      ; Volver a cargar durabilidad
  2178 000012DC 490FB69C24-                 movzx rbx, byte [block_states + r12]
  2178 000012E1 [F2140000]         
  2179 000012E5 4885DB                      test rbx, rbx
  2180 000012E8 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  2181                                  
  2182                                      ; >>> Llegó a 0 => Bloque destruido
  2183 000012EA 5F                          pop rdi  ; recuperar puntero base del bloque en board
  2184 000012EB B906000000                  mov rcx, block_length
  2185                                  .clear_loop:
  2186 000012F0 C60720                      mov byte [rdi], ' '
  2187 000012F3 48FFC7                      inc rdi
  2188 000012F6 E2F8                        loop .clear_loop
  2189                                  
  2190                                      ; Dibujar letra del bloque destruido
  2191 000012F8 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  2192 000012FC 4883EF06                    sub rdi, block_length
  2193 00001300 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  2194                                      ; Después de escribir la letra en el tablero
  2195 00001302 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  2196 00001306 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  2197 0000130A 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  2198 0000130F E892F0FFFF                  call register_letter
  2199                                      ; Actualizar contadores globales
  2200 00001314 FE0D(B5140000)              dec byte [blocks_remaining]
  2201 0000131A FE05(5E150000)              inc byte [destroyed_blocks]
  2202                                  
  2203                                      ; Sumar puntos según el tipo
  2204 00001320 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  2205 00001325 486BC00A                    imul rax, 10
  2206 00001329 480105(56150000)            add [current_score], rax
  2207                                  
  2208 00001330 B801000000                  mov rax, 1  ; colisión con destrucción
  2209 00001335 EB14                        jmp .end_pop
  2210                                  
  2211                                  .update_display:
  2212                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  2213 00001337 B801000000                  mov rax, 1  ; colisión con "rebote"  
  2214 0000133C 5F                          pop rdi     ; pop que quedó pendiente
  2215 0000133D EB0C                        jmp .end_pop
  2216                                  
  2217                                  .skip_collision:
  2218 0000133F 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  2219                                  .next_block:
  2220 00001340 49FFC4                      inc r12
  2221 00001343 E929FFFFFF                  jmp .find_block_loop
  2222                                  
  2223                                  .no_block_found:
  2224 00001348 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  2225                                  
  2226                                  .end_pop:
  2227 0000134B 415F                        pop r15
  2228 0000134D 415E                        pop r14
  2229 0000134F 415D                        pop r13
  2230 00001351 415C                        pop r12
  2231 00001353 5E                          pop rsi
  2232 00001354 5F                          pop rdi
  2233 00001355 5B                          pop rbx
  2234 00001356 5D                          pop rbp
  2235 00001357 C3                          ret
  2236                                  
  2237                                  
  2238                                  
  2239                                  init_enemies:
  2240 00001358 55                          push rbp
  2241 00001359 4889E5                      mov rbp, rsp
  2242                                      ; Reiniciar contadores de movimiento
  2243 0000135C C605(A1150000)00            mov byte [enemy_move_total], 0
  2244 00001363 C605(A2150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  2245                                      ; Limpiar estado previo de enemigos
  2246 0000136A B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  2247 0000136F 488D3D(78150000)            lea rdi, [enemies]
  2248 00001376 30C0                        xor al, al
  2249 00001378 F3AA                        rep stosb ; Limpiar datos de enemigos
  2250                                      
  2251                                      ; Marcar todos los enemigos como inactivos
  2252 0000137A 488D3D(01160000)            lea rdi, [enemy_spawns_triggered]
  2253 00001381 30C0                        xor al, al
  2254 00001383 B90A000000                  mov rcx, 10
  2255 00001388 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  2256                                  
  2257 0000138A 5D                          pop rbp
  2258 0000138B C3                          ret
  2259                                  
  2260                                  
  2261                                  ; Función para mover enemigos
  2262                                  move_enemies:
  2263 0000138C 55                          push rbp
  2264 0000138D 4889E5                      mov rbp, rsp
  2265                                      
  2266                                      ; Incrementar contador de movimiento
  2267 00001390 FE05(9F150000)              inc byte [enemy_move_counter]
  2268 00001396 480FB605(9F150000)          movzx rax, byte [enemy_move_counter]
  2269 0000139E 3A05(A0150000)              cmp al, [enemy_move_delay]
  2270 000013A4 0F85AA010000                jne .end
  2271                                      
  2272                                      ; Resetear contador
  2273 000013AA C605(9F150000)00            mov byte [enemy_move_counter], 0
  2274                                      
  2275 000013B1 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2276                                      
  2277                                      .enemy_loop:
  2278 000013B4 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  2279 000013B8 0F8D96010000                    jge .end
  2280                                          
  2281                                          ; Calcular offset del enemigo actual
  2282 000013BE 4C89E0                          mov rax, r12
  2283 000013C1 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2284 000013C5 488DB0[78150000]                lea rsi, [enemies + rax]
  2285                                          
  2286                                          ; Verificar si el enemigo está activo
  2287 000013CC 807E0201                        cmp byte [rsi + 2], 1
  2288 000013D0 0F8576010000                    jne .next_enemy
  2289                                          
  2290                                          ; Obtener posición actual
  2291 000013D6 4C0FB606                        movzx r8, byte [rsi]            ; X
  2292 000013DA 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2293                                          
  2294                                          ; Limpiar posición actual antes de mover
  2295 000013DF 4150                            push r8
  2296 000013E1 4151                            push r9
  2297 000013E3 B84E000000                      mov rax, column_cells
  2298 000013E8 4883C002                        add rax, 2
  2299 000013EC 49F7E1                          mul r9
  2300 000013EF 4C01C0                          add rax, r8
  2301 000013F2 488DB8[000A0000]                lea rdi, [board + rax]
  2302 000013F9 C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  2303 000013FC 4159                            pop r9
  2304 000013FE 4158                            pop r8
  2305                                  
  2306                                          ; Determinar comportamiento basado en índice
  2307 00001400 4C89E0                          mov rax, r12
  2308 00001403 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  2309 00001407 4885C0                          test rax, rax
  2310 0000140A 7402                            jz .chase_ball
  2311 0000140C EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  2312                                          
  2313                                          ; Perseguir bola (comportamiento original)
  2314                                      .chase_ball:
  2315 0000140E 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2316 00001415 4D39D0                          cmp r8, r10
  2317 00001418 0F8F96000000                    jg .move_left
  2318 0000141E 0F8C95000000                    jl .move_right
  2319                                          
  2320 00001424 4C8B15(67140000)                mov r10, [ball_y_pos]
  2321 0000142B 4D39D1                          cmp r9, r10
  2322 0000142E 0F8F8A000000                    jg .move_up
  2323 00001434 0F8C89000000                    jl .move_down
  2324 0000143A E9A5000000                      jmp .check_collision
  2325                                          
  2326                                      .chase_paddle:
  2327                                          ; Obtener la posición X actual de la paleta
  2328 0000143F 4C8B15(3F140000)                mov r10, [pallet_position]
  2329 00001446 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2330                                          
  2331                                          ; Calcular la posición X real de la paleta
  2332 0000144D 4C89D0                          mov rax, r10
  2333 00001450 BB4E000000                      mov rbx, column_cells
  2334 00001455 4883C302                        add rbx, 2                  ; Añadir newline chars
  2335 00001459 4831D2                          xor rdx, rdx
  2336 0000145C 48F7F3                          div rbx                     ; rax = y, rdx = x
  2337                                          
  2338                                          ; rdx ahora contiene la posición X de la paleta
  2339                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2340 0000145F 488B0D(47140000)                mov rcx, [pallet_size]
  2341 00001466 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2342 00001469 4801CA                          add rdx, rcx
  2343                                          
  2344                                          ; Comparar con posición X del enemigo y mover gradualmente
  2345 0000146C 4939D0                          cmp r8, rdx
  2346 0000146F 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2347 00001471 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2348 00001473 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2349                                  
  2350                                      .check_y_paddle:
  2351                                          ; La Y de la paleta siempre es row_cells - 2
  2352 00001475 41BA20000000                    mov r10, row_cells
  2353 0000147B 4983EA02                        sub r10, 2
  2354                                          
  2355                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2356 0000147F 4D39D1                          cmp r9, r10
  2357 00001482 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2358 00001484 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2359 00001486 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2360                                          
  2361                                      .no_movement:
  2362 00001488 EB5A                            jmp .check_collision
  2363                                  
  2364                                      ; También agregar una nueva sección para el movimiento suave
  2365                                      .smooth_transition:
  2366                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2367 0000148A 8A05(A2150000)                  mov al, [enemy_target]
  2368 00001490 84C0                            test al, al
  2369 00001492 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2370                                          
  2371                                          ; Verificar distancia en X
  2372 00001494 4989D2                          mov r10, rdx              ; Posición X objetivo
  2373 00001497 4D29C2                          sub r10, r8               ; Calcular diferencia
  2374 0000149A 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2375 0000149E 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2376 000014A0 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2377 000014A4 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2378 000014A6 EB3C                            jmp .check_collision
  2379                                          
  2380                                      .limit_right_movement:
  2381 000014A8 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2382 000014AC EB36                            jmp .check_collision
  2383                                          
  2384                                      .limit_left_movement:
  2385 000014AE 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2386 000014B2 EB30                            jmp .check_collision
  2387                                      .move_left:
  2388 000014B4 49FFC8                          dec r8
  2389 000014B7 EB0F                            jmp .check_vertical
  2390                                          
  2391                                      .move_right:
  2392 000014B9 49FFC0                          inc r8
  2393 000014BC EB0A                            jmp .check_vertical
  2394                                          
  2395                                      .move_up:
  2396 000014BE 49FFC9                          dec r9
  2397 000014C1 EB21                            jmp .check_collision
  2398                                          
  2399                                      .move_down:
  2400 000014C3 49FFC1                          inc r9
  2401 000014C6 EB1C                            jmp .check_collision
  2402                                          
  2403                                      .check_vertical:
  2404 000014C8 8A05(A2150000)                  mov al, [enemy_target]
  2405 000014CE 84C0                            test al, al
  2406 000014D0 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2407 000014D6 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2408 000014DD 4D39D1                          cmp r9, r10
  2409 000014E0 7FDC                            jg .move_up
  2410 000014E2 7CDF                            jl .move_down
  2411                                          
  2412                                      .check_collision:
  2413                                          ; Verificar colisión con bordes
  2414 000014E4 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2415 000014E8 7E62                            jle .next_enemy
  2416 000014EA 4983F84E                        cmp r8, column_cells
  2417 000014EE 7D5C                            jge .next_enemy
  2418 000014F0 4983F901                        cmp r9, 1                       ; Borde superior
  2419 000014F4 7E56                            jle .next_enemy
  2420 000014F6 4983F920                        cmp r9, row_cells
  2421 000014FA 7D50                            jge .next_enemy
  2422                                          
  2423                                          ; Verificar colisión con bloques antes de moverse
  2424 000014FC 4150                            push r8
  2425 000014FE 4151                            push r9
  2426 00001500 4152                            push r10
  2427                                          
  2428                                          ; Calcular posición en el tablero para verificar
  2429 00001502 B84E000000                      mov rax, column_cells
  2430 00001507 4883C002                        add rax, 2
  2431 0000150B 49F7E1                          mul r9
  2432 0000150E 4C01C0                          add rax, r8
  2433 00001511 4C8D90[000A0000]                lea r10, [board + rax]
  2434                                          
  2435                                          ; Verificar si hay un bloque en la nueva posición
  2436 00001518 418A02                          mov al, [r10]
  2437 0000151B 3C55                            cmp al, 'U'
  2438 0000151D 7427                            je .invalid_move
  2439 0000151F 3C4F                            cmp al, 'O'
  2440 00001521 7423                            je .invalid_move
  2441 00001523 3C44                            cmp al, 'D'
  2442 00001525 741F                            je .invalid_move
  2443 00001527 3C4C                            cmp al, 'L'
  2444 00001529 741B                            je .invalid_move
  2445 0000152B 3C56                            cmp al, 'V'
  2446 0000152D 7417                            je .invalid_move
  2447 0000152F 3C38                            cmp al, '8'
  2448 00001531 7413                            je .invalid_move
  2449 00001533 3C58                            cmp al, 'X'
  2450 00001535 740F                            je .invalid_move
  2451                                          
  2452 00001537 415A                            pop r10
  2453 00001539 4159                            pop r9
  2454 0000153B 4158                            pop r8
  2455                                          
  2456                                          ; Guardar nueva posición si es válida
  2457 0000153D 448806                          mov [rsi], r8b
  2458 00001540 44884E01                        mov [rsi + 1], r9b
  2459 00001544 EB06                            jmp .next_enemy
  2460                                          
  2461                                      .invalid_move:
  2462 00001546 415A                            pop r10
  2463 00001548 4159                            pop r9
  2464 0000154A 4158                            pop r8
  2465                                          
  2466                                      .next_enemy:
  2467 0000154C 49FFC4                          inc r12
  2468 0000154F E960FEFFFF                      jmp .enemy_loop
  2469                                          
  2470                                      .end:
  2471 00001554 5D                              pop rbp
  2472 00001555 C3                              ret
  2473                                  
  2474                                  get_current_spawn_points:
  2475 00001556 55                          push rbp
  2476 00001557 4889E5                      mov rbp, rsp
  2477                                      
  2478 0000155A 480FB605(B4140000)          movzx rax, byte [current_level]
  2479 00001562 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2480 00001565 488B04C5[D6150000]          mov rax, [spawn_points_table + rax * 8]
  2481                                      
  2482 0000156D 5D                          pop rbp
  2483 0000156E C3                          ret
  2484                                  
  2485                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2486                                  check_enemy_spawn:
  2487 0000156F 55                          push rbp
  2488 00001570 4889E5                      mov rbp, rsp
  2489                                      
  2490                                      ; Obtener spawn points del nivel actual
  2491 00001573 E8DEFFFFFF                  call get_current_spawn_points
  2492 00001578 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2493                                      
  2494                                      ; Obtener cantidad de bloques destruidos
  2495 0000157B 4C0FB62D(5E150000)          movzx r13, byte [destroyed_blocks]
  2496                                      
  2497                                      ; Verificar cada punto de spawn
  2498 00001583 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2499                                      
  2500                                      .check_loop:
  2501 00001586 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2502 0000158A 7D4B                            jge .end
  2503                                          
  2504                                          ; Verificar si este spawn point ya fue usado
  2505 0000158C 80B9[01160000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2506 00001593 743D                            je .next_enemy
  2507                                          
  2508                                          ; Verificar si este enemigo ya está activo
  2509 00001595 4889C8                          mov rax, rcx
  2510 00001598 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2511 0000159C 488DB0[78150000]                lea rsi, [enemies + rax]
  2512 000015A3 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2513 000015A7 7429                            je .next_enemy
  2514                                          
  2515                                          ; Verificar si debemos spawnear este enemigo
  2516 000015A9 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2517 000015AE 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2518 000015B1 751F                            jne .next_enemy
  2519                                          
  2520                                          ; Marcar este spawn point como usado
  2521 000015B3 C681[01160000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2522                                          
  2523                                          ; Spawner nuevo enemigo
  2524 000015BA C60628                          mov byte [rsi], 40             ; X inicial
  2525 000015BD C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2526 000015C1 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2527                                          
  2528                                          ; Inicializar comportamiento
  2529 000015C5 4889C8                          mov rax, rcx
  2530 000015C8 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2531 000015CC 8805(00160000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2532                                          
  2533                                      .next_enemy:
  2534 000015D2 48FFC1                          inc rcx
  2535 000015D5 EBAF                            jmp .check_loop
  2536                                          
  2537                                      .end:
  2538 000015D7 5D                              pop rbp
  2539 000015D8 C3                              ret
  2540                                  
  2541                                  
  2542                                  ; Función para dibujar enemigos
  2543                                  print_enemies:
  2544 000015D9 55                          push rbp
  2545 000015DA 4889E5                      mov rbp, rsp
  2546                                      
  2547 000015DD 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2548                                      
  2549                                      .print_loop:
  2550 000015E0 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2551 000015E4 7D4B                            jge .end
  2552                                          
  2553                                          ; Calcular offset del enemigo actual
  2554 000015E6 4C89E0                          mov rax, r12
  2555 000015E9 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2556 000015ED 488DB0[78150000]                lea rsi, [enemies + rax]
  2557                                          
  2558                                          ; Verificar si el enemigo está activo
  2559 000015F4 807E0201                        cmp byte [rsi + 2], 1
  2560 000015F8 7532                            jne .next_enemy
  2561                                          
  2562                                          ; Calcular posición en el tablero
  2563 000015FA 4C0FB606                        movzx r8, byte [rsi]            ; X
  2564 000015FE 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2565                                          
  2566                                          ; Calcular offset en el tablero
  2567 00001603 B84E000000                      mov rax, column_cells
  2568 00001608 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2569 0000160C 49F7E1                          mul r9
  2570 0000160F 4C01C0                          add rax, r8
  2571 00001612 488DB8[000A0000]                lea rdi, [board + rax]
  2572                                          
  2573                                          ; Obtener carácter del enemigo según el nivel
  2574 00001619 480FB605(B4140000)              movzx rax, byte [current_level]
  2575 00001621 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2576 00001624 8A80[73150000]                  mov al, [enemy_chars + rax]
  2577                                          
  2578                                          ; Dibujar enemigo
  2579 0000162A 8807                            mov [rdi], al
  2580                                          
  2581                                      .next_enemy:
  2582 0000162C 49FFC4                          inc r12
  2583 0000162F EBAF                            jmp .print_loop
  2584                                          
  2585                                      .end:
  2586 00001631 5D                              pop rbp
  2587 00001632 C3                              ret
  2588                                  
  2589                                  ; Función para verificar colisión con enemigos
  2590                                  ; Función para verificar colisión con enemigos
  2591                                  check_enemy_collision:
  2592 00001633 55                          push rbp
  2593 00001634 4889E5                      mov rbp, rsp
  2594                                      
  2595 00001637 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2596 0000163A 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2597                                      
  2598                                      .check_loop:
  2599 0000163D 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2600 00001641 0F8DE9000000                    jge .end
  2601                                          
  2602                                          ; Calcular offset del enemigo actual
  2603 00001647 4C89E1                          mov rcx, r12
  2604 0000164A 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2605 0000164E 488DB1[78150000]                lea rsi, [enemies + rcx]
  2606                                          
  2607                                          ; Verificar si el enemigo está activo
  2608 00001655 807E0201                        cmp byte [rsi + 2], 1
  2609 00001659 0F85C9000000                    jne .next_enemy
  2610                                          
  2611                                          ; Verificar colisión con la bola
  2612 0000165F 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2613 00001663 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2614                                          
  2615                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2616 00001668 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2617 0000166F 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2618                                          
  2619                                          ; Comprobar colisión vertical (misma columna)
  2620 00001676 4D39C2                          cmp r10, r8
  2621 00001679 7525                            jne .check_horizontal
  2622 0000167B 4D29CB                          sub r11, r9
  2623 0000167E 4983FB01                        cmp r11, 1
  2624 00001682 7F1C                            jg .check_horizontal
  2625 00001684 4983FBFF                        cmp r11, -1
  2626 00001688 7C16                            jl .check_horizontal
  2627                                          
  2628                                          ; Colisión vertical detectada
  2629 0000168A E8A3000000                      call destroy_enemy
  2630 0000168F 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2631 00001696 B801000000                      mov rax, 1
  2632 0000169B E990000000                      jmp .end
  2633                                          
  2634                                      .check_horizontal:
  2635                                          ; Comprobar colisión horizontal (misma fila)
  2636 000016A0 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2637 000016A7 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2638 000016AE 4D39CB                          cmp r11, r9
  2639 000016B1 7522                            jne .check_paddle
  2640 000016B3 4D29C2                          sub r10, r8
  2641 000016B6 4983FA01                        cmp r10, 1
  2642 000016BA 7F19                            jg .check_paddle
  2643 000016BC 4983FAFF                        cmp r10, -1
  2644 000016C0 7C13                            jl .check_paddle
  2645                                          
  2646                                          ; Colisión horizontal detectada
  2647 000016C2 E86B000000                      call destroy_enemy
  2648 000016C7 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2649 000016CE B801000000                      mov rax, 1
  2650 000016D3 EB5B                            jmp .end
  2651                                          
  2652                                      .check_paddle:
  2653                                          ; Verificar colisión con la paleta
  2654 000016D5 4C8B15(3F140000)                mov r10, [pallet_position]
  2655 000016DC 4981EA[000A0000]                sub r10, board
  2656 000016E3 4C89D0                          mov rax, r10
  2657 000016E6 41BB4E000000                    mov r11, column_cells
  2658 000016EC 4983C302                        add r11, 2
  2659 000016F0 4831D2                          xor rdx, rdx
  2660 000016F3 49F7F3                          div r11                     ; División para obtener la posición Y
  2661 000016F6 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2662                                          
  2663 000016F9 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2664                                          
  2665                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2666 00001700 41BD20000000                    mov r13, row_cells
  2667 00001706 4983ED02                        sub r13, 2                 ; Y de la paleta
  2668 0000170A 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2669 0000170D 7519                            jne .next_enemy
  2670                                          
  2671                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2672 0000170F 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2673 00001712 7C14                            jl .next_enemy
  2674                                          
  2675 00001714 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2676 00001717 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2677 0000171A 7F0C                            jg .next_enemy
  2678                                          
  2679                                          ; Si llegamos aquí, hay colisión con la paleta
  2680 0000171C E811000000                      call destroy_enemy        ; Destruir el enemigo
  2681 00001721 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2682 00001726 EB08                            jmp .end
  2683                                          
  2684                                      .next_enemy:
  2685 00001728 49FFC4                          inc r12
  2686 0000172B E90DFFFFFF                      jmp .check_loop
  2687                                          
  2688                                      .end:
  2689 00001730 5D                              pop rbp
  2690 00001731 C3                              ret
  2691                                  
  2692                                  ; Función para destruir un enemigo
  2693                                  destroy_enemy:
  2694                                      ; Desactivar enemigo
  2695 00001732 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2696                                  
  2697                                      ; Sumar puntos por destruir enemigo
  2698 00001736 488B05(97150000)            mov rax, [enemy_points]
  2699 0000173D 480105(56150000)            add [current_score], rax
  2700                                  
  2701                                      ; No tocar bloques destruidos aquí
  2702 00001744 C3                          ret
  2703                                  
  2704                                  
  2705                                  _start:
  2706 00001745 E8E1E9FFFF              	call canonical_off
  2707 0000174A E809010000              	call start_screen
  2708 0000174F E8B9F5FFFF                  call init_level
  2709 00001754 E8FFFBFFFF                  call init_enemies
  2710 00001759 EB00                    	jmp .main_loop
  2711                                  	
  2712                                  
  2713                                  	.main_loop:
  2714 0000175B E8B6F9FFFF                      call print_labels
  2715 00001760 E8E5F8FFFF                      call print_blocks
  2716 00001765 E80DEDFFFF                      call move_letters
  2717 0000176A E820EFFFFF                      call update_lasers
  2718 0000176F E878ECFFFF                      call print_letters
  2719 00001774 E8E5F1FFFF              		call print_pallet
  2720 00001779 E8C8F2FFFF                      call move_ball
  2721 0000177E E85BEBFFFF                      call check_bottom_collision
  2722 00001783 E855EAFFFF                      call print_lives
  2723 00001788 E81FF7FFFF                      call check_level_complete
  2724 0000178D E8DDFDFFFF                      call check_enemy_spawn
  2725 00001792 E8F5FBFFFF                      call move_enemies
  2726 00001797 E897FEFFFF                      call check_enemy_collision
  2727 0000179C E838FEFFFF                      call print_enemies
  2728 000017A1 E890F1FFFF              		call print_ball
  2729                                  		print board, board_size				
    82 000017A6 B801000000          <1>  mov eax, sys_write
    83 000017AB BF01000000          <1>  mov edi, 1
    84 000017B0 48BE-               <1>  mov rsi, %1
    84 000017B2 [000A000000000000]  <1>
    85 000017BA BA000A0000          <1>  mov edx, %2
    86 000017BF 0F05                <1>  syscall
  2730                                  		;setnonblocking	
  2731                                  	.read_more:	
  2732                                  	    getchar	
    90 000017C1 B800000000          <1>  mov rax, sys_read
    91 000017C6 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 000017CB 48BE-               <1>  mov rsi, input_char
    92 000017CD [0000000000000000]  <1>
    93 000017D5 BA01000000          <1>  mov rdx, 1
    94 000017DA 0F05                <1>  syscall
  2733 000017DC 4883F801                	    cmp rax, 1
  2734 000017E0 7543                    	    jne .done
  2735                                  	
  2736 000017E2 8A05(00000000)          	    mov al, [input_char]
  2737 000017E8 8805(1D180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2738                                  	
  2739 000017EE 3C61                    	    cmp al, 'a'
  2740 000017F0 750E                    	    jne .not_left
  2741 000017F2 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2742 000017F9 E895F1FFFF              	    call move_pallet
  2743 000017FE EB25                    	    jmp .done
  2744                                  	
  2745                                      .not_left:
  2746 00001800 3C64                    	    cmp al, 'd'
  2747 00001802 750C                    	    jne .not_right
  2748 00001804 BF01000000              	    mov rdi, right_direction
  2749 00001809 E885F1FFFF              	    call move_pallet
  2750 0000180E EB15                    	    jmp .done
  2751                                  	
  2752                                      .not_right:
  2753 00001810 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2754 00001812 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2755                                  	
  2756 00001814 3C71                    	    cmp al, 'q' 
  2757 00001816 0F84AF000000            	    je exit
  2758 0000181C EBA3                    	    jmp .read_more
  2759                                  	
  2760                                      .release_ball:
  2761 0000181E E8F6F3FFFF              	    call process_catch_release
  2762 00001823 EB00                    	    jmp .done
  2763                                  	
  2764                                      .done:
  2765                                  	    sleeptime
    98 00001825 B823000000          <1>  mov eax, sys_nanosleep
    99 0000182A 48BF-               <1>  mov rdi, timespec
    99 0000182C [0000000000000000]  <1>
   100 00001834 31F6                <1>  xor esi, esi
   101 00001836 0F05                <1>  syscall
  2766                                  	    print clear, clear_length
    82 00001838 B801000000          <1>  mov eax, sys_write
    83 0000183D BF01000000          <1>  mov edi, 1
    84 00001842 48BE-               <1>  mov rsi, %1
    84 00001844 [1000000000000000]  <1>
    85 0000184C BA07000000          <1>  mov edx, %2
    86 00001851 0F05                <1>  syscall
  2767 00001853 E903FFFFFF              	    jmp .main_loop
  2768                                  
  2769                                  
  2770                                  
  2771                                  
  2772                                  start_screen:
  2773                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001858 B801000000          <1>  mov eax, sys_write
    83 0000185D BF01000000          <1>  mov edi, 1
    84 00001862 48BE-               <1>  mov rsi, %1
    84 00001864 [1000000000000000]  <1>
    85 0000186C BA07000000          <1>  mov edx, %2
    86 00001871 0F05                <1>  syscall
  2774                                      print msg1, msg1_length
    82 00001873 B801000000          <1>  mov eax, sys_write
    83 00001878 BF01000000          <1>  mov edi, 1
    84 0000187D 48BE-               <1>  mov rsi, %1
    84 0000187F [1700000000000000]  <1>
    85 00001887 BA14010000          <1>  mov edx, %2
    86 0000188C 0F05                <1>  syscall
  2775                                      
  2776                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2777                                          getchar                 ; Esperamos una tecla
    90 0000188E B800000000          <1>  mov rax, sys_read
    91 00001893 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001898 48BE-               <1>  mov rsi, input_char
    92 0000189A [0000000000000000]  <1>
    93 000018A2 BA01000000          <1>  mov rdx, 1
    94 000018A7 0F05                <1>  syscall
  2778 000018A9 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2779 000018AD 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2780                                          
  2781                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 000018AF B801000000          <1>  mov eax, sys_write
    83 000018B4 BF01000000          <1>  mov edi, 1
    84 000018B9 48BE-               <1>  mov rsi, %1
    84 000018BB [1000000000000000]  <1>
    85 000018C3 BA07000000          <1>  mov edx, %2
    86 000018C8 0F05                <1>  syscall
  2782 000018CA C3                          ret
  2783                                  
  2784                                  exit: 
  2785 000018CB E89DE8FFFF              	call canonical_on
  2786 000018D0 B83C000000              	mov    rax, 60
  2787 000018D5 BF00000000                  mov    rdi, 0
  2788 000018DA 0F05                        syscall
  2789                                  
