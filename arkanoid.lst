     1                                  bits 64
     2                                  default rel
     3                                  
     4                                  
     5                                  ; Here comes the defines
     6                                  sys_read: equ 0	
     7                                  sys_write:	equ 1
     8                                  sys_nanosleep:	equ 35
     9                                  sys_time:	equ 201
    10                                  sys_fcntl:	equ 72
    11                                  
    12                                  
    13                                  STDIN_FILENO: equ 0
    14                                  
    15                                  F_SETFL:	equ 0x0004
    16                                  O_NONBLOCK: equ 0x0004
    17                                  
    18                                  ;screen clean definition
    19                                  row_cells:	equ 32	; set to any (reasonable) value you wish
    20                                  column_cells: 	equ 78 ; set to any (reasonable) value you wish
    21                                  array_length:	equ row_cells * column_cells + row_cells ; cells are mapped to bytes in the array and a new line char ends each row
    22                                  
    23                                  ;This is regarding the sleep time
    24                                  timespec:
    25 00000000 0000000000000000            tv_sec  dq 0
    26 00000008 00C2EB0B00000000            tv_nsec dq 200000000
    27                                  
    28                                  
    29                                  ;This is for cleaning up the screen
    30 00000010 1B5B324A1B5B48          clear:		db 27, "[2J", 27, "[H"
    31                                  clear_length:	equ $-clear
    32                                  	
    33                                  	
    34                                  
    35                                  ; Start Message
    36 00000017 202020202020202054-     msg1: db "        TECNOLOGICO DE COSTA RICA        ", 0xA, 0xD
    36 00000020 45434E4F4C4F474943-
    36 00000029 4F20444520434F5354-
    36 00000032 412052494341202020-
    36 0000003B 20202020200A0D     
    37 00000042 202020202020202041-     msg2: db "        ARQUITECTURA DE COMPUTADORAS I        ", 0xA, 0xD
    37 0000004B 525155495445435455-
    37 00000054 524120444520434F4D-
    37 0000005D 50555441444F524153-
    37 00000066 204920202020202020-
    37 0000006F 200A0D             
    38 00000072 202020202020202045-     msg3: db "        ESTUDIANTE: HENRY NUNEZ PEREZ        ", 0xA, 0xD
    38 0000007B 5354554449414E5445-
    38 00000084 3A2048454E5259204E-
    38 0000008D 554E455A2050455245-
    38 00000096 5A2020202020202020-
    38 0000009F 0A0D               
    39 000000A1 202020202020202050-     msg4: db "        PROFESOR: ERNESTO RIVERA ALVARADO        ", 0xA, 0xD
    39 000000AA 524F4645534F523A20-
    39 000000B3 45524E4553544F2052-
    39 000000BC 495645524120414C56-
    39 000000C5 415241444F20202020-
    39 000000CE 202020200A0D       
    40 000000D4 202020202020202041-     msg5: db "        ARKANOID RETRO        ", 0xA, 0xD
    40 000000DD 524B414E4F49442052-
    40 000000E6 4554524F2020202020-
    40 000000EF 2020200A0D         
    41 000000F4 202020202020202050-     msg6: db "        PRESIONE CUALQUIER TECLA PARA INICIAR        ", 0xA, 0xD
    41 000000FD 524553494F4E452043-
    41 00000106 55414C515549455220-
    41 0000010F 5445434C4120504152-
    41 00000118 4120494E4943494152-
    41 00000121 20202020202020200A-
    41 0000012A 0D                 
    42                                  msg1_length: equ $-msg1
    43                                  msg2_length: equ $-msg2
    44                                  msg3_length: equ $-msg3
    45                                  msg4_length: equ $-msg4
    46                                  msg5_length: equ $-msg5
    47                                  msg6_length: equ $-msg6
    48                                  
    49                                  ; Usefull macros
    50                                  
    51                                  
    52                                  
    53                                  %macro setnonblocking 0
    54                                  	mov rax, sys_fcntl
    55                                      mov rdi, STDIN_FILENO
    56                                      mov rsi, F_SETFL
    57                                      mov rdx, O_NONBLOCK
    58                                      syscall
    59                                  %endmacro
    60                                  
    61                                  %macro unsetnonblocking 0
    62                                  	mov rax, sys_fcntl
    63                                      mov rdi, STDIN_FILENO
    64                                      mov rsi, F_SETFL
    65                                      mov rdx, 0
    66                                      syscall
    67                                  %endmacro
    68                                  
    69                                  %macro full_line 0
    70                                      times column_cells db "X"
    71                                      db 0x0a, 0xD
    72                                  %endmacro
    73                                  
    74                                  %macro hollow_line 0
    75                                      db "X"
    76                                      times column_cells-2 db " "
    77                                      db "X", 0x0a, 0xD
    78                                  %endmacro
    79                                  
    80                                  
    81                                  %macro print 2
    82                                  	mov eax, sys_write
    83                                  	mov edi, 1 	; stdout
    84                                  	mov rsi, %1
    85                                  	mov edx, %2
    86                                  	syscall
    87                                  %endmacro
    88                                  
    89                                  %macro getchar 0
    90                                  	mov     rax, sys_read
    91                                      mov     rdi, STDIN_FILENO
    92                                      mov     rsi, input_char
    93                                      mov     rdx, 1 ; number of bytes
    94                                      syscall         ;read text input from keyboard
    95                                  %endmacro
    96                                  
    97                                  %macro sleeptime 0
    98                                  	mov eax, sys_nanosleep
    99                                  	mov rdi, timespec
   100                                  	xor esi, esi		; ignore remaining time in case of call interruption
   101                                  	syscall			; sleep for tv_sec seconds + tv_nsec nanoseconds
   102                                  %endmacro
   103                                  
   104                                  
   105                                  
   106                                  global _start
   107                                  
   108                                  section .bss
   109                                  
   110 00000000 ??                      input_char: resb 1
   111                                  
   112                                  section .data
   113                                  
   114                                  	; Guardamos la plantilla del tablero (32 filas)
   115                                      board_template:
   116                                          full_line
    70 00000000 58<rep 4Eh>         <1>  times column_cells db "X"
    71 0000004E 0A0D                <1>  db 0x0a, 0xD
   117                                          %rep 30
   118                                          hollow_line
   119                                          %endrep
   118                              <1>  hollow_line
    75 00000050 58                  <2>  db "X"
    76 00000051 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000009D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000A0 58                  <2>  db "X"
    76 000000A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000000ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000000F0 58                  <2>  db "X"
    76 000000F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000013D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000140 58                  <2>  db "X"
    76 00000141 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000018D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000190 58                  <2>  db "X"
    76 00000191 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000001DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000001E0 58                  <2>  db "X"
    76 000001E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000022D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000230 58                  <2>  db "X"
    76 00000231 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000027D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000280 58                  <2>  db "X"
    76 00000281 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000002CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000002D0 58                  <2>  db "X"
    76 000002D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000031D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000320 58                  <2>  db "X"
    76 00000321 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000036D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000370 58                  <2>  db "X"
    76 00000371 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000003BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000003C0 58                  <2>  db "X"
    76 000003C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000040D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000410 58                  <2>  db "X"
    76 00000411 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000045D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000460 58                  <2>  db "X"
    76 00000461 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004AD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000004B0 58                  <2>  db "X"
    76 000004B1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000004FD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000500 58                  <2>  db "X"
    76 00000501 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000054D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000550 58                  <2>  db "X"
    76 00000551 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000059D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005A0 58                  <2>  db "X"
    76 000005A1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000005ED 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000005F0 58                  <2>  db "X"
    76 000005F1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000063D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000640 58                  <2>  db "X"
    76 00000641 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000068D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000690 58                  <2>  db "X"
    76 00000691 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000006DD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000006E0 58                  <2>  db "X"
    76 000006E1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000072D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000730 58                  <2>  db "X"
    76 00000731 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000077D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000780 58                  <2>  db "X"
    76 00000781 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000007CD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000007D0 58                  <2>  db "X"
    76 000007D1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000081D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000820 58                  <2>  db "X"
    76 00000821 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000086D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000870 58                  <2>  db "X"
    76 00000871 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000008BD 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 000008C0 58                  <2>  db "X"
    76 000008C1 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000090D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000910 58                  <2>  db "X"
    76 00000911 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 0000095D 580A0D              <2>  db "X", 0x0a, 0xD
   118                              <1>  hollow_line
    75 00000960 58                  <2>  db "X"
    76 00000961 20<rep 4Ch>         <2>  times column_cells-2 db " "
    77 000009AD 580A0D              <2>  db "X", 0x0a, 0xD
   120                                          full_line
    70 000009B0 58<rep 4Eh>         <1>  times column_cells db "X"
    71 000009FE 0A0D                <1>  db 0x0a, 0xD
   121                                      board_template_size: equ $ - board_template
   122                                  
   123                                      ; Espacio real que se usará en la ejecución
   124 00000A00 00<rep A00h>                board: times board_template_size db 0
   125                                      board_size: equ board_template_size
   126                                  
   127                                  	; Added for the terminal issue
   128 00001400 00<rep 24h>             	termios:        times 36 db 0
   129                                  	stdin:          equ 0
   130                                  	ICANON:         equ 1<<1
   131                                  	ECHO:           equ 1<<3
   132                                  	VTIME: 			equ 5
   133                                  	VMIN:			equ 6
   134                                  	CC_C:			equ 18
   135                                  
   136                                  section .text
   137                                  ;;;;;;;;;;;;;;;;;;;;for the working of the terminal;;;;;;;;;;;;;;;;;
   138                                  canonical_off:
   139 0000012B E86F000000                      call read_stdin_termios
   140                                  
   141                                          ; clear canonical bit in local mode flags
   142 00000130 50                              push rax
   143 00000131 B802000000                      mov eax, ICANON
   144 00000136 F7D0                            not eax
   145 00000138 2105(0C140000)                  and [termios+12], eax
   146 0000013E C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   147 00000145 C605(18140000)00        		mov byte[termios+CC_C+VMIN], 0
   148 0000014C 58                              pop rax
   149                                  
   150 0000014D E86C000000                      call write_stdin_termios
   151 00000152 C3                              ret
   152                                  
   153                                  echo_off:
   154 00000153 E847000000                      call read_stdin_termios
   155                                  
   156                                          ; clear echo bit in local mode flags
   157 00000158 50                              push rax
   158 00000159 B808000000                      mov eax, ECHO
   159 0000015E F7D0                            not eax
   160 00000160 2105(0C140000)                  and [termios+12], eax
   161 00000166 58                              pop rax
   162                                  
   163 00000167 E852000000                      call write_stdin_termios
   164 0000016C C3                              ret
   165                                  
   166                                  canonical_on:
   167 0000016D E82D000000                      call read_stdin_termios
   168                                  
   169                                          ; set canonical bit in local mode flags
   170 00000172 830D(0C140000)02                or dword [termios+12], ICANON
   171 00000179 C605(17140000)00        		mov byte[termios+CC_C+VTIME], 0
   172 00000180 C605(18140000)01        		mov byte[termios+CC_C+VMIN], 1
   173 00000187 E832000000                      call write_stdin_termios
   174 0000018C C3                              ret
   175                                  
   176                                  echo_on:
   177 0000018D E80D000000                      call read_stdin_termios
   178                                  
   179                                          ; set echo bit in local mode flags
   180 00000192 830D(0C140000)08                or dword [termios+12], ECHO
   181                                  
   182 00000199 E820000000                      call write_stdin_termios
   183 0000019E C3                              ret
   184                                  
   185                                  read_stdin_termios:
   186 0000019F 50                              push rax
   187 000001A0 53                              push rbx
   188 000001A1 51                              push rcx
   189 000001A2 52                              push rdx
   190                                  
   191 000001A3 B836000000                      mov eax, 36h
   192 000001A8 BB00000000                      mov ebx, stdin
   193 000001AD B901540000                      mov ecx, 5401h
   194 000001B2 BA[00140000]                    mov edx, termios
   195 000001B7 CD80                            int 80h
   196                                  
   197 000001B9 5A                              pop rdx
   198 000001BA 59                              pop rcx
   199 000001BB 5B                              pop rbx
   200 000001BC 58                              pop rax
   201 000001BD C3                              ret
   202                                  
   203                                  write_stdin_termios:
   204 000001BE 50                              push rax
   205 000001BF 53                              push rbx
   206 000001C0 51                              push rcx
   207 000001C1 52                              push rdx
   208                                  
   209 000001C2 B836000000                      mov eax, 36h
   210 000001C7 BB00000000                      mov ebx, stdin
   211 000001CC B902540000                      mov ecx, 5402h
   212 000001D1 BA[00140000]                    mov edx, termios
   213 000001D6 CD80                            int 80h
   214                                  
   215 000001D8 5A                              pop rdx
   216 000001D9 59                              pop rcx
   217 000001DA 5B                              pop rbx
   218 000001DB 58                              pop rax
   219 000001DC C3                              ret
   220                                  
   221                                  ;;;;;;;;;;;;;;;;;;;;end for the working of the terminal;;;;;;;;;;;;
   222                                  
   223                                  char_equal: equ 61
   224                                  char_space: equ 32
   225                                  char_O: equ 79
   226                                  left_direction: equ -1
   227                                  right_direction: equ 1
   228                                  
   229                                  
   230                                  section .data
   231                                  
   232                                  ; Mensajes para los niveles
   233 00001424 4E4956454C20                level_msg: db "NIVEL "
   234                                      level_msg_len: equ $ - level_msg
   235 0000142A 31                          level_1_char: db "1"
   236 0000142B 32                          level_2_char: db "2"
   237 0000142C 33                          level_3_char: db "3"
   238 0000142D 34                          level_4_char: db "4"
   239 0000142E 35                          level_5_char: db "5"
   240                                      level_char_len: equ 1
   241                                  
   242                                      ; Timespec para la pausa del mensaje de nivel
   243                                      level_display_time:
   244 0000142F 0100000000000000                lvl_tv_sec dq 1           ; 1 segundo
   245 00001437 0000000000000000                lvl_tv_nsec dq 0
   246                                          
   247 0000143F [3613000000000000]      	pallet_position dq board + 38 + 29 * (column_cells +2)
   248 00001447 0500000000000000            pallet_size dq 5
   249 0000144F 0500000000000000            default_pallet_size dq 5    ; Tamaño normal de la paleta
   250 00001457 0700000000000000            extended_pallet_size dq 7   ; Tamaño extendido de la paleta
   251                                  
   252 0000145F 2800000000000000        	ball_x_pos: dq 40
   253 00001467 1C00000000000000        	ball_y_pos: dq 28
   254 0000146F 0100000000000000            ball_direction_x dq 1    ; 1 = derecha, -1 = izquierda
   255 00001477 FFFFFFFFFFFFFFFF            ball_direction_y dq -1   ; -1 = arriba, 1 = abajo
   256 0000147F 00                          ball_moving db 0         ; 0 = estática, 1 = en movimiento
   257                                  
   258                                  ; Definir los límites de la pantalla o área de juego
   259                                      board_top_left_x equ 1
   260                                      board_top_left_y equ 1
   261                                      board_bottom_right_x equ column_cells - 1
   262                                      board_bottom_right_y equ row_cells
   263                                  
   264                                      ; Limites laterales
   265                                      left_edge equ board_top_left_x               ; Límite izquierdo en la primera columna
   266                                      right_edge equ board_bottom_right_x         ; Límite derecho en la última columna
   267                                  
   268                                      ; O también puedes hacerlo así si prefieres usando las coordenadas en memoria para obtener la ubicación exacta:
   269 00001480 [500A000000000000]          left_edge_position dq board + (board_top_left_y * (column_cells + 2)) ; Coordenada de la parte izquierda del marco
   270 00001488 [9C0A000000000000]          right_edge_position dq board + (board_top_left_y * (column_cells + 2) + board_bottom_right_x - 1) ; Coordenada de la parte derecha del marco
   271                                  
   272                                      ; Definición de tipos de bloques
   273 00001490 555555555555                block_type_1: db "UUUUUU"    ; Durabilidad 1
   274 00001496 4F4F4F4F4F4F                block_type_2: db "OOOOOO"    ; Durabilidad 2
   275 0000149C 444444444444                block_type_3: db "DDDDDD"    ; Durabilidad 3
   276 000014A2 4C4C4C4C4C4C                block_type_4: db "LLLLLL"    ; Durabilidad 4
   277 000014A8 565656565656                block_type_5: db "VVVVVV"    ; Durabilidad 5
   278 000014AE 383838383838                block_type_6: db "888888"    ; Durabilidad 6
   279                                      block_length: equ 6        ; Longitud de cada bloque
   280                                  
   281                                      ; Estructura para el nivel actual
   282 000014B4 01                          current_level db 1
   283 000014B5 00                          blocks_remaining db 0
   284                                  
   285                                      ; Definición del nivel 1 (ejemplo con múltiples bloques)destroyed_blocks
   286                                      ; Formato: x_pos, y_pos, tipo_bloque, durabilidad_actual
   287                                      level1_blocks:
   288                                          ; Tercera fila (tipo 3)
   289 000014B6 3A07030145                      db 58, 7, 3, 1, 'E'    ; Bloque 7
   290 000014BB 3D09030153                      db 61, 9, 3, 1, 'S'    ; Bloque 7
   291 000014C0 1207030153                      db 18, 7, 3, 1, 'S'    ; Bloque 7
   292                                      level1_blocks_count equ 3   ; Cantidad total de bloques
   293                                  
   294                                      ; Nivel 2: Bloques de prueba
   295                                      level2_blocks:
   296 000014C5 3C07010145                      db 60, 7, 1, 1, 'E'    ; Un bloque simple en el nivel 2   ; Un bloque simple en el nivel 2
   297                                      level2_blocks_count equ 1
   298                                  
   299                                      ; Nivel 3
   300                                      level3_blocks:
   301 000014CA 3C07020145                      db 60, 7, 2, 1, 'E'    ; Bloque 1
   302                                  
   303                                      level3_blocks_count equ 1
   304                                  
   305                                      ; Nivel 4
   306                                      level4_blocks:
   307 000014CF 3C07040145                      db 60, 7, 4, 1, 'E'    ; Bloque 1
   308                                      level4_blocks_count equ 1
   309                                  
   310                                      ; Nivel 5
   311                                      level5_blocks:
   312 000014D4 3C07050145                      db 60, 7, 5, 1, 'E'    ; Bloque 1
   313                                      level5_blocks_count equ 1
   314                                  
   315                                      ; Array para mantener el estado de los bloques
   316 000014D9 00<rep 64h>                 block_states: times 100 db 0  ; Durabilidad actual de cada bloque
   317                                  
   318                                      
   319                                      ; Variables para almacenar los valores
   320 0000153D 0000000000000000            current_score dq 0          ; Score actual
   321 00001545 00                          destroyed_blocks db 0       ; Bloques destruidos en el nivel actual
   322                                      
   323                                      ; Buffer para convertir números a string
   324 00001546 00<rep 14h>                 number_buffer: times 20 db 0
   325                                  
   326 0000155A 4023242640                  enemy_chars db "@", "#", "$", "&", "@"    ; El nivel 1 y 5 comparten el mismo caracter (@)
   327                                      
   328                                      ; Estructura para los enemigos (x, y, activo)
   329 0000155F 00<rep 1Eh>                 enemies: times 10 * 3 db 0     ; Máximo 5 enemigos, cada uno con 3 bytes (x, y, activo)
   330 0000157D 0A                          enemies_count db 10            ; Cantidad de enemigos activos
   331                                      
   332 0000157E 3200000000000000            enemy_points dq 50              ; Puntos por destruir un enemigo
   333 00001586 00                          enemy_move_counter db 0         ; Contador para controlar velocidad de movimiento
   334 00001587 02                          enemy_move_delay db 2           ; Mover enemigos cada N ciclos
   335 00001588 00                          enemy_move_total db 0      ; Contador total de movimientos
   336 00001589 00                          enemy_target db 0          ; 0 = persigue bola, 1 = persigue paleta
   337 0000158A 14                          MOVEMENT_THRESHOLD db 20   ; Número de movimientos antes de cambiar objetivo
   338                                   ;Formato: número de bloques destruidos necesario para que aparezca cada enemigo
   339                                      ; Añade esto en la sección .dataa
   340 0000158B 00010206080A0C0E10-         level1_spawn_points: db 0, 1, 2, 6, 8, 10, 12, 14, 16, 18    ; 10 enemigos, cada 2 bloques
   340 00001594 12                 
   341 00001595 01030507090B0D0F11-         level2_spawn_points: db 1, 3, 5, 7, 9, 11, 13, 15, 17, 19    ; 10 enemigos, cada 2 bloques
   341 0000159E 13                 
   342 0000159F 000306090C0F121518-         level3_spawn_points: db 0, 3, 6, 9, 12, 15, 18, 21, 24, 27   ; 10 enemigos, cada 3 bloques
   342 000015A8 1B                 
   343 000015A9 0104070A0D10131619-         level4_spawn_points: db 1, 4, 7, 10, 13, 16, 19, 22, 25, 28  ; 10 enemigos, cada 3 bloques
   343 000015B2 1C                 
   344 000015B3 00050A0F14191E2328-         level5_spawn_points: db 0, 5, 10, 15, 20, 25, 30, 35, 40, 45 ; 10 enemigos, cada 5 bloques
   344 000015BC 2D                 
   345                                          ; Arreglo de punteros a los spawn points de cada nivel
   346                                      spawn_points_table:
   347 000015BD [8B15000000000000]              dq level1_spawn_points
   348 000015C5 [9515000000000000]              dq level2_spawn_points
   349 000015CD [9F15000000000000]              dq level3_spawn_points
   350 000015D5 [A915000000000000]              dq level4_spawn_points
   351 000015DD [B315000000000000]              dq level5_spawn_points
   352                                  
   353                                      ; Variables para el comportamiento de enemigos
   354 000015E5 1E                          BEHAVIOR_CHANGE_TIME db 30    ; Ciclos antes de cambiar comportamiento
   355 000015E6 00                          behavior_counter db 0          ; Contador para cambio de comportamiento
   356 000015E7 00                          current_behavior db 0          ; 0 = persigue bola, 1 = persigue paleta
   357 000015E8 00<rep Ah>                  enemy_spawns_triggered: times 10 db 0  ; 0 = no spawned, 1 = spawned
   358                                  
   359 000015F2 50756E74616A653A20-         score_label: db "Puntaje: [          ]", 0xA, 0xD  ; 10 espacios para el número
   359 000015FB 5B2020202020202020-
   359 00001604 20205D0A0D         
   360                                      score_label_len: equ $ - score_label
   361 00001609 426C6F717565732064-         blocks_label: db "Bloques destruidos: [   ]", 0xA, 0xD  ; 3 espacios para el número
   361 00001612 657374727569646F73-
   361 0000161B 3A205B2020205D0A0D 
   362                                      blocks_label_len: equ $ - blocks_label
   363                                      
   364                                      ; Posición donde insertar los números en los labels
   365                                      score_pos equ 10    ; Posición después de "Puntaje: ["
   366                                      blocks_pos equ 20   ; Posición después de "Bloques destruidos: ["
   367                                      
   368                                      ; Definición de las vidas (x, y, estado)
   369                                      ; Formato: posición_x, posición_y, estado (1 = activa, 0 = inactiva)
   370                                      lives_data: 
   371 00001624 021E01                          db 2, 30, 1     ; Vida 1 (activa)
   372 00001627 041E01                          db 4, 30, 1     ; Vida 2 (activa)
   373 0000162A 061E01                          db 6, 30, 1     ; Vida 3 (inactiva)
   374 0000162D 081E01                          db 8, 30, 1     ; Vida 4 (inactiva)
   375 00001630 0A1E00                          db 10, 30, 0    ; Vida 5 (inactiva)
   376 00001633 0C1E00                          db 12, 30, 0    ; Vida 6 (inactiva)
   377 00001636 0E1E00                          db 14, 30, 0    ; Vida 7 (inactiva)
   378                                      lives_count equ 7    ; Total de vidas
   379 00001639 5E                          life_char db "^"    
   380 0000163A 04                          current_lives db 4   ; Contador de vidas activas actual
   381                                  
   382                                  ; Estructura para almacenar las letras y sus posiciones
   383                                      ; Formato: x, y, letra, activo (1 = activo, 0 = inactivo)
   384 0000163B 00<rep 190h>                letters_map: times 100 * 4 db 0  ; Espacio para 100 letras
   385 000017CB 00                          letters_count db 0   
   386 000017CC 20                          last_letter db ' '    ; Variable para almacenar la última letra
   387 000017CD 506F64657220616374-         last_letter_msg db "Poder actual: [ ]", 0xA, 0xD  ; Mensaje para mostrar la última letra
   387 000017D6 75616C3A205B205D0A-
   387 000017DF 0D                 
   388                                      last_letter_msg_len equ $ - last_letter_msg
   389 000017E0 00                          current_power_processed db 0 ; 0 = no procesado, 1 = ya procesado
   390 000017E1 07                          max_lives db 7              ; Máximo número de vidas permitidas
   391 000017E2 0100000000000000            ball_speed dq 1             ; Velocidad normal de la bola
   392 000017EA 0200000000000000            slow_ball_speed dq 2        ; Velocidad lenta (se usará como divisor)
   393 000017F2 0000000000000000            speed_counter dq 0          ; Contador para ralentizar el movimiento
   394                                  
   395 000017FA 00                          catch_power_active db 0     ; 0 = inactivo, 1 = activo
   396 000017FB 00                          ball_caught db 0           ; 0 = no atrapada, 1 = atrapada
   397 000017FC 0000000000000000            ball_catch_offset dq 0     ; Offset respecto a la paleta cuando está atrapada
   398 00001804 00                          last_key db 0    ; Variable para almacenar la última tecla presionada
   399                                  
   400                                  
   401                                  section .text
   402                                  
   403                                  
   404                                  print_lives:
   405 000001DD 55                          push rbp
   406 000001DE 4889E5                      mov rbp, rsp
   407                                      
   408 000001E1 4D31E4                      xor r12, r12                    ; Índice de la vida actual
   409                                      
   410                                      .print_loop:
   411 000001E4 4983FC07                        cmp r12, lives_count
   412 000001E8 7D45                            jge .end
   413                                          
   414                                          ; Calcular offset de la vida actual
   415 000001EA 4C89E0                          mov rax, r12
   416 000001ED 486BC003                        imul rax, 3                     ; Cada vida ocupa 3 bytes (x, y, estado)
   417 000001F1 488DB0[24160000]                lea rsi, [lives_data + rax]
   418                                          
   419                                          ; Calcular posición en el tablero
   420 000001F8 4C0FB606                        movzx r8, byte [rsi]            ; X
   421 000001FC 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   422                                          
   423                                          ; Calcular offset en el tablero
   424 00000201 B84E000000                      mov rax, column_cells
   425 00000206 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   426 0000020A 49F7E1                          mul r9
   427 0000020D 4C01C0                          add rax, r8
   428 00000210 488DB8[000A0000]                lea rdi, [board + rax]
   429                                          
   430                                          ; Verificar estado de la vida y dibujar el carácter correspondiente
   431 00000217 807E0201                        cmp byte [rsi + 2], 1
   432 0000021B 7405                            je .draw_active
   433                                          
   434                                          ; Si está inactiva, dibujar espacio
   435 0000021D C60720                          mov byte [rdi], ' '
   436 00000220 EB08                            jmp .next_life
   437                                          
   438                                      .draw_active:
   439                                          ; Si está activa, dibujar el símbolo de vida
   440 00000222 8A05(39160000)                  mov al, [life_char]
   441 00000228 8807                            mov [rdi], al
   442                                          
   443                                      .next_life:
   444 0000022A 49FFC4                          inc r12
   445 0000022D EBB5                            jmp .print_loop
   446                                          
   447                                      .end:
   448 0000022F 5D                              pop rbp
   449 00000230 C3                              ret
   450                                  
   451                                  ; Función para desactivar una vida
   452                                  ; Función modificada para perder una vida
   453                                  lose_life:
   454 00000231 55                          push rbp
   455 00000232 4889E5                      mov rbp, rsp
   456                                      
   457                                      ; Verificar si aún quedan vidas
   458 00000235 803D(3A160000)00            cmp byte [current_lives], 0
   459 0000023C 0F8493000000                je .game_lost
   460                                      
   461                                      ; Encontrar la última vida activa
   462 00000242 B907000000                  mov rcx, lives_count
   463 00000247 48FFC9                      dec rcx                     ; Empezar desde la última vida
   464                                      
   465                                      .find_active_life:
   466 0000024A 4889C8                          mov rax, rcx
   467 0000024D 486BC003                        imul rax, 3            ; Cada vida ocupa 3 bytes
   468 00000251 488DB0[24160000]                lea rsi, [lives_data + rax]
   469 00000258 807E0201                        cmp byte [rsi + 2], 1  ; Verificar si está activa
   470 0000025C 7407                            je .deactivate_life
   471 0000025E 48FFC9                          dec rcx
   472 00000261 79E7                            jns .find_active_life  ; Continuar si no hemos llegado a -1
   473 00000263 EB70                            jmp .game_lost         ; Si no encontramos vidas activas
   474                                          
   475                                      .deactivate_life:
   476                                          ; Calcular posición correcta en el tablero para borrar la vida
   477 00000265 4C0FB606                        movzx r8, byte [rsi]            ; X
   478 00000269 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
   479                                          
   480                                          ; Calcular offset en el tablero: Y * (column_cells + 2) + X
   481 0000026E B84E000000                      mov rax, column_cells
   482 00000273 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
   483 00000277 49F7E1                          mul r9
   484 0000027A 4C01C0                          add rax, r8
   485 0000027D 488DB8[000A0000]                lea rdi, [board + rax]
   486                                          
   487                                          ; Borrar visualmente la vida
   488 00000284 C60720                          mov byte [rdi], ' '             
   489                                          
   490                                          ; Desactivar la vida en los datos
   491 00000287 C6460200                        mov byte [rsi + 2], 0          
   492 0000028B FE0D(3A160000)                  dec byte [current_lives]
   493                                          
   494                                          ; Borrar visualmente la paleta anterior
   495 00000291 4C8B05(3F140000)                mov r8, [pallet_position]
   496 00000298 488B0D(47140000)                mov rcx, [pallet_size]
   497                                          .erase_pallet_loop:
   498 0000029F 41C60020                            mov byte [r8], ' '          ; Reemplazar cada posición con un espacio
   499 000002A3 49FFC0                              inc r8
   500 000002A6 48FFC9                              dec rcx
   501 000002A9 75F4                                jnz .erase_pallet_loop
   502                                          
   503                                  
   504                                          ; Reiniciar posición de la bola y la paleta
   505 000002AB 48C705(5F140000)28-             mov qword [ball_x_pos], 40
   505 000002B3 000000             
   506 000002B6 48C705(67140000)1C-             mov qword [ball_y_pos], 28
   506 000002BE 000000             
   507 000002C1 C605(7F140000)00                mov byte [ball_moving], 0
   508 000002C8 48C705(3F140000)-               mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
   508 000002CF [36130000]         
   509                                          
   510 000002D3 EB07                            jmp .end
   511                                          
   512                                      .game_lost:
   513 000002D5 E81C000000                      call game_lost
   514 000002DA EB00                            jmp .end
   515                                          
   516                                      .end:
   517 000002DC 5D                              pop rbp
   518 000002DD C3                              ret
   519                                  ; Función modificada para verificar colisión con el borde inferior
   520                                  check_bottom_collision:
   521 000002DE 55                          push rbp
   522 000002DF 4889E5                      mov rbp, rsp
   523                                      
   524                                      ; Verificar si la bola está en la última fila (row_cells - 1)
   525 000002E2 488B05(67140000)            mov rax, [ball_y_pos]
   526 000002E9 4883F81E                    cmp rax, row_cells - 2
   527 000002ED 7505                        jne .no_collision
   528                                      
   529                                      ; Si hay colisión, perder una vida
   530 000002EF E83DFFFFFF                  call lose_life
   531                                      
   532                                      .no_collision:
   533 000002F4 5D                              pop rbp
   534 000002F5 C3                              ret
   535                                  
   536                                  ; Nueva función para game over
   537                                  game_lost:
   538                                      ; Limpiar la pantalla
   539                                      print clear, clear_length
    82 000002F6 B801000000          <1>  mov eax, sys_write
    83 000002FB BF01000000          <1>  mov edi, 1
    84 00000300 48BE-               <1>  mov rsi, %1
    84 00000302 [1000000000000000]  <1>
    85 0000030A BA07000000          <1>  mov edx, %2
    86 0000030F 0F05                <1>  syscall
   540                                      
   541                                      ; Mostrar mensaje de derrota
   542                                      section .data
   543 00001805 C2A148617320706572-             lost_msg: db "¡Has perdido!", 0xA, 0xD
   543 0000180E 6469646F210A0D     
   544                                          lost_msg_len: equ $ - lost_msg
   545                                      section .text
   546                                      
   547                                      ; Imprimir mensaje de derrota
   548                                      print lost_msg, lost_msg_len
    82 00000311 B801000000          <1>  mov eax, sys_write
    83 00000316 BF01000000          <1>  mov edi, 1
    84 0000031B 48BE-               <1>  mov rsi, %1
    84 0000031D [0518000000000000]  <1>
    85 00000325 BA10000000          <1>  mov edx, %2
    86 0000032A 0F05                <1>  syscall
   549                                      print score_msg, score_msg_len
    82 0000032C B801000000          <1>  mov eax, sys_write
    83 00000331 BF01000000          <1>  mov edi, 1
    84 00000336 48BE-               <1>  mov rsi, %1
    84 00000338 [3318000000000000]  <1>
    85 00000340 BA0F000000          <1>  mov edx, %2
    86 00000345 0F05                <1>  syscall
   550                                      
   551                                      ; Mostrar puntaje final
   552 00000347 488B05(3D150000)            mov rax, [current_score]
   553 0000034E 48BF-                       mov rdi, number_buffer
   553 00000350 [4615000000000000] 
   554 00000358 E82B0B0000                  call number_to_string
   555                                      print number_buffer, 20
    82 0000035D B801000000          <1>  mov eax, sys_write
    83 00000362 BF01000000          <1>  mov edi, 1
    84 00000367 48BE-               <1>  mov rsi, %1
    84 00000369 [4615000000000000]  <1>
    85 00000371 BA14000000          <1>  mov edx, %2
    86 00000376 0F05                <1>  syscall
   556                                      
   557                                      ; Esperar un momento antes de salir
   558 00000378 48C7057DFCFFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
   558 00000381 0000               
   559 00000383 48C7057AFCFFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
   559 0000038C 0000               
   560                                      sleeptime
    98 0000038E B823000000          <1>  mov eax, sys_nanosleep
    99 00000393 48BF-               <1>  mov rdi, timespec
    99 00000395 [0000000000000000]  <1>
   100 0000039D 31F6                <1>  xor esi, esi
   101 0000039F 0F05                <1>  syscall
   561                                      
   562 000003A1 E9D1120000                  jmp exit
   563                                  
   564                                  
   565                                  ; Función para registrar una nueva letra en el mapa
   566                                  ; Entrada:
   567                                  ;   al - letra a registrar
   568                                  ;   r8b - posición x
   569                                  ;   r9b - posición y
   570                                  register_letter:
   571 000003A6 55                          push rbp
   572 000003A7 4889E5                      mov rbp, rsp
   573 000003AA 53                          push rbx
   574 000003AB 51                          push rcx
   575                                      
   576 000003AC 3C20                        cmp al, ' '
   577 000003AE 7438                        je .end
   578                                  
   579                                      ; Encontrar un espacio libre en el mapa
   580 000003B0 4831C9                      xor rcx, rcx
   581 000003B3 480FB615(CB170000)          movzx rdx, byte [letters_count]
   582                                      
   583                                      .find_slot:
   584 000003BB 4883F964                        cmp rcx, 100              ; Máximo de letras
   585 000003BF 7D27                            jge .end                  ; Si no hay espacio, salir
   586                                          
   587 000003C1 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   588 000003C9 807B0300                        cmp byte [rbx + 3], 0    ; Verificar si el slot está inactivo
   589 000003CD 7405                            je .found_slot
   590                                          
   591 000003CF 48FFC1                          inc rcx
   592 000003D2 EBE7                            jmp .find_slot
   593                                          
   594                                      .found_slot:
   595                                          ; Guardar la información de la letra
   596 000003D4 448803                          mov [rbx], r8b           ; x
   597 000003D7 44884B01                        mov [rbx + 1], r9b       ; y
   598 000003DB 884302                          mov [rbx + 2], al        ; letra
   599 000003DE C6430301                        mov byte [rbx + 3], 1    ; marcar como activo
   600                                          
   601 000003E2 FE05(CB170000)                  inc byte [letters_count]
   602                                          
   603                                      .end:
   604 000003E8 59                              pop rcx
   605 000003E9 5B                              pop rbx
   606 000003EA 5D                              pop rbp
   607 000003EB C3                              ret
   608                                  
   609                                  ; Función para imprimir todas las letras registradas
   610                                  print_letters:
   611 000003EC 55                          push rbp
   612 000003ED 4889E5                      mov rbp, rsp
   613 000003F0 53                          push rbx
   614 000003F1 51                          push rcx
   615                                      
   616 000003F2 4831C9                      xor rcx, rcx
   617                                      
   618                                      .print_loop:
   619 000003F5 4883F964                        cmp rcx, 100              ; Máximo de letras
   620 000003F9 7D37                            jge .end
   621                                          
   622                                          ; Obtener puntero a la letra actual
   623 000003FB 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   624                                          
   625                                          ; Verificar si está activa
   626 00000403 807B0300                        cmp byte [rbx + 3], 0
   627 00000407 7424                            je .next_letter
   628                                          
   629                                          ; Calcular posición en el tablero
   630 00000409 4C0FB603                        movzx r8, byte [rbx]      ; x
   631 0000040D 4C0FB64B01                      movzx r9, byte [rbx + 1]  ; y
   632                                          
   633                                          ; Calcular offset en el tablero
   634 00000412 B84E000000                      mov rax, column_cells
   635 00000417 4883C002                        add rax, 2                ; Incluir caracteres de nueva línea
   636 0000041B 49F7E1                          mul r9
   637 0000041E 4C01C0                          add rax, r8
   638 00000421 488DB8[000A0000]                lea rdi, [board + rax]
   639                                          
   640                                          ; Imprimir la letra
   641 00000428 8A4302                          mov al, [rbx + 2]
   642 0000042B 8807                            mov [rdi], al
   643                                          
   644                                      .next_letter:
   645 0000042D 48FFC1                          inc rcx
   646 00000430 EBC3                            jmp .print_loop
   647                                          
   648                                      .end:
   649 00000432 59                              pop rcx
   650 00000433 5B                              pop rbx
   651 00000434 5D                              pop rbp
   652 00000435 C3                              ret
   653                                  
   654                                  ; Función para borrar una letra específica
   655                                  ; Entrada:
   656                                  ;   r8b - posición x
   657                                  ;   r9b - posición y
   658                                  remove_letter:
   659 00000436 55                          push rbp
   660 00000437 4889E5                      mov rbp, rsp
   661 0000043A 53                          push rbx
   662 0000043B 51                          push rcx
   663                                      
   664 0000043C 4831C9                      xor rcx, rcx
   665                                      
   666                                      .find_loop:
   667 0000043F 4883F964                        cmp rcx, 100              ; Máximo de letras
   668 00000443 7D2E                            jge .end
   669                                          
   670 00000445 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   671                                          
   672                                          ; Verificar si está activa y coincide la posición
   673 0000044D 807B0300                        cmp byte [rbx + 3], 0
   674 00000451 741B                            je .next_letter
   675                                          
   676 00000453 8A03                            mov al, [rbx]
   677 00000455 4438C0                          cmp al, r8b
   678 00000458 7514                            jne .next_letter
   679                                          
   680 0000045A 8A4301                          mov al, [rbx + 1]
   681 0000045D 4438C8                          cmp al, r9b
   682 00000460 750C                            jne .next_letter
   683                                          
   684                                          ; Encontrada la letra, desactivarla
   685 00000462 C6430300                        mov byte [rbx + 3], 0
   686 00000466 FE0D(CB170000)                  dec byte [letters_count]
   687 0000046C EB05                            jmp .end
   688                                          
   689                                      .next_letter:
   690 0000046E 48FFC1                          inc rcx
   691 00000471 EBCC                            jmp .find_loop
   692                                          
   693                                      .end:
   694 00000473 59                              pop rcx
   695 00000474 5B                              pop rbx
   696 00000475 5D                              pop rbp
   697 00000476 C3                              ret
   698                                  ; Función para mover las letras hacia abajo
   699                                  move_letters:
   700 00000477 55                          push rbp
   701 00000478 4889E5                      mov rbp, rsp
   702 0000047B 53                          push rbx
   703 0000047C 57                          push rdi
   704 0000047D 56                          push rsi
   705 0000047E 4150                        push r8
   706 00000480 4151                        push r9
   707 00000482 4152                        push r10
   708 00000484 4153                        push r11
   709                                  
   710 00000486 4831C9                      xor rcx, rcx
   711                                  
   712                                      .move_loop:
   713 00000489 4883F964                        cmp rcx, 100
   714 0000048D 0F8D44010000                    jge .print_last_letter
   715                                          
   716 00000493 488D1C8D[3B160000]              lea rbx, [letters_map + rcx * 4]
   717 0000049B 807B0300                        cmp byte [rbx + 3], 0
   718 0000049F 0F842A010000                    je .next_letter
   719                                  
   720 000004A5 4C0FB603                        movzx r8, byte [rbx]
   721 000004A9 4C0FB64B01                      movzx r9, byte [rbx + 1]
   722                                  
   723 000004AE B84E000000                      mov rax, column_cells
   724 000004B3 4883C002                        add rax, 2
   725 000004B7 49F7E1                          mul r9
   726 000004BA 4C01C0                          add rax, r8
   727 000004BD 488DB8[000A0000]                lea rdi, [board + rax]
   728 000004C4 C60720                          mov byte [rdi], ' '
   729                                  
   730 000004C7 FE4301                          inc byte [rbx + 1]
   731 000004CA 4C0FB64B01                      movzx r9, byte [rbx + 1]
   732                                  
   733 000004CF 4983F91F                        cmp r9, row_cells - 1
   734 000004D3 7C09                            jl .check_pallet_collision
   735                                  
   736 000004D5 C6430300                        mov byte [rbx + 3], 0
   737 000004D9 E9F1000000                      jmp .next_letter
   738                                  
   739                                          .check_pallet_collision:
   740 000004DE B84E000000                          mov rax, column_cells
   741 000004E3 4883C002                            add rax, 2
   742 000004E7 49F7E1                              mul r9
   743 000004EA 4C01C0                              add rax, r8
   744 000004ED 488DB8[000A0000]                    lea rdi, [board + rax]
   745                                  
   746 000004F4 8A07                                mov al, [rdi]
   747 000004F6 3C20                                cmp al, ' '
   748 000004F8 0F84D1000000                        je .next_letter
   749 000004FE 3C3D                                cmp al, char_equal
   750 00000500 740A                                je .capture_letter
   751                                  
   752 00000502 8A4302                              mov al, [rbx + 2]
   753 00000505 8807                                mov [rdi], al
   754 00000507 E9C3000000                          jmp .next_letter
   755                                  
   756                                          .capture_letter:
   757                                              ; Obtener la nueva letra
   758 0000050C 8A4302                              mov al, [rbx + 2]
   759                                              
   760                                              ; Comparar con la última letra
   761 0000050F 3A05(CC170000)                      cmp al, [last_letter]
   762 00000515 7407                                je .same_letter
   763                                              
   764                                              ; Es una letra diferente, resetear el procesamiento
   765 00000517 C605(E0170000)00                    mov byte [current_power_processed], 0
   766                                              
   767                                              .same_letter:
   768                                              ; Guardar la nueva letra
   769 0000051E 8805(CC170000)                      mov [last_letter], al
   770                                              
   771                                              ; Verificar si es 'E' para extender la paleta
   772 00000524 3C45                                cmp al, 'E'
   773 00000526 7432                                je .extend_pallet
   774                                              
   775                                              ; Verificar si es 'P' para añadir vida
   776 00000528 3C50                                cmp al, 'P'
   777 0000052A 7449                                je .check_add_life
   778                                  
   779 0000052C 3C53                                cmp al, 'S'
   780 0000052E 7477                                je .slow_ball
   781                                  
   782 00000530 3C43                                cmp al, 'C'
   783 00000532 0F848A000000                        je .activate_catch
   784                                              
   785                                              ; Si no es ningún power-up, restaurar tamaño normal
   786 00000538 488B05(4F140000)                    mov rax, [default_pallet_size]
   787 0000053F 488905(47140000)                    mov [pallet_size], rax
   788 00000546 48C705(E2170000)01-                 mov qword [ball_speed], 1    ; Restaurar velocidad normal
   788 0000054E 000000             
   789 00000551 C605(FA170000)00                    mov byte [catch_power_active], 0
   790 00000558 EB71                                jmp .finish_capture
   791                                  
   792                                              .extend_pallet:
   793 0000055A 48C705(E2170000)01-                     mov qword [ball_speed], 1    ; Restaurar velocidad normal
   793 00000562 000000             
   794 00000565 488B05(57140000)                        mov rax, [extended_pallet_size]
   795 0000056C 488905(47140000)                        mov [pallet_size], rax
   796 00000573 EB56                                    jmp .finish_capture
   797                                  
   798                                              .check_add_life:
   799 00000575 488B05(4F140000)                        mov rax, [default_pallet_size]
   800 0000057C 488905(47140000)                        mov [pallet_size], rax
   801 00000583 48C705(E2170000)01-                     mov qword [ball_speed], 1 
   801 0000058B 000000             
   802                                                  ; Verificar si ya procesamos este power-up
   803 0000058E 803D(E0170000)00                        cmp byte [current_power_processed], 0
   804 00000595 7534                                    jne .finish_capture
   805                                                  
   806                                                  ; Preservar registros importantes
   807 00000597 51                                      push rcx
   808 00000598 53                                      push rbx
   809                                                  
   810                                                  ; Marcar como procesado
   811 00000599 C605(E0170000)01                        mov byte [current_power_processed], 1
   812                                                  
   813                                                  ; Añadir una vida
   814 000005A0 E881000000                              call add_life
   815                                                  
   816                                                  ; Restaurar registros
   817 000005A5 5B                                      pop rbx
   818 000005A6 59                                      pop rcx
   819                                                  
   820                                              .slow_ball:
   821 000005A7 488B05(4F140000)                        mov rax, [default_pallet_size]
   822 000005AE 488905(47140000)                        mov [pallet_size], rax
   823 000005B5 48C705(E2170000)02-                     mov qword [ball_speed], 2    ; Activar velocidad lenta
   823 000005BD 000000             
   824 000005C0 EB09                                    jmp .finish_capture
   825                                  
   826                                              .activate_catch:
   827 000005C2 C605(FA170000)01                        mov byte [catch_power_active], 1
   828 000005C9 EB00                                    jmp .finish_capture
   829                                  
   830                                              .finish_capture:
   831 000005CB C6430300                                mov byte [rbx + 3], 0
   832                                  
   833                                          .next_letter:
   834 000005CF 48FFC1                              inc rcx
   835 000005D2 E9B2FEFFFF                          jmp .move_loop
   836                                  
   837                                      .print_last_letter:
   838                                          print last_letter_msg, last_letter_msg_len - 3
    82 000005D7 B801000000          <1>  mov eax, sys_write
    83 000005DC BF01000000          <1>  mov edi, 1
    84 000005E1 48BE-               <1>  mov rsi, %1
    84 000005E3 [CD17000000000000]  <1>
    85 000005EB BA10000000          <1>  mov edx, %2
    86 000005F0 0F05                <1>  syscall
   839 000005F2 8A05(CC170000)                  mov al, [last_letter]
   840 000005F8 8805(DC170000)                  mov [last_letter_msg + 15], al
   841                                          print last_letter_msg + last_letter_msg_len - 3, 3
    82 000005FE B801000000          <1>  mov eax, sys_write
    83 00000603 BF01000000          <1>  mov edi, 1
    84 00000608 48BE-               <1>  mov rsi, %1
    84 0000060A [DD17000000000000]  <1>
    85 00000612 BA03000000          <1>  mov edx, %2
    86 00000617 0F05                <1>  syscall
   842                                  
   843                                      .end:
   844 00000619 415B                            pop r11
   845 0000061B 415A                            pop r10
   846 0000061D 4159                            pop r9
   847 0000061F 4158                            pop r8
   848 00000621 5E                              pop rsi
   849 00000622 5F                              pop rdi
   850 00000623 5B                              pop rbx
   851 00000624 5D                              pop rbp
   852 00000625 C3                              ret
   853                                  
   854                                  add_life:
   855 00000626 55                          push rbp
   856 00000627 4889E5                      mov rbp, rsp
   857 0000062A 53                          push rbx
   858 0000062B 51                          push rcx
   859 0000062C 57                          push rdi
   860 0000062D 56                          push rsi
   861 0000062E 4150                        push r8
   862 00000630 4151                        push r9
   863                                      
   864                                      ; Verificar si ya tenemos el máximo de vidas
   865 00000632 480FB605(3A160000)          movzx rax, byte [current_lives]
   866 0000063A 4883F807                    cmp rax, 7          ; Comparar con el máximo de vidas
   867 0000063E 7D2C                        jge .end
   868                                      
   869                                      ; Incrementar el contador de vidas
   870 00000640 FE05(3A160000)              inc byte [current_lives]
   871                                      
   872                                      ; Encontrar la siguiente vida inactiva
   873 00000646 4831C9                      xor rcx, rcx
   874                                      
   875                                      .find_inactive:
   876 00000649 4883F907                        cmp rcx, lives_count
   877 0000064D 7D1D                            jge .end
   878                                          
   879                                          ; Calcular offset de la vida actual
   880 0000064F 4889C8                          mov rax, rcx
   881 00000652 486BC003                        imul rax, 3
   882 00000656 488DB0[24160000]                lea rsi, [lives_data + rax]
   883                                          
   884                                          ; Verificar si está inactiva
   885 0000065D 807E0200                        cmp byte [rsi + 2], 0
   886 00000661 7405                            je .activate_life
   887                                          
   888 00000663 48FFC1                          inc rcx
   889 00000666 EBE1                            jmp .find_inactive
   890                                          
   891                                      .activate_life:
   892                                          ; Activar la vida
   893 00000668 C6460201                        mov byte [rsi + 2], 1
   894                                          
   895                                      .end:
   896 0000066C 4159                            pop r9
   897 0000066E 4158                            pop r8
   898 00000670 5E                              pop rsi
   899 00000671 5F                              pop rdi
   900 00000672 59                              pop rcx
   901 00000673 5B                              pop rbx
   902 00000674 5D                              pop rbp
   903 00000675 C3                              ret
   904                                  
   905                                  
   906                                  print_ball:
   907 00000676 4C8B05(5F140000)        	mov r8, [ball_x_pos]
   908 0000067D 4C8B0D(67140000)        	mov r9, [ball_y_pos]
   909 00000684 4981C0[000A0000]        	add r8, board
   910                                  
   911 0000068B 4C89C9                  	mov rcx, r9
   912 0000068E B850000000              	mov rax, column_cells + 2
   913 00000693 48F7E9                  	imul rcx
   914                                  	
   915 00000696 4901C0                  	add r8, rax
   916 00000699 41C6004F                	mov byte [r8], char_O
   917 0000069D C3                      	ret
   918                                  
   919                                  	
   920                                  	;mov rax, board + r8 + r9 * (column_cells + 2)
   921                                  	
   922                                  print_pallet:
   923                                      ; Primero borrar la paleta anterior completa (usando el tamaño máximo posible)
   924 0000069E 4C8B05(3F140000)            mov r8, [pallet_position]
   925 000006A5 488B0D(57140000)            mov rcx, [extended_pallet_size]
   926                                      .clear_pallet:
   927 000006AC 41C60020                        mov byte [r8], char_space
   928 000006B0 49FFC0                          inc r8
   929 000006B3 48FFC9                          dec rcx
   930 000006B6 75F4                            jnz .clear_pallet
   931                                  
   932                                      ; Luego dibujar la nueva paleta con el tamaño actual
   933 000006B8 4C8B05(3F140000)            mov r8, [pallet_position]
   934 000006BF 488B0D(47140000)            mov rcx, [pallet_size]
   935                                      .write_pallet:
   936 000006C6 41C6003D                        mov byte [r8], char_equal
   937 000006CA 49FFC0                          inc r8
   938 000006CD 48FFC9                          dec rcx
   939 000006D0 75F4                            jnz .write_pallet
   940                                  
   941 000006D2 C3                          ret
   942                                  
   943                                  move_pallet:
   944                                      ; 0) Forzar ball_moving a 1 si era 0
   945 000006D3 803D(7F140000)00            cmp byte [ball_moving], 0
   946 000006DA 7507                        jne .continue
   947 000006DC C605(7F140000)01            mov byte [ball_moving], 1
   948                                      
   949                                  .continue:
   950 000006E3 4883FFFF                    cmp rdi, left_direction
   951 000006E7 756B                        jne .move_right
   952                                      
   953                                      ; --- MOVER IZQUIERDA ---
   954 000006E9 488B05(3F140000)            mov rax, [pallet_position]
   955 000006F0 482D[000A0000]              sub rax, board
   956 000006F6 4831D2                      xor rdx, rdx
   957 000006F9 B94E000000                  mov rcx, column_cells
   958 000006FE 4883C102                    add rcx, 2
   959 00000702 48F7F1                      div rcx
   960 00000705 4989C0                      mov r8, rax          ; y
   961 00000708 4989D1                      mov r9, rdx          ; x
   962                                      
   963                                      ; Verificar límite ANTES de borrar
   964 0000070B 4983F901                    cmp r9, 1
   965 0000070F 0F8EA4000000                jle .end            ; si x <= 1 => no mover
   966                                      
   967                                      ; Si llegamos aquí, es seguro borrar y mover
   968 00000715 488B1D(47140000)            mov rbx, [pallet_size]
   969 0000071C 4C89C9                      mov rcx, r9
   970 0000071F 4801D9                      add rcx, rbx         ; xDerecho = x + pal_size
   971 00000722 48FFC9                      dec rcx              ; xDerecho - 1
   972                                      
   973                                      ; Borrar solo si no estamos en el borde
   974 00000725 4C89C0                      mov rax, r8
   975 00000728 486BC050                    imul rax, (column_cells+2)
   976 0000072C 4801C8                      add rax, rcx
   977 0000072F 4805[000A0000]              add rax, board
   978 00000735 C60020                      mov byte [rax], char_space
   979                                      
   980 00000738 49FFC9                      dec r9
   981 0000073B 4C89C0                      mov rax, r8
   982 0000073E 486BC050                    imul rax, (column_cells+2)
   983 00000742 4C01C8                      add rax, r9
   984 00000745 4805[000A0000]              add rax, board
   985 0000074B 488905(3F140000)            mov [pallet_position], rax
   986 00000752 EB65                        jmp .end
   987                                  
   988                                  .move_right:
   989 00000754 488B05(3F140000)            mov rax, [pallet_position]
   990 0000075B 482D[000A0000]              sub rax, board
   991 00000761 4831D2                      xor rdx, rdx
   992 00000764 B94E000000                  mov rcx, column_cells
   993 00000769 4883C102                    add rcx, 2
   994 0000076D 48F7F1                      div rcx
   995 00000770 4989C0                      mov r8, rax   ; y
   996 00000773 4989D1                      mov r9, rdx   ; x
   997                                      
   998                                      ; Calcular nueva posición derecha ANTES de borrar
   999 00000776 488B1D(47140000)            mov rbx, [pallet_size]
  1000 0000077D 4889D9                      mov rcx, rbx
  1001 00000780 48FFC9                      dec rcx
  1002 00000783 4C01C9                      add rcx, r9   ; xDerecha
  1003                                      
  1004                                      ; Verificar límite ANTES de borrar
  1005 00000786 4883F94B                    cmp rcx, 75   ; si xDerecha >= 75 => borde
  1006 0000078A 7D2D                        jge .end
  1007                                      
  1008                                      ; Si llegamos aquí, es seguro borrar y mover
  1009 0000078C 4C89C0                      mov rax, r8
  1010 0000078F 486BC050                    imul rax, (column_cells+2)
  1011 00000793 4C01C8                      add rax, r9
  1012 00000796 4805[000A0000]              add rax, board
  1013 0000079C C60020                      mov byte [rax], char_space
  1014                                      
  1015 0000079F 49FFC1                      inc r9
  1016 000007A2 4C89C0                      mov rax, r8
  1017 000007A5 486BC050                    imul rax, (column_cells+2)
  1018 000007A9 4C01C8                      add rax, r9
  1019 000007AC 4805[000A0000]              add rax, board
  1020 000007B2 488905(3F140000)            mov [pallet_position], rax
  1021                                  
  1022                                  .end:
  1023 000007B9 C3                          ret
  1024                                  
  1025                                  
  1026                                  
  1027                                  
  1028                                              
  1029                                  ; Nueva función auxiliar para actualizar la posición de la bola atrapada
  1030                                  update_caught_ball_position:
  1031 000007BA 55                          push rbp
  1032 000007BB 4889E5                      mov rbp, rsp
  1033                                      
  1034                                      ; Calcular la nueva posición de la bola basada en la paleta
  1035 000007BE 4C8B05(3F140000)            mov r8, [pallet_position]
  1036 000007C5 4981E8[000A0000]            sub r8, board          ; Obtener posición relativa
  1037 000007CC B850000000                  mov rax, column_cells + 2
  1038 000007D1 4831D2                      xor rdx, rdx
  1039 000007D4 48F7F0                      div rax                ; División para obtener X,Y
  1040                                      
  1041                                      ; rdx contiene X (resto), rax contiene Y (cociente)
  1042 000007D7 4989C1                      mov r9, rax            ; Y de la paleta
  1043 000007DA 49FFC9                      dec r9                 ; Una posición arriba de la paleta
  1044                                      
  1045                                      ; Añadir el offset guardado a la posición X
  1046 000007DD 4889D0                      mov rax, rdx
  1047 000007E0 480305(FC170000)            add rax, [ball_catch_offset]
  1048 000007E7 488905(5F140000)            mov [ball_x_pos], rax
  1049 000007EE 4C890D(67140000)            mov [ball_y_pos], r9
  1050                                      
  1051 000007F5 5D                          pop rbp
  1052 000007F6 C3                          ret
  1053                                  move_ball:
  1054                                  
  1055 000007F7 803D(FB170000)01            cmp byte [ball_caught], 1
  1056 000007FE 0F849D000000                je .move_with_pallet
  1057                                  
  1058 00000804 803D(7F140000)00            cmp byte [ball_moving], 0
  1059 0000080B 0F84B8010000                je .end
  1060                                  
  1061                                      ; Incrementar contador de velocidad
  1062 00000811 48FF05(F2170000)            inc qword [speed_counter]
  1063                                      
  1064                                      ; Verificar si debemos mover la bola en este ciclo
  1065 00000818 488B05(F2170000)            mov rax, [speed_counter]
  1066 0000081F 483B05(E2170000)            cmp rax, [ball_speed]
  1067 00000826 0F8C9D010000                jl .end
  1068                                      
  1069                                      ; Resetear contador de velocidad
  1070 0000082C 48C705(F2170000)00-         mov qword [speed_counter], 0
  1070 00000834 000000             
  1071                                  
  1072                                      ; Borrar la posición actual de la bola
  1073 00000837 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1074 0000083E 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1075 00000845 4981C0[000A0000]            add r8, board
  1076 0000084C 4C89C9                      mov rcx, r9
  1077 0000084F B850000000                  mov rax, column_cells + 2
  1078 00000854 48F7E9                      imul rcx
  1079 00000857 4901C0                      add r8, rax
  1080 0000085A 41C60020                    mov byte [r8], char_space
  1081                                  
  1082                                      ; Calcular siguiente posición X
  1083 0000085E 4C8B05(5F140000)            mov r8, [ball_x_pos]
  1084 00000865 4C8B0D(67140000)            mov r9, [ball_y_pos]
  1085 0000086C 488B05(6F140000)            mov rax, [ball_direction_x]
  1086 00000873 4901C0                      add r8, rax               ; Nueva posición X
  1087                                  
  1088                                      ; Calcular la dirección de memoria para la siguiente posición
  1089 00000876 4D89C2                      mov r10, r8
  1090 00000879 4981C2[000A0000]            add r10, board
  1091 00000880 4C89C9                      mov rcx, r9
  1092 00000883 B850000000                  mov rax, column_cells + 2
  1093 00000888 48F7E9                      imul rcx
  1094 0000088B 4901C2                      add r10, rax
  1095                                  
  1096                                      ; Verificar si hay una X en la siguiente posición X
  1097 0000088E 418A02                      mov al, [r10]
  1098 00000891 3C58                        cmp al, 'X'
  1099 00000893 7565                        jne .check_block_x
  1100 00000895 48F71D(6F140000)            neg qword [ball_direction_x]  ; Cambiar dirección X si hay una X
  1101 0000089C E928010000                  jmp .end
  1102                                  
  1103                                      .move_with_pallet:
  1104                                          ; Borrar la posición actual de la bola
  1105 000008A1 4C8B05(5F140000)                mov r8, [ball_x_pos]
  1106 000008A8 4C8B0D(67140000)                mov r9, [ball_y_pos]
  1107 000008AF 4D89C2                          mov r10, r8
  1108 000008B2 4981C2[000A0000]                add r10, board
  1109 000008B9 4C89C9                          mov rcx, r9
  1110 000008BC B850000000                      mov rax, column_cells + 2
  1111 000008C1 48F7E9                          imul rcx
  1112 000008C4 4901C2                          add r10, rax
  1113 000008C7 41C60220                        mov byte [r10], char_space
  1114                                  
  1115                                          ; Actualizar posición X basada en la paleta
  1116 000008CB 4C8B05(3F140000)                mov r8, [pallet_position]      ; Obtener posición actual de la paleta
  1117 000008D2 4981E8[000A0000]                sub r8, board                  ; Ajustar por el offset del tablero
  1118 000008D9 4C0305(FC170000)                add r8, [ball_catch_offset]    ; Añadir el offset guardado
  1119 000008E0 4C8905(5F140000)                mov [ball_x_pos], r8          ; Guardar nueva posición X
  1120                                  
  1121                                          ; Mantener la bola una posición arriba de la paleta
  1122 000008E7 4C8B0D(67140000)                mov r9, [ball_y_pos]          ; Mantener la misma altura
  1123 000008EE 4C890D(67140000)                mov [ball_y_pos], r9          ; Actualizar posición Y
  1124                                  
  1125 000008F5 E9CF000000                      jmp .end
  1126                                  
  1127                                  
  1128                                      .check_block_x:
  1129                                          ; Verificar colisión con bloques en X
  1130 000008FA 4150                            push r8     ; Guardar registros que usa check_block_collision
  1131 000008FC 4151                            push r9
  1132 000008FE 4152                            push r10
  1133 00000900 E8DB060000                      call check_block_collision
  1134 00000905 415A                            pop r10
  1135 00000907 4159                            pop r9
  1136 00000909 4158                            pop r8
  1137 0000090B 4885C0                          test rax, rax
  1138 0000090E 740C                            jz .check_paddle_x      ; Si no hay colisión, verificar paleta
  1139 00000910 48F71D(6F140000)                neg qword [ball_direction_x]  ; Si hay colisión, rebotar
  1140 00000917 E9AD000000                      jmp .end
  1141                                  
  1142                                      .check_paddle_x:
  1143                                          ; Verificar si hay una paleta (=) en la siguiente posición X
  1144 0000091C 41803A3D                        cmp byte [r10], char_equal
  1145 00000920 750C                            jne .check_y_movement
  1146 00000922 48F71D(6F140000)                neg qword [ball_direction_x]  ; Cambiar dirección X si hay una paleta
  1147 00000929 E99B000000                      jmp .end
  1148                                  
  1149                                      .check_y_movement:
  1150                                          ; Calcular siguiente posición Y
  1151 0000092E 488B05(77140000)                mov rax, [ball_direction_y]
  1152 00000935 4901C1                          add r9, rax                  ; Nueva posición Y
  1153                                  
  1154                                          ; Calcular la dirección de memoria para la siguiente posición Y
  1155 00000938 4D89C2                          mov r10, r8
  1156 0000093B 4981C2[000A0000]                add r10, board
  1157 00000942 4C89C9                          mov rcx, r9
  1158 00000945 B850000000                      mov rax, column_cells + 2
  1159 0000094A 48F7E9                          imul rcx
  1160 0000094D 4901C2                          add r10, rax
  1161                                  
  1162                                          ; Verificar si hay una X en la siguiente posición Y
  1163 00000950 418A02                          mov al, [r10]
  1164 00000953 3C58                            cmp al, 'X'
  1165 00000955 7509                            jne .check_block_y
  1166 00000957 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una X
  1167 0000095E EB69                            jmp .end
  1168                                  
  1169                                      .check_block_y:
  1170                                          ; Verificar colisión con bloques en Y
  1171 00000960 4150                            push r8     ; Guardar registros que usa check_block_collision
  1172 00000962 4151                            push r9
  1173 00000964 4152                            push r10
  1174 00000966 E875060000                      call check_block_collision
  1175 0000096B 415A                            pop r10
  1176 0000096D 4159                            pop r9
  1177 0000096F 4158                            pop r8
  1178 00000971 4885C0                          test rax, rax
  1179 00000974 7409                            jz .check_paddle_y      ; Si no hay colisión, verificar paleta
  1180 00000976 48F71D(77140000)                neg qword [ball_direction_y]  ; Si hay colisión, rebotar
  1181 0000097D EB4A                            jmp .end
  1182                                  
  1183                                      .check_paddle_y:
  1184                                          ; Verificar si hay una paleta (=) en la siguiente posición Y
  1185 0000097F 41803A3D                        cmp byte [r10], char_equal
  1186 00000983 7536                            jne .update_position
  1187                                  
  1188                                          ; Verificar si el poder catch está activo
  1189 00000985 803D(FA170000)01                cmp byte [catch_power_active], 1
  1190 0000098C 7524                            jne .normal_bounce
  1191                                  
  1192                                          ; Activar el modo "atrapado"
  1193 0000098E C605(FB170000)01                mov byte [ball_caught], 1
  1194                                          
  1195                                          ; Guardar la posición X actual de la bola como offset
  1196 00000995 488B05(5F140000)                mov rax, [ball_x_pos]           ; Posición X actual de la bola
  1197 0000099C 482B05(3F140000)                sub rax, [pallet_position]      ; Restar la posición de la paleta
  1198 000009A3 4805[000A0000]                  add rax, board                  ; Ajustar por el offset del tablero
  1199 000009A9 488905(FC170000)                mov [ball_catch_offset], rax    ; Guardar el offset
  1200                                          
  1201 000009B0 EB17                            jmp .end
  1202                                  
  1203                                      .normal_bounce:
  1204 000009B2 48F71D(77140000)                neg qword [ball_direction_y]  ; Cambiar dirección Y si hay una paleta
  1205 000009B9 EB0E                            jmp .end
  1206                                  
  1207                                  
  1208                                      .update_position:
  1209 000009BB 4C8905(5F140000)                mov [ball_x_pos], r8
  1210 000009C2 4C890D(67140000)                mov [ball_y_pos], r9
  1211                                  
  1212                                      .end:
  1213 000009C9 C3                              ret
  1214                                  
  1215                                  ; Nueva función para procesar la tecla C cuando la bola está atrapada
  1216                                  ; Procesar la tecla 'c' cuando el poder de atrapar está activo
  1217                                  process_catch_release:
  1218 000009CA 55                          push rbp
  1219 000009CB 4889E5                      mov rbp, rsp
  1220                                  
  1221                                      ; Verificar si la bola está atrapada
  1222 000009CE 803D(FB170000)00            cmp byte [ball_caught], 0
  1223 000009D5 7436                        je .end
  1224                                  
  1225                                      ; Verificar si el poder catch está activo
  1226 000009D7 803D(FA170000)01            cmp byte [catch_power_active], 1
  1227 000009DE 752D                        jne .end
  1228                                  
  1229                                      ; Verificar si se presionó la tecla 'c'
  1230 000009E0 803D(04180000)63            cmp byte [last_key], 'c'
  1231 000009E7 7524                        jne .end
  1232                                  
  1233                                      ; Liberar la bola y asignar dirección inicial
  1234 000009E9 C605(FB170000)00            mov byte [ball_caught], 0
  1235 000009F0 48C705(6F140000)01-         mov qword [ball_direction_x], 1
  1235 000009F8 000000             
  1236 000009FB 48C705(77140000)FF-         mov qword [ball_direction_y], -1
  1236 00000A03 FFFFFF             
  1237                                  
  1238                                      ; Limpiar la tecla procesada
  1239 00000A06 C605(04180000)00            mov byte [last_key], 0
  1240                                  
  1241                                      .end:
  1242 00000A0D 5D                              pop rbp
  1243 00000A0E C3                              ret
  1244                                  
  1245                                  
  1246                                  display_level_number:
  1247 00000A0F 55                          push rbp
  1248 00000A10 4889E5                      mov rbp, rsp
  1249                                      
  1250                                      ; Limpiar la pantalla primero
  1251                                      print clear, clear_length
    82 00000A13 B801000000          <1>  mov eax, sys_write
    83 00000A18 BF01000000          <1>  mov edi, 1
    84 00000A1D 48BE-               <1>  mov rsi, %1
    84 00000A1F [1000000000000000]  <1>
    85 00000A27 BA07000000          <1>  mov edx, %2
    86 00000A2C 0F05                <1>  syscall
  1252                                      
  1253                                      ; Calcular la posición central para el mensaje
  1254                                      ; Para el mensaje "NIVEL X", necesitamos centrar 7 caracteres
  1255 00000A2E B84E000000                  mov rax, column_cells
  1256 00000A33 4883E807                    sub rax, 7                  ; longitud de "NIVEL X"
  1257 00000A37 48D1E8                      shr rax, 1                  ; dividir por 2 para centrar
  1258                                      
  1259                                      ; Calcular la fila central
  1260 00000A3A BB20000000                  mov rbx, row_cells
  1261 00000A3F 48D1EB                      shr rbx, 1                  ; dividir por 2 para obtener la fila central
  1262                                      
  1263                                      ; Calcular el offset en el buffer
  1264 00000A42 B950000000                  mov rcx, column_cells + 2   ; ancho total de una línea incluyendo newline
  1265 00000A47 48F7E3                      mul rbx                     ; multiplicar por la fila central
  1266 00000A4A 4801D8                      add rax, rbx                ; añadir el offset horizontal
  1267                                      
  1268                                      ; Escribir "NIVEL " en la posición calculada
  1269 00000A4D 488DB8[000A0000]            lea rdi, [board + rax]
  1270 00000A54 48BE-                       mov rsi, level_msg
  1270 00000A56 [2414000000000000] 
  1271 00000A5E B906000000                  mov rcx, level_msg_len
  1272 00000A63 F3A4                        rep movsb
  1273                                      
  1274                                      ; Escribir el número del nivel
  1275 00000A65 8A05(B4140000)              mov al, [current_level]
  1276 00000A6B 0430                        add al, '0'                 ; convertir a ASCII
  1277 00000A6D 8807                        mov [rdi], al
  1278                                      
  1279                                      ; Mostrar el board con el mensaje
  1280                                      print board, board_size
    82 00000A6F B801000000          <1>  mov eax, sys_write
    83 00000A74 BF01000000          <1>  mov edi, 1
    84 00000A79 48BE-               <1>  mov rsi, %1
    84 00000A7B [000A000000000000]  <1>
    85 00000A83 BA000A0000          <1>  mov edx, %2
    86 00000A88 0F05                <1>  syscall
  1281                                      
  1282                                      ; Esperar un segundo
  1283 00000A8A B823000000                  mov rax, sys_nanosleep
  1284 00000A8F 48BF-                       mov rdi, level_display_time
  1284 00000A91 [2F14000000000000] 
  1285 00000A99 4831F6                      xor rsi, rsi
  1286 00000A9C 0F05                        syscall
  1287                                      
  1288 00000A9E 5D                          pop rbp
  1289 00000A9F C3                          ret
  1290                                  
  1291                                  ; Función para inicializar un tablero vacío
  1292                                  init_empty_board:
  1293 00000AA0 56                          push rsi
  1294 00000AA1 57                          push rdi
  1295 00000AA2 51                          push rcx
  1296 00000AA3 50                          push rax
  1297                                  
  1298 00000AA4 488D35(00000000)            lea rsi, [board_template]   ; Copiar la plantilla del tablero
  1299 00000AAB 488D3D(000A0000)            lea rdi, [board]            ; Destino: el tablero actual
  1300 00000AB2 B9000A0000                  mov rcx, board_template_size
  1301 00000AB7 F3A4                        rep movsb                   ; Copiar el tablero
  1302                                  
  1303 00000AB9 58                          pop rax
  1304 00000ABA 59                          pop rcx
  1305 00000ABB 5F                          pop rdi
  1306 00000ABC 5E                          pop rsi
  1307 00000ABD C3                          ret
  1308                                  
  1309                                  
  1310                                  init_level:
  1311                                  
  1312 00000ABE 488B05(4F140000)            mov rax, [default_pallet_size]
  1313 00000AC5 488905(47140000)            mov [pallet_size], rax
  1314 00000ACC 48C705(E2170000)01-         mov qword [ball_speed], 1    ; Restaurar velocidad normal
  1314 00000AD4 000000             
  1315                                  
  1316                                      ; 1) Copiamos board_template en board para que quede "virgen"
  1317                                          ; Reiniciar letras activas
  1318 00000AD7 488D3D(3B160000)            lea rdi, [letters_map]
  1319 00000ADE B990010000                  mov rcx, 100 * 4             ; Cada letra ocupa 4 bytes, limpiar 100 letras
  1320 00000AE3 4831C0                      xor rax, rax
  1321 00000AE6 F3AA                        rep stosb                    ; Llenar con ceros
  1322                                      
  1323                                      ; Inicializar dirección de la bola (derecha y arriba)
  1324 00000AE8 48C705(6F140000)01-         mov qword [ball_direction_x], 1    ; Dirección hacia la derecha (1 = derecha, -1 = izquierda)
  1324 00000AF0 000000             
  1325 00000AF3 48C705(77140000)FF-         mov qword [ball_direction_y], -1   ; Dirección hacia arriba (-1 = arriba, 1 = abajo)
  1325 00000AFB FFFFFF             
  1326                                  
  1327                                  
  1328                                      ; Reiniciar contador de letras activas
  1329 00000AFE 4831C0                      xor rax, rax
  1330 00000B01 8805(CB170000)              mov [letters_count], al
  1331                                  
  1332                                      ; Reiniciar última letra capturada
  1333 00000B07 C605(CC170000)20            mov byte [last_letter], ' '
  1334 00000B0E C605(45150000)00            mov byte [destroyed_blocks], 0 
  1335 00000B15 E886FFFFFF                  call init_empty_board
  1336 00000B1A E8F0FEFFFF                  call display_level_number
  1337 00000B1F E8E5050000                  call init_enemies
  1338                                      
  1339 00000B24 56                          push rsi
  1340 00000B25 57                          push rdi
  1341 00000B26 51                          push rcx
  1342 00000B27 50                          push rax
  1343                                  
  1344 00000B28 488D35(00000000)            lea rsi, [board_template]
  1345 00000B2F 488D3D(000A0000)            lea rdi, [board]
  1346 00000B36 B9000A0000                  mov rcx, board_template_size
  1347 00000B3B F3A4                        rep movsb                 ; Copiamos la plantilla a board
  1348                                  
  1349 00000B3D 58                          pop rax
  1350 00000B3E 59                          pop rcx
  1351 00000B3F 5F                          pop rdi
  1352 00000B40 5E                          pop rsi
  1353                                  
  1354 00000B41 B90A000000                  mov rcx, 10
  1355 00000B46 4831C0                      xor rax, rax
  1356 00000B49 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1357 00000B50 F3AA                        rep stosb      
  1358                                  
  1359                                      ; Verificar el nivel actual y cargar los bloques correspondientes
  1360 00000B52 803D(B4140000)01            cmp byte [current_level], 1
  1361 00000B59 7431                        je .level1
  1362 00000B5B 803D(B4140000)02            cmp byte [current_level], 2
  1363 00000B62 7454                        je .level2
  1364 00000B64 803D(B4140000)03            cmp byte [current_level], 3
  1365 00000B6B 7477                        je .level3
  1366 00000B6D 803D(B4140000)04            cmp byte [current_level], 4
  1367 00000B74 0F8492000000                je .level4
  1368 00000B7A 803D(B4140000)05            cmp byte [current_level], 5
  1369 00000B81 0F84AD000000                je .level5
  1370 00000B87 E9D0000000                  jmp .done
  1371                                  
  1372                                  
  1373                                  
  1374                                      .level1:
  1375 00000B8C C605(B5140000)03                mov byte [blocks_remaining], level1_blocks_count
  1376 00000B93 4831C9                          xor rcx, rcx             
  1377                                          .init_loop1:
  1378 00000B96 4883F903                            cmp rcx, level1_blocks_count
  1379 00000B9A 0F8DBC000000                        jge .done
  1380 00000BA0 4889C8                              mov rax, rcx         
  1381 00000BA3 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1382 00000BA7 8A90[B9140000]                      mov dl, byte [level1_blocks + rax + 3]  
  1383 00000BAD 8891[D9140000]                      mov byte [block_states + rcx], dl
  1384 00000BB3 48FFC1                              inc rcx
  1385 00000BB6 EBDE                                jmp .init_loop1
  1386                                  
  1387                                      .level2:
  1388 00000BB8 C605(B5140000)01                mov byte [blocks_remaining], level2_blocks_count
  1389 00000BBF 4831C9                          xor rcx, rcx             
  1390                                          .init_loop2:
  1391 00000BC2 4883F901                            cmp rcx, level2_blocks_count
  1392 00000BC6 0F8D90000000                        jge .done
  1393 00000BCC 4889C8                              mov rax, rcx         
  1394 00000BCF 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1395 00000BD3 8A90[C8140000]                      mov dl, byte [level2_blocks + rax + 3]  
  1396 00000BD9 8891[D9140000]                      mov byte [block_states + rcx], dl
  1397 00000BDF 48FFC1                              inc rcx
  1398 00000BE2 EBDE                                jmp .init_loop2
  1399                                      .level3:
  1400 00000BE4 C605(B5140000)01                mov byte [blocks_remaining], level3_blocks_count
  1401 00000BEB 4831C9                          xor rcx, rcx             
  1402                                          .init_loop3:
  1403 00000BEE 4883F901                            cmp rcx, level3_blocks_count
  1404 00000BF2 7D68                                jge .done
  1405 00000BF4 4889C8                              mov rax, rcx         
  1406 00000BF7 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1407 00000BFB 8A90[CD140000]                      mov dl, byte [level3_blocks + rax + 3]  
  1408 00000C01 8891[D9140000]                      mov byte [block_states + rcx], dl
  1409 00000C07 48FFC1                              inc rcx
  1410 00000C0A EBE2                                jmp .init_loop3
  1411                                  
  1412                                      .level4:
  1413 00000C0C C605(B5140000)01                mov byte [blocks_remaining], level4_blocks_count
  1414 00000C13 4831C9                          xor rcx, rcx             
  1415                                          .init_loop4:
  1416 00000C16 4883F901                            cmp rcx, level4_blocks_count
  1417 00000C1A 7D40                                jge .done
  1418 00000C1C 4889C8                              mov rax, rcx         
  1419 00000C1F 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1420 00000C23 8A90[D2140000]                      mov dl, byte [level4_blocks + rax + 3]  
  1421 00000C29 8891[D9140000]                      mov byte [block_states + rcx], dl
  1422 00000C2F 48FFC1                              inc rcx
  1423 00000C32 EBE2                                jmp .init_loop4
  1424                                  
  1425                                      .level5:
  1426 00000C34 C605(B5140000)01                mov byte [blocks_remaining], level5_blocks_count
  1427 00000C3B 4831C9                          xor rcx, rcx             
  1428                                          .init_loop5:
  1429 00000C3E 4883F901                            cmp rcx, level5_blocks_count
  1430 00000C42 7D18                                jge .done
  1431 00000C44 4889C8                              mov rax, rcx         
  1432 00000C47 486BC005                            imul rax, 5         ; en vez de shl rax,2
  1433 00000C4B 8A90[D7140000]                      mov dl, byte [level5_blocks + rax + 3]  
  1434 00000C51 8891[D9140000]                      mov byte [block_states + rcx], dl
  1435 00000C57 48FFC1                              inc rcx
  1436 00000C5A EBE2                                jmp .init_loop5
  1437                                      .done:
  1438 00000C5C C3                              ret
  1439                                  
  1440                                  
  1441                                  ; Función para verificar y manejar la transición de nivel
  1442                                  check_level_complete:
  1443                                      ; Verificar si quedan bloques
  1444 00000C5D 803D(B5140000)00            cmp byte [blocks_remaining], 0
  1445 00000C64 753C                        jne .not_complete
  1446                                      
  1447                                      ; Incrementar el nivel
  1448 00000C66 FE05(B4140000)              inc byte [current_level]
  1449                                      
  1450                                      ; Verificar si hemos completado todos los niveles (asumiendo 2 niveles por ahora)
  1451 00000C6C 803D(B4140000)06            cmp byte [current_level], 6
  1452 00000C73 742E                        je game_win
  1453                                      
  1454                                      ; Reinicializar el juego para el siguiente nivel
  1455 00000C75 E844FEFFFF                  call init_level
  1456                                      
  1457                                      ; Reinicializar la posición de la bola y la paleta
  1458 00000C7A 48C705(5F140000)28-         mov qword [ball_x_pos], 40
  1458 00000C82 000000             
  1459 00000C85 48C705(67140000)1C-         mov qword [ball_y_pos], 28
  1459 00000C8D 000000             
  1460 00000C90 C605(7F140000)00            mov byte [ball_moving], 0
  1461 00000C97 48C705(3F140000)-           mov qword [pallet_position], board + 38 + 29 * (column_cells + 2)
  1461 00000C9E [36130000]         
  1462                                      
  1463                                      .not_complete:
  1464 00000CA2 C3                              ret
  1465                                  
  1466                                      ; Nueva función para manejar la victoria del juego
  1467                                  game_win:
  1468                                      ; Limpiar la pantalla primero
  1469                                      print clear, clear_length
    82 00000CA3 B801000000          <1>  mov eax, sys_write
    83 00000CA8 BF01000000          <1>  mov edi, 1
    84 00000CAD 48BE-               <1>  mov rsi, %1
    84 00000CAF [1000000000000000]  <1>
    85 00000CB7 BA07000000          <1>  mov edx, %2
    86 00000CBC 0F05                <1>  syscall
  1470                                      
  1471                                      ; Mensaje de victoria
  1472 00000CBE 488B05(3D150000)            mov rax, [current_score]    ; Obtener el puntaje final
  1473 00000CC5 48BF-                       mov rdi, number_buffer      ; Convertir a string
  1473 00000CC7 [4615000000000000] 
  1474 00000CCF E8B4010000                  call number_to_string
  1475                                      
  1476                                      ; Definir mensaje de victoria
  1477                                      section .data
  1478 00001815 C2A146656C69636964-             win_msg: db "¡Felicidades! ¡Has ganado!", 0xA, 0xD
  1478 0000181E 616465732120C2A148-
  1478 00001827 61732067616E61646F-
  1478 00001830 210A0D             
  1479                                          win_msg_len: equ $ - win_msg
  1480 00001833 50756E74616A652066-             score_msg: db "Puntaje final: "
  1480 0000183C 696E616C3A20       
  1481                                          score_msg_len: equ $ - score_msg
  1482                                      section .text
  1483                                      
  1484                                      ; Imprimir mensajes
  1485                                      print win_msg, win_msg_len
    82 00000CD4 B801000000          <1>  mov eax, sys_write
    83 00000CD9 BF01000000          <1>  mov edi, 1
    84 00000CDE 48BE-               <1>  mov rsi, %1
    84 00000CE0 [1518000000000000]  <1>
    85 00000CE8 BA1E000000          <1>  mov edx, %2
    86 00000CED 0F05                <1>  syscall
  1486                                      print score_msg, score_msg_len
    82 00000CEF B801000000          <1>  mov eax, sys_write
    83 00000CF4 BF01000000          <1>  mov edi, 1
    84 00000CF9 48BE-               <1>  mov rsi, %1
    84 00000CFB [3318000000000000]  <1>
    85 00000D03 BA0F000000          <1>  mov edx, %2
    86 00000D08 0F05                <1>  syscall
  1487                                      print number_buffer, 20
    82 00000D0A B801000000          <1>  mov eax, sys_write
    83 00000D0F BF01000000          <1>  mov edi, 1
    84 00000D14 48BE-               <1>  mov rsi, %1
    84 00000D16 [4615000000000000]  <1>
    85 00000D1E BA14000000          <1>  mov edx, %2
    86 00000D23 0F05                <1>  syscall
  1488                                      
  1489                                      ; Esperar un momento antes de salir
  1490 00000D25 48C705D0F2FFFF0200-         mov qword [timespec + 0], 2    ; 2 segundos
  1490 00000D2E 0000               
  1491 00000D30 48C705CDF2FFFF0000-         mov qword [timespec + 8], 0    ; 0 nanosegundos
  1491 00000D39 0000               
  1492                                      sleeptime
    98 00000D3B B823000000          <1>  mov eax, sys_nanosleep
    99 00000D40 48BF-               <1>  mov rdi, timespec
    99 00000D42 [0000000000000000]  <1>
   100 00000D4A 31F6                <1>  xor esi, esi
   101 00000D4C 0F05                <1>  syscall
  1493                                      
  1494 00000D4E E924090000                  jmp exit
  1495                                  
  1496                                  ; Función para imprimir los bloques
  1497                                  ; Función modificada para imprimir bloques
  1498                                  
  1499                                  ; Primero, agreguemos una función para obtener el puntero a los bloques del nivel actual
  1500                                  get_current_level_blocks:
  1501 00000D53 803D(B4140000)01            cmp byte [current_level], 1
  1502 00000D5A 7428                        je .level1
  1503 00000D5C 803D(B4140000)02            cmp byte [current_level], 2
  1504 00000D63 7427                        je .level2
  1505 00000D65 803D(B4140000)03            cmp byte [current_level], 3
  1506 00000D6C 7426                        je .level3
  1507 00000D6E 803D(B4140000)04            cmp byte [current_level], 4
  1508 00000D75 7425                        je .level4
  1509 00000D77 803D(B4140000)05            cmp byte [current_level], 5
  1510 00000D7E 7424                        je .level5
  1511                                      ; Si llegamos aquí, hay un error en el nivel
  1512 00000D80 4831C0                      xor rax, rax
  1513 00000D83 C3                          ret
  1514                                  
  1515                                      .level1:
  1516 00000D84 488D05(B6140000)                lea rax, [level1_blocks]
  1517 00000D8B C3                              ret
  1518                                      .level2:
  1519 00000D8C 488D05(C5140000)                lea rax, [level2_blocks]
  1520 00000D93 C3                              ret
  1521                                      .level3:
  1522 00000D94 488D05(CA140000)                lea rax, [level3_blocks]
  1523 00000D9B C3                              ret
  1524                                      .level4:
  1525 00000D9C 488D05(CF140000)                lea rax, [level4_blocks]
  1526 00000DA3 C3                              ret
  1527                                      .level5:
  1528 00000DA4 488D05(D4140000)                lea rax, [level5_blocks]
  1529 00000DAB C3                              ret
  1530                                  ; Función para obtener la cantidad de bloques del nivel actual
  1531                                  get_current_level_count:
  1532 00000DAC 803D(B4140000)01            cmp byte [current_level], 1
  1533 00000DB3 7428                        je .level1
  1534 00000DB5 803D(B4140000)02            cmp byte [current_level], 2
  1535 00000DBC 7425                        je .level2
  1536 00000DBE 803D(B4140000)03            cmp byte [current_level], 3
  1537 00000DC5 7422                        je .level3
  1538 00000DC7 803D(B4140000)04            cmp byte [current_level], 4
  1539 00000DCE 741F                        je .level4
  1540 00000DD0 803D(B4140000)05            cmp byte [current_level], 5
  1541 00000DD7 741C                        je .level5
  1542                                      ; Si llegamos aquí, hay un error en el nivel
  1543 00000DD9 4831C0                      xor rax, rax
  1544 00000DDC C3                          ret
  1545                                  
  1546                                      .level1:
  1547 00000DDD B803000000                      mov rax, level1_blocks_count
  1548 00000DE2 C3                              ret
  1549                                      .level2:
  1550 00000DE3 B801000000                      mov rax, level2_blocks_count
  1551 00000DE8 C3                              ret
  1552                                      .level3:
  1553 00000DE9 B801000000                      mov rax, level3_blocks_count
  1554 00000DEE C3                              ret
  1555                                      .level4:
  1556 00000DEF B801000000                      mov rax, level4_blocks_count
  1557 00000DF4 C3                              ret
  1558                                      .level5:
  1559 00000DF5 B801000000                      mov rax, level5_blocks_count
  1560 00000DFA C3                              ret
  1561                                  
  1562                                  
  1563                                  print_blocks:
  1564 00000DFB 55                          push rbp
  1565 00000DFC 4889E5                      mov rbp, rsp
  1566                                      
  1567                                      ; Obtener puntero a los bloques del nivel actual
  1568 00000DFF E84FFFFFFF                  call get_current_level_blocks
  1569 00000E04 4989C5                      mov r13, rax                  ; Guardar puntero a los bloques en r13
  1570                                      
  1571                                      ; Obtener cantidad de bloques del nivel actual
  1572 00000E07 E8A0FFFFFF                  call get_current_level_count
  1573 00000E0C 4989C6                      mov r14, rax                  ; Guardar cantidad de bloques en r14
  1574                                      
  1575 00000E0F 4D31E4                      xor r12, r12                  ; Índice del bloque actual
  1576                                      
  1577                                      .print_loop:
  1578 00000E12 4D39F4                          cmp r12, r14                  ; Usar r14 en lugar de level1_blocks_count
  1579 00000E15 7D6F                            jge .end
  1580                                          
  1581                                          ; Verificar si el bloque está activo
  1582 00000E17 490FB68424-                     movzx rax, byte [block_states + r12]
  1582 00000E1C [D9140000]         
  1583 00000E20 4885C0                          test rax, rax
  1584 00000E23 745C                            jz .next_block
  1585                                          
  1586                                          ; Obtener posición y tipo del bloque usando r13
  1587 00000E25 4C89E0                          mov rax, r12
  1588 00000E28 486BC005                        imul rax, 5
  1589 00000E2C 4C01E8                          add rax, r13
  1590 00000E2F 448A00                          mov r8b, [rax]        ; X position
  1591 00000E32 448A4801                        mov r9b, [rax + 1]    ; Y position
  1592 00000E36 448A5002                        mov r10b, [rax + 2]   ; Tipo de bloque
  1593                                  
  1594                                          ; El resto de la lógica de impresión permanece igual
  1595 00000E3A 4D0FB6C0                        movzx r8, r8b
  1596 00000E3E 4D0FB6C9                        movzx r9, r9b
  1597 00000E42 4981C0[000A0000]                add r8, board
  1598 00000E49 B850000000                      mov rax, column_cells + 2
  1599 00000E4E 49F7E1                          mul r9
  1600 00000E51 4901C0                          add r8, rax
  1601                                          
  1602 00000E54 B906000000                      mov rcx, block_length
  1603 00000E59 48BE-                           mov rsi, block_type_1
  1603 00000E5B [9014000000000000] 
  1604 00000E63 490FB6C2                        movzx rax, r10b
  1605 00000E67 48FFC8                          dec rax
  1606 00000E6A 486BC006                        imul rax, block_length
  1607 00000E6E 4801C6                          add rsi, rax
  1608                                          
  1609                                      .print_block_chars:
  1610 00000E71 8A06                            mov al, [rsi]
  1611 00000E73 418800                          mov [r8], al
  1612 00000E76 48FFC6                          inc rsi
  1613 00000E79 49FFC0                          inc r8
  1614 00000E7C 48FFC9                          dec rcx
  1615 00000E7F 75F0                            jnz .print_block_chars
  1616                                          
  1617                                      .next_block:
  1618 00000E81 49FFC4                          inc r12
  1619 00000E84 EB8C                            jmp .print_loop
  1620                                          
  1621                                      .end:
  1622 00000E86 5D                              pop rbp
  1623 00000E87 C3                              ret
  1624                                  
  1625                                  ; Función para convertir número a string
  1626                                  ; Input: RAX = número a convertir
  1627                                  ; RDI = buffer donde escribir el string
  1628                                  number_to_string:
  1629 00000E88 53                          push rbx
  1630 00000E89 52                          push rdx
  1631 00000E8A 56                          push rsi
  1632 00000E8B BB0A000000                  mov rbx, 10          ; Divisor
  1633 00000E90 B900000000                  mov rcx, 0          ; Contador de dígitos
  1634                                      
  1635                                      ; Si el número es 0, manejarlo especialmente
  1636 00000E95 4885C0                      test rax, rax
  1637 00000E98 7509                        jnz .convert_loop
  1638 00000E9A C60730                      mov byte [rdi], '0'
  1639 00000E9D C6470100                    mov byte [rdi + 1], 0
  1640 00000EA1 EB20                        jmp .end
  1641                                      
  1642                                      .convert_loop:
  1643 00000EA3 4831D2                          xor rdx, rdx    ; Limpiar RDX para la división
  1644 00000EA6 48F7F3                          div rbx         ; RAX/10, cociente en RAX, residuo en RDX
  1645 00000EA9 80C230                          add dl, '0'     ; Convertir a ASCII
  1646 00000EAC 52                              push rdx        ; Guardar el dígito
  1647 00000EAD 48FFC1                          inc rcx         ; Incrementar contador
  1648 00000EB0 4885C0                          test rax, rax   ; Verificar si quedan más dígitos
  1649 00000EB3 75EE                            jnz .convert_loop
  1650                                          
  1651                                      .write_loop:
  1652 00000EB5 5A                              pop rdx         ; Obtener dígito
  1653 00000EB6 8817                            mov [rdi], dl   ; Escribir al buffer
  1654 00000EB8 48FFC7                          inc rdi         ; Siguiente posición
  1655 00000EBB 48FFC9                          dec rcx         ; Decrementar contador
  1656 00000EBE 75F5                            jnz .write_loop
  1657                                          
  1658 00000EC0 C60700                      mov byte [rdi], 0   ; Null terminator
  1659                                      
  1660                                      .end:
  1661 00000EC3 5E                          pop rsi
  1662 00000EC4 5A                          pop rdx
  1663 00000EC5 5B                          pop rbx
  1664 00000EC6 C3                          ret
  1665                                  
  1666                                  ; Función para imprimir los labels
  1667                                  print_labels:
  1668 00000EC7 55                          push rbp
  1669 00000EC8 4889E5                      mov rbp, rsp
  1670                                  
  1671                                      ; Crear buffer temporal
  1672 00000ECB 4883EC20                    sub rsp, 32
  1673                                  
  1674                                      ; Copiar labels a buffer temporal
  1675 00000ECF 4889E7                      mov rdi, rsp
  1676 00000ED2 488D35(F2150000)            lea rsi, [score_label]
  1677 00000ED9 B917000000                  mov rcx, score_label_len
  1678 00000EDE F3A4                        rep movsb
  1679                                  
  1680                                      ; Convertir score a string
  1681 00000EE0 488B05(3D150000)            mov rax, [current_score]
  1682 00000EE7 48BF-                       mov rdi, number_buffer
  1682 00000EE9 [4615000000000000] 
  1683 00000EF1 E892FFFFFF                  call number_to_string
  1684                                  
  1685                                      ; Calcular longitud del número
  1686 00000EF6 B900000000                  mov rcx, 0
  1687 00000EFB 48BF-                       mov rdi, number_buffer
  1687 00000EFD [4615000000000000] 
  1688                                      .count_loop:
  1689 00000F05 803C0F00                        cmp byte [rdi + rcx], 0
  1690 00000F09 7405                            je .count_done
  1691 00000F0B 48FFC1                          inc rcx
  1692 00000F0E EBF5                            jmp .count_loop
  1693                                      .count_done:
  1694                                  
  1695                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1696 00000F10 4889E7                      mov rdi, rsp
  1697 00000F13 4883C70A                    add rdi, score_pos           ; Moverse a la posición del número
  1698 00000F17 BE0A000000                  mov rsi, 10                  ; Espacio reservado para el número
  1699 00000F1C 4829CE                      sub rsi, rcx                 ; Calcular padding necesario
  1700                                      .pad_loop:
  1701 00000F1F 4885F6                          test rsi, rsi
  1702 00000F22 740B                            jz .pad_done
  1703 00000F24 C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1704 00000F27 48FFC7                          inc rdi
  1705 00000F2A 48FFCE                          dec rsi
  1706 00000F2D EBF0                            jmp .pad_loop
  1707                                      .pad_done:
  1708                                  
  1709                                      ; Copiar el número
  1710 00000F2F 48BE-                       mov rsi, number_buffer
  1710 00000F31 [4615000000000000] 
  1711 00000F39 F3A4                        rep movsb
  1712                                  
  1713                                      ; Imprimir el buffer completo
  1714                                      print rsp, score_label_len
    82 00000F3B B801000000          <1>  mov eax, sys_write
    83 00000F40 BF01000000          <1>  mov edi, 1
    84 00000F45 4889E6              <1>  mov rsi, %1
    85 00000F48 BA17000000          <1>  mov edx, %2
    86 00000F4D 0F05                <1>  syscall
  1715                                  
  1716                                      ; Repetir proceso para bloques destruidos
  1717 00000F4F 4889E7                      mov rdi, rsp
  1718 00000F52 488D35(09160000)            lea rsi, [blocks_label]
  1719 00000F59 B91B000000                  mov rcx, blocks_label_len
  1720 00000F5E F3A4                        rep movsb
  1721                                  
  1722                                      ; Verificar que el `[` esté en su posición correcta
  1723 00000F60 4889E7                      mov rdi, rsp
  1724 00000F63 4883C713                    add rdi, blocks_pos - 1  ; Posición exacta donde debe ir el '['
  1725 00000F67 C6075B                      mov byte [rdi], '['      ; Garantizar que el `[` esté presente
  1726                                  
  1727                                      ; Convertir bloques destruidos a string
  1728 00000F6A 480FB605(45150000)          movzx rax, byte [destroyed_blocks]
  1729 00000F72 48BF-                       mov rdi, number_buffer
  1729 00000F74 [4615000000000000] 
  1730 00000F7C E807FFFFFF                  call number_to_string
  1731                                  
  1732                                      ; Calcular longitud del número
  1733 00000F81 B900000000                  mov rcx, 0
  1734 00000F86 48BF-                       mov rdi, number_buffer
  1734 00000F88 [4615000000000000] 
  1735                                      .count_loop2:
  1736 00000F90 803C0F00                        cmp byte [rdi + rcx], 0
  1737 00000F94 7405                            je .count_done2
  1738 00000F96 48FFC1                          inc rcx
  1739 00000F99 EBF5                            jmp .count_loop2
  1740                                      .count_done2:
  1741                                  
  1742                                      ; Insertar el número en la posición correcta, alineado a la derecha
  1743 00000F9B 4889E7                      mov rdi, rsp
  1744 00000F9E 4883C714                    add rdi, blocks_pos         ; Moverse a la posición del número
  1745 00000FA2 BE03000000                  mov rsi, 3                  ; Espacio reservado para el número
  1746 00000FA7 4829CE                      sub rsi, rcx                ; Calcular padding necesario
  1747                                      .pad_loop2:
  1748 00000FAA 4885F6                          test rsi, rsi
  1749 00000FAD 740B                            jz .pad_done2
  1750 00000FAF C60720                          mov byte [rdi], ' '      ; Añadir espacio de padding
  1751 00000FB2 48FFC7                          inc rdi
  1752 00000FB5 48FFCE                          dec rsi
  1753 00000FB8 EBF0                            jmp .pad_loop2
  1754                                      .pad_done2:
  1755                                  
  1756                                      ; Copiar el número
  1757 00000FBA 48BE-                       mov rsi, number_buffer
  1757 00000FBC [4615000000000000] 
  1758 00000FC4 F3A4                        rep movsb
  1759                                  
  1760                                      ; Imprimir el buffer completo
  1761                                      print rsp, blocks_label_len
    82 00000FC6 B801000000          <1>  mov eax, sys_write
    83 00000FCB BF01000000          <1>  mov edi, 1
    84 00000FD0 4889E6              <1>  mov rsi, %1
    85 00000FD3 BA1B000000          <1>  mov edx, %2
    86 00000FD8 0F05                <1>  syscall
  1762                                  
  1763                                      ; Restaurar stack
  1764 00000FDA 4883C420                    add rsp, 32
  1765 00000FDE 5D                          pop rbp
  1766 00000FDF C3                          ret
  1767                                  
  1768                                  
  1769                                  
  1770                                  check_block_collision:
  1771 00000FE0 55                          push rbp
  1772 00000FE1 4889E5                      mov rbp, rsp
  1773                                  
  1774                                      ; Almacenar el carácter en la posición r10 (pos. de la bola en board[])
  1775 00000FE4 418A02                      mov al, [r10]
  1776                                  
  1777                                      ; Verificar si el carácter es un bloque
  1778 00000FE7 3C55                        cmp al, 'U'  
  1779 00000FE9 7419                        je .possible
  1780 00000FEB 3C4F                        cmp al, 'O'  
  1781 00000FED 7415                        je .possible
  1782 00000FEF 3C44                        cmp al, 'D'  
  1783 00000FF1 7411                        je .possible
  1784 00000FF3 3C4C                        cmp al, 'L'  
  1785 00000FF5 740D                        je .possible
  1786 00000FF7 3C56                        cmp al, 'V'  
  1787 00000FF9 7409                        je .possible
  1788 00000FFB 3C38                        cmp al, '8'  
  1789 00000FFD 7405                        je .possible
  1790                                  
  1791                                      ; No es bloque, salir
  1792 00000FFF 4831C0                      xor rax, rax
  1793 00001002 5D                          pop rbp
  1794 00001003 C3                          ret
  1795                                  
  1796                                  .possible:
  1797 00001004 53                          push rbx
  1798 00001005 57                          push rdi
  1799 00001006 56                          push rsi
  1800 00001007 4154                        push r12
  1801 00001009 4155                        push r13
  1802 0000100B 4156                        push r14
  1803 0000100D 4157                        push r15
  1804                                  
  1805                                      ; 1) Obtener base de los bloques del nivel actual
  1806 0000100F E83FFDFFFF                  call get_current_level_blocks
  1807 00001014 4989C5                      mov r13, rax  ; (r13) = base de levelX_blocks
  1808                                  
  1809                                      ; 2) Obtener la cantidad de bloques
  1810 00001017 E890FDFFFF                  call get_current_level_count
  1811 0000101C 4989C6                      mov r14, rax
  1812                                  
  1813 0000101F 4D31E4                      xor r12, r12  ; Índice del bloque actual
  1814                                  
  1815                                  .find_block_loop:
  1816 00001022 4D39F4                      cmp r12, r14
  1817 00001025 0F8DCE000000                jge .no_block_found  ; Se acabaron los bloques
  1818                                  
  1819                                      ; Calcular puntero base del bloque actual en levelX_blocks
  1820 0000102B 4C89E0                      mov rax, r12
  1821 0000102E 486BC005                    imul rax, 5            ; (x, y, tipo, durabilidad_inicial, letra)
  1822 00001032 4C01E8                      add rax, r13
  1823 00001035 4989C7                      mov r15, rax           ; r15 apunta a los datos del bloque actual
  1824                                  
  1825                                      ; --- Aquí la diferencia: la durabilidad no la leemos de [r15+3], sino de block_states[r12]
  1826 00001038 490FB69C24-                 movzx rbx, byte [block_states + r12]  ; Durabilidad "viva" en block_states
  1826 0000103D [D9140000]         
  1827 00001041 4885DB                      test rbx, rbx
  1828 00001044 0F84A7000000                jz .next_block  ; si durabilidad=0 => bloque destruido => ignorar
  1829                                  
  1830                                      ; Obtener coordenadas
  1831 0000104A 418A17                      mov dl, [r15]         ; x
  1832 0000104D 418A4F01                    mov cl, [r15 + 1]     ; y
  1833                                  
  1834                                      ; Calcular posición en el board
  1835 00001051 488D3D(000A0000)            lea rdi, [board]
  1836 00001058 4831C0                      xor rax, rax
  1837 0000105B B84E000000                  mov rax, column_cells
  1838 00001060 4883C002                    add rax, 2
  1839 00001064 480FB6C9                    movzx rcx, cl         ; y
  1840 00001068 480FAFC1                    imul rax, rcx
  1841 0000106C 4801C7                      add rdi, rax
  1842 0000106F 480FB6C2                    movzx rax, dl         ; x
  1843 00001073 4801C7                      add rdi, rax
  1844                                  
  1845                                      ; Guardar la posición base del bloque
  1846 00001076 57                          push rdi
  1847                                  
  1848                                      ; Verificar si la bola (r10) está dentro de [rdi .. rdi+block_length)
  1849 00001077 4939FA                      cmp r10, rdi
  1850 0000107A 7274                        jb .skip_collision
  1851 0000107C 488D5F06                    lea rbx, [rdi + block_length]
  1852 00001080 4939DA                      cmp r10, rbx
  1853 00001083 736B                        jae .skip_collision
  1854                                  
  1855                                      ; ------- Hay colisión, reducir durabilidad en block_states
  1856 00001085 41FE8C24[D9140000]          dec byte [block_states + r12]
  1857                                      ; Volver a cargar durabilidad
  1858 0000108D 490FB69C24-                 movzx rbx, byte [block_states + r12]
  1858 00001092 [D9140000]         
  1859 00001096 4885DB                      test rbx, rbx
  1860 00001099 754D                        jnz .update_display  ; si no llegó a 0 => solo "golpeado"
  1861                                  
  1862                                      ; >>> Llegó a 0 => Bloque destruido
  1863 0000109B 5F                          pop rdi  ; recuperar puntero base del bloque en board
  1864 0000109C B906000000                  mov rcx, block_length
  1865                                  .clear_loop:
  1866 000010A1 C60720                      mov byte [rdi], ' '
  1867 000010A4 48FFC7                      inc rdi
  1868 000010A7 E2F8                        loop .clear_loop
  1869                                  
  1870                                      ; Dibujar letra del bloque destruido
  1871 000010A9 418A4704                    mov al, [r15 + 4]  ; Obtener la letra asociada
  1872 000010AD 4883EF06                    sub rdi, block_length
  1873 000010B1 8807                        mov [rdi], al      ; Escribir la letra en la posición inicial
  1874                                      ; Después de escribir la letra en el tablero
  1875 000010B3 418A4704                    mov al, [r15 + 4]      ; Obtener la letra
  1876 000010B7 4D0FB607                    movzx r8, byte [r15]   ; Posición x del bloque
  1877 000010BB 4D0FB64F01                  movzx r9, byte [r15 + 1] ; Posición y del bloque
  1878 000010C0 E8E1F2FFFF                  call register_letter
  1879                                      ; Actualizar contadores globales
  1880 000010C5 FE0D(B5140000)              dec byte [blocks_remaining]
  1881 000010CB FE05(45150000)              inc byte [destroyed_blocks]
  1882                                  
  1883                                      ; Sumar puntos según el tipo
  1884 000010D1 490FB64702                  movzx rax, byte [r15 + 2]  ; tipo del bloque original
  1885 000010D6 486BC00A                    imul rax, 10
  1886 000010DA 480105(3D150000)            add [current_score], rax
  1887                                  
  1888 000010E1 B801000000                  mov rax, 1  ; colisión con destrucción
  1889 000010E6 EB14                        jmp .end_pop
  1890                                  
  1891                                  .update_display:
  1892                                      ; => durabilidad >0, se podría actualizar el "look" del bloque
  1893 000010E8 B801000000                  mov rax, 1  ; colisión con "rebote"  
  1894 000010ED 5F                          pop rdi     ; pop que quedó pendiente
  1895 000010EE EB0C                        jmp .end_pop
  1896                                  
  1897                                  .skip_collision:
  1898 000010F0 5F                          pop rdi     ; si no hubo colisión, quita de la pila
  1899                                  .next_block:
  1900 000010F1 49FFC4                      inc r12
  1901 000010F4 E929FFFFFF                  jmp .find_block_loop
  1902                                  
  1903                                  .no_block_found:
  1904 000010F9 4831C0                      xor rax, rax  ; 0 => no hubo colisión
  1905                                  
  1906                                  .end_pop:
  1907 000010FC 415F                        pop r15
  1908 000010FE 415E                        pop r14
  1909 00001100 415D                        pop r13
  1910 00001102 415C                        pop r12
  1911 00001104 5E                          pop rsi
  1912 00001105 5F                          pop rdi
  1913 00001106 5B                          pop rbx
  1914 00001107 5D                          pop rbp
  1915 00001108 C3                          ret
  1916                                  
  1917                                  
  1918                                  
  1919                                  init_enemies:
  1920 00001109 55                          push rbp
  1921 0000110A 4889E5                      mov rbp, rsp
  1922                                      ; Reiniciar contadores de movimiento
  1923 0000110D C605(88150000)00            mov byte [enemy_move_total], 0
  1924 00001114 C605(89150000)00            mov byte [enemy_target], 0 ; Inicialmente persigue la bola
  1925                                      ; Limpiar estado previo de enemigos
  1926 0000111B B90A000000                  mov rcx, 10 ; Máximo 10 enemigos
  1927 00001120 488D3D(5F150000)            lea rdi, [enemies]
  1928 00001127 30C0                        xor al, al
  1929 00001129 F3AA                        rep stosb ; Limpiar datos de enemigos
  1930                                      
  1931                                      ; Marcar todos los enemigos como inactivos
  1932 0000112B 488D3D(E8150000)            lea rdi, [enemy_spawns_triggered]
  1933 00001132 30C0                        xor al, al
  1934 00001134 B90A000000                  mov rcx, 10
  1935 00001139 F3AA                        rep stosb ; Todos los enemigos no han sido activados aún
  1936                                  
  1937 0000113B 5D                          pop rbp
  1938 0000113C C3                          ret
  1939                                  
  1940                                  
  1941                                  ; Función para mover enemigos
  1942                                  move_enemies:
  1943 0000113D 55                          push rbp
  1944 0000113E 4889E5                      mov rbp, rsp
  1945                                      
  1946                                      ; Incrementar contador de movimiento
  1947 00001141 FE05(86150000)              inc byte [enemy_move_counter]
  1948 00001147 480FB605(86150000)          movzx rax, byte [enemy_move_counter]
  1949 0000114F 3A05(87150000)              cmp al, [enemy_move_delay]
  1950 00001155 0F85AA010000                jne .end
  1951                                      
  1952                                      ; Resetear contador
  1953 0000115B C605(86150000)00            mov byte [enemy_move_counter], 0
  1954                                      
  1955 00001162 4D31E4                      xor r12, r12                    ; Índice del enemigo
  1956                                      
  1957                                      .enemy_loop:
  1958 00001165 4983FC0A                        cmp r12, 10                     ; Máximo 10 enemigos
  1959 00001169 0F8D96010000                    jge .end
  1960                                          
  1961                                          ; Calcular offset del enemigo actual
  1962 0000116F 4C89E0                          mov rax, r12
  1963 00001172 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  1964 00001176 488DB0[5F150000]                lea rsi, [enemies + rax]
  1965                                          
  1966                                          ; Verificar si el enemigo está activo
  1967 0000117D 807E0201                        cmp byte [rsi + 2], 1
  1968 00001181 0F8576010000                    jne .next_enemy
  1969                                          
  1970                                          ; Obtener posición actual
  1971 00001187 4C0FB606                        movzx r8, byte [rsi]            ; X
  1972 0000118B 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  1973                                          
  1974                                          ; Limpiar posición actual antes de mover
  1975 00001190 4150                            push r8
  1976 00001192 4151                            push r9
  1977 00001194 B84E000000                      mov rax, column_cells
  1978 00001199 4883C002                        add rax, 2
  1979 0000119D 49F7E1                          mul r9
  1980 000011A0 4C01C0                          add rax, r8
  1981 000011A3 488DB8[000A0000]                lea rdi, [board + rax]
  1982 000011AA C60720                          mov byte [rdi], ' '         ; Limpiar rastro
  1983 000011AD 4159                            pop r9
  1984 000011AF 4158                            pop r8
  1985                                  
  1986                                          ; Determinar comportamiento basado en índice
  1987 000011B1 4C89E0                          mov rax, r12
  1988 000011B4 4883E001                        and rax, 1                      ; 0 para índices pares, 1 para impares
  1989 000011B8 4885C0                          test rax, rax
  1990 000011BB 7402                            jz .chase_ball
  1991 000011BD EB31                            jmp .chase_paddle             ; Si es 1, perseguir paleta
  1992                                          
  1993                                          ; Perseguir bola (comportamiento original)
  1994                                      .chase_ball:
  1995 000011BF 4C8B15(5F140000)                mov r10, [ball_x_pos]
  1996 000011C6 4D39D0                          cmp r8, r10
  1997 000011C9 0F8F96000000                    jg .move_left
  1998 000011CF 0F8C95000000                    jl .move_right
  1999                                          
  2000 000011D5 4C8B15(67140000)                mov r10, [ball_y_pos]
  2001 000011DC 4D39D1                          cmp r9, r10
  2002 000011DF 0F8F8A000000                    jg .move_up
  2003 000011E5 0F8C89000000                    jl .move_down
  2004 000011EB E9A5000000                      jmp .check_collision
  2005                                          
  2006                                      .chase_paddle:
  2007                                          ; Obtener la posición X actual de la paleta
  2008 000011F0 4C8B15(3F140000)                mov r10, [pallet_position]
  2009 000011F7 4981EA[000A0000]                sub r10, board              ; Convertir a offset relativo
  2010                                          
  2011                                          ; Calcular la posición X real de la paleta
  2012 000011FE 4C89D0                          mov rax, r10
  2013 00001201 BB4E000000                      mov rbx, column_cells
  2014 00001206 4883C302                        add rbx, 2                  ; Añadir newline chars
  2015 0000120A 4831D2                          xor rdx, rdx
  2016 0000120D 48F7F3                          div rbx                     ; rax = y, rdx = x
  2017                                          
  2018                                          ; rdx ahora contiene la posición X de la paleta
  2019                                          ; Añadir la mitad del tamaño de la paleta para apuntar al centro
  2020 00001210 488B0D(47140000)                mov rcx, [pallet_size]
  2021 00001217 48D1E9                          shr rcx, 1                  ; Dividir por 2
  2022 0000121A 4801CA                          add rdx, rcx
  2023                                          
  2024                                          ; Comparar con posición X del enemigo y mover gradualmente
  2025 0000121D 4939D0                          cmp r8, rdx
  2026 00001220 7404                            je .check_y_paddle          ; Si está en la misma X, verificar Y
  2027 00001222 7F41                            jg .move_left              ; Si está a la derecha, mover izquierda
  2028 00001224 7C44                            jl .move_right             ; Si está a la izquierda, mover derecha
  2029                                  
  2030                                      .check_y_paddle:
  2031                                          ; La Y de la paleta siempre es row_cells - 2
  2032 00001226 41BA20000000                    mov r10, row_cells
  2033 0000122C 4983EA02                        sub r10, 2
  2034                                          
  2035                                          ; Comparar con posición Y del enemigo y mover gradualmente
  2036 00001230 4D39D1                          cmp r9, r10
  2037 00001233 7404                            je .no_movement            ; Si está en la misma Y, no mover
  2038 00001235 7F38                            jg .move_up               ; Si está abajo, mover arriba
  2039 00001237 7C3B                            jl .move_down             ; Si está arriba, mover abajo
  2040                                          
  2041                                      .no_movement:
  2042 00001239 EB5A                            jmp .check_collision
  2043                                  
  2044                                      ; También agregar una nueva sección para el movimiento suave
  2045                                      .smooth_transition:
  2046                                          ; Si el enemigo está muy lejos de su objetivo, limitar el movimiento
  2047 0000123B 8A05(89150000)                  mov al, [enemy_target]
  2048 00001241 84C0                            test al, al
  2049 00001243 7450                            jz .check_collision        ; Si persigue la bola, movimiento normal
  2050                                          
  2051                                          ; Verificar distancia en X
  2052 00001245 4989D2                          mov r10, rdx              ; Posición X objetivo
  2053 00001248 4D29C2                          sub r10, r8               ; Calcular diferencia
  2054 0000124B 4983FA05                        cmp r10, 5               ; Si la diferencia es mayor a 5
  2055 0000124F 7F08                            jg .limit_right_movement  ; Limitar movimiento a la derecha
  2056 00001251 4983FAFB                        cmp r10, -5              ; Si la diferencia es menor a -5
  2057 00001255 7C08                            jl .limit_left_movement   ; Limitar movimiento a la izquierda
  2058 00001257 EB3C                            jmp .check_collision
  2059                                          
  2060                                      .limit_right_movement:
  2061 00001259 4983C002                        add r8, 2                ; Mover solo 2 unidades a la derecha
  2062 0000125D EB36                            jmp .check_collision
  2063                                          
  2064                                      .limit_left_movement:
  2065 0000125F 4983E802                        sub r8, 2                ; Mover solo 2 unidades a la izquierda
  2066 00001263 EB30                            jmp .check_collision
  2067                                      .move_left:
  2068 00001265 49FFC8                          dec r8
  2069 00001268 EB0F                            jmp .check_vertical
  2070                                          
  2071                                      .move_right:
  2072 0000126A 49FFC0                          inc r8
  2073 0000126D EB0A                            jmp .check_vertical
  2074                                          
  2075                                      .move_up:
  2076 0000126F 49FFC9                          dec r9
  2077 00001272 EB21                            jmp .check_collision
  2078                                          
  2079                                      .move_down:
  2080 00001274 49FFC1                          inc r9
  2081 00001277 EB1C                            jmp .check_collision
  2082                                          
  2083                                      .check_vertical:
  2084 00001279 8A05(89150000)                  mov al, [enemy_target]
  2085 0000127F 84C0                            test al, al
  2086 00001281 0F8569FFFFFF                    jnz .chase_paddle         ; Si persigue paleta, volver a su lógica
  2087 00001287 4C8B15(67140000)                mov r10, [ball_y_pos]     ; Si no, seguir persiguiendo la bola
  2088 0000128E 4D39D1                          cmp r9, r10
  2089 00001291 7FDC                            jg .move_up
  2090 00001293 7CDF                            jl .move_down
  2091                                          
  2092                                      .check_collision:
  2093                                          ; Verificar colisión con bordes
  2094 00001295 4983F801                        cmp r8, 1                       ; Borde izquierdo
  2095 00001299 7E62                            jle .next_enemy
  2096 0000129B 4983F84E                        cmp r8, column_cells
  2097 0000129F 7D5C                            jge .next_enemy
  2098 000012A1 4983F901                        cmp r9, 1                       ; Borde superior
  2099 000012A5 7E56                            jle .next_enemy
  2100 000012A7 4983F920                        cmp r9, row_cells
  2101 000012AB 7D50                            jge .next_enemy
  2102                                          
  2103                                          ; Verificar colisión con bloques antes de moverse
  2104 000012AD 4150                            push r8
  2105 000012AF 4151                            push r9
  2106 000012B1 4152                            push r10
  2107                                          
  2108                                          ; Calcular posición en el tablero para verificar
  2109 000012B3 B84E000000                      mov rax, column_cells
  2110 000012B8 4883C002                        add rax, 2
  2111 000012BC 49F7E1                          mul r9
  2112 000012BF 4C01C0                          add rax, r8
  2113 000012C2 4C8D90[000A0000]                lea r10, [board + rax]
  2114                                          
  2115                                          ; Verificar si hay un bloque en la nueva posición
  2116 000012C9 418A02                          mov al, [r10]
  2117 000012CC 3C55                            cmp al, 'U'
  2118 000012CE 7427                            je .invalid_move
  2119 000012D0 3C4F                            cmp al, 'O'
  2120 000012D2 7423                            je .invalid_move
  2121 000012D4 3C44                            cmp al, 'D'
  2122 000012D6 741F                            je .invalid_move
  2123 000012D8 3C4C                            cmp al, 'L'
  2124 000012DA 741B                            je .invalid_move
  2125 000012DC 3C56                            cmp al, 'V'
  2126 000012DE 7417                            je .invalid_move
  2127 000012E0 3C38                            cmp al, '8'
  2128 000012E2 7413                            je .invalid_move
  2129 000012E4 3C58                            cmp al, 'X'
  2130 000012E6 740F                            je .invalid_move
  2131                                          
  2132 000012E8 415A                            pop r10
  2133 000012EA 4159                            pop r9
  2134 000012EC 4158                            pop r8
  2135                                          
  2136                                          ; Guardar nueva posición si es válida
  2137 000012EE 448806                          mov [rsi], r8b
  2138 000012F1 44884E01                        mov [rsi + 1], r9b
  2139 000012F5 EB06                            jmp .next_enemy
  2140                                          
  2141                                      .invalid_move:
  2142 000012F7 415A                            pop r10
  2143 000012F9 4159                            pop r9
  2144 000012FB 4158                            pop r8
  2145                                          
  2146                                      .next_enemy:
  2147 000012FD 49FFC4                          inc r12
  2148 00001300 E960FEFFFF                      jmp .enemy_loop
  2149                                          
  2150                                      .end:
  2151 00001305 5D                              pop rbp
  2152 00001306 C3                              ret
  2153                                  
  2154                                  get_current_spawn_points:
  2155 00001307 55                          push rbp
  2156 00001308 4889E5                      mov rbp, rsp
  2157                                      
  2158 0000130B 480FB605(B4140000)          movzx rax, byte [current_level]
  2159 00001313 48FFC8                      dec rax                         ; Ajustar para índice base 0
  2160 00001316 488B04C5[BD150000]          mov rax, [spawn_points_table + rax * 8]
  2161                                      
  2162 0000131E 5D                          pop rbp
  2163 0000131F C3                          ret
  2164                                  
  2165                                  ; Función para verificar si debe aparecer un nuevo enemigo
  2166                                  check_enemy_spawn:
  2167 00001320 55                          push rbp
  2168 00001321 4889E5                      mov rbp, rsp
  2169                                      
  2170                                      ; Obtener spawn points del nivel actual
  2171 00001324 E8DEFFFFFF                  call get_current_spawn_points
  2172 00001329 4989C4                      mov r12, rax                    ; r12 = puntero a spawn points
  2173                                      
  2174                                      ; Obtener cantidad de bloques destruidos
  2175 0000132C 4C0FB62D(45150000)          movzx r13, byte [destroyed_blocks]
  2176                                      
  2177                                      ; Verificar cada punto de spawn
  2178 00001334 4831C9                      xor rcx, rcx                    ; Índice del enemigo
  2179                                      
  2180                                      .check_loop:
  2181 00001337 4883F90A                        cmp rcx, 10                     ; Máximo 10 enemigos
  2182 0000133B 7D4B                            jge .end
  2183                                          
  2184                                          ; Verificar si este spawn point ya fue usado
  2185 0000133D 80B9[E8150000]01                cmp byte [enemy_spawns_triggered + rcx], 1
  2186 00001344 743D                            je .next_enemy
  2187                                          
  2188                                          ; Verificar si este enemigo ya está activo
  2189 00001346 4889C8                          mov rax, rcx
  2190 00001349 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2191 0000134D 488DB0[5F150000]                lea rsi, [enemies + rax]
  2192 00001354 807E0201                        cmp byte [rsi + 2], 1          ; Verificar si está activo
  2193 00001358 7429                            je .next_enemy
  2194                                          
  2195                                          ; Verificar si debemos spawnear este enemigo
  2196 0000135A 490FB6040C                      movzx rax, byte [r12 + rcx]    ; Obtener punto de spawn
  2197 0000135F 4939C5                          cmp r13, rax                   ; Comparar con bloques destruidos
  2198 00001362 751F                            jne .next_enemy
  2199                                          
  2200                                          ; Marcar este spawn point como usado
  2201 00001364 C681[E8150000]01                mov byte [enemy_spawns_triggered + rcx], 1
  2202                                          
  2203                                          ; Spawner nuevo enemigo
  2204 0000136B C60628                          mov byte [rsi], 40             ; X inicial
  2205 0000136E C6460102                        mov byte [rsi + 1], 2          ; Y inicial
  2206 00001372 C6460201                        mov byte [rsi + 2], 1          ; Activar enemigo
  2207                                          
  2208                                          ; Inicializar comportamiento
  2209 00001376 4889C8                          mov rax, rcx
  2210 00001379 4883E001                        and rax, 1                     ; Alternar comportamiento basado en índice par/impar
  2211 0000137D 8805(E7150000)                  mov [current_behavior], al      ; 0 = persigue bola, 1 = persigue paleta
  2212                                          
  2213                                      .next_enemy:
  2214 00001383 48FFC1                          inc rcx
  2215 00001386 EBAF                            jmp .check_loop
  2216                                          
  2217                                      .end:
  2218 00001388 5D                              pop rbp
  2219 00001389 C3                              ret
  2220                                  
  2221                                  
  2222                                  ; Función para dibujar enemigos
  2223                                  print_enemies:
  2224 0000138A 55                          push rbp
  2225 0000138B 4889E5                      mov rbp, rsp
  2226                                      
  2227 0000138E 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2228                                      
  2229                                      .print_loop:
  2230 00001391 4983FC0A                        cmp r12, 10                      ; Máximo 5 enemigos
  2231 00001395 7D4B                            jge .end
  2232                                          
  2233                                          ; Calcular offset del enemigo actual
  2234 00001397 4C89E0                          mov rax, r12
  2235 0000139A 486BC003                        imul rax, 3                     ; Cada enemigo ocupa 3 bytes
  2236 0000139E 488DB0[5F150000]                lea rsi, [enemies + rax]
  2237                                          
  2238                                          ; Verificar si el enemigo está activo
  2239 000013A5 807E0201                        cmp byte [rsi + 2], 1
  2240 000013A9 7532                            jne .next_enemy
  2241                                          
  2242                                          ; Calcular posición en el tablero
  2243 000013AB 4C0FB606                        movzx r8, byte [rsi]            ; X
  2244 000013AF 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y
  2245                                          
  2246                                          ; Calcular offset en el tablero
  2247 000013B4 B84E000000                      mov rax, column_cells
  2248 000013B9 4883C002                        add rax, 2                      ; Incluir caracteres de nueva línea
  2249 000013BD 49F7E1                          mul r9
  2250 000013C0 4C01C0                          add rax, r8
  2251 000013C3 488DB8[000A0000]                lea rdi, [board + rax]
  2252                                          
  2253                                          ; Obtener carácter del enemigo según el nivel
  2254 000013CA 480FB605(B4140000)              movzx rax, byte [current_level]
  2255 000013D2 48FFC8                          dec rax                         ; Ajustar para índice base 0
  2256 000013D5 8A80[5A150000]                  mov al, [enemy_chars + rax]
  2257                                          
  2258                                          ; Dibujar enemigo
  2259 000013DB 8807                            mov [rdi], al
  2260                                          
  2261                                      .next_enemy:
  2262 000013DD 49FFC4                          inc r12
  2263 000013E0 EBAF                            jmp .print_loop
  2264                                          
  2265                                      .end:
  2266 000013E2 5D                              pop rbp
  2267 000013E3 C3                              ret
  2268                                  
  2269                                  ; Función para verificar colisión con enemigos
  2270                                  ; Función para verificar colisión con enemigos
  2271                                  check_enemy_collision:
  2272 000013E4 55                          push rbp
  2273 000013E5 4889E5                      mov rbp, rsp
  2274                                      
  2275 000013E8 4D31E4                      xor r12, r12                    ; Índice del enemigo
  2276 000013EB 4831C0                      xor rax, rax                    ; Valor de retorno (0 = no colisión)
  2277                                      
  2278                                      .check_loop:
  2279 000013EE 4983FC05                        cmp r12, 5                      ; Máximo 5 enemigos
  2280 000013F2 0F8DE9000000                    jge .end
  2281                                          
  2282                                          ; Calcular offset del enemigo actual
  2283 000013F8 4C89E1                          mov rcx, r12
  2284 000013FB 486BC903                        imul rcx, 3                     ; Cada enemigo ocupa 3 bytes
  2285 000013FF 488DB1[5F150000]                lea rsi, [enemies + rcx]
  2286                                          
  2287                                          ; Verificar si el enemigo está activo
  2288 00001406 807E0201                        cmp byte [rsi + 2], 1
  2289 0000140A 0F85C9000000                    jne .next_enemy
  2290                                          
  2291                                          ; Verificar colisión con la bola
  2292 00001410 4C0FB606                        movzx r8, byte [rsi]            ; X enemigo
  2293 00001414 4C0FB64E01                      movzx r9, byte [rsi + 1]        ; Y enemigo
  2294                                          
  2295                                          ; Verificar si la bola está en el rango del enemigo (considerando el enemigo como un área)
  2296 00001419 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2297 00001420 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2298                                          
  2299                                          ; Comprobar colisión vertical (misma columna)
  2300 00001427 4D39C2                          cmp r10, r8
  2301 0000142A 7525                            jne .check_horizontal
  2302 0000142C 4D29CB                          sub r11, r9
  2303 0000142F 4983FB01                        cmp r11, 1
  2304 00001433 7F1C                            jg .check_horizontal
  2305 00001435 4983FBFF                        cmp r11, -1
  2306 00001439 7C16                            jl .check_horizontal
  2307                                          
  2308                                          ; Colisión vertical detectada
  2309 0000143B E8A3000000                      call destroy_enemy
  2310 00001440 48F71D(77140000)                neg qword [ball_direction_y]    ; Invertir dirección vertical
  2311 00001447 B801000000                      mov rax, 1
  2312 0000144C E990000000                      jmp .end
  2313                                          
  2314                                      .check_horizontal:
  2315                                          ; Comprobar colisión horizontal (misma fila)
  2316 00001451 4C8B15(5F140000)                mov r10, [ball_x_pos]
  2317 00001458 4C8B1D(67140000)                mov r11, [ball_y_pos]
  2318 0000145F 4D39CB                          cmp r11, r9
  2319 00001462 7522                            jne .check_paddle
  2320 00001464 4D29C2                          sub r10, r8
  2321 00001467 4983FA01                        cmp r10, 1
  2322 0000146B 7F19                            jg .check_paddle
  2323 0000146D 4983FAFF                        cmp r10, -1
  2324 00001471 7C13                            jl .check_paddle
  2325                                          
  2326                                          ; Colisión horizontal detectada
  2327 00001473 E86B000000                      call destroy_enemy
  2328 00001478 48F71D(6F140000)                neg qword [ball_direction_x]    ; Invertir dirección horizontal
  2329 0000147F B801000000                      mov rax, 1
  2330 00001484 EB5B                            jmp .end
  2331                                          
  2332                                      .check_paddle:
  2333                                          ; Verificar colisión con la paleta
  2334 00001486 4C8B15(3F140000)                mov r10, [pallet_position]
  2335 0000148D 4981EA[000A0000]                sub r10, board
  2336 00001494 4C89D0                          mov rax, r10
  2337 00001497 41BB4E000000                    mov r11, column_cells
  2338 0000149D 4983C302                        add r11, 2
  2339 000014A1 4831D2                          xor rdx, rdx
  2340 000014A4 49F7F3                          div r11                     ; División para obtener la posición Y
  2341 000014A7 4989D3                          mov r11, rdx               ; X de la paleta en r11
  2342                                          
  2343 000014AA 488B0D(47140000)                mov rcx, [pallet_size]     ; Obtener el tamaño de la paleta
  2344                                          
  2345                                          ; Verificar si el enemigo está en la misma fila que la paleta
  2346 000014B1 41BD20000000                    mov r13, row_cells
  2347 000014B7 4983ED02                        sub r13, 2                 ; Y de la paleta
  2348 000014BB 4D39E9                          cmp r9, r13               ; Comparar Y del enemigo con Y de la paleta
  2349 000014BE 7519                            jne .next_enemy
  2350                                          
  2351                                          ; Verificar si el enemigo está dentro del rango X de la paleta
  2352 000014C0 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X inicial de la paleta
  2353 000014C3 7C14                            jl .next_enemy
  2354                                          
  2355 000014C5 4901CB                          add r11, rcx              ; Añadir el tamaño de la paleta
  2356 000014C8 4D39D8                          cmp r8, r11               ; Comparar X del enemigo con X final de la paleta
  2357 000014CB 7F0C                            jg .next_enemy
  2358                                          
  2359                                          ; Si llegamos aquí, hay colisión con la paleta
  2360 000014CD E811000000                      call destroy_enemy        ; Destruir el enemigo
  2361 000014D2 B801000000                      mov rax, 1                ; Indicar que hubo colisión
  2362 000014D7 EB08                            jmp .end
  2363                                          
  2364                                      .next_enemy:
  2365 000014D9 49FFC4                          inc r12
  2366 000014DC E90DFFFFFF                      jmp .check_loop
  2367                                          
  2368                                      .end:
  2369 000014E1 5D                              pop rbp
  2370 000014E2 C3                              ret
  2371                                  
  2372                                  ; Función para destruir un enemigo
  2373                                  destroy_enemy:
  2374                                      ; Desactivar enemigo
  2375 000014E3 C6460200                    mov byte [rsi + 2], 0   ; Marcar enemigo como inactivo
  2376                                  
  2377                                      ; Sumar puntos por destruir enemigo
  2378 000014E7 488B05(7E150000)            mov rax, [enemy_points]
  2379 000014EE 480105(3D150000)            add [current_score], rax
  2380                                  
  2381                                      ; No tocar bloques destruidos aquí
  2382 000014F5 C3                          ret
  2383                                  
  2384                                  
  2385                                  _start:
  2386 000014F6 E830ECFFFF              	call canonical_off
  2387 000014FB E804010000              	call start_screen
  2388 00001500 E8B9F5FFFF                  call init_level
  2389 00001505 E8FFFBFFFF                  call init_enemies
  2390 0000150A EB00                    	jmp .main_loop
  2391                                  	
  2392                                  
  2393                                  	.main_loop:
  2394 0000150C E8B6F9FFFF                      call print_labels
  2395 00001511 E8E5F8FFFF                      call print_blocks
  2396 00001516 E85CEFFFFF                      call move_letters
  2397 0000151B E8CCEEFFFF                      call print_letters
  2398 00001520 E879F1FFFF              		call print_pallet
  2399 00001525 E8CDF2FFFF                      call move_ball
  2400 0000152A E8AFEDFFFF                      call check_bottom_collision
  2401 0000152F E8A9ECFFFF                      call print_lives
  2402 00001534 E824F7FFFF                      call check_level_complete
  2403 00001539 E8E2FDFFFF                      call check_enemy_spawn
  2404 0000153E E8FAFBFFFF                      call move_enemies
  2405 00001543 E89CFEFFFF                      call check_enemy_collision
  2406 00001548 E83DFEFFFF                      call print_enemies
  2407 0000154D E824F1FFFF              		call print_ball
  2408                                  		print board, board_size				
    82 00001552 B801000000          <1>  mov eax, sys_write
    83 00001557 BF01000000          <1>  mov edi, 1
    84 0000155C 48BE-               <1>  mov rsi, %1
    84 0000155E [000A000000000000]  <1>
    85 00001566 BA000A0000          <1>  mov edx, %2
    86 0000156B 0F05                <1>  syscall
  2409                                  		;setnonblocking	
  2410                                  	.read_more:	
  2411                                  	    getchar	
    90 0000156D B800000000          <1>  mov rax, sys_read
    91 00001572 BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001577 48BE-               <1>  mov rsi, input_char
    92 00001579 [0000000000000000]  <1>
    93 00001581 BA01000000          <1>  mov rdx, 1
    94 00001586 0F05                <1>  syscall
  2412 00001588 4883F801                	    cmp rax, 1
  2413 0000158C 7543                    	    jne .done
  2414                                  	
  2415 0000158E 8A05(00000000)          	    mov al, [input_char]
  2416 00001594 8805(04180000)          	    mov [last_key], al      ; Registrar la última tecla presionada
  2417                                  	
  2418 0000159A 3C61                    	    cmp al, 'a'
  2419 0000159C 750E                    	    jne .not_left
  2420 0000159E 48C7C7FFFFFFFF          	    mov rdi, left_direction
  2421 000015A5 E829F1FFFF              	    call move_pallet
  2422 000015AA EB25                    	    jmp .done
  2423                                  	
  2424                                      .not_left:
  2425 000015AC 3C64                    	    cmp al, 'd'
  2426 000015AE 750C                    	    jne .not_right
  2427 000015B0 BF01000000              	    mov rdi, right_direction
  2428 000015B5 E819F1FFFF              	    call move_pallet
  2429 000015BA EB15                    	    jmp .done
  2430                                  	
  2431                                      .not_right:
  2432 000015BC 3C63                    	    cmp al, 'c'             ; Verificar si se presionó la tecla 'c'
  2433 000015BE 740A                    	    je .release_ball        ; Si sí, liberar la bola
  2434                                  	
  2435 000015C0 3C71                    	    cmp al, 'q' 
  2436 000015C2 0F84AF000000            	    je exit
  2437 000015C8 EBA3                    	    jmp .read_more
  2438                                  	
  2439                                      .release_ball:
  2440 000015CA E8FBF3FFFF              	    call process_catch_release
  2441 000015CF EB00                    	    jmp .done
  2442                                  	
  2443                                      .done:
  2444                                  	    sleeptime
    98 000015D1 B823000000          <1>  mov eax, sys_nanosleep
    99 000015D6 48BF-               <1>  mov rdi, timespec
    99 000015D8 [0000000000000000]  <1>
   100 000015E0 31F6                <1>  xor esi, esi
   101 000015E2 0F05                <1>  syscall
  2445                                  	    print clear, clear_length
    82 000015E4 B801000000          <1>  mov eax, sys_write
    83 000015E9 BF01000000          <1>  mov edi, 1
    84 000015EE 48BE-               <1>  mov rsi, %1
    84 000015F0 [1000000000000000]  <1>
    85 000015F8 BA07000000          <1>  mov edx, %2
    86 000015FD 0F05                <1>  syscall
  2446 000015FF E908FFFFFF              	    jmp .main_loop
  2447                                  
  2448                                  
  2449                                  
  2450                                  
  2451                                  start_screen:
  2452                                      print clear, clear_length    ; Limpiamos la pantalla primero
    82 00001604 B801000000          <1>  mov eax, sys_write
    83 00001609 BF01000000          <1>  mov edi, 1
    84 0000160E 48BE-               <1>  mov rsi, %1
    84 00001610 [1000000000000000]  <1>
    85 00001618 BA07000000          <1>  mov edx, %2
    86 0000161D 0F05                <1>  syscall
  2453                                      print msg1, msg1_length
    82 0000161F B801000000          <1>  mov eax, sys_write
    83 00001624 BF01000000          <1>  mov edi, 1
    84 00001629 48BE-               <1>  mov rsi, %1
    84 0000162B [1700000000000000]  <1>
    85 00001633 BA14010000          <1>  mov edx, %2
    86 00001638 0F05                <1>  syscall
  2454                                      
  2455                                      .wait_for_key:              ; Agregamos una etiqueta para esperar la tecla
  2456                                          getchar                 ; Esperamos una tecla
    90 0000163A B800000000          <1>  mov rax, sys_read
    91 0000163F BF00000000          <1>  mov rdi, STDIN_FILENO
    92 00001644 48BE-               <1>  mov rsi, input_char
    92 00001646 [0000000000000000]  <1>
    93 0000164E BA01000000          <1>  mov rdx, 1
    94 00001653 0F05                <1>  syscall
  2457 00001655 4883F801                        cmp rax, 1             ; Verificamos si se leyó un carácter
  2458 00001659 75DF                            jne .wait_for_key      ; Si no se leyó, seguimos esperando
  2459                                          
  2460                                      print clear, clear_length   ; Limpiamos la pantalla antes de salir
    82 0000165B B801000000          <1>  mov eax, sys_write
    83 00001660 BF01000000          <1>  mov edi, 1
    84 00001665 48BE-               <1>  mov rsi, %1
    84 00001667 [1000000000000000]  <1>
    85 0000166F BA07000000          <1>  mov edx, %2
    86 00001674 0F05                <1>  syscall
  2461 00001676 C3                          ret
  2462                                  
  2463                                  exit: 
  2464 00001677 E8F1EAFFFF              	call canonical_on
  2465 0000167C B83C000000              	mov    rax, 60
  2466 00001681 BF00000000                  mov    rdi, 0
  2467 00001686 0F05                        syscall
  2468                                  
